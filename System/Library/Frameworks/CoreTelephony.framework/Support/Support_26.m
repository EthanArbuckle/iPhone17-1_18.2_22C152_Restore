void sub_100E2624C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  NSObject *v6;
  int v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t *v12;
  char *WirelessUserDirectory;
  xpc_object_t v14;
  xpc_object_t object;
  void (**v16)(FileSystemInterface *__hidden);
  unsigned char buf[18];
  __int16 v18;
  char *v19;

  sub_100E29D94();
  v6 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I  ## server_SettingsModelEraseCommCentersPreferences", buf, 2u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12C40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12C40))
  {
    WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
    sub_100058DB0(buf, WirelessUserDirectory);
    sub_10055B020("/Library/Preferences/com.apple.commcenter.plist", (std::string *)buf, (std::string *)&qword_101B12C58);
    if (SBYTE3(v19) < 0) {
      operator delete(*(void **)buf);
    }
    __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B12C58, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B12C40);
  }
  v16 = &off_101A0BD40;
  if (sub_1007ECCD4((uint64_t)&v16, &qword_101B12C58))
  {
    v7 = sub_1007ED7D4((uint64_t)&v16, &qword_101B12C58);
    if (v7)
    {
      v14 = xpc_int64_create(5);
      if (!v14) {
        v14 = xpc_null_create();
      }
      *(void *)buf = *a5;
      *(void *)&buf[8] = "kMachError";
      sub_100035E70((uint64_t)buf, &v14, &object);
      xpc_release(object);
      object = 0;
      xpc_release(v14);
      v14 = 0;
      sub_100E29D94();
      v8 = qword_101B12C30;
      if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_ERROR))
      {
        v9 = byte_101B12C6F;
        v10 = qword_101B12C58;
        v11 = strerror(v7);
        if (v9 >= 0) {
          v12 = &qword_101B12C58;
        }
        else {
          v12 = (uint64_t *)v10;
        }
        *(_DWORD *)buf = 136315650;
        *(void *)&buf[4] = v12;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v7;
        v18 = 2080;
        v19 = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to delete %s, returned error code %d: %s", buf, 0x1Cu);
      }
    }
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v16);
}

void sub_100E264A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  __cxa_guard_abort(&qword_101B12C40);
  _Unwind_Resume(a1);
}

void sub_100E2650C(Registry **a1@<X0>, void *a2@<X3>, void *a3@<X4>, uint64_t *a4@<X8>)
{
  void (***v36)(xpc_object_t *__return_ptr, void, void **);
  uint64_t *v37;
  std::mutex *v38;
  std::mutex *v39;
  uint64_t v40;
  unsigned __int8 *v41;
  uint64_t v42;
  unsigned int v43;
  void *v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  char v47;
  unsigned int *v48;
  NSObject *v49;
  NSObject *v50;
  std::__shared_weak_count *v51;
  NSObject *v52;
  CFStringRef v53;
  void *v54;
  std::__shared_weak_count *v55;
  char v56;
  const char *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  xpc_object_t v60;
  xpc_object_t v61;
  xpc_object_t object;
  std::__shared_weak_count *v63;
  void *__p;
  const char *v65;
  uint64_t v66;
  xpc_object_t v67;
  xpc_object_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  xpc_object_t v72;
  xpc_object_t v73;
  uint8_t buf[8];
  const char *v75;
  uint64_t (*v76)(void);

  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a1);
  v8 = ServiceMap;
  if (v9 < 0)
  {
    v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v9;
  v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
LABEL_13:
      v69 = 0;
      v70 = 0;
      v71 = 0;
      __p = a2;
      v65 = "kSettingsModelEraseWhat";
      sub_100048BAC((uint64_t)&__p, &object);
      *(void *)buf = 0;
      v75 = 0;
      v76 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v76) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_release(object);
      if (v71 >= 0) {
        v17 = (const char *)&v69;
      }
      else {
        v17 = (const char *)v69;
      }
      CFStringRef v18 = CFStringCreateWithCStringNoCopy(0, v17, 0x8000100u, kCFAllocatorNull);
      CFStringRef v19 = v18;
      if (!v18) {
        goto LABEL_26;
      }
      uint64_t v20 = HIBYTE(v71);
      if (v71 < 0) {
        uint64_t v20 = v70;
      }
      if (v20)
      {
        if (CFEqual(v18, @"kCTBasebandSettingsEraseSFP"))
        {
          sub_100E29D94();
          v21 = qword_101B12C30;
          if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Initiating SFP erasure of baseband settings", buf, 2u);
          }
          uint64_t v22 = 6;
LABEL_83:
          CFRelease(v19);
          v51 = (std::__shared_weak_count *)a3[1];
          v58 = *a3;
          v59 = v51;
          if (v51) {
            atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v15 + 184))(v15, v22, &v58);
          if (v59) {
            sub_10004D2C8(v59);
          }
          goto LABEL_87;
        }
        if (CFEqual(v19, @"kCTBasebandSettingsEraseEFS"))
        {
          v53 = v19;
          v54 = a3;
          v56 = v16;
          v55 = v14;
          subscriber::makeSimSlotRange();
          v24 = *(const char **)buf;
          v23 = (unsigned int *)v75;
          if (*(const char **)buf == v75) {
            goto LABEL_76;
          }
          v25 = v76;
          while ((v25(*(unsigned int *)v24) & 1) == 0)
          {
            v24 += 4;
            if (v24 == (const char *)v23)
            {
              v24 = (const char *)v23;
              break;
            }
          }
          v26 = (unsigned int *)v75;
          if (v24 == v75)
          {
LABEL_76:
            sub_100E29D94();
            v49 = qword_101B12C30;
            a3 = v54;
            v14 = v55;
            char v16 = v56;
            CFStringRef v19 = v53;
            if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Initiating EFS erasure of baseband settings", buf, 2u);
            }
            uint64_t v22 = 1;
            goto LABEL_83;
          }
          v57 = v75;
          while (1)
          {
            sub_100A6D454();
            __p = 0;
            v65 = 0;
            v66 = 0;
            PersonalityIdFromSlotId();
            v27 = (uint64_t *)HIBYTE(v66);
            if (v66 < 0) {
              v27 = (uint64_t *)v65;
            }
            if (!v27) {
              goto LABEL_68;
            }
            v28 = (std::mutex *)Registry::getServiceMap(v27, *a1);
            v29 = v28;
            if (v30 < 0)
            {
              v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v32 = 5381;
              do
              {
                uint64_t v30 = v32;
                unsigned int v33 = *v31++;
                uint64_t v32 = (33 * v32) ^ v33;
              }
              while (v33);
            }
            std::mutex::lock(v28);
            object = (xpc_object_t)v30;
            v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&object);
            if (!v34)
            {
              std::mutex::unlock(v29);
              goto LABEL_56;
            }
            v36 = (void (***)(xpc_object_t *__return_ptr, void, void **))v34[3];
            v35 = (std::__shared_weak_count *)v34[4];
            if (v35)
            {
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v29);
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
              v26 = (unsigned int *)v57;
              sub_10004D2C8(v35);
              if (!v36) {
                goto LABEL_55;
              }
            }
            else
            {
              std::mutex::unlock(v29);
              if (!v36) {
                goto LABEL_56;
              }
            }
            object = 0;
            v63 = 0;
            (**v36)(&object, v36, &__p);
            if (object)
            {
              (*(void (**)(xpc_object_t, const char *))(*(void *)object + 552))(object, "CSIM reset via kSettingsModelEraseBasebandSettings");
              (*(void (**)(xpc_object_t, uint64_t))(*(void *)object + 376))(object, 1);
            }
            if (v63) {
              sub_10004D2C8(v63);
            }
            if (v35) {
LABEL_55:
            }
              sub_10004D2C8(v35);
LABEL_56:
            v38 = (std::mutex *)Registry::getServiceMap(v37, *a1);
            v39 = v38;
            if (v40 < 0)
            {
              v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
              v42 = 5381;
              do
              {
                v40 = v42;
                v43 = *v41++;
                v42 = (33 * v42) ^ v43;
              }
              while (v43);
            }
            std::mutex::lock(v38);
            object = (xpc_object_t)v40;
            v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)&object);
            if (!v44)
            {
              v46 = 0;
LABEL_64:
              std::mutex::unlock(v39);
              v45 = 0;
              v47 = 1;
              if (!v46) {
                goto LABEL_66;
              }
LABEL_65:
              (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v46 + 32))(v46, &__p, 1);
              (*(void (**)(uint64_t, void **, void))(*(void *)v46 + 40))(v46, &__p, 0);
              goto LABEL_66;
            }
            v46 = v44[3];
            v45 = (std::__shared_weak_count *)v44[4];
            if (!v45) {
              goto LABEL_64;
            }
            atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v39);
            atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
            v26 = (unsigned int *)v57;
            sub_10004D2C8(v45);
            v47 = 0;
            if (v46) {
              goto LABEL_65;
            }
LABEL_66:
            if ((v47 & 1) == 0) {
              sub_10004D2C8(v45);
            }
LABEL_68:
            if (SHIBYTE(v66) < 0) {
              operator delete(__p);
            }
            v48 = (unsigned int *)(v24 + 4);
            v24 = (const char *)v23;
            if (v48 != v23)
            {
              v24 = (const char *)v48;
              while ((v25(*(unsigned int *)v24) & 1) == 0)
              {
                v24 += 4;
                if (v24 == (const char *)v23)
                {
                  v24 = (const char *)v23;
                  break;
                }
              }
            }
            if (v24 == (const char *)v26) {
              goto LABEL_76;
            }
          }
        }
        if (CFEqual(v19, @"kCTBasebandSettingsEraseEverything"))
        {
          sub_100E29D94();
          v50 = qword_101B12C30;
          if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Initiating erasure of all baseband settings", buf, 2u);
          }
          uint64_t v22 = 7;
          goto LABEL_83;
        }
        sub_100E29D94();
        v52 = qword_101B12C30;
        if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Invalid erase string; canceling request",
            buf,
            2u);
        }
        CFRelease(v19);
        v60 = xpc_int64_create(4);
        if (!v60) {
          v60 = xpc_null_create();
        }
        *(void *)buf = *a3;
        v75 = "kMachError";
        sub_100035E70((uint64_t)buf, &v60, &v61);
        xpc_release(v61);
        v61 = 0;
        xpc_release(v60);
        v60 = 0;
      }
      else
      {
LABEL_26:
        v67 = xpc_int64_create(5);
        if (!v67) {
          v67 = xpc_null_create();
        }
        *(void *)buf = *a3;
        v75 = "kSettingsModelError";
        sub_100035E70((uint64_t)buf, &v67, &v68);
        xpc_release(v68);
        v68 = 0;
        xpc_release(v67);
        v67 = 0;
        if (v19) {
          CFRelease(v19);
        }
      }
LABEL_87:
      if (SHIBYTE(v71) < 0)
      {
        operator delete(v69);
        if (v16) {
          return;
        }
      }
      else if (v16)
      {
        return;
      }
LABEL_89:
      sub_10004D2C8(v14);
      return;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_13;
  }
LABEL_7:
  v72 = xpc_int64_create(45);
  if (!v72) {
    v72 = xpc_null_create();
  }
  *(void *)buf = *a3;
  v75 = "kPosixError";
  sub_100035E70((uint64_t)buf, &v72, &v73);
  xpc_release(v73);
  v73 = 0;
  xpc_release(v72);
  v72 = 0;
  if ((v16 & 1) == 0) {
    goto LABEL_89;
  }
}

void sub_100E26D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E26E38(Registry **a1@<X0>, void *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v6;
  v10 = sub_10004D37C(&v5[1].__m_.__sig, &v17);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_14;
  }
LABEL_10:
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  v15[2] = sub_100E2A3C8;
  v15[3] = &unk_101A5F7B8;
  v14 = (std::__shared_weak_count *)a2[1];
  v15[4] = *a2;
  char v16 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v12 + 128))(v12, v15);
  if (v16) {
    sub_10004D2C8(v16);
  }
LABEL_14:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E26FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E26FD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7 = dispatch_group_create();
  sub_100E29D94();
  uint64_t v8 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in PersonalityShop", (uint8_t *)group, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)a1);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  group[0] = (dispatch_group_t)v12;
  char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)group);
  if (v16)
  {
    uint64_t v18 = v16[3];
    unint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_18;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  unint64_t v17 = 0;
  char v19 = 1;
  if (!v18) {
    goto LABEL_18;
  }
LABEL_12:
  group[0] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    if (group[0]) {
      dispatch_group_enter(group[0]);
    }
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v18 + 328))(v18, group);
  if (group[0])
  {
    dispatch_group_leave(group[0]);
    if (group[0]) {
      dispatch_release(group[0]);
    }
  }
LABEL_18:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  sub_100E29D94();
  uint64_t v20 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in Max Data Rate Manager", (uint8_t *)group, 2u);
  }
  uint64_t v22 = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)a1);
  v23 = v22;
  if (v24 < 0)
  {
    v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(v22);
  group[0] = (dispatch_group_t)v24;
  v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)group);
  if (v28)
  {
    uint64_t v30 = v28[3];
    v29 = (std::__shared_weak_count *)v28[4];
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      char v31 = 0;
      if (!v30) {
        goto LABEL_37;
      }
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
  std::mutex::unlock(v23);
  v29 = 0;
  char v31 = 1;
  if (!v30) {
    goto LABEL_37;
  }
LABEL_31:
  dispatch_object_t v164 = v7;
  if (v7)
  {
    dispatch_retain(v7);
    if (v164) {
      dispatch_group_enter(v164);
    }
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v30 + 40))(v30, &v164);
  if (v164)
  {
    dispatch_group_leave(v164);
    if (v164) {
      dispatch_release(v164);
    }
  }
LABEL_37:
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  sub_100E29D94();
  uint64_t v32 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in CDMA Roaming Handler", (uint8_t *)group, 2u);
  }
  v34 = (std::mutex *)Registry::getServiceMap(v33, *(Registry **)a1);
  v35 = v34;
  if (v36 < 0)
  {
    v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v38 = 5381;
    do
    {
      uint64_t v36 = v38;
      unsigned int v39 = *v37++;
      uint64_t v38 = (33 * v38) ^ v39;
    }
    while (v39);
  }
  std::mutex::lock(v34);
  group[0] = (dispatch_group_t)v36;
  v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)group);
  if (v40)
  {
    uint64_t v42 = v40[3];
    v41 = (std::__shared_weak_count *)v40[4];
    if (v41)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v35);
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v41);
      char v43 = 0;
      if (!v42) {
        goto LABEL_56;
      }
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v42 = 0;
  }
  std::mutex::unlock(v35);
  v41 = 0;
  char v43 = 1;
  if (!v42) {
    goto LABEL_56;
  }
LABEL_50:
  dispatch_object_t v163 = v7;
  if (v7)
  {
    dispatch_retain(v7);
    if (v163) {
      dispatch_group_enter(v163);
    }
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v42 + 56))(v42, &v163);
  if (v163)
  {
    dispatch_group_leave(v163);
    if (v163) {
      dispatch_release(v163);
    }
  }
LABEL_56:
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v41);
  }
  sub_100E29D94();
  v44 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in Roaming Handler", (uint8_t *)group, 2u);
  }
  v46 = (std::mutex *)Registry::getServiceMap(v45, *(Registry **)a1);
  v47 = v46;
  if (v48 < 0)
  {
    v49 = (unsigned __int8 *)(v48 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v50 = 5381;
    do
    {
      uint64_t v48 = v50;
      unsigned int v51 = *v49++;
      uint64_t v50 = (33 * v50) ^ v51;
    }
    while (v51);
  }
  std::mutex::lock(v46);
  group[0] = (dispatch_group_t)v48;
  v52 = sub_10004D37C(&v47[1].__m_.__sig, (unint64_t *)group);
  if (v52)
  {
    uint64_t v54 = v52[3];
    v53 = (std::__shared_weak_count *)v52[4];
    if (v53)
    {
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v47);
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v53);
      char v55 = 0;
LABEL_68:
      dispatch_group_t object = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (object) {
          dispatch_group_enter(object);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v54 + 64))(v54, &object);
      if (object)
      {
        dispatch_group_leave(object);
        if (object) {
          dispatch_release(object);
        }
      }
      if ((v55 & 1) == 0) {
        sub_10004D2C8(v53);
      }
      v57 = (std::mutex *)Registry::getServiceMap(v56, *(Registry **)a1);
      v58 = v57;
      if (v59 < 0)
      {
        v60 = (unsigned __int8 *)(v59 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v61 = 5381;
        do
        {
          uint64_t v59 = v61;
          unsigned int v62 = *v60++;
          uint64_t v61 = (33 * v61) ^ v62;
        }
        while (v62);
      }
      std::mutex::lock(v57);
      group[0] = (dispatch_group_t)v59;
      v63 = sub_10004D37C(&v58[1].__m_.__sig, (unint64_t *)group);
      if (v63)
      {
        uint64_t v65 = v63[3];
        v64 = (std::__shared_weak_count *)v63[4];
        if (v64)
        {
          atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v58);
          atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v64);
          char v67 = 0;
          if (!v65) {
            goto LABEL_93;
          }
          goto LABEL_85;
        }
      }
      else
      {
        uint64_t v65 = 0;
      }
      std::mutex::unlock(v58);
      v64 = 0;
      char v67 = 1;
      if (!v65) {
        goto LABEL_93;
      }
LABEL_85:
      sub_100E29D94();
      v68 = qword_101B12C30;
      if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(group[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in Registration", (uint8_t *)group, 2u);
      }
      dispatch_group_t v161 = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (v161) {
          dispatch_group_enter(v161);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v65 + 400))(v65, &v161);
      if (v161)
      {
        dispatch_group_leave(v161);
        if (v161) {
          dispatch_release(v161);
        }
      }
LABEL_93:
      if ((v67 & 1) == 0) {
        sub_10004D2C8(v64);
      }
      v69 = (std::mutex *)Registry::getServiceMap(v66, *(Registry **)a1);
      v70 = v69;
      if (v71 < 0)
      {
        v72 = (unsigned __int8 *)(v71 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v73 = 5381;
        do
        {
          uint64_t v71 = v73;
          unsigned int v74 = *v72++;
          uint64_t v73 = (33 * v73) ^ v74;
        }
        while (v74);
      }
      std::mutex::lock(v69);
      group[0] = (dispatch_group_t)v71;
      v75 = sub_10004D37C(&v70[1].__m_.__sig, (unint64_t *)group);
      if (v75)
      {
        uint64_t v77 = v75[3];
        v76 = (std::__shared_weak_count *)v75[4];
        if (v76)
        {
          atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v70);
          atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v76);
          char v79 = 0;
          if (!v77) {
            goto LABEL_112;
          }
          goto LABEL_104;
        }
      }
      else
      {
        uint64_t v77 = 0;
      }
      std::mutex::unlock(v70);
      v76 = 0;
      char v79 = 1;
      if (!v77) {
        goto LABEL_112;
      }
LABEL_104:
      sub_100E29D94();
      v80 = qword_101B12C30;
      if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(group[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in Settings Controller", (uint8_t *)group, 2u);
      }
      dispatch_group_t v160 = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (v160) {
          dispatch_group_enter(v160);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v77 + 176))(v77, &v160);
      if (v160)
      {
        dispatch_group_leave(v160);
        if (v160) {
          dispatch_release(v160);
        }
      }
LABEL_112:
      if ((v79 & 1) == 0) {
        sub_10004D2C8(v76);
      }
      v81 = (std::mutex *)Registry::getServiceMap(v78, *(Registry **)a1);
      v82 = v81;
      if (v83 < 0)
      {
        v84 = (unsigned __int8 *)(v83 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v85 = 5381;
        do
        {
          uint64_t v83 = v85;
          unsigned int v86 = *v84++;
          uint64_t v85 = (33 * v85) ^ v86;
        }
        while (v86);
      }
      std::mutex::lock(v81);
      group[0] = (dispatch_group_t)v83;
      v87 = sub_10004D37C(&v82[1].__m_.__sig, (unint64_t *)group);
      if (v87)
      {
        uint64_t v89 = v87[3];
        v88 = (std::__shared_weak_count *)v87[4];
        if (v88)
        {
          atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v82);
          atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v88);
          char v91 = 0;
          if (!v89) {
            goto LABEL_127;
          }
          goto LABEL_123;
        }
      }
      else
      {
        uint64_t v89 = 0;
      }
      std::mutex::unlock(v82);
      v88 = 0;
      char v91 = 1;
      if (!v89) {
        goto LABEL_127;
      }
LABEL_123:
      dispatch_object_t v159 = v7;
      if (v7) {
        dispatch_retain(v7);
      }
      (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v89 + 248))(v89, &v159);
      if (v159) {
        dispatch_release(v159);
      }
LABEL_127:
      if ((v91 & 1) == 0) {
        sub_10004D2C8(v88);
      }
      v92 = (std::mutex *)Registry::getServiceMap(v90, *(Registry **)a1);
      v93 = v92;
      if (v94 < 0)
      {
        v95 = (unsigned __int8 *)(v94 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v96 = 5381;
        do
        {
          uint64_t v94 = v96;
          unsigned int v97 = *v95++;
          uint64_t v96 = (33 * v96) ^ v97;
        }
        while (v97);
      }
      std::mutex::lock(v92);
      group[0] = (dispatch_group_t)v94;
      v98 = sub_10004D37C(&v93[1].__m_.__sig, (unint64_t *)group);
      if (v98)
      {
        uint64_t v100 = v98[3];
        v99 = (std::__shared_weak_count *)v98[4];
        if (v99)
        {
          atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v93);
          atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v99);
          char v102 = 0;
          if (!v100) {
            goto LABEL_146;
          }
          goto LABEL_138;
        }
      }
      else
      {
        uint64_t v100 = 0;
      }
      std::mutex::unlock(v93);
      v99 = 0;
      char v102 = 1;
      if (!v100) {
        goto LABEL_146;
      }
LABEL_138:
      sub_100E29D94();
      v103 = qword_101B12C30;
      if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(group[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in Save Data Mode Controller", (uint8_t *)group, 2u);
      }
      dispatch_group_t v158 = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (v158) {
          dispatch_group_enter(v158);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v100 + 96))(v100, &v158);
      if (v158)
      {
        dispatch_group_leave(v158);
        if (v158) {
          dispatch_release(v158);
        }
      }
LABEL_146:
      if ((v102 & 1) == 0) {
        sub_10004D2C8(v99);
      }
      v104 = (std::mutex *)Registry::getServiceMap(v101, *(Registry **)a1);
      v105 = v104;
      if (v106 < 0)
      {
        v107 = (unsigned __int8 *)(v106 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v108 = 5381;
        do
        {
          uint64_t v106 = v108;
          unsigned int v109 = *v107++;
          uint64_t v108 = (33 * v108) ^ v109;
        }
        while (v109);
      }
      std::mutex::lock(v104);
      group[0] = (dispatch_group_t)v106;
      v110 = sub_10004D37C(&v105[1].__m_.__sig, (unint64_t *)group);
      if (v110)
      {
        uint64_t v112 = v110[3];
        v111 = (std::__shared_weak_count *)v110[4];
        if (v111)
        {
          atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v105);
          atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v111);
          char v114 = 0;
          if (!v112) {
            goto LABEL_163;
          }
          goto LABEL_157;
        }
      }
      else
      {
        uint64_t v112 = 0;
      }
      std::mutex::unlock(v105);
      v111 = 0;
      char v114 = 1;
      if (!v112) {
        goto LABEL_163;
      }
LABEL_157:
      dispatch_group_t v157 = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (v157) {
          dispatch_group_enter(v157);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v112 + 424))(v112, &v157);
      if (v157)
      {
        dispatch_group_leave(v157);
        if (v157) {
          dispatch_release(v157);
        }
      }
LABEL_163:
      if ((v114 & 1) == 0) {
        sub_10004D2C8(v111);
      }
      v115 = (std::mutex *)Registry::getServiceMap(v113, *(Registry **)a1);
      v116 = v115;
      if (v117 < 0)
      {
        v118 = (unsigned __int8 *)(v117 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v119 = 5381;
        do
        {
          uint64_t v117 = v119;
          unsigned int v120 = *v118++;
          uint64_t v119 = (33 * v119) ^ v120;
        }
        while (v120);
      }
      std::mutex::lock(v115);
      group[0] = (dispatch_group_t)v117;
      v121 = sub_10004D37C(&v116[1].__m_.__sig, (unint64_t *)group);
      if (v121)
      {
        uint64_t v123 = v121[3];
        v122 = (std::__shared_weak_count *)v121[4];
        if (v122)
        {
          atomic_fetch_add_explicit(&v122->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v116);
          atomic_fetch_add_explicit(&v122->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v122);
          char v125 = 0;
          if (!v123) {
            goto LABEL_180;
          }
          goto LABEL_174;
        }
      }
      else
      {
        uint64_t v123 = 0;
      }
      std::mutex::unlock(v116);
      v122 = 0;
      char v125 = 1;
      if (!v123) {
        goto LABEL_180;
      }
LABEL_174:
      dispatch_group_t v156 = v7;
      if (v7)
      {
        dispatch_retain(v7);
        if (v156) {
          dispatch_group_enter(v156);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v123 + 48))(v123, &v156);
      if (v156)
      {
        dispatch_group_leave(v156);
        if (v156) {
          dispatch_release(v156);
        }
      }
LABEL_180:
      if ((v125 & 1) == 0) {
        sub_10004D2C8(v122);
      }
      v126 = (std::mutex *)Registry::getServiceMap(v124, *(Registry **)a1);
      v127 = v126;
      if (v128 < 0)
      {
        v129 = (unsigned __int8 *)(v128 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v130 = 5381;
        do
        {
          uint64_t v128 = v130;
          unsigned int v131 = *v129++;
          uint64_t v130 = (33 * v130) ^ v131;
        }
        while (v131);
      }
      std::mutex::lock(v126);
      group[0] = (dispatch_group_t)v128;
      v132 = sub_10004D37C(&v127[1].__m_.__sig, (unint64_t *)group);
      if (v132)
      {
        uint64_t v134 = v132[3];
        v133 = (std::__shared_weak_count *)v132[4];
        if (v133)
        {
          atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v127);
          atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v133);
          char v135 = 0;
          if (!v134)
          {
LABEL_192:
            if ((v135 & 1) == 0) {
              sub_10004D2C8(v133);
            }
            v155[0] = 0;
            v155[1] = 0;
            Registry::getMobileHelper(v155, *(Registry **)a1);
            v136 = (uint64_t *)v155[0];
            if (v155[0])
            {
              sub_100E29D94();
              v137 = qword_101B12C30;
              if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(group[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, "#I Resetting network settings in MobileHelper", (uint8_t *)group, 2u);
              }
              (*(void (**)(uint64_t))(*(void *)v155[0] + 88))(v155[0]);
            }
            v138 = (std::mutex *)Registry::getServiceMap(v136, *(Registry **)a1);
            v139 = v138;
            if (v140 < 0)
            {
              v141 = (unsigned __int8 *)(v140 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v142 = 5381;
              do
              {
                uint64_t v140 = v142;
                unsigned int v143 = *v141++;
                uint64_t v142 = (33 * v142) ^ v143;
              }
              while (v143);
            }
            std::mutex::lock(v138);
            group[0] = (dispatch_group_t)v140;
            v144 = sub_10004D37C(&v139[1].__m_.__sig, (unint64_t *)group);
            if (v144)
            {
              uint64_t v146 = v144[3];
              v145 = (std::__shared_weak_count *)v144[4];
              if (v145)
              {
                atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v139);
                atomic_fetch_add_explicit(&v145->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v145);
                char v147 = 0;
                if (!v146) {
                  goto LABEL_213;
                }
                goto LABEL_207;
              }
            }
            else
            {
              uint64_t v146 = 0;
            }
            std::mutex::unlock(v139);
            v145 = 0;
            char v147 = 1;
            if (!v146) {
              goto LABEL_213;
            }
LABEL_207:
            dispatch_group_t v154 = v7;
            if (v7)
            {
              dispatch_retain(v7);
              if (v154) {
                dispatch_group_enter(v154);
              }
            }
            (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v146 + 64))(v146, &v154);
            if (v154)
            {
              dispatch_group_leave(v154);
              if (v154) {
                dispatch_release(v154);
              }
            }
LABEL_213:
            if ((v147 & 1) == 0) {
              sub_10004D2C8(v145);
            }
            global_queue = dispatch_get_global_queue(0, 0);
            if (global_queue) {
              dispatch_retain(global_queue);
            }
            v150 = *(NSObject **)a5;
            uint64_t v149 = *(void *)(a5 + 8);
            group[0] = v150;
            group[1] = (dispatch_group_t)v149;
            if (v149) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v149 + 8), 1uLL, memory_order_relaxed);
            }
            v152 = *(Registry **)a1;
            uint64_t v151 = *(void *)(a1 + 8);
            group[2] = (dispatch_group_t)v152;
            group[3] = (dispatch_group_t)v151;
            if (v151) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v151 + 8), 1uLL, memory_order_relaxed);
            }
            operator new();
          }
LABEL_191:
          (*(void (**)(uint64_t))(*(void *)v134 + 32))(v134);
          goto LABEL_192;
        }
      }
      else
      {
        uint64_t v134 = 0;
      }
      std::mutex::unlock(v127);
      v133 = 0;
      char v135 = 1;
      if (!v134) {
        goto LABEL_192;
      }
      goto LABEL_191;
    }
  }
  else
  {
    uint64_t v54 = 0;
  }
  std::mutex::unlock(v47);
  v53 = 0;
  char v55 = 1;
  goto LABEL_68;
}

void sub_100E27FC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_group_t group, uint64_t a15, std::__shared_weak_count *a16, dispatch_group_t object, dispatch_group_t a18, dispatch_group_t a19, uint64_t a20,dispatch_group_t a21,dispatch_group_t a22,dispatch_group_t a23)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v23) {
    dispatch_release(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E281EC(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_100E29D94();
  unint64_t v6 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchCallForwardingValue", buf, 2u);
  }
  *(void *)buf = a4;
  char v25 = "kSettingsModelReason";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  *(void *)buf = a4;
  char v25 = "kSettingsModelClss";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v10 = xpc::dyn_cast_or_default((xpc *)&object, 0, v9);
  xpc_release(object);
  sub_100E29D94();
  uint64_t v11 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I _CTFetchCallForwardingValue for reason = %d", buf, 8u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *a1);
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v15;
  char v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_13:
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v21 = v19[3];
  uint64_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (v21) {
LABEL_14:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v21 + 80))(v21, 1, v8, v10);
LABEL_15:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
}

void sub_100E2842C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2848C(Registry **a1, uint64_t a2, uint64_t a3, void *a4)
{
  sub_100E29D94();
  unint64_t v6 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchCallBarringValue", buf, 2u);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v25 = 0;
  v22[0] = a4;
  v22[1] = "kSettingsModelPin2";
  sub_100048BAC((uint64_t)v22, &object);
  *(void *)buf = 0;
  unsigned int v27 = 0;
  uint64_t v28 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object);
  *(void *)buf = a4;
  unsigned int v27 = "kSettingsModelClss";
  sub_100048BAC((uint64_t)buf, v22);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)v22, 0, v7);
  xpc_release(v22[0]);
  *(void *)buf = a4;
  unsigned int v27 = "kSettingsModelFacility";
  sub_100048BAC((uint64_t)buf, v22);
  uint64_t v10 = xpc::dyn_cast_or_default((xpc *)v22, 0, v9);
  xpc_release(v22[0]);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *a1);
  char v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v14;
  unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_13:
    std::mutex::unlock(v13);
    char v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v20 = v18[3];
  char v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20) {
LABEL_14:
  }
    (*(void (**)(uint64_t, uint64_t, void **, uint64_t, uint64_t))(*(void *)v20 + 128))(v20, 1, __p, v10, v8);
LABEL_15:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100E286B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100E2874C(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, CFTypeRef *a5)
{
  sub_100E29D94();
  unsigned int v7 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I ## server_CTPreferencesSetValue", (uint8_t *)v12, 2u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12C48, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12C48))
  {
    qword_101B12C70 = @"Modem";
    unk_101B12C78 = @"IMSIOverride";
    qword_101B12C80 = @"FakePrimaryDns";
    unk_101B12C88 = @"FakeSecondaryDns";
    qword_101B12C90 = @"VerifyBundles";
    unk_101B12C98 = @"VerifyAPN";
    qword_101B12CA0 = @"DualIPBringUp";
    unk_101B12CA8 = @"WiFiCallingInCallHandover";
    qword_101B12CB0 = kCFSettingsModelKeyEPDGAddress;
    unk_101B12CB8 = kCFSettingsModelKeyPCSCFAddress;
    qword_101B12CC0 = @"ShowVoLTEStatusIndicator";
    unk_101B12CC8 = @"ShowLazuliStatusIndicator";
    qword_101B12CD0 = @"ShowFR2StatusIndicator";
    __cxa_guard_release(&qword_101B12C48);
  }
  CFStringRef theString1 = 0;
  xpc_dictionary_get_value(*a4, "kSettingsModelKey");
  v12[0] = (CFTypeRef)_CFXPCCreateCFObjectFromXPCObject();
  sub_100225AE0(&theString1, v12);
  xpc_dictionary_get_value(*a4, "kSettingsModelValue");
  uint64_t v8 = 0;
  CFTypeRef cf = (CFTypeRef)_CFXPCCreateCFObjectFromXPCObject();
  do
  {
    if (CFEqual(theString1, *(CFStringRef *)((char *)&unk_101B12C28 + v8 + 72)))
    {
      CFTypeID v9 = CFGetTypeID(cf);
      if (v9 == CFNullGetTypeID()) {
        CFTypeRef v10 = 0;
      }
      else {
        CFTypeRef v10 = cf;
      }
      CFPreferencesSetValue(theString1, v10, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_1003F2A04();
      goto LABEL_14;
    }
    v8 += 8;
  }
  while (v8 != 104);
  xpc_object_t v13 = xpc_int64_create(4);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  v12[0] = *a5;
  v12[1] = "kMachError";
  sub_100035E70((uint64_t)v12, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
LABEL_14:
  sub_1000577C4(&cf);
  return sub_1000558F4((const void **)&theString1);
}

void sub_100E289AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100E289D4(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, CFTypeRef *a5)
{
  uint64_t v12 = 0;
  xpc_dictionary_get_value(*a4, "kSettingsModelNoBackupKey");
  v8[0] = (CFTypeRef)_CFXPCCreateCFObjectFromXPCObject();
  sub_100225AE0(&v12, v8);
  xpc_dictionary_get_value(*a4, "kSettingsModelNoBackupValue");
  uint64_t v11 = _CFXPCCreateCFObjectFromXPCObject();
  xpc_object_t v9 = xpc_int64_create(4);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  v8[0] = *a5;
  v8[1] = "kMachError";
  sub_100035E70((uint64_t)v8, &v9, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  sub_1000577C4((const void **)&v11);
  return sub_1000558F4(&v12);
}

void sub_100E28AB0(_Unwind_Exception *a1)
{
  sub_1000558F4((const void **)(v1 - 24));
  _Unwind_Resume(a1);
}

const void **sub_100E28AC4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  sub_100E29D94();
  uint64_t v8 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I ## server_CTPreferencesCopyValue", buf, 2u);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12C50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12C50))
  {
    qword_101B12CD8 = @"Modem";
    unk_101B12CE0 = @"IMSIOverride";
    qword_101B12CE8 = @"FakePrimaryDns";
    unk_101B12CF0 = @"FakeSecondaryDns";
    qword_101B12CF8 = @"VerifyBundles";
    unk_101B12D00 = @"VerifyAPN";
    qword_101B12D08 = @"DualIPBringUp";
    unk_101B12D10 = @"WiFiCallingInCallHandover";
    qword_101B12D18 = kCFSettingsModelKeyEPDGAddress;
    unk_101B12D20 = kCFSettingsModelKeyPCSCFAddress;
    qword_101B12D28 = @"ShowVoLTEStatusIndicator";
    unk_101B12D30 = @"ShowFR2StatusIndicator";
    qword_101B12D38 = @"ShowLazuliStatusIndicator";
    unk_101B12D40 = @"iWlanGatewayAddress";
    __cxa_guard_release(&qword_101B12C50);
  }
  CFStringRef v49 = 0;
  xpc_dictionary_get_value(*a4, "kSettingsModelKey");
  *(void *)buf = _CFXPCCreateCFObjectFromXPCObject();
  sub_100225AE0(&v49, (CFTypeRef *)buf);
  for (uint64_t i = 0; i != 112; i += 8)
  {
    if (CFEqual(v49, *(CFStringRef *)((char *)&unk_101B12C28 + i + 176)))
    {
      if (CFStringCompare(v49, @"iWlanGatewayAddress", 0))
      {
        CFPropertyListRef v11 = CFPreferencesCopyValue(v49, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        v44 = v11;
        if (v11) {
          uint64_t v12 = sub_100080934;
        }
        else {
          uint64_t v12 = 0;
        }
        if (!v12 || (CFTypeID v13 = CFGetTypeID(v11), v13 == CFNullGetTypeID()))
        {
          if (CFStringCompare(v49, @"VerifyBundles", 0))
          {
            if (CFStringCompare(v49, @"VerifyAPN", 0))
            {
              if (CFStringCompare(v49, @"DualIPBringUp", 0)
                && CFStringCompare(v49, @"ShowVoLTEStatusIndicator", 0)
                && CFStringCompare(v49, @"ShowLazuliStatusIndicator", 0)
                && CFStringCompare(v49, @"ShowFR2StatusIndicator", 0))
              {
                if (CFEqual(v49, @"WiFiCallingInCallHandover"))
                {
                  CFDictionaryRef theDict = 0;
                  *(void *)buf = 0;
                  v46 = 0;
                  sub_100E2A500(*a1, &v38, v14);
                  (*(void (**)(uint8_t *__return_ptr))(*(void *)v38 + 32))(buf);
                  if (v39) {
                    sub_10004D2C8(v39);
                  }
                  if (*(void *)buf)
                  {
                    (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)buf + 40))(&v42);
                    CFDictionaryRef v38 = theDict;
                    CFDictionaryRef v15 = v42;
                    CFDictionaryRef v42 = 0;
                    CFDictionaryRef theDict = v15;
                    sub_100057D78((const void **)&v38);
                    sub_100057D78((const void **)&v42);
                  }
                  if (v46) {
                    sub_10004D2C8(v46);
                  }
                  if (theDict) {
                    uint64_t v16 = sub_100080778;
                  }
                  else {
                    uint64_t v16 = 0;
                  }
                  if (v16)
                  {
                    Value = CFDictionaryGetValue(theDict, @"SupportCallHandover");
                    unsigned int v18 = Value;
                    if (Value && (CFTypeID v19 = CFGetTypeID(Value), v19 == CFBooleanGetTypeID()))
                    {
                      *(void *)buf = v18;
                      sub_1002CC4B4(&v44, (CFTypeRef *)buf);
                    }
                    else
                    {
                      *(void *)buf = kCFBooleanTrue;
                      sub_1002CC4B4(&v44, (CFTypeRef *)buf);
                    }
                  }
                  else
                  {
                    *(void *)buf = kCFBooleanFalse;
                    sub_1002CC4B4(&v44, (CFTypeRef *)buf);
                  }
                  sub_100057D78((const void **)&theDict);
                }
              }
              else
              {
                *(void *)buf = kCFBooleanFalse;
                sub_1002CC4B4(&v44, (CFTypeRef *)buf);
              }
              goto LABEL_70;
            }
            sub_100E29D94();
            v34 = qword_101B12C30;
            if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I ## VerifyAPN DEFAULT", buf, 2u);
            }
          }
          else
          {
            sub_100E29D94();
            uint64_t v30 = qword_101B12C30;
            if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I ## VerifyBundles DEFAULT", buf, 2u);
            }
          }
          *(void *)buf = kCFBooleanTrue;
          sub_1002CC4B4(&v44, (CFTypeRef *)buf);
        }
LABEL_70:
        xpc_object_t v36 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        *(void *)buf = *a5;
        v46 = (std::__shared_weak_count *)"kSettingsModelValue";
        sub_100035E70((uint64_t)buf, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
LABEL_73:
        sub_1000577C4(&v44);
        return sub_1000558F4((const void **)&v49);
      }
      CFDictionaryRef theDict = 0;
      v44 = 0;
      *(void *)buf = 0;
      v46 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *a1);
      char v21 = ServiceMap;
      if (v22 < 0)
      {
        char v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          uint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      CFDictionaryRef v38 = (CFDictionaryRef)v22;
      uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&v38);
      if (v26)
      {
        uint64_t v28 = v26[3];
        unsigned int v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
LABEL_47:
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v28 + 32))(buf, v28, 1);
          if ((v29 & 1) == 0) {
            sub_10004D2C8(v27);
          }
          if (*(void *)buf)
          {
            (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)buf + 40))(&v42);
            CFDictionaryRef v38 = theDict;
            CFDictionaryRef v31 = v42;
            CFDictionaryRef v42 = 0;
            CFDictionaryRef theDict = v31;
            sub_100057D78((const void **)&v38);
            sub_100057D78((const void **)&v42);
          }
          if (v46) {
            sub_10004D2C8(v46);
          }
          if (theDict) {
            uint64_t v32 = sub_100080778;
          }
          else {
            uint64_t v32 = 0;
          }
          if (v32)
          {
            CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"IKE");
            if (v33)
            {
              *(void *)buf = CFDictionaryGetValue(v33, @"RemoteAddress");
              sub_100057DAC(&v44, (CFTypeRef *)buf);
            }
          }
          xpc_object_t v40 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
          if (!v40) {
            xpc_object_t v40 = xpc_null_create();
          }
          *(void *)buf = *a5;
          v46 = (std::__shared_weak_count *)"kSettingsModelValue";
          sub_100035E70((uint64_t)buf, &v40, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v40);
          xpc_object_t v40 = 0;
          sub_100057D78((const void **)&theDict);
          goto LABEL_73;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      unsigned int v27 = 0;
      char v29 = 1;
      goto LABEL_47;
    }
  }
  xpc_object_t v47 = xpc_int64_create(4);
  if (!v47) {
    xpc_object_t v47 = xpc_null_create();
  }
  *(void *)buf = *a5;
  v46 = (std::__shared_weak_count *)"kMachError";
  sub_100035E70((uint64_t)buf, &v47, &v48);
  xpc_release(v48);
  xpc_object_t v48 = 0;
  xpc_release(v47);
  xpc_object_t v47 = 0;
  return sub_1000558F4((const void **)&v49);
}

void sub_100E292B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  CFPropertyListRef v11 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_1000577C4((const void **)va1);
  sub_1000558F4((const void **)(v9 - 56));
  _Unwind_Resume(a1);
}

const void **sub_100E29390(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, CFTypeRef *a5)
{
  CFTypeRef v10 = 0;
  xpc_dictionary_get_value(*a4, "kSettingsModelNoBackupKey");
  v7[0] = (CFTypeRef)_CFXPCCreateCFObjectFromXPCObject();
  sub_100225AE0(&v10, v7);
  xpc_object_t v8 = xpc_int64_create(4);
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  v7[0] = *a5;
  v7[1] = "kMachError";
  sub_100035E70((uint64_t)v7, &v8, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  return sub_1000558F4(&v10);
}

void sub_100E29448(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  sub_100E29D94();
  unint64_t v6 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchCallWaitingValue", (uint8_t *)v20, 2u);
  }
  v20[0] = a4;
  v20[1] = (unint64_t)"kSettingsModelClss";
  sub_100048BAC((uint64_t)v20, &object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *a1);
  CFPropertyListRef v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    CFTypeID v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, v20);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_11:
    std::mutex::unlock(v11);
    unsigned int v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v18 = v16[3];
  unsigned int v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (v18) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 152))(v18, 1, v8);
LABEL_13:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100E295D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29608(Registry **a1)
{
  sub_100E29D94();
  v2 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchSimLockValue", v14, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *a1);
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  CFTypeRef v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    CFPropertyListRef v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  CFPropertyListRef v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_12:
  }
    (*(void (**)(uint64_t))(*(void *)v12 + 80))(v12);
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E29758(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29778(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  sub_100E29D94();
  unint64_t v6 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchConnectedLinePresentationValue", (uint8_t *)v20, 2u);
  }
  v20[0] = a4;
  v20[1] = (unint64_t)"kSettingsModelLinePresentation";
  sub_100048BAC((uint64_t)v20, &object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *a1);
  CFPropertyListRef v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, v20);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_11:
    std::mutex::unlock(v11);
    unsigned int v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v18 = v16[3];
  unsigned int v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (v18) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 176))(v18, 1, v8);
LABEL_13:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100E29904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29938(Registry **a1)
{
  sub_100E29D94();
  v2 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchConnectedLineIdRestrictionValue", v14, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *a1);
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  CFTypeRef v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    CFPropertyListRef v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  CFPropertyListRef v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 192))(v12, 1);
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E29A8C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29AAC(Registry **a1)
{
  sub_100E29D94();
  v2 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchCallingLineIdRestrictionValue", v14, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *a1);
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  CFTypeRef v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    CFPropertyListRef v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  CFPropertyListRef v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 208))(v12, 1);
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E29C00(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29C20(Registry **a1)
{
  sub_100E29D94();
  v2 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ## server_CTFetchServiceCenterAddressValue", v14, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *a1);
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  CFTypeRef v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    CFPropertyListRef v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  CFPropertyListRef v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 240))(v12, 1);
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E29D74(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E29D94()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12C38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12C38))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12C30, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B12C38);
  }
}

void sub_100E29E18(_Unwind_Exception *a1)
{
}

void sub_100E29E30(id a1, auto_reply a2, shared_ptr<SettingsInterface> a3, BOOL a4, CSIPhoneNumber *a5)
{
  char var0 = (char)a3.var0;
  var1 = a2.var0.var1;
  uint64_t v7 = a2.var0.var0;
  memset(&v21, 0, sizeof(v21));
  CSIPhoneNumber::getFullNumber((uint64_t *)&v21, (CSIPhoneNumber *)a3.var1);
  if (var0)
  {
    BOOL v8 = 1;
  }
  else
  {
    uint64_t v9 = *(void *)var1;
    if (*(void *)var1)
    {
      __p = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      __int16 v17 = 0;
      char v16 = 0;
      memset(__str, 0, sizeof(__str));
      if ((*(unsigned int (**)(void))(*(void *)v9 + 256))()) {
        std::string::operator=(&v21, (const std::string *)__str);
      }
      BOOL v8 = HIBYTE(v17) != 0;
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      if (SHIBYTE(v20) < 0) {
        operator delete(__p);
      }
    }
    else
    {
      BOOL v8 = 0;
    }
  }
  xpc_object_t v13 = xpc_BOOL_create(v8);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  *(dict *)__str = (dict)v7->fObj.fObj;
  *(void *)&__str[8] = "kSettingsModelValid";
  sub_100035E70((uint64_t)__str, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  if (v8)
  {
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeRef v10 = &v21;
    }
    else {
      CFTypeRef v10 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v11 = xpc_string_create((const char *)v10);
    if (!v11) {
      xpc_object_t v11 = xpc_null_create();
    }
    *(dict *)__str = (dict)v7->fObj.fObj;
    *(void *)&__str[8] = "kSettingsEffectivePhoneNumber";
    sub_100035E70((uint64_t)__str, &v11, &v12);
    xpc_release(v12);
    xpc_object_t v12 = 0;
    xpc_release(v11);
    xpc_object_t v11 = 0;
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
}

void sub_100E2A008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v27 - 33) < 0) {
    operator delete(*(void **)(v27 - 56));
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2A05C(void *a1, unsigned char *a2)
{
  uint64_t v39 = 0;
  long long v38 = 0u;
  long long v36 = 0u;
  memset(v37, 0, sizeof(v37));
  long long v35 = 0u;
  memset(&v34, 0, sizeof(v34));
  CSIPhoneNumber::CSIPhoneNumber(&v34);
  int v4 = *a2;
  if (*a2)
  {
    CSIPhoneNumber::CSIPhoneNumber();
    *(void *)&v34.char var0 = v21;
    if (*((char *)&v34.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(v34.var2.__r_.__value_.var0.var1.__data_);
    }
    *(_OWORD *)v34.var2.__r_.__value_.var0.var0.__data_ = v22;
    *((void *)&v34.var2.__r_.__value_.var0.var1 + 2) = v23;
    HIBYTE(v23) = 0;
    LOBYTE(v22) = 0;
    if (SBYTE7(v35) < 0) {
      operator delete(*(void **)&v34.var2.__r_.var0);
    }
    *(_OWORD *)&v34.var2.__r_.char var0 = v24;
    *(void *)&long long v35 = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    DWORD2(v35) = v26;
    BYTE12(v35) = v27;
    if (SBYTE7(v37[0]) < 0) {
      operator delete((void *)v36);
    }
    long long v36 = __p;
    *(void *)&v37[0] = v29;
    HIBYTE(v29) = 0;
    LOBYTE(__p) = 0;
    if (SHIBYTE(v37[1]) < 0) {
      operator delete(*((void **)&v37[0] + 1));
    }
    *(_OWORD *)((char *)v37 + 8) = v30;
    *((void *)&v37[1] + 1) = v31;
    HIBYTE(v31) = 0;
    LOBYTE(v30) = 0;
    long long v38 = v32;
    LOBYTE(v39) = v33;
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)v24);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)v22);
    }
  }
  uint64_t v5 = a1[4];
  unint64_t v6 = (std::__shared_weak_count *)a1[6];
  uint64_t v19 = a1[5];
  uint64_t v20 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[8];
  uint64_t v17 = a1[7];
  uint64_t v18 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10009DB3C((uint64_t)&v8, (uint64_t)&v34);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, BOOL, uint64_t *))(v5 + 16))(v5, &v19, &v17, v4 != 0, &v8);
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (SHIBYTE(v37[1]) < 0) {
    operator delete(*((void **)&v37[0] + 1));
  }
  if (SBYTE7(v37[0]) < 0) {
    operator delete((void *)v36);
  }
  if (SBYTE7(v35) < 0) {
    operator delete(*(void **)&v34.var2.__r_.var0);
  }
  if (*((char *)&v34.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v34.var2.__r_.__value_.var0.var1.__data_);
  }
}

void sub_100E2A2FC(_Unwind_Exception *a1)
{
  sub_100087E24(v1 - 208);
  _Unwind_Resume(a1);
}

void *sub_100E2A344(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E2A378(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_100E2A3C8(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  sub_100E29D94();
  uint64_t v3 = qword_101B12C30;
  if (v2 == 1)
  {
    if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Vinyl: Deleted all user profiles", buf, 2u);
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v4 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Vinyl: Failed to delete all user profiles", v4, 2u);
  }
}

uint64_t *sub_100E2A478(uint64_t a1)
{
  uint64_t v3 = a1;
  sub_100E29D94();
  uint64_t v1 = qword_101B12C30;
  if (os_log_type_enabled((os_log_t)qword_101B12C30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I All reset network setting handlers are complete", buf, 2u);
  }
  return sub_100BE3560(&v3);
}

void sub_100E2A4EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100BE3560((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100E2A500(Registry *this@<X1>, void *a2@<X0>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, &v13);
  if (v10)
  {
    uint64_t v12 = v10[3];
    xpc_object_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    xpc_object_t v11 = 0;
  }
  std::mutex::unlock(v5);
  *a2 = v12;
  a2[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
}

uint64_t sub_100E2A5CC()
{
  return sub_100C624B8((uint64_t)&unk_101B12C2A, (uint64_t)sub_100E2417C);
}

uint64_t sub_100E2A5E8(uint64_t a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "carrier.space.info");
  sub_100E2A6E0((void *)(a1 + 8), a3, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)a1 = off_101A5F8F8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return a1;
}

void sub_100E2A6BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CarrierSpaceInfoModelInterface::~CarrierSpaceInfoModelInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_100E2A6E0(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100E2A748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_100E2A76C(uint64_t a1)
{
  *(void *)a1 = off_101A5F8F8;

  int v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CarrierSpaceInfoModelInterface::~CarrierSpaceInfoModelInterface((CarrierSpaceInfoModelInterface *)a1);
}

void sub_100E2A804(uint64_t a1)
{
  sub_100E2A76C(a1);

  operator delete();
}

void sub_100E2A83C()
{
}

void sub_100E2A8B0()
{
}

void sub_100E2A8D4(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v4 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  *(_OWORD *)(a1 + 64) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_100E2A8F4(void *a1)
{
  id v2 = objc_alloc_init((Class)CTCarrierSpaceCapabilities);
  uint64_t v3 = (void *)a1[10];
  a1[10] = v2;

  id v4 = objc_alloc_init((Class)CTCarrierSpaceInfo);
  uint64_t v5 = (void *)a1[12];
  a1[12] = v4;

  uint64_t v6 = (void *)a1[11];
  a1[11] = 0;
}

void sub_100E2A95C(void *a1)
{
  id v2 = (void *)a1[10];
  a1[10] = 0;

  uint64_t v3 = (void *)a1[12];
  a1[12] = 0;

  id v4 = (void *)a1[11];
  a1[11] = 0;
}

id sub_100E2A9AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  [*(id *)(a1 + 80) setSupportsServices:a2];
  [*(id *)(a1 + 80) setSupportsUsage:a3];
  [*(id *)(a1 + 80) setSupportsPlans:a4];
  unsigned int v9 = *(void **)(a1 + 80);

  return [v9 setSupportsApplications:a5];
}

void sub_100E2AA1C(uint64_t a1, id **a2)
{
  if (*a2) {
    id v3 = **a2;
  }
  else {
    id v3 = 0;
  }
  if (([v3 isEqual:*(void *)(a1 + 88)] & 1) == 0)
  {
    objc_storeStrong((id *)(a1 + 88), v3);
    id v4 = *(std::__shared_weak_count **)(a1 + 72);
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        uint64_t v6 = *(void *)(a1 + 64);
        if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 80))(v6);
LABEL_13:
          sub_10004D2C8(v5);
          goto LABEL_14;
        }
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)OsLogContext v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "somehow delegate pointer not valid", v8, 2u);
    }
    if (v5) {
      goto LABEL_13;
    }
  }
LABEL_14:
}

void sub_100E2AB20(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);

  _Unwind_Resume(a1);
}

void sub_100E2AB40(uint64_t a1, void **a2)
{
  if (*a2) {
    [*(id *)(a1 + 96) setUsageInfo:**a2];
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    id v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, 1);
LABEL_11:
        sub_10004D2C8(v4);
        return;
      }
    }
  }
  else
  {
    id v4 = 0;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "somehow delegate pointer not valid", v7, 2u);
  }
  if (v4) {
    goto LABEL_11;
  }
}

void sub_100E2AC14(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100E2AC28(uint64_t a1, void **a2)
{
  if (*a2) {
    [*(id *)(a1 + 96) setPlansInfo:**a2];
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    id v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, 2);
LABEL_11:
        sub_10004D2C8(v4);
        return;
      }
    }
  }
  else
  {
    id v4 = 0;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "somehow delegate pointer not valid", v7, 2u);
  }
  if (v4) {
    goto LABEL_11;
  }
}

void sub_100E2ACFC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100E2AD10(uint64_t a1, void **a2)
{
  if (*a2) {
    [*(id *)(a1 + 96) setAppsInfo:**a2];
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    id v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, 4);
LABEL_11:
        sub_10004D2C8(v4);
        return;
      }
    }
  }
  else
  {
    id v4 = 0;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "somehow delegate pointer not valid", v7, 2u);
  }
  if (v4) {
    goto LABEL_11;
  }
}

void sub_100E2ADE4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E2ADF8(uint64_t a1)
{
  for (unint64_t i = 0; ; ++i)
  {
    id v3 = [*(id *)(a1 + 96) usageInfo];
    id v4 = [v3 accountMetrics];
    id v5 = [v4 count];

    if (i >= (unint64_t)v5) {
      return 0;
    }
    uint64_t v6 = [*(id *)(a1 + 96) usageInfo];
    uint64_t v7 = [v6 accountMetrics];
    OsLogContext v8 = [v7 objectAtIndex:i];

    if ([v8 localDevice]) {
      break;
    }
  }
  char v10 = [v8 billingCycleEndDate];
  [v10 timeIntervalSinceReferenceDate];
  uint64_t v12 = v11;

  return v12;
}

void sub_100E2AEE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E2AF30(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  id v3 = *(id *)(a1 + 80);
  if (v3 || (id v3 = objc_alloc_init((Class)CTCarrierSpaceCapabilities)) != 0)
  {
    id v4 = operator new(0x20uLL);
    v4[1] = 0;
    v4[2] = 0;
    *id v4 = off_101A5FAC8;
    v4[3] = v3;
    *a2 = v4 + 3;
    a2[1] = v4;
    id v5 = v3;
  }
}

void sub_100E2AFDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E2AFEC(uint64_t a1@<X0>, id **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  id v2 = *(void **)(a1 + 88);
  if (v2)
  {
    id v4 = (id *)operator new(0x20uLL);
    v4[1] = 0;
    v4[2] = 0;
    *id v4 = off_101A5AD78;
    a2[1] = v4;
    v4[3] = 0;
    id v5 = v4 + 3;
    *a2 = v5;
    objc_storeStrong(v5, v2);
  }
}

void sub_100E2B06C(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  id v3 = [*(id *)(a1 + 96) usageInfo];
  if (v3)
  {
    id obj = v3;
    id v4 = (char *)operator new(0x20uLL);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)id v4 = off_101A5AC88;
    *((void *)v4 + 3) = 0;
    *a2 = v4 + 24;
    a2[1] = v4;
    objc_storeStrong((id *)v4 + 3, obj);
    id v3 = obj;
  }
}

void sub_100E2B100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100E2B114(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  id v3 = [*(id *)(a1 + 96) plansInfo];
  if (v3)
  {
    id obj = v3;
    id v4 = (char *)operator new(0x20uLL);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)id v4 = off_101A5ACD8;
    *((void *)v4 + 3) = 0;
    *a2 = v4 + 24;
    a2[1] = v4;
    objc_storeStrong((id *)v4 + 3, obj);
    id v3 = obj;
  }
}

void sub_100E2B1A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100E2B1BC(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  id v3 = [*(id *)(a1 + 96) appsInfo];
  if (v3)
  {
    id obj = v3;
    id v4 = (char *)operator new(0x20uLL);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)id v4 = off_101A5AD28;
    *((void *)v4 + 3) = 0;
    *a2 = v4 + 24;
    a2[1] = v4;
    objc_storeStrong((id *)v4 + 3, obj);
    id v3 = obj;
  }
}

void sub_100E2B250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100E2B264(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  id v5 = [*(id *)(a1 + 96) plansInfo];
  uint64_t v6 = v5;
  if (v5
    && ([v5 planGroupsList], uint64_t v7 = objc_claimAutoreleasedReturnValue(), v7, v7))
  {
    if (*((char *)a2 + 23) >= 0) {
      OsLogContext v8 = a2;
    }
    else {
      OsLogContext v8 = (uint64_t *)*a2;
    }
    unsigned int v9 = +[NSString stringWithUTF8String:v8];
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x3032000000;
    uint64_t v20 = sub_100E2B470;
    uint64_t v21 = sub_100E2B480;
    id v22 = 0;
    char v10 = [v6 planGroupsList];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_100E2B488;
    v14[3] = &unk_101A5F990;
    id v11 = v9;
    id v15 = v11;
    char v16 = &v17;
    [v10 enumerateObjectsUsingBlock:v14];

    uint64_t v12 = (void *)v18[5];
    *a3 = 0;
    a3[1] = 0;
    if (v12)
    {
      unint64_t v13 = (char *)operator new(0x20uLL);
      *((void *)v13 + 1) = 0;
      *((void *)v13 + 2) = 0;
      *(void *)unint64_t v13 = off_101A5FB18;
      *((void *)v13 + 3) = 0;
      *a3 = v13 + 24;
      a3[1] = v13;
      objc_storeStrong((id *)v13 + 3, v12);
    }

    _Block_object_dispose(&v17, 8);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_100E2B418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100E2B470(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100E2B480(uint64_t a1)
{
}

void sub_100E2B488(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v6 = objc_msgSend(a2, "groupOptionsList", 0);
  id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v14;
    while (2)
    {
      for (unint64_t i = 0; i != v7; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v6);
        }
        char v10 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        id v11 = [v10 planId];
        unsigned int v12 = [v11 isEqualToString:*(void *)(a1 + 32)];

        if (v12)
        {
          objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v10);
          *a4 = 1;
          goto LABEL_11;
        }
      }
      id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

void sub_100E2B5D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E2B5FC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = 0;
  long long v16 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 128))(&v15);
  if (!v15) {
    goto LABEL_14;
  }
  uint64_t v5 = *(void *)(a3 + 24);
  if (!v5) {
    goto LABEL_14;
  }
  uint64_t v13 = v15;
  long long v14 = v16;
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = *(void *)(a3 + 24);
    if (!v5) {
      sub_10007B600();
    }
  }
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v5 + 48))(v5, &v13);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v6)
  {
    id v7 = (std::__shared_weak_count *)a1[9];
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        unsigned int v9 = v8;
        uint64_t v10 = a1[8];
        if (v10) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 72))(v10, 2);
        }
        sub_10004D2C8(v9);
      }
    }
    uint64_t v11 = 1;
  }
  else
  {
LABEL_14:
    uint64_t v11 = 0;
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  return v11;
}

void sub_100E2B730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_10004D2C8(v12);
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_100E2B760(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100E2B82C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100E2B904);
  __cxa_rethrow();
}

void sub_100E2B854(_Unwind_Exception *a1)
{
}

void sub_100E2B86C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E2B8A4(uint64_t a1)
{
}

uint64_t sub_100E2B8C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E2B904(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E2B930(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FAC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E2B950(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FAC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E2B9A4(uint64_t a1)
{
}

void sub_100E2B9B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FB18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E2B9D0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FB18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E2BA24(uint64_t a1)
{
}

void sub_100E2BA30(uint64_t a1, Registry **a2)
{
  byte_101B13F30 = a1;
  sub_100E2BC14();
  id v4 = qword_101B12D50;
  if (os_log_type_enabled((os_log_t)qword_101B12D50, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_101B13F30) {
      int v6 = "true";
    }
    else {
      int v6 = "false";
    }
    *(_DWORD *)uint64_t v17 = 136315138;
    *(void *)&v17[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Submitting TTY Status (CTM Status) metric (switch on && tty machine?) with %s", v17, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *a2);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v17 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v17);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_14:
    std::mutex::unlock(v8);
    long long v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v15 = v13[3];
  long long v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
LABEL_15:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 160))(v15, a1);
LABEL_16:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_100E2BBE4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2BC14()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B12D58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_101B12D58))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12D50, kCtLoggingSystemName, "misc");
    __cxa_guard_release(qword_101B12D58);
  }
}

void sub_100E2BC94(_Unwind_Exception *a1)
{
}

uint64_t *sub_100E2BCAC(uint64_t a1)
{
  sub_100C62630(a1, "kAudioSetAudioPath", (unint64_t)sub_100E2BFEC, 3u);
  sub_100C62630(a1, "kAudioSetSourceGain", (unint64_t)sub_100E2C1B4, 3u);
  sub_100C62630(a1, "kAudioSetChannelMute", (unint64_t)sub_100E2C37C, 3u);
  sub_100C62630(a1, "kAudioSetI2SFormat", (unint64_t)sub_100E2C548, 3u);
  sub_100C62630(a1, "kAudioEnablePCMChannel", (unint64_t)sub_100E2C710, 3u);
  sub_100C62630(a1, "kAudioDisablePCMChannel", (unint64_t)sub_100E2C888, 3u);
  sub_100C62630(a1, "kAudioSetMixState", (unint64_t)sub_100E2C9B0, 3u);
  sub_100C62630(a1, "kAudioEnableMediaToDownlink", (unint64_t)sub_100E2CB28, 3u);
  sub_100C62630(a1, "kAudioEnableEchoCancelationNoiseReduction", (unint64_t)sub_100E2CCA4, 3u);
  sub_100C62630(a1, "kAudioSetTTYMode", (unint64_t)sub_100E2CE74, 3u);
  sub_100C62700(a1, "kAudioGetTTYMode", (unint64_t)sub_100E2D09C, 3u);
  sub_100C62630(a1, "kAudioSetVoiceMute", (unint64_t)sub_100E2D258, 3u);
  sub_100C62700(a1, "kAudioGetVoiceMute", (unint64_t)sub_100E2D3D4, 3u);
  sub_100C62630(a1, "kAudioSetMasterMute", (unint64_t)sub_100E2D590, 3u);
  sub_100C62630(a1, "kAudioStartAudioTone", (unint64_t)sub_100E2D70C, 3u);
  sub_100C62630(a1, "kAudioStopAudioTone", (unint64_t)sub_100E2D924, 3u);
  sub_100C62630(a1, "kAudioSetVibratorState", (unint64_t)sub_100E2DA4C, 3u);
  sub_100C62630(a1, "kSetActiveAudioSystemConfiguration", (unint64_t)sub_1000161B0, 3u);
  sub_100C62630(a1, "kSetAudioLoggingEnabled", (unint64_t)sub_100E2DCBC, 3u);
  sub_100C62700(a1, "kGetAudioLoggingEnabled", (unint64_t)sub_100E2DE44, 3u);
  sub_100C62700(a1, "kAudioQueryAudioVocoderInfo", (unint64_t)sub_100E2DFFC, 3u);

  return sub_100C62630(a1, "kAudioSampleRateSwitchDidComplete", (unint64_t)sub_100E2E328, 3u);
}

void sub_100E2BFEC(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioDownPath";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioUpPath";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v15, v17);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2C160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C1B4(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioVolume";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioSource";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, v15, v17);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2C328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C37C(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioMuteChannel";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioMuteState";
    sub_100048BAC((uint64_t)&v18, &object);
    char v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v12 + 64))(v12, v15, v17 != 0);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2C4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C548(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioI2SInterface";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioChannelFormat";
    sub_100048BAC((uint64_t)&v18, &object);
    uint64_t v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 72))(v12, v15, v17);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2C6BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C710(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioPcmDirection";
    sub_100048BAC((uint64_t)v16, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, v15);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2C850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C888(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  id v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    unsigned int v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  unsigned int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v10 + 88))(v10);
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E2C990(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2C9B0(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioPcmMixState";
    sub_100048BAC((uint64_t)v16, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 96))(v12, v15);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2CAF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2CB28(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioBoolean";
    sub_100048BAC((uint64_t)v16, &object);
    char v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, BOOL))(*(void *)v12 + 128))(v12, v15 != 0);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2CC6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2CCA4(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioEnableEchoCancelation";
    sub_100048BAC((uint64_t)&v18, &object);
    char v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v18 = a2;
    uint64_t v19 = "kAudioEnableNoiseReduction";
    sub_100048BAC((uint64_t)&v18, &object);
    char v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    (*(void (**)(uint64_t, BOOL, BOOL))(*(void *)v12 + 136))(v12, v15 != 0, v17 != 0);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2CE20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2CE74(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  unint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_15;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13) {
    goto LABEL_15;
  }
LABEL_10:
  *(void *)&long long buf = a4;
  *((void *)&buf + 1) = "kAudioBoolean";
  sub_100048BAC((uint64_t)&buf, &object);
  unsigned __int8 v16 = xpc::dyn_cast_or_default((xpc *)&object, 0, v15);
  xpc_release(object);
  sub_100E2BC14();
  int v17 = v16;
  unint64_t v18 = qword_101B12D50;
  if (os_log_type_enabled((os_log_t)qword_101B12D50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = "true";
    if (!v17) {
      uint64_t v19 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Submitting TTY Switch Status metric with %s", (uint8_t *)&buf, 0xCu);
  }
  (*(void (**)(uint64_t, BOOL))(*(void *)v13 + 144))(v13, v17 != 0);
LABEL_15:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100E2D050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D09C(Registry **a1@<X0>, unint64_t *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_7:
    xpc_object_t v16 = xpc_int64_create(45);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    v15[0] = *a2;
    v15[1] = (unint64_t)"kPosixError";
    sub_100035E70((uint64_t)v15, &v16, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
    goto LABEL_16;
  }
LABEL_12:
  char v14 = (std::__shared_weak_count *)a2[1];
  unint64_t v18 = *a2;
  uint64_t v19 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, unint64_t *))(*(void *)v12 + 152))(v12, &v18);
  if (v19) {
    sub_10004D2C8(v19);
  }
LABEL_16:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2D230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D258(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioMuteState";
    sub_100048BAC((uint64_t)v16, &object);
    char v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, BOOL))(*(void *)v12 + 40))(v12, v15 != 0);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2D39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D3D4(Registry **a1@<X0>, unint64_t *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_7:
    xpc_object_t v16 = xpc_int64_create(45);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    v15[0] = *a2;
    v15[1] = (unint64_t)"kPosixError";
    sub_100035E70((uint64_t)v15, &v16, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
    goto LABEL_16;
  }
LABEL_12:
  int v14 = (std::__shared_weak_count *)a2[1];
  unint64_t v18 = *a2;
  uint64_t v19 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, unint64_t *))(*(void *)v12 + 48))(v12, &v18);
  if (v19) {
    sub_10004D2C8(v19);
  }
LABEL_16:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2D568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D590(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioMuteState";
    sub_100048BAC((uint64_t)v16, &object);
    char v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, BOOL))(*(void *)v12 + 56))(v12, v15 != 0);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2D6D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D70C(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v20);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v20 = a2;
    uint64_t v21 = "kAudioTone";
    sub_100048BAC((uint64_t)&v20, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v20 = a2;
    uint64_t v21 = "kAudioToneCount";
    sub_100048BAC((uint64_t)&v20, &object);
    uint64_t v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    unint64_t v20 = a2;
    uint64_t v21 = "kAudioToneMix";
    sub_100048BAC((uint64_t)&v20, &object);
    uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 112))(v12, v15, v17, v19);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2D8B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D924(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  char v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    unsigned int v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  unsigned int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v10 + 120))(v10);
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E2DA2C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2DA4C(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v22);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    unint64_t v22 = a2;
    uint64_t v23 = "kAudioAction";
    sub_100048BAC((uint64_t)&v22, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    unint64_t v22 = a2;
    uint64_t v23 = "kAudioIntensity";
    sub_100048BAC((uint64_t)&v22, &object);
    uint64_t v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
    xpc_release(object);
    unint64_t v22 = a2;
    uint64_t v23 = "kAudioTotalTime";
    sub_100048BAC((uint64_t)&v22, &object);
    uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
    xpc_release(object);
    unint64_t v22 = a2;
    uint64_t v23 = "kAudioOnTime";
    sub_100048BAC((uint64_t)&v22, &object);
    uint64_t v21 = xpc::dyn_cast_or_default((xpc *)&object, 0, v20);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 104))(v12, v15, v17, v19, v21);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2DC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2DCBC(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  unint64_t v6 = "14AudioInterface";
  if (((unint64_t)"14AudioInterface" & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)((unint64_t)"14AudioInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v16[0] = (unint64_t)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v16);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_10:
  if (sub_10121F6B4() || sub_10121F67C())
  {
    v16[0] = a2;
    v16[1] = (unint64_t)"kAudioLoggingEnabled";
    sub_100048BAC((uint64_t)v16, &object);
    uint64_t v15 = xpc::dyn_cast_or_default((xpc *)&object, 0, v14);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 32))(v12, v15);
  }
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2DE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2DE44(Registry **a1@<X0>, unint64_t *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  unint64_t v6 = "14AudioInterface";
  if (((unint64_t)"14AudioInterface" & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)((unint64_t)"14AudioInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = (unint64_t)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_7:
    xpc_object_t v16 = xpc_int64_create(45);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    v15[0] = *a2;
    v15[1] = (unint64_t)"kPosixError";
    sub_100035E70((uint64_t)v15, &v16, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
    goto LABEL_16;
  }
LABEL_12:
  BOOL v14 = (std::__shared_weak_count *)a2[1];
  unint64_t v18 = *a2;
  uint64_t v19 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, unint64_t *))(*(void *)v12 + 40))(v12, &v18);
  if (v19) {
    sub_10004D2C8(v19);
  }
LABEL_16:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2DFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2DFFC(Registry **a1@<X0>, void *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  unint64_t v6 = "14AudioInterface";
  if (((unint64_t)"14AudioInterface" & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)((unint64_t)"14AudioInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v29 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v29);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    xpc_object_t v26 = 0;
    xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v15 = v14;
    if (v14)
    {
      xpc_object_t v26 = v14;
    }
    else
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v26 = v15;
      if (!v15)
      {
        xpc_object_t v17 = xpc_null_create();
        xpc_object_t v15 = 0;
        goto LABEL_20;
      }
    }
    if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v15);
LABEL_21:
      xpc_release(v15);
      xpc_object_t v24 = xpc_BOOL_create(0);
      if (!v24) {
        xpc_object_t v24 = xpc_null_create();
      }
      long long v29 = 0uLL;
      uint64_t v30 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = v29;
      uint64_t v22 = v30;
      unint64_t v18 = __p;
      if (v30 < 0) {
        unint64_t v18 = (void **)__p[0];
      }
      v23[0] = &v26;
      v23[1] = v18;
      sub_100035E70((uint64_t)v23, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      if (SHIBYTE(v22) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_object_t v19 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v19 = xpc_null_create();
      }
      *(void *)&long long v29 = *a2;
      *((void *)&v29 + 1) = "kAudioVocoderInfo";
      sub_10014E03C((uint64_t)&v29, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_release(v26);
      goto LABEL_31;
    }
    xpc_object_t v17 = xpc_null_create();
LABEL_20:
    xpc_object_t v26 = v17;
    goto LABEL_21;
  }
LABEL_11:
  xpc_object_t v16 = (std::__shared_weak_count *)a2[1];
  uint64_t v27 = *a2;
  uint64_t v28 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 16))(v12, &v27);
  if (v28) {
    sub_10004D2C8(v28);
  }
LABEL_31:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2E2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21)
{
  if (*(char *)(v24 - 49) < 0) {
    operator delete(*(void **)(v24 - 72));
  }
  xpc_release(v22);
  xpc_release(object);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

void sub_100E2E328(Registry **a1@<X0>, xpc_object_t *a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  CFDictionaryRef v6 = (const __CFDictionary *)"14AudioInterface";
  if (((unint64_t)"14AudioInterface" & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)((unint64_t)"14AudioInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      CFDictionaryRef v6 = (const __CFDictionary *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  CFDictionaryRef theDict = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&theDict);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
      sub_10004D2C8(v11);
LABEL_9:
      sub_100A0D650(0);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v5);
    if (!v12) {
      goto LABEL_9;
    }
  }
  CFDictionaryRef theDict = 0;
  xpc_dictionary_get_value(*a2, "kAudioVocoderInfo");
  uint64_t v24 = _CFXPCCreateCFObjectFromXPCObject();
  sub_100084068(&theDict, (CFTypeRef *)&v24);
  Value = CFDictionaryGetValue(theDict, @"kCTAudioVocoderType");
  xpc_object_t v14 = Value;
  if (Value)
  {
    CFTypeID v15 = CFGetTypeID(Value);
    if (v15 != CFStringGetTypeID()) {
      xpc_object_t v14 = 0;
    }
  }
  CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCTAudioVocoderSampleRate");
  CFNumberRef v17 = v16;
  if (v16)
  {
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 != CFNumberGetTypeID()) {
      CFNumberRef v17 = 0;
    }
  }
  CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCTAudioVocoderI2SClockRate");
  CFNumberRef v20 = v19;
  if (v19)
  {
    CFTypeID v21 = CFGetTypeID(v19);
    if (v21 != CFNumberGetTypeID()) {
      CFNumberRef v20 = 0;
    }
  }
  uint64_t v22 = sub_100A0D9C8(v14);
  LODWORD(v24) = 0;
  if (v17)
  {
    if (CFNumberGetValue(v17, kCFNumberSInt32Type, &v24)) {
      CFNumberRef v17 = (const __CFNumber *)v24;
    }
    else {
      CFNumberRef v17 = 0;
    }
  }
  LODWORD(v24) = 0;
  if (v20)
  {
    if (CFNumberGetValue(v20, kCFNumberSInt32Type, &v24)) {
      uint64_t v23 = v24;
    }
    else {
      uint64_t v23 = 0;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, const __CFNumber *, uint64_t))(*(void *)v12 + 24))(v12, v22, v17, v23);
  sub_100057D78((const void **)&theDict);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100E2E56C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100E2E5A4()
{
  if (!v0) {
    JUMPOUT(0x100E2E598);
  }
  JUMPOUT(0x100E2E590);
}

uint64_t sub_100E2E5B0()
{
  return sub_100C624B8((uint64_t)&unk_101B12D4A, (uint64_t)sub_100E2BCAC);
}

void sub_100E2E5CC(NSObject **a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  char v7 = a5;
  char v8 = a3;
  char v11 = sub_100125CBC(a5 & ~a3, a4);
  if (v11)
  {
    object[1] = 0;
    uint64_t v12 = (void *)MAEGetActivationStateWithError();
    id v13 = 0;
    if ([v12 isEqualToString:kMAActivationStateActivated])
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B12D80, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(qword_101B12D80))
      {
        sub_100E2F744(buf);
        xmmword_101B12D90 = *(_OWORD *)buf;
        __cxa_atexit((void (*)(void *))sub_100E2F714, &xmmword_101B12D90, (void *)&_mh_execute_header);
        __cxa_guard_release(qword_101B12D80);
      }
      long long v14 = xmmword_101B12D90;
      if (*((void *)&xmmword_101B12D90 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B12D90 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      CFTypeID v15 = *a1;
      object[0] = v15;
      if (v15) {
        dispatch_retain(v15);
      }
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3321888768;
      v20[2] = sub_100E2EAB0;
      unint64_t v20[3] = &unk_101A5FB90;
      v20[4] = a2;
      char v23 = v8;
      sub_10095A7C0((uint64_t)v21, a6);
      char v24 = v7;
      CFNumberRef v16 = *a1;
      dispatch_object_t v22 = v16;
      if (v16) {
        dispatch_retain(v16);
      }
      xpc_object_t v26 = 0;
      v25[0] = off_101A5FCC0;
      v25[1] = objc_retainBlock(v20);
      xpc_object_t v26 = v25;
      (*(void (**)(void, void *, dispatch_object_t *, void *))(*(void *)v14 + 16))(v14, v11, object, v25);
      sub_100613154(v25);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      if (*((void *)&v14 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
      }
      if (v22) {
        dispatch_release(v22);
      }
      sub_100414310(v21);
    }
    else
    {
      sub_100E2E9C4();
      CFTypeID v18 = qword_101B12D70;
      if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&buf[4] = v12;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Device is not activated! activationState= %@, queryError= %@", buf, 0x16u);
      }
      sub_100E2EA58(*(void *)(a6 + 24), 0, 0x100000001);
    }
  }
  else
  {
    sub_100E2E9C4();
    CFNumberRef v17 = qword_101B12D70;
    if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "creating options for BAA cert generation failed", buf, 2u);
    }
    sub_100E2EA58(*(void *)(a6 + 24), 0, (uint64_t)&_mh_execute_header);
  }
}

void sub_100E2E92C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,dispatch_object_t object,uint64_t a24,char a25)
{
  __cxa_guard_abort(qword_101B12D80);

  _Unwind_Resume(a1);
}

void sub_100E2E9C4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12D78, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12D78))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12D70, kCtLoggingSystemName, (const char *)qword_101B12D68);
    __cxa_guard_release(&qword_101B12D78);
  }
}

void sub_100E2EA40(_Unwind_Exception *a1)
{
}

uint64_t sub_100E2EA58(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = a3;
  char v4 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(void *)a1 + 48))(a1, &v4, &v5);
}

void sub_100E2EAB0(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, void *a5, void *a6)
{
  id v9 = a5;
  id v10 = a6;
  v36[0] = a4;
  if (a4) {
    CFRetain(a4);
  }
  uint64_t v32 = 0;
  char v33 = &v32;
  uint64_t v34 = 0x2020000000;
  int v35 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x5012000000;
  uint64_t v27 = sub_100E2EF2C;
  uint64_t v28 = sub_100E2EF50;
  long long v29 = "";
  *(_OWORD *)long long __p = 0u;
  long long v31 = 0u;
  if (v10)
  {
    sub_100E2E9C4();
    char v11 = qword_101B12D70;
    if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v41 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Getting DeviceIdentityCertificate failed w/ %{public}@", buf, 0xCu);
    }
    uint64_t v12 = objc_msgSend(v10, "localizedDescription", v24);
    id v13 = v12;
    if (v12) {
      long long v14 = (char *)[v12 UTF8String];
    }
    else {
      long long v14 = "Getting DeviceIdentityCertificate failed w/ null error";
    }
    sub_10003ED78((std::string *)(v25 + 7), v14);
    *((_DWORD *)v33 + 6) = 2;
    sub_100E2EF64((char *)v25 + 48, *(Registry ***)(a1 + 32));

    goto LABEL_17;
  }
  if (!v9 || objc_msgSend(v9, "count", v24) != (id)2)
  {
LABEL_17:
    uint64_t v16 = *(void *)(a1 + 64);
    if (!v16) {
      goto LABEL_20;
    }
    char v18 = 0;
    unint64_t v17 = *((unsigned int *)v33 + 6) | (unint64_t)&_mh_execute_header;
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    sub_100E2E9C4();
    CFTypeID v15 = qword_101B12D70;
    if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I BAA fetch for update baseband successful", buf, 2u);
    }
    uint64_t v16 = *(void *)(a1 + 64);
    if (v16)
    {
      unint64_t v17 = 0;
      char v18 = 1;
LABEL_19:
      sub_100E2EA58(v16, v18, v17);
    }
  }
  else
  {
    *((unsigned char *)v25 + 48) = 1;
    uint64_t v38 = kMAOptionsUseCellularOTAConnection;
    CFNumberRef v19 = &__kCFBooleanTrue;
    if (!*(unsigned char *)(a1 + 81)) {
      CFNumberRef v19 = &__kCFBooleanFalse;
    }
    uint64_t v39 = v19;
    CFNumberRef v20 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    CFTypeID v21 = +[NSMutableDictionary dictionaryWithDictionary:v20];

    dispatch_object_t v22 = [v9 objectAtIndexedSubscript:0];
    char v23 = [v9 objectAtIndexedSubscript:1];
    v36[1] = _NSConcreteStackBlock;
    v36[2] = (const void *)3321888768;
    v36[3] = sub_100E2F490;
    v36[4] = &unk_101A5FB60;
    v36[5] = &v24;
    v36[6] = &v32;
    v36[7] = *(const void **)(a1 + 32);
    sub_10095A7C0((uint64_t)v37, a1 + 40);
    MAEUpdateBasebandTicketWithError();

    sub_100414310(v37);
  }
LABEL_20:
  _Block_object_dispose(&v24, 8);
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[1]);
  }
  _Block_object_dispose(&v32, 8);
  sub_100127DDC(v36);
}

void sub_100E2EE78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,const void *a26)
{
  sub_100414310(v31);

  _Block_object_dispose(&a9, 8);
  if (a21 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a22, 8);
  sub_100127DDC(&a26);

  _Unwind_Resume(a1);
}

__n128 sub_100E2EF2C(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  __n128 result = *(__n128 *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(__n128 *)(a1 + 56) = result;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_100E2EF50(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
}

void sub_100E2EF64(char *a1, Registry **a2)
{
  if (*a1) {
    BOOL v3 = a1[1] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    goto LABEL_35;
  }
  memset(&v31[1], 0, 32);
  long long v32 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  memset(&v34, 0, sizeof(v34));
  long long v33 = 0u;
  uint64_t v35 = 23;
  qmemcpy((char *)&v31[2] + 7, "\tActivation Push", 16);
  LOBYTE(v31[1]) = 121;
  v31[0] = *(void **)"Telephony";
  BYTE7(v32) = 15;
  sub_10003ECB8((std::string *)((char *)&v32 + 8), "BB ticket update failure", 0x18uLL);
  std::string::operator=(&v34, (const std::string *)(a1 + 8));
  v35 |= 0x11uLL;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  CFDictionaryRef v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v38 = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, &v38);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_14:
  sub_1000DB86C((char *)v21, (long long *)v31);
  v39[0] = off_101A5FC20;
  v39[3] = v39;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v13 + 16))(v13, v21, v39);
  sub_1000DBADC(v39);
  if (v30 < 0) {
    operator delete(__p);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v22 < 0)
  {
    operator delete(v21[0]);
    if (v14) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if ((v14 & 1) == 0) {
LABEL_24:
  }
    sub_10004D2C8(v12);
LABEL_25:
  if (SBYTE7(v37) < 0) {
    operator delete((void *)v36);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(*((void **)&v32 + 1));
  }
  if (SBYTE7(v32) < 0) {
    operator delete(v31[3]);
  }
  if (SHIBYTE(v31[2]) < 0) {
    operator delete(v31[0]);
  }
LABEL_35:
  v31[0] = _NSConcreteStackBlock;
  v31[1] = (void *)3221225472;
  v31[2] = sub_100E2FA4C;
  v31[3] = &unk_101A5FC90;
  v31[4] = a1;
  CFTypeID v15 = v31;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v15);
  unint64_t v17 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8012Eu);
  unint64_t v38 = (unint64_t)v17;
  if (v17)
  {
    char v18 = sub_10001C8F4(8);
    uint64_t v20 = *v18;
    CFNumberRef v19 = (std::__shared_weak_count *)v18[1];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v20) {
      operator new();
    }
    if (v19) {
      sub_10004D2C8(v19);
    }
    wis::MetricContainer::~MetricContainer(v17);
    operator delete();
  }
}

void sub_100E2F39C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)(v3 - 112), 0);

  _Unwind_Resume(a1);
}

void sub_100E2F490(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v3)
  {
    *(unsigned char *)(v4 + 49) = 0;
    sub_100E2E9C4();
    uint64_t v5 = qword_101B12D70;
    if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_ERROR))
    {
      int v11 = 138543362;
      id v12 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Getting new baseband ticket failed w/ %{public}@", (uint8_t *)&v11, 0xCu);
    }
    CFDictionaryRef v6 = [v3 localizedDescription];
    unint64_t v7 = v6;
    if (v6) {
      char v8 = (char *)[v6 UTF8String];
    }
    else {
      char v8 = "Getting new baseband ticket failed w/ null error";
    }
    sub_10003ED78((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 56), v8);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 3;
  }
  else
  {
    *(unsigned char *)(v4 + 49) = 1;
    sub_100E2E9C4();
    uint64_t v9 = qword_101B12D70;
    if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Received new baseband ticket successfully", (uint8_t *)&v11, 2u);
    }
  }
  sub_100E2EF64((char *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), *(Registry ***)(a1 + 48));
  uint64_t v10 = *(void *)(a1 + 80);
  if (v10) {
    sub_100E2EA58(v10, v3 == 0, *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) | (unint64_t)&_mh_execute_header);
  }
}

void sub_100E2F638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E2F668(uint64_t a1, uint64_t a2)
{
  return sub_10095A7C0(a1 + 56, a2 + 56);
}

void *sub_100E2F674(uint64_t a1)
{
  return sub_100414310((void *)(a1 + 56));
}

void sub_100E2F67C(uint64_t a1, uint64_t a2)
{
  sub_10095A7C0(a1 + 40, a2 + 40);
  uint64_t v4 = *(NSObject **)(a2 + 72);
  *(void *)(a1 + 72) = v4;
  if (v4)
  {
    dispatch_retain(v4);
  }
}

void *sub_100E2F6D4(uint64_t a1)
{
  id v2 = *(NSObject **)(a1 + 72);
  if (v2) {
    dispatch_release(v2);
  }

  return sub_100414310((void *)(a1 + 40));
}

uint64_t sub_100E2F714(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void *sub_100E2F744@<X0>(void *a1@<X8>)
{
  id v2 = operator new(0x38uLL);
  __n128 result = sub_100E2F790(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_100E2F77C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100E2F790(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A5FBD0;
  sub_100612638(a1 + 3);
  return a1;
}

void sub_100E2F7D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100E2F7EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FBD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E2F80C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A5FBD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E2F860(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100E2F88C()
{
}

void *sub_100E2F8A0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A5FC20;
  return result;
}

void sub_100E2F8D8(uint64_t a1, void *a2)
{
  *a2 = off_101A5FC20;
}

void sub_100E2F900(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v3 = *a2;
  uint64_t v4 = *(void **)a3;
  int v5 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  sub_100E2E9C4();
  CFDictionaryRef v6 = qword_101B12D70;
  if (!os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_ERROR))
  {
    if ((v5 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_3;
  }
  unint64_t v7 = "success";
  if (!v3) {
    unint64_t v7 = "failed";
  }
  int v8 = 136315138;
  uint64_t v9 = v7;
  _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "ABC report %s for BB ticket update failure", (uint8_t *)&v8, 0xCu);
  if (v5 < 0) {
LABEL_3:
  }
    operator delete(v4);
}

void sub_100E2F9E8(_Unwind_Exception *exception_object)
{
  if (v2 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E2FA00(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A5FC80)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E2FA40()
{
  return &off_101A5FC80;
}

void sub_100E2FA4C(uint64_t a1, uint64_t a2)
{
  sub_100E2E9C4();
  uint64_t v4 = qword_101B12D70;
  if (os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(unsigned char **)(a1 + 32);
    if (*v5) {
      CFDictionaryRef v6 = "";
    }
    else {
      CFDictionaryRef v6 = "not ";
    }
    if (v5[1]) {
      unint64_t v7 = "";
    }
    else {
      unint64_t v7 = "not ";
    }
    int v15 = 136315394;
    uint64_t v16 = v6;
    __int16 v17 = 2080;
    char v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending update ticket AWD metric: BAA is %ssuccessful, Ticket update is %ssuccessful", (uint8_t *)&v15, 0x16u);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v8 + 1) || !*(unsigned char *)v8)
  {
    if (*(char *)(v8 + 31) < 0)
    {
      if (!*(void *)(v8 + 16)) {
        goto LABEL_21;
      }
    }
    else if (!*(unsigned char *)(v8 + 31))
    {
      goto LABEL_21;
    }
    *(_DWORD *)(a2 + 32) |= 2u;
    uint64_t v9 = *(std::string **)(a2 + 16);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v9, (const std::string *)(v8 + 8));
    sub_100E2E9C4();
    uint64_t v10 = qword_101B12D70;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_101B12D70, OS_LOG_TYPE_DEFAULT);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v11)
    {
      id v12 = (const char *)(v8 + 8);
      if (*(char *)(v8 + 31) < 0) {
        id v12 = *(const char **)v12;
      }
      int v15 = 136315138;
      uint64_t v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I AWD metric has failure reason: %s", (uint8_t *)&v15, 0xCu);
      uint64_t v8 = *(void *)(a1 + 32);
    }
  }
LABEL_21:
  int v13 = *(_DWORD *)(a2 + 32);
  *(unsigned char *)(a2 + 25) = *(unsigned char *)v8;
  char v14 = *(unsigned char *)(v8 + 1);
  *(_DWORD *)(a2 + 32) = v13 | 0xC;
  *(unsigned char *)(a2 + 24) = v14;
}

uint64_t sub_100E2FC3C(uint64_t a1)
{
  return a1;
}

void sub_100E2FC68(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100E2FCB4()
{
  return 0;
}

id sub_100E2FCBC(uint64_t a1, void *a2)
{
  *a2 = off_101A5FCC0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E2FD04(uint64_t a1)
{
  char v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

const void **sub_100E2FD14(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v5 = *a3;
  *a3 = 0;
  (*(void (**)(void))(v3 + 16))();
  return sub_100030068(&v5);
}

void sub_100E2FD70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100030068((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100E2FD84(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A5FD30)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E2FDC4()
{
  return &off_101A5FD30;
}

void sub_100E2FDD0()
{
  qword_101B12D68 = sGetLogGroupName();
}

void sub_100E30100(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E3061C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25,uint64_t a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E309FC(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E30CC8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E30F64(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E31350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E317B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }

  _Unwind_Resume(a1);
}

void sub_100E31BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E32018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E32478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }

  _Unwind_Resume(a1);
}

void sub_100E328A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E32CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E33140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }

  _Unwind_Resume(a1);
}

void sub_100E33570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100E33A1C(_Unwind_Exception *a1)
{
  CFDictionaryRef v6 = v1;

  if ((v3 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_100E33B2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (!a24) {
    JUMPOUT(0x100E33B1CLL);
  }
  JUMPOUT(0x100E33B18);
}

uint64_t sub_100E33B40(uint64_t a1)
{
  return a1;
}

void sub_100E33B74(uint64_t a1)
{
  operator delete();
}

void *sub_100E33BC8(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  void *v2 = off_101A5FD50;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100E33C2C(uint64_t a1, void *a2)
{
  *a2 = off_101A5FD50;
  a2[1] = objc_retainBlock(*(id *)(a1 + 8));
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100E33C84(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
}

void sub_100E33CC0(id *a1)
{
  operator delete(a1);
}

void sub_100E33D04(uint64_t a1, id *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  id v5 = *a2;
  CFDictionaryRef v6 = v5;
  if ((v4 & 0xFF00000000) != 0)
  {
    id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:(int)v4 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
  else
  {
    if (v5)
    {
      id v7 = 0;
    }
    else
    {
      uint64_t v8 = *(void **)(a1 + 16);
      if (v8)
      {
        [v8 getLogContext];
        uint64_t v9 = v11;
      }
      else
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        BOOL v11 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v10) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Got empty data usage", (uint8_t *)&v10, 2u);
      }
      id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    }
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
}

void sub_100E33E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E33E74(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A5FDB0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E33EB4()
{
  return &off_101A5FDB0;
}

uint64_t sub_100E33EC0(uint64_t a1)
{
  return a1;
}

void sub_100E33EF4(uint64_t a1)
{
  operator delete();
}

void *sub_100E33F48(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  void *v2 = off_101A5FDD0;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100E33FAC(uint64_t a1, void *a2)
{
  *a2 = off_101A5FDD0;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100E34004(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
}

void sub_100E34040(id *a1)
{
  operator delete(a1);
}

void sub_100E34084(uint64_t a1, xpc_object_t **a2)
{
  char v3 = *a2;
  if (!*a2)
  {
    uint64_t v5 = 2;
    goto LABEL_5;
  }
  if (xpc_dictionary_get_value(*v3, "kPosixError"))
  {
    *(void *)long long buf = v3;
    *(void *)&uint8_t buf[8] = "kPosixError";
    sub_100048BAC((uint64_t)buf, &object);
    uint64_t v5 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
    xpc_release(object);
LABEL_5:
    CFDictionaryRef v6 = *(void **)(a1 + 8);
    if (v6)
    {
      [v6 getLogContext];
      id v7 = *(NSObject **)&buf[8];
    }
    else
    {
      id v7 = 0;
      *(_OWORD *)long long buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "failed to retrieve active paired device data usage, error: %lu", buf, 0xCu);
    }
    uint64_t v8 = (uint64_t)[objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v5 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
    goto LABEL_24;
  }
  xpc_object_t object = 0;
  data = xpc_dictionary_get_data(*v3, "kDeviceDataUsage", (size_t *)&object);
  if (!data)
  {
    uint64_t v10 = 0;
    goto LABEL_15;
  }
  uint64_t v10 = +[NSData dataWithBytes:data length:object];
  if (!v10)
  {
LABEL_15:
    uint64_t v8 = 0;
    unint64_t v11 = 0;
    goto LABEL_16;
  }
  id v15 = 0;
  uint64_t v8 = +[NSKeyedUnarchiver unarchivedObjectOfClass:objc_opt_class() fromData:v10 error:&v15];
  unint64_t v11 = (unint64_t)v15;
LABEL_16:
  if (!(v8 | v11))
  {
    id v12 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:94 userInfo:0];
    int v13 = *(void **)(a1 + 8);
    if (v13)
    {
      [v13 getLogContext];
      char v14 = *(NSObject **)&buf[8];
    }
    else
    {
      char v14 = 0;
      *(_OWORD *)long long buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "failed to retrieve active paired device data usage, error: %@", buf, 0xCu);
    }
    unint64_t v11 = (unint64_t)v12;
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();

LABEL_24:
}

void sub_100E34364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E343CC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A5FE30)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E3440C()
{
  return &off_101A5FE30;
}

void sub_100E34418(void *a1@<X0>, void *a2@<X1>, __n128 *a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v33 = NSLocalizedDescriptionKey;
      CFStringRef v34 = @"Message is nil";
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:&v34 forKeys:&v33 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
    }
    goto LABEL_11;
  }
  if ((unint64_t)[v5 conversationID] >= 0x100)
  {
    if (a2)
    {
      NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
      CFStringRef v32 = @"Invalid ConversationID";
      uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v10];
    }
    goto LABEL_11;
  }
  uint64_t v7 = (uint64_t)[v6 sequenceNum];
  if (v7 < 0
    || (uint64_t)+[CTStewieEmergencyTextMessage maxSequenceNum] < v7)
  {
    if (a2)
    {
      NSErrorUserInfoKey v29 = NSLocalizedDescriptionKey;
      CFStringRef v30 = @"Invalid SequenceNum";
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v8];
    }
LABEL_11:
    a3->n128_u8[0] = 0;
    a3[5].n128_u8[0] = 0;
    goto LABEL_12;
  }
  unint64_t v11 = [v6 text];

  if (!v11)
  {
    if (a2)
    {
      NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
      CFStringRef v28 = @"Text is missing";
      id v15 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v15];
    }
    goto LABEL_11;
  }
  id v12 = [v6 text];
  int v13 = (char *)[v12 lengthOfBytesUsingEncoding:4];

  if (!v13
    || (uint64_t)v13 > (uint64_t)+[CTStewieEmergencyTextMessage maxLengthInBytesForOutgoingText])
  {
    if (a2)
    {
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      CFStringRef v26 = @"Invalid text length";
      char v14 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v14];
    }
    goto LABEL_11;
  }
  v20.n128_u64[1] = 0x300000001;
  uint64_t __p = 512;
  v20.n128_u64[0] = (unint64_t)off_1019BDE00;
  CFTypeID v21 = &unk_1019BDEA8;
  char v24 = 0;
  memset(__p_8, 0, sizeof(__p_8));
  BYTE2(__p) = [v6 conversationID];
  WORD2(__p) = (unsigned __int16)[v6 sequenceNum];
  id v16 = [v6 text];
  __int16 v17 = (char *)[v16 UTF8String];

  long long v18 = 0uLL;
  uint64_t v19 = 0;
  sub_10014BD54((char *)&v18, v17, &v13[(void)v17], (size_t)v13);
  if (*(void *)__p_8)
  {
    *(void *)&__p_8[8] = *(void *)__p_8;
    operator delete(*(void **)__p_8);
  }
  *(_OWORD *)__p_8 = v18;
  *(void *)&__p_8[16] = v19;
  sub_100E38884(a3, &v20);
  v20.n128_u64[0] = (unint64_t)off_1019BDE00;
  CFTypeID v21 = &unk_1019BDEA8;
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (*(void *)__p_8)
  {
    *(void *)&__p_8[8] = *(void *)__p_8;
    operator delete(*(void **)__p_8);
  }
LABEL_12:
}

void sub_100E34A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10036C89C((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_100E34AD8(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v29 = NSLocalizedDescriptionKey;
      CFStringRef v30 = @"Message is nil";
      __int16 v17 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v17];
    }
    goto LABEL_20;
  }
  if ((unint64_t)[v5 conversationID] >= 0x100)
  {
    if (a2)
    {
      NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
      CFStringRef v28 = @"Invalid ConversationID";
      long long v18 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v18];
    }
LABEL_20:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 64) = 0;
    goto LABEL_21;
  }
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v23 = 0x100000001;
  char v22 = off_1019BDAD8;
  char v24 = &unk_1019BDB80;
  LODWORD(v25[0]) = 33554688;
  LOBYTE(v25[1]) = 0;
  BYTE2(v25[0]) = [v6 conversationID];
  uint64_t v7 = [v6 serializedQuestionnaireAnswers];
  BOOL v8 = v7 == 0;

  if (!v8)
  {
    id v19 = [v6 serializedQuestionnaireAnswers];
    id v9 = [v19 bytes];
    id v10 = [v6 serializedQuestionnaireAnswers];
    id v11 = [v10 bytes];
    id v12 = [v6 serializedQuestionnaireAnswers];
    int v13 = (char *)[v12 length];
    __n128 __p = 0uLL;
    uint64_t v21 = 0;
    sub_1001E7940(&__p, v9, (uint64_t)&v13[(void)v11], &v13[(void)v11] - (char *)v9);
    sub_100195D74((uint64_t)&v25[1], &__p);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
  }
  id v14 = [v6 notifyOption];
  int v15 = 2 * (v14 != (id)1);
  if (v14 == (id)3) {
    int v15 = 1;
  }
  if (v15 == 2) {
    LOBYTE(v15) = 0;
  }
  BYTE3(v25[0]) = v15;
  *(void *)a3 = off_1019BDC60;
  *(void *)a3 = off_1019BDC60;
  *(void *)(a3 + 8) = v23;
  *(void *)(a3 + 16) = &unk_1019BDCD8;
  *(void *)a3 = &off_1019BDD78;
  *(void *)a3 = off_1019BDAD8;
  *(void *)(a3 + 16) = &unk_1019BDB80;
  *(_DWORD *)(a3 + 24) = v25[0];
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  int v16 = v26;
  if ((_BYTE)v26)
  {
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v25[1];
    *(void **)(a3 + 48) = v25[3];
    memset(&v25[1], 0, 24);
    *(unsigned char *)(a3 + 56) = 1;
  }
  *(unsigned char *)(a3 + 64) = 1;
  char v22 = off_1019BDAD8;
  char v24 = &unk_1019BDB80;
  if (v16 && v25[1])
  {
    v25[2] = v25[1];
    operator delete(v25[1]);
  }
LABEL_21:
}

void sub_100E350B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(a1);
}

void sub_100E3513C(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
      CFStringRef v28 = @"Message is nil";
      __int16 v17 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v17];
    }
    goto LABEL_11;
  }
  uint64_t v7 = [v5 encryptedData];
  if (!v7
    || ([v6 encryptedData],
        BOOL v8 = objc_claimAutoreleasedReturnValue(),
        id v9 = [v8 length],
        v8,
        v7,
        !v9))
  {
    if (a2)
    {
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      CFStringRef v26 = @"Data provided is either nil or empty";
      int v16 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v16];
    }
LABEL_11:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 56) = 0;
    goto LABEL_12;
  }
  uint64_t __p = 1024;
  uint64_t v21 = 0x500000004;
  __n128 v20 = off_1019ADF38;
  char v22 = &unk_1019ADFE0;
  memset(__p_8, 0, sizeof(__p_8));
  id v10 = [v6 encryptedData];
  id v11 = [v10 bytes];
  id v12 = [v6 encryptedData];
  id v13 = [v12 bytes];
  id v14 = [v6 encryptedData];
  int v15 = (char *)[v14 length];
  long long v18 = 0uLL;
  uint64_t v19 = 0;
  sub_1001E7940(&v18, v11, (uint64_t)&v15[(void)v13], &v15[(void)v13] - (char *)v11);
  if (*(void *)__p_8)
  {
    *(void *)&__p_8[8] = *(void *)__p_8;
    operator delete(*(void **)__p_8);
  }
  *(_OWORD *)__p_8 = v18;
  *(void *)&__p_8[16] = v19;
  uint64_t v19 = 0;
  long long v18 = 0uLL;

  *(void *)a3 = off_1019AE0C0;
  *(void *)a3 = off_1019AE0C0;
  *(void *)(a3 + 8) = v21;
  *(void *)(a3 + 16) = &unk_1019AE138;
  *(void *)a3 = &off_1019AE1D8;
  *(void *)a3 = off_1019ADF38;
  *(void *)(a3 + 16) = &unk_1019ADFE0;
  *(_WORD *)(a3 + 24) = __p;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)__p_8;
  *(void *)(a3 + 48) = *(void *)&__p_8[16];
  *(unsigned char *)(a3 + 56) = 1;
LABEL_12:
}

void sub_100E3560C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E35688(void *a1@<X0>, void *a2@<X1>, __n128 *a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
      CFStringRef v37 = @"Message is nil";
      id v9 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v9];
    }
    goto LABEL_11;
  }
  if ((unint64_t)[v5 conversationID] >= 0x100)
  {
    if (a2)
    {
      NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
      CFStringRef v35 = @"Invalid ConversationID";
      id v10 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v10];
    }
    goto LABEL_11;
  }
  uint64_t v7 = (uint64_t)[v6 sequenceNum];
  if (v7 < 0
    || (uint64_t)+[CTStewieEmergencyTextMessage maxSequenceNum] < v7)
  {
    if (a2)
    {
      NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
      CFStringRef v33 = @"Invalid SequenceNum";
      BOOL v8 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v8];
    }
LABEL_11:
    a3->n128_u8[0] = 0;
    a3[5].n128_u8[0] = 0;
    goto LABEL_12;
  }
  if ((unint64_t)[v6 providerId] >= 0x8000)
  {
    if (a2)
    {
      NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
      CFStringRef v31 = @"Invalid providerId";
      int v15 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v15];
    }
    goto LABEL_11;
  }
  id v11 = [v6 text];

  if (!v11)
  {
    if (a2)
    {
      NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
      CFStringRef v29 = @"Text is missing";
      int v16 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v16];
    }
    goto LABEL_11;
  }
  id v12 = [v6 text];
  id v13 = (char *)[v12 lengthOfBytesUsingEncoding:4];

  if (!v13
    || (uint64_t)v13 > (uint64_t)+[CTStewieRoadsideTextMessage maxLengthInBytesForOutgoingText])
  {
    if (a2)
    {
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      CFStringRef v27 = @"Invalid text length";
      id v14 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v14];
    }
    goto LABEL_11;
  }
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  *(_OWORD *)uint64_t __p = 0u;
  __n128 v21 = 0u;
  sub_100E35B98((uint64_t)&v21);
  BYTE10(v22) = [v6 conversationID];
  WORD6(v22) = (unsigned __int16)[v6 providerId];
  HIWORD(v22) = (unsigned __int16)[v6 sequenceNum];
  id v17 = [v6 text];
  long long v18 = (char *)[v17 UTF8String];

  long long v19 = 0uLL;
  uint64_t v20 = 0;
  sub_10014BD54((char *)&v19, v18, &v13[(void)v18], (size_t)v13);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)uint64_t __p = v19;
  *(void *)&long long v24 = v20;
  sub_100E38A28(a3, &v21);
  sub_100E35D18(&v21);
LABEL_12:
}

void sub_100E35B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100E35D18((uint64_t *)va);

  _Unwind_Resume(a1);
}

uint64_t sub_100E35B98(uint64_t result)
{
  *(void *)id result = off_101A91328;
  *(void *)id result = off_101A91328;
  *(_WORD *)(result + 8) = 8;
  *(_DWORD *)(result + 12) = 8;
  *(void *)(result + 16) = &unk_101A913A0;
  *(void *)id result = &off_101A91440;
  *(void *)id result = off_101A911A0;
  *(void *)(result + 16) = &unk_101A91248;
  *(_WORD *)(result + 24) = 1792;
  *(unsigned char *)(result + 26) = 0;
  *(unsigned char *)(result + 60) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 28) = 0;
  *(void *)(result + 44) = 0;
  *(void *)(result + 36) = 0;
  *(void *)(result + 49) = 0;
  return result;
}

void *sub_100E35D18(void *a1)
{
  *a1 = off_101A911A0;
  *a1 = off_101A911A0;
  a1[2] = &unk_101A91248;
  int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100E35E18(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      CFStringRef v41 = @"Message is nil";
      uint64_t v23 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v23];
    }
    goto LABEL_30;
  }
  if ((unint64_t)[v5 conversationID] >= 0x100)
  {
    if (a2)
    {
      NSErrorUserInfoKey v38 = NSLocalizedDescriptionKey;
      CFStringRef v39 = @"Invalid ConversationID";
      long long v24 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v24];
    }
    goto LABEL_30;
  }
  if ((unint64_t)[v6 providerId] >= 0x8000)
  {
    if (a2)
    {
      NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
      CFStringRef v37 = @"Invalid providerId";
      long long v25 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v25];
    }
    goto LABEL_30;
  }
  uint64_t v7 = [v6 phoneNumber];
  if (v7)
  {
    BOOL v8 = [v6 phoneNumber];
    unsigned __int8 v9 = sub_100E36698(v8, 0);

    if ((v9 & 1) == 0)
    {
      if (a2)
      {
        NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
        CFStringRef v35 = @"phoneNumber is invalid. Phone number can only contain digits and must be of length <= 15";
        NSErrorUserInfoKey v26 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
        *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v26];
      }
LABEL_30:
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 96) = 0;
      goto LABEL_31;
    }
  }
  uint64_t v33 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v30 = 0x600000008;
  CFStringRef v29 = off_101A90E78;
  CFStringRef v31 = &unk_101A90F20;
  LOWORD(v32[0]) = 1536;
  LOBYTE(v32[1]) = 0;
  LOBYTE(v32[5]) = 0;
  BYTE2(v32[0]) = [v6 conversationID];
  WORD2(v32[0]) = (unsigned __int16)[v6 providerId];
  BYTE6(v32[0]) = [v6 isPayPerUse];
  id v10 = [v6 serializedQuestionnaireAnswers];
  BOOL v11 = v10 == 0;

  if (!v11)
  {
    id v12 = [v6 serializedQuestionnaireAnswers];
    id v13 = [v12 bytes];
    id v14 = [v6 serializedQuestionnaireAnswers];
    id v15 = [v14 bytes];
    int v16 = [v6 serializedQuestionnaireAnswers];
    id v17 = (char *)[v16 length];
    __n128 __p = 0uLL;
    uint64_t v28 = 0;
    sub_1001E7940(&__p, v13, (uint64_t)&v17[(void)v15], &v17[(void)v15] - (char *)v13);
    sub_100195D74((uint64_t)&v32[5], &__p);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
  }
  long long v18 = [v6 phoneNumber];
  BOOL v19 = v18 == 0;

  if (!v19)
  {
    id v20 = [v6 phoneNumber];
    __p.n128_u64[0] = (unint64_t)[v20 UTF8String];
    sub_1000791C0((std::string *)&v32[1], (char **)&__p);
  }
  *(void *)a3 = off_101A91000;
  *(void *)a3 = off_101A91000;
  *(void *)(a3 + 8) = v30;
  *(void *)(a3 + 16) = &unk_101A91078;
  *(void *)a3 = &off_101A91118;
  *(void *)a3 = off_101A90E78;
  *(void *)(a3 + 16) = &unk_101A90F20;
  *(_DWORD *)(a3 + 24) = v32[0];
  *(_DWORD *)(a3 + 27) = *(_DWORD *)((char *)v32 + 3);
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  int v21 = LOBYTE(v32[4]);
  if (LOBYTE(v32[4]))
  {
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v32[1];
    *(void **)(a3 + 48) = v32[3];
    memset(&v32[1], 0, 24);
    *(unsigned char *)(a3 + 56) = 1;
  }
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  int v22 = v33;
  if ((_BYTE)v33)
  {
    *(_OWORD *)(a3 + 64) = *(_OWORD *)&v32[5];
    *(void **)(a3 + 80) = v32[7];
    memset(&v32[5], 0, 24);
    *(unsigned char *)(a3 + 88) = 1;
  }
  *(unsigned char *)(a3 + 96) = 1;
  CFStringRef v29 = off_101A90E78;
  CFStringRef v31 = &unk_101A90F20;
  if (v22 && v32[5])
  {
    v32[6] = v32[5];
    operator delete(v32[5]);
    int v21 = LOBYTE(v32[4]);
  }
  if (v21 && SHIBYTE(v32[3]) < 0) {
    operator delete(v32[1]);
  }
LABEL_31:
}

void sub_100E365D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(a1);
}

id sub_100E36698(void *a1, int a2)
{
  id v3 = a1;
  unint64_t v4 = v3;
  if (a2 && [v3 hasPrefix:@"+"])
  {
    uint64_t v5 = [v4 substringFromIndex:1];

    unint64_t v4 = (void *)v5;
  }
  if (v4 && [v4 length] && (unint64_t)objc_msgSend(v4, "length") <= 0xF)
  {
    CFDictionaryRef v6 = +[NSCharacterSet decimalDigitCharacterSet];
    uint64_t v7 = +[NSCharacterSet characterSetWithCharactersInString:v4];
    id v8 = [v6 isSupersetOfSet:v7];
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_100E3676C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E36794(uint64_t a1)
{
  *(void *)a1 = off_101A90E78;
  *(void *)a1 = off_101A90E78;
  *(void *)(a1 + 16) = &unk_101A90F20;
  if (*(unsigned char *)(a1 + 88))
  {
    int v2 = *(void **)(a1 + 64);
    if (v2)
    {
      *(void *)(a1 + 72) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

void sub_100E368A8(void *a1@<X0>, void *a2@<X1>, unsigned char *a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
      CFStringRef v50 = @"Message is nil";
      id v17 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v17];
    }
    goto LABEL_23;
  }
  uint64_t v7 = [v5 myShortHandle];
  BOOL v8 = sub_100E36EF8(v7);

  if (!v8)
  {
    if (a2)
    {
      NSErrorUserInfoKey v47 = NSLocalizedDescriptionKey;
      CFStringRef v48 = @"Invalid myShortHandle";
      long long v18 = +[NSDictionary dictionaryWithObjects:&v48 forKeys:&v47 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v18];
    }
    goto LABEL_23;
  }
  unsigned __int8 v9 = [v6 otherShortHandle];
  BOOL v10 = sub_100E36EF8(v9);

  if (!v10)
  {
    if (a2)
    {
      NSErrorUserInfoKey v45 = NSLocalizedDescriptionKey;
      CFStringRef v46 = @"Invalid otherShortHandle";
      BOOL v19 = +[NSDictionary dictionaryWithObjects:&v46 forKeys:&v45 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v19];
    }
    goto LABEL_23;
  }
  if ((char *)[v6 partNumber] - 1 >= (char *)4)
  {
    if (a2)
    {
      NSErrorUserInfoKey v43 = NSLocalizedDescriptionKey;
      CFStringRef v44 = @"Invalid partNumber";
      id v20 = +[NSDictionary dictionaryWithObjects:&v44 forKeys:&v43 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v20];
    }
    goto LABEL_23;
  }
  if ((char *)[v6 totalParts] - 1 >= (char *)4)
  {
    if (a2)
    {
      NSErrorUserInfoKey v41 = NSLocalizedDescriptionKey;
      CFStringRef v42 = @"Invalid totalParts";
      int v21 = +[NSDictionary dictionaryWithObjects:&v42 forKeys:&v41 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v21];
    }
    goto LABEL_23;
  }
  BOOL v11 = [v6 payload];
  if (!v11
    || ([v6 payload],
        id v12 = objc_claimAutoreleasedReturnValue(),
        id v13 = [v12 length],
        v12,
        v11,
        !v13))
  {
    if (a2)
    {
      NSErrorUserInfoKey v39 = NSLocalizedDescriptionKey;
      CFStringRef v40 = @"Payload is missing";
      int v22 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v22];
    }
    goto LABEL_23;
  }
  id v14 = [v6 payload];
  id v15 = [v14 length];

  if ((unint64_t)v15 >= 0x94)
  {
    if (a2)
    {
      NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
      CFStringRef v38 = @"Payload is too big";
      int v16 = +[NSDictionary dictionaryWithObjects:&v38 forKeys:&v37 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v16];
    }
LABEL_23:
    *a3 = 0;
    a3[104] = 0;
    goto LABEL_24;
  }
  uint64_t v36 = 0;
  *(_OWORD *)__n128 __p = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  memset(v31, 0, sizeof(v31));
  sub_100E36F5C((uint64_t)v31);
  uint64_t v23 = [v6 myShortHandle];
  *(void *)&long long v32 = [v23 unsignedLongLongValue];

  long long v24 = [v6 otherShortHandle];
  *((void *)&v32 + 1) = [v24 unsignedLongLongValue];

  *(void *)&long long v33 = [v6 partNumber];
  *((void *)&v33 + 1) = [v6 totalParts];
  id v25 = [v6 payload];
  id v26 = [v25 bytes];

  CFStringRef v27 = [v6 payload];
  id v28 = [v27 length];
  long long v29 = 0uLL;
  uint64_t v30 = 0;
  sub_1001E7940(&v29, v26, (uint64_t)v28 + (void)v26, (size_t)v28);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)__n128 __p = v29;
  *(void *)&long long v35 = v30;
  uint64_t v30 = 0;
  long long v29 = 0uLL;

  sub_100E38BC0((uint64_t)a3, (uint64_t)v31);
  sub_1004A425C(v31);
LABEL_24:
}

void sub_100E36E1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100E36EF8(void *a1)
{
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    [v1 unsignedLongLongValue];
    BOOL v3 = (unint64_t)[v2 unsignedLongLongValue] >> 57 == 0;
  }
  else
  {
    BOOL v3 = 0;
  }

  return v3;
}

void sub_100E36F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E36F5C(uint64_t a1)
{
  *(void *)a1 = off_1019D29A8;
  *(void *)a1 = off_1019D29A8;
  *(_WORD *)(a1 + 8) = 16;
  *(_DWORD *)(a1 + 12) = 13;
  *(void *)(a1 + 16) = &unk_1019D2A20;
  *(void *)a1 = &off_1019D2AC0;
  *(void *)a1 = off_1019D2820;
  *(void *)(a1 + 16) = &unk_1019D28C8;
  *(_WORD *)(a1 + 24) = 2560;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = 0;
  int v2 = operator new(0x20uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = off_1019B3378;
  *(void *)(a1 + 96) = v2;
  *((unsigned char *)v2 + 24) = 0;
  *(void *)(a1 + 88) = v2 + 3;
  return a1;
}

void sub_100E37128(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
      CFStringRef v60 = @"Message is nil";
      id v14 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v14];
    }
    goto LABEL_11;
  }
  uint64_t v7 = [v5 shortHandles];
  if (!v7
    || ([v6 shortHandles],
        BOOL v8 = objc_claimAutoreleasedReturnValue(),
        id v9 = [v8 count],
        v8,
        v7,
        !v9))
  {
    if (a2)
    {
      NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
      CFStringRef v58 = @"Short handles are missing";
      id v13 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v13];
    }
    goto LABEL_11;
  }
  BOOL v10 = [v6 shortHandles];
  id v11 = [v10 count];

  if ((unint64_t)v11 >= 0x18)
  {
    if (a2)
    {
      NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
      CFStringRef v56 = @"Too many short handles";
      id v12 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v12];
    }
LABEL_11:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 56) = 0;
    goto LABEL_12;
  }
  __n128 __p = 0;
  long long v51 = 0uLL;
  id v15 = [v6 shortHandles];
  unint64_t v16 = (unint64_t)[v15 count];
  if (v16)
  {
    if (v16 >> 61) {
      sub_10010562C();
    }
    id v17 = (char *)sub_10004EF74((uint64_t)&v51 + 8, v16);
    long long v18 = &v17[v51 & 0xFFFFFFFFFFFFFFF8];
    id v20 = &v17[8 * v19];
    int v21 = (char *)__p;
    int v22 = (char *)v51;
    uint64_t v23 = v18;
    if ((void *)v51 != __p)
    {
      uint64_t v23 = v18;
      do
      {
        uint64_t v24 = *((void *)v22 - 1);
        v22 -= 8;
        *((void *)v23 - 1) = v24;
        v23 -= 8;
      }
      while (v22 != v21);
    }
    __n128 __p = v23;
    *(void *)&long long v51 = v18;
    *((void *)&v51 + 1) = v20;
  }

  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  id v25 = [v6 shortHandles];
  id v26 = [v25 countByEnumeratingWithState:&v46 objects:v54 count:16];
  if (v26)
  {
    uint64_t v27 = *(void *)v47;
    while (2)
    {
      for (unint64_t i = 0; i != v26; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v47 != v27) {
          objc_enumerationMutation(v25);
        }
        long long v29 = *(void **)(*((void *)&v46 + 1) + 8 * i);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || !sub_100E36EF8(v29))
        {
          if (a2)
          {
            NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
            CFStringRef v53 = @"Invalid shortHandle";
            NSErrorUserInfoKey v45 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
            *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v45];
          }
          *(unsigned char *)a3 = 0;
          *(unsigned char *)(a3 + 56) = 0;

          if (__p)
          {
            *(void *)&long long v51 = __p;
            operator delete(__p);
          }
          goto LABEL_12;
        }
        id v30 = [v29 unsignedLongLongValue];
        id v31 = v30;
        long long v32 = (char *)v51;
        if ((unint64_t)v51 >= *((void *)&v51 + 1))
        {
          NSErrorUserInfoKey v34 = (char *)__p;
          uint64_t v35 = (uint64_t)(v51 - (void)__p) >> 3;
          unint64_t v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61) {
            sub_10010562C();
          }
          uint64_t v37 = *((void *)&v51 + 1) - (void)__p;
          if ((uint64_t)(*((void *)&v51 + 1) - (void)__p) >> 2 > v36) {
            unint64_t v36 = v37 >> 2;
          }
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v38 = v36;
          }
          if (v38)
          {
            NSErrorUserInfoKey v39 = (char *)sub_10004EF74((uint64_t)&v51 + 8, v38);
            NSErrorUserInfoKey v34 = (char *)__p;
            long long v32 = (char *)v51;
          }
          else
          {
            NSErrorUserInfoKey v39 = 0;
          }
          CFStringRef v40 = &v39[8 * v35];
          *(void *)CFStringRef v40 = v31;
          long long v33 = v40 + 8;
          while (v32 != v34)
          {
            uint64_t v41 = *((void *)v32 - 1);
            v32 -= 8;
            *((void *)v40 - 1) = v41;
            v40 -= 8;
          }
          __n128 __p = v40;
          *(void *)&long long v51 = v33;
          *((void *)&v51 + 1) = &v39[8 * v38];
          if (v34) {
            operator delete(v34);
          }
        }
        else
        {
          *(void *)long long v51 = v30;
          long long v33 = v32 + 8;
        }
        *(void *)&long long v51 = v33;
      }
      id v26 = [v25 countByEnumeratingWithState:&v46 objects:v54 count:16];
      if (v26) {
        continue;
      }
      break;
    }
  }

  CFStringRef v42 = __p;
  uint64_t v43 = v51;
  __n128 __p = 0;
  uint64_t v44 = *((void *)&v51 + 1);
  long long v51 = 0uLL;
  *(void *)a3 = off_1019D2E30;
  *(void *)a3 = off_1019D2E30;
  *(void *)(a3 + 8) = 0xE00000010;
  *(void *)(a3 + 16) = &unk_1019D2EA8;
  *(void *)a3 = &off_1019D2F48;
  *(void *)a3 = off_1019D2CA8;
  *(void *)(a3 + 16) = &unk_1019D2D50;
  *(_WORD *)(a3 + 24) = 2816;
  *(void *)(a3 + 32) = v42;
  *(void *)(a3 + 40) = v43;
  *(void *)(a3 + 48) = v44;
  *(unsigned char *)(a3 + 56) = 1;
LABEL_12:
}

void sub_100E37890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100E37938(void *a1@<X0>, void *a2@<X1>, unsigned char *a3@<X8>)
{
  id v5 = a1;
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
    if (a2)
    {
      NSErrorUserInfoKey v54 = NSLocalizedDescriptionKey;
      CFStringRef v55 = @"Message is nil";
      id v17 = +[NSDictionary dictionaryWithObjects:&v55 forKeys:&v54 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v17];
    }
    goto LABEL_24;
  }
  uint64_t v7 = [v5 context];

  if (!v7)
  {
    if (a2)
    {
      NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
      CFStringRef v53 = @"Context is missing";
      long long v18 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v18];
    }
    goto LABEL_24;
  }
  BOOL v8 = [v6 context];
  id v9 = [v8 slotID];
  if (v9 == (id)2) {
    int v10 = 2;
  }
  else {
    int v10 = v9 == (id)1;
  }

  if (!v10)
  {
    if (a2)
    {
      NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
      CFStringRef v51 = @"Invalid context slotID";
      id v20 = +[NSDictionary dictionaryWithObjects:&v51 forKeys:&v50 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v20];
    }
    goto LABEL_24;
  }
  id v11 = [v6 destinationPhoneNumber];
  if (!v11
    || ([v6 destinationPhoneNumber],
        id v12 = objc_claimAutoreleasedReturnValue(),
        id v13 = [v12 length],
        v12,
        v11,
        !v13))
  {
    if (a2)
    {
      NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
      CFStringRef v49 = @"destinationPhoneNumber is missing";
      uint64_t v19 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v19];
    }
    goto LABEL_24;
  }
  id v14 = [v6 destinationPhoneNumber];
  unsigned __int8 v15 = sub_100E36698(v14, 1);

  if ((v15 & 1) == 0)
  {
    if (a2)
    {
      NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
      CFStringRef v47 = @"destinationPhoneNumber is invalid";
      int v21 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v21];
    }
    goto LABEL_24;
  }
  if (((unint64_t)[v6 codecID] & 0x8000000000000000) != 0
    || (unint64_t)[v6 codecID] >= 0x10)
  {
    if (a2)
    {
      NSErrorUserInfoKey v44 = NSLocalizedDescriptionKey;
      CFStringRef v45 = @"Invalid codecID";
      unint64_t v16 = +[NSDictionary dictionaryWithObjects:&v45 forKeys:&v44 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v16];
    }
LABEL_24:
    *a3 = 0;
    a3[96] = 0;
    goto LABEL_25;
  }
  int v22 = [v6 textPayload];
  if (!v22
    || ([v6 textPayload],
        uint64_t v23 = objc_claimAutoreleasedReturnValue(),
        id v24 = [v23 length],
        v23,
        v22,
        !v24))
  {
    if (a2)
    {
      NSErrorUserInfoKey v42 = NSLocalizedDescriptionKey;
      CFStringRef v43 = @"textPayload is missing";
      id v28 = +[NSDictionary dictionaryWithObjects:&v43 forKeys:&v42 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v28];
    }
    goto LABEL_24;
  }
  id v25 = [v6 textPayload];
  id v26 = [v25 length];

  if ((unint64_t)v26 >= 0x8F)
  {
    if (a2)
    {
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      CFStringRef v41 = @"textPayload is too big";
      uint64_t v27 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
      *a2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v27];
    }
    goto LABEL_24;
  }
  memset(v39, 0, sizeof(v39));
  long long v37 = 0u;
  long long v38 = 0u;
  sub_100E380A0((uint64_t)&v37);
  HIDWORD(v38) = v10;
  long long v29 = [v6 destinationPhoneNumber];
  LOBYTE(v39[0]) = [v29 hasPrefix:@"+"];

  id v30 = [v6 destinationPhoneNumber];
  sub_10003ED78((std::string *)((char *)v39 + 8), (char *)[v30 UTF8String]);

  if (LOBYTE(v39[0])) {
    std::string::erase((std::string *)((char *)v39 + 8), 0, 1uLL);
  }
  LOBYTE(v39[2]) = [v6 codecID];
  id v31 = [v6 textPayload];
  id v32 = [v31 bytes];

  long long v33 = [v6 textPayload];
  id v34 = [v33 length];
  long long v35 = 0uLL;
  uint64_t v36 = 0;
  sub_1001E7940(&v35, v32, (uint64_t)v34 + (void)v32, (size_t)v34);
  if (*((void *)&v39[2] + 1))
  {
    *(void *)&v39[3] = *((void *)&v39[2] + 1);
    operator delete(*((void **)&v39[2] + 1));
  }
  *(_OWORD *)((char *)&v39[2] + 8) = v35;
  *((void *)&v39[3] + 1) = v36;
  uint64_t v36 = 0;
  long long v35 = 0uLL;

  BYTE1(v39[0]) = [v6 notifyDowngrade];
  sub_100E38D6C((uint64_t)a3, (uint64_t)&v37);
  sub_1004A4B94((uint64_t)&v37);
LABEL_25:
}

void sub_100E37FB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E380A0(uint64_t result)
{
  *(void *)id result = off_1019D3318;
  *(void *)id result = off_1019D3318;
  *(_WORD *)(result + 8) = 32;
  *(_DWORD *)(result + 12) = 18;
  *(void *)(result + 16) = &unk_1019D3390;
  *(void *)id result = &off_1019D3430;
  *(void *)id result = off_1019D3190;
  *(void *)(result + 16) = &unk_1019D3238;
  *(_WORD *)(result + 24) = 3328;
  *(_DWORD *)(result + 28) = 0;
  *(_WORD *)(result + 32) = 0;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 40) = 0;
  *(unsigned char *)(result + 64) = 0;
  return result;
}

id sub_100E38224(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  sub_10012CD04(__p, *(char **)(a1 + 40), *(char **)(a1 + 48), *(void *)(a1 + 48) - *(void *)(a1 + 40));
  if (v11 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  id v5 = +[NSString stringWithCString:v4 encoding:4];
  id v6 = objc_alloc((Class)CTStewieEmergencyTextMessage);
  if (*(unsigned char *)(a1 + 28) == 1) {
    uint64_t v7 = 3;
  }
  else {
    uint64_t v7 = *(unsigned char *)(a1 + 28) == 0;
  }
  id v8 = [v6 initIncomingTextMessageWithConversationID:*(unsigned __int8 *)(a1 + 26) sequenceNum:*(unsigned __int16 *)(a1 + 30) emergencyText:v5 notifyOption:v7 error:a2];

  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }

  return v8;
}

void sub_100E38300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100E38328(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v9 = 0;
  sub_10012CD04(__p, *(char **)(a1 + 48), *(char **)(a1 + 56), *(void *)(a1 + 56) - *(void *)(a1 + 48));
  if (v9 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  id v5 = +[NSString stringWithCString:v4 encoding:4];
  id v6 = [objc_alloc((Class)CTStewieRoadsideTextMessage) initIncomingTextMessageWithConversationID:*(unsigned __int8 *)(a1 + 26) providerId:*(unsigned __int16 *)(a1 + 28) sequenceNum:*(unsigned __int16 *)(a1 + 32) text:v5 error:a2];

  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }

  return v6;
}

void sub_100E383F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100E38418(uint64_t a1, uint64_t a2)
{
  id v4 = objc_alloc_init((Class)NSMutableArray);
  id v5 = *(uint64_t **)(a1 + 64);
  for (unint64_t i = *(uint64_t **)(a1 + 72); v5 != i; v5 += 2)
  {
    uint64_t v7 = *v5;
    uint64_t v8 = *((unsigned __int8 *)v5 + 8);
    id v9 = objc_alloc((Class)CTStewieIMessageLiteSummaryPendingCount);
    int v10 = +[NSNumber numberWithUnsignedLongLong:v7];
    id v11 = [v9 initWithOtherShortHandle:v10 pendingCount:v8 error:0];
    [v4 addObject:v11];
  }
  id v12 = [objc_alloc((Class)CTStewieIMessageLiteSummaryMessage) initWithPendingIMessageLiteTotalCount:*(unsigned __int8 *)(a1 + 30) pendingCounts:v4 error:a2];

  return v12;
}

void sub_100E38518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100E38544(uint64_t a1, uint64_t a2)
{
  id v2 = [objc_alloc((Class)CTStewieSatSmsSummaryMessage) initWithPendingSatSmsTotalCount:*(unsigned __int8 *)(a1 + 31) error:a2];

  return v2;
}

id sub_100E38590(uint64_t a1, uint64_t a2)
{
  id v4 = +[NSData dataWithBytes:*(void *)(a1 + 80) length:*(void *)(a1 + 88) - *(void *)(a1 + 80)];
  id v5 = objc_alloc((Class)CTStewieIMessageLiteMessageIncoming);
  id v6 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 32)];
  uint64_t v7 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 41);
  id v9 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 48)];
  int v10 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 56)];
  id v11 = [v5 initWithTimestamp:v6 pendingTotalCount:v7 pendingCount:v8 myShortHandle:v9 otherShortHandle:v10 partNumber:*(void *)(a1 + 64) totalParts:*(void *)(a1 + 72) payload:v4 error:a2];

  return v11;
}

void sub_100E386A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100E386D4(uint64_t a1, uint64_t a2)
{
  id v24 = +[NSData dataWithBytes:*(void *)(a1 + 112) length:*(void *)(a1 + 120) - *(void *)(a1 + 112)];
  id v4 = objc_alloc((Class)CTStewieSatSmsMessageIncoming);
  id v5 = objc_alloc((Class)CTXPCServiceSubscriptionContext);
  int v6 = *(_DWORD *)(a1 + 40);
  if (v6 == 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 2 * (v6 == 2);
  }
  id v8 = [v5 initWithSlot:v7];
  id v9 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 32)];
  uint64_t v10 = *(unsigned __int8 *)(a1 + 44);
  uint64_t v11 = *(unsigned __int8 *)(a1 + 45);
  id v12 = objc_alloc((Class)NSString);
  if (*(char *)(a1 + 103) >= 0) {
    uint64_t v13 = a1 + 80;
  }
  else {
    uint64_t v13 = *(void *)(a1 + 80);
  }
  id v14 = [v12 initWithUTF8String:v13];
  uint64_t v15 = *(unsigned __int8 *)(a1 + 104);
  id v16 = objc_alloc((Class)NSString);
  uint64_t v19 = *(void *)(a1 + 136);
  uint64_t v18 = a1 + 136;
  uint64_t v17 = v19;
  if (*(char *)(v18 + 23) >= 0) {
    uint64_t v20 = v18;
  }
  else {
    uint64_t v20 = v17;
  }
  id v21 = [v16 initWithUTF8String:v20];
  id v22 = [v4 initWithContext:v8 timestamp:v9 pendingTotalCount:v10 pendingCount:v11 sourcePhoneNumber:v14 codecID:v15 textPayload:v24 uniqueID:v21 error:a2];

  return v22;
}

void sub_100E38840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

__n128 sub_100E38884(__n128 *a1, __n128 *a2)
{
  a1->n128_u64[0] = (unint64_t)off_1019BDF88;
  a1->n128_u64[0] = (unint64_t)off_1019BDF88;
  a1->n128_u64[1] = a2->n128_u64[1];
  a1[1].n128_u64[0] = (unint64_t)&unk_1019BE000;
  a1->n128_u64[0] = (unint64_t)&off_1019BE0A0;
  a1->n128_u64[0] = (unint64_t)off_1019BDE00;
  a1[1].n128_u64[0] = (unint64_t)&unk_1019BDEA8;
  unsigned __int32 v2 = a2[1].n128_u32[2];
  a1[1].n128_u16[6] = a2[1].n128_u16[6];
  a1[1].n128_u32[2] = v2;
  a1[2].n128_u64[1] = 0;
  a1[3].n128_u64[0] = 0;
  a1[2].n128_u64[0] = 0;
  a1[2] = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[2].n128_u64[0] = 0;
  a2[2].n128_u64[1] = 0;
  a2[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  __n128 result = a2[4];
  a1[4] = result;
  a2[4].n128_u64[0] = 0;
  a2[4].n128_u64[1] = 0;
  a1[5].n128_u8[0] = 1;
  return result;
}

__n128 sub_100E38A28(__n128 *a1, __n128 *a2)
{
  a1->n128_u64[0] = (unint64_t)off_101A91328;
  a1->n128_u64[0] = (unint64_t)off_101A91328;
  a1->n128_u64[1] = a2->n128_u64[1];
  a1[1].n128_u64[0] = (unint64_t)&unk_101A913A0;
  a1->n128_u64[0] = (unint64_t)&off_101A91440;
  a1->n128_u64[0] = (unint64_t)off_101A911A0;
  a1[1].n128_u64[0] = (unint64_t)&unk_101A91248;
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a1[2].n128_u64[0] = 0;
  a1[2].n128_u64[1] = 0;
  a1[3].n128_u64[0] = 0;
  a1[2] = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[2].n128_u64[0] = 0;
  a2[2].n128_u64[1] = 0;
  a2[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  __n128 result = a2[4];
  a1[4] = result;
  a2[4].n128_u64[0] = 0;
  a2[4].n128_u64[1] = 0;
  a1[5].n128_u8[0] = 1;
  return result;
}

uint64_t sub_100E38BC0(uint64_t result, uint64_t a2)
{
  *(void *)__n128 result = off_1019D29A8;
  *(void *)__n128 result = off_1019D29A8;
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(result + 16) = &unk_1019D2A20;
  *(void *)__n128 result = &off_1019D2AC0;
  *(void *)__n128 result = off_1019D2820;
  *(void *)(result + 16) = &unk_1019D28C8;
  long long v2 = *(_OWORD *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 56);
  *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(result + 24) = v2;
  *(void *)(result + 56) = v3;
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 64);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  uint64_t v4 = *(void *)(a2 + 96);
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(result + 96) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(result + 104) = 1;
  return result;
}

__n128 sub_100E38D6C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1019D3318;
  *(void *)a1 = off_1019D3318;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = &unk_1019D3390;
  *(void *)a1 = &off_1019D3430;
  *(void *)a1 = off_1019D3190;
  *(void *)(a1 + 16) = &unk_1019D3238;
  uint64_t v2 = *(void *)(a2 + 24);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(void *)(a1 + 24) = v2;
  long long v3 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v3;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a1 + 72) = result;
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  return result;
}

double sub_100E38F1C@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  long long v8 = 0uLL;
  sub_100E4240C(a1, &v8);
  uint64_t v3 = v8;
  uint64_t v7 = &v8;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100E425EC;
  v9[3] = &unk_10199E470;
  v9[4] = v8 + 8;
  v9[5] = &v7;
  uint64_t v4 = objc_retainBlock(v9);
  id v5 = *(NSObject **)(v3 + 24);
  if (*(void *)(v3 + 32)) {
    dispatch_async_and_wait(v5, v4);
  }
  else {
    dispatch_sync(v5, v4);
  }

  double result = *(double *)&v8;
  *a2 = v8;
  return result;
}

uint64_t sub_100E38FF4(uint64_t a1, void *a2)
{
  *(void *)a1 = &off_101A5FE50;
  uint64_t v4 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, "cdp.alert");
  id v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  int v6 = dispatch_queue_create("Cellular Data Plan Alert", v5);
  *uint64_t v4 = 0;
  v4[1] = 0;
  *(void *)(a1 + 24) = v6;
  if (v6)
  {
    uint64_t v7 = v6;
    dispatch_retain(v6);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v7);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v15, &v14);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v15);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v15);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)a1 = off_101A5FF58;
  *(void *)(a1 + 48) = objc_alloc_init(CellularPlanUserNotificationDelegate);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 61) = 0;
  *(void *)(a1 + 72) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 80) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "Cellular Data Plan Alert");
  id v9 = *(NSObject **)(a1 + 24);
  uint64_t v11 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  ctu::RestModule::RestModule();
  if (v11) {
    dispatch_release(v11);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 152) = -1;
  *(void *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  return a1;
}

void sub_100E391B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  id v21 = *(std::__shared_weak_count **)(v17 + 80);
  if (v21) {
    sub_10004D2C8(v21);
  }

  ctu::OsLogLogger::~OsLogLogger(v19);
  sub_100087E88(v18);
  _Unwind_Resume(a1);
}

uint64_t sub_100E39250(uint64_t a1)
{
  *(void *)a1 = off_101A5FF58;
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100E392F0(uint64_t a1)
{
  sub_100E39250(a1);

  operator delete();
}

BOOL sub_100E39328(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0)
  {
    if (*(void *)(a1 + 112)) {
      return *(void *)(a1 + 160) != 0;
    }
  }
  else if (*(unsigned char *)(a1 + 127))
  {
    return *(void *)(a1 + 160) != 0;
  }
  return 0;
}

void sub_100E39358(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E393CC;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

const void **sub_100E393CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Show profile download failure alert", buf, 2u);
  }
  CFStringRef v40 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 72));
  id v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  id v12 = 0;
  char v14 = 1;
LABEL_11:
  uint64_t v15 = kAlertDialogLocalizationTable;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&v40, v13, kAlertDialogLocalizationTable, @"Data Plan Activation Failure", 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFStringRef v39 = 0;
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v1 + 72));
  uint64_t v18 = v17;
  uint64_t v19 = v6;
  if (v6 < 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  *(void *)long long buf = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    id v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  id v24 = 0;
  char v26 = 1;
LABEL_21:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v25 + 16))(&v39, v25, v15, @"Your cellular data plan did not successfully activate.", 1);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  CFStringRef defaultButtonTitle = 0;
  id v28 = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(v1 + 72));
  long long v29 = v28;
  if (v6 < 0)
  {
    id v30 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v6 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v28);
  *(void *)long long buf = v6;
  long long v33 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
  if (v33)
  {
    uint64_t v35 = v33[3];
    id v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v29);
  id v34 = 0;
  char v36 = 1;
LABEL_31:
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v35 + 16))(&defaultButtonTitle, v35, v15, @"OK", 1);
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  *(void *)long long buf = 0;
  CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v40, v39, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
  sub_1000558F4((const void **)&defaultButtonTitle);
  sub_1000558F4((const void **)&v39);
  return sub_1000558F4((const void **)&v40);
}

void sub_100E39738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  id v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

void sub_100E397B4(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E39828;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

const void **sub_100E39828(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Show Cellular Plan New Plan Available Alert", buf, 2u);
  }
  CFStringRef v40 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 72));
  id v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  id v12 = 0;
  char v14 = 1;
LABEL_11:
  uint64_t v15 = kAlertDialogLocalizationTable;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&v40, v13, kAlertDialogLocalizationTable, @"Data Plan Updated", 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  CFStringRef v39 = 0;
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v1 + 72));
  uint64_t v18 = v17;
  uint64_t v19 = v6;
  if (v6 < 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  *(void *)long long buf = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    id v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  id v24 = 0;
  char v26 = 1;
LABEL_21:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v25 + 16))(&v39, v25, v15, @"Your Cellular data plan has been successfully updated.", 1);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  CFStringRef defaultButtonTitle = 0;
  id v28 = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(v1 + 72));
  long long v29 = v28;
  if (v6 < 0)
  {
    id v30 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v6 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v28);
  *(void *)long long buf = v6;
  long long v33 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
  if (v33)
  {
    uint64_t v35 = v33[3];
    id v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v29);
  id v34 = 0;
  char v36 = 1;
LABEL_31:
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v35 + 16))(&defaultButtonTitle, v35, v15, @"OK", 1);
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  *(void *)long long buf = 0;
  CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v40, v39, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
  sub_1000558F4((const void **)&defaultButtonTitle);
  sub_1000558F4((const void **)&v39);
  return sub_1000558F4((const void **)&v40);
}

void sub_100E39B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  id v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

void sub_100E39C10(uint64_t a1, char a2, char a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100E39C88;
  v3[3] = &unk_101A60050;
  v3[4] = a1;
  char v4 = a3;
  char v5 = a2;
  sub_100E42808((uint64_t *)(a1 + 8), v3);
}

const void **sub_100E39C88(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Showing Selection Changed Alert", buf, 2u);
  }
  CFStringRef v59 = 0;
  CFStringRef v60 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 72));
  uint64_t v6 = ServiceMap;
  uint64_t v8 = v7;
  if (v7 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  id v12 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_11:
  uint64_t v16 = kAlertDialogLocalizationTable;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v14 + 16))(&v59, v14, kAlertDialogLocalizationTable, @"DEFAULT_SETTING_CHANGED_TITLE", 1);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  uint64_t v17 = (uint64_t *)*(unsigned __int8 *)(a1 + 41);
  if (!*(unsigned char *)(a1 + 40))
  {
    if (!*(unsigned char *)(a1 + 41)) {
      goto LABEL_45;
    }
    id v28 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(v2 + 72));
    long long v29 = v28;
    uint64_t v30 = v7;
    if (v7 < 0)
    {
      uint64_t v31 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v28);
    *(void *)long long buf = v30;
    id v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
    if (v34)
    {
      uint64_t v35 = v34[3];
      uint64_t v25 = (std::__shared_weak_count *)v34[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
LABEL_39:
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v35 + 16))(&defaultButtonTitle, v35, v16, @"DATA_CHANGED", 1);
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v29);
    uint64_t v25 = 0;
    char v27 = 1;
    goto LABEL_39;
  }
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t v18 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(v2 + 72));
    uint64_t v19 = v18;
    uint64_t v20 = v7;
    if (v7 < 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(v18);
    *(void *)long long buf = v20;
    id v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
LABEL_36:
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v26 + 16))(&defaultButtonTitle, v26, v16, @"VOICE_AND_DATA_CHANGED", 1);
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    uint64_t v25 = 0;
    char v27 = 1;
    goto LABEL_36;
  }
  char v36 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(v2 + 72));
  long long v37 = v36;
  uint64_t v38 = v7;
  if (v7 < 0)
  {
    CFStringRef v39 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(v36);
  *(void *)long long buf = v38;
  NSErrorUserInfoKey v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)buf);
  if (!v42)
  {
    uint64_t v43 = 0;
    goto LABEL_41;
  }
  uint64_t v43 = v42[3];
  uint64_t v25 = (std::__shared_weak_count *)v42[4];
  if (!v25)
  {
LABEL_41:
    std::mutex::unlock(v37);
    uint64_t v25 = 0;
    char v27 = 1;
    goto LABEL_42;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v37);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
LABEL_42:
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v43 + 16))(&defaultButtonTitle, v43, v16, @"VOICE_CHANGED", 1);
LABEL_43:
  CFStringRef v44 = v60;
  CFStringRef v60 = defaultButtonTitle;
  *(void *)long long buf = v44;
  CFStringRef defaultButtonTitle = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&defaultButtonTitle);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
LABEL_45:
  if (v60) {
    CFStringRef v45 = sub_1000810B8;
  }
  else {
    CFStringRef v45 = 0;
  }
  if (v45)
  {
    NSErrorUserInfoKey v46 = v59 ? (uint64_t *)sub_1000810B8 : 0;
    if (v46)
    {
      CFStringRef defaultButtonTitle = 0;
      CFStringRef v47 = (std::mutex *)Registry::getServiceMap(v46, *(Registry **)(v2 + 72));
      NSErrorUserInfoKey v48 = v47;
      if (v7 < 0)
      {
        CFStringRef v49 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v50 = 5381;
        do
        {
          uint64_t v7 = v50;
          unsigned int v51 = *v49++;
          uint64_t v50 = (33 * v50) ^ v51;
        }
        while (v51);
      }
      std::mutex::lock(v47);
      *(void *)long long buf = v7;
      NSErrorUserInfoKey v52 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
      if (v52)
      {
        uint64_t v54 = v52[3];
        CFStringRef v53 = (std::__shared_weak_count *)v52[4];
        if (v53)
        {
          atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v48);
          atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v53);
          char v55 = 0;
LABEL_63:
          (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v54 + 16))(&defaultButtonTitle, v54, v16, @"OK", 1);
          if ((v55 & 1) == 0) {
            sub_10004D2C8(v53);
          }
          *(void *)long long buf = 0;
          CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v59, v60, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
          sub_1000558F4((const void **)&defaultButtonTitle);
          goto LABEL_66;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
      std::mutex::unlock(v48);
      CFStringRef v53 = 0;
      char v55 = 1;
      goto LABEL_63;
    }
  }
  CFStringRef v56 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Localized strings not available", buf, 2u);
  }
LABEL_66:
  sub_1000558F4((const void **)&v59);
  return sub_1000558F4((const void **)&v60);
}

void sub_100E3A248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, const void *);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100E3A2DC(uint64_t a1, char a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100E3A354;
  v2[3] = &unk_1019BB378;
  v2[4] = a1;
  char v3 = a2;
  sub_100E42808((uint64_t *)(a1 + 8), v2);
}

const void **sub_100E3A354(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Install Failed Alert: %s", buf, 0xCu);
  }
  CFStringRef v22 = 0;
  CFStringRef v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 72));
  char v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
LABEL_11:
  if (*(unsigned __int8 *)(a1 + 40) - 1 < 0x43)
  {
    uint64_t v15 = kAlertDialogLocalizationTable;
    (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&v21, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_FAILED_ACTION_TITLE", 1);
    CFStringRef v16 = v23;
    CFStringRef v23 = v21;
    *(void *)long long buf = v16;
    CFStringRef v21 = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v21);
    (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&v21, v13, v15, @"CELLULARPLANERROR_FAILED_ACTION_MESSAGE", 1);
    *(void *)long long buf = v22;
    CFStringRef v17 = v21;
    CFStringRef v21 = 0;
    CFStringRef v22 = v17;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v21);
LABEL_13:
    *(void *)long long buf = 0;
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(buf, v13, v15, @"OK", 1);
    CFStringRef v21 = 0;
    if (v22) {
      uint64_t v18 = sub_1000810B8;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v18) {
      CFStringRef v19 = v22;
    }
    else {
      CFStringRef v19 = 0;
    }
    CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v23, v19, *(CFStringRef *)buf, 0, 0, (CFOptionFlags *)&v21);
    sub_1000558F4((const void **)buf);
    goto LABEL_20;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v15 = kAlertDialogLocalizationTable;
    goto LABEL_13;
  }
LABEL_20:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_1000558F4((const void **)&v22);
  return sub_1000558F4((const void **)&v23);
}

void sub_100E3A64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unsigned int v10 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va2);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100E3A6A4(uint64_t a1, char a2, const void **a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3321888768;
  v5[2] = sub_100E3A73C;
  v5[3] = &unk_101A60070;
  char v3 = (uint64_t *)(a1 + 8);
  v5[4] = a1;
  char v7 = a2;
  sub_100083DA4(&v6, a3);
  sub_100E42808(v3, v5);
  return sub_1000558F4(&v6);
}

const void **sub_100E3A73C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Install Failed Alert: %s", buf, 0xCu);
  }
  CFTypeRef v57 = 0;
  CFTypeRef v58 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 72));
  char v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  id v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_10:
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_11:
  switch(*(unsigned char *)(a1 + 48))
  {
    case 0:
      goto LABEL_22;
    case 1:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xE:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
      uint64_t v15 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_FAILED_ACTION_TITLE", 1);
      CFTypeRef v16 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v16;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v15, @"CELLULARPLANERROR_FAILED_ACTION_MESSAGE", 1);
      goto LABEL_13;
    case 2:
      uint64_t v22 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_PARSE_TITLE", 1);
      CFTypeRef v23 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v23;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v22, @"CELLULARPLANERROR_PARSE_MESSAGE", 1);
      goto LABEL_13;
    case 6:
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_INVALID_ARGUMENT_TITLE", 1);
      CFTypeRef v47 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v47;
      goto LABEL_14;
    case 0xD:
      uint64_t v48 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_BUSY_TITLE", 1);
      CFTypeRef v49 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v49;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v48, @"CELLULARPLANERROR_BUSY_MESSAGE", 1);
      goto LABEL_13;
    case 0xF:
      uint64_t v24 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_DUPLICATE_FAUX_CARD_TITLE", 1);
      CFTypeRef v25 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v25;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v24, @"CELLULARPLANERROR_DUPLICATE_FAUX_CARD_MESSAGE", 1);
      goto LABEL_13;
    case 0x19:
      uint64_t v26 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_INVALID_PPR_TITLE", 1);
      CFTypeRef v27 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v27;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v26, @"CELLULARPLANERROR_INVALID_PPR_MESSAGE", 1);
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@%@", format, 0, *(void *)(a1 + 40), *(void *)(a1 + 40));
        goto LABEL_45;
      }
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v26, @"CELLULARPLANERROR_INVALID_PPR_MESSAGE_NO_CARRIER", 1);
      goto LABEL_13;
    case 0x1A:
      uint64_t v29 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_INVALID_FAUX_CARD_TITLE", 1);
      CFTypeRef v30 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v30;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v29, @"CELLULARPLANERROR_INVALID_FAUX_CARD_MESSAGE", 1);
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        goto LABEL_45;
      }
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v29, @"CELLULARPLANERROR_INVALID_FAUX_CARD_MESSAGE_NO_CARRIER", 1);
      goto LABEL_13;
    case 0x22:
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) < 1)
      {
        uint64_t v50 = kAlertDialogLocalizationTable;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_ELIGIBILITY_CHECK_FAILED_TITLE_NO_CARRIER", 1);
        CFTypeRef v53 = v58;
        CFTypeRef v58 = format;
        *(void *)long long buf = v53;
        CFStringRef format = 0;
      }
      else
      {
        CFStringRef format = 0;
        uint64_t v50 = kAlertDialogLocalizationTable;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_ELIGIBILITY_CHECK_FAILED_TITLE", 1);
        CFStringRef v51 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        CFTypeRef v52 = v58;
        CFTypeRef v58 = v51;
        *(void *)long long buf = v52;
      }
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v50, @"CELLULARPLANERROR_ELIGIBILITY_CHECK_FAILED_MESSAGE", 1);
      goto LABEL_13;
    case 0x23:
      uint64_t v31 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_NO_ELIGIBLE_PROFILES_TITLE", 1);
      CFTypeRef v32 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v32;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v31, @"CELLULARPLANERROR_NO_ELIGIBLE_PROFILES_MESSAGE", 1);
      goto LABEL_13;
    case 0x24:
      uint64_t v33 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_INVALID_SMDP_TITLE", 1);
      CFTypeRef v34 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v34;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v33, @"CELLULARPLANERROR_INVALID_SMDP_MESSAGE", 1);
      goto LABEL_13;
    case 0x25:
      uint64_t v35 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, kCBMessageLocalizationTable, @"FAILED_TRANSFER_TITLE", @"FAILED_TRANSFER_TITLE");
      CFTypeRef v36 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v36;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v35, @"FAILED_TRANSFER_INELIGIBLE_ACCOUNT_%@", @"FAILED_TRANSFER_INELIGIBLE_ACCOUNT_%@");
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        goto LABEL_45;
      }
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v35, @"FAILED_TRANSFER_INELIGIBLE_ACCOUNT_NO_CARRIER", @"FAILED_TRANSFER_INELIGIBLE_ACCOUNT_NO_CARRIER");
      goto LABEL_13;
    case 0x2A:
      uint64_t v37 = kAlertDialogLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"CELLULARPLANERROR_PROFILE_UNAVAILABLE_ON_ALS_TITLE", 1);
      CFTypeRef v38 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v38;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v37, @"CELLULARPLANERROR_PROFILE_UNAVAILABLE_ON_ALS_MESSAGE", 1);
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        goto LABEL_45;
      }
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, v37, @"CELLULARPLANERROR_PROFILE_UNAVAILABLE_ON_ALS_MESSAGE_NO_CARRIER", 1);
      goto LABEL_13;
    case 0x34:
      uint64_t v39 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, kCBMessageLocalizationTable, @"FAILED_TRANSFER_TITLE", @"FAILED_TRANSFER_TITLE");
      CFTypeRef v40 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v40;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1) {
        goto LABEL_38;
      }
      goto LABEL_55;
    case 0x35:
      uint64_t v39 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, kCBMessageLocalizationTable, @"FAILED_TRANSFER_TITLE", @"FAILED_TRANSFER_TITLE");
      CFTypeRef v41 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v41;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
LABEL_38:
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v39, @"FAILED_TRANSFER_TEMPORARY_FAILURE_%@", @"FAILED_TRANSFER_TEMPORARY_FAILURE_%@");
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        goto LABEL_45;
      }
LABEL_55:
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v39, @"FAILED_TRANSFER_TEMPORARY_FAILURE_NO_CARRIER", @"FAILED_TRANSFER_TEMPORARY_FAILURE_NO_CARRIER");
      goto LABEL_13;
    case 0x36:
      uint64_t v42 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, kCBMessageLocalizationTable, @"FAILED_TRANSFER_TITLE", @"FAILED_TRANSFER_TITLE");
      CFTypeRef v43 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v43;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) >= 1)
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v42, @"FAILED_TRANSFER_PERMANENT_FAILURE_%@", @"FAILED_TRANSFER_PERMANENT_FAILURE_%@");
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
        goto LABEL_45;
      }
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v42, @"FAILED_TRANSFER_PERMANENT_FAILURE_NO_CARRIER", @"FAILED_TRANSFER_PERMANENT_FAILURE_NO_CARRIER");
      goto LABEL_13;
    case 0x37:
      uint64_t v44 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, kCBMessageLocalizationTable, @"FAILED_TRANSFER_TITLE", @"FAILED_TRANSFER_TITLE");
      CFTypeRef v45 = v58;
      CFTypeRef v58 = format;
      *(void *)long long buf = v45;
      CFStringRef format = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (CFStringGetLength(*(CFStringRef *)(a1 + 40)) < 1)
      {
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v44, @"FAILED_TRANSFER_BLOCKED_ACCOUNT_NO_CARRIER", @"FAILED_TRANSFER_BLOCKED_ACCOUNT_NO_CARRIER");
LABEL_13:
        *(void *)long long buf = v57;
        CFTypeRef v57 = format;
LABEL_14:
        CFStringRef format = 0;
      }
      else
      {
        CFStringRef format = 0;
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v13 + 40))(&format, v13, v44, @"FAILED_TRANSFER_BLOCKED_ACCOUNT_%@", @"FAILED_TRANSFER_BLOCKED_ACCOUNT_%@");
        CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
LABEL_45:
        CFTypeRef v46 = v57;
        CFTypeRef v57 = StringWithValidatedFormat;
        *(void *)long long buf = v46;
      }
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
LABEL_16:
      CFStringRef format = 0;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v13 + 16))(&format, v13, kAlertDialogLocalizationTable, @"OK", 1);
      CFDictionaryRef dictionary = 0;
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFDictionaryRef v18 = dictionary;
        CFDictionaryRef dictionary = Mutable;
        *(void *)long long buf = v18;
        sub_10005717C((const void **)buf);
      }
      sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertHeaderKey, (uint64_t)v58);
      sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertMessageKey, (uint64_t)v57);
      sub_10010F3F0(dictionary, (void *)kCFUserNotificationDefaultButtonTitleKey, (uint64_t)format);
      sub_10012C97C(dictionary, SBUserNotificationPendInSetupIfNotAllowedKey, (uint64_t)kCFBooleanTrue);
      SInt32 error = 0;
      CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, &error, dictionary);
      uint64_t v19 = error;
      if (error)
      {
        uint64_t v20 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "User notification failed! SInt32 error = %ld", buf, 0xCu);
        }
      }
      sub_10005717C((const void **)&dictionary);
      sub_1000558F4((const void **)&format);
LABEL_22:
      if ((v14 & 1) == 0) {
        sub_10004D2C8(v12);
      }
      sub_1000558F4(&v57);
      return sub_1000558F4(&v58);
    default:
      goto LABEL_16;
  }
}

void sub_100E3B9A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  unsigned int v10 = va_arg(va1, const void *);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100E3BBE4(uint64_t a1, uint64_t a2)
{
  return sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));
}

const void **sub_100E3BBF0(uint64_t a1)
{
  return sub_1000558F4((const void **)(a1 + 40));
}

void sub_100E3BBF8(uint64_t a1, char a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100E3BC70;
  v2[3] = &unk_1019BB378;
  v2[4] = a1;
  char v3 = a2;
  sub_100E42808((uint64_t *)(a1 + 8), v2);
}

void sub_100E3BC70(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    sub_100E3BC84(*(void *)(a1 + 32));
  }
}

void sub_100E3BC84(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I reset alerts to false", v3, 2u);
  }
  *(unsigned char *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 64) = 0;
}

void sub_100E3BCF0(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E3BD64;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

void sub_100E3BD64(uint64_t a1)
{
}

const void **sub_100E3BD6C(uint64_t a1, char a2, const void **a3, const void **a4)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768;
  CFTypeRef v7[2] = sub_100E3BE28;
  v7[3] = &unk_101A600A0;
  char v5 = (uint64_t *)(a1 + 8);
  v7[4] = a1;
  char v10 = a2;
  sub_100083DA4(&v8, a3);
  sub_100083DA4(&v9, a4);
  sub_100E42808(v5, v7);
  sub_1000558F4(&v9);
  return sub_1000558F4(&v8);
}

const void **sub_100E3BE28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v99 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v2 + 72));
  char v4 = ServiceMap;
  unint64_t v6 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v100 = v6;
  char v10 = sub_10004D37C(&v4[1].__m_.__sig, &v100);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unsigned int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = kAlertDialogLocalizationTable;
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v99, v12, kAlertDialogLocalizationTable, @"Data Status Changed", 1);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  v98 = 0;
  CFTypeRef v16 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(v2 + 72));
  CFStringRef v17 = v16;
  unint64_t v18 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  unint64_t v100 = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v100);
  if (v22)
  {
    uint64_t v24 = v22[3];
    CFTypeRef v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  CFTypeRef v23 = 0;
  char v25 = 1;
LABEL_19:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v24 + 16))(&v98, v24, v14, @"Your plan has been updated to have high speed data.", 1);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  unsigned int v97 = 0;
  CFTypeRef v27 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(v2 + 72));
  id v28 = v27;
  unint64_t v29 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    CFTypeRef v30 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      unint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  unint64_t v100 = v29;
  uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, &v100);
  if (v33)
  {
    uint64_t v35 = v33[3];
    CFTypeRef v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v28);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v28);
  CFTypeRef v34 = 0;
  char v36 = 1;
LABEL_29:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v35 + 16))(&v97, v35, v14, @"Cellular Data Plan Usage", 1);
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  uint64_t v96 = 0;
  CFTypeRef v38 = (std::mutex *)Registry::getServiceMap(v37, *(Registry **)(v2 + 72));
  uint64_t v39 = v38;
  unint64_t v40 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    CFTypeRef v41 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      unint64_t v40 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(v38);
  unint64_t v100 = v40;
  uint64_t v44 = sub_10004D37C(&v39[1].__m_.__sig, &v100);
  if (v44)
  {
    uint64_t v46 = v44[3];
    CFTypeRef v45 = (std::__shared_weak_count *)v44[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v39);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v47 = 0;
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v46 = 0;
  }
  std::mutex::unlock(v39);
  CFTypeRef v45 = 0;
  char v47 = 1;
LABEL_39:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v46 + 16))(&v96, v46, v14, @"No high speed data remains on your current plan. You can continue with low speed data or add more high speed data in Settings.", 1);
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  CFStringRef v95 = 0;
  CFTypeRef v49 = (std::mutex *)Registry::getServiceMap(v48, *(Registry **)(v2 + 72));
  uint64_t v50 = v49;
  unint64_t v51 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    CFTypeRef v52 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v53 = 5381;
    do
    {
      unint64_t v51 = v53;
      unsigned int v54 = *v52++;
      uint64_t v53 = (33 * v53) ^ v54;
    }
    while (v54);
  }
  std::mutex::lock(v49);
  unint64_t v100 = v51;
  char v55 = sub_10004D37C(&v50[1].__m_.__sig, &v100);
  if (v55)
  {
    uint64_t v57 = v55[3];
    CFStringRef v56 = (std::__shared_weak_count *)v55[4];
    if (v56)
    {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v50);
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v56);
      char v58 = 0;
      goto LABEL_49;
    }
  }
  else
  {
    uint64_t v57 = 0;
  }
  std::mutex::unlock(v50);
  CFStringRef v56 = 0;
  char v58 = 1;
LABEL_49:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v57 + 16))(&v95, v57, v14, @"Settings", 1);
  if ((v58 & 1) == 0) {
    sub_10004D2C8(v56);
  }
  uint64_t v94 = 0;
  CFStringRef v60 = (std::mutex *)Registry::getServiceMap(v59, *(Registry **)(v2 + 72));
  uint64_t v61 = v60;
  unint64_t v62 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    v63 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v64 = 5381;
    do
    {
      unint64_t v62 = v64;
      unsigned int v65 = *v63++;
      uint64_t v64 = (33 * v64) ^ v65;
    }
    while (v65);
  }
  std::mutex::lock(v60);
  unint64_t v100 = v62;
  v66 = sub_10004D37C(&v61[1].__m_.__sig, &v100);
  if (v66)
  {
    uint64_t v68 = v66[3];
    char v67 = (std::__shared_weak_count *)v66[4];
    if (v67)
    {
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v61);
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v67);
      char v69 = 0;
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v68 = 0;
  }
  std::mutex::unlock(v61);
  char v67 = 0;
  char v69 = 1;
LABEL_59:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v68 + 16))(&v94, v68, v14, @"Later", 1);
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v67);
  }
  v93 = 0;
  uint64_t v71 = (std::mutex *)Registry::getServiceMap(v70, *(Registry **)(v2 + 72));
  v72 = v71;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v73 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v74 = 5381;
    do
    {
      unint64_t v5 = v74;
      unsigned int v75 = *v73++;
      uint64_t v74 = (33 * v74) ^ v75;
    }
    while (v75);
  }
  std::mutex::lock(v71);
  unint64_t v100 = v5;
  v76 = sub_10004D37C(&v72[1].__m_.__sig, &v100);
  if (v76)
  {
    uint64_t v78 = v76[3];
    uint64_t v77 = (std::__shared_weak_count *)v76[4];
    if (v77)
    {
      atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v72);
      atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v77);
      char v79 = 0;
      goto LABEL_69;
    }
  }
  else
  {
    uint64_t v78 = 0;
  }
  std::mutex::unlock(v72);
  uint64_t v77 = 0;
  char v79 = 1;
LABEL_69:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v78 + 16))(&v93, v78, v14, @"OK", 1);
  if ((v79 & 1) == 0) {
    sub_10004D2C8(v77);
  }
  if (*(unsigned char *)(a1 + 56))
  {
    v80 = &v94;
    v81 = &v96;
    v82 = &v97;
    CFStringRef v83 = v95;
  }
  else
  {
    CFStringRef v83 = 0;
    v80 = &v93;
    v81 = &v98;
    v82 = &v99;
  }
  CFStringRef v84 = (const __CFString *)*v80;
  CFStringRef v85 = (const __CFString *)*v81;
  CFStringRef v86 = (const __CFString *)*v82;
  unint64_t v100 = 0;
  v87 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I showing throttle transition alert", buf, 2u);
  }
  CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v86, v85, v84, v83, 0, &v100);
  if (*(unsigned char *)(a1 + 56) && v100 == 1)
  {
    if (*(void *)(a1 + 40)) {
      v88 = sub_1000810B8;
    }
    else {
      v88 = 0;
    }
    if (v88)
    {
      uint64_t v89 = *(void *)(a1 + 48);
      v101[0] = @"Iccid";
      v101[1] = @"FlowTypeKey";
      v102[0] = v89;
      v102[1] = &off_101AE6400;
      v90 = +[NSDictionary dictionaryWithObjects:v102 forKeys:v101 count:2];
      [*(id *)(v2 + 56) launchWithServiceName:@"com.apple.SIMSetupUIService" viewControllerClassName:@"TSSIMSetupSupportViewController" options:v90];
    }
  }
  sub_1000558F4(&v93);
  sub_1000558F4(&v94);
  sub_1000558F4((const void **)&v95);
  sub_1000558F4(&v96);
  sub_1000558F4(&v97);
  sub_1000558F4(&v98);
  return sub_1000558F4(&v99);
}

void sub_100E3C630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va6, a4);
  va_start(va5, a4);
  va_start(va4, a4);
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  unint64_t v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  char v10 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v12 = va_arg(va4, const void *);
  va_copy(va5, va4);
  uint64_t v14 = va_arg(va5, const void *);
  va_copy(va6, va5);
  CFTypeRef v16 = va_arg(va6, const void *);

  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)va4);
  sub_1000558F4((const void **)va5);
  sub_1000558F4((const void **)va6);
  _Unwind_Resume(a1);
}

void sub_100E3C758()
{
}

void sub_100E3C760()
{
}

void sub_100E3C768()
{
}

const void **sub_100E3C770(uint64_t a1, uint64_t a2)
{
  sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100083DA4((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_100E3C7B8(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 40);
  sub_1000558F4((const void **)(a1 + 48));

  return sub_1000558F4(v1);
}

void sub_100E3C7F4(uint64_t a1, id *a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3321888768;
  v4[2] = sub_100E3C89C;
  v4[3] = &unk_101A600D0;
  v4[4] = a1;
  aBlock = objc_retainBlock(*a2);
  sub_100E42808(v2, v4);
  if (aBlock)
  {
    _Block_release(aBlock);
    char v3 = aBlock;
  }
  else
  {
    char v3 = 0;
  }
}

const void **sub_100E3C89C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Show Enable Roaming in Monitor Mode Alert", buf, 2u);
  }
  CFStringRef v57 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 72));
  unint64_t v6 = ServiceMap;
  uint64_t v8 = v7;
  if (v7 < 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    char v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v6);
  char v13 = 0;
  char v15 = 1;
LABEL_11:
  uint64_t v16 = kAlertDialogLocalizationTable;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v14 + 16))(&v57, v14, kAlertDialogLocalizationTable, @"Data Roaming is turned off", 1);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  CFStringRef v56 = 0;
  unint64_t v18 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(v2 + 72));
  uint64_t v19 = v18;
  uint64_t v20 = v7;
  if (v7 < 0)
  {
    unsigned int v21 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v18);
  *(void *)long long buf = v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v24)
  {
    uint64_t v26 = v24[3];
    char v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v19);
  char v25 = 0;
  char v27 = 1;
LABEL_21:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v26 + 16))(&v56, v26, v16, @"Enable Data Roaming to use your plan. If not, you can enable data roaming in Settings > Cellular. Additional fees may apply.", 1);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  CFStringRef v55 = 0;
  unint64_t v29 = (std::mutex *)Registry::getServiceMap(v28, *(Registry **)(v2 + 72));
  CFTypeRef v30 = v29;
  uint64_t v31 = v7;
  if (v7 < 0)
  {
    unsigned int v32 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v33 = 5381;
    do
    {
      uint64_t v31 = v33;
      unsigned int v34 = *v32++;
      uint64_t v33 = (33 * v33) ^ v34;
    }
    while (v34);
  }
  std::mutex::lock(v29);
  *(void *)long long buf = v31;
  uint64_t v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
  if (v35)
  {
    uint64_t v37 = v35[3];
    char v36 = (std::__shared_weak_count *)v35[4];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v30);
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v36);
      char v38 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v37 = 0;
  }
  std::mutex::unlock(v30);
  char v36 = 0;
  char v38 = 1;
LABEL_31:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v37 + 16))(&v55, v37, v16, @"CANCEL", 1);
  if ((v38 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  CFStringRef v54 = 0;
  unint64_t v40 = (std::mutex *)Registry::getServiceMap(v39, *(Registry **)(v2 + 72));
  CFTypeRef v41 = v40;
  if (v7 < 0)
  {
    uint64_t v42 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v43 = 5381;
    do
    {
      uint64_t v7 = v43;
      unsigned int v44 = *v42++;
      uint64_t v43 = (33 * v43) ^ v44;
    }
    while (v44);
  }
  std::mutex::lock(v40);
  *(void *)long long buf = v7;
  CFTypeRef v45 = sub_10004D37C(&v41[1].__m_.__sig, (unint64_t *)buf);
  if (v45)
  {
    uint64_t v47 = v45[3];
    uint64_t v46 = (std::__shared_weak_count *)v45[4];
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v41);
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v46);
      char v48 = 0;
      goto LABEL_41;
    }
  }
  else
  {
    uint64_t v47 = 0;
  }
  std::mutex::unlock(v41);
  uint64_t v46 = 0;
  char v48 = 1;
LABEL_41:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v47 + 16))(&v54, v47, v16, @"Enable", 1);
  if ((v48 & 1) == 0) {
    sub_10004D2C8(v46);
  }
  CFStringRef v50 = v56;
  CFStringRef v49 = v57;
  CFStringRef v51 = v54;
  CFStringRef v52 = v55;
  *(void *)long long buf = 0;
  *(unsigned char *)(v2 + 64) = 1;
  CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, v49, v50, v51, v52, 0, (CFOptionFlags *)buf);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  sub_1000558F4((const void **)&v54);
  sub_1000558F4((const void **)&v55);
  sub_1000558F4((const void **)&v56);
  return sub_1000558F4((const void **)&v57);
}

void sub_100E3CD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  char v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v8 = va_arg(va3, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  _Unwind_Resume(a1);
}

void sub_100E3CDC8()
{
}

id sub_100E3CDD0(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100E3CDFC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    _Block_release(v2);
    uint64_t v2 = *(void **)(a1 + 40);
  }
}

const void **sub_100E3CE40(uint64_t a1, int a2, int a3, int a4, int a5, const __CFString **a6)
{
  CFTypeRef v30 = 0;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v12 = v30;
    CFTypeRef v30 = Mutable;
    valuePtr = v12;
    sub_10005717C((const void **)&valuePtr);
  }
  CFNumberRef v31 = 0;
  LODWORD(valuePtr) = a2;
  CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v13)
  {
    uint64_t v14 = v31;
    CFNumberRef v31 = v13;
    valuePtr = v14;
    sub_1000570E8((const void **)&valuePtr);
  }
  uint64_t v29 = (uint64_t)v31;
  CFNumberRef v31 = 0;
  sub_1000570E8((const void **)&v31);
  sub_10069637C(v30, @"kCTRegistrationDataContextID", v29);
  sub_1000570E8((const void **)&v29);
  CFNumberRef v31 = 0;
  LODWORD(valuePtr) = a3;
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v15)
  {
    uint64_t v16 = v31;
    CFNumberRef v31 = v15;
    valuePtr = v16;
    sub_1000570E8((const void **)&valuePtr);
  }
  uint64_t v29 = (uint64_t)v31;
  CFNumberRef v31 = 0;
  sub_1000570E8((const void **)&v31);
  sub_10069637C(v30, @"kCTRegistrationDataActive", v29);
  sub_1000570E8((const void **)&v29);
  CFNumberRef v31 = 0;
  LODWORD(valuePtr) = a4;
  CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v17)
  {
    unint64_t v18 = v31;
    CFNumberRef v31 = v17;
    valuePtr = v18;
    sub_1000570E8((const void **)&valuePtr);
  }
  uint64_t v29 = (uint64_t)v31;
  CFNumberRef v31 = 0;
  sub_1000570E8((const void **)&v31);
  sub_10069637C(v30, @"kCTRegistrationDataAttached", v29);
  sub_1000570E8((const void **)&v29);
  CFNumberRef v31 = 0;
  LODWORD(valuePtr) = 63;
  CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v19)
  {
    uint64_t v20 = v31;
    CFNumberRef v31 = v19;
    valuePtr = v20;
    sub_1000570E8((const void **)&valuePtr);
  }
  uint64_t v29 = (uint64_t)v31;
  CFNumberRef v31 = 0;
  sub_1000570E8((const void **)&v31);
  sub_10069637C(v30, @"kCTRegistrationDataActivateFailure", v29);
  sub_1000570E8((const void **)&v29);
  sub_10010F3F0(v30, @"kCTRegistrationDataActivateFailureString", @"kCTErrorGprsServiceOptionNotSubscribed");
  unsigned int v21 = (uint64_t *)&kCFBooleanFalse;
  if (!a5) {
    unsigned int v21 = (uint64_t *)&kCFBooleanTrue;
  }
  sub_10012C97C(v30, @"kCTRegistrationCellularDataPlanNewAccount", *v21);
  sub_10010F3F0(v30, @"kCTRegistrationDataConnectionServices", @"kCTDataConnectionServiceTypeInternet");
  if (*a6) {
    uint64_t v22 = sub_1000810B8;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v22) {
    CFStringRef v23 = *a6;
  }
  else {
    CFStringRef v23 = &stru_101AC1B28;
  }
  sub_10010F3F0(v30, @"kCTRegistrationCellularDataPlanAccountURL", (uint64_t)v23);
  ctu::cf_to_xpc((uint64_t *)&valuePtr, v30, v24);
  xpc_object_t v25 = valuePtr;
  if (valuePtr && xpc_get_type(valuePtr) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v25);
  }
  else {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_release(valuePtr);
  valuePtr = (ctu *)v25;
  if (v25)
  {
    xpc_retain(v25);
    uint64_t v26 = (ctu *)v25;
  }
  else
  {
    uint64_t v26 = (ctu *)xpc_null_create();
    valuePtr = v26;
  }
  CFNumberRef v27 = (const __CFNumber *)xpc_null_create();
  CFNumberRef v31 = v27;
  sub_1000452AC(97, (xpc_object_t *)&valuePtr, (xpc_object_t *)&v31);
  xpc_release(v27);
  xpc_release(v26);
  xpc_release(v25);
  return sub_10005717C((const void **)&v30);
}

void sub_100E3D19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, __int16 a11, char a12, char a13)
{
  xpc_release(v15);
  xpc_release(v14);
  xpc_release(v13);
  sub_10005717C(&a10);
  _Unwind_Resume(a1);
}

void sub_100E3D234(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E3D2A8;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

id sub_100E3D2A8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 56) reactivateDataActivationIfPresent];
}

id sub_100E3D2B4(uint64_t a1)
{
  return [*(id *)(a1 + 56) isAlertHandleExistAndValid];
}

void sub_100E3D2C0(uint64_t a1, uint64_t a2, char a3, char a4, long long *a5, long long *a6)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3321888768;
  v9[2] = sub_100E3D3E4;
  v9[3] = &unk_101A60100;
  v9[4] = a1;
  char v14 = a3;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&v10, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v10 = *a5;
    uint64_t v11 = *((void *)a5 + 2);
  }
  char v15 = a4;
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long __p = *a6;
    uint64_t v13 = *((void *)a6 + 2);
  }
  sub_100E42808((uint64_t *)(a1 + 8), v9);
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
}

void sub_100E3D3C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E3D3E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = objc_opt_new();
  char v4 = v3;
  switch(*(unsigned char *)(a1 + 88))
  {
    case 0:
    case 5:
    case 7:
    case 9:
      unint64_t v5 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        int v16 = 136315138;
        uint64_t v17 = asString();
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Unsupported SetupFlowOption %s", (uint8_t *)&v16, 0xCu);
      }
      goto LABEL_27;
    case 1:
    case 8:
      [v3 setObject:&off_101AE6418 forKeyedSubscript:@"FlowTypeKey"];
      unint64_t v6 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        unint64_t v6 = (void *)*v6;
      }
      uint64_t v7 = +[NSString stringWithUTF8String:v6];
      [v4 setObject:v7 forKeyedSubscript:@"SetupNewIccidKey"];

      BOOL v8 = *(unsigned char *)(a1 + 89) == 0;
      CFStringRef v9 = @"ForceDualSIMSetup";
      goto LABEL_8;
    case 2:
    case 6:
      [v3 setObject:&off_101AE6430 forKeyedSubscript:@"FlowTypeKey"];
      BOOL v8 = *(unsigned __int8 *)(a1 + 88) == 2;
      CFStringRef v9 = @"RequireSetupKey-DEBUG";
LABEL_8:
      if (v8) {
        long long v10 = &__kCFBooleanFalse;
      }
      else {
        long long v10 = &__kCFBooleanTrue;
      }
      [v4 setObject:v10 forKeyedSubscript:v9];
      break;
    case 3:
    case 4:
      [v3 setObject:&off_101AE6448 forKeyedSubscript:@"FlowTypeKey"];
      if (*(unsigned char *)(a1 + 88) == 2) {
        uint64_t v11 = &__kCFBooleanFalse;
      }
      else {
        uint64_t v11 = &__kCFBooleanTrue;
      }
      [v4 setObject:v11 forKeyedSubscript:@"RequireSetupKey-DEBUG"];
      uint64_t v12 = (void *)(a1 + 64);
      if (*(char *)(a1 + 87) < 0) {
        uint64_t v12 = (void *)*v12;
      }
      goto LABEL_23;
    case 0xA:
    case 0xB:
      [v3 setObject:&off_101AE6460 forKeyedSubscript:@"FlowTypeKey"];
      if (*(unsigned char *)(a1 + 88) == 2) {
        uint64_t v13 = &__kCFBooleanFalse;
      }
      else {
        uint64_t v13 = &__kCFBooleanTrue;
      }
      [v4 setObject:v13 forKeyedSubscript:@"RequireSetupKey-DEBUG"];
      uint64_t v12 = (void *)(a1 + 64);
      if (*(char *)(a1 + 87) < 0) {
        uint64_t v12 = (void *)*v12;
      }
LABEL_23:
      char v14 = +[NSString stringWithUTF8String:v12];
      [v4 setObject:v14 forKeyedSubscript:@"CarrierNameKey"];

      break;
    default:
      break;
  }
  char v15 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 136315394;
    uint64_t v17 = asString();
    __int16 v18 = 2112;
    CFNumberRef v19 = v4;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Launch %s for SIMSetup with %@", (uint8_t *)&v16, 0x16u);
  }
  [*(id *)(v2 + 56) launchWithServiceName:@"com.apple.SIMSetupUIService" viewControllerClassName:@"TSSIMSetupSupportViewController" options:v4];
LABEL_27:
}

void sub_100E3D710(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unsigned char *sub_100E3D774(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  id result = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  long long v6 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)id result = v6;
  return result;
}

void sub_100E3D7FC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E3D818(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

const void **sub_100E3D870(uint64_t a1, const void **a2, const void **a3, const void **a4)
{
  long long v6 = (uint64_t *)(a1 + 8);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3321888768;
  CFTypeRef v8[2] = sub_100E3D948;
  v8[3] = &unk_101A60130;
  v8[4] = a1;
  sub_100083DA4(&v9, a2);
  sub_100058198(&v10, a3);
  sub_100083DA4(&v11, a4);
  sub_100E42808(v6, v8);
  sub_1000558F4(&v11);
  sub_100057D78(&v10);
  return sub_1000558F4(&v9);
}

void sub_100E3D948(void *a1)
{
  uint64_t v2 = a1[4];
  id v4 = (id)objc_opt_new();
  [v4 setObject:&off_101AE6478 forKey:@"FlowTypeKey"];
  [v4 setObject:a1[5] forKey:@"WebsheetURLKey"];
  [v4 setObject:a1[6] forKey:@"WebsheetPostdataKey"];
  if (a1[7]) {
    char v3 = sub_1000810B8;
  }
  else {
    char v3 = 0;
  }
  if (v3) {
    objc_msgSend(v4, "setObject:forKey:");
  }
  [*(id *)(v2 + 56) launchWithServiceName:@"com.apple.SIMSetupUIService" viewControllerClassName:@"TSSIMSetupSupportViewController" options:v4];
}

void sub_100E3DA20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

const void **sub_100E3DA34(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 5, a2 + 5);
  sub_100058198(a1 + 6, a2 + 6);

  return sub_100083DA4(a1 + 7, a2 + 7);
}

const void **sub_100E3DA88(const void **a1)
{
  uint64_t v1 = a1 + 5;
  uint64_t v2 = a1 + 6;
  sub_1000558F4(a1 + 7);
  sub_100057D78(v2);

  return sub_1000558F4(v1);
}

const void **sub_100E3DAD0(uint64_t a1, char a2, const void **a3, const void **a4)
{
  long long v6 = (uint64_t *)(a1 + 8);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3321888768;
  CFTypeRef v8[2] = sub_100E3DB98;
  v8[3] = &unk_101A600A0;
  v8[4] = a1;
  sub_100083DA4(&v9, a3);
  sub_100083DA4(&v10, a4);
  char v11 = a2;
  sub_100E42808(v6, v8);
  sub_1000558F4(&v10);
  return sub_1000558F4(&v9);
}

void sub_100E3DB98(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Show Cellular Activation Success/Failure Alert", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 72));
  long long v6 = ServiceMap;
  uint64_t v8 = v7;
  if (v7 < 0)
  {
    CFStringRef v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_11:
  CFStringRef v76 = 0;
  sub_100083DA4((const void **)&v76, (const void **)(a1 + 40));
  CFTypeRef cf = 0;
  sub_100083DA4(&cf, (const void **)(a1 + 48));
  CFStringRef v73 = 0;
  CFStringRef v74 = 0;
  CFStringRef defaultButtonTitle = 0;
  int v16 = (uint64_t *)*(unsigned __int8 *)(a1 + 56);
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v17 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v2 + 72));
    __int16 v18 = v17;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(v17);
    CFStringRef v77 = (const __CFString *)v19;
    CFStringRef v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v77);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
LABEL_26:
    (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v25 + 248))(buf, v25);
    uint64_t v37 = v71;
    if ((v71 & 0x80u) != 0) {
      uint64_t v37 = v70;
    }
    if (v37 == 4)
    {
      char v38 = *(uint8_t **)buf;
      if ((v71 & 0x80u) == 0) {
        char v38 = buf;
      }
      BOOL v39 = *(_DWORD *)v38 == 1684099177;
      if (((char)v71 & 0x80000000) == 0) {
        goto LABEL_35;
      }
    }
    else
    {
      BOOL v39 = 0;
      if (((char)v71 & 0x80000000) == 0)
      {
LABEL_35:
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        uint64_t v40 = kCBMessageLocalizationTable;
        if (v39)
        {
          (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, kCBMessageLocalizationTable, @"DATA_PLAN_ACTIVATION_TITLE", @"DATA_PLAN_ACTIVATION_TITLE");
          *(void *)long long buf = v74;
          CFStringRef v74 = v77;
          CFStringRef v77 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v77);
          (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v40, @"DATA_PLAN_ACTIVATION_MESSAGE", @"DATA_PLAN_ACTIVATION_MESSAGE");
        }
        else
        {
          (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, kCBMessageLocalizationTable, @"CELLULAR_PLAN_ACTIVATION_TITLE", @"CELLULAR_PLAN_ACTIVATION_TITLE");
          *(void *)long long buf = v74;
          CFStringRef v74 = v77;
          CFStringRef v77 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v77);
          (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v40, @"CELLULAR_PLAN_ACTIVATION_MESSAGE", @"CELLULAR_PLAN_ACTIVATION_MESSAGE");
        }
        goto LABEL_81;
      }
    }
    operator delete(*(void **)buf);
    goto LABEL_35;
  }
  CFNumberRef v27 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v2 + 72));
  id v28 = v27;
  if (v29 < 0)
  {
    CFTypeRef v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  CFStringRef v77 = (const __CFString *)v29;
  uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)&v77);
  if (v33)
  {
    uint64_t v35 = v33[3];
    unsigned int v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v28);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v28);
  unsigned int v34 = 0;
  char v36 = 1;
LABEL_42:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v35 + 248))(buf, v35);
  uint64_t v41 = v71;
  if ((v71 & 0x80u) != 0) {
    uint64_t v41 = v70;
  }
  if (v41 != 4)
  {
    BOOL v43 = 0;
    if (((char)v71 & 0x80000000) == 0) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  uint64_t v42 = *(uint8_t **)buf;
  if ((v71 & 0x80u) == 0) {
    uint64_t v42 = buf;
  }
  BOOL v43 = *(_DWORD *)v42 == 1684099177;
  if ((char)v71 < 0) {
LABEL_50:
  }
    operator delete(*(void **)buf);
LABEL_51:
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  uint64_t v44 = kCBMessageLocalizationTable;
  if (v43)
  {
    (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, kCBMessageLocalizationTable, @"DATA_PLAN_ACTIVATION_FAILURE_TITLE", @"DATA_PLAN_ACTIVATION_FAILURE_TITLE");
    *(void *)long long buf = v74;
    CFStringRef v74 = v77;
    CFStringRef v77 = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v77);
    (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v44, @"DATA_PLAN_ACTIVATION_FAILURE_MESSAGE", @"DATA_PLAN_ACTIVATION_FAILURE_MESSAGE");
LABEL_81:
    *(void *)long long buf = v73;
    CFStringRef v73 = v77;
    CFStringRef v77 = 0;
    goto LABEL_82;
  }
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, kCBMessageLocalizationTable, @"CELLULAR_PLAN_ACTIVATION_FAILURE_TITLE", @"CELLULAR_PLAN_ACTIVATION_FAILURE_TITLE");
  *(void *)long long buf = v74;
  CFStringRef v74 = v77;
  CFStringRef v77 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v77);
  CFStringRef v45 = (const __CFString *)cf;
  CFStringRef theString = (CFStringRef)cf;
  if (cf)
  {
    CFRetain(cf);
    CFStringRef v45 = theString;
  }
  if (v45) {
    uint64_t v46 = sub_1000810B8;
  }
  else {
    uint64_t v46 = 0;
  }
  if (!v46)
  {
    sub_1000558F4((const void **)&theString);
LABEL_71:
    CFStringRef v52 = v76;
    CFStringRef v66 = v76;
    if (v76)
    {
      CFRetain(v76);
      CFStringRef v52 = v66;
    }
    if (v52) {
      uint64_t v53 = sub_1000810B8;
    }
    else {
      uint64_t v53 = 0;
    }
    if (v53)
    {
      CFIndex Length = CFStringGetLength(v52);
      sub_1000558F4((const void **)&v66);
      if (Length)
      {
        CFStringRef v77 = 0;
        (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v44, @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_CARRIER_%@", @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_CARRIER_%@");
        CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v77, v76);
        goto LABEL_97;
      }
    }
    else
    {
      sub_1000558F4((const void **)&v66);
    }
    (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v44, @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE", @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE");
    goto LABEL_81;
  }
  CFIndex v47 = CFStringGetLength(v45);
  sub_1000558F4((const void **)&theString);
  if (!v47) {
    goto LABEL_71;
  }
  CFStringRef v48 = v76;
  CFStringRef v67 = v76;
  if (v76)
  {
    CFRetain(v76);
    CFStringRef v48 = v67;
  }
  if (v48) {
    CFStringRef v49 = sub_1000810B8;
  }
  else {
    CFStringRef v49 = 0;
  }
  if (!v49)
  {
    sub_1000558F4((const void **)&v67);
    goto LABEL_96;
  }
  CFIndex v50 = CFStringGetLength(v48);
  sub_1000558F4((const void **)&v67);
  if (!v50)
  {
LABEL_96:
    CFStringRef v77 = 0;
    (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v44, @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_NUMBER_%@", @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_NUMBER_%@");
    CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v77, cf);
    goto LABEL_97;
  }
  CFStringRef v77 = 0;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&v77, v14, v44, @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_NUMBER_AND_CARRIER_%@_%@", @"CELLULAR_PLAN_ACTIVATION_FAILURE_MESSAGE_WITH_NUMBER_AND_CARRIER_%@_%@");
  CFStringRef v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v77, cf, v76);
LABEL_97:
  CFStringRef v65 = v73;
  CFStringRef v73 = v51;
  *(void *)long long buf = v65;
LABEL_82:
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v77);
  CFStringRef v56 = (std::mutex *)Registry::getServiceMap(v55, *(Registry **)(v2 + 72));
  CFStringRef v57 = v56;
  if (v7 < 0)
  {
    char v58 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v59 = 5381;
    do
    {
      uint64_t v7 = v59;
      unsigned int v60 = *v58++;
      uint64_t v59 = (33 * v59) ^ v60;
    }
    while (v60);
  }
  std::mutex::lock(v56);
  *(void *)long long buf = v7;
  uint64_t v61 = sub_10004D37C(&v57[1].__m_.__sig, (unint64_t *)buf);
  if (v61)
  {
    uint64_t v63 = v61[3];
    unint64_t v62 = (std::__shared_weak_count *)v61[4];
    if (v62)
    {
      atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v57);
      atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v62);
      char v64 = 0;
      goto LABEL_90;
    }
  }
  else
  {
    uint64_t v63 = 0;
  }
  std::mutex::unlock(v57);
  unint64_t v62 = 0;
  char v64 = 1;
LABEL_90:
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v63 + 16))(&v77, v63, kAlertDialogLocalizationTable, @"OK", 1);
  *(void *)long long buf = defaultButtonTitle;
  CFStringRef defaultButtonTitle = v77;
  CFStringRef v77 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v77);
  if ((v64 & 1) == 0) {
    sub_10004D2C8(v62);
  }
  *(void *)long long buf = 0;
  CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v74, v73, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
  sub_1000558F4((const void **)&defaultButtonTitle);
  sub_1000558F4((const void **)&v73);
  sub_1000558F4((const void **)&v74);
  sub_1000558F4(&cf);
  sub_1000558F4((const void **)&v76);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100E3E578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va3, a11);
  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  char v15 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v17 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v19 = va_arg(va3, const void *);
  sub_1000558F4((const void **)(v13 - 88));
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)(v13 - 96));
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(a1);
}

void sub_100E3E66C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100E3E710;
  v3[3] = &unk_1019BB7D8;
  v3[4] = a1;
  void v3[5] = a2;
  v3[6] = a3;
  sub_100E42808((uint64_t *)(a1 + 8), v3);
}

void sub_100E3E710(void *a1)
{
  uint64_t v2 = a1[4];
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v2 + 72));
  id v4 = ServiceMap;
  if (v5 < 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long __p = v5;
  CFStringRef v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  CFStringRef v23 = 0;
  uint64_t v13 = kAlertDialogLocalizationTable;
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v11 + 16))(&v23, v11, kAlertDialogLocalizationTable, @"CELLULAR_PLAN_SETUP_NOTIFICATION_TITLE", 1);
  unsigned int v22 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v11 + 16))(&v22, v11, v13, @"CELLULAR_PLAN_SETUP_NOTIFICATION_MESSAGE", 1);
  uint64_t v15 = a1[5];
  uint64_t v16 = a1[6];
  uint64_t v17 = (ctu *)(a1 + 5);
  if (v15 | v16)
  {
    ctu::hex((uint64_t *)__p, v17, (const void *)0x10, v14);
    if (v25 >= 0) {
      __int16 v18 = __p;
    }
    else {
      __int16 v18 = *(unsigned char **)__p;
    }
    uint64_t v19 = +[NSString stringWithUTF8String:v18];
    if (v25 < 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  uint64_t v20 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    id v21 = [v19 UTF8String];
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Publish notification for csn:(%s)", __p, 0xCu);
  }
  [*(id *)(v2 + 48) publishUserNotificationWithBundleIdentifier:@"com.apple.Bridge" title:v23 body:v22 csn:v19];

  sub_1000558F4(&v22);
  sub_1000558F4(&v23);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100E3E994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_1000558F4((const void **)&a9);
  sub_1000558F4(&a10);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

void sub_100E3EA1C(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E3EA90;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

void sub_100E3EA90(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(v2 + 72));
  id v4 = ServiceMap;
  if (v5 < 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  CFStringRef v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
LABEL_11:
      CFStringRef v19 = 0;
      CFStringRef v20 = 0;
      CFStringRef defaultButtonTitle = 0;
      uint64_t v14 = kCBMessageLocalizationTable;
      (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v11 + 40))(&v17, v11, kCBMessageLocalizationTable, @"OK", @"OK");
      *(void *)long long buf = defaultButtonTitle;
      CFStringRef v15 = v17;
      CFStringRef v17 = 0;
      CFStringRef defaultButtonTitle = v15;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v17);
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v11 + 40))(&v17, v11, v14, @"NO_INTERNET_CONNECTION_TITLE", @"NO_INTERNET_CONNECTION_TITLE");
      CFStringRef v16 = v20;
      CFStringRef v20 = v17;
      *(void *)long long buf = v16;
      CFStringRef v17 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v17);
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v11 + 40))(&v17, v11, v14, @"NO_INTERNET_CONNECTION_MESSAGE", @"NO_INTERNET_CONNECTION_MESSAGE");
      *(void *)long long buf = v19;
      CFStringRef v19 = v17;
      CFStringRef v17 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v17);
      *(void *)long long buf = 0;
      CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v20, v19, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
      sub_1000558F4((const void **)&defaultButtonTitle);
      sub_1000558F4((const void **)&v19);
      sub_1000558F4((const void **)&v20);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v13 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
  }
LABEL_12:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100E3ED24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFStringRef v9 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

const void **sub_100E3ED64(uint64_t a1, int a2, const void **a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3321888768;
  v5[2] = sub_100E3EDFC;
  v5[3] = &unk_101A60160;
  char v3 = (uint64_t *)(a1 + 8);
  v5[4] = a1;
  int v7 = a2;
  sub_100083DA4(&v6, a3);
  sub_100E42808(v3, v5);
  return sub_1000558F4(&v6);
}

void sub_100E3EDFC(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(v3 + 72));
  char v5 = ServiceMap;
  if (v6 < 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
LABEL_11:
      CFStringRef v25 = 0;
      CFStringRef v26 = 0;
      CFStringRef defaultButtonTitle = 0;
      uint64_t v15 = kCBMessageLocalizationTable;
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, kCBMessageLocalizationTable, @"OK", @"OK");
      *(void *)long long buf = defaultButtonTitle;
      CFStringRef v16 = format;
      CFStringRef format = 0;
      CFStringRef defaultButtonTitle = v16;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&format);
      if (*(_DWORD *)(a1 + 48) > 1u)
      {
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_FAIL_TITLE", @"INSTALL_REPLACE_ESIM_FAIL_TITLE");
        CFStringRef v20 = v26;
        CFStringRef v26 = format;
        *(void *)long long buf = v20;
        CFStringRef format = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&format);
        if (*(void *)(a1 + 40)) {
          id v21 = sub_1000810B8;
        }
        else {
          id v21 = 0;
        }
        if (v21)
        {
          CFStringRef format = 0;
          (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_FAIL_MESSAGE_%@", @"INSTALL_REPLACE_ESIM_FAIL_MESSAGE_%@");
          CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
          goto LABEL_22;
        }
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_FAIL_MESSAGE", @"INSTALL_REPLACE_ESIM_FAIL_MESSAGE");
      }
      else
      {
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_SUCCESS_TITLE", @"INSTALL_REPLACE_ESIM_SUCCESS_TITLE");
        CFStringRef v17 = v26;
        CFStringRef v26 = format;
        *(void *)long long buf = v17;
        CFStringRef format = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&format);
        if (*(void *)(a1 + 40)) {
          char v18 = sub_1000810B8;
        }
        else {
          char v18 = 0;
        }
        if (v18)
        {
          CFStringRef format = 0;
          (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_SUCCESS_MESSAGE_%@", @"INSTALL_REPLACE_ESIM_SUCCESS_MESSAGE_%@");
          CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, *(void *)(a1 + 40));
LABEL_22:
          CFStringRef v22 = v25;
          CFStringRef v25 = StringWithValidatedFormat;
          *(void *)long long buf = v22;
LABEL_26:
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&format);
          *(void *)long long buf = 0;
          CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v26, v25, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
          sub_1000558F4((const void **)&defaultButtonTitle);
          sub_1000558F4((const void **)&v25);
          sub_1000558F4((const void **)&v26);
          goto LABEL_27;
        }
        (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&format, v12, v15, @"INSTALL_REPLACE_ESIM_SUCCESS_MESSAGE", @"INSTALL_REPLACE_ESIM_SUCCESS_MESSAGE");
      }
      *(void *)long long buf = v25;
      CFStringRef v25 = format;
      CFStringRef format = 0;
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (v12) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v14 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
  }
LABEL_27:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E3F270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  int v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unsigned int v9 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100E3F2D4(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E3F348;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

void sub_100E3F348(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(v2 + 72));
  id v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v13 = 1;
LABEL_9:
  CFTypeRef v30 = 0;
  uint64_t v14 = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(v2 + 72));
  uint64_t v15 = v14;
  if (v16 < 0)
  {
    CFStringRef v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(v14);
  uint64_t v31 = (void *)v16;
  CFStringRef v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&v31);
  if (v20)
  {
    uint64_t v22 = v20[3];
    id v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  id v21 = 0;
  char v23 = 1;
LABEL_17:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v22 + 248))(__p, v22);
  unint64_t v24 = v29;
  if ((v29 & 0x80u) != 0) {
    unint64_t v24 = (unint64_t)__p[1];
  }
  if (v24 != 4)
  {
    BOOL v26 = 0;
    if (((char)v29 & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  CFStringRef v25 = (void **)__p[0];
  if ((v29 & 0x80u) == 0) {
    CFStringRef v25 = __p;
  }
  BOOL v26 = *(_DWORD *)v25 == 1684099177;
  if ((char)v29 < 0) {
LABEL_25:
  }
    operator delete(__p[0]);
LABEL_26:
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  uint64_t v27 = kCBMessageLocalizationTable;
  if (v26) {
    (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v11 + 40))(&v31, v11, kCBMessageLocalizationTable, @"TRANSFER_TITLE_PAD", @"TRANSFER_TITLE_PAD");
  }
  else {
    (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v11 + 40))(&v31, v11, kCBMessageLocalizationTable, @"TRANSFER_TITLE", @"TRANSFER_TITLE");
  }
  __p[0] = v30;
  CFTypeRef v30 = v31;
  uint64_t v31 = 0;
  sub_1000558F4((const void **)__p);
  sub_1000558F4((const void **)&v31);
  __p[0] = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v11 + 40))(__p, v11, v27, @"ESIM_TRANSFER_ALERT_MESSAGE", @"ESIM_TRANSFER_ALERT_MESSAGE");
  [*(id *)(v2 + 48) publishUserNotificationWithBundleIdentifier:@"com.apple.Preferences" requestIdentifier:@"TRANSFER_TITLE" title:v30 body:__p[0] actionUrl:@"prefs:root=MOBILE_DATA_SETTINGS_ID" destinations:6];
  sub_1000558F4((const void **)__p);
  sub_1000558F4((const void **)&v30);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100E3F688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000558F4((const void **)va);
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_100E3F6E0(uint64_t a1, char a2, long long *a3, long long *a4, long long *a5)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3321888768;
  CFTypeRef v8[2] = sub_100E3F854;
  v8[3] = &unk_101A60190;
  v8[4] = a1;
  char v15 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    uint64_t v10 = *((void *)a3 + 2);
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&v11, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    uint64_t v12 = *((void *)a5 + 2);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long __p = *a4;
    uint64_t v14 = *((void *)a4 + 2);
  }
  sub_100E42808((uint64_t *)(a1 + 8), v8);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)v11);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
}

void sub_100E3F820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E3F854(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v1 + 72));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    long long v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  long long v9 = 0;
  char v11 = 1;
LABEL_9:
  uint64_t v12 = *(NSObject **)(v1 + 40);
  if (v10)
  {
    if (os_log_type_enabled(*(os_log_t *)(v1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      uint64_t v14 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v14 = (void *)*v14;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I showing Esim Setup Required alert - option (%s) url (%s)", buf, 0x16u);
    }
    CFStringRef v143 = 0;
    CFStringRef v144 = 0;
    CFStringRef v141 = 0;
    CFStringRef v142 = 0;
    CFStringRef v140 = 0;
    switch(*(unsigned char *)(a1 + 112))
    {
      case 0:
        uint64_t v15 = kCBMessageLocalizationTable;
        (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, kCBMessageLocalizationTable, @"SETUP_ESIM_TITLE", @"SETUP_ESIM_TITLE");
        *(void *)long long buf = v144;
        CFStringRef v144 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v15, @"SETUP_ESIM_MESSAGE", @"SETUP_ESIM_TITLE");
        *(void *)long long buf = v143;
        CFStringRef v143 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v15, @"SETUP", @"SETUP_ESIM_TITLE");
        *(void *)long long buf = v142;
        CFStringRef v142 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v15, @"CBMessageDeclineButton", @"SETUP_ESIM_TITLE");
        goto LABEL_214;
      case 1:
        uint64_t v16 = kCBMessageLocalizationTable;
        (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, kCBMessageLocalizationTable, @"CONTINUE_SETUP_ESIM_TITLE", @"CONTINUE_SETUP_ESIM_TITLE");
        *(void *)long long buf = v144;
        CFStringRef v144 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v16, @"SETUP_ESIM_MESSAGE", @"CONTINUE_SETUP_ESIM_TITLE");
        *(void *)long long buf = v143;
        CFStringRef v143 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v16, @"CONTINUE", @"CONTINUE_SETUP_ESIM_TITLE");
        *(void *)long long buf = v142;
        CFStringRef v142 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v16, @"CBMessageDeclineButton", @"CONTINUE_SETUP_ESIM_TITLE");
        goto LABEL_214;
      case 2:
        uint64_t v17 = kCBMessageLocalizationTable;
        (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, kCBMessageLocalizationTable, @"CROSS_PLATFORM_TRANFER_TITLE", @"CROSS_PLATFORM_TRANFER_TITLE");
        *(void *)long long buf = v144;
        CFStringRef v144 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        unsigned int v19 = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(v1 + 72));
        CFStringRef v20 = v19;
        if (v21 < 0)
        {
          uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v23 = 5381;
          do
          {
            uint64_t v21 = v23;
            unsigned int v24 = *v22++;
            uint64_t v23 = (33 * v23) ^ v24;
          }
          while (v24);
        }
        std::mutex::lock(v19);
        *(void *)&long long v146 = v21;
        CFStringRef v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v146);
        if (v25)
        {
          uint64_t v27 = v25[3];
          BOOL v26 = (std::__shared_weak_count *)v25[4];
          if (v26)
          {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v20);
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v26);
            char v28 = 0;
            goto LABEL_50;
          }
        }
        else
        {
          uint64_t v27 = 0;
        }
        std::mutex::unlock(v20);
        BOOL v26 = 0;
        char v28 = 1;
LABEL_50:
        (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v27 + 248))(buf, v27);
        uint64_t v62 = buf[23];
        if (buf[23] < 0) {
          uint64_t v62 = *(void *)&buf[8];
        }
        if (v62 != 4)
        {
          BOOL v64 = 0;
          if ((buf[23] & 0x80000000) == 0) {
            goto LABEL_59;
          }
          goto LABEL_58;
        }
        uint64_t v63 = *(_DWORD **)buf;
        if (buf[23] >= 0) {
          uint64_t v63 = buf;
        }
        BOOL v64 = *v63 == 1684099177;
        if ((buf[23] & 0x80000000) != 0) {
LABEL_58:
        }
          operator delete(*(void **)buf);
LABEL_59:
        if (v28)
        {
          if (v64) {
            goto LABEL_61;
          }
        }
        else
        {
          sub_10004D2C8(v26);
          if (v64)
          {
LABEL_61:
            (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v17, @"CROSS_PLATFORM_TRANFER_MESSAGE_%@", @"CROSS_PLATFORM_TRANFER_TITLE");
            *(void *)long long buf = v140;
            CFStringRef v140 = (const __CFString *)v146;
            *(void *)&long long v146 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v146);
            CFStringRef v65 = v140;
            if (*(char *)(a1 + 87) < 0)
            {
              sub_10004FC84(&__dst, *(void **)(a1 + 64), *(void *)(a1 + 72));
            }
            else
            {
              long long __dst = *(_OWORD *)(a1 + 64);
              uint64_t v138 = *(void *)(a1 + 80);
            }
            if (SHIBYTE(v138) < 0)
            {
              sub_10004FC84(&v146, (void *)__dst, *((unint64_t *)&__dst + 1));
            }
            else
            {
              long long v146 = __dst;
              uint64_t v147 = v138;
            }
            v145 = 0;
            if (SHIBYTE(v147) < 0)
            {
              sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
            }
            else
            {
              *(_OWORD *)long long buf = v146;
              *(void *)&uint8_t buf[16] = v147;
            }
            v148 = 0;
            if (ctu::cf::convert_copy())
            {
              CFStringRef v67 = v145;
              v145 = v148;
              uint64_t v149 = v67;
              sub_1000558F4(&v149);
            }
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            v139 = v145;
            v145 = 0;
            sub_1000558F4(&v145);
            if (SHIBYTE(v147) < 0) {
              operator delete((void *)v146);
            }
            CFStringRef v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v65, v139);
            CFStringRef v69 = v143;
            CFStringRef v143 = v68;
            *(void *)long long buf = v69;
            sub_1000558F4((const void **)buf);
            sub_1000558F4(&v139);
            if (SHIBYTE(v138) < 0)
            {
              uint64_t v70 = (void *)__dst;
LABEL_145:
              operator delete(v70);
              goto LABEL_146;
            }
            goto LABEL_146;
          }
        }
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v17, @"CROSS_PLATFORM_TRANFER_MESSAGE_%@_%@", @"CROSS_PLATFORM_TRANFER_TITLE");
        *(void *)long long buf = v140;
        CFStringRef v140 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        CFStringRef v66 = v140;
        if (*(char *)(a1 + 111) < 0)
        {
          sub_10004FC84(&v135, *(void **)(a1 + 88), *(void *)(a1 + 96));
        }
        else
        {
          long long v135 = *(_OWORD *)(a1 + 88);
          uint64_t v136 = *(void *)(a1 + 104);
        }
        if (SHIBYTE(v136) < 0)
        {
          sub_10004FC84(&v146, (void *)v135, *((unint64_t *)&v135 + 1));
        }
        else
        {
          long long v146 = v135;
          uint64_t v147 = v136;
        }
        v145 = 0;
        if (SHIBYTE(v147) < 0)
        {
          sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v146;
          *(void *)&uint8_t buf[16] = v147;
        }
        v148 = 0;
        if (ctu::cf::convert_copy())
        {
          unsigned __int8 v71 = v145;
          v145 = v148;
          uint64_t v149 = v71;
          sub_1000558F4(&v149);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        v139 = v145;
        v145 = 0;
        sub_1000558F4(&v145);
        if (SHIBYTE(v147) < 0) {
          operator delete((void *)v146);
        }
        v72 = v139;
        if (*(char *)(a1 + 87) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 64);
          uint64_t v133 = *(void *)(a1 + 80);
        }
        if (SHIBYTE(v133) < 0)
        {
          sub_10004FC84(&v146, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long v146 = __p;
          uint64_t v147 = v133;
        }
        v145 = 0;
        if (SHIBYTE(v147) < 0)
        {
          sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v146;
          *(void *)&uint8_t buf[16] = v147;
        }
        v148 = 0;
        if (ctu::cf::convert_copy())
        {
          v81 = v145;
          v145 = v148;
          uint64_t v149 = v81;
          sub_1000558F4(&v149);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v134 = v145;
        v145 = 0;
        sub_1000558F4(&v145);
        if (SHIBYTE(v147) < 0) {
          operator delete((void *)v146);
        }
        CFStringRef v82 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v66, v72, v134);
        CFStringRef v83 = v143;
        CFStringRef v143 = v82;
        *(void *)long long buf = v83;
        sub_1000558F4((const void **)buf);
        sub_1000558F4(&v134);
        if (SHIBYTE(v133) < 0) {
          operator delete((void *)__p);
        }
        sub_1000558F4(&v139);
        if (SHIBYTE(v136) < 0)
        {
          uint64_t v70 = (void *)v135;
          goto LABEL_145;
        }
LABEL_146:
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v17, @"TRANSFER_NUMBER", @"CROSS_PLATFORM_TRANFER_TITLE");
        *(void *)long long buf = v142;
        CFStringRef v142 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v17, @"CBMessageDeclineButton", @"CROSS_PLATFORM_TRANFER_TITLE");
        goto LABEL_214;
      case 3:
        unsigned __int8 v29 = (std::mutex *)Registry::getServiceMap((uint64_t *)a1, *(Registry **)(v1 + 72));
        CFTypeRef v30 = v29;
        uint64_t v32 = v31;
        if (v31 < 0)
        {
          uint64_t v33 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v34 = 5381;
          do
          {
            uint64_t v32 = v34;
            unsigned int v35 = *v33++;
            uint64_t v34 = (33 * v34) ^ v35;
          }
          while (v35);
        }
        std::mutex::lock(v29);
        *(void *)long long buf = v32;
        char v36 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
        if (v36)
        {
          uint64_t v38 = v36[3];
          uint64_t v37 = (std::__shared_weak_count *)v36[4];
          if (v37)
          {
            atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v30);
            atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v37);
            char v39 = 0;
            goto LABEL_33;
          }
        }
        else
        {
          uint64_t v38 = 0;
        }
        std::mutex::unlock(v30);
        uint64_t v37 = 0;
        char v39 = 1;
LABEL_33:
        int v40 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 72))(v38);
        if ((v39 & 1) == 0) {
          sub_10004D2C8(v37);
        }
        uint64_t v41 = kCBMessageLocalizationTable;
        if (v40)
        {
          (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, kCBMessageLocalizationTable, @"WLAN_REQUIRED_TITLE", @"WIFI_REQUIRED_TITLE");
          *(void *)long long buf = v144;
          CFStringRef v144 = (const __CFString *)v146;
          *(void *)&long long v146 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v146);
          BOOL v43 = (std::mutex *)Registry::getServiceMap(v42, *(Registry **)(v1 + 72));
          uint64_t v44 = v43;
          if (v31 < 0)
          {
            CFStringRef v45 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v46 = 5381;
            do
            {
              uint64_t v31 = v46;
              unsigned int v47 = *v45++;
              uint64_t v46 = (33 * v46) ^ v47;
            }
            while (v47);
          }
          std::mutex::lock(v43);
          *(void *)&long long v146 = v31;
          CFStringRef v48 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)&v146);
          if (v48)
          {
            uint64_t v50 = v48[3];
            CFStringRef v49 = (std::__shared_weak_count *)v48[4];
            if (v49)
            {
              atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v44);
              atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v49);
              char v51 = 0;
              goto LABEL_98;
            }
          }
          else
          {
            uint64_t v50 = 0;
          }
          std::mutex::unlock(v44);
          CFStringRef v49 = 0;
          char v51 = 1;
LABEL_98:
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v50 + 248))(buf, v50);
          uint64_t v73 = buf[23];
          if (buf[23] < 0) {
            uint64_t v73 = *(void *)&buf[8];
          }
          if (v73 == 4)
          {
            CFStringRef v74 = *(_DWORD **)buf;
            if (buf[23] >= 0) {
              CFStringRef v74 = buf;
            }
            BOOL v75 = *v74 == 1684099177;
            if ((buf[23] & 0x80000000) == 0)
            {
LABEL_104:
              if (v51) {
                goto LABEL_105;
              }
              goto LABEL_109;
            }
          }
          else
          {
            BOOL v75 = 0;
            if ((buf[23] & 0x80000000) == 0) {
              goto LABEL_104;
            }
          }
          operator delete(*(void **)buf);
          if (v51)
          {
LABEL_105:
            if (v75)
            {
LABEL_106:
              (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WLAN_REQUIRED_MESSAGE", @"WIFI_REQUIRED_TITLE");
              *(void *)long long buf = v143;
              CFStringRef v143 = (const __CFString *)v146;
              *(void *)&long long v146 = 0;
              sub_1000558F4((const void **)buf);
              sub_1000558F4((const void **)&v146);
LABEL_200:
              (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WLAN_REQUIRED_BUTTON", @"WIFI_REQUIRED_TITLE");
              goto LABEL_213;
            }
LABEL_110:
            (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WLAN_REQUIRED_MESSAGE_%@", @"WIFI_REQUIRED_TITLE");
            *(void *)long long buf = v140;
            CFStringRef v140 = (const __CFString *)v146;
            *(void *)&long long v146 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v146);
            CFStringRef v76 = v140;
            if (*(char *)(a1 + 111) < 0)
            {
              sub_10004FC84(v130, *(void **)(a1 + 88), *(void *)(a1 + 96));
            }
            else
            {
              *(_OWORD *)uint64_t v130 = *(_OWORD *)(a1 + 88);
              uint64_t v131 = *(void *)(a1 + 104);
            }
            if (SHIBYTE(v131) < 0)
            {
              sub_10004FC84(&v146, v130[0], (unint64_t)v130[1]);
            }
            else
            {
              long long v146 = *(_OWORD *)v130;
              uint64_t v147 = v131;
            }
            v145 = 0;
            if (SHIBYTE(v147) < 0)
            {
              sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
            }
            else
            {
              *(_OWORD *)long long buf = v146;
              *(void *)&uint8_t buf[16] = v147;
            }
            v148 = 0;
            if (ctu::cf::convert_copy())
            {
              CFStringRef v84 = v145;
              v145 = v148;
              uint64_t v149 = v84;
              sub_1000558F4(&v149);
            }
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            v139 = v145;
            v145 = 0;
            sub_1000558F4(&v145);
            if (SHIBYTE(v147) < 0) {
              operator delete((void *)v146);
            }
            CFStringRef v85 = v139;
            if (*(char *)(a1 + 87) < 0)
            {
              sub_10004FC84(v128, *(void **)(a1 + 64), *(void *)(a1 + 72));
            }
            else
            {
              *(_OWORD *)uint64_t v128 = *(_OWORD *)(a1 + 64);
              uint64_t v129 = *(void *)(a1 + 80);
            }
            if (SHIBYTE(v129) < 0)
            {
              sub_10004FC84(&v146, v128[0], (unint64_t)v128[1]);
            }
            else
            {
              long long v146 = *(_OWORD *)v128;
              uint64_t v147 = v129;
            }
            v145 = 0;
            if (SHIBYTE(v147) < 0)
            {
              sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
            }
            else
            {
              *(_OWORD *)long long buf = v146;
              *(void *)&uint8_t buf[16] = v147;
            }
            v148 = 0;
            if (ctu::cf::convert_copy())
            {
              v88 = v145;
              v145 = v148;
              uint64_t v149 = v88;
              sub_1000558F4(&v149);
            }
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v134 = v145;
            v145 = 0;
            sub_1000558F4(&v145);
            if (SHIBYTE(v147) < 0) {
              operator delete((void *)v146);
            }
            CFStringRef v89 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v76, v85, v134);
            CFStringRef v90 = v143;
            CFStringRef v143 = v89;
            *(void *)long long buf = v90;
            sub_1000558F4((const void **)buf);
            sub_1000558F4(&v134);
            if (SHIBYTE(v129) < 0) {
              operator delete(v128[0]);
            }
            sub_1000558F4(&v139);
            if (SHIBYTE(v131) < 0) {
              operator delete(v130[0]);
            }
            goto LABEL_200;
          }
LABEL_109:
          sub_10004D2C8(v49);
          if (v75) {
            goto LABEL_106;
          }
          goto LABEL_110;
        }
        (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, kCBMessageLocalizationTable, @"WIFI_REQUIRED_TITLE", @"WIFI_REQUIRED_TITLE");
        *(void *)long long buf = v144;
        CFStringRef v144 = (const __CFString *)v146;
        *(void *)&long long v146 = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)&v146);
        uint64_t v53 = (std::mutex *)Registry::getServiceMap(v52, *(Registry **)(v1 + 72));
        CFStringRef v54 = v53;
        if (v31 < 0)
        {
          CFStringRef v55 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v56 = 5381;
          do
          {
            uint64_t v31 = v56;
            unsigned int v57 = *v55++;
            uint64_t v56 = (33 * v56) ^ v57;
          }
          while (v57);
        }
        std::mutex::lock(v53);
        *(void *)&long long v146 = v31;
        char v58 = sub_10004D37C(&v54[1].__m_.__sig, (unint64_t *)&v146);
        if (v58)
        {
          uint64_t v60 = v58[3];
          uint64_t v59 = (std::__shared_weak_count *)v58[4];
          if (v59)
          {
            atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v54);
            atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v59);
            char v61 = 0;
            goto LABEL_114;
          }
        }
        else
        {
          uint64_t v60 = 0;
        }
        std::mutex::unlock(v54);
        uint64_t v59 = 0;
        char v61 = 1;
LABEL_114:
        (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v60 + 248))(buf, v60);
        uint64_t v77 = buf[23];
        if (buf[23] < 0) {
          uint64_t v77 = *(void *)&buf[8];
        }
        if (v77 == 4)
        {
          uint64_t v78 = *(_DWORD **)buf;
          if (buf[23] >= 0) {
            uint64_t v78 = buf;
          }
          BOOL v79 = *v78 == 1684099177;
          if ((buf[23] & 0x80000000) == 0)
          {
LABEL_120:
            if (v61) {
              goto LABEL_121;
            }
            goto LABEL_125;
          }
        }
        else
        {
          BOOL v79 = 0;
          if ((buf[23] & 0x80000000) == 0) {
            goto LABEL_120;
          }
        }
        operator delete(*(void **)buf);
        if (v61)
        {
LABEL_121:
          if (v79)
          {
LABEL_122:
            (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WIFI_REQUIRED_MESSAGE", @"WIFI_REQUIRED_TITLE");
            *(void *)long long buf = v143;
            CFStringRef v143 = (const __CFString *)v146;
            *(void *)&long long v146 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v146);
            goto LABEL_212;
          }
LABEL_126:
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WIFI_REQUIRED_MESSAGE_%@", @"WIFI_REQUIRED_TITLE");
          *(void *)long long buf = v140;
          CFStringRef v140 = (const __CFString *)v146;
          *(void *)&long long v146 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v146);
          CFStringRef v80 = v140;
          if (*(char *)(a1 + 111) < 0)
          {
            sub_10004FC84(v126, *(void **)(a1 + 88), *(void *)(a1 + 96));
          }
          else
          {
            *(_OWORD *)v126 = *(_OWORD *)(a1 + 88);
            uint64_t v127 = *(void *)(a1 + 104);
          }
          if (SHIBYTE(v127) < 0)
          {
            sub_10004FC84(&v146, v126[0], (unint64_t)v126[1]);
          }
          else
          {
            long long v146 = *(_OWORD *)v126;
            uint64_t v147 = v127;
          }
          v145 = 0;
          if (SHIBYTE(v147) < 0)
          {
            sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
          }
          else
          {
            *(_OWORD *)long long buf = v146;
            *(void *)&uint8_t buf[16] = v147;
          }
          v148 = 0;
          if (ctu::cf::convert_copy())
          {
            CFStringRef v86 = v145;
            v145 = v148;
            uint64_t v149 = v86;
            sub_1000558F4(&v149);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          v139 = v145;
          v145 = 0;
          sub_1000558F4(&v145);
          if (SHIBYTE(v147) < 0) {
            operator delete((void *)v146);
          }
          v87 = v139;
          if (*(char *)(a1 + 87) < 0)
          {
            sub_10004FC84(v124, *(void **)(a1 + 64), *(void *)(a1 + 72));
          }
          else
          {
            *(_OWORD *)v124 = *(_OWORD *)(a1 + 64);
            uint64_t v125 = *(void *)(a1 + 80);
          }
          if (SHIBYTE(v125) < 0)
          {
            sub_10004FC84(&v146, v124[0], (unint64_t)v124[1]);
          }
          else
          {
            long long v146 = *(_OWORD *)v124;
            uint64_t v147 = v125;
          }
          v145 = 0;
          if (SHIBYTE(v147) < 0)
          {
            sub_10004FC84(buf, (void *)v146, *((unint64_t *)&v146 + 1));
          }
          else
          {
            *(_OWORD *)long long buf = v146;
            *(void *)&uint8_t buf[16] = v147;
          }
          v148 = 0;
          if (ctu::cf::convert_copy())
          {
            char v91 = v145;
            v145 = v148;
            uint64_t v149 = v91;
            sub_1000558F4(&v149);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v134 = v145;
          v145 = 0;
          sub_1000558F4(&v145);
          if (SHIBYTE(v147) < 0) {
            operator delete((void *)v146);
          }
          CFStringRef v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v80, v87, v134);
          CFStringRef v93 = v143;
          CFStringRef v143 = v92;
          *(void *)long long buf = v93;
          sub_1000558F4((const void **)buf);
          sub_1000558F4(&v134);
          if (SHIBYTE(v125) < 0) {
            operator delete(v124[0]);
          }
          sub_1000558F4(&v139);
          if (SHIBYTE(v127) < 0) {
            operator delete(v126[0]);
          }
LABEL_212:
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"WIFI_REQUIRED_BUTTON", @"WIFI_REQUIRED_TITLE");
LABEL_213:
          *(void *)long long buf = v142;
          CFStringRef v142 = (const __CFString *)v146;
          *(void *)&long long v146 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v146);
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v10 + 40))(&v146, v10, v41, @"CBMessageDeclineButton", @"WIFI_REQUIRED_TITLE");
LABEL_214:
          *(void *)long long buf = v141;
          CFStringRef v141 = (const __CFString *)v146;
          *(void *)&long long v146 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v146);
LABEL_215:
          *(void *)&long long v146 = 0;
          CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v144, v143, v142, v141, 0, (CFOptionFlags *)&v146);
          uint64_t v94 = (uint64_t *)v146;
          if ((void)v146)
          {
LABEL_216:
            CFStringRef v95 = (std::mutex *)Registry::getServiceMap(v94, *(Registry **)(v1 + 72));
            uint64_t v96 = v95;
            unsigned int v97 = "22CellularPlanController";
            if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
            {
              v98 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v99 = 5381;
              do
              {
                unsigned int v97 = (const char *)v99;
                unsigned int v100 = *v98++;
                uint64_t v99 = (33 * v99) ^ v100;
              }
              while (v100);
            }
            std::mutex::lock(v95);
            *(void *)long long buf = v97;
            v101 = sub_10004D37C(&v96[1].__m_.__sig, (unint64_t *)buf);
            if (v101)
            {
              uint64_t v103 = v101[3];
              char v102 = (std::__shared_weak_count *)v101[4];
              if (v102)
              {
                atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v96);
                atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v102);
                char v104 = 0;
                if (!v103) {
                  goto LABEL_222;
                }
                goto LABEL_230;
              }
            }
            else
            {
              uint64_t v103 = 0;
            }
            std::mutex::unlock(v96);
            char v102 = 0;
            char v104 = 1;
            if (!v103)
            {
LABEL_222:
              v105 = *(NSObject **)(v1 + 40);
              if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
              }
              goto LABEL_231;
            }
LABEL_230:
            (*(void (**)(uint64_t))(*(void *)v103 + 792))(v103);
LABEL_231:
            if ((v104 & 1) == 0) {
              sub_10004D2C8(v102);
            }
            goto LABEL_235;
          }
          unsigned int v106 = *(unsigned __int8 *)(a1 + 112);
          if (v106 < 2)
          {
            CFStringRef v107 = @"prefs:root=MOBILE_DATA_SETTINGS_ID&path=CELLULAR_PLAN_DESCRIPTION";
            goto LABEL_234;
          }
          if (v106 != 2)
          {
            if (v106 != 3)
            {
LABEL_235:
              sub_1000558F4((const void **)&v140);
              sub_1000558F4((const void **)&v141);
              sub_1000558F4((const void **)&v142);
              sub_1000558F4((const void **)&v143);
              sub_1000558F4((const void **)&v144);
              goto LABEL_236;
            }
            CFStringRef v107 = @"prefs:root=WIFI";
LABEL_234:
            uint64_t v108 = +[NSURL URLWithString:v107];
            unsigned int v109 = +[LSApplicationWorkspace defaultWorkspace];
            [v109 openSensitiveURL:v108 withOptions:0];

            goto LABEL_235;
          }
          if (*(char *)(a1 + 63) < 0) {
            uint64_t v94 = *(uint64_t **)(a1 + 48);
          }
          else {
            uint64_t v94 = (uint64_t *)*(unsigned __int8 *)(a1 + 63);
          }
          if (!v94) {
            goto LABEL_216;
          }
          v110 = (std::mutex *)Registry::getServiceMap(v94, *(Registry **)(v1 + 72));
          v111 = v110;
          if (v112 < 0)
          {
            v113 = (unsigned __int8 *)(v112 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v114 = 5381;
            do
            {
              uint64_t v112 = v114;
              unsigned int v115 = *v113++;
              uint64_t v114 = (33 * v114) ^ v115;
            }
            while (v115);
          }
          std::mutex::lock(v110);
          *(void *)long long buf = v112;
          v116 = sub_10004D37C(&v111[1].__m_.__sig, (unint64_t *)buf);
          if (v116)
          {
            uint64_t v118 = v116[3];
            uint64_t v117 = (std::__shared_weak_count *)v116[4];
            if (v117)
            {
              atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v111);
              atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v117);
              char v119 = 0;
LABEL_251:
              if (v118)
              {
                LOBYTE(v149) = 0;
                global_queue = dispatch_get_global_queue(0, 0);
                v121 = global_queue;
                if (global_queue)
                {
                  dispatch_retain(global_queue);
                  dispatch_object_t object = v121;
                  dispatch_retain(v121);
                }
                else
                {
                  dispatch_object_t object = 0;
                }
                *(void *)long long buf = off_101A60390;
                *(void *)&uint8_t buf[8] = v1;
                uint64_t v151 = buf;
                (*(void (**)(uint64_t, uint64_t, const void **, dispatch_object_t *, unsigned char *))(*(void *)v118 + 24))(v118, a1 + 40, &v149, &object, buf);
                sub_100060644(buf);
                if (object) {
                  dispatch_release(object);
                }
                if (v121) {
                  dispatch_release(v121);
                }
              }
              if ((v119 & 1) == 0) {
                sub_10004D2C8(v117);
              }
              goto LABEL_216;
            }
          }
          else
          {
            uint64_t v118 = 0;
          }
          std::mutex::unlock(v111);
          uint64_t v117 = 0;
          char v119 = 1;
          goto LABEL_251;
        }
LABEL_125:
        sub_10004D2C8(v59);
        if (v79) {
          goto LABEL_122;
        }
        goto LABEL_126;
      default:
        goto LABEL_215;
    }
  }
  if (os_log_type_enabled(*(os_log_t *)(v1 + 40), OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
  }
LABEL_236:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E412CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,const void *a61)
{
  sub_1000558F4((const void **)(v63 - 200));
  if (*(char *)(v63 - 169) < 0) {
    operator delete(*(void **)(v63 - 192));
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a61);
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_1000558F4((const void **)(v63 - 240));
  sub_1000558F4((const void **)(v63 - 232));
  sub_1000558F4((const void **)(v63 - 224));
  sub_1000558F4((const void **)(v63 - 216));
  sub_1000558F4((const void **)(v63 - 208));
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v61);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100E416F0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v5;
  }
  id result = (unsigned char *)(a1 + 88);
  if (*(char *)(a2 + 111) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  long long v7 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)id result = v7;
  return result;
}

void sub_100E417A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E417DC(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_100E41844(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E418B8;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

id sub_100E418B8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 48) removeNotificationWithBundleIdentifier:@"com.apple.Preferences" requestIdentifier:@"TRANSFER_TITLE"];
}

uint64_t sub_100E418D4(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 80))(a1, 0, 0);
}

void sub_100E41900(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E41974;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

void sub_100E41974(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Show Get Transfer Credentail Failure Alert", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 72));
  long long v5 = ServiceMap;
  if (v6 < 0)
  {
    long long v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_9:
    uint64_t v14 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E invalid localization", buf, 2u);
    }
    goto LABEL_20;
  }
LABEL_13:
  CFStringRef alertMessage = 0;
  CFStringRef alertHeader = 0;
  CFStringRef defaultButtonTitle = 0;
  uint64_t v15 = kCBMessageLocalizationTable;
  (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v12 + 40))(&v19, v12, kCBMessageLocalizationTable, @"GET_TRANSFER_CREDENTIAL_FAILURE_TITLE", 0);
  CFStringRef v16 = alertHeader;
  CFStringRef alertHeader = v19;
  *(void *)long long buf = v16;
  CFStringRef v19 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v19);
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v12 + 40))(&v19, v12, v15, @"GET_TRANSFER_CREDENTIAL_FAILURE", 0);
  *(void *)long long buf = alertMessage;
  CFStringRef alertMessage = v19;
  CFStringRef v19 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v19);
  (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v12 + 40))(&v19, v12, v15, @"OK", 0);
  *(void *)long long buf = defaultButtonTitle;
  CFStringRef v17 = v19;
  CFStringRef v19 = 0;
  CFStringRef defaultButtonTitle = v17;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v19);
  if (alertHeader && alertMessage && defaultButtonTitle)
  {
    *(void *)long long buf = 0;
    CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, alertHeader, alertMessage, defaultButtonTitle, 0, 0, (CFOptionFlags *)buf);
  }
  else
  {
    uint64_t v18 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E localization string does not exist", buf, 2u);
    }
  }
  sub_1000558F4((const void **)&defaultButtonTitle);
  sub_1000558F4((const void **)&alertMessage);
  sub_1000558F4((const void **)&alertHeader);
LABEL_20:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100E41C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  long long v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unsigned int v9 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100E41CD4(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100E41D48;
  v1[3] = &unk_1019A1BF8;
  v1[4] = a1;
  sub_100E42808((uint64_t *)(a1 + 8), v1);
}

void sub_100E41D48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(v1 + 64);
    int v4 = *(unsigned __int8 *)(v1 + 65);
    v5[0] = 67109376;
    v5[1] = v3;
    __int16 v6 = 1024;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Alerts State -- fDidShowExpiredAlert: %d, fDidShowMonitorModeAlert: %d", (uint8_t *)v5, 0xEu);
  }
}

void sub_100E41DF8(uint64_t a1, char a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100E41E70;
  v2[3] = &unk_1019BB378;
  v2[4] = a1;
  char v3 = a2;
  sub_100E42808((uint64_t *)(a1 + 8), v2);
}

void sub_100E41E70(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v7[0] = @"FlowTypeKey";
  uint64_t v3 = +[NSNumber numberWithInt:1];
  int v4 = (void *)v3;
  v7[1] = @"ConfirmationCodeRequiredKey";
  if (*(unsigned char *)(a1 + 40)) {
    char v5 = &__kCFBooleanTrue;
  }
  else {
    char v5 = &__kCFBooleanFalse;
  }
  v8[0] = v3;
  v8[1] = v5;
  __int16 v6 = +[NSDictionary dictionaryWithObjects:v8 forKeys:v7 count:2];

  [*(id *)(v2 + 56) launchWithServiceName:@"com.apple.SIMSetupUIService" viewControllerClassName:@"TSSIMSetupSupportViewController" options:v6];
}

void sub_100E41F64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E41F88(uint64_t a1, const void **a2)
{
  sub_100058198((const void **)&v4 + 1, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E42094(uint64_t a1, BOOL a2)
{
  xpc_object_t v20 = 0;
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v20 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v20 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v20 = v5;
LABEL_9:
  xpc_release(v4);
  long long __p = 0;
  long long v19 = 0uLL;
  sub_100058DB0(&__p, "");
  xpc_object_t v21 = 0;
  long long v22 = 0uLL;
  ctu::cf::assign();
  xpc_object_t v6 = v21;
  v23[0] = (xpc_object_t)v22;
  *(xpc_object_t *)((char *)v23 + 7) = *(xpc_object_t *)((char *)&v22 + 7);
  char v7 = HIBYTE(v22);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  long long __p = v6;
  *(xpc_object_t *)&long long v19 = v23[0];
  *(xpc_object_t *)((char *)&v19 + 7) = *(xpc_object_t *)((char *)v23 + 7);
  HIBYTE(v19) = v7;
  xpc_object_t v16 = xpc_BOOL_create(a2);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  p_p = &__p;
  if (v19 < 0) {
    p_p = __p;
  }
  xpc_object_t v21 = &v20;
  *(void *)&long long v22 = p_p;
  sub_100035E70((uint64_t)&v21, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v21 = 0;
  long long v22 = 0uLL;
  ctu::cf::assign();
  xpc_object_t v9 = v21;
  v23[0] = (xpc_object_t)v22;
  *(xpc_object_t *)((char *)v23 + 7) = *(xpc_object_t *)((char *)&v22 + 7);
  char v10 = HIBYTE(v22);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  long long __p = v9;
  *(xpc_object_t *)&long long v19 = v23[0];
  *(xpc_object_t *)((char *)&v19 + 7) = *(xpc_object_t *)((char *)v23 + 7);
  HIBYTE(v19) = v10;
  xpc_object_t v14 = xpc_BOOL_create(0);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  char v11 = &__p;
  if (v19 < 0) {
    char v11 = __p;
  }
  xpc_object_t v21 = &v20;
  *(void *)&long long v22 = v11;
  sub_100035E70((uint64_t)&v21, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_object_t v12 = v20;
  xpc_object_t v21 = v20;
  if (v20)
  {
    xpc_retain(v20);
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v21 = v12;
  }
  xpc_object_t v13 = xpc_null_create();
  v23[0] = v13;
  sub_1000452AC(98, &v21, v23);
  xpc_release(v13);
  xpc_release(v12);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  xpc_release(v20);
}

void sub_100E42350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100E4240C(void *a1@<X1>, void *a2@<X8>)
{
  xpc_object_t v4 = operator new(0xC8uLL);
  sub_100E42480(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;

  sub_1000B3BC8((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_100E4246C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100E42480(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A60288;
  sub_100E42578((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_100E424C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100E424DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A60288;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E424FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A60288;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E42550(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 232))();
}

uint64_t sub_100E42578(uint64_t a1, void *a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100E38FF4(a1, v5);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100E425D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E425EC(uint64_t a1)
{
  uint64_t v1 = ***(void ***)(a1 + 40);
  Registry::createRestModuleOneTimeUseConnection(&v4, *(Registry **)(v1 + 72));
  ctu::RestModule::connect();
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100058DB0(&__p, "/cc/props/frontmostapp");
  v8[0] = off_101A602D8;
  v8[1] = v1 + 104;
  v8[3] = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(v8);
  if (v7 < 0) {
    operator delete(__p);
  }
  uint64_t v2 = [[DataActivationLaunchHelper alloc] initWithLogger:v1 + 40];
  xpc_object_t v3 = *(void **)(v1 + 56);
  *(void *)(v1 + 56) = v2;
}

void sub_100E426F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100E42734()
{
}

void *sub_100E42748(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = off_101A602D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E42790(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A602D8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E427BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E427FC()
{
}

void sub_100E42808(uint64_t *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (!v4 || (v5 = *a1, (xpc_object_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  char v7 = v6;
  uint64_t v8 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_100E428F4;
  block[3] = &unk_101A60350;
  uint64_t v12 = v5;
  xpc_object_t v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  id v9 = v3;
  id v11 = v9;
  dispatch_async(v8, block);

  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
}

uint64_t sub_100E428F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100E42904(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E42920(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E42934()
{
}

void *sub_100E42948(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = off_101A60390;
  result[1] = v3;
  return result;
}

uint64_t sub_100E42990(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A60390;
  a2[1] = v2;
  return result;
}

void sub_100E429BC(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v2 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Failed to launch default browser", v3, 2u);
    }
  }
}

uint64_t sub_100E42A2C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A603F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E42A6C()
{
  return &off_101A603F0;
}

uint64_t *sub_100E42A78(void *a1)
{
  objc_msgSend(*(id *)(*(void *)*a1 + 56), "launchWithServiceName:viewControllerClassName:options:", @"com.apple.SIMSetupUIService", @"TSSIMSetupSupportViewController", *(void *)(*a1 + 8), a1, *a1);
  sub_10005F900(&v3);
  return sub_100046B58(&v2);
}

void sub_100E42AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100E42AEC()
{
}

void sub_100E42B14(uint64_t a1)
{
  *(void *)a1 = off_101A60410;
  uint64_t v12 = (void **)(a1 + 88);
  sub_100465E6C(&v12);
  uint64_t v2 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v2) {
    sub_100206334(a1 + 80, v2);
  }
  uint64_t v3 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v3) {
    sub_100206334(a1 + 72, v3);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v4) {
    sub_100206334(a1 + 64, v4);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v5) {
    sub_100206334(a1 + 56, v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    sub_100206334(a1 + 48, v6);
  }
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v7) {
    sub_100206334(a1 + 40, v7);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v8) {
    sub_100206334(a1 + 32, v8);
  }
  uint64_t v9 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v9) {
    sub_100206334(a1 + 24, v9);
  }
  uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v10) {
    sub_100206334(a1 + 16, v10);
  }
  uint64_t v11 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v11) {
    sub_100206334(a1 + 8, v11);
  }
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100E42C3C(uint64_t a1)
{
  sub_100E42B14(a1);

  operator delete();
}

uint64_t sub_100E42C74(uint64_t result, uint64_t a2)
{
  *(void *)id result = off_101A60410;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_DWORD *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  if (*(void *)(a2 + 72)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 88) != *(void *)(a2 + 96)) {
    sub_1004656A4();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  char v2 = *(unsigned char *)(a2 + 128);
  if ((v2 & 2) != 0)
  {
    int v4 = *(_DWORD *)(a2 + 116);
    *(unsigned char *)(result + 128) |= 2u;
    *(_DWORD *)(result + 116) = v4;
    char v2 = *(unsigned char *)(a2 + 128);
    if ((v2 & 1) == 0)
    {
LABEL_13:
      if ((v2 & 4) == 0) {
        goto LABEL_14;
      }
      goto LABEL_20;
    }
  }
  else if ((*(unsigned char *)(a2 + 128) & 1) == 0)
  {
    goto LABEL_13;
  }
  int v5 = *(_DWORD *)(a2 + 112);
  *(unsigned char *)(result + 128) |= 1u;
  *(_DWORD *)(result + 112) = v5;
  char v2 = *(unsigned char *)(a2 + 128);
  if ((v2 & 4) == 0)
  {
LABEL_14:
    if ((v2 & 8) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_20:
  int v6 = *(_DWORD *)(a2 + 120);
  *(unsigned char *)(result + 128) |= 4u;
  *(_DWORD *)(result + 120) = v6;
  if ((*(unsigned char *)(a2 + 128) & 8) != 0)
  {
LABEL_15:
    int v3 = *(_DWORD *)(a2 + 124);
    *(unsigned char *)(result + 128) |= 8u;
    *(_DWORD *)(result + 124) = v3;
  }
LABEL_16:
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 80)) {
    operator new();
  }
  if (*(void *)(a2 + 64)) {
    operator new();
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  return result;
}

uint64_t sub_100E4320C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }
  if (*(unsigned char *)(a1 + 128)) {
    PB::TextFormatter::format(this, "osVersion", *(_DWORD *)(a1 + 112));
  }
  if (*(void *)(a1 + 64)) {
    PB::TextFormatter::format();
  }
  if ((*(unsigned char *)(a1 + 128) & 2) != 0) {
    PB::TextFormatter::format(this, "radioSku", *(_DWORD *)(a1 + 116));
  }
  if (*(void *)(a1 + 72)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 80)) {
    PB::TextFormatter::format();
  }
  char v5 = *(unsigned char *)(a1 + 128);
  if ((v5 & 4) != 0)
  {
    PB::TextFormatter::format(this, "sgp22Version", *(_DWORD *)(a1 + 120));
    char v5 = *(unsigned char *)(a1 + 128);
  }
  if ((v5 & 8) != 0) {
    PB::TextFormatter::format(this, "simAllianceVersion", *(_DWORD *)(a1 + 124));
  }
  int v6 = *(uint64_t **)(a1 + 88);
  uint64_t v7 = *(uint64_t **)(a1 + 96);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "vinylInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100E43404(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_63:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        sub_100465C64();
      case 4u:
        operator new();
      case 5u:
        operator new();
      case 6u:
        *(unsigned char *)(a1 + 128) |= 2u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_102;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_74:
          LODWORD(v27) = 0;
          goto LABEL_102;
        }
        char v55 = 0;
        unsigned int v56 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        while (2)
        {
          if (v23 == v22)
          {
            LODWORD(v27) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v57 = v22 + 1;
            char v58 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v57;
            v27 |= (unint64_t)(v58 & 0x7F) << v55;
            if (v58 < 0)
            {
              v55 += 7;
              unint64_t v22 = v57;
              BOOL v14 = v56++ > 8;
              if (v14) {
                goto LABEL_74;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v27) = 0;
            }
          }
          break;
        }
LABEL_102:
        *(_DWORD *)(a1 + 116) = v27;
        goto LABEL_63;
      case 7u:
        *(unsigned char *)(a1 + 128) |= 1u;
        unint64_t v30 = *((void *)this + 1);
        unint64_t v31 = *((void *)this + 2);
        uint64_t v32 = *(void *)this;
        if (v30 <= 0xFFFFFFFFFFFFFFF5 && v30 + 10 <= v31)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            unint64_t v36 = v30 + 1;
            *((void *)this + 1) = v30 + 1;
            char v37 = *(unsigned char *)(v32 + v30);
            v35 |= (unint64_t)(v37 & 0x7F) << v33;
            if ((v37 & 0x80) == 0) {
              goto LABEL_105;
            }
            v33 += 7;
            unint64_t v30 = v36;
            BOOL v14 = v34++ > 8;
          }
          while (!v14);
LABEL_81:
          LODWORD(v35) = 0;
          goto LABEL_105;
        }
        char v59 = 0;
        unsigned int v60 = 0;
        uint64_t v35 = 0;
        if (v31 <= v30) {
          unint64_t v31 = *((void *)this + 1);
        }
        while (2)
        {
          if (v31 == v30)
          {
            LODWORD(v35) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v61 = v30 + 1;
            char v62 = *(unsigned char *)(v32 + v30);
            *((void *)this + 1) = v61;
            v35 |= (unint64_t)(v62 & 0x7F) << v59;
            if (v62 < 0)
            {
              v59 += 7;
              unint64_t v30 = v61;
              BOOL v14 = v60++ > 8;
              if (v14) {
                goto LABEL_81;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v35) = 0;
            }
          }
          break;
        }
LABEL_105:
        *(_DWORD *)(a1 + 112) = v35;
        goto LABEL_63;
      case 8u:
        *(unsigned char *)(a1 + 128) |= 4u;
        unint64_t v38 = *((void *)this + 1);
        unint64_t v39 = *((void *)this + 2);
        uint64_t v40 = *(void *)this;
        if (v38 <= 0xFFFFFFFFFFFFFFF5 && v38 + 10 <= v39)
        {
          char v41 = 0;
          unsigned int v42 = 0;
          uint64_t v43 = 0;
          do
          {
            unint64_t v44 = v38 + 1;
            *((void *)this + 1) = v38 + 1;
            char v45 = *(unsigned char *)(v40 + v38);
            v43 |= (unint64_t)(v45 & 0x7F) << v41;
            if ((v45 & 0x80) == 0) {
              goto LABEL_108;
            }
            v41 += 7;
            unint64_t v38 = v44;
            BOOL v14 = v42++ > 8;
          }
          while (!v14);
LABEL_88:
          LODWORD(v43) = 0;
          goto LABEL_108;
        }
        char v63 = 0;
        unsigned int v64 = 0;
        uint64_t v43 = 0;
        if (v39 <= v38) {
          unint64_t v39 = *((void *)this + 1);
        }
        while (2)
        {
          if (v39 == v38)
          {
            LODWORD(v43) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v65 = v38 + 1;
            char v66 = *(unsigned char *)(v40 + v38);
            *((void *)this + 1) = v65;
            v43 |= (unint64_t)(v66 & 0x7F) << v63;
            if (v66 < 0)
            {
              v63 += 7;
              unint64_t v38 = v65;
              BOOL v14 = v64++ > 8;
              if (v14) {
                goto LABEL_88;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v43) = 0;
            }
          }
          break;
        }
LABEL_108:
        *(_DWORD *)(a1 + 120) = v43;
        goto LABEL_63;
      case 9u:
        *(unsigned char *)(a1 + 128) |= 8u;
        unint64_t v46 = *((void *)this + 1);
        unint64_t v47 = *((void *)this + 2);
        uint64_t v48 = *(void *)this;
        if (v46 <= 0xFFFFFFFFFFFFFFF5 && v46 + 10 <= v47)
        {
          char v49 = 0;
          unsigned int v50 = 0;
          uint64_t v51 = 0;
          do
          {
            unint64_t v52 = v46 + 1;
            *((void *)this + 1) = v46 + 1;
            char v53 = *(unsigned char *)(v48 + v46);
            v51 |= (unint64_t)(v53 & 0x7F) << v49;
            if ((v53 & 0x80) == 0) {
              goto LABEL_111;
            }
            v49 += 7;
            unint64_t v46 = v52;
            BOOL v14 = v50++ > 8;
          }
          while (!v14);
LABEL_95:
          LODWORD(v51) = 0;
          goto LABEL_111;
        }
        char v67 = 0;
        unsigned int v68 = 0;
        uint64_t v51 = 0;
        if (v47 <= v46) {
          unint64_t v47 = *((void *)this + 1);
        }
        break;
      case 0xAu:
        operator new();
      case 0xBu:
        operator new();
      case 0xCu:
        operator new();
      case 0xDu:
        operator new();
      case 0xEu:
        operator new();
      case 0xFu:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v47 == v46)
      {
        LODWORD(v51) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_111;
      }
      unint64_t v69 = v46 + 1;
      char v70 = *(unsigned char *)(v48 + v46);
      *((void *)this + 1) = v69;
      v51 |= (unint64_t)(v70 & 0x7F) << v67;
      if ((v70 & 0x80) == 0) {
        break;
      }
      v67 += 7;
      unint64_t v46 = v69;
      BOOL v14 = v68++ > 8;
      if (v14) {
        goto LABEL_95;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v51) = 0;
    }
LABEL_111:
    *(_DWORD *)(a1 + 124) = v51;
    goto LABEL_63;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_100E43DB0(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  if (*(void *)(result + 72)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  int v4 = *(const PB::Base ***)(v3 + 88);
  char v5 = *(const PB::Base ***)(v3 + 96);
  while (v4 != v5)
  {
    int v6 = *v4++;
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 3u);
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  char v7 = *(unsigned char *)(v3 + 128);
  if ((v7 & 2) != 0)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 116), 6u);
    char v7 = *(unsigned char *)(v3 + 128);
    if ((v7 & 1) == 0)
    {
LABEL_14:
      if ((v7 & 4) == 0) {
        goto LABEL_15;
      }
      goto LABEL_33;
    }
  }
  else if ((*(unsigned char *)(v3 + 128) & 1) == 0)
  {
    goto LABEL_14;
  }
  uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 112), 7u);
  char v7 = *(unsigned char *)(v3 + 128);
  if ((v7 & 4) == 0)
  {
LABEL_15:
    if ((v7 & 8) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_33:
  uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 120), 8u);
  if ((*(unsigned char *)(v3 + 128) & 8) != 0) {
LABEL_16:
  }
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 124), 9u);
LABEL_17:
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 80)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 64)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 56))
  {
    return PB::Writer::write();
  }
  return result;
}

double sub_100E43F50@<D0>(_OWORD *a1@<X8>)
{
  sub_1003B1B28(&v3);
  double result = *(double *)&v3;
  *a1 = v3;
  return result;
}

void sub_100E43F8C(NanoPreferencesSyncFactoryInterface *a1)
{
  NanoPreferencesSyncFactoryInterface::~NanoPreferencesSyncFactoryInterface(a1);

  operator delete();
}

void sub_100E43FC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A604A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E43FE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A604A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E44038(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100E44060(uint64_t a1)
{
  *(void *)a1 = off_101A60500;
  if (*(void *)(a1 + 8))
  {
    unint64_t v2 = **(NSObject ***)(a1 + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      long long v3 = (void *)(a1 + 24);
      if (*(char *)(a1 + 47) < 0) {
        long long v3 = (void *)*v3;
      }
      int v6 = 136446210;
      char v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WiFi assertion released for '%{public}s'", (uint8_t *)&v6, 0xCu);
    }
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 48), 0);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100E44164(uint64_t a1)
{
  sub_100E44060(a1);

  operator delete();
}

void sub_100E4419C()
{
}

void sub_100E44404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    (*((void (**)(dispatch_object_t))a11->isa + 1))(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

WiFiManagerInterface *sub_100E44504(uint64_t a1)
{
  *(void *)a1 = off_101A60520;
  unint64_t v2 = *(void **)(a1 + 184);
  if (v2)
  {
    [v2 suspend];
    [*(id *)(a1 + 184) invalidate];
  }
  if (*(unsigned char *)(a1 + 216))
  {
    sub_100058DB0(__p, "~WiFiManagerImpl");
    sub_100E44628(a1, (uint64_t *)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1000558F4((const void **)(a1 + 256));
  sub_100142A3C((const void **)(a1 + 248));
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  sub_100160AF8((atomic_uint **)(a1 + 208));

  long long v3 = *(void **)(a1 + 160);
  if (v3)
  {
    do
    {
      int v4 = (void *)*v3;
      char v5 = (std::__shared_weak_count *)v3[4];
      if (v5) {
        std::__shared_weak_count::__release_weak(v5);
      }
      operator delete(v3);
      long long v3 = v4;
    }
    while (v4);
  }
  int v6 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v6) {
    operator delete(v6);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 80));
  char v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return sub_100DD7E28((WiFiManagerInterface *)a1);
}

const void **sub_100E44628(uint64_t a1, uint64_t *a2)
{
  long long v3 = *(const __SCDynamicStore **)(a1 + 248);
  if (v3) {
    int v4 = sub_100142574;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    if (!SCDynamicStoreSetNotificationKeys(v3, 0, 0))
    {
      int v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Failed to clear dynamic store notification key", v13, 2u);
      }
    }
    if (!SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 248), 0))
    {
      char v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Failed to clear dynamic store dispatch queue", v13, 2u);
      }
    }
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        char v9 = a2;
      }
      else {
        char v9 = (uint64_t *)*a2;
      }
      *(_DWORD *)char v13 = 136446210;
      *(void *)&v13[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I WoW monitoring disabled successfully for '%{public}s'", v13, 0xCu);
    }
    uint64_t v10 = *(void *)(a1 + 248);
    *(void *)(a1 + 248) = 0;
    *(void *)char v13 = v10;
    sub_100142A3C((const void **)v13);
  }
  uint64_t v11 = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  *(void *)char v13 = v11;
  return sub_1000558F4((const void **)v13);
}

void sub_100E447C8(uint64_t a1)
{
  sub_100E44504(a1);

  operator delete();
}

void sub_100E44800(uint64_t a1, NSObject **a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3321888768;
  void v5[2] = sub_100E448B0;
  v5[3] = &unk_101A60578;
  long long v3 = *a2;
  int v4 = (uint64_t *)(a1 + 8);
  v5[4] = a1;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(group);
  }
  sub_100E4963C(v4, v5);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_100E448B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  Registry::createRestModuleOneTimeUseConnection(&v11, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  unint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A60710;
  v2[1] = v1;
  v2[2] = sub_100E45064;
  v2[3] = 0;
  *((void *)&v16 + 1) = v2;
  ctu::RestModule::observeEvent();
  sub_10003F600(v15);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  long long v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
  {
    int v4 = *(void **)(v1 + 8);
    char v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
      char v7 = *(std::__shared_weak_count **)(v1 + 16);
      if (v7)
      {
        uint64_t v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          char v9 = v8;
          __dst[0] = *(void **)(v1 + 24);
          uint64_t v10 = __dst[0];
          __dst[1] = v4;
          BOOL v14 = v6;
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          *(_OWORD *)char v15 = 0u;
          long long v16 = 0u;
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v10);
          char v18 = v4;
          unsigned __int8 v19 = v6;
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          __p[1] = v10;
          dispatch_retain(v10);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          __p[0] = off_101A60780;
          sub_100168034((uint64_t *)__p, (uint64_t *)&v16 + 1);
          sub_100168C78((uint64_t *)__p);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          dispatch_release(v10);
          std::__shared_weak_count::__release_weak(v6);
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100E44EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E45064(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 192)) {
      long long v3 = "enabled";
    }
    else {
      long long v3 = "disabled";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v16 = (uint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WoW is %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 216))
    {
      if (*(void *)(a1 + 248)) {
        int v4 = sub_100142574;
      }
      else {
        int v4 = 0;
      }
      if (v4) {
        char v5 = "enabled";
      }
      else {
        char v5 = "requested";
      }
    }
    else
    {
      char v5 = "disabled";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v16 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WoW monitoring is %s", buf, 0xCu);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 264));
    uint64_t v7 = subscriber::asString();
    *(_DWORD *)long long buf = 136315394;
    uint64_t v16 = v6;
    __int16 v17 = 2080;
    uint64_t v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I CarrierMobileHotspot usage: active=%s sim=%s", buf, 0x16u);
  }
  std::mutex::lock((std::mutex *)(a1 + 80));
  for (unint64_t i = *(void **)(a1 + 160); i; unint64_t i = (void *)*i)
  {
    char v9 = (std::__shared_weak_count *)i[4];
    if (v9)
    {
      uint64_t v10 = std::__shared_weak_count::lock(v9);
      if (v10)
      {
        uint64_t v11 = v10;
        if (i[3])
        {
          unint64_t v12 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = asString();
            uint64_t shared_owners = v11->__shared_owners_;
            *(_DWORD *)long long buf = 136315394;
            uint64_t v16 = v13;
            __int16 v17 = 2048;
            uint64_t v18 = shared_owners;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I WiFiManagerClient type '%s' (%lu refs)", buf, 0x16u);
          }
        }
        sub_10004D2C8(v11);
      }
    }
  }
  std::mutex::unlock((std::mutex *)(a1 + 80));
}

void sub_100E452E4(_Unwind_Exception *exception_object)
{
}

void sub_100E45308(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  memset(&__p, 0, sizeof(__p));
  if (a3 == a4)
  {
    sub_100058DB0(&__p, "");
  }
  else if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    std::string __p = *(std::string *)a3;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "";
    if (!a2) {
      uint64_t v7 = "un";
    }
    uint64_t v8 = (void *)(a1 + 224);
    if (*(char *)(a1 + 247) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v25 = 2080;
    unsigned int v26 = v8;
    __int16 v27 = 2080;
    unint64_t v28 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I WiFi: %savailable. Interface name changed from '%s' -> '%s'", buf, 0x20u);
  }
  uint64_t v10 = *(unsigned __int8 *)(a1 + 247);
  unsigned int v11 = *(unsigned __int8 *)(a1 + 247);
  if (*(char *)(a1 + 247) < 0) {
    uint64_t v12 = *(void *)(a1 + 232);
  }
  else {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 247);
  }
  uint64_t v13 = (const void **)(a1 + 224);
  if (v12)
  {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      if ((v11 & 0x80u) == 0) {
        uint64_t v15 = *(unsigned __int8 *)(a1 + 247);
      }
      else {
        uint64_t v15 = *(void *)(a1 + 232);
      }
      if (v15 == size)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v16 = &__p;
        }
        else {
          uint64_t v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*v13, v16, *(void *)(a1 + 232))) {
            goto LABEL_39;
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 247)) {
            goto LABEL_39;
          }
          __int16 v17 = (unsigned __int8 *)(a1 + 224);
          while (*v17 == v16->__r_.__value_.__s.__data_[0])
          {
            ++v17;
            uint64_t v16 = (std::string *)((char *)v16 + 1);
            if (!--v10) {
              goto LABEL_39;
            }
          }
        }
      }
      if (*(unsigned char *)(a1 + 216))
      {
        sub_100058DB0(buf, "Interface change. Tearing down WoW monitoring on previous interface");
        sub_100E44628(a1, (uint64_t *)buf);
        if (SHIBYTE(v27) < 0) {
          operator delete(*(void **)buf);
        }
        unsigned int v11 = *(unsigned __int8 *)(a1 + 247);
      }
    }
  }
LABEL_39:
  uint64_t v18 = v11;
  if ((v11 & 0x80u) == 0) {
    uint64_t v19 = v11;
  }
  else {
    uint64_t v19 = *(void *)(a1 + 232);
  }
  std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
  }
  if (v19 == v20)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      xpc_object_t v21 = &__p;
    }
    else {
      xpc_object_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((v11 & 0x80) != 0)
    {
      if (!memcmp(*v13, v21, *(void *)(a1 + 232))) {
        goto LABEL_61;
      }
    }
    else
    {
      if (!v11) {
        goto LABEL_61;
      }
      unint64_t v22 = (unsigned __int8 *)(a1 + 224);
      while (*v22 == v21->__r_.__value_.__s.__data_[0])
      {
        ++v22;
        xpc_object_t v21 = (std::string *)((char *)v21 + 1);
        if (!--v18) {
          goto LABEL_61;
        }
      }
    }
  }
  std::string::operator=((std::string *)(a1 + 224), &__p);
  if (*(unsigned char *)(a1 + 216))
  {
    if (*(char *)(a1 + 247) < 0)
    {
      if (!*(void *)(a1 + 232)) {
        goto LABEL_61;
      }
    }
    else if (!*(unsigned char *)(a1 + 247))
    {
      goto LABEL_61;
    }
    sub_100E45A0C(a1);
  }
LABEL_61:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100E455E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E45628(uint64_t a1, uint64_t a2)
{
  long long v3 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    int v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_group_enter(v4);
    }
  }
}

void sub_100E4567C(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = *(NSObject **)(a1 + 40);
    if (v3)
    {
      dispatch_release(v3);
    }
  }
}

void sub_100E456CC(uint64_t a1, dispatch_object_t *a2)
{
  long long v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E457CC(uint64_t a1, long long *a2)
{
  long long __dst = 0uLL;
  uint64_t v7 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100E458E0;
  v3[3] = &unk_1019DC970;
  v3[4] = a1;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v5 = v7;
  }
  sub_100E4963C((uint64_t *)(a1 + 8), v3);
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100E458C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 25) < 0) {
    operator delete(*(void **)(v1 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100E458E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 216))
  {
    long long v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        int v4 = (void *)*v4;
      }
      int v7 = 136446210;
      uint64_t v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WoW monitoring already enabled. requested by: '%{public}s'", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    *(unsigned char *)(v2 + 216) = 1;
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      int v7 = 136446210;
      uint64_t v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Requested to enable WoW monitoring for '%{public}s'", (uint8_t *)&v7, 0xCu);
    }
    sub_100E45A0C(v2);
  }
}

void sub_100E45A0C(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 247);
  if ((v2 & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 247)) {
      goto LABEL_3;
    }
LABEL_10:
    int v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf.version) = 0;
    uint64_t v5 = "#I Missing interface name";
    goto LABEL_12;
  }
  if (!*(void *)(a1 + 232)) {
    goto LABEL_10;
  }
LABEL_3:
  if (*(void *)(a1 + 248)) {
    long long v3 = sub_100142574;
  }
  else {
    long long v3 = 0;
  }
  if (v3)
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf.version) = 0;
    uint64_t v5 = "#I WoW monitoring has already been setup";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&buf, 2u);
    return;
  }
  CFStringRef ifname = 0;
  if (v2 < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 224), *(void *)(a1 + 232));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 224);
    uint64_t v24 = *(const void *(__cdecl **)(const void *))(a1 + 240);
  }
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    unint64_t v28 = v24;
  }
  values = 0;
  if (SHIBYTE(v28) < 0)
  {
    sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)&buf.version = __dst;
    buf.retain = v28;
  }
  *(void *)char v29 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v6 = values;
    values = *(void **)v29;
    v19[0] = v6;
    sub_1000558F4((const void **)v19);
  }
  if (SHIBYTE(buf.retain) < 0) {
    operator delete((void *)buf.version);
  }
  CFStringRef ifname = (CFStringRef)values;
  values = 0;
  sub_1000558F4((const void **)&values);
  if (SHIBYTE(v28) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, ifname, @"ActiveDuringSleepSupported");
  CFIndex v8 = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = NetworkInterfaceEntity;
  buf.version = v8;
  sub_1000558F4((const void **)&buf);
  values = *(void **)(a1 + 256);
  buf.version = 0;
  memset(&buf.retain, 0, 24);
  buf.info = (void *)a1;
  SCDynamicStoreRef store = 0;
  SCDynamicStoreRef store = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:WakeOnWifiChange", (SCDynamicStoreCallBack)sub_100E46260, &buf);
  if (store) {
    char v9 = sub_100142574;
  }
  else {
    char v9 = 0;
  }
  if (!v9)
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      long long __dst = 0uLL;
      unint64_t v28 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v19 = __dst;
      std::string::size_type v20 = v28;
      uint64_t v13 = v19;
      if (SHIBYTE(v28) < 0) {
        uint64_t v13 = (void **)v19[0];
      }
      *(_DWORD *)char v29 = 136315138;
      *(void *)&v29[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Failed to create dynamic store for key '%s'", v29, 0xCu);
      if (SHIBYTE(v20) < 0) {
        operator delete(v19[0]);
      }
    }
    goto LABEL_58;
  }
  CFArrayRef v18 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  if (SCDynamicStoreSetNotificationKeys(store, v18, 0))
  {
    if (SCDynamicStoreSetDispatchQueue(store, *(dispatch_queue_t *)(a1 + 24)))
    {
      sub_100142A70((const void **)(a1 + 248), (const void **)&store);
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        long long __dst = 0uLL;
        unint64_t v28 = 0;
        ctu::cf::assign();
        *(_OWORD *)uint64_t v19 = __dst;
        std::string::size_type v20 = v28;
        unsigned int v11 = v19;
        if (SHIBYTE(v28) < 0) {
          unsigned int v11 = (void **)v19[0];
        }
        *(_DWORD *)char v29 = 136315138;
        *(void *)&v29[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I WoW monitoring enabled successfully for key '%s'", v29, 0xCu);
        if (SHIBYTE(v20) < 0) {
          operator delete(v19[0]);
        }
      }
      sub_100E46270(a1, 0);
      goto LABEL_57;
    }
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      long long __dst = 0uLL;
      unint64_t v28 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v19 = __dst;
      std::string::size_type v20 = v28;
      __int16 v17 = v19;
      if (SHIBYTE(v28) < 0) {
        __int16 v17 = (void **)v19[0];
      }
      *(_DWORD *)char v29 = 136315138;
      *(void *)&v29[4] = v17;
      uint64_t v16 = "#I Failed to set dynamic store dispatch queue for key '%s'";
LABEL_55:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, v29, 0xCu);
      if (SHIBYTE(v20) < 0) {
        operator delete(v19[0]);
      }
    }
  }
  else
  {
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      long long __dst = 0uLL;
      unint64_t v28 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v19 = __dst;
      std::string::size_type v20 = v28;
      uint64_t v15 = v19;
      if (SHIBYTE(v28) < 0) {
        uint64_t v15 = (void **)v19[0];
      }
      *(_DWORD *)char v29 = 136315138;
      *(void *)&v29[4] = v15;
      uint64_t v16 = "#I Failed to set dynamic store notification key '%s'";
      goto LABEL_55;
    }
  }
LABEL_57:
  sub_100044D00((const void **)&v18);
LABEL_58:
  sub_100142A3C((const void **)&store);
  sub_1000558F4((const void **)&ifname);
}

void sub_100E45F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,const void *a31)
{
  if (*(char *)(v31 - 89) < 0) {
    operator delete(*(void **)(v31 - 112));
  }
  sub_100044D00(&a10);
  sub_100142A3C(&a14);
  sub_1000558F4(&a31);
  _Unwind_Resume(a1);
}

void sub_100E46020(uint64_t a1, long long *a2)
{
  long long __dst = 0uLL;
  uint64_t v7 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100E46134;
  v3[3] = &unk_1019DC970;
  v3[4] = a1;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v5 = v7;
  }
  sub_100E4963C((uint64_t *)(a1 + 8), v3);
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100E46118(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 25) < 0) {
    operator delete(*(void **)(v1 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100E46134(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 216))
  {
    *(unsigned char *)(v2 + 216) = 0;
    long long v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        int v4 = (void *)*v4;
      }
      int v7 = 136446210;
      CFIndex v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Requested to disable WoW monitoring for '%{public}s'", (uint8_t *)&v7, 0xCu);
    }
    sub_100E44628(v2, (uint64_t *)(a1 + 40));
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      int v7 = 136446210;
      CFIndex v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I WoW monitoring already disabled. requested by: '%{public}s'", (uint8_t *)&v7, 0xCu);
    }
  }
}

const void **sub_100E46260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100E46270(a3, "WoW SCDynamicStore change callback");
}

const void **sub_100E46270(uint64_t a1, const char *a2)
{
  if (a2)
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)SCDynamicStoreContext buf = 136315138;
      __int16 v17 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I checkWoWSupport_sync(): triggered by '%s'", buf, 0xCu);
    }
  }
  double result = *(const void ***)(a1 + 248);
  if (result) {
    uint64_t v6 = sub_100142574;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    CFStringRef v7 = *(const __CFString **)(a1 + 256);
    if (v7 ? sub_1000810B8 : 0)
    {
      CFPropertyListRef v15 = SCDynamicStoreCopyValue((SCDynamicStoreRef)result, v7);
      if (v15) {
        char v9 = sub_100080934;
      }
      else {
        char v9 = 0;
      }
      int v10 = v9 != 0;
      int v11 = *(unsigned __int8 *)(a1 + 217);
      if (v11 != v10)
      {
        uint64_t v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = "true";
          if (v11) {
            BOOL v14 = "true";
          }
          else {
            BOOL v14 = "false";
          }
          if (!v10) {
            uint64_t v13 = "false";
          }
          *(_DWORD *)SCDynamicStoreContext buf = 136315394;
          __int16 v17 = v14;
          __int16 v18 = 2080;
          uint64_t v19 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I WoW support changed from %s to %s", buf, 0x16u);
        }
        *(unsigned char *)(a1 + 217) = v10;
        sub_100358C28((uint64_t)&event::data::wakeOnWifiChanged, v10);
      }
      return sub_1000577C4(&v15);
    }
  }
  return result;
}

void sub_100E46420(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100E4643C(uint64_t a1, long long *a2)
{
  long long __dst = 0uLL;
  uint64_t v7 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100E46550;
  v3[3] = &unk_1019DC970;
  v3[4] = a1;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v5 = v7;
  }
  sub_100E4963C((uint64_t *)(a1 + 8), v3);
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100E46534(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 25) < 0) {
    operator delete(*(void **)(v1 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100E46550(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 192))
  {
    long long v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        int v4 = (void *)*v4;
      }
      *(_DWORD *)SCDynamicStoreContext buf = 136446210;
      unint64_t v22 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WoW already enabled. requested by: '%{public}s'", buf, 0xCu);
    }
    return;
  }
  if (qword_101B12DA8 != -1) {
    dispatch_once(&qword_101B12DA8, &stru_101A60600);
  }
  if (byte_101B12DA2 && !*(void *)(v2 + 184))
  {
    id v5 = objc_alloc_init((Class)CWFInterface);
    uint64_t v6 = *(void **)(v2 + 184);
    *(void *)(v2 + 184) = v5;

    uint64_t v7 = *(void **)(v2 + 184);
    if (v7)
    {
      [v7 resume];
    }
    else
    {
      CFIndex v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)SCDynamicStoreContext buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to create CWFInterface", buf, 2u);
      }
    }
  }
  if (*(void *)(v2 + 184))
  {
    char v9 = +[CWFActivity activityWithType:4 reason:@"CTWiFiManager"];
    int v10 = *(void **)(v2 + 184);
    id v20 = 0;
    unsigned int v11 = [v10 beginActivity:v9 error:&v20];
    id v12 = v20;
    if (v11)
    {
      objc_storeStrong((id *)(v2 + 192), v9);
      uint64_t v13 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v14 = (void *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0) {
          BOOL v14 = (void *)*v14;
        }
        *(_DWORD *)SCDynamicStoreContext buf = 136446210;
        unint64_t v22 = v14;
        CFPropertyListRef v15 = "#I WoW enabled successfully for '%{public}s'";
        uint64_t v16 = v13;
        uint32_t v17 = 12;
LABEL_24:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }
    else
    {
      __int16 v18 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = (void *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0) {
          uint64_t v19 = (void *)*v19;
        }
        *(_DWORD *)SCDynamicStoreContext buf = 136446466;
        unint64_t v22 = v19;
        __int16 v23 = 2112;
        id v24 = v12;
        CFPropertyListRef v15 = "#I Failed to enable WoW for '%{public}s'. Error: %@";
        uint64_t v16 = v18;
        uint32_t v17 = 22;
        goto LABEL_24;
      }
    }
  }
}

void sub_100E467E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E467FC(uint64_t a1, long long *a2)
{
  long long __dst = 0uLL;
  uint64_t v7 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100E46910;
  v3[3] = &unk_1019DC970;
  v3[4] = a1;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v5 = v7;
  }
  sub_100E4963C((uint64_t *)(a1 + 8), v3);
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100E468F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 25) < 0) {
    operator delete(*(void **)(v1 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100E46910(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a1 + 40;
  if (*(void *)(v2 + 192))
  {
    objc_msgSend(*(id *)(v2 + 184), "endActivity:");
    int v4 = *(void **)(v2 + 192);
    *(void *)(v2 + 192) = 0;

    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*(char *)(a1 + 63) >= 0) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = *(void *)(a1 + 40);
    }
    int v9 = 136446210;
    uint64_t v10 = v6;
    uint64_t v7 = "#I WoW disabled successfully for '%{public}s'";
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*(char *)(a1 + 63) >= 0) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = *(void *)(a1 + 40);
    }
    int v9 = 136446210;
    uint64_t v10 = v8;
    uint64_t v7 = "#I WoW already disabled. requested by: '%{public}s'";
  }
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v9, 0xCu);
}

void sub_100E46A30(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  int v9 = 0;
  uint64_t v10 = 0;
  sub_100E46CA0(&v9, a1, a3);
  uint64_t v6 = v9;
  if (v9)
  {
    uint64_t v7 = v10;
    uint64_t v8 = operator new(0x50uLL);
    v8[1] = 0;
    void v8[2] = 0;
    void *v8 = off_101A60898;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v8[3] = off_101A60500;
    void v8[4] = v6;
    void v8[5] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84((unsigned char *)v8 + 48, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *((_OWORD *)v8 + 3) = *(_OWORD *)a2;
      v8[8] = *(void *)(a2 + 16);
    }
    operator new();
  }
  *a4 = 0;
  a4[1] = 0;
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100E46C1C(_Unwind_Exception *a1)
{
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    sub_10004D2C8(shared_weak_owners);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v5);
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

void sub_100E46CA0(uint64_t **a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = (std::mutex *)(a2 + 80);
  std::mutex::lock((std::mutex *)(a2 + 80));
  unint64_t v7 = *(void *)(a2 + 152);
  if (!v7) {
    goto LABEL_17;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v9 = a3;
    if (v7 <= a3) {
      unint64_t v9 = a3 % v7;
    }
  }
  else
  {
    unint64_t v9 = (v7 - 1) & a3;
  }
  uint64_t v10 = *(uint64_t ****)(*(void *)(a2 + 144) + 8 * v9);
  if (!v10) {
    goto LABEL_17;
  }
  unsigned int v11 = *v10;
  if (!v11) {
    goto LABEL_17;
  }
  while (1)
  {
    unint64_t v12 = (unint64_t)v11[1];
    if (v12 == a3) {
      break;
    }
    if (v8.u32[0] > 1uLL)
    {
      if (v12 >= v7) {
        v12 %= v7;
      }
    }
    else
    {
      v12 &= v7 - 1;
    }
    if (v12 != v9) {
      goto LABEL_17;
    }
LABEL_16:
    unsigned int v11 = (uint64_t **)*v11;
    if (!v11) {
      goto LABEL_17;
    }
  }
  if (*((unsigned __int8 *)v11 + 16) != a3) {
    goto LABEL_16;
  }
  uint64_t v13 = (std::__shared_weak_count *)v11[4];
  if (!v13)
  {
LABEL_17:
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_18;
  }
  BOOL v14 = v11[3];
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *a1 = 0;
  CFPropertyListRef v15 = std::__shared_weak_count::lock(v13);
  a1[1] = (uint64_t *)v15;
  if (!v15 || (*a1 = v14) == 0)
  {
LABEL_18:
    WiFiManagerClientCreate();
    operator new();
  }
  std::__shared_weak_count::__release_weak(v13);
  std::mutex::unlock(v6);
}

void sub_100E4737C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, std::__shared_weak_count *a11, int a12, int a13, char a14)
{
}

void sub_100E473D0()
{
  __cxa_end_catch();
  if (v0) {
    JUMPOUT(0x100E473FCLL);
  }
  JUMPOUT(0x100E47404);
}

uint64_t sub_100E47424(uint64_t a1)
{
  return *(void *)a1;
}

void sub_100E4742C(uint64_t a1@<X0>, Registry **a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a2);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v14[0] = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v14);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_8;
  }
  uint64_t v12 = v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
LABEL_8:
    std::mutex::unlock(v5);
    unsigned int v11 = 0;
    char v13 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_9:
  PersonalityIdFromSlotId();
  (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)v12 + 176))(&v16, v12, v14);
  *(_OWORD *)a1 = *(_OWORD *)v20;
  *(void *)(a1 + 16) = v21;
  v20[1] = 0;
  uint64_t v21 = 0;
  v20[0] = 0;
  if (v23 < 0)
  {
    operator delete(__p);
    if (SHIBYTE(v21) < 0) {
      operator delete(v20[0]);
    }
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if (v15 < 0)
  {
    operator delete(v14[0]);
    if (v13) {
      return;
    }
  }
  else if (v13)
  {
    return;
  }
  sub_10004D2C8(v11);
}

void sub_100E475C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E475FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 24))
  {
    v9[0] = 0;
    v9[1] = 0;
    std::string::size_type v10 = 0;
    uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *(void *)(a3 + 8);
    }
    if (v5)
    {
      std::operator+<char>();
      uint64_t v6 = std::string::append(&v8, ") ", 2uLL);
      long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      std::string::size_type v10 = v6->__r_.__value_.__r.__words[2];
      *(_OWORD *)unsigned int v9 = v7;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v8.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      sub_100058DB0(v9, "");
    }
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3321888768;
    v11[2] = sub_100E477F0;
    v11[3] = &unk_101A605A8;
    v11[4] = a1;
    if (SHIBYTE(v10) < 0)
    {
      sub_10004FC84(&__p, v9[0], (unint64_t)v9[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v9;
      std::string::size_type v13 = v10;
    }
    sub_100AD3B2C((uint64_t)v14, a2);
    sub_100E4963C((uint64_t *)(a1 + 8), v11);
    sub_100333DB8(v14);
    if (SHIBYTE(v13) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v10) < 0) {
      operator delete(v9[0]);
    }
  }
}

void sub_100E477A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E477F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(v2 + 264) = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_100E46CA0(&v5, v2, 0);
  if (v5) {
    operator new();
  }
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      int v4 = (void *)*v4;
    }
    int buf = 136446210;
    *(void *)buf_4 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N %{public}s: Could not obtain WiFiManagerClient", (uint8_t *)&buf, 0xCu);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100E484A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,char a46)
{
}

void sub_100E48690(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(a19) < 0) {
    operator delete(a17);
  }
  JUMPOUT(0x100E48728);
}

void sub_100E486CC()
{
}

void sub_100E486D4()
{
}

uint64_t sub_100E4873C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  return sub_100AD3B2C(a1 + 64, a2 + 64);
}

void sub_100E487A4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E487C0(uint64_t a1)
{
  sub_100333DB8((void *)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

uint64_t sub_100E48810(uint64_t a1, uint64_t *a2)
{
  uint64_t v18 = a1;
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_100E49C94;
  v19[3] = &unk_101A60998;
  v19[4] = a1 + 8;
  v19[5] = &v18;
  id v20 = objc_retainBlock(v19);
  long long v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unint64_t v21 = 0;
    *(void *)block = _NSConcreteStackBlock;
    *(void *)&block[8] = 3221225472;
    *(void *)&block[16] = sub_100E49CE0;
    char v23 = &unk_10199E470;
    id v24 = &v21;
    __int16 v25 = &v20;
    dispatch_async_and_wait(v4, block);
  }
  else
  {
    unint64_t v21 = 0;
    *(void *)block = _NSConcreteStackBlock;
    *(void *)&block[8] = 3221225472;
    *(void *)&block[16] = sub_100E49CA4;
    char v23 = &unk_10199E470;
    id v24 = &v21;
    __int16 v25 = &v20;
    dispatch_sync(v4, block);
  }
  unint64_t v5 = v21;

  unint64_t v6 = HIDWORD(v5);
  long long v7 = *(NSObject **)(a1 + 40);
  BOOL v8 = v5 & 1;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asStringBool(v8);
    uint64_t v10 = subscriber::asString();
    *(_DWORD *)block = 136315394;
    *(void *)&void block[4] = v9;
    *(_WORD *)&block[12] = 2080;
    *(void *)&block[14] = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I mobileHotspot: active=%s, sim=%s", block, 0x16u);
  }
  if (!v8) {
    return 0;
  }
  uint64_t v11 = *a2;
  uint64_t v12 = *(NSObject **)(a1 + 40);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      *(_WORD *)block = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N mobileHotspot: requested pInfo empty", block, 2u);
    }
    return 1;
  }
  if (v13)
  {
    uint64_t v14 = asString();
    uint64_t v15 = subscriber::asString();
    *(_DWORD *)block = 136315394;
    *(void *)&void block[4] = v14;
    *(_WORD *)&block[12] = 2080;
    *(void *)&block[14] = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I mobileHotspot: requested pInfo: type=%s sim=%s", block, 0x16u);
    uint64_t v11 = *a2;
  }
  if (*(unsigned char *)(v11 + 49)) {
    return 1;
  }
  uint64_t result = 1;
  if (v6 != 3)
  {
    int v17 = *(_DWORD *)(v11 + 52);
    if (v17 != 3 && v17 != v6)
    {
      if (capabilities::ct::supportsGemini((capabilities::ct *)1))
      {
        if (!v6)
        {
          *(void *)block = 0;
          *(void *)&block[8] = 0;
          sub_1002A1B14(*(Registry **)(a1 + 48), block);
          if (*(void *)block
            && v17 == (*(unsigned int (**)(void))(**(void **)block + 760))(*(void *)block))
          {
            if (*(void *)&block[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&block[8]);
            }
            return 1;
          }
          if (*(void *)&block[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&block[8]);
          }
        }
        return 0;
      }
      return 1;
    }
  }
  return result;
}

void sub_100E48B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100E48B70(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_100E48BA4(id a1)
{
  byte_101B12DA2 = NSClassFromString(@"CWFInterface") != 0;
}

void sub_100E48BD8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E48C10(uint64_t a1)
{
}

uint64_t sub_100E48C2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E48C70(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E48C9C(ServiceManager::Service *this)
{
  *(void *)this = off_101A60690;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E48CF8(ServiceManager::Service *this)
{
  *(void *)this = off_101A60690;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E48D68@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "WiFiManager");
}

unsigned char *sub_100E48D78@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E48DB4(uint64_t a1, NSObject **a2)
{
}

uint64_t sub_100E48DBC()
{
  return 0;
}

uint64_t sub_100E48DC4()
{
  return 1;
}

uint64_t sub_100E48DCC()
{
  return 0;
}

void sub_100E48DDC(uint64_t a1, int a2, ServiceStage *a3)
{
}

void sub_100E48DE8()
{
}

__n128 sub_100E48DFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A60710;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100E48E50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A60710;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E48E88(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100E48ED0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E48F10()
{
}

uint64_t sub_100E48F1C(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E48F54(uint64_t a1, NSObject **a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 != 3)
    {
      if (a3 != 2)
      {
LABEL_2:
        *a2 = &off_101A60790;
        *((_WORD *)a2 + 4) = 0;
        return;
      }
      uint64_t v9 = (uint64_t)a2;
      goto LABEL_13;
    }
    uint64_t v10 = (const char *)((uint64_t)(*a2)[1].isa & 0x7FFFFFFFFFFFFFFFLL);
    if (v10 == (const char *)((unint64_t)"N3ctu12DispatchSlotIZZN15WiFiManagerImpl10initializeEN8dispatch13group_"
                                                 "sessionEEUb_E3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v10, (const char *)((unint64_t)"N3ctu12DispatchSlotIZZN15WiFiManagerImpl10initializeEN8dispatch13group_sessionEEUb_E3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *a2 = a1;
    }
    else
    {
      *a2 = 0;
    }
  }
  else
  {
    long long v6 = *(_OWORD *)a1;
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v7 = *(void *)(a1 + 16);
    a2[2] = v7;
    if (v7)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
      BOOL v8 = *a2;
    }
    else
    {
      BOOL v8 = v6;
    }
    dispatch_retain(v8);
    if (a3 == 1)
    {
      uint64_t v9 = a1;
LABEL_13:
      sub_100E48F1C(v9);
    }
  }
}

void sub_100E49050(uint64_t a1, uint64_t a2, long long **a3)
{
  memset(v6, 0, 24);
  sub_1000302C0((char *)v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  else
  {
    uint64_t v7 = 0;
  }
  v6[3] = off_101A607A0;
  v6[4] = v4;
  sub_100168470();
}

void sub_100E49154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  sub_100168C78((uint64_t *)&a13);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  a13 = (void **)&a10;
  sub_100047F64(&a13);
  _Unwind_Resume(a1);
}

void sub_100E49184(void *a1, void *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    uint64_t v5 = a1[1];
    *a2 = *a1;
    a2[1] = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    long long v6 = (std::__shared_weak_count *)a1[1];
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZZN15WiFiManagerImpl10initializeEN8dispatch13group_sessionEEUb_E3$_0" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZZN15WiFiManagerImpl10initializeEN8dispatch13group_sessionEEUb_E3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *a2 = a1;
    }
    else
    {
      *a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *a2 = &off_101A607B0;
    *((_WORD *)a2 + 4) = 0;
    return;
  }
  long long v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100E49260(uint64_t *a1, int a2, uint64_t *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      BOOL v8 = v7;
      uint64_t v9 = *a1;
      if (*a1)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100E45308(v9, a2, *a3, a3[1]);
        sub_10004D2C8(v8);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100E492F0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100E4930C(void *a1)
{
  *a1 = off_101A607D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E49358(void *a1)
{
  *a1 = off_101A607D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100E493C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100E49474(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100E4948C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100E494AC()
{
}

void *sub_100E49518(void *a1)
{
  *a1 = off_101A60820;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100E49564(void *a1)
{
  *a1 = off_101A60820;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100E495D0()
{
}

void sub_100E4963C(uint64_t *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (!v4 || (v5 = *a1, (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  BOOL v8 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_100E49728;
  block[3] = &unk_101A60858;
  uint64_t v12 = v5;
  BOOL v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  id v9 = v3;
  id v11 = v9;
  dispatch_async(v8, block);

  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
}

uint64_t sub_100E49728(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100E49738(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E49754(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100E49764(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  sub_10016111C((uint64_t *)(*(void *)v1 + 200));
  sub_100058DB0(&__p, "/cc/events/dump_state");
  id v3 = (ctu::RestModule *)(v2 + 64);
  ctu::RestModule::unobserveEvent();
  if (v8 < 0) {
    operator delete(__p);
  }
  ctu::RestModule::disconnect(v3);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100E497E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100E49818(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A60898;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E49838(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A60898;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E4988C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100E498B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A608E8;
  if (SHIBYTE(this[2].__vftable) < 0) {
    operator delete((void *)this[1].__shared_owners_);
  }

  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E49914(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A608E8;
  if (SHIBYTE(this[2].__vftable) < 0) {
    operator delete((void *)this[1].__shared_owners_);
  }
  std::__shared_weak_count::~__shared_weak_count(this);

  operator delete();
}

void sub_100E49988(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete();
  }
  id v3 = (void **)(a1 + 32);
  uint64_t v4 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0) {
      uint64_t v5 = *v3;
    }
    int v6 = 136446210;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %{public}s: WiFiManagerClient returned", (uint8_t *)&v6, 0xCu);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v3);
  }
}

uint64_t sub_100E49A84(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A60928)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

void sub_100E49AC8(uint64_t a1, const void *a2)
{
  id v3 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    uint64_t v5 = asString();
    __int16 v6 = 2048;
    uint64_t v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFiManagerClient of type '%s' (%p) deleted", (uint8_t *)&v4, 0x16u);
  }
  CFRelease(a2);
}

void sub_100E49B94(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E49BCC(uint64_t a1)
{
}

uint64_t sub_100E49BF4(uint64_t a1, uint64_t a2)
{
    return a1 + 32;
  else {
    return 0;
  }
}

void sub_100E49C38(char a1, void *__p)
{
  if (a1)
  {
    id v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_100E49C94(uint64_t a1)
{
  return *(void *)(**(void **)(a1 + 40) + 264);
}

uint64_t sub_100E49CA4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100E49CE0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_100E49D1C()
{
}

void sub_100E49D44(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  DataiRatController::create();
}

void sub_100E49DE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  if (v9) {
    dispatch_release(v9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E49E2C(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = a1 + 8;
  id v3 = *a2;
  dispatch_object_t v4 = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  sub_100962014(v2, &v4);
}

void sub_100E49EB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E49ED0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10119C5DC();
}

void sub_100E49F3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E49F54(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  DataWirelessTechnologyListManager::create();
}

void sub_100E49FE4(_Unwind_Exception *exception_object)
{
  if (v2) {
    dispatch_release(v2);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A008(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  v3[2] = *(void *)(a1 + 8);
  v3[3] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_100BBA620(v3);
}

void sub_100E4A088(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A0AC(uint64_t a1, NSObject **a2)
{
  Registry::getCommandDriversFactory(&v6, *(Registry **)(a1 + 8));
  uint64_t v3 = v6;
  dispatch_object_t v4 = *a2;
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v3 + 112))(v3, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100E4A148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A16C(uint64_t a1@<X0>, NSObject **a2@<X3>, void *a3@<X4>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  uint64_t v25 = 0;
  unsigned int v26 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a3 + 16))(&v25);
  uint64_t v8 = v25;
  if (v25)
  {
    uint64_t v9 = a1 + 8;
    uint64_t v10 = *a2;
    dispatch_object_t object = v10;
    if (v10)
    {
      dispatch_retain(v10);
      uint64_t v8 = v25;
    }
    uint64_t v20 = v8;
    unint64_t v21 = v26;
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BBDataDriverInterface::createDataDriverInstance(&v20, &v23);
    uint64_t v12 = v23;
    id v11 = v24;
    uint64_t v23 = 0;
    id v24 = 0;
    *a4 = v12;
    a4[1] = v11;
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (object) {
      dispatch_release(object);
    }
    uint64_t v18 = v12;
    char v19 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v13 = *a2;
    dispatch_object_t v17 = v13;
    if (v13) {
      dispatch_retain(v13);
    }
    uint64_t v14 = (std::__shared_weak_count *)a3[1];
    uint64_t v15 = *a3;
    uint64_t v16 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BBDataDriverInterface::initDataDriverInstance(v9, &v18, &v17, &v15);
    if (v16) {
      sub_10004D2C8(v16);
    }
    if (v17) {
      dispatch_release(v17);
    }
    if (v19) {
      sub_10004D2C8(v19);
    }
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
}

void sub_100E4A2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, dispatch_object_t object, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, dispatch_object_t a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  char v19 = *(std::__shared_weak_count **)(v17 - 56);
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A354(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 8));
  dispatch_object_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v13 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v13);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_11;
    }
LABEL_10:
    long long v13 = 0uLL;
    sub_100E21238(&v13);
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
    goto LABEL_10;
  }
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_100E4A4BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A4F8(uint64_t a1@<X0>, uint64_t a2@<X2>, NSObject **a3@<X3>, void *a4@<X8>)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 72))(&v10);
  if (v10)
  {
    if (*(unsigned char *)(*(void *)a2 + 49) == 1)
    {
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v8 = *a3;
      if (v8) {
        dispatch_retain(v8);
      }
      sub_100E4A6BC(&v9);
    }
    if (!*(unsigned char *)(*(void *)a2 + 49))
    {
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = *a3;
      if (v7) {
        dispatch_retain(v7);
      }
      sub_100E4A6BC(&v9);
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_100E4A688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (v19) {
    dispatch_release(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A6BC(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100E4A82C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12)
{
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_100E4A8BC@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::integratedPDPStatisticsInterval(a1);
  if (result >= 1) {
    sub_10037EA6C();
  }
  *a2 = 0;
  return result;
}

void sub_100E4A908(capabilities::ct *a1@<X1>, NSObject **a2@<X3>, void *a3@<X8>)
{
  uint64_t v5 = *a2;
  dispatch_object_t v6 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  sub_101278C50(a1, &v6, a3);
}

void sub_100E4A9A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4A9C0(uint64_t a1, uint64_t a2, uint64_t a3, dispatch_object_t *a4)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*a4) {
    dispatch_retain(*a4);
  }
  operator new();
}

void sub_100E4AB64(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[5], v1, (dispatch_function_t)sub_100E4AE48);
  __cxa_rethrow();
}

void sub_100E4AB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  __cxa_end_catch();
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v13)
  {
    dispatch_release(v13);
    if (!v12) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v12)
  {
    goto LABEL_8;
  }
  sub_10004D2C8(v12);
  goto LABEL_8;
}

void sub_100E4AC18(DataServiceFactoryInterface *this)
{
  *(void *)this = off_101A609C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  DataServiceFactoryInterface::~DataServiceFactoryInterface(this);
}

void sub_100E4AC74(DataServiceFactoryInterface *this)
{
  *(void *)this = off_101A609C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  DataServiceFactoryInterface::~DataServiceFactoryInterface(this);

  operator delete();
}

void sub_100E4ACE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E4AD20(uint64_t a1)
{
}

uint64_t sub_100E4AD3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E4AD80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E4ADB0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E4ADE8(uint64_t a1)
{
}

uint64_t sub_100E4AE04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E4AE48(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sms::Controller::submitNetworkNotificationMetric(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (a4 == 5 || a5) {
    return sub_100E4AF0C((wis::MetricFactory *)0x800EB);
  }
  return result;
}

uint64_t sub_100E4AF0C(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    dispatch_object_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100E4B068(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100E4B0EC(uint64_t a1, _DWORD *a2)
{
  int v4 = *(_DWORD *)(a1 + 40);
  a2[17] |= 2u;
  a2[4] = v4;
  int v5 = subscriber::simSlotAsInstance();
  int v6 = a2[17];
  int v7 = v6 | 0x80;
  a2[17] = v6 | 0x80;
  a2[15] = v5;
  unint64_t v8 = *(char *)(a1 + 52);
  if (v8 <= 4)
  {
    int v9 = dword_10157E3A8[v8];
    int v7 = v6 | 0x84;
    a2[17] = v6 | 0x84;
    a2[5] = v9;
  }
  unsigned int v10 = *(unsigned __int8 *)(a1 + 53);
  if (v10 <= 3)
  {
    v7 |= 8u;
    a2[17] = v7;
    a2[12] = v10 + 1;
  }
  int v11 = 8;
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
      int v11 = 1;
      goto LABEL_14;
    case 1:
      v7 |= 0x40u;
      a2[17] = v7;
      a2[14] = 2;
      goto LABEL_8;
    case 2:
      int v11 = 3;
      goto LABEL_14;
    case 3:
      int v11 = 4;
      goto LABEL_14;
    case 4:
      int v11 = 5;
      goto LABEL_14;
    case 5:
      int v11 = 6;
      goto LABEL_14;
    case 6:
      int v11 = 7;
      goto LABEL_14;
    case 7:
      goto LABEL_14;
    case 8:
    case 9:
LABEL_8:
      int v11 = 0;
LABEL_14:
      a2[17] = v7 | 0x40;
      a2[14] = v11;
      break;
    default:
      break;
  }
  if (v8 <= 3 && v8 != 1)
  {
    uint64_t v12 = *(void *)(a1 + 32);
    if (*(char *)(v12 + 23) < 0)
    {
      unint64_t v14 = *(void *)(v12 + 8);
      if (v14 >= 7) {
        std::string::size_type v13 = 7;
      }
      else {
        std::string::size_type v13 = v14;
      }
    }
    else if (*(unsigned __int8 *)(v12 + 23) >= 7u)
    {
      std::string::size_type v13 = 7;
    }
    else
    {
      std::string::size_type v13 = *(unsigned __int8 *)(v12 + 23);
    }
    memset(&__str, 0, sizeof(__str));
    std::string::resize(&__str, v13, 0);
    uint64_t v16 = *(const void ***)(a1 + 32);
    if (*((char *)v16 + 23) < 0) {
      uint64_t v16 = (const void **)*v16;
    }
    if (v13)
    {
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      uint64_t v15 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)memmove(p_str, v16, v13);
    }
    int v18 = a2[9];
    uint64_t v19 = (int)a2[8];
    if ((int)v19 >= v18)
    {
      if (v18 == a2[10])
      {
        uint64_t v15 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 6), v18 + 1);
        int v18 = a2[9];
      }
      a2[9] = v18 + 1;
      unint64_t v21 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v15);
      uint64_t v22 = *((void *)a2 + 3);
      uint64_t v23 = (int)a2[8];
      a2[8] = v23 + 1;
      *(void *)(v22 + 8 * v23) = v21;
    }
    else
    {
      uint64_t v20 = *((void *)a2 + 3);
      a2[8] = v19 + 1;
      unint64_t v21 = *(std::string **)(v20 + 8 * v19);
    }
    std::string::operator=(v21, &__str);
    uint64_t v24 = *(void *)(a1 + 32);
    if (*(char *)(v24 + 23) < 0) {
      uint64_t v24 = *(void *)(v24 + 8);
    }
    else {
      LODWORD(v24) = *(unsigned __int8 *)(v24 + 23);
    }
    a2[17] |= 0x20u;
    a2[13] = v24;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100E4B33C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sms::Controller::submitSMSSendStartMetric(uint64_t a1, unsigned int a2, int a3, uint64_t a4, int a5, int a6, unsigned __int8 *a7)
{
  unsigned int v92 = a2;
  *(_OWORD *)CFStringRef v90 = 0u;
  long long v91 = 0u;
  *(_OWORD *)v88 = 0u;
  long long v89 = 0u;
  unsigned int v10 = (uint64_t **)(a1 + 2544);
  *(void *)int buf = &v92;
  int v11 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v92, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
  MCC::MCC((MCC *)v88, (const MCC *)(v11 + 49));
  MCC::MCC((MCC *)v90, (const MCC *)(v11 + 53));
  MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)v88);
  unsigned int IntValue = MCC::getIntValue((MCC *)buf);
  if (SBYTE5(v97) < 0) {
    operator delete(v94);
  }
  MCCAndMNC::getMnc((uint64_t *)buf, (MCCAndMNC *)v88);
  unsigned int v13 = MCC::getIntValue((MCC *)buf);
  if (SBYTE5(v97) < 0) {
    operator delete(v94);
  }
  int v14 = v92;
  if (v92 == 2)
  {
    uint64_t v15 = (int *)(a1 + 1288);
    goto LABEL_9;
  }
  if (v92 == 1)
  {
    uint64_t v15 = (int *)(a1 + 488);
LABEL_9:
    int v16 = *v15;
    goto LABEL_11;
  }
  int v16 = 0;
LABEL_11:
  if ((char)a7[23] < 0)
  {
    sub_10004FC84(__p, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a7;
    uint64_t v87 = *((void *)a7 + 2);
  }
  BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, v14, (uint64_t)__p);
  if (SHIBYTE(v87) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v18 = a7[23];
  if ((v18 & 0x80u) == 0) {
    uint64_t v19 = a7[23];
  }
  else {
    uint64_t v19 = *((void *)a7 + 1);
  }
  uint64_t v20 = *(unsigned __int8 *)(a1 + 199);
  int v21 = (char)v20;
  if ((v20 & 0x80u) != 0) {
    uint64_t v20 = *(void *)(a1 + 184);
  }
  if (v19 == v20)
  {
    if (v21 >= 0) {
      uint64_t v22 = (unsigned __int8 *)(a1 + 176);
    }
    else {
      uint64_t v22 = *(unsigned __int8 **)(a1 + 176);
    }
    if ((v18 & 0x80) != 0)
    {
      BOOL v30 = memcmp(*(const void **)a7, v22, *((void *)a7 + 1)) == 0;
    }
    else if (a7[23])
    {
      uint64_t v23 = v18 - 1;
      do
      {
        int v25 = *a7++;
        int v24 = v25;
        int v27 = *v22++;
        int v26 = v27;
        BOOL v29 = v23-- != 0;
        BOOL v30 = v24 == v26;
      }
      while (v24 == v26 && v29);
    }
    else
    {
      BOOL v30 = 1;
    }
  }
  else
  {
    BOOL v30 = 0;
  }
  uint64_t v31 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v92);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = asString();
    if (isEmergencyTextNumberForSlot_sync) {
      unsigned int v34 = "Emergency";
    }
    else {
      unsigned int v34 = (const char *)asString();
    }
    *(_DWORD *)int buf = 67438339;
    uint64_t v35 = "Default Transport";
    LOWORD(v94) = 1029;
    *(_DWORD *)&uint8_t buf[4] = IntValue;
    if (a5 == 1) {
      uint64_t v35 = "Signaling Transport";
    }
    *(_DWORD *)((char *)&v94 + 2) = v13;
    uint64_t v95 = v33;
    HIWORD(v94) = 2080;
    if (a5 == 2) {
      uint64_t v35 = "IMS Transport";
    }
    __int16 v96 = 2080;
    unsigned int v97 = v34;
    __int16 v98 = 2080;
    uint64_t v99 = v35;
    __int16 v100 = 1024;
    int v101 = a3;
    __int16 v102 = 2048;
    uint64_t v103 = a4;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I SMS AWD Send Start [mcc: %{sensitive}u mnc: %{sensitive}u regStatus = %s type: %s transport: %s size: %d fragments: %zu ]", buf, 0x3Cu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(a1 + 80));
  char v37 = ServiceMap;
  if (v38 < 0)
  {
    unint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v38;
  unsigned int v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)buf);
  int v59 = a6;
  unsigned int value = IntValue;
  if (v42)
  {
    uint64_t v44 = v42[3];
    uint64_t v43 = (std::__shared_weak_count *)v42[4];
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v37);
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v43);
      char v45 = 0;
      if (!v44) {
        goto LABEL_52;
      }
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v37);
  uint64_t v43 = 0;
  char v45 = 1;
  if (!v44)
  {
LABEL_52:
    unint64_t v46 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for SMS received...", buf, 2u);
    }
    goto LABEL_104;
  }
LABEL_56:
  xpc_object_t v85 = 0;
  xpc_object_t v47 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v48 = v47;
  if (v47)
  {
    xpc_object_t v85 = v47;
  }
  else
  {
    xpc_object_t v48 = xpc_null_create();
    xpc_object_t v85 = v48;
    if (!v48)
    {
      xpc_object_t v49 = xpc_null_create();
      xpc_object_t v48 = 0;
      goto LABEL_63;
    }
  }
  if (xpc_get_type(v48) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v49 = xpc_null_create();
LABEL_63:
    xpc_object_t v85 = v49;
    goto LABEL_64;
  }
  xpc_retain(v48);
LABEL_64:
  xpc_release(v48);
  unsigned int v50 = subscriber::simSlotAsInstance();
  xpc_object_t v83 = xpc_int64_create(v50);
  if (!v83) {
    xpc_object_t v83 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "subs_id";
  sub_100035E70((uint64_t)buf, &v83, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v83);
  xpc_object_t v83 = 0;
  xpc_object_t v81 = xpc_int64_create(a3);
  if (!v81) {
    xpc_object_t v81 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "wSize";
  sub_100035E70((uint64_t)buf, &v81, &v82);
  xpc_release(v82);
  xpc_object_t v82 = 0;
  xpc_release(v81);
  xpc_object_t v81 = 0;
  xpc_object_t v79 = xpc_int64_create((unsigned __int16)a4);
  if (!v79) {
    xpc_object_t v79 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "wNumFrags";
  sub_100035E70((uint64_t)buf, &v79, &v80);
  xpc_release(v80);
  xpc_object_t v80 = 0;
  xpc_release(v79);
  xpc_object_t v79 = 0;
  if (a5 == 2) {
    int64_t v51 = 1;
  }
  else {
    int64_t v51 = 2;
  }
  xpc_object_t v77 = xpc_int64_create(v51);
  if (!v77) {
    xpc_object_t v77 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "transport";
  sub_100035E70((uint64_t)buf, &v77, &v78);
  xpc_release(v78);
  xpc_object_t v78 = 0;
  xpc_release(v77);
  xpc_object_t v77 = 0;
  *(void *)int buf = &v92;
  int v52 = *((unsigned __int8 *)sub_1001B0B78(v10, (int *)&v92, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270);
  *(void *)int buf = &v92;
  char v53 = sub_1001B0B78(v10, (int *)&v92, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  if (v52)
  {
    int64_t v54 = 9;
  }
  else
  {
    uint64_t v55 = *((int *)v53[5] + 66);
    if (v55 > 0xA) {
      int64_t v54 = 0;
    }
    else {
      int64_t v54 = qword_10157E400[v55];
    }
  }
  xpc_object_t v75 = xpc_int64_create(v54);
  if (!v75) {
    xpc_object_t v75 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "rat";
  sub_100035E70((uint64_t)buf, &v75, &v76);
  xpc_release(v76);
  xpc_object_t v76 = 0;
  xpc_release(v75);
  xpc_object_t v75 = 0;
  if (isEmergencyTextNumberForSlot_sync)
  {
    int64_t v56 = 6;
  }
  else if ((v59 - 1) > 4)
  {
    int64_t v56 = 0;
  }
  else
  {
    int64_t v56 = qword_10157E3C0[v59 - 1];
  }
  xpc_object_t v73 = xpc_int64_create(v56);
  if (!v73) {
    xpc_object_t v73 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "smsType";
  sub_100035E70((uint64_t)buf, &v73, &v74);
  xpc_release(v74);
  xpc_object_t v74 = 0;
  xpc_release(v73);
  xpc_object_t v73 = 0;
  xpc_object_t v71 = xpc_int64_create(value);
  if (!v71) {
    xpc_object_t v71 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "mcc";
  sub_100035E70((uint64_t)buf, &v71, &v72);
  xpc_release(v72);
  xpc_object_t v72 = 0;
  xpc_release(v71);
  xpc_object_t v71 = 0;
  xpc_object_t v69 = xpc_int64_create(v13);
  if (!v69) {
    xpc_object_t v69 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "mnc";
  sub_100035E70((uint64_t)buf, &v69, &v70);
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_release(v69);
  xpc_object_t v69 = 0;
  uint64_t v57 = (v16 - 4);
  if (v57 < 3) {
    int64_t v58 = v57 + 1;
  }
  else {
    int64_t v58 = 0;
  }
  xpc_object_t v67 = xpc_int64_create(v58);
  if (!v67) {
    xpc_object_t v67 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "serviceStatus";
  sub_100035E70((uint64_t)buf, &v67, &v68);
  xpc_release(v68);
  xpc_object_t v68 = 0;
  xpc_release(v67);
  xpc_object_t v67 = 0;
  xpc_object_t v65 = xpc_int64_create(v30);
  if (!v65) {
    xpc_object_t v65 = xpc_null_create();
  }
  *(void *)int buf = &v85;
  uint64_t v94 = "is911";
  sub_100035E70((uint64_t)buf, &v65, &v66);
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_release(v65);
  xpc_object_t v64 = v85;
  xpc_object_t v65 = 0;
  if (v85) {
    xpc_retain(v85);
  }
  else {
    xpc_object_t v64 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v44 + 16))(v44, "metricCCSMSSendStart", &v64);
  xpc_release(v64);
  xpc_object_t v64 = 0;
  xpc_release(v85);
LABEL_104:
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v43);
  }
  if (SHIBYTE(v91) < 0) {
    operator delete(v90[1]);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete(v88[1]);
  }
}

void sub_100E4BC9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,xpc_object_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4BE10()
{
}

void sms::Controller::submitSMSSendEndMetric(uint64_t a1, unsigned int a2, int a3, int a4, unsigned __int8 *a5, unsigned int a6, int a7)
{
  unsigned int v96 = a2;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  *(void *)int buf = &v96;
  value_4 = (uint64_t **)(a1 + 2544);
  int v11 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v96, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
  MCC::MCC((MCC *)&v92, (const MCC *)(v11 + 49));
  MCC::MCC((MCC *)&v94, (const MCC *)(v11 + 53));
  MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)&v92);
  unsigned int IntValue = MCC::getIntValue((MCC *)buf);
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  MCCAndMNC::getMnc((uint64_t *)buf, (MCCAndMNC *)&v92);
  unsigned int v65 = MCC::getIntValue((MCC *)buf);
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (v96 == 2)
  {
    unsigned int v13 = (int *)(a1 + 1288);
    goto LABEL_9;
  }
  if (v96 == 1)
  {
    unsigned int v13 = (int *)(a1 + 488);
LABEL_9:
    int v64 = *v13;
    goto LABEL_11;
  }
  int v64 = 0;
LABEL_11:
  memset(&v91, 0, sizeof(v91));
  sub_100058DB0(&v91, "no error");
  switch(a6)
  {
    case 1u:
      gsmToCsiErrorWithCode();
      int v14 = (char *)asString();
      goto LABEL_20;
    case 2u:
      if (a7 <= 126)
      {
        if (a7 > 40)
        {
          if (a7 > 94)
          {
            switch(a7)
            {
              case '_':
                int v14 = "IBI_SMS_SEMANT_INCORRECT_MSG";
                break;
                int v14 = "IBI_SMS_INVALID_MANDATORY_INFO";
                break;
              case 'a':
                int v14 = "IBI_SMS_MSG_TYPE_NON_EXISTENT";
                break;
              case 'b':
                int v14 = "IBI_SMS_MSG_NOT_COMPATIBLE";
                break;
              case 'c':
                int v14 = "IBI_SMS_IE_NON_EXISTENT";
                break;
              default:
                if (a7 == 111) {
                  int v14 = "IBI_SMS_PROTOCOLL_ERROR";
                }
                else {
LABEL_147:
                }
                  int v14 = "???";
                break;
            }
          }
          else
          {
            switch(a7)
            {
              case ')':
                int v14 = "IBI_SMS_TEMPORARY_FAILURE";
                goto LABEL_20;
              case '*':
                int v14 = "IBI_SMS_CONGESTION";
                goto LABEL_20;
              case '+':
              case ',':
              case '-':
              case '.':
              case '0':
              case '1':
                goto LABEL_147;
              case '/':
                int v14 = "IBI_SMS_RESOURCES_UNAVAILABLE";
                goto LABEL_20;
              case '2':
                int v14 = "IBI_SMS_FACILITY_NOT_SUBSCRIBED";
                goto LABEL_20;
              default:
                if (a7 == 69)
                {
                  int v14 = "IBI_SMS_REQ_FACILITY_NON_IMPL";
                }
                else
                {
                  if (a7 != 81) {
                    goto LABEL_147;
                  }
                  int v14 = "IBI_SMS_INVALID_REFERENCE_VALUE";
                }
                break;
            }
          }
        }
        else
        {
          switch(a7)
          {
            case 8:
              int v14 = "IBI_SMS_OP_DETERMINED_BARRING";
              goto LABEL_20;
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 18:
            case 19:
            case 20:
            case 23:
            case 24:
            case 25:
            case 26:
              goto LABEL_147;
            case 10:
              int v14 = "IBI_SMS_CALL_BARRED";
              goto LABEL_20;
            case 16:
              int v14 = "IBI_SMS_NORMAL_CALL_CLEARING";
              goto LABEL_20;
            case 17:
              int v14 = "IBI_SMS_CP_NETWORK_FAILURE";
              goto LABEL_20;
            case 21:
              int v14 = "IBI_SMS_TRANSFER_REJECTED";
              goto LABEL_20;
            case 22:
              int v14 = "IBI_SMS_MEMORY_CAPACITY_EXCEEDED";
              goto LABEL_20;
            case 27:
              int v14 = "IBI_SMS_DEST_OUT_OF_SERVICE";
              goto LABEL_20;
            case 28:
              int v14 = "IBI_SMS_UNIDENTIFIED_SUBSCRIBER";
              goto LABEL_20;
            case 29:
              int v14 = "IBI_SMS_FACILITY_REJECTED";
              goto LABEL_20;
            case 30:
              int v14 = "IBI_SMS_UNKNOWN_SUBSCRIBER";
              goto LABEL_20;
            default:
              if (a7 == 1)
              {
                int v14 = "IBI_SMS_UNASSIGNED_NUMBER";
              }
              else
              {
                if (a7 != 38) {
                  goto LABEL_147;
                }
                int v14 = "IBI_SMS_NETWORK_OUT_OF_ORDER";
              }
              break;
          }
        }
      }
      else
      {
        switch(a7)
        {
          case 287:
            int v14 = "IBI_SMS_NETWORK_FAILURE_UNSPECIFIED";
            goto LABEL_20;
          case 288:
            int v14 = "IBI_SMS_NO_SERVICE";
            goto LABEL_20;
          case 289:
            int v14 = "IBI_SMS_MS_ACCESS_CLASS_BARRED";
            goto LABEL_20;
          case 290:
            int v14 = "IBI_SMS_NETWORK_NO_RESOURCE";
            goto LABEL_20;
          case 291:
            int v14 = "IBI_SMS_SERVICE_BUSY";
            goto LABEL_20;
          case 292:
            int v14 = "IBI_SMS_MS_FAILURE_UNSPECIFIED";
            goto LABEL_20;
          case 293:
          case 294:
          case 295:
          case 300:
          case 301:
          case 302:
          case 303:
          case 304:
          case 305:
          case 306:
          case 307:
          case 308:
          case 309:
          case 310:
          case 311:
          case 312:
          case 313:
          case 314:
          case 315:
          case 316:
          case 317:
          case 318:
          case 319:
          case 320:
          case 321:
          case 322:
          case 323:
          case 324:
          case 325:
          case 326:
          case 327:
          case 328:
          case 329:
          case 330:
          case 331:
          case 332:
          case 333:
          case 334:
          case 335:
          case 336:
          case 337:
          case 338:
          case 339:
          case 371:
          case 372:
          case 398:
          case 400:
          case 402:
          case 404:
          case 405:
          case 406:
          case 407:
          case 408:
          case 409:
          case 410:
          case 411:
          case 412:
          case 413:
          case 414:
          case 415:
          case 416:
          case 417:
          case 418:
          case 419:
          case 420:
          case 421:
          case 422:
          case 423:
          case 424:
          case 425:
          case 426:
          case 427:
          case 428:
          case 429:
          case 430:
          case 431:
          case 432:
          case 433:
          case 434:
          case 435:
          case 436:
          case 437:
          case 438:
          case 439:
          case 440:
          case 441:
          case 442:
          case 443:
          case 444:
          case 445:
          case 446:
          case 447:
          case 448:
          case 449:
          case 450:
          case 451:
          case 452:
          case 453:
          case 454:
          case 455:
          case 456:
          case 457:
          case 458:
          case 459:
          case 460:
          case 461:
          case 462:
          case 463:
          case 464:
          case 465:
          case 466:
          case 467:
          case 468:
          case 469:
          case 470:
          case 471:
          case 472:
          case 473:
          case 474:
          case 475:
          case 476:
          case 477:
          case 478:
          case 479:
          case 480:
          case 481:
          case 482:
          case 483:
          case 484:
          case 485:
          case 486:
          case 487:
          case 488:
          case 489:
          case 490:
          case 491:
          case 492:
          case 493:
          case 494:
          case 495:
          case 496:
          case 497:
          case 498:
          case 499:
          case 500:
          case 501:
          case 502:
          case 503:
          case 504:
          case 505:
          case 506:
          case 507:
          case 508:
          case 509:
          case 510:
          case 511:
            goto LABEL_147;
          case 296:
            int v14 = "IBI_SMS_DUAL_SIM_RADIO_CONFLICT";
            goto LABEL_20;
          case 297:
            int v14 = "IBI_SMS_NO_CARRIER_DUAL_SIM_CONFLICT";
            goto LABEL_20;
          case 298:
            int v14 = "IBI_SMS_SERV_NOT_ALLOWED_IN_UE_OP_MODE";
            goto LABEL_20;
          case 299:
            int v14 = "IBI_SMS_FAILURE_CAUSE_RSRVCC";
            goto LABEL_20;
          case 340:
            int v14 = "IBI_SMS_SAPI3_RELEASE";
            goto LABEL_20;
          case 341:
            int v14 = "IBI_SMS_LOWER_LAYER_FAILURE";
            goto LABEL_20;
          case 342:
            int v14 = "IBI_SMS_MS_AUTH_FAILURE";
            goto LABEL_20;
          case 343:
            int v14 = "IBI_SMS_PS_REJECT";
            goto LABEL_20;
          case 344:
            int v14 = "IBI_SMS_SERVICE_REJECTED";
            goto LABEL_20;
          case 345:
            int v14 = "IBI_SMS_ABORT_BY_NETWORK";
            goto LABEL_20;
          case 346:
            int v14 = "IBI_SMS_MS_TIMEOUT";
            goto LABEL_20;
          case 347:
            int v14 = "IBI_SMS_MS_DETACH";
            goto LABEL_20;
          case 348:
            int v14 = "IBI_SMS_RR_CONN_RELEASE";
            goto LABEL_20;
          case 349:
            int v14 = "IBI_SMS_MS_NOT_REGISTERED";
            goto LABEL_20;
          case 350:
            int v14 = "IBI_SMS_REEST_FAILURE";
            goto LABEL_20;
          case 351:
            int v14 = "IBI_SMS_MS_HANDOVER";
            goto LABEL_20;
          case 352:
            int v14 = "IBI_SMS_MS_LINK_ESTAB_FAILURE";
            goto LABEL_20;
          case 353:
            int v14 = "IBI_SMS_MS_RA_FAILURE";
            goto LABEL_20;
          case 354:
            int v14 = "IBI_SMS_MS_LINK_ABORTION";
            goto LABEL_20;
          case 355:
            int v14 = "IBI_SMS_L1_FAILURE";
            goto LABEL_20;
          case 356:
            int v14 = "IBI_SMS_IMM_ASS_REJECT";
            goto LABEL_20;
          case 357:
            int v14 = "IBI_SMS_PAGING_PENDING";
            goto LABEL_20;
          case 358:
            int v14 = "IBI_SMS_ABNORMAL_RELEASE_UNSPECIFIED";
            goto LABEL_20;
          case 359:
            int v14 = "IBI_SMS_ABNORMAL_RELEASE_CHANNEL_UNACCEPTABLE";
            goto LABEL_20;
          case 360:
            int v14 = "IBI_SMS_ABNORMAL_RELEASE_TIMER_EXPIRED";
            goto LABEL_20;
          case 361:
            int v14 = "IBI_SMS_ABNORMAL_RELEASE_NO_ACT_ON_RADIO_PATH";
            goto LABEL_20;
          case 362:
            int v14 = "IBI_SMS_MS_PREEMPTIVE_RELEASE";
            goto LABEL_20;
          case 363:
            int v14 = "IBI_SMS_UTRAN_CONFIGURATION_UNKNOWN";
            goto LABEL_20;
          case 364:
            int v14 = "IBI_SMS_HANDOVER_IMPOSSIBLE";
            goto LABEL_20;
          case 365:
            int v14 = "IBI_SMS_CHANNEL_MODE_UNACCEPTABLE";
            goto LABEL_20;
          case 366:
            int v14 = "IBI_SMS_FREQUENCY_NOT_IMPLEMENTED";
            goto LABEL_20;
          case 367:
            int v14 = "IBI_SMS_ORIGINATOR_TALKER_LEAVING_GROUP_CALL_AREA";
            goto LABEL_20;
          case 368:
            int v14 = "IBI_SMS_LOWER_LAYER_FAILURE_FROM_NW";
            goto LABEL_20;
          case 369:
            int v14 = "IBI_SMS_CALL_ALREADY_CLEARED";
            goto LABEL_20;
          case 370:
            int v14 = "IBI_SMS_SEMANTICALLY_INCORRECT_MSG";
            goto LABEL_20;
          case 373:
            int v14 = "IBI_SMS_MSG_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE";
            goto LABEL_20;
          case 374:
            int v14 = "IBI_SMS_CONDITIONAL_IE_ERROR";
            goto LABEL_20;
          case 375:
            int v14 = "IBI_SMS_NO_CELL_ALLOCATION_AVAILABLE";
            goto LABEL_20;
          case 376:
            int v14 = "IBI_SMS_PROTOCOL_ERROR_UNSPECIFIED";
            goto LABEL_20;
          case 377:
            int v14 = "IBI_SMS_MS_NORMAL_EVENT";
            goto LABEL_20;
          case 378:
            int v14 = "IBI_SMS_MS_UNSPECIFIED";
            goto LABEL_20;
          case 379:
            int v14 = "IBI_SMS_PRE_EMPTIVE_RELEASE";
            goto LABEL_20;
          case 380:
            int v14 = "IBI_SMS_MS_CONGESTION";
            goto LABEL_20;
          case 381:
            int v14 = "IBI_SMS_RE_ESTABLISHMENT_REJECT";
            goto LABEL_20;
          case 382:
            int v14 = "IBI_SMS_DIRECTED_SIGCONN_RE_ESTABLISHMENT";
            goto LABEL_20;
          case 383:
            int v14 = "IBI_SMS_USER_INACTIVITY";
            goto LABEL_20;
          case 384:
            int v14 = "IBI_SMS_MS_CONN_REL_LOWER_LAYER_FAILURE_DL";
            goto LABEL_20;
          case 385:
            int v14 = "IBI_SMS_MS_CONN_REL_LOWER_LAYER_FAILURE_UL";
            goto LABEL_20;
          case 386:
            int v14 = "IBI_SMS_MS_CELL_BARRED";
            goto LABEL_20;
          case 387:
            int v14 = "IBI_SMS_MS_SIGN_CONN_REL";
            goto LABEL_20;
          case 388:
            int v14 = "IBI_SMS_NAS_TRIGGERED_ABORT";
            goto LABEL_20;
          case 389:
            int v14 = "IBI_SMS_MS_RRC_CONN_ESTABLISHMENT_FAILURE";
            goto LABEL_20;
          case 390:
            int v14 = "IBI_SMS_MS_CONN_REJECT_REDIRECTION";
            goto LABEL_20;
          case 391:
            int v14 = "IBI_SMS_RESOURCE_CONFLICT";
            goto LABEL_20;
          case 392:
            int v14 = "IBI_SMS_MS_L2_CAUSE_SEQUENCE_ERROR";
            goto LABEL_20;
          case 393:
            int v14 = "IBI_SMS_MS_L2_CAUSE_T200_EXP_N200_PLUS_1_TIMES";
            goto LABEL_20;
          case 394:
            int v14 = "IBI_SMS_MS_L2_CAUSE_UNSOLICITED_DM_RESP_MFES";
            goto LABEL_20;
          case 395:
            int v14 = "IBI_SMS_MS_L2_CAUSE_CONTENTION_RESOLUTION";
            goto LABEL_20;
          case 396:
            int v14 = "IBI_SMS_MS_L2_CAUSE_NORMAL_CAUSE";
            goto LABEL_20;
          case 397:
            int v14 = "IBI_SMS_BAND_CHANGED";
            goto LABEL_20;
          case 399:
            int v14 = "IBI_SMS_PLMN_NOT_MATCHING";
            goto LABEL_20;
          case 401:
            int v14 = "IBI_SMS_HOFRMUTRAN_REVERT_BACK_SYNC_FAIL";
            goto LABEL_20;
          case 403:
            int v14 = "IBI_SMS_RELEASE_OOSA";
            goto LABEL_20;
          case 512:
            int v14 = "IBI_SMS_RP_ACK";
            goto LABEL_20;
          case 513:
            int v14 = "IBI_SMS_TIMER_EXPIRED";
            goto LABEL_20;
          case 514:
            int v14 = "IBI_SMS_FORW_AVAIL_FAILED";
            goto LABEL_20;
          case 515:
            int v14 = "IBI_SMS_FORW_AVAIL_ABORTED";
            goto LABEL_20;
          case 516:
            int v14 = "IBI_SMS_TP_INVALID_MTI";
            goto LABEL_20;
          case 517:
            int v14 = "IBI_SMS_TP_SRF_NOT_IN_PHASE1";
            goto LABEL_20;
          case 518:
            int v14 = "IBI_SMS_TP_RDF_NOT_IN_PHASE1";
            goto LABEL_20;
          case 519:
            int v14 = "IBI_SMS_TP_RPF_NOT_IN_PHASE1";
            goto LABEL_20;
          case 520:
            int v14 = "IBI_SMS_TP_UDHF_NOT_IN_PHASE1";
            goto LABEL_20;
          case 521:
            int v14 = "IBI_SMS_TP_MISSING_VALIDITY_PERIOD";
            goto LABEL_20;
          case 522:
            int v14 = "IBI_SMS_TP_INVALID_TIME_STAMP";
            goto LABEL_20;
          case 523:
            int v14 = "IBI_SMS_TP_MISSING_DEST_ADDRESS";
            goto LABEL_20;
          case 524:
            int v14 = "IBI_SMS_TP_INVALID_DEST_ADDRESS";
            goto LABEL_20;
          case 525:
            int v14 = "IBI_SMS_TP_MISSING_SC_ADDRESS";
            goto LABEL_20;
          case 526:
            int v14 = "IBI_SMS_TP_INVALID_SC_ADDRESS";
            goto LABEL_20;
          case 527:
            int v14 = "IBI_SMS_TP_INVALID_ALPHABET";
            goto LABEL_20;
          case 528:
            int v14 = "IBI_SMS_TP_INVALID_USER_DATA_LENGTH";
            goto LABEL_20;
          case 529:
            int v14 = "IBI_SMS_TP_MISSING_USER_DATA";
            goto LABEL_20;
          case 530:
            int v14 = "IBI_SMS_TP_USER_DATA_TOO_LARGE";
            goto LABEL_20;
          case 531:
            int v14 = "IBI_SMS_TP_CMD_REQ_NOT_IN_PHASE1";
            goto LABEL_20;
          case 532:
            int v14 = "IBI_SMS_TP_INVALID_DEST_ADDR_SPEC_CMDS";
            goto LABEL_20;
          case 533:
            int v14 = "IBI_SMS_TP_INVALID_CMD_DATA_LENGTH";
            goto LABEL_20;
          case 534:
            int v14 = "IBI_SMS_TP_MISSING_CMD_DATA";
            goto LABEL_20;
          case 535:
            int v14 = "IBI_SMS_TP_INVALID_CMD_DATA_TYPE";
            goto LABEL_20;
          case 536:
            int v14 = "IBI_SMS_TP_CREATION_OF_MNR_FAILED";
            goto LABEL_20;
          case 537:
            int v14 = "IBI_SMS_TP_CREATION_OF_CMM_FAILED";
            goto LABEL_20;
          case 538:
            int v14 = "IBI_SMS_TP_MT_CONNECTION_LOST";
            goto LABEL_20;
          case 539:
            int v14 = "IBI_SMS_TP_PENDING_MO_SMS";
            goto LABEL_20;
          case 540:
            int v14 = "IBI_SMS_REJ_BY_SMS_CONTROL";
            goto LABEL_20;
          case 541:
            int v14 = "IBI_SMS_NO_ERROR";
            goto LABEL_20;
          case 542:
            int v14 = "IBI_SMS_NO_ERROR_NO_ICON_DISPLAY";
            goto LABEL_20;
          case 543:
            int v14 = "IBI_SMS_FDN_FAILED";
            goto LABEL_20;
          case 544:
            int v14 = "IBI_SMS_FDN_SCA_FAILED";
            goto LABEL_20;
          case 545:
            int v14 = "IBI_SMS_FDN_DA_FAILED";
            goto LABEL_20;
          case 546:
            int v14 = "IBI_SMS_BDN_FAILED";
            goto LABEL_20;
          case 547:
            int v14 = "IBI_SMS_PP_UNSPECIFIED";
            goto LABEL_20;
          case 548:
            int v14 = "IBI_SMS_UNDEFINED_RESULT";
            goto LABEL_20;
          default:
            if (a7 == 127)
            {
              int v14 = "IBI_SMS_INTERWORKING";
            }
            else
            {
              if (a7 != 0x7FFFFFFF) {
                goto LABEL_147;
              }
              int v14 = "IBISmsSendResult_ARM41_INT_ENFORCE";
            }
            break;
        }
      }
      goto LABEL_20;
    case 3u:
      int v14 = (char *)sms::asString();
      goto LABEL_20;
    case 4u:
      uint64_t v111 = 0;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v98 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_10004BD84((uint64_t)buf);
      std::ostream::operator<<();
      sub_10004BC98((uint64_t)&buf[24], &v90);
      if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v91.__r_.__value_.__l.__data_);
      }
      std::string v91 = v90;
      *(void *)&uint8_t buf[16] = v15;
      if (SHIBYTE(v100) < 0) {
        operator delete(*((void **)&v99 + 1));
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      break;
    case 5u:
      int v14 = (char *)sms::asString();
LABEL_20:
      sub_10003ED78(&v91, v14);
      break;
    default:
      break;
  }
  int v16 = v96;
  if ((char)a5[23] < 0)
  {
    sub_10004FC84(&__dst, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long __dst = *(_OWORD *)a5;
    uint64_t v89 = *((void *)a5 + 2);
  }
  BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(a1, v16, (uint64_t)&__dst);
  if (SHIBYTE(v89) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v18 = a5[23];
  if ((v18 & 0x80u) == 0) {
    uint64_t v19 = a5[23];
  }
  else {
    uint64_t v19 = *((void *)a5 + 1);
  }
  uint64_t v20 = *(unsigned __int8 *)(a1 + 199);
  int v21 = (char)v20;
  if ((v20 & 0x80u) != 0) {
    uint64_t v20 = *(void *)(a1 + 184);
  }
  unsigned int value = a7;
  if (v19 == v20)
  {
    if (v21 >= 0) {
      uint64_t v22 = (unsigned __int8 *)(a1 + 176);
    }
    else {
      uint64_t v22 = *(unsigned __int8 **)(a1 + 176);
    }
    if ((v18 & 0x80) != 0)
    {
      BOOL v30 = memcmp(*(const void **)a5, v22, *((void *)a5 + 1)) == 0;
    }
    else if (a5[23])
    {
      uint64_t v23 = v18 - 1;
      do
      {
        int v25 = *a5++;
        int v24 = v25;
        int v27 = *v22++;
        int v26 = v27;
        BOOL v29 = v23-- != 0;
        BOOL v30 = v24 == v26;
      }
      while (v24 == v26 && v29);
    }
    else
    {
      BOOL v30 = 1;
    }
  }
  else
  {
    BOOL v30 = 0;
  }
  uint64_t v31 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v96);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = asString();
    if (isEmergencyTextNumberForSlot_sync) {
      unsigned int v34 = "Emergency";
    }
    else {
      unsigned int v34 = (const char *)asString();
    }
    uint64_t v35 = sms::asString();
    unint64_t v36 = "Default Transport";
    *(_WORD *)&uint8_t buf[8] = 1029;
    if (a3 == 1) {
      unint64_t v36 = "Signaling Transport";
    }
    if (a3 == 2) {
      unint64_t v36 = "IMS Transport";
    }
    *(_DWORD *)int buf = 67438339;
    *(_DWORD *)&uint8_t buf[4] = IntValue;
    *(_DWORD *)&buf[10] = v65;
    char v37 = &v91;
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      char v37 = (std::string *)v91.__r_.__value_.__r.__words[0];
    }
    *(_WORD *)&buf[14] = 2080;
    *(void *)&uint8_t buf[16] = v33;
    *(_WORD *)&unsigned char buf[24] = 2080;
    *(void *)&buf[26] = v34;
    *(_WORD *)&buf[34] = 2080;
    *(void *)&buf[36] = v36;
    *(_WORD *)&buf[44] = 2080;
    *(void *)&buf[46] = v35;
    *(_WORD *)&buf[54] = 2080;
    *(void *)&buf[56] = v37;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I SMS AWD Send End [mcc: %{sensitive}u mnc: %{sensitive}u regStatus = %s type: %s transport: %s errorGroup: %s error: %s]", buf, 0x40u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(a1 + 80));
  unint64_t v39 = ServiceMap;
  if (v40 < 0)
  {
    unsigned int v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      uint64_t v40 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v40;
  uint64_t v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)buf);
  if (v44)
  {
    uint64_t v45 = v44[3];
    unint64_t v46 = (std::__shared_weak_count *)v44[4];
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v39);
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v46);
      char v47 = 0;
      if (!v45) {
        goto LABEL_67;
      }
      goto LABEL_71;
    }
  }
  else
  {
    uint64_t v45 = 0;
  }
  std::mutex::unlock(v39);
  unint64_t v46 = 0;
  char v47 = 1;
  if (!v45)
  {
LABEL_67:
    xpc_object_t v48 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for SMS received...", buf, 2u);
    }
    goto LABEL_119;
  }
LABEL_71:
  v90.__r_.__value_.__r.__words[0] = 0;
  xpc_object_t v49 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v50 = v49;
  if (v49)
  {
    v90.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
  }
  else
  {
    xpc_object_t v50 = xpc_null_create();
    v90.__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
    if (!v50)
    {
      xpc_object_t v51 = xpc_null_create();
      xpc_object_t v50 = 0;
      goto LABEL_78;
    }
  }
  if (xpc_get_type(v50) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v51 = xpc_null_create();
LABEL_78:
    v90.__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
    goto LABEL_79;
  }
  xpc_retain(v50);
LABEL_79:
  xpc_release(v50);
  unsigned int v52 = subscriber::simSlotAsInstance();
  xpc_object_t v86 = xpc_int64_create(v52);
  if (!v86) {
    xpc_object_t v86 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "subs_id";
  sub_100035E70((uint64_t)buf, &v86, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v86);
  xpc_object_t v86 = 0;
  xpc_object_t v84 = xpc_int64_create(a6);
  if (!v84) {
    xpc_object_t v84 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "errorGroup";
  sub_100035E70((uint64_t)buf, &v84, &v85);
  xpc_release(v85);
  xpc_object_t v85 = 0;
  xpc_release(v84);
  xpc_object_t v84 = 0;
  xpc_object_t v82 = xpc_int64_create(value);
  if (!v82) {
    xpc_object_t v82 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "errorCode";
  sub_100035E70((uint64_t)buf, &v82, &v83);
  xpc_release(v83);
  xpc_object_t v83 = 0;
  xpc_release(v82);
  xpc_object_t v82 = 0;
  if (isEmergencyTextNumberForSlot_sync)
  {
    int64_t v53 = 6;
  }
  else if ((a4 - 1) > 4)
  {
    int64_t v53 = 0;
  }
  else
  {
    int64_t v53 = qword_10157E3C0[a4 - 1];
  }
  xpc_object_t v80 = xpc_int64_create(v53);
  if (!v80) {
    xpc_object_t v80 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "smsType";
  sub_100035E70((uint64_t)buf, &v80, &v81);
  xpc_release(v81);
  xpc_object_t v81 = 0;
  xpc_release(v80);
  xpc_object_t v80 = 0;
  if (a3 == 2) {
    int64_t v54 = 1;
  }
  else {
    int64_t v54 = 2;
  }
  xpc_object_t v78 = xpc_int64_create(v54);
  if (!v78) {
    xpc_object_t v78 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "transport";
  sub_100035E70((uint64_t)buf, &v78, &v79);
  xpc_release(v79);
  xpc_object_t v79 = 0;
  xpc_release(v78);
  xpc_object_t v78 = 0;
  *(void *)int buf = &v96;
  int v55 = *((unsigned __int8 *)sub_1001B0B78(value_4, (int *)&v96, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270);
  *(void *)int buf = &v96;
  int64_t v56 = sub_1001B0B78(value_4, (int *)&v96, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  if (v55)
  {
    int64_t v57 = 9;
  }
  else
  {
    uint64_t v58 = *((int *)v56[5] + 66);
    if (v58 > 0xA) {
      int64_t v57 = 0;
    }
    else {
      int64_t v57 = qword_10157E400[v58];
    }
  }
  xpc_object_t v76 = xpc_int64_create(v57);
  if (!v76) {
    xpc_object_t v76 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "rat";
  sub_100035E70((uint64_t)buf, &v76, &v77);
  xpc_release(v77);
  xpc_object_t v77 = 0;
  xpc_release(v76);
  xpc_object_t v76 = 0;
  xpc_object_t v74 = xpc_int64_create(IntValue);
  if (!v74) {
    xpc_object_t v74 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "mcc";
  sub_100035E70((uint64_t)buf, &v74, &v75);
  xpc_release(v75);
  xpc_object_t v75 = 0;
  xpc_release(v74);
  xpc_object_t v74 = 0;
  xpc_object_t v72 = xpc_int64_create(v65);
  if (!v72) {
    xpc_object_t v72 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "mnc";
  sub_100035E70((uint64_t)buf, &v72, &v73);
  xpc_release(v73);
  xpc_object_t v73 = 0;
  xpc_release(v72);
  xpc_object_t v72 = 0;
  uint64_t v59 = (v64 - 4);
  if (v59 < 3) {
    int64_t v60 = v59 + 1;
  }
  else {
    int64_t v60 = 0;
  }
  xpc_object_t v70 = xpc_int64_create(v60);
  if (!v70) {
    xpc_object_t v70 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "serviceStatus";
  sub_100035E70((uint64_t)buf, &v70, &v71);
  xpc_release(v71);
  xpc_object_t v71 = 0;
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_object_t v68 = xpc_BOOL_create(v30);
  if (!v68) {
    xpc_object_t v68 = xpc_null_create();
  }
  *(void *)int buf = &v90;
  *(void *)&uint8_t buf[8] = "is911";
  sub_100035E70((uint64_t)buf, &v68, &v69);
  xpc_release(v69);
  xpc_object_t v69 = 0;
  xpc_release(v68);
  xpc_object_t v67 = (xpc_object_t)v90.__r_.__value_.__r.__words[0];
  xpc_object_t v68 = 0;
  if (v90.__r_.__value_.__r.__words[0]) {
    xpc_retain(v90.__r_.__value_.__l.__data_);
  }
  else {
    xpc_object_t v67 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v45 + 16))(v45, "metricCCSMSSendEnd", &v67);
  xpc_release(v67);
  xpc_object_t v67 = 0;
  xpc_release(v90.__r_.__value_.__l.__data_);
LABEL_119:
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v46);
  }
  if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v91.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v95) < 0) {
    operator delete(*((void **)&v94 + 1));
  }
  if (SHIBYTE(v93) < 0) {
    operator delete(*((void **)&v92 + 1));
  }
}

void sub_100E4D0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,xpc_object_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,char a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (a46 < 0) {
    operator delete(__p);
  }
  sub_10013C44C((uint64_t)&a48);
  _Unwind_Resume(a1);
}

void sms::Controller::submitSMSReceivedMetric(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int a5, int a6)
{
  if (a5 > 4) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = dword_10157E3E8[(char)a5];
  }
  sms::Controller::submitSMSReceivedMetric(a1, a2, a3, a4, v6, a6, 0);
}

void sms::Controller::submitSMSReceivedMetric(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int a5, int a6, BOOL a7)
{
  int v74 = a2;
  *(_OWORD *)long long __p = 0u;
  long long v73 = 0u;
  *(_OWORD *)xpc_object_t v70 = 0u;
  long long v71 = 0u;
  int v11 = (uint64_t **)(a1 + 2544);
  *(void *)int buf = &v74;
  uint64_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v74, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
  MCC::MCC((MCC *)v70, (const MCC *)(v12 + 49));
  MCC::MCC((MCC *)__p, (const MCC *)(v12 + 53));
  MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)v70);
  unsigned int IntValue = MCC::getIntValue((MCC *)buf);
  if (SBYTE5(v79) < 0) {
    operator delete(v76);
  }
  MCCAndMNC::getMnc((uint64_t *)buf, (MCCAndMNC *)v70);
  unsigned int v14 = MCC::getIntValue((MCC *)buf);
  if (SBYTE5(v79) < 0) {
    operator delete(v76);
  }
  if (v74 == 2)
  {
    xpc_object_t v15 = (int *)(a1 + 1288);
    goto LABEL_9;
  }
  if (v74 == 1)
  {
    xpc_object_t v15 = (int *)(a1 + 488);
LABEL_9:
    int v16 = *v15;
    goto LABEL_11;
  }
  int v16 = 0;
LABEL_11:
  uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = asString();
    uint64_t v20 = "Signaling Transport";
    if (a6 != 1) {
      uint64_t v20 = "Default Transport";
    }
    if (a5 - 1 > 0xC) {
      int v21 = "kCommCenterSMSTypeUnknown";
    }
    else {
      int v21 = off_101A60B30[a5 - 1];
    }
    *(_DWORD *)int buf = 67438595;
    if (a6 == 2) {
      uint64_t v20 = "IMS Transport";
    }
    *(_DWORD *)&uint8_t buf[4] = IntValue;
    LOWORD(v76) = 1029;
    *(_DWORD *)((char *)&v76 + 2) = v14;
    HIWORD(v76) = 2080;
    uint64_t v77 = v19;
    __int16 v78 = 2080;
    xpc_object_t v79 = v21;
    __int16 v80 = 2080;
    xpc_object_t v81 = v20;
    __int16 v82 = 1024;
    int v83 = a3;
    __int16 v84 = 2048;
    uint64_t v85 = a4;
    __int16 v86 = 1024;
    BOOL v87 = a7;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I SMS AWD received [mcc: %{sensitive}u mnc: %{sensitive}u regStatus = %s type: %s transport: %s sz: %d numOfFrags: %zu is911: %d]", buf, 0x42u);
  }
  unsigned int value = a5;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 80));
  uint64_t v23 = ServiceMap;
  if (v24 < 0)
  {
    int v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v24;
  unint64_t v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)buf);
  int v44 = a6;
  if (v28)
  {
    uint64_t v29 = v28[3];
    BOOL v30 = (std::__shared_weak_count *)v28[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v31 = 0;
      if (!v29) {
        goto LABEL_26;
      }
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v23);
  BOOL v30 = 0;
  char v31 = 1;
  if (!v29)
  {
LABEL_26:
    uint64_t v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for SMS received...", buf, 2u);
    }
    goto LABEL_73;
  }
LABEL_30:
  xpc_object_t v69 = 0;
  xpc_object_t v33 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v34 = v33;
  if (v33)
  {
    xpc_object_t v69 = v33;
  }
  else
  {
    xpc_object_t v34 = xpc_null_create();
    xpc_object_t v69 = v34;
    if (!v34)
    {
      xpc_object_t v35 = xpc_null_create();
      xpc_object_t v34 = 0;
      goto LABEL_37;
    }
  }
  if (xpc_get_type(v34) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v35 = xpc_null_create();
LABEL_37:
    xpc_object_t v69 = v35;
    goto LABEL_38;
  }
  xpc_retain(v34);
LABEL_38:
  xpc_release(v34);
  unsigned int v36 = subscriber::simSlotAsInstance();
  xpc_object_t v67 = xpc_int64_create(v36);
  if (!v67) {
    xpc_object_t v67 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "subs_id";
  sub_100035E70((uint64_t)buf, &v67, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v67);
  xpc_object_t v67 = 0;
  xpc_object_t v65 = xpc_int64_create(a3);
  if (!v65) {
    xpc_object_t v65 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "wSize";
  sub_100035E70((uint64_t)buf, &v65, &v66);
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_release(v65);
  xpc_object_t v65 = 0;
  xpc_object_t v63 = xpc_int64_create((unsigned __int16)a4);
  if (!v63) {
    xpc_object_t v63 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "wNumFrags";
  sub_100035E70((uint64_t)buf, &v63, &v64);
  xpc_release(v64);
  xpc_object_t v64 = 0;
  xpc_release(v63);
  xpc_object_t v63 = 0;
  xpc_object_t v61 = xpc_int64_create(value);
  if (!v61) {
    xpc_object_t v61 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "smsType";
  sub_100035E70((uint64_t)buf, &v61, &v62);
  xpc_release(v62);
  xpc_object_t v62 = 0;
  xpc_release(v61);
  xpc_object_t v61 = 0;
  if (v44 == 2) {
    int64_t v37 = 1;
  }
  else {
    int64_t v37 = 2;
  }
  xpc_object_t v59 = xpc_int64_create(v37);
  if (!v59) {
    xpc_object_t v59 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "transport";
  sub_100035E70((uint64_t)buf, &v59, &v60);
  xpc_release(v60);
  xpc_object_t v60 = 0;
  xpc_release(v59);
  xpc_object_t v59 = 0;
  *(void *)int buf = &v74;
  int v38 = *((unsigned __int8 *)sub_1001B0B78(v11, &v74, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270);
  *(void *)int buf = &v74;
  unint64_t v39 = sub_1001B0B78(v11, &v74, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  if (v38)
  {
    int64_t v40 = 9;
  }
  else
  {
    uint64_t v41 = *((int *)v39[5] + 66);
    if (v41 > 0xA) {
      int64_t v40 = 0;
    }
    else {
      int64_t v40 = qword_10157E400[v41];
    }
  }
  xpc_object_t v57 = xpc_int64_create(v40);
  if (!v57) {
    xpc_object_t v57 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "rat";
  sub_100035E70((uint64_t)buf, &v57, &v58);
  xpc_release(v58);
  xpc_object_t v58 = 0;
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_object_t v55 = xpc_int64_create(IntValue);
  if (!v55) {
    xpc_object_t v55 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "mcc";
  sub_100035E70((uint64_t)buf, &v55, &v56);
  xpc_release(v56);
  xpc_object_t v56 = 0;
  xpc_release(v55);
  xpc_object_t v55 = 0;
  xpc_object_t v53 = xpc_int64_create(v14);
  if (!v53) {
    xpc_object_t v53 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "mnc";
  sub_100035E70((uint64_t)buf, &v53, &v54);
  xpc_release(v54);
  xpc_object_t v54 = 0;
  xpc_release(v53);
  xpc_object_t v53 = 0;
  uint64_t v42 = (v16 - 4);
  if (v42 < 3) {
    int64_t v43 = v42 + 1;
  }
  else {
    int64_t v43 = 0;
  }
  xpc_object_t v51 = xpc_int64_create(v43);
  if (!v51) {
    xpc_object_t v51 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "serviceStatus";
  sub_100035E70((uint64_t)buf, &v51, &v52);
  xpc_release(v52);
  xpc_object_t v52 = 0;
  xpc_release(v51);
  xpc_object_t v51 = 0;
  xpc_object_t v49 = xpc_BOOL_create(a7);
  if (!v49) {
    xpc_object_t v49 = xpc_null_create();
  }
  *(void *)int buf = &v69;
  xpc_object_t v76 = "is911";
  sub_100035E70((uint64_t)buf, &v49, &v50);
  xpc_release(v50);
  xpc_object_t v50 = 0;
  xpc_release(v49);
  xpc_object_t v48 = v69;
  xpc_object_t v49 = 0;
  if (v69) {
    xpc_retain(v69);
  }
  else {
    xpc_object_t v48 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v29 + 16))(v29, "metricCCSMSReceived", &v48);
  xpc_release(v48);
  xpc_object_t v48 = 0;
  xpc_release(v69);
LABEL_73:
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (SHIBYTE(v73) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v71) < 0) {
    operator delete(v70[1]);
  }
}

void sub_100E4DF74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,xpc_object_t a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E4E0D0()
{
}

void sms::Controller::incrementMTSMSRecvFailedCounter(Registry **this@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, this[10]);
  uint64_t v3 = ServiceMap;
  int v4 = "N3awd7metrics14MetricCountersE";
  if (((unint64_t)"N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)((unint64_t)"N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      int v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v13 = v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v13);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    int v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10)
  {
LABEL_10:
    uint64_t v12 = *(void *)(v10 + 344);
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 16));
    ++*(void *)(v12 + 80);
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E4E1DC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sms::Controller::incrementMTSMSRecvSuccessCounter(Registry **this@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, this[10]);
  uint64_t v3 = ServiceMap;
  int v4 = "N3awd7metrics14MetricCountersE";
  if (((unint64_t)"N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)((unint64_t)"N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      int v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v13 = v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v13);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    int v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10)
  {
LABEL_10:
    uint64_t v12 = *(void *)(v10 + 336);
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 16));
    ++*(void *)(v12 + 80);
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E4E2F8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void CarrierBundleHandler::prepareBundleMetric(CarrierBundleHandler *this)
{
  char v2 = this;
  sub_100E4E398((uint64_t)&v2);
  sub_100E4E398((uint64_t)&v2);
  sub_100E4E398((uint64_t)&v2);
  sub_100E4E398((uint64_t)&v2);
  if (capabilities::ct::supportsGemini(v1))
  {
    sub_100E4E398((uint64_t)&v2);
    sub_100E4E398((uint64_t)&v2);
  }
}

void sub_100E4E398(uint64_t a1)
{
  sub_10003E168(&v2, (void *)(*(void *)a1 + 8));
  unsigned int v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E4E4AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  _Unwind_Resume(exception_object);
}

void CarrierBundleHandler::submitBundleStateMetric_sync(uint64_t a1, unsigned __int8 *a2, int a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  int v9 = ServiceMap;
  if (v10 < 0)
  {
    char v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v15 = v14[3];
    int v16 = (std::__shared_weak_count *)v14[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v17 = 0;
      if (!v15) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = asString();
        *(_DWORD *)int buf = 136315138;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I CA: Submitting the state of %s", buf, 0xCu);
      }
      xpc_object_t v88 = 0;
      xpc_object_t v21 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v22 = v21;
      if (v21)
      {
        xpc_object_t v88 = v21;
      }
      else
      {
        xpc_object_t v22 = xpc_null_create();
        xpc_object_t v88 = v22;
        if (!v22)
        {
          xpc_object_t v23 = xpc_null_create();
          xpc_object_t v22 = 0;
          goto LABEL_20;
        }
      }
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v22);
        goto LABEL_21;
      }
      xpc_object_t v23 = xpc_null_create();
LABEL_20:
      xpc_object_t v88 = v23;
LABEL_21:
      xpc_release(v22);
      unsigned int v24 = subscriber::simSlotAsInstance();
      xpc_object_t v86 = xpc_int64_create(v24);
      if (!v86) {
        xpc_object_t v86 = xpc_null_create();
      }
      *(void *)int buf = &v88;
      *(void *)&uint8_t buf[8] = "subs_id";
      sub_100035E70((uint64_t)buf, &v86, &v87);
      xpc_release(v87);
      xpc_object_t v87 = 0;
      xpc_release(v86);
      xpc_object_t v86 = 0;
      CFDictionaryRef v25 = (const __CFDictionary *)*((void *)a2 + 25);
      if (v25) {
        uint64_t v26 = sub_100080778;
      }
      else {
        uint64_t v26 = 0;
      }
      if (v26)
      {
        Value = CFDictionaryGetValue(v25, (const void *)qword_101B13EC0);
        unint64_t v28 = Value;
        if (Value)
        {
          CFTypeID v29 = CFGetTypeID(Value);
          if (v29 == CFStringGetTypeID())
          {
            v62[0] = v28;
            sub_1000292E0((uint64_t)&__str);
            std::string::basic_string((std::string *)buf, &__str, 0, 7uLL, (std::allocator<char> *)&v63);
            if ((SBYTE7(v90) & 0x80u) == 0) {
              BOOL v30 = buf;
            }
            else {
              BOOL v30 = *(uint8_t **)buf;
            }
            xpc_object_t v84 = xpc_string_create((const char *)v30);
            if (!v84) {
              xpc_object_t v84 = xpc_null_create();
            }
            v63.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
            v63.__r_.__value_.__l.__size_ = (std::string::size_type)"imsi_prefix";
            sub_100035E70((uint64_t)&v63, &v84, &v85);
            xpc_release(v85);
            xpc_object_t v85 = 0;
            xpc_release(v84);
            xpc_object_t v84 = 0;
            if (SBYTE7(v90) < 0) {
              operator delete(*(void **)buf);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }
        }
      }
      uint64_t v31 = a2[23];
      if ((v31 & 0x80u) != 0) {
        uint64_t v31 = *((void *)a2 + 1);
      }
      if (!v31)
      {
        xpc_object_t v33 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = asString();
          *(_DWORD *)int buf = 136315138;
          *(void *)&uint8_t buf[4] = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#N State of %s is not valid", buf, 0xCu);
        }
        goto LABEL_135;
      }
      if ((a3 - 1) > 3u) {
        uint64_t v32 = "???";
      }
      else {
        uint64_t v32 = off_101A60C20[(char)(a3 - 1)];
      }
      xpc_object_t v81 = xpc_string_create(v32);
      if (!v81) {
        xpc_object_t v81 = xpc_null_create();
      }
      *(void *)int buf = &v88;
      *(void *)&uint8_t buf[8] = "bundle_type";
      sub_100035E70((uint64_t)buf, &v81, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v81);
      xpc_object_t v81 = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 88) + 120))(buf);
      if ((SBYTE7(v90) & 0x80u) == 0) {
        xpc_object_t v35 = buf;
      }
      else {
        xpc_object_t v35 = *(uint8_t **)buf;
      }
      xpc_object_t v79 = xpc_string_create((const char *)v35);
      if (!v79) {
        xpc_object_t v79 = xpc_null_create();
      }
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
      __str.__r_.__value_.__l.__size_ = (std::string::size_type)"matching_bundle_name";
      sub_100035E70((uint64_t)&__str, &v79, &v80);
      xpc_release(v80);
      xpc_object_t v80 = 0;
      xpc_release(v79);
      xpc_object_t v79 = 0;
      if (SBYTE7(v90) < 0) {
        operator delete(*(void **)buf);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 88) + 120))(buf);
      if ((SBYTE7(v90) & 0x80u) == 0) {
        unsigned int v36 = buf;
      }
      else {
        unsigned int v36 = *(uint8_t **)buf;
      }
      xpc_object_t v77 = xpc_string_create((const char *)v36);
      if (!v77) {
        xpc_object_t v77 = xpc_null_create();
      }
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
      __str.__r_.__value_.__l.__size_ = (std::string::size_type)"resolved_bundle_name";
      sub_100035E70((uint64_t)&__str, &v77, &v78);
      xpc_release(v78);
      xpc_object_t v78 = 0;
      xpc_release(v77);
      xpc_object_t v77 = 0;
      if (SBYTE7(v90) < 0) {
        operator delete(*(void **)buf);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 88) + 120))(buf);
      if ((SBYTE7(v90) & 0x80u) == 0) {
        int64_t v37 = buf;
      }
      else {
        int64_t v37 = *(uint8_t **)buf;
      }
      xpc_object_t v75 = xpc_string_create((const char *)v37);
      if (!v75) {
        xpc_object_t v75 = xpc_null_create();
      }
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
      __str.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier_plist_name";
      sub_100035E70((uint64_t)&__str, &v75, &v76);
      xpc_release(v76);
      xpc_object_t v76 = 0;
      xpc_release(v75);
      xpc_object_t v75 = 0;
      if (SBYTE7(v90) < 0) {
        operator delete(*(void **)buf);
      }
      if ((a2[119] & 0x80u) == 0) {
        int v38 = (const char *)(a2 + 96);
      }
      else {
        int v38 = (const char *)*((void *)a2 + 12);
      }
      xpc_object_t v73 = xpc_string_create(v38);
      if (!v73) {
        xpc_object_t v73 = xpc_null_create();
      }
      *(void *)int buf = &v88;
      *(void *)&uint8_t buf[8] = "bundle_version";
      sub_100035E70((uint64_t)buf, &v73, &v74);
      xpc_release(v74);
      xpc_object_t v74 = 0;
      xpc_release(v73);
      xpc_object_t v73 = 0;
      sub_1000493DC(&v70, kSysCBDir);
      char v39 = ctu::starts_with();
      xpc_object_t v71 = xpc_BOOL_create(v39);
      if (!v71) {
        xpc_object_t v71 = xpc_null_create();
      }
      *(void *)int buf = &v88;
      *(void *)&uint8_t buf[8] = "is_embedded";
      sub_100035E70((uint64_t)buf, &v71, &v72);
      xpc_release(v72);
      xpc_object_t v72 = 0;
      xpc_release(v71);
      xpc_object_t v71 = 0;
      if (a3 != 1) {
        goto LABEL_135;
      }
      sub_1000292E0((uint64_t)buf);
      uint64_t v40 = a2[23];
      if ((v40 & 0x80u) == 0) {
        uint64_t v41 = a2[23];
      }
      else {
        uint64_t v41 = *((void *)a2 + 1);
      }
      uint64_t v42 = BYTE7(v90);
      int v43 = SBYTE7(v90);
      if (SBYTE7(v90) < 0) {
        uint64_t v42 = *(void *)&buf[8];
      }
      if (v41 != v42)
      {
        BOOL v52 = 0;
        if ((SBYTE7(v90) & 0x80000000) == 0) {
          goto LABEL_100;
        }
        goto LABEL_96;
      }
      if ((SBYTE7(v90) & 0x80u) == 0) {
        int v44 = buf;
      }
      else {
        int v44 = *(uint8_t **)buf;
      }
      if ((v40 & 0x80) != 0)
      {
        BOOL v52 = memcmp(*(const void **)a2, v44, *((void *)a2 + 1)) == 0;
      }
      else
      {
        if (!a2[23])
        {
          BOOL v52 = 1;
          if ((SBYTE7(v90) & 0x80000000) == 0)
          {
LABEL_100:
            if (v52)
            {
LABEL_101:
              int v53 = CarrierBundleHandler::evaluateGsmaSettingsSwitchState_sync(a1, a4);
              if (v53 == 2) {
                int64_t v54 = 2;
              }
              else {
                int64_t v54 = v53 == 1;
              }
              xpc_object_t v68 = xpc_int64_create(v54);
              if (!v68) {
                xpc_object_t v68 = xpc_null_create();
              }
              *(void *)int buf = &v88;
              *(void *)&uint8_t buf[8] = "gsma_switch_state";
              sub_100035E70((uint64_t)buf, &v68, &v69);
              xpc_release(v69);
              xpc_object_t v69 = 0;
              xpc_release(v68);
              xpc_object_t v68 = 0;
              memset(&__str, 0, sizeof(__str));
              (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 88) + 120))(buf);
              getGSMAOverlayKey(&__str);
              if (SBYTE7(v90) < 0) {
                operator delete(*(void **)buf);
              }
              char v55 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = __str.__r_.__value_.__l.__size_;
              }
              if (size)
              {
                uint64_t v93 = 0;
                long long v91 = 0u;
                long long v92 = 0u;
                *(_OWORD *)int buf = 0u;
                long long v90 = 0u;
                ctu::partition();
                xpc_object_t v66 = xpc_BOOL_create(1);
                if (!v66) {
                  xpc_object_t v66 = xpc_null_create();
                }
                v63.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
                v63.__r_.__value_.__l.__size_ = (std::string::size_type)"gsma_settings_applied";
                sub_100035E70((uint64_t)&v63, &v66, &v67);
                xpc_release(v67);
                xpc_object_t v67 = 0;
                xpc_release(v66);
                xpc_object_t v66 = 0;
                std::string::basic_string(&v63, (const std::string *)buf, 2uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v62);
                if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  xpc_object_t v57 = &v63;
                }
                else {
                  xpc_object_t v57 = (std::string *)v63.__r_.__value_.__r.__words[0];
                }
                xpc_object_t v64 = xpc_string_create((const char *)v57);
                if (!v64) {
                  xpc_object_t v64 = xpc_null_create();
                }
                v62[0] = &v88;
                v62[1] = "gsma_matched_config_name";
                sub_100035E70((uint64_t)v62, &v64, &v65);
                xpc_release(v65);
                xpc_object_t v65 = 0;
                xpc_release(v64);
                xpc_object_t v64 = 0;
                if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v63.__r_.__value_.__l.__data_);
                }
                if (v93 >= 0) {
                  xpc_object_t v58 = (const char *)&v92;
                }
                else {
                  xpc_object_t v58 = (const char *)v92;
                }
                xpc_object_t v60 = xpc_string_create(v58);
                if (!v60) {
                  xpc_object_t v60 = xpc_null_create();
                }
                v63.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
                v63.__r_.__value_.__l.__size_ = (std::string::size_type)"gsma_bundle_version";
                sub_100035E70((uint64_t)&v63, &v60, &v61);
                xpc_release(v61);
                xpc_object_t v61 = 0;
                xpc_release(v60);
                xpc_object_t v60 = 0;
                if (SHIBYTE(v93) < 0) {
                  operator delete((void *)v92);
                }
                if (SHIBYTE(v91) < 0) {
                  operator delete(*((void **)&v90 + 1));
                }
                if (SBYTE7(v90) < 0) {
                  operator delete(*(void **)buf);
                }
                char v55 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              }
              if (v55 < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
            }
LABEL_135:
            xpc_object_t v59 = v88;
            if (v88) {
              xpc_retain(v88);
            }
            else {
              xpc_object_t v59 = xpc_null_create();
            }
            (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterBundleDetails", &v59);
            xpc_release(v59);
            xpc_object_t v59 = 0;
            xpc_release(v88);
            goto LABEL_139;
          }
LABEL_96:
          operator delete(*(void **)buf);
          if (v52) {
            goto LABEL_101;
          }
          goto LABEL_135;
        }
        uint64_t v45 = v40 - 1;
        do
        {
          int v47 = *a2++;
          int v46 = v47;
          int v49 = *v44++;
          int v48 = v49;
          BOOL v51 = v45-- != 0;
          BOOL v52 = v46 == v48;
        }
        while (v46 == v48 && v51);
      }
      if ((v43 & 0x80000000) == 0) {
        goto LABEL_100;
      }
      goto LABEL_96;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v9);
  int v16 = 0;
  char v17 = 1;
  if (v15) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid Analytics Interface. Not submitting metric.", buf, 2u);
  }
LABEL_139:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_100E4F010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void CarrierBundleHandler::submitBundleStateMetric_sync(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if ((a2 - 1) <= 3u)
  {
    v10[5] = v3;
    v10[6] = v4;
    unint64_t v9 = a2 | (unint64_t)(a3 << 32);
    v10[0] = &v9;
    unint64_t v8 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v9, (uint64_t)&unk_10144E20E, v10);
    CarrierBundleHandler::submitBundleStateMetric_sync(a1, (unsigned __int8 *)v8 + 40, a2, a3);
  }
}

void CarrierBundleHandler::submitBundleScheduleMetric_sync(CarrierBundleHandler *this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*((Registry **)this + 13));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&buf);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    unint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_26;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  unint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (!v10) {
    goto LABEL_26;
  }
LABEL_10:
  uint64_t v12 = *((void *)this + 5);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *((void *)this + 52);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Submit metric for update schedule set to %@", (uint8_t *)&buf, 0xCu);
  }
  double AbsoluteTime = CFDateGetAbsoluteTime(*((CFDateRef *)this + 52));
  double Current = CFAbsoluteTimeGetCurrent();
  xpc_object_t v22 = 0;
  xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v17 = v16;
  if (v16)
  {
    xpc_object_t v22 = v16;
  }
  else
  {
    xpc_object_t v17 = xpc_null_create();
    xpc_object_t v22 = v17;
    if (!v17)
    {
      xpc_object_t v18 = xpc_null_create();
      xpc_object_t v17 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v18 = xpc_null_create();
LABEL_19:
    xpc_object_t v22 = v18;
    goto LABEL_20;
  }
  xpc_retain(v17);
LABEL_20:
  xpc_release(v17);
  xpc_object_t v20 = xpc_int64_create((uint64_t)(AbsoluteTime - Current) / 86400);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  *(void *)&long long buf = &v22;
  *((void *)&buf + 1) = "next_bundle_update_check_in_days";
  sub_100035E70((uint64_t)&buf, &v20, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v20);
  xpc_object_t v19 = v22;
  xpc_object_t v20 = 0;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v10 + 16))(v10, "commCenterBundleUpdateCheckSchedule", &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(v22);
LABEL_26:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E4F504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, xpc_object_t a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void CarrierBundleHandler::submitLegacyDesktopHostUpdateMetric_sync(uint64_t a1, int a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_36;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14) {
    goto LABEL_36;
  }
LABEL_10:
  xpc_object_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Submitting metric for older desktop host update mechanism", buf, 2u);
  }
  xpc_object_t v31 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v31 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v31 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_19;
    }
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v19 = xpc_null_create();
LABEL_19:
    xpc_object_t v31 = v19;
    goto LABEL_20;
  }
  xpc_retain(v18);
LABEL_20:
  xpc_release(v18);
  if ((a2 - 1) < 6) {
    int64_t v20 = (a2 - 1) + 1;
  }
  else {
    int64_t v20 = 0;
  }
  xpc_object_t v29 = xpc_int64_create(v20);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)long long buf = &v31;
  unint64_t v28 = "bundle_update_check_info_bundle_type";
  sub_100035E70((uint64_t)buf, &v29, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (*(char *)(a3 + 23) >= 0) {
    xpc_object_t v21 = (const char *)a3;
  }
  else {
    xpc_object_t v21 = *(const char **)a3;
  }
  xpc_object_t v25 = xpc_string_create(v21);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)long long buf = &v31;
  unint64_t v28 = "bundle_update_check_info_bundle_name_to_check";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_BOOL_create(1);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  *(void *)long long buf = &v31;
  unint64_t v28 = "is_desktop_host_using_legacy_mechanism";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v22 = v31;
  xpc_object_t v23 = 0;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v14 + 16))(v14, "commCenterBundleUpdateCheck", &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v31);
LABEL_36:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100E4F8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 72));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_100E4F914(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (*(void *)(a1 + 40))
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 0x40000000;
        void v7[2] = sub_100E4FA60;
        v7[3] = &unk_101A60B98;
        v7[4] = v3;
        int v8 = *(_DWORD *)(a1 + 56);
        char v9 = *(unsigned char *)(a1 + 60);
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        sub_10003E168(&v12, (void *)(v3 + 8));
        uint64_t v6 = *(NSObject **)(v3 + 24);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100E4FB78;
        block[3] = &unk_101A60BF0;
        block[5] = v12;
        char v11 = v13;
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        void block[4] = v7;
        dispatch_async(v6, block);
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E4FA60(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 40));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received a call back for state of %s", (uint8_t *)&v4, 0xCu);
  }
  CarrierBundleHandler::submitBundleStateMetric_sync(v2, *(unsigned __int8 *)(a1 + 44), *(unsigned int *)(a1 + 40));
}

uint64_t sub_100E4FB4C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E4FB68(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100E4FB78(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100E4FB88(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E4FBA4(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E4FBB4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100E502D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, NotifySubscription *a12, NotifySubscription *a13, NotifySubscription *a14, NotifySubscription *a15, NotifySubscription *a16, NotifySubscription *a17, NotifySubscription *a18, NotifySubscription *a19, NotifySubscription *a20,NotifySubscription *a21,ctu::OsLogLogger *a22,NotifySubscription *a23,dispatch_object_t object,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,dispatch_object_t a31,uint64_t a32,uint64_t a33,dispatch_object_t a34,dispatch_object_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (object) {
    dispatch_release(object);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  uint64_t v45 = *(std::__shared_weak_count **)(v41 + 920);
  if (v45) {
    sub_10004D2C8(v45);
  }
  int v46 = *(std::__shared_weak_count **)(v41 + 904);
  if (v46) {
    sub_10004D2C8(v46);
  }
  if (*(void *)(v41 + 888)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v41 + 888));
  }
  int v47 = *(std::__shared_weak_count **)(v41 + 872);
  if (v47) {
    sub_10004D2C8(v47);
  }
  int v48 = *(std::__shared_weak_count **)(v41 + 856);
  if (v48) {
    sub_10004D2C8(v48);
  }
  sub_10030AB98((void *)(v41 + 808));
  sub_100E521B4((void *)(v41 + 768));
  sub_100E52238((void *)(v41 + 728));
  sub_10030AB98((void *)(v41 + 688));
  sub_100E522BC((void *)(v41 + 648));
  sub_100E52340(v41 + 568);
  sub_10080AC40((void *)(v41 + 528));
  sub_100E52418((void *)(v41 + 488));
  sub_10030AB98((void *)(v41 + 448));
  sub_10030AB98(v44);
  int v49 = *(std::__shared_weak_count **)(v41 + 392);
  if (v49) {
    sub_10004D2C8(v49);
  }
  ctu::OsLogLogger::~OsLogLogger(v43);
  xpc_object_t v50 = *(std::__shared_weak_count **)(v41 + 328);
  if (v50) {
    sub_10004D2C8(v50);
  }
  if (*(unsigned char *)(v41 + 312)) {
    NotifySubscription::~NotifySubscription(a12);
  }
  NotifySubscription::~NotifySubscription(a18);
  NotifySubscription::~NotifySubscription(a19);
  NotifySubscription::~NotifySubscription(a20);
  NotifySubscription::~NotifySubscription(a13);
  NotifySubscription::~NotifySubscription(a21);
  NotifySubscription::~NotifySubscription(a23);
  NotifySubscription::~NotifySubscription(a14);
  NotifySubscription::~NotifySubscription(a15);
  NotifySubscription::~NotifySubscription(a16);
  NotifySubscription::~NotifySubscription(a17);
  ctu::OsLogLogger::~OsLogLogger(a22);
  sub_100087E88(v42);
  SystemObserverInterface::~SystemObserverInterface((SystemObserverInterface *)v41);
  operator delete();
}

void sub_100E50570()
{
  unsigned int v1 = *(NSObject **)(v0 - 208);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E504F4);
}

void sub_100E50584()
{
  unsigned int v1 = *(NSObject **)(v0 - 200);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E504FCLL);
}

void sub_100E50598()
{
  unsigned int v1 = *(NSObject **)(v0 - 192);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E50504);
}

void sub_100E505AC()
{
  unsigned int v1 = *(NSObject **)(v0 - 184);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E5050CLL);
}

void sub_100E505C0()
{
  unsigned int v1 = *(NSObject **)(v0 - 176);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E50514);
}

void sub_100E505D4()
{
  unsigned int v1 = *(NSObject **)(v0 - 168);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E5051CLL);
}

void sub_100E505E8()
{
  unsigned int v1 = *(NSObject **)(v0 - 160);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E50524);
}

void sub_100E505FC()
{
  unsigned int v1 = *(NSObject **)(v0 - 152);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E5052CLL);
}

void sub_100E50610()
{
  unsigned int v1 = *(NSObject **)(v0 - 144);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E50534);
}

void sub_100E50624()
{
  unsigned int v1 = *(NSObject **)(v0 - 136);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x100E5053CLL);
}

void sub_100E50638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v37 - 128));
  sub_100087E88(v36);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a36);
  JUMPOUT(0x100E5054CLL);
}

void sub_100E50660()
{
}

void sub_100E50668(uint64_t a1)
{
  *(void *)a1 = off_101A60C50;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 920);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 904);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 888);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 872);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 856);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_10030AB98((void *)(a1 + 808));
  sub_100E521B4((void *)(a1 + 768));
  sub_100E52238((void *)(a1 + 728));
  sub_10030AB98((void *)(a1 + 688));
  sub_100E522BC((void *)(a1 + 648));
  sub_100E52340(a1 + 568);
  sub_10080AC40((void *)(a1 + 528));
  sub_100E52418((void *)(a1 + 488));
  sub_10030AB98((void *)(a1 + 448));
  sub_10030AB98((void *)(a1 + 400));
  unsigned int v7 = *(std::__shared_weak_count **)(a1 + 392);
  if (v7) {
    sub_10004D2C8(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 336));
  int v8 = *(std::__shared_weak_count **)(a1 + 328);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (*(unsigned char *)(a1 + 312)) {
    NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 288));
  }
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 264));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 240));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 216));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 192));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 168));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 144));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 120));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 96));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 72));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 48));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SystemObserverInterface::~SystemObserverInterface((SystemObserverInterface *)a1);
}

void sub_100E507DC(uint64_t a1)
{
  sub_100E50668(a1);

  operator delete();
}

void sub_100E50814(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

uint64_t sub_100E5090C(uint64_t a1, int a2)
{
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Got first unlock notification: %d", (uint8_t *)v6, 8u);
  }
  *(unsigned char *)(a1 + 720) = a2;
  uint64_t result = *(void *)(a1 + 712);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a1 + 720);
  }
  return result;
}

uint64_t sub_100E509E8(uint64_t a1)
{
  uint64_t result = NotifySubscription::getState((NotifySubscription *)(a1 + 288));
  if (v3)
  {
    int v4 = result ? 2 : 1;
    if (*(_DWORD *)(a1 + 560) != v4)
    {
      *(_DWORD *)(a1 + 560) = v4;
      uint64_t result = *(void *)(a1 + 552);
      if (result)
      {
        uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 48);
        return v5();
      }
    }
  }
  return result;
}

void sub_100E50A7C(uint64_t a1, int a2, char a3)
{
  if (a3)
  {
    if (*(_DWORD *)(a1 + 800) != a2)
    {
      *(_DWORD *)(a1 + 800) = a2;
      uint64_t v3 = *(void *)(a1 + 792);
      if (v3)
      {
        uint64_t v4 = a1 + 800;
        uint64_t v5 = *(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48);
        uint64_t v6 = *(void *)(a1 + 792);
        v5(v6, v4);
      }
    }
  }
  else
  {
    unsigned int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to read thermal pressure level state", v8, 2u);
    }
  }
}

uint64_t sub_100E50B48(uint64_t a1)
{
  uint64_t result = sub_100BCD588(a1);
  if (*(unsigned __int8 *)(a1 + 840) != result)
  {
    *(unsigned char *)(a1 + 840) = result;
    uint64_t result = *(void *)(a1 + 832);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 48);
      return v3();
    }
  }
  return result;
}

uint64_t sub_100E50BC4(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 840) != a2)
  {
    *(unsigned char *)(result + 840) = a2;
    uint64_t v2 = *(void *)(result + 832);
    if (v2) {
      return (*(uint64_t (**)(void, uint64_t))(*(void *)v2 + 48))(*(void *)(result + 832), result + 840);
    }
  }
  return result;
}

BOOL sub_100E50C0C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100E56F64;
  v5[3] = &unk_101A61AB8;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  unsigned int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B2FC;
    uint64_t v10 = &unk_101A61AF8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A598;
    uint64_t v10 = &unk_101A61AD8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100E50D3C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100E56F74;
  v5[3] = &unk_101A61B18;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  unsigned int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B2FC;
    uint64_t v10 = &unk_101A61AF8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A598;
    uint64_t v10 = &unk_101A61AD8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100E50E6C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100E56F84;
  v5[3] = &unk_101A61B38;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  unsigned int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B2FC;
    uint64_t v10 = &unk_101A61AF8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A598;
    uint64_t v10 = &unk_101A61AD8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100E50F9C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100E56F9C;
  v5[3] = &unk_101A61B58;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  unsigned int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B2FC;
    uint64_t v10 = &unk_101A61AF8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A598;
    uint64_t v10 = &unk_101A61AD8;
    char v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100E510CC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = a1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100E56FB4;
  v7[3] = &unk_101A61B78;
  v7[4] = a1 + 8;
  void v7[5] = &v6;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)&long long v4 = 0x200000002;
    *((void *)&v4 + 1) = 0x200000002;
    *(_OWORD *)a2 = v4;
    *(_OWORD *)(a2 + 16) = v4;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_100E57030;
    uint64_t v12 = &unk_101A61BB8;
    uint64_t v13 = a2;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)&long long v5 = 0x200000002;
    *((void *)&v5 + 1) = 0x200000002;
    *(_OWORD *)a2 = v5;
    *(_OWORD *)(a2 + 16) = v5;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    char v11 = sub_100E56FD8;
    uint64_t v12 = &unk_101A61B98;
    uint64_t v13 = a2;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
}

uint64_t sub_100E511F8(uint64_t result, int a2, int a3)
{
  int v3 = *(unsigned __int8 *)(result + 480);
  if (v3 != a2 || a3 != 0)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      char v9 = "false";
      if (a3) {
        uint64_t v10 = "true";
      }
      else {
        uint64_t v10 = "false";
      }
      if (v3 != a2) {
        char v9 = "true";
      }
      int v11 = 136315394;
      uint64_t v12 = v10;
      __int16 v13 = 2080;
      uint64_t v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sending the springboard startup event forcefully (%s) or state has changed (%s)", (uint8_t *)&v11, 0x16u);
    }
    *(unsigned char *)(v7 + 480) = a2;
    uint64_t result = *(void *)(v7 + 472);
    if (result) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v7 + 480);
    }
  }
  return result;
}

void sub_100E5131C(unsigned __int8 *a1, int a2, int a3)
{
  int v4 = a1[520];
  if (v4 != a2 || a3 != 0)
  {
    uint64_t v12 = 1;
    uint64_t v13 = (uint64_t)(a1 + 488);
    a1[520] = a2;
    a1 = (unsigned __int8 *)sub_100E57088((uint64_t)&v12);
  }
  if (v4 != a2)
  {
    uint64_t v12 = (uint64_t)_NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_100E51BF0;
    char v15 = &unk_101A60CC0;
    char v16 = a2;
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)a1);
    uint64_t v7 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x160001u);
    if (v7)
    {
      uint64_t v8 = (wis::MetricContainer *)v7;
      char v9 = sub_10001C8F4(8);
      uint64_t v11 = *v9;
      uint64_t v10 = (std::__shared_weak_count *)v9[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v11) {
        operator new();
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      wis::MetricContainer::~MetricContainer(v8);
      operator delete();
    }
  }
}

void sub_100E514D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E51570(uint64_t a1)
{
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_create("SBSGetScreenLockStatus", v2);
  sub_10003E168(&v4, (void *)(a1 + 8));
  int v3 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  operator new();
}

void sub_100E51660(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E51678(uint64_t a1, int a2, int a3, int a4)
{
  char v5 = a2;
  if (*(unsigned __int8 *)(a1 + 521) == a2)
  {
    int v6 = *(unsigned __int8 *)(a1 + 523);
    if (v6 == a3 && a4 == 0) {
      return;
    }
    uint64_t v15 = 1;
    uint64_t v16 = a1 + 488;
    *(unsigned char *)(a1 + 521) = a2;
    *(unsigned char *)(a1 + 523) = a3;
    uint64_t v8 = (wis::MetricFactory *)sub_100E57088((uint64_t)&v15);
    if (v6 == a3) {
      return;
    }
  }
  else
  {
    uint64_t v15 = 1;
    uint64_t v16 = a1 + 488;
    *(unsigned char *)(a1 + 521) = a2;
    *(unsigned char *)(a1 + 523) = a3;
    uint64_t v8 = (wis::MetricFactory *)sub_100E57088((uint64_t)&v15);
  }
  uint64_t v15 = (uint64_t)_NSConcreteStackBlock;
  uint64_t v16 = 0x40000000;
  xpc_object_t v17 = sub_100E51BD8;
  xpc_object_t v18 = &unk_101A60CA0;
  char v19 = v5;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v8);
  uint64_t v10 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x160002u);
  if (v10)
  {
    uint64_t v11 = (wis::MetricContainer *)v10;
    uint64_t v12 = sub_10001C8F4(8);
    uint64_t v14 = *v12;
    uint64_t v13 = (std::__shared_weak_count *)v12[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v14) {
      operator new();
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
    wis::MetricContainer::~MetricContainer(v11);
    operator delete();
  }
}

void sub_100E5185C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E518FC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 441) != a2)
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315394;
      uint64_t v4 = asString();
      __int16 v5 = 2080;
      uint64_t v6 = asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Internet availability is changing from %s to %s", (uint8_t *)&v3, 0x16u);
    }
  }
}

void sub_100E519D0(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 440) != a2)
  {
    int v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315394;
      uint64_t v5 = asString();
      __int16 v6 = 2080;
      uint64_t v7 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFi Availability is changing from %s to %s", (uint8_t *)&v4, 0x16u);
    }
    sub_100BCD0B0(a1);
  }
}

uint64_t sub_100E51AAC(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100E57314;
  v5[3] = &unk_101A61BD8;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  __int16 v6 = v5;
  uint64_t v2 = a1 + 24;
  unsigned int v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100E57360;
    uint64_t v10 = &unk_101A61C18;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100E57324;
    uint64_t v10 = &unk_101A61BF8;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

uint64_t sub_100E51BD8(uint64_t result, uint64_t a2)
{
  char v2 = *(unsigned char *)(result + 32);
  *(_DWORD *)(a2 + 24) |= 2u;
  *(unsigned char *)(a2 + 16) = v2;
  return result;
}

uint64_t sub_100E51BF0(uint64_t result, uint64_t a2)
{
  char v2 = *(unsigned char *)(result + 32);
  *(_DWORD *)(a2 + 24) |= 2u;
  *(unsigned char *)(a2 + 16) = v2;
  return result;
}

void sub_100E51C08(uint64_t a1)
{
  int isSubscribed = NotifySubscription::isSubscribed((NotifySubscription *)(a1 + 72));
  int v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (isSubscribed)
  {
    if (!v4) {
      goto LABEL_10;
    }
    if (*(unsigned char *)(a1 + 520)) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    int v36 = 136315138;
    uint64_t v37 = v5;
    __int16 v6 = "#I Display on: %s";
    uint64_t v7 = v3;
    uint32_t v8 = 12;
  }
  else
  {
    if (!v4) {
      goto LABEL_10;
    }
    LOWORD(v36) = 0;
    __int16 v6 = "#N Could not register for screen blank notification";
    uint64_t v7 = v3;
    uint32_t v8 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v36, v8);
LABEL_10:
  int v9 = NotifySubscription::isSubscribed((NotifySubscription *)(a1 + 264));
  uint64_t v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (!v11) {
      goto LABEL_19;
    }
    if (*(unsigned char *)(a1 + 522)) {
      uint64_t v12 = "true";
    }
    else {
      uint64_t v12 = "false";
    }
    int v36 = 136315138;
    uint64_t v37 = v12;
    unsigned int v13 = "#I Coversheet active: %s";
    uint64_t v14 = v10;
    uint32_t v15 = 12;
  }
  else
  {
    if (!v11) {
      goto LABEL_19;
    }
    LOWORD(v36) = 0;
    unsigned int v13 = "#N Could not register for coversheet state notification";
    uint64_t v14 = v10;
    uint32_t v15 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v36, v15);
LABEL_19:
  int v16 = NotifySubscription::isSubscribed((NotifySubscription *)(a1 + 216));
  xpc_object_t v17 = *(NSObject **)(a1 + 40);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (!v18) {
      goto LABEL_28;
    }
    if (*(unsigned char *)(a1 + 521)) {
      char v19 = "true";
    }
    else {
      char v19 = "false";
    }
    int v36 = 136315138;
    uint64_t v37 = v19;
    int64_t v20 = "#I Display locked: %s";
    xpc_object_t v21 = v17;
    uint32_t v22 = 12;
  }
  else
  {
    if (!v18) {
      goto LABEL_28;
    }
    LOWORD(v36) = 0;
    int64_t v20 = "#N Could not register for lock status notification";
    xpc_object_t v21 = v17;
    uint32_t v22 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v36, v22);
LABEL_28:
  xpc_object_t v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 432)) {
      xpc_object_t v24 = "true";
    }
    else {
      xpc_object_t v24 = "false";
    }
    int v36 = 136315138;
    uint64_t v37 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Battery Saver Mode: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v25 = (void *)(a1 + 600);
    if (*(char *)(a1 + 623) < 0) {
      xpc_object_t v25 = (void *)*v25;
    }
    int v36 = 136315138;
    uint64_t v37 = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Wi-Fi MAC Address: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v26 = (void *)(a1 + 624);
    if (*(char *)(a1 + 647) < 0) {
      xpc_object_t v26 = (void *)*v26;
    }
    int v36 = 136315138;
    uint64_t v37 = v26;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Wi-Fi Network Name: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = asString();
    int v36 = 136315138;
    uint64_t v37 = (void *)v27;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Wi-Fi status: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = asString();
    int v36 = 136315138;
    uint64_t v37 = (void *)v28;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Internet status: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = *(_DWORD *)(a1 + 680);
    int v36 = 67109120;
    LODWORD(v37) = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Starts since boot: %u", (uint8_t *)&v36, 8u);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v30 = *(unsigned __int8 *)(a1 + 720);
    int v36 = 67109120;
    LODWORD(v37) = v30;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I First unlock since boot: %d", (uint8_t *)&v36, 8u);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = asString();
    int v36 = 136315138;
    uint64_t v37 = (void *)v31;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Ringer state: %s", (uint8_t *)&v36, 0xCu);
    xpc_object_t v23 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = *(_DWORD *)(a1 + 800);
    int v36 = 67109120;
    LODWORD(v37) = v32;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Thermal pressure level: %u", (uint8_t *)&v36, 8u);
  }
  if (sub_100BCD400((capabilities::ct *)(a1 + 320)))
  {
    xpc_object_t v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 840)) {
        uint64_t v34 = "true";
      }
      else {
        uint64_t v34 = "false";
      }
      int v36 = 136315138;
      uint64_t v37 = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I In Metro status: %s", (uint8_t *)&v36, 0xCu);
    }
  }
  sub_10015B27C(a1 + 336);
  xpc_object_t v35 = *(id **)(a1 + 864);
  if (v35) {
    [*v35 dumpState];
  }
}

void *sub_100E521B4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E52238(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E522BC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E52340(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  return sub_100E52394((void *)a1);
}

void *sub_100E52394(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E52418(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100E524A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E524D8(uint64_t a1)
{
}

uint64_t sub_100E524F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E52538(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E52564(ServiceManager::Service *this)
{
  *(void *)this = off_101A60DF8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E525C0(ServiceManager::Service *this)
{
  *(void *)this = off_101A60DF8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E52630@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SystemObserver");
}

unsigned char *sub_100E52640@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E52680(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100E50814(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100E50814(v4, 0);
}

uint64_t sub_100E52704()
{
  return 0;
}

uint64_t sub_100E5270C()
{
  return 1;
}

uint64_t sub_100E52714()
{
  return 0;
}

void sub_100E52720(uint64_t a1)
{
  unsigned int v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_100E527FC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

uint64_t *sub_100E52910(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  PowerObserver::shutdown(*(PowerObserver **)(v2 + 880));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 384));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 48));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 72));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 264));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 216));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 96));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 120));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 240));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 144));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 168));
  if (sub_100BCD400((capabilities::ct *)(v2 + 320))) {
    NotifySubscription::cancel((NotifySubscription *)(v2 + 192));
  }
  uint64_t v4 = *(void *)(v2 + 912);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  sub_100088C88(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100E52A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100E52A40(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v89 = a1;
  long long v90 = (dispatch_group_t *)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100BCD3AC((capabilities::ct *)(v2 + 320), (dispatch_object_t *)(v2 + 24), (uint64_t)buf);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 904);
  *(_OWORD *)(v2 + 896) = *(_OWORD *)buf;
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(NSObject **)(v2 + 24);
  uint64_t v93 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  sub_100F31A48((capabilities::ct *)(v2 + 320), buf);
  long long v6 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v7 = *(std::__shared_weak_count **)(v2 + 920);
  *(_OWORD *)(v2 + 912) = v6;
  if (v7)
  {
    sub_10004D2C8(v7);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v5) {
    dispatch_release(v5);
  }
  uint64_t v8 = *(void *)(v2 + 912);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  PowerObserver::bootstrap(*(PowerObserver **)(v2 + 880));
  Registry::createRestModuleOneTimeUseConnection(&v91, *(Registry **)(v2 + 320));
  uint64_t v9 = v2 + 384;
  ctu::RestModule::connect();
  if (v92) {
    sub_10004D2C8(v92);
  }
  *(void *)long long buf = off_101A60E78;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  sub_100318874(buf, (void *)(v2 + 400));
  sub_10030AB98(buf);
  uint64_t v10 = *(void *)(v2 + 424);
  if (v10) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v2 + 432);
  }
  sub_100058DB0(&__p, "/cc/props/wifi_status");
  BOOL v11 = (uint8_t *)operator new(0x28uLL);
  *(void *)BOOL v11 = off_101A60EF8;
  *((void *)v11 + 1) = v2 + 440;
  *((void *)v11 + 2) = v2;
  *((void *)v11 + 3) = sub_100E519D0;
  *((void *)v11 + 4) = 0;
  long long v99 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v96) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/internet_status");
  uint64_t v12 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v12 = off_101A60F78;
  *((void *)v12 + 1) = v2 + 441;
  *((void *)v12 + 2) = v2;
  *((void *)v12 + 3) = sub_100E518FC;
  *((void *)v12 + 4) = 0;
  long long v99 = v12;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v96) < 0) {
    operator delete(__p);
  }
  uint64_t v13 = v2 + 568;
  *(void *)long long buf = off_101A60FF8;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  if (buf != (uint8_t *)(v2 + 568))
  {
    uint64_t v14 = *(uint8_t **)(v2 + 592);
    if (v14 == (uint8_t *)v13)
    {
      long long v95 = (std::__shared_weak_count *)(v2 + 384);
      uint64_t v96 = 0;
      long long __p = off_101A60FF8;
      long long v99 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 24))(v2 + 568, buf);
      (*(void (**)(void))(**(void **)(v2 + 592) + 32))(*(void *)(v2 + 592));
      *(void *)(v2 + 592) = 0;
      long long v99 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 568);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 568) = off_101A60FF8;
      *(void *)(v2 + 576) = v9;
      long long v99 = v14;
    }
    *(void *)(v2 + 592) = v13;
  }
  sub_100E52394(buf);
  uint64_t v15 = *(void *)(v2 + 592);
  if (v15) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, v2 + 600);
  }
  *(void *)long long buf = off_101A61088;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  sub_100318874(buf, (void *)(v2 + 448));
  sub_10030AB98(buf);
  uint64_t v16 = *(void *)(v2 + 472);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 48))(v16, v2 + 480);
  }
  uint64_t v17 = v2 + 488;
  *(void *)long long buf = off_101A61108;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  if (buf != (uint8_t *)(v2 + 488))
  {
    BOOL v18 = *(uint8_t **)(v2 + 512);
    if (v18 == (uint8_t *)v17)
    {
      long long v95 = (std::__shared_weak_count *)(v2 + 384);
      uint64_t v96 = 0;
      long long __p = off_101A61108;
      long long v99 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v17 + 24))(v2 + 488, buf);
      (*(void (**)(void))(**(void **)(v2 + 512) + 32))(*(void *)(v2 + 512));
      *(void *)(v2 + 512) = 0;
      long long v99 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 488);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 488) = off_101A61108;
      *(void *)(v2 + 496) = v9;
      long long v99 = v18;
    }
    *(void *)(v2 + 512) = v17;
  }
  sub_100E52418(buf);
  uint64_t v19 = *(void *)(v2 + 512);
  if (v19) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, v2 + 520);
  }
  if (*(unsigned char *)(v2 + 312))
  {
    *(void *)long long buf = off_101A61198;
    *(void *)&uint8_t buf[8] = v2 + 384;
    long long v99 = buf;
    sub_10080BCD4(buf, (void *)(v2 + 528));
    sub_10080AC40(buf);
    uint64_t v20 = *(void *)(v2 + 552);
    if (v20) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, v2 + 560);
    }
  }
  uint64_t v21 = v2 + 648;
  *(void *)long long buf = off_101A61218;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  if (buf != (uint8_t *)(v2 + 648))
  {
    uint32_t v22 = *(uint8_t **)(v2 + 672);
    if (v22 == (uint8_t *)v21)
    {
      long long v95 = (std::__shared_weak_count *)(v2 + 384);
      uint64_t v96 = 0;
      long long __p = off_101A61218;
      long long v99 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v21 + 24))(v2 + 648, buf);
      (*(void (**)(void))(**(void **)(v2 + 672) + 32))(*(void *)(v2 + 672));
      *(void *)(v2 + 672) = 0;
      long long v99 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 648);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 648) = off_101A61218;
      *(void *)(v2 + 656) = v9;
      long long v99 = v22;
    }
    *(void *)(v2 + 672) = v21;
  }
  sub_100E522BC(buf);
  uint64_t v23 = *(void *)(v2 + 672);
  if (v23) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 48))(v23, v2 + 680);
  }
  *(void *)long long buf = off_101A612A8;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  sub_100318874(buf, (void *)(v2 + 688));
  sub_10030AB98(buf);
  xpc_object_t v24 = *(capabilities::ct **)(v2 + 712);
  if (v24) {
    xpc_object_t v24 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v24 + 48))(v24, v2 + 720);
  }
  if (capabilities::ct::supportsVoiceCall(v24))
  {
    uint64_t v25 = v2 + 728;
    *(void *)long long buf = off_101A61328;
    *(void *)&uint8_t buf[8] = v2 + 384;
    long long v99 = buf;
    if (buf != (uint8_t *)(v2 + 728))
    {
      xpc_object_t v26 = *(uint8_t **)(v2 + 752);
      if (v26 == (uint8_t *)v25)
      {
        long long v95 = (std::__shared_weak_count *)(v2 + 384);
        uint64_t v96 = 0;
        long long __p = off_101A61328;
        long long v99 = 0;
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v25 + 24))(v2 + 728, buf);
        (*(void (**)(void))(**(void **)(v2 + 752) + 32))(*(void *)(v2 + 752));
        *(void *)(v2 + 752) = 0;
        long long v99 = buf;
        (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 728);
        (*((void (**)(void **))__p + 4))(&__p);
      }
      else
      {
        *(void *)(v2 + 728) = off_101A61328;
        *(void *)(v2 + 736) = v9;
        long long v99 = v26;
      }
      *(void *)(v2 + 752) = v25;
    }
    sub_100E52238(buf);
    uint64_t v27 = *(void *)(v2 + 752);
    if (v27) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 48))(v27, v2 + 760);
    }
  }
  uint64_t v28 = v2 + 768;
  *(void *)long long buf = off_101A613B8;
  *(void *)&uint8_t buf[8] = v2 + 384;
  long long v99 = buf;
  if (buf != (uint8_t *)(v2 + 768))
  {
    int v29 = *(uint8_t **)(v2 + 792);
    if (v29 == (uint8_t *)v28)
    {
      long long v95 = (std::__shared_weak_count *)(v2 + 384);
      uint64_t v96 = 0;
      long long __p = off_101A613B8;
      long long v99 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v28 + 24))(v2 + 768, buf);
      (*(void (**)(void))(**(void **)(v2 + 792) + 32))(*(void *)(v2 + 792));
      *(void *)(v2 + 792) = 0;
      long long v99 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 768);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 768) = off_101A613B8;
      *(void *)(v2 + 776) = v9;
      long long v99 = v29;
    }
    *(void *)(v2 + 792) = v28;
  }
  sub_100E521B4(buf);
  uint64_t v30 = *(void *)(v2 + 792);
  if (v30) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 48))(v30, v2 + 800);
  }
  if (sub_100BCD400((capabilities::ct *)(v2 + 320)))
  {
    *(void *)long long buf = off_101A61448;
    *(void *)&uint8_t buf[8] = v2 + 384;
    long long v99 = buf;
    sub_100318874(buf, (void *)(v2 + 808));
    sub_10030AB98(buf);
    uint64_t v31 = *(void *)(v2 + 832);
    if (v31) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 48))(v31, v2 + 840);
    }
  }
  objc_msgSend(**(id **)(v2 + 848), "bootstrap", v89, v90);
  int v32 = *(id **)(v2 + 864);
  if (v32)
  {
    xpc_object_t v33 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Setting up edu mode notifier", buf, 2u);
      int v32 = *(id **)(v2 + 864);
    }
    [*v32 setup];
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v34 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v34 = off_101A614C8;
  *((void *)v34 + 1) = v2;
  *((void *)v34 + 2) = sub_100E51C08;
  *((void *)v34 + 3) = 0;
  long long v99 = v34;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v96) < 0) {
    operator delete(__p);
  }
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v36 = *(void *)buf;
  xpc_object_t v35 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v35);
    atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 48));
  uint64_t v37 = (std::__shared_weak_count *)operator new(0x30uLL);
  v37->__shared_weak_owners_ = 0;
  v37->__shared_owners_ = 0;
  v37[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v37->__vftable = (std::__shared_weak_count_vtbl *)off_101A61678;
  v37[1].__shared_owners_ = v36;
  v37[1].__shared_weak_owners_ = (uint64_t)v35;
  int v38 = *(const char **)(v2 + 48);
  char v39 = *(NSObject **)(v2 + 56);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E562D4;
  long long v99 = (uint8_t *)&unk_101A61638;
  long long v100 = v37 + 1;
  long long v101 = v37;
  atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v38, (int *)(v2 + 64), v39, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v37);
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v41 = *(void *)buf;
  uint64_t v40 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v40);
    atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 72));
  uint64_t v42 = (std::__shared_weak_count *)operator new(0x30uLL);
  v42->__shared_weak_owners_ = 0;
  v42->__shared_owners_ = 0;
  v42->__vftable = (std::__shared_weak_count_vtbl *)off_101A616F8;
  v42[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v42[1].__shared_owners_ = v41;
  v42[1].__shared_weak_owners_ = (uint64_t)v40;
  int v43 = *(const char **)(v2 + 72);
  int v44 = *(NSObject **)(v2 + 80);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E5642C;
  long long v99 = (uint8_t *)&unk_101A616B8;
  long long v100 = v42 + 1;
  long long v101 = v42;
  atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v43, (int *)(v2 + 88), v44, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v42);
  if (v40) {
    std::__shared_weak_count::__release_weak(v40);
  }
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v46 = *(void *)buf;
  uint64_t v45 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v45);
    atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 264));
  int v47 = (std::__shared_weak_count *)operator new(0x30uLL);
  v47->__shared_weak_owners_ = 0;
  v47->__shared_owners_ = 0;
  v47->__vftable = (std::__shared_weak_count_vtbl *)off_101A61778;
  v47[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v47[1].__shared_owners_ = v46;
  v47[1].__shared_weak_owners_ = (uint64_t)v45;
  int v48 = *(const char **)(v2 + 264);
  int v49 = *(NSObject **)(v2 + 272);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E56584;
  long long v99 = (uint8_t *)&unk_101A61738;
  long long v100 = v47 + 1;
  long long v101 = v47;
  atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v48, (int *)(v2 + 280), v49, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v47);
  if (v45) {
    std::__shared_weak_count::__release_weak(v45);
  }
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v51 = *(void *)buf;
  xpc_object_t v50 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v50);
    atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 216));
  BOOL v52 = (std::__shared_weak_count *)operator new(0x30uLL);
  v52->__shared_weak_owners_ = 0;
  v52->__shared_owners_ = 0;
  v52->__vftable = (std::__shared_weak_count_vtbl *)off_101A61878;
  v52[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v52[1].__shared_owners_ = v51;
  v52[1].__shared_weak_owners_ = (uint64_t)v50;
  int v53 = *(const char **)(v2 + 216);
  int64_t v54 = *(NSObject **)(v2 + 224);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E56844;
  long long v99 = (uint8_t *)&unk_101A61838;
  long long v100 = v52 + 1;
  long long v101 = v52;
  atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v53, (int *)(v2 + 232), v54, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v52);
  if (v50) {
    std::__shared_weak_count::__release_weak(v50);
  }
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v56 = *(void *)buf;
  char v55 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v55);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 96));
  xpc_object_t v57 = (std::__shared_weak_count *)operator new(0x30uLL);
  v57->__shared_weak_owners_ = 0;
  v57->__shared_owners_ = 0;
  v57->__vftable = (std::__shared_weak_count_vtbl *)off_101A617F8;
  v57[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v57[1].__shared_owners_ = v56;
  v57[1].__shared_weak_owners_ = (uint64_t)v55;
  xpc_object_t v58 = *(const char **)(v2 + 96);
  xpc_object_t v59 = *(NSObject **)(v2 + 104);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E566C4;
  long long v99 = (uint8_t *)&unk_101A617B8;
  long long v100 = v57 + 1;
  long long v101 = v57;
  atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v58, (int *)(v2 + 112), v59, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v57);
  sub_10003E168(buf, (void *)(v2 + 8));
  xpc_object_t v61 = *(std::__shared_weak_count_vtbl **)buf;
  xpc_object_t v60 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v60);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 120));
  xpc_object_t v62 = (std::__shared_weak_count *)operator new(0x28uLL);
  v62->__shared_weak_owners_ = 0;
  v62->__shared_owners_ = 0;
  v62->__vftable = (std::__shared_weak_count_vtbl *)off_101A61578;
  v62[1].__vftable = v61;
  v62[1].__shared_owners_ = (uint64_t)v60;
  std::string v63 = *(const char **)(v2 + 120);
  xpc_object_t v64 = *(NSObject **)(v2 + 128);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E55F10;
  long long v99 = (uint8_t *)&unk_101A61538;
  long long v100 = v62 + 1;
  long long v101 = v62;
  atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v63, (int *)(v2 + 136), v64, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v62);
  sub_10003E168(buf, (void *)(v2 + 8));
  xpc_object_t v66 = *(std::__shared_weak_count_vtbl **)buf;
  xpc_object_t v65 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v65);
    atomic_fetch_add_explicit(&v65->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 240));
  xpc_object_t v67 = (std::__shared_weak_count *)operator new(0x28uLL);
  v67->__shared_weak_owners_ = 0;
  v67->__shared_owners_ = 0;
  v67->__vftable = (std::__shared_weak_count_vtbl *)off_101A615F8;
  v67[1].__vftable = v66;
  v67[1].__shared_owners_ = (uint64_t)v65;
  xpc_object_t v68 = *(const char **)(v2 + 240);
  xpc_object_t v69 = *(NSObject **)(v2 + 248);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E5619C;
  long long v99 = (uint8_t *)&unk_101A615B8;
  long long v100 = v67 + 1;
  long long v101 = v67;
  atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v68, (int *)(v2 + 256), v69, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v67);
  if (v65) {
    std::__shared_weak_count::__release_weak(v65);
  }
  if (*(unsigned char *)(v2 + 312))
  {
    sub_10003E168(&__p, (void *)(v2 + 8));
    xpc_object_t v71 = (std::__shared_weak_count_vtbl *)__p;
    uint64_t v70 = v95;
    if (v95)
    {
      atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v70->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v70);
      atomic_fetch_add_explicit(&v70->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    NotifySubscription::cancel((NotifySubscription *)(v2 + 288));
    xpc_object_t v72 = (std::__shared_weak_count *)operator new(0x38uLL);
    v72->__shared_owners_ = 0;
    v72->__shared_weak_owners_ = 0;
    v72->__vftable = (std::__shared_weak_count_vtbl *)off_101A618F8;
    v72[1].__vftable = v71;
    v72[1].__shared_owners_ = (uint64_t)v70;
    v72[1].__shared_weak_owners_ = (uint64_t)sub_100E509E8;
    v72[2].__vftable = 0;
    xpc_object_t v73 = *(const char **)(v2 + 288);
    xpc_object_t v74 = *(NSObject **)(v2 + 296);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 1174405120;
    long long v98 = sub_100E569B0;
    long long v99 = (uint8_t *)&unk_101A618B8;
    long long v100 = v72 + 1;
    long long v101 = v72;
    atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v73, (int *)(v2 + 304), v74, buf);
    if (v101) {
      sub_10004D2C8(v101);
    }
    sub_10004D2C8(v72);
    if (v70) {
      std::__shared_weak_count::__release_weak(v70);
    }
    if (v95) {
      sub_10004D2C8(v95);
    }
    sub_100E509E8(v2);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 144));
  xpc_object_t v75 = (std::__shared_weak_count *)operator new(0x20uLL);
  v75->__shared_weak_owners_ = 0;
  v75->__shared_owners_ = 0;
  v75->__vftable = (std::__shared_weak_count_vtbl *)off_101A61978;
  v75[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  xpc_object_t v76 = *(const char **)(v2 + 144);
  xpc_object_t v77 = *(NSObject **)(v2 + 152);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E56B18;
  long long v99 = (uint8_t *)&unk_101A61938;
  long long v100 = v75 + 1;
  long long v101 = v75;
  atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v76, (int *)(v2 + 160), v77, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v75);
  sub_10003E168(buf, (void *)(v2 + 8));
  uint64_t v79 = *(void *)buf;
  xpc_object_t v78 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v78);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 168));
  xpc_object_t v80 = (std::__shared_weak_count *)operator new(0x30uLL);
  v80->__shared_weak_owners_ = 0;
  v80->__shared_owners_ = 0;
  v80->__vftable = (std::__shared_weak_count_vtbl *)off_101A619F8;
  v80[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v80[1].__shared_owners_ = v79;
  v80[1].__shared_weak_owners_ = (uint64_t)v78;
  xpc_object_t v81 = *(const char **)(v2 + 168);
  __int16 v82 = *(NSObject **)(v2 + 176);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  long long v98 = sub_100E56CD4;
  long long v99 = (uint8_t *)&unk_101A619B8;
  long long v100 = v80 + 1;
  long long v101 = v80;
  atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v81, (int *)(v2 + 184), v82, buf);
  if (v101) {
    sub_10004D2C8(v101);
  }
  sub_10004D2C8(v80);
  if (sub_100BCD400((capabilities::ct *)(v2 + 320)))
  {
    sub_10003E168(buf, (void *)(v2 + 8));
    uint64_t v84 = *(void *)buf;
    int v83 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v83);
    }
    NotifySubscription::cancel((NotifySubscription *)(v2 + 192));
    xpc_object_t v85 = (std::__shared_weak_count *)operator new(0x30uLL);
    v85->__shared_weak_owners_ = 0;
    v85->__shared_owners_ = 0;
    v85->__vftable = (std::__shared_weak_count_vtbl *)off_101A61A78;
    v85[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
    v85[1].__shared_owners_ = v84;
    v85[1].__shared_weak_owners_ = (uint64_t)v83;
    xpc_object_t v86 = *(const char **)(v2 + 192);
    xpc_object_t v87 = *(NSObject **)(v2 + 200);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 1174405120;
    long long v98 = sub_100E56E28;
    long long v99 = (uint8_t *)&unk_101A61A38;
    long long v100 = v85 + 1;
    long long v101 = v85;
    atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v86, (int *)(v2 + 208), v87, buf);
    if (v101) {
      sub_10004D2C8(v101);
    }
    sub_10004D2C8(v85);
  }
  sub_10062AF08(&v90);
  return sub_100046B58((uint64_t *)&v89);
}

void sub_100E54158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E542FC()
{
}

void *sub_100E54310(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A60E78;
  result[1] = v3;
  return result;
}

uint64_t sub_100E54358(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A60E78;
  a2[1] = v2;
  return result;
}

void sub_100E54384(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/battery_saver_mode");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E54434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5447C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E544BC()
{
}

void sub_100E544CC()
{
}

__n128 sub_100E544E0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A60EF8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E54534(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A60EF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E5456C(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100E54664(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E546A4()
{
}

void sub_100E546B4()
{
}

__n128 sub_100E546C8(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A60F78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E5471C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A60F78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E54754(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100E5484C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5488C()
{
}

void sub_100E5489C()
{
}

void *sub_100E548B0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A60FF8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E548F8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A60FF8;
  a2[1] = v2;
  return result;
}

void sub_100E54924()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/wifi_settings");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100E549C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E54A0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E54A4C()
{
}

void sub_100E54A5C()
{
}

void *sub_100E54A70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61088;
  result[1] = v3;
  return result;
}

uint64_t sub_100E54AB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61088;
  a2[1] = v2;
  return result;
}

void sub_100E54AE4(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/springboard_finished_startup");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E54B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E54BDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E54C1C()
{
}

void sub_100E54C2C()
{
}

void *sub_100E54C40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61108;
  result[1] = v3;
  return result;
}

uint64_t sub_100E54C88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61108;
  a2[1] = v2;
  return result;
}

void sub_100E54CB4(uint64_t a1, const DisplayStatus *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2);
  sub_100058DB0(&__p, "/cc/props/display_status");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E54D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E54D9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E54DDC()
{
}

void sub_100E54DEC()
{
}

void *sub_100E54E00(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61198;
  result[1] = v3;
  return result;
}

uint64_t sub_100E54E48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61198;
  a2[1] = v2;
  return result;
}

void sub_100E54E74(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/carplay_connected");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100E54F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E54F6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E54FAC()
{
}

void sub_100E54FBC()
{
}

void *sub_100E54FD0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61218;
  result[1] = v3;
  return result;
}

uint64_t sub_100E55018(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61218;
  a2[1] = v2;
  return result;
}

void sub_100E55044(uint64_t a1, unsigned int *a2)
{
  xpc_object_t v2 = xpc_int64_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/commcenter_starts_since_boot");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E550F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5513C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5517C()
{
}

void sub_100E5518C()
{
}

void *sub_100E551A0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A612A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E551E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A612A8;
  a2[1] = v2;
  return result;
}

void sub_100E55214(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/first_unlock_since_boot");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E552C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5530C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5534C()
{
}

void sub_100E5535C()
{
}

void *sub_100E55370(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61328;
  result[1] = v3;
  return result;
}

uint64_t sub_100E553B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61328;
  a2[1] = v2;
  return result;
}

void sub_100E553E4(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/ringer_state");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100E55498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E554DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5551C()
{
}

void sub_100E5552C()
{
}

void *sub_100E55540(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A613B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E55588(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A613B8;
  a2[1] = v2;
  return result;
}

void sub_100E555B4(uint64_t a1, unsigned int *a2)
{
  xpc_object_t v2 = xpc_int64_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/thermal_pressure_level");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E55664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E556AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E556EC()
{
}

void sub_100E556FC()
{
}

void *sub_100E55710(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A61448;
  result[1] = v3;
  return result;
}

uint64_t sub_100E55758(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A61448;
  a2[1] = v2;
  return result;
}

void sub_100E55784(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/in_metro_status");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100E55834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5587C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E558BC()
{
}

void sub_100E558CC()
{
}

__n128 sub_100E558E0(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A614C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100E55934(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A614C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E5596C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100E559B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E559F4()
{
}

void sub_100E55A00(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", (uint8_t *)&buf, 2u);
  }
  PowerObserver::start(*(PowerObserver **)(v1 + 880));
  sub_100BCD518(v1);
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Polling for the states of screen, locks, reachability status, ringer state, battery saver mode, thermal pressure level & in metro status", (uint8_t *)&buf, 2u);
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 48)))
  {
    uint64_t State = NotifySubscription::getState((NotifySubscription *)(v1 + 48));
    if (v5) {
      BOOL v6 = State == 0;
    }
    else {
      BOOL v6 = 1;
    }
    int v7 = !v6;
    sub_100E511F8(v1, v7, 1);
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 72)))
  {
    uint64_t v8 = NotifySubscription::getState((NotifySubscription *)(v1 + 72));
    if (v9) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    int v11 = v10;
    sub_100E5131C((unsigned __int8 *)v1, v11, 1);
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 264))) {
    sub_100E51570(v1);
  }
  if (&_MKBGetDeviceLockState)
  {
    unsigned int v12 = MKBGetDeviceLockState();
    int v13 = v12 != 3 && v12 != 0;
    sub_100E51678(v1, v13, v12 < 3, 1);
  }
  if (&_MKBDeviceUnlockedSinceBoot)
  {
    BOOL v14 = MKBDeviceUnlockedSinceBoot() != 0;
    sub_100E5090C(v1, v14);
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 96)))
  {
    uint64_t v15 = NotifySubscription::getState((NotifySubscription *)(v1 + 96));
    if (v16)
    {
      *(unsigned char *)(v1 + 432) = v15 != 0;
      uint64_t v17 = *(void *)(v1 + 424);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, v1 + 432);
      }
    }
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 144)))
  {
    uint64_t v18 = NotifySubscription::getState((NotifySubscription *)(v1 + 144));
    if (v19)
    {
      *(_DWORD *)(v1 + 760) = v18 != 0;
      uint64_t v20 = *(void *)(v1 + 752);
      if (v20) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, v1 + 760);
      }
    }
  }
  if (NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 168)))
  {
    int v21 = NotifySubscription::getState((NotifySubscription *)(v1 + 168));
    sub_100E50A7C(v1, v21, v22);
  }
  if (sub_100BCD400((capabilities::ct *)(v1 + 320))
    && NotifySubscription::isSubscribed((NotifySubscription *)(v1 + 192)))
  {
    sub_100E50B48(v1);
  }
  uint64_t v23 = sub_100365D74();
  int v37 = 0;
  uint64_t v24 = sub_100BAC798();
  uint64_t v35 = 0;
  uint64_t v36 = v24;
  sub_100058DB0(&buf, "BootTime");
  BOOL v25 = sub_100225FC8(v23, (void **)&buf.__r_.__value_.__l.__data_, &v35);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v24 == v35 && v25)
  {
    sub_100058DB0(&buf, "CommCenterStartsThisBoot");
    sub_10072A8A0(v23, (void **)&buf.__r_.__value_.__l.__data_, &v37);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    int v27 = v37 + 1;
  }
  else
  {
    int v27 = 1;
  }
  uint64_t v28 = (int *)(v1 + 680);
  if (*(_DWORD *)(v1 + 680) != v27)
  {
    *(_DWORD *)(v1 + 680) = v27;
    uint64_t v29 = *(void *)(v1 + 672);
    if (v29)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v29 + 48))(v29, v1 + 680);
      int v27 = *v28;
    }
  }
  if (v27 == 1)
  {
    uint64_t v30 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&buf, "BootTime");
    sub_100226428(v30, &buf, &v36);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v31 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&buf, "CommCenterStartsThisBoot");
  sub_1006560E0(v31, &buf, (_DWORD *)(v1 + 680));
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  int v32 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    int v33 = *v28;
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I CommCenter starts since device boot: %u", (uint8_t *)&buf, 8u);
  }
  uint64_t v34 = *(void *)(v1 + 912);
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 24))(v34);
  }
  operator delete();
}

void sub_100E55EC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100E55F10(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*v1)
      {
        char v5 = *(NSObject **)(*v1 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Got significant time change notification", buf, 2u);
        }
        bzero(buf, 0x401uLL);
        ssize_t v6 = readlink("/var/db/timezone/localtime", (char *)buf, 0x400uLL);
        if (v6 >= 1)
        {
          buf[v6] = 0;
          setenv("TZ", (const char *)buf, 1);
          tzset();
        }
        CFTimeZoneResetSystem();
        sub_100058DB0(&__p, "/cc/events/significant_time_change");
        xpc_object_t object = xpc_null_create();
        ctu::RestModule::sendEvent();
        xpc_release(object);
        if (v9 < 0) {
          operator delete(__p);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100E56098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E560E8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56104(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56114(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61578;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56134(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61578;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56188(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E5619C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *v1;
      if (v5)
      {
        BOOL v6 = MKBDeviceUnlockedSinceBoot() != 0;
        sub_100E5090C(v5, v6);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100E5620C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56220(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E5623C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E5624C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A615F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E5626C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A615F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E562C0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E562D4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        uint64_t State = NotifySubscription::getState((NotifySubscription *)(v3 + 48));
        if (v7) {
          BOOL v8 = State == 0;
        }
        else {
          BOOL v8 = 1;
        }
        int v9 = !v8;
        sub_100E511F8(v3, v9, 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E56360(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56378(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56394(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E563A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E563C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56418(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E5642C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(unsigned __int8 **)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        uint64_t State = NotifySubscription::getState((NotifySubscription *)(v3 + 72));
        if (v7) {
          BOOL v8 = State == 0;
        }
        else {
          BOOL v8 = 1;
        }
        int v9 = v8;
        sub_100E5131C(v3, v9, 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E564B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E564D0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E564EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E564FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A616F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E5651C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A616F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56570(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E56584(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (v1[1]) {
        sub_100E51570(v3);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100E565FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56610(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E5662C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E5663C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E5665C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61778;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E566B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E566C4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        uint64_t State = NotifySubscription::getState((NotifySubscription *)(v3 + 96));
        if (v7)
        {
          *(unsigned char *)(v3 + 432) = State != 0;
          uint64_t v8 = *(void *)(v3 + 424);
          if (v8) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v3 + 432);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E5677C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56790(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E567AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E567BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A617F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E567DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A617F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56830(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E56844(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1]) {
        BOOL v6 = &_MKBGetDeviceLockState == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (!v6)
      {
        unsigned int v7 = MKBGetDeviceLockState();
        int v8 = v7 != 3 && v7 != 0;
        sub_100E51678(v3, v8, v7 < 3, 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E568E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E568FC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56918(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56928(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56948(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61878;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E5699C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E569B0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*v1)
      {
        uint64_t v5 = (void (*)(void *))v1[2];
        uint64_t v6 = v1[3];
        unsigned int v7 = (void *)(*v1 + (v6 >> 1));
        if (v6) {
          uint64_t v5 = *(void (**)(void *))(*v7 + v5);
        }
        v5(v7);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100E56A50(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56A64(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56A80(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56A90(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A618F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56AB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A618F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56B04(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100E56B18(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 32);
  uint64_t result = NotifySubscription::getState((NotifySubscription *)(v1 + 144));
  if (v3)
  {
    BOOL v4 = result != 0;
    uint64_t v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315394;
      uint64_t v7 = asString();
      __int16 v8 = 2080;
      uint64_t v9 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Ringer switch state changed from: %s -> %s", (uint8_t *)&v6, 0x16u);
    }
    *(_DWORD *)(v1 + 760) = v4;
    uint64_t result = *(void *)(v1 + 752);
    if (result) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v1 + 760);
    }
  }
  return result;
}

uint64_t sub_100E56C2C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56C48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56C58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61978;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56C78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61978;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56CD4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        int State = NotifySubscription::getState((NotifySubscription *)(v3 + 168));
        sub_100E50A7C(v3, State, v7);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E56D60(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56D74(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56D90(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56DA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A619F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56DC0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A619F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56E14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E56E28(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1]) {
        sub_100E50B48(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E56E9C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E56EB0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E56ECC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E56EDC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A61A78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E56EFC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A61A78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E56F50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100E56F64(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 521);
}

uint64_t sub_100E56F74(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 523);
}

BOOL sub_100E56F84(uint64_t a1)
{
  return *(unsigned char *)(**(void **)(a1 + 40) + 440) == 1;
}

BOOL sub_100E56F9C(uint64_t a1)
{
  return *(unsigned char *)(**(void **)(a1 + 40) + 441) == 1;
}

__n128 sub_100E56FB4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = **(void **)(a1 + 40);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(v2 + 376);
  __n128 result = *(__n128 *)(v2 + 344);
  long long v4 = *(_OWORD *)(v2 + 360);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

__n128 sub_100E56FD8(uint64_t a1)
{
  (*(void (**)(_OWORD *__return_ptr))(**(void **)(a1 + 40) + 16))(v5);
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = (__n128)v5[0];
  long long v4 = v5[1];
  *(unsigned char *)(v2 + 32) = v6;
  *(__n128 *)uint64_t v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  return result;
}

__n128 sub_100E57030(uint64_t a1)
{
  (*(void (**)(_OWORD *__return_ptr))(**(void **)(a1 + 40) + 16))(v5);
  uint64_t v2 = *(void *)(a1 + 32);
  __n128 result = (__n128)v5[0];
  long long v4 = v5[1];
  *(unsigned char *)(v2 + 32) = v6;
  *(__n128 *)uint64_t v2 = result;
  *(_OWORD *)(v2 + 16) = v4;
  return result;
}

uint64_t sub_100E57088(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t *sub_100E570EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100E57140(void *a1)
{
  char v6 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[1])
      {
        SBSGetScreenLockStatus();
        v7[0] = 0;
        v7[1] = 0;
        sub_10003E168(v7, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_100E570EC((uint64_t *)&v6);
}

void sub_100E5726C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10004D2C8(v2);
  sub_100E570EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100E5728C(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  if (v2 != *(unsigned __int8 *)(v1 + 522) || *((unsigned char *)*a1 + 9))
  {
    v4[0] = 1;
    v4[1] = v1 + 488;
    *(unsigned char *)(v1 + 522) = v2 != 0;
    sub_100E57088((uint64_t)v4);
  }
  operator delete();
}

uint64_t sub_100E57314(uint64_t a1)
{
  return *(unsigned int *)(**(void **)(a1 + 40) + 680);
}

uint64_t sub_100E57324(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100E57360(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void *sub_100E5739C(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  BOOL v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  unsigned int v12 = "DATA.Connection.Em.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    unsigned int v12 = "DATA.Connection.Em.2";
  }
  BOOL v14 = "Em.X";
  if (v13 == 2) {
    BOOL v14 = "Em.2";
  }
  if (v13 == 1) {
    uint64_t v15 = "DATA.Connection.Em.1";
  }
  else {
    uint64_t v15 = v12;
  }
  if (v13 == 1) {
    char v16 = "Em.1";
  }
  else {
    char v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_101A626A8, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_101A61C70;
  a1[8] = off_101A621C0;
  a1[9] = off_101A62450;
  a1[10] = off_101A62640;
  return a1;
}

void sub_100E57528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100E57554(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A626A8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100E57584(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_101A626A8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100E575B8(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_101A626A8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100E575EC(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_101A626A8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100E57620(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A626A8);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100E57664(uint64_t a1)
{
}

void sub_100E5766C(uint64_t a1)
{
}

void sub_100E57674(uint64_t a1)
{
}

uint64_t sub_100E5767C()
{
  return 0x101000000;
}

uint64_t sub_100E5768C()
{
  return 0x101000000;
}

uint64_t sub_100E5769C(uint64_t a1, unsigned int a2)
{
  uint64_t result = 1;
  if (a2 <= 0x12 && ((1 << a2) & 0x40092) != 0)
  {
    long long v4 = *(NSObject **)(a1 + 56);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v5)
    {
      int v6 = 136315394;
      char v7 = "deactivateWithReasonAllowed";
      __int16 v8 = 2080;
      uint64_t v9 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Do not deactivate for %s", (uint8_t *)&v6, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100E57784(uint64_t a1, unsigned int a2)
{
  return sub_100E5769C(a1 - 72, a2);
}

uint64_t sub_100E5778C()
{
  return 1;
}

uint64_t sub_100E57794()
{
  return 1;
}

uint64_t sub_100E5779C()
{
  return 2;
}

uint64_t sub_100E577A4()
{
  return 2;
}

uint64_t sub_100E577AC()
{
  return 0;
}

uint64_t sub_100E577B4()
{
  return 0;
}

uint64_t sub_100E577BC()
{
  return 100;
}

uint64_t sub_100E577C4()
{
  return 1;
}

uint64_t sub_100E577CC()
{
  return 0;
}

uint64_t sub_100E577D4()
{
  return 1;
}

uint64_t sub_100E577DC()
{
  return 1;
}

uint64_t sub_100E577E4()
{
  return 0;
}

uint64_t sub_100E577EC()
{
  return 0;
}

uint64_t sub_100E577F4()
{
  return 1;
}

uint64_t sub_100E577FC()
{
  return 1;
}

uint64_t sub_100E57804()
{
  return 0;
}

uint64_t sub_100E5780C()
{
  return 1;
}

uint64_t sub_100E57814()
{
  return 100;
}

uint64_t *sub_100E5781C(uint64_t a1)
{
  return sub_100C62700(a1, "kThumperGetCarrierName", (unint64_t)sub_100E5783C, 3u);
}

void sub_100E5783C(Registry **a1@<X0>, void **a2@<X4>, uint64_t *a3@<X8>)
{
  void (***v12)(void **__return_ptr, void, void **);
  char v13;
  void *v14;
  uint64_t (*v15)(uint64_t);
  CFTypeID v16;
  void *v17;
  void *v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t object;
  CFTypeRef v22;
  void *v23;
  void *value;
  void *v25[2];
  uint64_t v26;
  void *__p[2];
  uint64_t v28;
  void *v29;
  std::__shared_weak_count *v30;

  uint64_t v29 = 0;
  uint64_t v30 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  BOOL v5 = ServiceMap;
  if (v6 < 0)
  {
    char v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    unsigned int v12 = (void (***)(void **__return_ptr, void, void **))v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      int v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  int v13 = 1;
LABEL_9:
  sub_100058DB0(v25, "thumper");
  if (SHIBYTE(v26) < 0)
  {
    sub_10004FC84(__p, v25[0], (unint64_t)v25[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v25;
    uint64_t v28 = v26;
  }
  (**v12)(&v29, v12, __p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  if ((SHIBYTE(v26) & 0x80000000) == 0)
  {
    if (v13) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  operator delete(v25[0]);
  if ((v13 & 1) == 0) {
LABEL_16:
  }
    sub_10004D2C8(v11);
LABEL_17:
  v25[0] = 0;
  BOOL v14 = v29;
  if (v29) {
    BOOL v14 = (void *)(*(uint64_t (**)(void *))(*(void *)v29 + 112))(v29);
  }
  unsigned int value = 0;
  v25[0] = v14;
  uint64_t v23 = 0;
  if (v14) {
    uint64_t v15 = sub_100080778;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)v14, @"CarrierName", (const void **)&value)
    && (char v16 = CFGetTypeID(value), v16 == CFStringGetTypeID()))
  {
    char v22 = value;
    __p[0] = 0;
    sub_100056248(__p, &v22);
    uint64_t v17 = v23;
    uint64_t v23 = __p[0];
    __p[0] = v17;
    sub_1000558F4((const void **)__p);
  }
  else
  {
    __p[0] = &stru_101AC1B28;
    sub_100013168((const void **)&v23, (CFTypeRef *)__p);
  }
  uint64_t v18 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  uint64_t v19 = v18;
  if (v18)
  {
    uint64_t v20 = v18;
LABEL_32:
    xpc_retain(v19);
    goto LABEL_33;
  }
  uint64_t v19 = xpc_null_create();
  uint64_t v20 = v19;
  if (v19) {
    goto LABEL_32;
  }
  uint64_t v19 = 0;
  uint64_t v20 = xpc_null_create();
LABEL_33:
  __p[0] = *a2;
  __p[1] = "kThumperCarrierName";
  sub_100035E70((uint64_t)__p, &v20, &object);
  xpc_release(object);
  dispatch_object_t object = 0;
  xpc_release(v20);
  uint64_t v20 = 0;
  xpc_release(v19);
  sub_1000558F4((const void **)&v23);
  sub_100057D78((const void **)v25);
  if (v30) {
    sub_10004D2C8(v30);
  }
}

void sub_100E57B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1000558F4(&a12);
  sub_100057D78((const void **)&__p);
  if (*(void *)(v25 - 56)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v25 - 56));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E57BA8()
{
  return sub_100C624B8((uint64_t)&unk_101B12DB0, (uint64_t)sub_100E5781C);
}

void sub_100E57BC4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100E57F1C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100E5B34C);
  __cxa_rethrow();
}

void sub_100E57F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23)
{
}

void sub_100E5802C(uint64_t a1)
{
  *(void *)a1 = off_101A63438;
  sub_1000558F4((const void **)(a1 + 152));
  sub_100057D78((const void **)(a1 + 144));
  int v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_100559894(a1);
}

void sub_100E58098(uint64_t a1)
{
  sub_100E5802C(a1);

  operator delete();
}

void sub_100E580D0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 144);
    *(_DWORD *)std::string buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Device info: %@", buf, 0xCu);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v8 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v6 = v8;
    long long v4 = __p;
    if (v8 < 0) {
      long long v4 = *(void ***)buf;
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Device name: %{public}s", buf, 0xCu);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100E58200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E5821C(uint64_t a1, const void **a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100058198(&v6, a2);
  sub_10055E1FC((uint64_t)&v7, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100E5836C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100E58398(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(void *)a1)
  {
    dispatch_group_leave(*(dispatch_group_t *)a1);
    if (*(void *)a1) {
      dispatch_release(*(dispatch_object_t *)a1);
    }
  }
  return a1;
}

const void **sub_100E583E0(uint64_t a1, const void **a2, CFDictionaryRef *a3, uint64_t a4)
{
  BOOL v5 = (CFDictionaryRef *)a2;
  sub_100058198((const void **)&theDict, a2);
  CFTypeRef v324 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_1003AA8C0(&v324, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"IMSI");
  CFDictionaryRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFDictionaryGetTypeID())
    {
      v336[0] = 0;
      v336[0] = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFIndex Count = CFDictionaryGetCount(v8);
      memset(buf, 0, sizeof(buf));
      sub_10004EE3C(buf, Count);
      memset(&values, 0, sizeof(values));
      sub_10004EE3C(&values, Count);
      v296 = v5;
      CFDictionaryGetKeysAndValues(v8, *(const void ***)buf, (const void **)values.__r_.__value_.__l.__data_);
      v298 = (void *)Count;
      if (Count >= 1)
      {
        int v11 = 0;
        do
        {
          unsigned int v12 = *(const void **)(*(void *)buf + 8 * (void)v11);
          if (v12)
          {
            CFTypeID v13 = CFGetTypeID(*(CFTypeRef *)(*(void *)buf + 8 * (void)v11));
            if (v13 != CFStringGetTypeID()) {
              unsigned int v12 = 0;
            }
          }
          *(void *)v343 = v12;
          CFDictionaryRef v14 = *(const __CFDictionary **)(values.__r_.__value_.__r.__words[0] + 8 * (void)v11);
          if (v14)
          {
            CFTypeID v15 = CFGetTypeID(*(CFTypeRef *)(values.__r_.__value_.__r.__words[0] + 8 * (void)v11));
            if (v15 != CFDictionaryGetTypeID()) {
              CFDictionaryRef v14 = 0;
            }
          }
          char v16 = CFDictionaryGetValue(v14, @"BundleMapKey");
          uint64_t v17 = v16;
          if (v16)
          {
            CFTypeID v18 = CFGetTypeID(v16);
            if (v18 == CFStringGetTypeID()) {
              CFDictionarySetValue(v336[0], v12, v17);
            }
          }
          CFArrayRef v19 = (const __CFArray *)CFDictionaryGetValue(v14, @"MVNOs");
          CFArrayRef v20 = v19;
          if (v19)
          {
            CFTypeID v21 = CFGetTypeID(v19);
            if (v21 == CFArrayGetTypeID())
            {
              CFIndex v22 = CFArrayGetCount(v20);
              if (v22 >= 1)
              {
                for (CFIndex i = 0; i != v22; ++i)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, i);
                  CFDictionaryRef v25 = ValueAtIndex;
                  if (ValueAtIndex)
                  {
                    CFTypeID v26 = CFGetTypeID(ValueAtIndex);
                    if (v26 != CFDictionaryGetTypeID()) {
                      CFDictionaryRef v25 = 0;
                    }
                  }
                  int v27 = CFDictionaryGetValue(v25, @"BundleMapKey");
                  uint64_t v28 = v27;
                  if (v27)
                  {
                    CFTypeID v29 = CFGetTypeID(v27);
                    if (v29 == CFStringGetTypeID())
                    {
                      memset(&v329, 0, sizeof(v329));
                      sub_1000292E0((uint64_t)&v329);
                      uint64_t v30 = (__CFString *)CFDictionaryGetValue(v25, @"GID1");
                      uint64_t v31 = v30;
                      if (v30 && (CFTypeID v32 = CFGetTypeID(v30), v32 == CFStringGetTypeID()))
                      {
                        v332 = v31;
                        sub_1000292E0((uint64_t)&v328);
                        int v33 = std::string::insert(&v328, 0, "_", 1uLL);
                        long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
                        __str.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v34;
                        v33->__r_.__value_.__l.__size_ = 0;
                        v33->__r_.__value_.__r.__words[2] = 0;
                        v33->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&v327);
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          uint64_t v35 = &v327;
                        }
                        else {
                          uint64_t v35 = (std::string *)v327.__r_.__value_.__r.__words[0];
                        }
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type size = HIBYTE(v327.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type size = v327.__r_.__value_.__l.__size_;
                        }
                        int v37 = std::string::append(&__str, (const std::string::value_type *)v35, size);
                        long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
                        __p.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v38;
                        v37->__r_.__value_.__l.__size_ = 0;
                        v37->__r_.__value_.__r.__words[2] = 0;
                        v37->__r_.__value_.__r.__words[0] = 0;
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          p_p = &__p;
                        }
                        else {
                          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                        }
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v40 = __p.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v329, (const std::string::value_type *)p_p, v40);
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v327.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v327.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v328.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v328.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        v332 = 0;
                      }
                      uint64_t v41 = CFDictionaryGetValue(v25, @"GID2");
                      uint64_t v42 = v41;
                      if (v41 && (CFTypeID v43 = CFGetTypeID(v41), v43 == CFStringGetTypeID()))
                      {
                        CFTypeRef v331 = v42;
                        sub_1000292E0((uint64_t)&v328);
                        int v44 = std::string::insert(&v328, 0, "_", 1uLL);
                        long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
                        __str.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v45;
                        v44->__r_.__value_.__l.__size_ = 0;
                        v44->__r_.__value_.__r.__words[2] = 0;
                        v44->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&v327);
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          uint64_t v46 = &v327;
                        }
                        else {
                          uint64_t v46 = (std::string *)v327.__r_.__value_.__r.__words[0];
                        }
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v47 = HIBYTE(v327.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v47 = v327.__r_.__value_.__l.__size_;
                        }
                        int v48 = std::string::append(&__str, (const std::string::value_type *)v46, v47);
                        long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
                        __p.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v49;
                        v48->__r_.__value_.__l.__size_ = 0;
                        v48->__r_.__value_.__r.__words[2] = 0;
                        v48->__r_.__value_.__r.__words[0] = 0;
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          xpc_object_t v50 = &__p;
                        }
                        else {
                          xpc_object_t v50 = (std::string *)__p.__r_.__value_.__r.__words[0];
                        }
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v51 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v51 = __p.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v329, (const std::string::value_type *)v50, v51);
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v327.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v327.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v328.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v328.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        CFTypeRef v331 = 0;
                      }
                      BOOL v52 = CFDictionaryGetValue(v25, @"ICCID");
                      int v53 = v52;
                      if (v52 && (CFTypeID v54 = CFGetTypeID(v52), v54 == CFStringGetTypeID()))
                      {
                        CFTypeRef v330 = v53;
                        sub_1000292E0((uint64_t)&v328);
                        char v55 = std::string::insert(&v328, 0, "_", 1uLL);
                        long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
                        __str.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v56;
                        v55->__r_.__value_.__l.__size_ = 0;
                        v55->__r_.__value_.__r.__words[2] = 0;
                        v55->__r_.__value_.__r.__words[0] = 0;
                        sub_1000292E0((uint64_t)&v327);
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          xpc_object_t v57 = &v327;
                        }
                        else {
                          xpc_object_t v57 = (std::string *)v327.__r_.__value_.__r.__words[0];
                        }
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v58 = HIBYTE(v327.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v58 = v327.__r_.__value_.__l.__size_;
                        }
                        xpc_object_t v59 = std::string::append(&__str, (const std::string::value_type *)v57, v58);
                        long long v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
                        __p.__r_.__value_.__r.__words[2] = v59->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v60;
                        v59->__r_.__value_.__l.__size_ = 0;
                        v59->__r_.__value_.__r.__words[2] = 0;
                        v59->__r_.__value_.__r.__words[0] = 0;
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          xpc_object_t v61 = &__p;
                        }
                        else {
                          xpc_object_t v61 = (std::string *)__p.__r_.__value_.__r.__words[0];
                        }
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v62 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v62 = __p.__r_.__value_.__l.__size_;
                        }
                        std::string::append(&v329, (const std::string::value_type *)v61, v62);
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v327.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v327.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__str.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(v328.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v328.__r_.__value_.__l.__data_);
                        }
                      }
                      else
                      {
                        CFTypeRef v330 = 0;
                      }
                      std::string v63 = v336[0];
                      if (SHIBYTE(v329.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&__dst, v329.__r_.__value_.__l.__data_, v329.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string __dst = v329;
                      }
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string __str = __dst;
                      }
                      v312[0] = 0;
                      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string __p = __str;
                      }
                      v327.__r_.__value_.__r.__words[0] = 0;
                      if (ctu::cf::convert_copy())
                      {
                        xpc_object_t v64 = v312[0];
                        v312[0] = v327.__r_.__value_.__l.__data_;
                        v328.__r_.__value_.__r.__words[0] = (std::string::size_type)v64;
                        sub_1000558F4((const void **)&v328.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__p.__r_.__value_.__l.__data_);
                      }
                      v326 = v312[0];
                      v312[0] = 0;
                      sub_1000558F4((const void **)v312);
                      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__str.__r_.__value_.__l.__data_);
                      }
                      CFDictionarySetValue(v63, v326, v28);
                      sub_1000558F4((const void **)&v326);
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(v329.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v329.__r_.__value_.__l.__data_);
                      }
                    }
                  }
                }
              }
            }
          }
          int v11 = (char *)v11 + 1;
        }
        while (v11 != v298);
      }
      copyMergedDictionaries((const __CFDictionary *)v324, v336[0], &__str);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v324;
      CFTypeRef v324 = (CFTypeRef)__str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = 0;
      sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
      sub_100057D78((const void **)&__str.__r_.__value_.__l.__data_);
      BOOL v5 = v296;
      if (values.__r_.__value_.__r.__words[0])
      {
        values.__r_.__value_.__l.__size_ = values.__r_.__value_.__r.__words[0];
        operator delete(values.__r_.__value_.__l.__data_);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      sub_10005717C((const void **)v336);
    }
  }
  sub_100057D78((const void **)&theDict);
  CFDictionaryRef v322 = 0;
  CFDictionaryRef v65 = (const __CFDictionary *)CFDictionaryGetValue(*v5, @"BundleMappings");
  CFDictionaryRef v66 = v65;
  if (v65 && (CFTypeID v67 = CFGetTypeID(v65), v67 == CFDictionaryGetTypeID()))
  {
    CFDictionaryRef v322 = v66;
    CFRetain(v66);
  }
  else
  {
    CFDictionaryRef v322 = 0;
  }
  CFDictionaryRef v321 = 0;
  sub_100058198((const void **)&v320, (const void **)v5);
  CFDictionaryRef v321 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_1003AA8C0(&v321, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
  CFDictionaryRef v68 = (const __CFDictionary *)CFDictionaryGetValue(v320, @"Bundles");
  CFDictionaryRef v69 = v68;
  if (!v68 || (CFTypeID v70 = CFGetTypeID(v68), v70 != CFDictionaryGetTypeID()))
  {
    xpc_object_t v71 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_129;
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    xpc_object_t v72 = "#I Bundles key is not found in version.xml";
LABEL_128:
    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v72, (uint8_t *)&__p, 2u);
    goto LABEL_129;
  }
  if (!CFDictionaryGetCount(v69))
  {
    xpc_object_t v71 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_129;
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    xpc_object_t v72 = "#I Bundles key has 0 elements";
    goto LABEL_128;
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v69;
  sub_100282490((const void **)&v321, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
LABEL_129:
  sub_100057D78((const void **)&v320);
  CFTypeRef cf = CFDictionaryGetValue(*a3, @"kBundleUpdateCheckCriteria");
  if (cf)
  {
    CFTypeID v73 = CFGetTypeID(cf);
    if (v73 == CFArrayGetTypeID())
    {
      xpc_object_t v74 = dispatch_group_create();
      xpc_object_t v75 = v74;
      if (v74)
      {
        dispatch_retain(v74);
        dispatch_group_enter(v75);
        dispatch_release(v75);
      }
      dispatch_object_t object = v75;
      xpc_object_t v76 = operator new(0x30uLL);
      v76[1] = 0;
      v76[2] = 0;
      void *v76 = off_1019E3880;
      v76[3] = 0;
      xpc_object_t v77 = v76 + 3;
      v76[4] = 0;
      v76[5] = 0;
      v291 = v76;
      *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = 0uLL;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__l.__size_;
      CFIndex v78 = CFArrayGetCount((CFArrayRef)cf);
      if (v78 < 1) {
        goto LABEL_546;
      }
      CFIndex v79 = 0;
      key = (os_log_t *)(a1 + 40);
      v295 = (Registry **)(a1 + 80);
      uint64_t v293 = a1;
      CFIndex v297 = v78;
LABEL_135:
      CFDictionaryRef v318 = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex((CFArrayRef)cf, v79);
      sub_10004EFE4(&v318, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
      xpc_object_t v80 = (int *)CFDictionaryGetValue(v318, @"kUpdateBundleType");
      xpc_object_t v81 = v80;
      LODWORD(__p.__r_.__value_.__l.__data_) = 0;
      if (v80)
      {
        CFTypeID v82 = CFGetTypeID(v80);
        if (v82 == CFNumberGetTypeID()) {
          ctu::cf::assign((ctu::cf *)&__p, v81, v83);
        }
      }
      unsigned __int8 v84 = __p.__r_.__value_.__s.__data_[0];
      if ((__p.__r_.__value_.__s.__data_[0] - 5) < 2u) {
        goto LABEL_545;
      }
      xpc_object_t v85 = *key;
      if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v86 = asString();
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v86;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#N Checking update for %s", (uint8_t *)&__p, 0xCu);
      }
      if (v84 == 3)
      {
        CFDictionaryRef v317 = v318;
        if (v318) {
          CFRetain(v318);
        }
        sub_1004D3980(&v317, (const __CFDictionary **)&__str);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v318;
        CFDictionaryRef v318 = (CFDictionaryRef)__str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
        sub_100057D78((const void **)&__str.__r_.__value_.__l.__data_);
        sub_100057D78((const void **)&v317);
      }
      v315 = 0;
      CFTypeRef v316 = 0;
      CFTypeRef v314 = v324;
      if (v324) {
        CFRetain(v324);
      }
      sub_1006CE9F8((const void **)key, v295, (const __CFDictionary **)&v314, v318, &__str);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v315;
      v315 = (void *)__str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
      sub_100057D78(&v314);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v318;
      if (v318)
      {
        CFRetain(v318);
        xpc_object_t v87 = (const void *)__str.__r_.__value_.__r.__words[0];
      }
      else
      {
        xpc_object_t v87 = 0;
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v316;
      CFTypeRef v316 = v87;
      __str.__r_.__value_.__r.__words[0] = 0;
      sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
      xpc_object_t v88 = *key;
      if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
      {
        memset(&__p, 0, sizeof(__p));
        ctu::cf::assign();
        std::string __str = __p;
        p_str = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_str = &__str;
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = p_str;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#N The best match found from the version.xml is %{public}s", buf, 0xCu);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      if (v315) {
        long long v90 = sub_1000810B8;
      }
      else {
        long long v90 = 0;
      }
      if (!v90)
      {
        uint64_t v96 = *key;
        if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#N Did not get the bundle Map key to look for the update", (uint8_t *)&__p, 2u);
        }
        goto LABEL_544;
      }
      v312[0] = 0;
      v312[1] = 0;
      uint64_t v313 = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v315;
      sub_1000292E0((uint64_t)v312);
      sub_100046BAC((uint64_t **)&__dst, v312, (uint64_t)v312);
      if (!v91)
      {
        long long v109 = *key;
        if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
        {
          memset(&__p, 0, sizeof(__p));
          ctu::cf::assign();
          std::string __str = __p;
          long long v110 = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v110 = &__str;
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)&uint8_t buf[4] = v110;
          _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "#N %{public}s is already covered", buf, 0xCu);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
        }
        goto LABEL_542;
      }
      CFDictionaryRef v311 = 0;
      CFDictionaryRef v92 = (const __CFDictionary *)CFDictionaryGetValue(v322, v315);
      CFDictionaryRef v93 = v92;
      if (v92 && (CFTypeID v94 = CFGetTypeID(v92), v94 == CFDictionaryGetTypeID()))
      {
        CFDictionaryRef v311 = v93;
        CFRetain(v93);
        CFDictionaryRef v95 = v311;
      }
      else
      {
        CFDictionaryRef v95 = 0;
        CFDictionaryRef v311 = 0;
      }
      if (v95) {
        unsigned int v97 = sub_100080778;
      }
      else {
        unsigned int v97 = 0;
      }
      if (!v97)
      {
        uint64_t v111 = *key;
        if (os_log_type_enabled(*key, OS_LOG_TYPE_ERROR))
        {
          uint64_t v112 = v312;
          if (v313 < 0) {
            uint64_t v112 = (void **)v312[0];
          }
          LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v112;
          _os_log_error_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "No entry for bundle Map key %{public}s in BundleMappings", (uint8_t *)&__p, 0xCu);
        }
        goto LABEL_541;
      }
      CFDictionaryRef v309 = v95;
      v310 = 0;
      if (v95) {
        CFRetain(v95);
      }
      sub_100058198((const void **)&v308, (const void **)a3);
      v310 = 0;
      if (v309) {
        long long v98 = sub_100080778;
      }
      else {
        long long v98 = 0;
      }
      if (!v98)
      {
        v113 = *key;
        if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "#N bundleMap empty.", (uint8_t *)&__p, 2u);
        }
        goto LABEL_388;
      }
      *(void *)v343 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v295, *v295);
      long long v100 = ServiceMap;
      if ((v101 & 0x8000000000000000) != 0)
      {
        long long v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v103 = 5381;
        do
        {
          std::string::size_type v101 = v103;
          unsigned int v104 = *v102++;
          uint64_t v103 = (33 * v103) ^ v104;
        }
        while (v104);
      }
      std::mutex::lock(ServiceMap);
      __p.__r_.__value_.__r.__words[0] = v101;
      long long v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)&__p);
      if (v105)
      {
        uint64_t v107 = v105[3];
        long long v106 = (std::__shared_weak_count *)v105[4];
        if (v106)
        {
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v100);
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v106);
          char v108 = 0;
LABEL_195:
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v107 + 112))(v343, v107);
          if ((v108 & 1) == 0) {
            sub_10004D2C8(v106);
          }
          if (*(void *)v343) {
            uint64_t v114 = sub_1000810B8;
          }
          else {
            uint64_t v114 = 0;
          }
          if (!v114)
          {
            uint64_t v118 = *key;
            if (os_log_type_enabled(*key, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p.__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, "currentOSVersion is missing.", (uint8_t *)&__p, 2u);
            }
            goto LABEL_387;
          }
          memset(&__str, 0, sizeof(__str));
          memset(&__p, 0, sizeof(__p));
          ctu::cf::assign();
          std::string __str = __p;
          std::string::size_type v115 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          v116 = &__str;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          {
            std::string::size_type v115 = __str.__r_.__value_.__l.__size_;
            v116 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (!v115) {
            goto LABEL_213;
          }
          std::string::size_type v117 = 0;
          while (v116->__r_.__value_.__s.__data_[v117] != 46)
          {
            if (v115 == ++v117) {
              goto LABEL_213;
            }
          }
          if (v115 == v117)
          {
LABEL_213:
            memset(buf, 0, sizeof(buf));
          }
          else
          {
            memset(buf, 0, sizeof(buf));
            if (v117 != -1)
            {
              std::string::basic_string(&__p, &__str, 0, v117, (std::allocator<char> *)&values);
LABEL_217:
              char v119 = std::string::append(&__p, ".0", 2uLL);
              long long v120 = *(_OWORD *)&v119->__r_.__value_.__l.__data_;
              *(void *)&uint8_t buf[16] = *((void *)&v119->__r_.__value_.__l + 2);
              *(_OWORD *)std::string buf = v120;
              v119->__r_.__value_.__l.__size_ = 0;
              v119->__r_.__value_.__r.__words[2] = 0;
              v119->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              v332 = 0;
              if ((buf[23] & 0x80u) == 0) {
                v121 = buf;
              }
              else {
                v121 = *(uint8_t **)buf;
              }
              v332 = (__CFString *)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v121, 0x8000100u);
              CFIndex v122 = CFDictionaryGetCount(v309);
              memset(&values, 0, sizeof(values));
              sub_10004EE3C(&values, v122);
              memset(&v329, 0, sizeof(v329));
              sub_10004EE3C(&v329, v122);
              memset(&v328, 0, sizeof(v328));
              CFDictionaryGetKeysAndValues(v309, (const void **)values.__r_.__value_.__l.__data_, (const void **)v329.__r_.__value_.__l.__data_);
              if (v122 < 1) {
                goto LABEL_360;
              }
              uint64_t v123 = 0;
              while (1)
              {
                CFDictionaryRef v124 = *(const __CFDictionary **)(v329.__r_.__value_.__r.__words[0] + 8 * v123);
                if (!v124
                  || (CFTypeID v125 = CFGetTypeID(*(CFTypeRef *)(v329.__r_.__value_.__r.__words[0] + 8 * v123)),
                      v125 != CFDictionaryGetTypeID()))
                {
                  os_log_t v142 = *key;
                  if (!os_log_type_enabled(*key, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_354;
                  }
                  LOWORD(__p.__r_.__value_.__l.__data_) = 0;
                  CFStringRef v143 = v142;
                  CFStringRef v144 = "This key is empty";
                  goto LABEL_249;
                }
                CFDictionaryRef v126 = (const __CFDictionary *)CFDictionaryGetValue(v124, @"OS");
                CFDictionaryRef v127 = v126;
                if (!v126 || (CFTypeID v128 = CFGetTypeID(v126), v128 != CFDictionaryGetTypeID()))
                {
                  os_log_t v145 = *key;
                  if (!os_log_type_enabled(*key, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_354;
                  }
                  LOWORD(__p.__r_.__value_.__l.__data_) = 0;
                  CFStringRef v143 = v145;
                  CFStringRef v144 = "OS Dict is missing. Not a valid config. Skipping";
                  goto LABEL_249;
                }
                CFStringRef v129 = (const __CFString *)CFDictionaryGetValue(v127, @"Min");
                CFStringRef v130 = v129;
                if (v129)
                {
                  CFTypeID v131 = CFGetTypeID(v129);
                  if (v131 != CFStringGetTypeID()) {
                    CFStringRef v130 = 0;
                  }
                }
                CFStringRef v132 = (const __CFString *)CFDictionaryGetValue(v127, @"Max");
                CFStringRef v133 = v132;
                if (v132)
                {
                  CFTypeID v134 = CFGetTypeID(v132);
                  if (v134 != CFStringGetTypeID()) {
                    CFStringRef v133 = 0;
                  }
                }
                if (!v130)
                {
                  os_log_t v146 = *key;
                  if (!os_log_type_enabled(*key, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_354;
                  }
                  LOWORD(__p.__r_.__value_.__l.__data_) = 0;
                  CFStringRef v143 = v146;
                  CFStringRef v144 = "OS Dict is missing min OS entry. This is a mandatory key. Skipping";
LABEL_249:
                  _os_log_error_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_ERROR, v144, (uint8_t *)&__p, 2u);
                  goto LABEL_354;
                }
                if (_CompareBundleVersionStrings(v130, v332) == -1
                  || _CompareBundleVersionStrings(v130, *(const __CFString **)v343) == 1
                  || v133 && _CompareBundleVersionStrings(*(const __CFString **)v343, v133) == 1)
                {
                  goto LABEL_354;
                }
                CFDictionaryRef v135 = (const __CFDictionary *)CFDictionaryGetValue(v124, @"Device");
                CFDictionaryRef v136 = v135;
                if (!v135) {
                  goto LABEL_332;
                }
                CFTypeID v137 = CFGetTypeID(v135);
                if (v137 != CFDictionaryGetTypeID()) {
                  goto LABEL_332;
                }
                CFArrayRef v138 = (const __CFArray *)CFDictionaryGetValue(v136, @"Supported");
                CFArrayRef v139 = v138;
                if (v138)
                {
                  CFTypeID v140 = CFGetTypeID(v138);
                  if (v140 == CFArrayGetTypeID()) {
                    CFArrayRef v141 = v139;
                  }
                  else {
                    CFArrayRef v141 = 0;
                  }
                }
                else
                {
                  CFArrayRef v141 = 0;
                }
                CFArrayRef v147 = (const __CFArray *)CFDictionaryGetValue(v136, @"UnSupported");
                CFArrayRef v148 = v147;
                if (v147)
                {
                  CFTypeID v149 = CFGetTypeID(v147);
                  if (v149 == CFArrayGetTypeID()) {
                    CFArrayRef v150 = v148;
                  }
                  else {
                    CFArrayRef v150 = 0;
                  }
                  CFArrayRef theArray = v150;
                }
                else
                {
                  CFArrayRef theArray = 0;
                }
                uint64_t v151 = (__CFDictionary *)CFDictionaryGetValue(v308, @"DeviceName");
                v152 = v151;
                if (v151)
                {
                  CFTypeID v153 = CFGetTypeID(v151);
                  if (v153 == CFStringGetTypeID()) {
                    dispatch_group_t v154 = v152;
                  }
                  else {
                    dispatch_group_t v154 = 0;
                  }
                }
                else
                {
                  dispatch_group_t v154 = 0;
                }
                v336[0] = v154;
                if (!v141)
                {
                  if (!theArray) {
                    goto LABEL_332;
                  }
                  v289 = (void *)a4;
                  CFIndex v175 = CFArrayGetCount(theArray);
                  if (v175 < 1)
                  {
LABEL_331:
                    a4 = (uint64_t)v289;
                    goto LABEL_332;
                  }
                  CFIndex v176 = 0;
                  BOOL v177 = 1;
                  while (2)
                  {
                    BOOL v285 = v177;
                    v178 = CFArrayGetValueAtIndex(theArray, v176);
                    v179 = v178;
                    if (v178)
                    {
                      CFTypeID v180 = CFGetTypeID(v178);
                      if (v180 == CFStringGetTypeID())
                      {
                        CFTypeRef v331 = v179;
                        sub_1000292E0((uint64_t)&__p);
                        sub_1000292E0((uint64_t)&v327);
                        char v181 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          std::string::size_type v182 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          std::string::size_type v182 = __p.__r_.__value_.__l.__size_;
                        }
                        std::string::size_type v183 = HIBYTE(v327.__r_.__value_.__r.__words[2]);
                        int v184 = SHIBYTE(v327.__r_.__value_.__r.__words[2]);
                        if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                          std::string::size_type v183 = v327.__r_.__value_.__l.__size_;
                        }
                        if (v182 == v183)
                        {
                          if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            v185 = &v327;
                          }
                          else {
                            v185 = (std::string *)v327.__r_.__value_.__r.__words[0];
                          }
                          if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
                          {
                            BOOL v193 = memcmp(__p.__r_.__value_.__l.__data_, v185, __p.__r_.__value_.__l.__size_) == 0;
                          }
                          else if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
                          {
                            uint64_t v186 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
                            v187 = &__p;
                            do
                            {
                              int v189 = v187->__r_.__value_.__s.__data_[0];
                              v187 = (std::string *)((char *)v187 + 1);
                              int v188 = v189;
                              int v191 = v185->__r_.__value_.__s.__data_[0];
                              v185 = (std::string *)((char *)v185 + 1);
                              int v190 = v191;
                              BOOL v172 = v186-- != 0;
                              char v192 = v172;
                              BOOL v193 = v188 == v190;
                            }
                            while (v188 == v190 && (v192 & 1) != 0);
                          }
                          else
                          {
                            BOOL v193 = 1;
                          }
                        }
                        else
                        {
                          BOOL v193 = 0;
                        }
                        if (v184 < 0)
                        {
                          operator delete(v327.__r_.__value_.__l.__data_);
                          if ((v181 & 0x80) == 0) {
                            goto LABEL_326;
                          }
                        }
                        else if ((v181 & 0x80) == 0)
                        {
LABEL_326:
                          if (v193) {
                            goto LABEL_358;
                          }
                          goto LABEL_330;
                        }
                        operator delete(__p.__r_.__value_.__l.__data_);
                        if (v193)
                        {
LABEL_358:
                          a4 = (uint64_t)v289;
                          if (!v285) {
                            goto LABEL_332;
                          }
                          goto LABEL_354;
                        }
                      }
                    }
LABEL_330:
                    BOOL v177 = ++v176 < v175;
                    if (v176 == v175) {
                      goto LABEL_331;
                    }
                    continue;
                  }
                }
                v288 = (void *)a4;
                CFArrayRef theArraya = v141;
                CFIndex v155 = CFArrayGetCount(v141);
                if (v155 < 1)
                {
LABEL_297:
                  a4 = (uint64_t)v288;
                  goto LABEL_354;
                }
                CFIndex v156 = 0;
                BOOL v157 = 1;
                while (1)
                {
                  BOOL v284 = v157;
                  dispatch_group_t v158 = CFArrayGetValueAtIndex(theArraya, v156);
                  dispatch_object_t v159 = v158;
                  if (v158)
                  {
                    CFTypeID v160 = CFGetTypeID(v158);
                    if (v160 == CFStringGetTypeID())
                    {
                      CFTypeRef v331 = v159;
                      sub_1000292E0((uint64_t)&__p);
                      sub_1000292E0((uint64_t)&v327);
                      char v161 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                        std::string::size_type v162 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                      }
                      else {
                        std::string::size_type v162 = __p.__r_.__value_.__l.__size_;
                      }
                      std::string::size_type v163 = HIBYTE(v327.__r_.__value_.__r.__words[2]);
                      int v164 = SHIBYTE(v327.__r_.__value_.__r.__words[2]);
                      if ((v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        std::string::size_type v163 = v327.__r_.__value_.__l.__size_;
                      }
                      if (v162 == v163)
                      {
                        v165 = (v327.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                             ? &v327
                             : (std::string *)v327.__r_.__value_.__r.__words[0];
                        if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
                        {
                          BOOL v174 = memcmp(__p.__r_.__value_.__l.__data_, v165, __p.__r_.__value_.__l.__size_) == 0;
                        }
                        else if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
                        {
                          uint64_t v166 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
                          v167 = &__p;
                          do
                          {
                            int v169 = v167->__r_.__value_.__s.__data_[0];
                            v167 = (std::string *)((char *)v167 + 1);
                            int v168 = v169;
                            int v171 = v165->__r_.__value_.__s.__data_[0];
                            v165 = (std::string *)((char *)v165 + 1);
                            int v170 = v171;
                            BOOL v172 = v166-- != 0;
                            char v173 = v172;
                            BOOL v174 = v168 == v170;
                          }
                          while (v168 == v170 && (v173 & 1) != 0);
                        }
                        else
                        {
                          BOOL v174 = 1;
                        }
                      }
                      else
                      {
                        BOOL v174 = 0;
                      }
                      if (v164 < 0)
                      {
                        operator delete(v327.__r_.__value_.__l.__data_);
                        if ((v161 & 0x80) == 0)
                        {
LABEL_292:
                          if (v174) {
                            break;
                          }
                          goto LABEL_296;
                        }
                      }
                      else if ((v161 & 0x80) == 0)
                      {
                        goto LABEL_292;
                      }
                      operator delete(__p.__r_.__value_.__l.__data_);
                      if (v174) {
                        break;
                      }
                    }
                  }
LABEL_296:
                  BOOL v157 = ++v156 < v155;
                  if (v156 == v155) {
                    goto LABEL_297;
                  }
                }
                a4 = (uint64_t)v288;
                if (!v284) {
                  goto LABEL_354;
                }
LABEL_332:
                uint64_t v194 = *(void *)(values.__r_.__value_.__r.__words[0] + 8 * v123);
                if (v194)
                {
                  CFTypeID v195 = CFGetTypeID(*(CFTypeRef *)(values.__r_.__value_.__r.__words[0] + 8 * v123));
                  if (v195 == CFStringGetTypeID()) {
                    uint64_t v196 = v194;
                  }
                  else {
                    uint64_t v196 = 0;
                  }
                }
                else
                {
                  uint64_t v196 = 0;
                }
                std::string::size_type v197 = v328.__r_.__value_.__l.__size_;
                if (v328.__r_.__value_.__l.__size_ >= v328.__r_.__value_.__r.__words[2])
                {
                  uint64_t v199 = (uint64_t)(v328.__r_.__value_.__l.__size_ - v328.__r_.__value_.__r.__words[0]) >> 3;
                  if ((unint64_t)(v199 + 1) >> 61) {
                    sub_10006A748();
                  }
                  unint64_t v200 = (uint64_t)(v328.__r_.__value_.__r.__words[2] - v328.__r_.__value_.__r.__words[0]) >> 2;
                  if (v200 <= v199 + 1) {
                    unint64_t v200 = v199 + 1;
                  }
                  if (v328.__r_.__value_.__r.__words[2] - v328.__r_.__value_.__r.__words[0] >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v201 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v201 = v200;
                  }
                  if (v201) {
                    v202 = (char *)sub_10004EF74((uint64_t)&v328.__r_.__value_.__r.__words[2], v201);
                  }
                  else {
                    v202 = 0;
                  }
                  v203 = &v202[8 * v199];
                  *(void *)v203 = v196;
                  std::string::size_type v198 = (std::string::size_type)(v203 + 8);
                  v204 = (char *)v328.__r_.__value_.__l.__size_;
                  std::string::size_type v205 = v328.__r_.__value_.__r.__words[0];
                  if (v328.__r_.__value_.__l.__size_ != v328.__r_.__value_.__r.__words[0])
                  {
                    do
                    {
                      uint64_t v206 = *((void *)v204 - 1);
                      v204 -= 8;
                      *((void *)v203 - 1) = v206;
                      v203 -= 8;
                    }
                    while (v204 != (char *)v205);
                    v204 = (char *)v328.__r_.__value_.__r.__words[0];
                  }
                  v328.__r_.__value_.__r.__words[0] = (std::string::size_type)v203;
                  v328.__r_.__value_.__l.__size_ = v198;
                  v328.__r_.__value_.__r.__words[2] = (std::string::size_type)&v202[8 * v201];
                  if (v204) {
                    operator delete(v204);
                  }
                }
                else
                {
                  *(void *)v328.__r_.__value_.__l.__size_ = v196;
                  std::string::size_type v198 = v197 + 8;
                }
                v328.__r_.__value_.__l.__size_ = v198;
LABEL_354:
                if (++v123 == v122)
                {
LABEL_360:
                  v207 = (void *)v328.__r_.__value_.__r.__words[0];
                  if (v328.__r_.__value_.__r.__words[0] == v328.__r_.__value_.__l.__size_)
                  {
                    a1 = v293;
                    if (v328.__r_.__value_.__r.__words[0]) {
                      goto LABEL_378;
                    }
                  }
                  else
                  {
                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1006CEC10;
                    sub_10049981C((uint64_t)v328.__r_.__value_.__l.__data_, (char *)v328.__r_.__value_.__l.__size_, (uint64_t (**)(uint64_t, uint64_t))&__p, 126- 2 * __clz((uint64_t)(v328.__r_.__value_.__l.__size_ - v328.__r_.__value_.__r.__words[0]) >> 3), 1);
                    a1 = v293;
                    CFTypeRef v331 = 0;
                    v208 = CFDictionaryGetValue(v309, *(const void **)(v328.__r_.__value_.__l.__size_ - 8));
                    v209 = v208;
                    if (v208 && (CFTypeID v210 = CFGetTypeID(v208), v210 == CFDictionaryGetTypeID()))
                    {
                      CFTypeRef v331 = v209;
                      CFRetain(v209);
                      CFDictionaryRef v211 = (const __CFDictionary *)v331;
                    }
                    else
                    {
                      CFDictionaryRef v211 = 0;
                      CFTypeRef v331 = 0;
                    }
                    v212 = CFDictionaryGetValue(v211, @"BundleMatchEntry");
                    std::string::size_type v213 = (std::string::size_type)v212;
                    if (v212)
                    {
                      CFTypeID v214 = CFGetTypeID(v212);
                      if (v214 == CFStringGetTypeID()) {
                        std::string::size_type v215 = v213;
                      }
                      else {
                        std::string::size_type v215 = 0;
                      }
                    }
                    else
                    {
                      std::string::size_type v215 = 0;
                    }
                    __p.__r_.__value_.__r.__words[0] = v215;
                    sub_100013168((const void **)&v310, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
                    v216 = *key;
                    if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
                    {
                      memset(&__p, 0, sizeof(__p));
                      ctu::cf::assign();
                      std::string v327 = __p;
                      v217 = &v327;
                      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        v217 = (std::string *)__p.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v336[0]) = 136446210;
                      *(CFMutableDictionaryRef *)((char *)v336 + 4) = (CFMutableDictionaryRef)v217;
                      _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "#I Matched bundle entry from BundleMap dict is %{public}s", (uint8_t *)v336, 0xCu);
                      if (SHIBYTE(v327.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v327.__r_.__value_.__l.__data_);
                      }
                    }
                    sub_100057D78(&v331);
                    v207 = (void *)v328.__r_.__value_.__r.__words[0];
                    if (v328.__r_.__value_.__r.__words[0])
                    {
LABEL_378:
                      v328.__r_.__value_.__l.__size_ = (std::string::size_type)v207;
                      operator delete(v207);
                    }
                  }
                  if (v329.__r_.__value_.__r.__words[0])
                  {
                    v329.__r_.__value_.__l.__size_ = v329.__r_.__value_.__r.__words[0];
                    operator delete(v329.__r_.__value_.__l.__data_);
                  }
                  if (values.__r_.__value_.__r.__words[0])
                  {
                    values.__r_.__value_.__l.__size_ = values.__r_.__value_.__r.__words[0];
                    operator delete(values.__r_.__value_.__l.__data_);
                  }
                  sub_1000558F4((const void **)&v332);
                  if ((char)buf[23] < 0) {
                    operator delete(*(void **)buf);
                  }
                  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__str.__r_.__value_.__l.__data_);
                  }
LABEL_387:
                  sub_1000558F4((const void **)v343);
LABEL_388:
                  sub_100057D78((const void **)&v308);
                  sub_100057D78((const void **)&v309);
                  if (v310) {
                    v218 = sub_1000810B8;
                  }
                  else {
                    v218 = 0;
                  }
                  if (v218)
                  {
                    CFTypeRef v307 = 0;
                    v219 = CFDictionaryGetValue(v321, v310);
                    v220 = v219;
                    if (v219 && (CFTypeID v221 = CFGetTypeID(v219), v221 == CFDictionaryGetTypeID()))
                    {
                      CFTypeRef v307 = v220;
                      CFRetain(v220);
                      CFDictionaryRef v222 = (const __CFDictionary *)v307;
                    }
                    else
                    {
                      CFDictionaryRef v222 = 0;
                      CFTypeRef v307 = 0;
                    }
                    if (v222) {
                      v223 = sub_100080778;
                    }
                    else {
                      v223 = 0;
                    }
                    if (v223)
                    {
                      v336[1] = 0;
                      v336[0] = 0;
                      v337 = 0;
                      v224 = CFDictionaryGetValue(v222, @"BundleID");
                      std::string::size_type v225 = (std::string::size_type)v224;
                      if (v224)
                      {
                        CFTypeID v226 = CFGetTypeID(v224);
                        if (v226 == CFStringGetTypeID()) {
                          std::string::size_type v227 = v225;
                        }
                        else {
                          std::string::size_type v227 = 0;
                        }
                      }
                      else
                      {
                        std::string::size_type v227 = 0;
                      }
                      __p.__r_.__value_.__r.__words[0] = v227;
                      sub_1000292E0((uint64_t)v336);
                      sub_10055D190(a1, v84, (const char *)v336, 0);
                      CFDictionaryRef v306 = (CFDictionaryRef)v307;
                      if (v307) {
                        CFRetain(v307);
                      }
                      CFDictionaryRef v305 = v318;
                      if (v318) {
                        CFRetain(v318);
                      }
                      *(void *)dispatch_group_t group = a1;
                      *(void *)&group[8] = object;
                      if (object)
                      {
                        dispatch_retain(object);
                        dispatch_group_enter(object);
                      }
                      *(void *)&group[16] = v316;
                      if (v316) {
                        CFRetain(v316);
                      }
                      if (SHIBYTE(v337) < 0)
                      {
                        sub_10004FC84(v302, v336[0], (unint64_t)v336[1]);
                      }
                      else
                      {
                        *(_OWORD *)v302 = *(_OWORD *)v336;
                        v302[2] = v337;
                      }
                      unsigned __int8 v303 = v84;
                      *(void *)&long long v304 = v77;
                      *((void *)&v304 + 1) = v291;
                      atomic_fetch_add_explicit(v291 + 1, 1uLL, memory_order_relaxed);
                      v335 = 0;
                      v232 = (char *)operator new(0x50uLL);
                      *(void *)v232 = off_101A636F8;
                      *(_OWORD *)(v232 + 8) = *(_OWORD *)group;
                      *((void *)v232 + 3) = *(void *)&group[16];
                      *(_OWORD *)&group[8] = 0u;
                      *((_OWORD *)v232 + 2) = *(_OWORD *)v302;
                      *((void **)v232 + 6) = v302[2];
                      memset(v302, 0, sizeof(v302));
                      v232[56] = v84;
                      *((void *)v232 + 8) = v77;
                      *((void *)v232 + 9) = v291;
                      long long v304 = 0u;
                      v335 = v232;
                      memset(buf, 0, sizeof(buf));
                      memset(&values, 0, sizeof(values));
                      v233 = (__CFString *)CFDictionaryGetValue(v306, @"BundleVersion");
                      v234 = v233;
                      if (v233)
                      {
                        CFTypeID v235 = CFGetTypeID(v233);
                        if (v235 != CFStringGetTypeID()) {
                          v234 = 0;
                        }
                      }
                      v332 = v234;
                      v236 = CFDictionaryGetValue(v306, @"BundleID");
                      std::string::size_type v237 = (std::string::size_type)v236;
                      if (v236)
                      {
                        CFTypeID v238 = CFGetTypeID(v236);
                        if (v238 == CFStringGetTypeID()) {
                          std::string::size_type v239 = v237;
                        }
                        else {
                          std::string::size_type v239 = 0;
                        }
                      }
                      else
                      {
                        std::string::size_type v239 = 0;
                      }
                      v329.__r_.__value_.__r.__words[0] = v239;
                      sub_1000292E0((uint64_t)&__str);
                      v240 = std::string::insert(&__str, 0, "com.apple.", 0xAuLL);
                      v290 = (void *)v240->__r_.__value_.__r.__words[0];
                      int v241 = SHIBYTE(v240->__r_.__value_.__r.__words[2]);
                      v240->__r_.__value_.__r.__words[0] = 0;
                      v240->__r_.__value_.__l.__size_ = 0;
                      v240->__r_.__value_.__r.__words[2] = 0;
                      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__str.__r_.__value_.__l.__data_);
                      }
                      v242 = CFDictionaryGetValue(v306, @"BundleID");
                      v243 = v242;
                      if (v242)
                      {
                        CFTypeID v244 = CFGetTypeID(v242);
                        if (v244 != CFStringGetTypeID()) {
                          v243 = 0;
                        }
                      }
                      if (v305) {
                        v245 = sub_100080778;
                      }
                      else {
                        v245 = 0;
                      }
                      if (!v245) {
                        goto LABEL_449;
                      }
                      v246 = CFDictionaryGetValue(v305, @"BundleIDOnTheDevice");
                      v247 = v246;
                      if (v246)
                      {
                        CFTypeID v248 = CFGetTypeID(v246);
                        if (v248 != CFStringGetTypeID()) {
                          v247 = 0;
                        }
                      }
                      v249 = CFDictionaryGetValue(v305, @"BundleVersionOnTheDevice");
                      v250 = v249;
                      if (v249)
                      {
                        CFTypeID v251 = CFGetTypeID(v249);
                        CFStringRef v252 = v251 == CFStringGetTypeID() ? (const __CFString *)v250 : 0;
                      }
                      else
                      {
                        CFStringRef v252 = 0;
                      }
                      if ((sub_1006CEC58(key, v247, v252, v243, v234) & 1) == 0)
                      {
                        v262 = *key;
                        if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
                        {
                          LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                          _os_log_impl((void *)&_mh_execute_header, v262, OS_LOG_TYPE_DEFAULT, "#I Not a new bundle, nothing to download", (uint8_t *)&__str, 2u);
                        }
                        v329.__r_.__value_.__s.__data_[0] = 3;
                        sub_10055D86C((uint64_t)&__str, &v329, (long long *)buf, (long long *)&values);
                        if (!v335) {
                          sub_10007B600();
                        }
                        (*(void (**)(char *, std::string *))(*(void *)v335 + 48))(v335, &__str);
                        if (v347 < 0) {
                          operator delete(v346);
                        }
                        if (SHIBYTE(v345) < 0) {
                          operator delete((void *)__str.__r_.__value_.__l.__size_);
                        }
                      }
                      else
                      {
LABEL_449:
                        CFTypeRef v331 = 0;
                        v253 = CFDictionaryGetValue(v306, @"BundleURL");
                        v254 = v253;
                        if (v253 && (CFTypeID v255 = CFGetTypeID(v253), v255 == CFStringGetTypeID()))
                        {
                          CFTypeRef v331 = v254;
                          CFRetain(v254);
                          CFTypeRef v256 = v331;
                        }
                        else
                        {
                          CFTypeRef v256 = 0;
                          CFTypeRef v331 = 0;
                        }
                        if (v256) {
                          v257 = sub_1000810B8;
                        }
                        else {
                          v257 = 0;
                        }
                        if (v257)
                        {
                          CFTypeRef v330 = 0;
                          v258 = CFDictionaryGetValue(v306, @"Digest");
                          v259 = v258;
                          if (v258 && (CFTypeID v260 = CFGetTypeID(v258), v260 == CFDataGetTypeID()))
                          {
                            CFTypeRef v330 = v259;
                            CFRetain(v259);
                            CFTypeRef v261 = v330;
                          }
                          else
                          {
                            CFTypeRef v261 = 0;
                            CFTypeRef v330 = 0;
                          }
                          if (v261) {
                            v263 = sub_10008324C;
                          }
                          else {
                            v263 = 0;
                          }
                          if (!v263)
                          {
                            v264 = *key;
                            if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
                            {
                              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                              _os_log_impl((void *)&_mh_execute_header, v264, OS_LOG_TYPE_DEFAULT, "#N No bundle digest found in the versionXML bundle dict", (uint8_t *)&__str, 2u);
                            }
                          }
                          memset(&v329, 0, sizeof(v329));
                          generateUUIDForIPCC(&v329);
                          WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
                          sub_100058DB0(&v327, WirelessUserDirectory);
                          v266 = std::string::append(&v327, "/Library/", 9uLL);
                          long long v267 = *(_OWORD *)&v266->__r_.__value_.__l.__data_;
                          v328.__r_.__value_.__r.__words[2] = v266->__r_.__value_.__r.__words[2];
                          *(_OWORD *)&v328.__r_.__value_.__l.__data_ = v267;
                          v266->__r_.__value_.__l.__size_ = 0;
                          v266->__r_.__value_.__r.__words[2] = 0;
                          v266->__r_.__value_.__r.__words[0] = 0;
                          if ((v329.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            v268 = &v329;
                          }
                          else {
                            v268 = (std::string *)v329.__r_.__value_.__r.__words[0];
                          }
                          size_t v269 = strlen((const char *)v268);
                          v270 = std::string::append(&v328, (const std::string::value_type *)v268, v269);
                          long long v271 = *(_OWORD *)&v270->__r_.__value_.__l.__data_;
                          __str.__r_.__value_.__r.__words[2] = v270->__r_.__value_.__r.__words[2];
                          *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v271;
                          v270->__r_.__value_.__l.__size_ = 0;
                          v270->__r_.__value_.__r.__words[2] = 0;
                          v270->__r_.__value_.__r.__words[0] = 0;
                          v272 = std::string::append(&__str, ".ipcc", 5uLL);
                          std::string::size_type v273 = v272->__r_.__value_.__r.__words[0];
                          *(void *)v343 = v272->__r_.__value_.__l.__size_;
                          *(void *)&v343[7] = *(std::string::size_type *)((char *)&v272->__r_.__value_.__r.__words[1]
                                                                          + 7);
                          uint8_t v274 = HIBYTE(v272->__r_.__value_.__r.__words[2]);
                          v272->__r_.__value_.__l.__size_ = 0;
                          v272->__r_.__value_.__r.__words[2] = 0;
                          v272->__r_.__value_.__r.__words[0] = 0;
                          if ((char)buf[23] < 0) {
                            operator delete(*(void **)buf);
                          }
                          *(void *)std::string buf = v273;
                          *(void *)&uint8_t buf[8] = *(void *)v343;
                          *(void *)&buf[15] = *(void *)&v343[7];
                          buf[23] = v274;
                          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(__str.__r_.__value_.__l.__data_);
                          }
                          if (SHIBYTE(v328.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(v328.__r_.__value_.__l.__data_);
                          }
                          if (SHIBYTE(v327.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(v327.__r_.__value_.__l.__data_);
                          }
                          sub_1000292E0((uint64_t)&__str);
                          if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(values.__r_.__value_.__l.__data_);
                          }
                          std::string values = __str;
                          *(_OWORD *)&v328.__r_.__value_.__l.__data_ = 0uLL;
                          (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 56) + 96))(&v328);
                          if (v328.__r_.__value_.__r.__words[0])
                          {
                            v327.__r_.__value_.__r.__words[0] = (std::string::size_type)v331;
                            if (v331) {
                              CFRetain(v331);
                            }
                            BOOL v275 = sub_10055B46C(a1, &v327);
                            sub_1000558F4((const void **)&v327.__r_.__value_.__l.__data_);
                            std::string::size_type v276 = v328.__r_.__value_.__r.__words[0];
                            *(void *)v343 = v331;
                            if (v331) {
                              CFRetain(v331);
                            }
                            v326 = (void *)v330;
                            if (v330) {
                              CFRetain(v330);
                            }
                            uint64_t v277 = *(unsigned __int8 *)(a1 + 120);
                            __p.__r_.__value_.__r.__words[0] = a1;
                            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = *(_OWORD *)&v328.__r_.__value_.__l.__data_;
                            if (v328.__r_.__value_.__l.__size_) {
                              atomic_fetch_add_explicit((atomic_ullong *volatile)(v328.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
                            }
                            sub_10055E430((uint64_t)v339, (uint64_t)v334);
                            if ((char)buf[23] < 0)
                            {
                              sub_10004FC84(&v340, *(void **)buf, *(unint64_t *)&buf[8]);
                            }
                            else
                            {
                              long long v340 = *(_OWORD *)buf;
                              uint64_t v341 = *(void *)&buf[16];
                            }
                            if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
                              sub_10004FC84(&v342, values.__r_.__value_.__l.__data_, values.__r_.__value_.__l.__size_);
                            }
                            else {
                              std::string v342 = values;
                            }
                            v345 = 0;
                            v280 = (char *)operator new(0x70uLL);
                            *(void *)v280 = off_101A63778;
                            *(std::string *)(v280 + 8) = __p;
                            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
                            sub_10055E9C8((uint64_t)(v280 + 32), (uint64_t)v339);
                            *((_OWORD *)v280 + 4) = v340;
                            *((void *)v280 + 10) = v341;
                            uint64_t v341 = 0;
                            long long v340 = 0uLL;
                            *(std::string *)(v280 + 88) = v342;
                            memset(&v342, 0, sizeof(v342));
                            v345 = v280;
                            (*(void (**)(std::string::size_type, unsigned char *, uint8_t *, void **, uint64_t, BOOL, std::string *))(*(void *)v276 + 24))(v276, v343, buf, &v326, v277, v275, &__str);
                            sub_100060644(&__str);
                            if (SHIBYTE(v342.__r_.__value_.__r.__words[2]) < 0) {
                              operator delete(v342.__r_.__value_.__l.__data_);
                            }
                            if (SHIBYTE(v341) < 0) {
                              operator delete((void *)v340);
                            }
                            sub_10055E178(v339);
                            if (__p.__r_.__value_.__r.__words[2]) {
                              sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__r.__words[2]);
                            }
                            sub_100030068((const void **)&v326);
                            sub_1000558F4((const void **)v343);
                          }
                          else
                          {
                            v279 = *key;
                            if (os_log_type_enabled(*key, OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                              _os_log_error_impl((void *)&_mh_execute_header, v279, OS_LOG_TYPE_ERROR, "Failed to create downloader.", (uint8_t *)&__str, 2u);
                            }
                          }
                          if (v328.__r_.__value_.__l.__size_) {
                            sub_10004D2C8((std::__shared_weak_count *)v328.__r_.__value_.__l.__size_);
                          }
                          if (SHIBYTE(v329.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(v329.__r_.__value_.__l.__data_);
                          }
                          sub_100030068(&v330);
                        }
                        else
                        {
                          v278 = *key;
                          if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
                          {
                            LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v278, OS_LOG_TYPE_DEFAULT, "#I No bundle URL key found in the version specific dict", (uint8_t *)&__str, 2u);
                          }
                          v329.__r_.__value_.__s.__data_[0] = 2;
                          sub_10055D86C((uint64_t)&__str, &v329, (long long *)buf, (long long *)&values);
                          if (!v335) {
                            sub_10007B600();
                          }
                          (*(void (**)(char *, std::string *))(*(void *)v335 + 48))(v335, &__str);
                          if (v347 < 0) {
                            operator delete(v346);
                          }
                          if (SHIBYTE(v345) < 0) {
                            operator delete((void *)__str.__r_.__value_.__l.__size_);
                          }
                        }
                        sub_1000558F4(&v331);
                      }
                      if (v241 < 0) {
                        operator delete(v290);
                      }
                      if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(values.__r_.__value_.__l.__data_);
                      }
                      if ((char)buf[23] < 0) {
                        operator delete(*(void **)buf);
                      }
                      sub_10055E178(v334);
                      if (*((void *)&v304 + 1)) {
                        sub_10004D2C8(*((std::__shared_weak_count **)&v304 + 1));
                      }
                      if (SHIBYTE(v302[2]) < 0) {
                        operator delete(v302[0]);
                      }
                      sub_1000577C4((const void **)&group[16]);
                      if (*(void *)&group[8])
                      {
                        dispatch_group_leave(*(dispatch_group_t *)&group[8]);
                        dispatch_release(*(dispatch_object_t *)&group[8]);
                      }
                      sub_100057D78((const void **)&v305);
                      sub_100057D78((const void **)&v306);
                      if (SHIBYTE(v337) < 0)
                      {
                        CFMutableDictionaryRef v231 = v336[0];
LABEL_538:
                        operator delete(v231);
                      }
                    }
                    else
                    {
                      v229 = *key;
                      if (os_log_type_enabled(*key, OS_LOG_TYPE_ERROR))
                      {
                        *(void *)std::string buf = v310;
                        sub_1000292E0((uint64_t)&__p);
                        v230 = &__p;
                        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                          v230 = (std::string *)__p.__r_.__value_.__r.__words[0];
                        }
                        LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v230;
                        _os_log_error_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, "No dict under bundles with key %{public}s ", (uint8_t *)&__str, 0xCu);
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                        {
                          CFMutableDictionaryRef v231 = (CFMutableDictionaryRef)__p.__r_.__value_.__r.__words[0];
                          goto LABEL_538;
                        }
                      }
                    }
                    sub_100057D78(&v307);
                  }
                  else
                  {
                    v228 = *key;
                    if (os_log_type_enabled(*key, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
                      _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_DEFAULT, "#N No bundleMatchEntry in BundleMap", (uint8_t *)&__p, 2u);
                    }
                  }
                  sub_1000558F4((const void **)&v310);
LABEL_541:
                  sub_100057D78((const void **)&v311);
LABEL_542:
                  if (SHIBYTE(v313) < 0) {
                    operator delete(v312[0]);
                  }
LABEL_544:
                  sub_1000558F4((const void **)&v315);
                  sub_1000577C4(&v316);
LABEL_545:
                  sub_100057D78((const void **)&v318);
                  if (++v79 == v297)
                  {
LABEL_546:
                    sub_10055E1FC((uint64_t)&__p, a4);
                    v339[1] = v77;
                    v339[2] = v291;
                    atomic_fetch_add_explicit(v291 + 1, 1uLL, memory_order_relaxed);
                    operator new();
                  }
                  goto LABEL_135;
                }
              }
            }
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__p, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = __str;
          }
          goto LABEL_217;
        }
      }
      else
      {
        uint64_t v107 = 0;
      }
      std::mutex::unlock(v100);
      long long v106 = 0;
      char v108 = 1;
      goto LABEL_195;
    }
  }
  v281 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v281, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v281, OS_LOG_TYPE_ERROR, "Cannot find bundle match criteria in the device info", (uint8_t *)&__p, 2u);
  }
  memset(v319, 0, sizeof(v319));
  uint64_t v282 = *(void *)(a4 + 24);
  if (!v282) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, CFDictionaryRef *))(*(void *)v282 + 48))(v282, v319);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v319;
  sub_10055D640((void ***)&__p);
  sub_100057D78((const void **)&v321);
  sub_100057D78((const void **)&v322);
  return sub_100057D78(&v324);
}

void sub_100E5AB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,std::__shared_weak_count *a24,NSObject *group,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,dispatch_group_t object,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,const void *a51,const void *a52,const void *a53,const void *a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61,const void *a62,const void *a63)
{
  xpc_object_t v76 = (void *)STACK[0x230];
  if (STACK[0x230])
  {
    STACK[0x238] = (unint64_t)v76;
    operator delete(v76);
  }
  xpc_object_t v77 = (void *)STACK[0x250];
  if (STACK[0x250])
  {
    STACK[0x258] = (unint64_t)v77;
    operator delete(v77);
  }
  CFIndex v78 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    STACK[0x288] = (unint64_t)v78;
    operator delete(v78);
  }
  sub_1000558F4((const void **)&STACK[0x278]);
  if (*(char *)(v74 - 105) < 0) {
    operator delete(*(void **)(v74 - 128));
  }
  if (*(char *)(v74 - 169) < 0) {
    operator delete(*(void **)(v74 - 192));
  }
  sub_1000558F4((const void **)(v74 - 208));
  sub_1000558F4(&a53);
  sub_100057D78(&a51);
  sub_100057D78(&a52);
  sub_100057D78(&a54);
  if (a60 < 0) {
    operator delete(a55);
  }
  sub_1000558F4(&a62);
  sub_1000577C4(&a63);
  sub_100057D78(&a65);
  sub_10005CD2C((uint64_t)&a73, (char *)a74);
  sub_10004D2C8(a24);
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  sub_100057D78(&a70);
  sub_100057D78(&a71);
  sub_100057D78(&a72);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5B250(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  sub_1000577C4((const void **)(a1 + 16));
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    long long v4 = *(NSObject **)(a1 + 8);
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void sub_100E5B2B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E5B2EC(uint64_t a1)
{
}

uint64_t sub_100E5B308(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E5B34C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100E5B378(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(*(void *)v1 + 80));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  void *v3 = off_101A634E8;
  v3[1] = v2;
  v3[2] = sub_100E580D0;
  v3[3] = 0;
  v11[3] = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p);
  }
  sub_1000E3958(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100E5B480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1000E3958(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100E5B4DC()
{
}

__n128 sub_100E5B4F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A634E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100E5B544(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A634E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E5B57C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100E5B5C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5B604()
{
}

uint64_t *sub_100E5B610(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFTypeID v26 = a1;
  uint64_t v27 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100058198(&v28, (const void **)(v1 + 8));
  sub_10055E1FC((uint64_t)v41, v1 + 16);
  if (v28) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    long long v4 = (std::__shared_weak_count *)operator new(0x30uLL);
    v4->__shared_owners_ = 0;
    v4->__shared_weak_owners_ = 0;
    v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3880;
    v4[1].__vftable = 0;
    BOOL v5 = v4 + 1;
    v4[1].__shared_owners_ = 0;
    v4[1].__shared_weak_owners_ = 0;
    uint64_t v6 = dispatch_group_create();
    sub_100058198((const void **)&theDict, &v28);
    CFTypeID v32 = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    int v33 = v4 + 1;
    long long v34 = v4;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v49 = 0;
    uint64_t v7 = operator new(0x20uLL);
    void *v7 = off_101A63568;
    v7[1] = v6;
    CFTypeID v32 = 0;
    void v7[2] = v5;
    v7[3] = v4;
    int v33 = 0;
    long long v34 = 0;
    long long v49 = v7;
    CFTypeRef cf = 0;
    sub_100058140(&cf, (const void **)(v2 + 144));
    if (cf) {
      CFDictionaryRef v8 = sub_100080778;
    }
    else {
      CFDictionaryRef v8 = 0;
    }
    if (v8)
    {
      CFTypeID v9 = (os_log_t *)(v2 + 40);
      char v10 = *(std::__shared_weak_count **)(v2 + 88);
      CFTypeID v29 = *(NSObject **)(v2 + 80);
      uint64_t v30 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v11 = sub_1006CE940((os_log_t *)(v2 + 40), (uint64_t)&v29, (uint64_t)theDict, 1, 2);
      if (v30) {
        sub_10004D2C8(v30);
      }
      if ((v11 & 1) == 0)
      {
        CFArrayRef v20 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I CarrierBundles versions format 2 section failed verification", buf, 2u);
        }
        *(void *)std::string buf = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        CFTypeID v21 = v49;
        if (!v49) {
          sub_10007B600();
        }
        goto LABEL_46;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CarrierBundles");
      CFDictionaryRef v13 = Value;
      if (Value)
      {
        CFTypeID v14 = CFGetTypeID(Value);
        if (v14 == CFDictionaryGetTypeID())
        {
          key = 0;
          sub_1006CED64((capabilities::ct *)(v2 + 80), &key);
          if (key) {
            CFTypeID v15 = sub_1000810B8;
          }
          else {
            CFTypeID v15 = 0;
          }
          if (!v15)
          {
            *(void *)std::string buf = 0;
            uint64_t v43 = 0;
            uint64_t v44 = 0;
            if (!v49) {
              sub_10007B600();
            }
            (*(void (**)(void *, uint8_t *))(*v49 + 48))(v49, buf);
            v50[0] = (void **)buf;
            sub_10055D640(v50);
            goto LABEL_43;
          }
          char v16 = CFDictionaryGetValue(v13, key);
          uint64_t v17 = v16;
          if (v16 && (CFTypeID v18 = CFGetTypeID(v16), v18 == CFDictionaryGetTypeID()))
          {
            long long v38 = v17;
            CFRetain(v17);
          }
          else
          {
            uint64_t v17 = 0;
            long long v38 = 0;
          }
          if (v17) {
            CFIndex v22 = sub_100080778;
          }
          else {
            CFIndex v22 = 0;
          }
          if (v22)
          {
            int v37 = v17;
            if (v17) {
              CFRetain(v17);
            }
            CFTypeRef v36 = cf;
            if (cf) {
              CFRetain(cf);
            }
            sub_10055E1FC((uint64_t)v50, (uint64_t)v48);
            long long v45 = 0;
            uint64_t v23 = operator new(0x28uLL);
            void *v23 = off_101A63678;
            sub_10055E2EC((uint64_t)(v23 + 1), (uint64_t)v50);
            long long v45 = v23;
            sub_100E583E0(v2, &v37, (CFDictionaryRef *)&v36, (uint64_t)buf);
            sub_10055D77C(buf);
            sub_10055D77C(v50);
            sub_100057D78(&v36);
            sub_100057D78(&v37);
            sub_100057D78(&v38);
LABEL_43:
            sub_1000558F4((const void **)&key);
            goto LABEL_47;
          }
          sub_100057D78(&v38);
          sub_1000558F4((const void **)&key);
        }
      }
    }
    *(void *)std::string buf = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    CFTypeID v21 = v49;
    if (!v49) {
      sub_10007B600();
    }
LABEL_46:
    (*(void (**)(void *, uint8_t *))(*v49 + 48))(v21, buf);
    v50[0] = (void **)buf;
    sub_10055D640(v50);
LABEL_47:
    sub_100057D78(&cf);
    sub_10055D77C(v48);
    sub_100057D78((const void **)&theDict);
    key = (void *)v28;
    if (v28) {
      CFRetain(v28);
    }
    sub_100058198(&v38, (const void **)(v2 + 144));
    CFTypeID v29 = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    uint64_t v30 = v4 + 1;
    uint64_t v31 = v4;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    std::string::size_type v51 = 0;
    uint64_t v24 = operator new(0x20uLL);
    void *v24 = off_101A635F8;
    v24[1] = v6;
    CFTypeID v29 = 0;
    v24[2] = v5;
    v24[3] = v4;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    std::string::size_type v51 = v24;
    sub_10055BBA4(v2, (const void **)&key, (CFDictionaryRef *)&v38, (uint64_t)v50);
    sub_10055D77C(v50);
    sub_100057D78(&v38);
    sub_100057D78((const void **)&key);
    sub_10055E1FC((uint64_t)buf, (uint64_t)v41);
    uint64_t v46 = v4 + 1;
    std::string::size_type v47 = v4;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    operator new();
  }
  CFArrayRef v19 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Failed to load version.xml from the server", buf, 2u);
  }
  sub_10055D77C(v41);
  sub_100057D78(&v28);
  sub_100E5BDD8(&v27);
  return sub_100046B58((uint64_t *)&v26);
}

void sub_100E5BC64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,int a41,__int16 a42,char a43,char a44,int a45,__int16 a46,char a47,char a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E5BDD0()
{
}

uint64_t *sub_100E5BDD8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10055D77C((void *)(v1 + 16));
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_100E5BE30(void *a1)
{
  *a1 = off_101A63568;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    long long v4 = a1[1];
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void sub_100E5BE94(void *a1)
{
  *a1 = off_101A63568;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    long long v4 = a1[1];
    if (v4) {
      dispatch_release(v4);
    }
  }

  operator delete();
}

void *sub_100E5BF18(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A63568;
  sub_100E5C0A8((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100E5BF6C(uint64_t a1, void *a2)
{
  *a2 = off_101A63568;
  return sub_100E5C0A8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100E5BF98(uint64_t a1)
{
}

void sub_100E5BFA0(void *a1)
{
  sub_100E5C104((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100E5BFDC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v2 = v4;
  long long v5 = *(_OWORD *)(a2 + 8);
  uint64_t v3 = v5;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_100E5C160(*(uint64_t **)(a1 + 16), *(void *)(*(void *)(a1 + 16) + 8), v2, v3, (v3 - v2) >> 4);
  uint64_t v6 = (void **)&v4;
  sub_10055D640(&v6);
}

void sub_100E5C040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10055D640(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5C05C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5C09C()
{
}

uint64_t sub_100E5C0A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)a2;
  *(void *)a1 = *(void *)a2;
  if (v4)
  {
    dispatch_retain(v4);
    if (*(void *)a1) {
      dispatch_group_enter(*(dispatch_group_t *)a1);
    }
  }
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100E5C104(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(void *)a1)
  {
    dispatch_group_leave(*(dispatch_group_t *)a1);
    uint64_t v3 = *(NSObject **)a1;
    if (*(void *)a1)
    {
      dispatch_release(v3);
    }
  }
}

uint64_t sub_100E5C160(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = a3;
  uint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    uint64_t v13 = *a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *a1) >> 4);
    if (v14 >> 60) {
      sub_10006A748();
    }
    uint64_t v15 = (a2 - v13) >> 4;
    uint64_t v16 = v10 - v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    v32[4] = v9;
    if (v17) {
      CFTypeID v18 = (char *)sub_10006A794(v9, v17);
    }
    else {
      CFTypeID v18 = 0;
    }
    uint64_t v27 = (const void **)&v18[16 * v15];
    v32[0] = v18;
    v32[1] = v27;
    v32[3] = &v18[16 * v17];
    uint64_t v28 = 16 * a5;
    CFTypeID v29 = &v27[2 * a5];
    do
    {
      uint64_t v30 = sub_1000584C8(v27, (const void **)v7);
      *((unsigned char *)v30 + 8) = *(unsigned char *)(v7 + 8);
      uint64_t v27 = v30 + 2;
      v7 += 16;
      v28 -= 16;
    }
    while (v28);
    v32[2] = v29;
    uint64_t v5 = sub_100E5C3BC(a1, v32, v5);
    sub_10055D72C((uint64_t)v32);
    return v5;
  }
  uint64_t v19 = v12 - a2;
  uint64_t v20 = (uint64_t)(v12 - a2) >> 4;
  if (v20 >= a5)
  {
    uint64_t v22 = a3 + 16 * a5;
LABEL_18:
    sub_100E5C328((uint64_t)a1, v5, v12, v5 + 16 * a5);
    sub_100E5C4D8(v7, v22, v5);
    return v5;
  }
  uint64_t v22 = a3 + 16 * v20;
  uint64_t v23 = *(void *)(v9 - 8);
  if (v22 != a4)
  {
    uint64_t v24 = a3 + 16 * v20;
    CFDictionaryRef v25 = *(const void ***)(v9 - 8);
    do
    {
      CFTypeID v26 = sub_1000584C8(v25, (const void **)v24);
      *((unsigned char *)v26 + 8) = *(unsigned char *)(v24 + 8);
      v24 += 16;
      CFDictionaryRef v25 = v26 + 2;
      v23 += 16;
    }
    while (v24 != a4);
  }
  a1[1] = v23;
  if (v19 >= 1) {
    goto LABEL_18;
  }
  return v5;
}

void sub_100E5C314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10055D72C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5C328(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 8);
  unint64_t v5 = a2 + v4 - a4;
  uint64_t v6 = v4;
  while (v5 < a3)
  {
    *(void *)uint64_t v6 = 0;
    *(void *)uint64_t v6 = *(void *)v5;
    *(void *)unint64_t v5 = 0;
    *(unsigned char *)(v6 + 8) = *(unsigned char *)(v5 + 8);
    v6 += 16;
    v5 += 16;
  }
  *(void *)(result + 8) = v6;
  if (v4 != a4)
  {
    uint64_t v7 = v4 - 16;
    uint64_t v8 = 16 * ((v4 - a4) >> 4);
    uint64_t v9 = a2 - 16;
    do
    {
      __n128 result = sub_100E5C478(v7, v9 + v8);
      v7 -= 16;
      v8 -= 16;
    }
    while (v8);
  }
  return result;
}

uint64_t sub_100E5C3BC(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t result = a2[1];
  uint64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v6 = a2[1];
    do
    {
      *(void *)(v6 - 16) = 0;
      v6 -= 16;
      uint64_t v8 = *(void *)(v7 - 16);
      v7 -= 16;
      *(void *)uint64_t v6 = v8;
      *(void *)uint64_t v7 = 0;
      *(unsigned char *)(v6 + 8) = *(unsigned char *)(v7 + 8);
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v9 = a1[1];
  uint64_t v10 = a2[2];
  if (v9 != a3)
  {
    do
    {
      *(void *)uint64_t v10 = 0;
      *(void *)uint64_t v10 = *(void *)a3;
      *(void *)a3 = 0;
      *(unsigned char *)(v10 + 8) = *(unsigned char *)(a3 + 8);
      v10 += 16;
      a3 += 16;
    }
    while (a3 != v9);
    uint64_t v6 = a2[1];
  }
  a2[2] = v10;
  uint64_t v11 = *a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100E5C478(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(const void **)a1;
    *(void *)a1 = 0;
    uint64_t v6 = v4;
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = 0;
    sub_1000577C4(&v6);
  }
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  return a1;
}

uint64_t sub_100E5C4D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    sub_100058470((const void **)a3, (const void **)v4);
    *(unsigned char *)(a3 + 8) = *(unsigned char *)(v4 + 8);
    a3 += 16;
    v4 += 16;
  }
  while (v4 != v5);
  return v5;
}

void *sub_100E5C544(void *a1)
{
  *a1 = off_101A635F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = a1[1];
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void sub_100E5C5A8(void *a1)
{
  *a1 = off_101A635F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = a1[1];
    if (v4) {
      dispatch_release(v4);
    }
  }

  operator delete();
}

void *sub_100E5C62C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A635F8;
  sub_100E5C0A8((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100E5C680(uint64_t a1, void *a2)
{
  *a2 = off_101A635F8;
  return sub_100E5C0A8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100E5C6AC(uint64_t a1)
{
}

void sub_100E5C6B4(void *a1)
{
  sub_100E5C104((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100E5C6F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v2 = v4;
  long long v5 = *(_OWORD *)(a2 + 8);
  uint64_t v3 = v5;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_100E5C160(*(uint64_t **)(a1 + 16), *(void *)(*(void *)(a1 + 16) + 8), v2, v3, (v3 - v2) >> 4);
  uint64_t v6 = (void **)&v4;
  sub_10055D640(&v6);
}

void sub_100E5C754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10055D640(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5C770(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5C7B0()
{
}

void **sub_100E5C7BC(uint64_t a1)
{
  uint64_t v4 = (void *)a1;
  memset(v5, 0, sizeof(v5));
  sub_10055D914(v5, **(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 8), (uint64_t)(*(void *)(*(void *)(a1 + 32) + 8) - **(void **)(a1 + 32)) >> 4);
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, v5);
  uint64_t v6 = v5;
  sub_10055D640((void ***)&v6);
  return sub_10055E294(&v4);
}

void sub_100E5C854(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10055E294((void **)va);
  _Unwind_Resume(a1);
}

void *sub_100E5C880(void *a1)
{
  *a1 = off_101A63678;
  sub_10055D77C(a1 + 1);
  return a1;
}

void sub_100E5C8C4(void *a1)
{
  *a1 = off_101A63678;
  sub_10055D77C(a1 + 1);

  operator delete();
}

void *sub_100E5C928(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A63678;
  sub_10055E1FC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100E5C97C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5C990(uint64_t a1, void *a2)
{
  *a2 = off_101A63678;
  return sub_10055E1FC((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100E5C9BC(uint64_t a1)
{
  return sub_10055D77C((void *)(a1 + 8));
}

void sub_100E5C9C4(void *a1)
{
  sub_10055D77C(a1 + 1);

  operator delete(a1);
}

void sub_100E5CA00(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)a2;
  uint64_t v3 = v6;
  long long v7 = *(_OWORD *)(a2 + 8);
  uint64_t v4 = v7;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  memset(v8, 0, sizeof(v8));
  sub_10055D914(v8, v3, v4, (v4 - v3) >> 4);
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v5 + 48))(v5, v8);
  uint64_t v9 = v8;
  sub_10055D640((void ***)&v9);
  v8[0] = &v6;
  sub_10055D640((void ***)v8);
}

void sub_100E5CAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  *(void *)(v10 - 24) = &a10;
  sub_10055D640((void ***)(v10 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E5CAEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5CB2C()
{
}

uint64_t sub_100E5CB38(uint64_t a1)
{
  *(void *)a1 = off_101A636F8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  sub_1000577C4((const void **)(a1 + 24));
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 16);
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void sub_100E5CBB4(uint64_t a1)
{
  *(void *)a1 = off_101A636F8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  sub_1000577C4((const void **)(a1 + 24));
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 16);
    if (v4) {
      dispatch_release(v4);
    }
  }

  operator delete();
}

void *sub_100E5CC50(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_101A636F8;
  sub_100E5D174((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100E5CCA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5CCB8(uint64_t a1, void *a2)
{
  *a2 = off_101A636F8;
  return sub_100E5D174((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100E5CCE4(uint64_t a1)
{
}

void sub_100E5CCEC(void *a1)
{
  sub_100E5D248((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100E5CD28(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v3 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  unint64_t v4 = *((void *)a2 + 2);
  *(_DWORD *)uint64_t v28 = *((_DWORD *)a2 + 6);
  *(_DWORD *)&v28[3] = *(_DWORD *)(a2 + 27);
  int v6 = (char)a2[31];
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  long long v7 = (void *)*((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  *(_DWORD *)&v27[3] = *(_DWORD *)(a2 + 51);
  *(_DWORD *)uint64_t v27 = *((_DWORD *)a2 + 12);
  int v9 = (char)a2[55];
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  uint64_t v10 = *(void *)(a1 + 8);
  std::string __dst = 0;
  unint64_t v35 = 0;
  uint64_t v36 = 0;
  if (v6 < 0)
  {
    sub_10004FC84(&__dst, v5, v4);
  }
  else
  {
    std::string __dst = v5;
    unint64_t v35 = v4;
    LODWORD(v36) = *(_DWORD *)v28;
    *(_DWORD *)((char *)&v36 + 3) = *(_DWORD *)&v28[3];
    HIBYTE(v36) = v6;
  }
  std::string __p = 0;
  unint64_t v32 = 0;
  uint64_t v33 = 0;
  if (v9 < 0)
  {
    sub_10004FC84(&__p, v7, v8);
  }
  else
  {
    std::string __p = v7;
    unint64_t v32 = v8;
    LODWORD(v33) = *(_DWORD *)v27;
    *(_DWORD *)((char *)&v33 + 3) = *(_DWORD *)&v27[3];
    HIBYTE(v33) = v9;
  }
  if (v3 == 4)
  {
    uint64_t v11 = *(NSObject **)(v10 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = a1 + 32;
      if (*(char *)(a1 + 55) < 0) {
        uint64_t v12 = *(void *)(a1 + 32);
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Update downloaded for bundle: %{public}s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v13 = sub_100559958(v10, a1 + 32, (std::string::size_type)&__dst, *(_DWORD *)(v10 + 160));
    int v14 = BYTE1(v13);
    if ((_BYTE)v13)
    {
      unsigned int v3 = 4;
    }
    else if ((v13 & 0xFF0000) != 0)
    {
      unsigned int v3 = 5;
    }
    else
    {
      unsigned int v3 = 7;
    }
  }
  else
  {
    int v14 = 0;
  }
  uint64_t v15 = *(uint64_t **)(a1 + 64);
  sub_1000584C8(&v29, (const void **)(a1 + 24));
  char v30 = v3;
  unint64_t v16 = v15[1];
  unint64_t v17 = v15[2];
  if (v16 >= v17)
  {
    uint64_t v19 = (uint64_t)(v16 - *v15) >> 4;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v21 = v17 - *v15;
    if (v21 >> 3 > v20) {
      unint64_t v20 = v21 >> 3;
    }
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v20;
    }
    std::string::size_type v40 = v15 + 2;
    uint64_t v23 = (char *)sub_10006A794((uint64_t)(v15 + 2), v22);
    uint64_t v24 = &v23[16 * v19];
    *(void *)&long long buf = v23;
    *((void *)&buf + 1) = v24;
    char v39 = &v23[16 * v25];
    *(void *)uint64_t v24 = 0;
    *(void *)uint64_t v24 = v29;
    CFTypeID v29 = 0;
    v24[8] = v30;
    long long v38 = v24 + 16;
    sub_10055D6C4(v15, &buf);
    uint64_t v18 = v15[1];
    sub_10055D72C((uint64_t)&buf);
  }
  else
  {
    *(void *)unint64_t v16 = 0;
    *(void *)unint64_t v16 = v29;
    CFTypeID v29 = 0;
    *(unsigned char *)(v16 + 8) = v3;
    uint64_t v18 = v16 + 16;
    v15[1] = v16 + 16;
  }
  v15[1] = v18;
  sub_1000577C4(&v29);
  int v26 = *(unsigned __int8 *)(a1 + 56);
  (*(void (**)(long long *__return_ptr))(**(void **)(v10 + 64) + 120))(&buf);
  sub_10092BC20(v10, v3, v26, (const char *)(a1 + 32), (void **)&buf, &__p, v14 != 0, 0);
  if (SHIBYTE(v38) < 0) {
    operator delete((void *)buf);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v36) < 0)
  {
    operator delete(__dst);
    if ((v9 & 0x80000000) == 0)
    {
LABEL_33:
      if ((v6 & 0x80000000) == 0) {
        return;
      }
LABEL_37:
      operator delete(v5);
      return;
    }
  }
  else if ((v9 & 0x80000000) == 0)
  {
    goto LABEL_33;
  }
  operator delete(v7);
  if (v6 < 0) {
    goto LABEL_37;
  }
}

void sub_100E5D088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
  {
    operator delete(__p);
    if ((v33 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((v33 & 0x80000000) == 0)
  {
LABEL_3:
    if ((v32 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  operator delete(v31);
  if ((v32 & 0x80000000) == 0) {
LABEL_5:
  }
    _Unwind_Resume(a1);
LABEL_4:
  operator delete(v30);
  goto LABEL_5;
}

uint64_t sub_100E5D128(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5D168()
{
}

uint64_t sub_100E5D174(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(NSObject **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  sub_1000584C8((const void **)(a1 + 16), (const void **)(a2 + 16));
  int v6 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)int v6 = v7;
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  uint64_t v8 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100E5D21C(_Unwind_Exception *a1)
{
  sub_1000577C4(v2);
  unint64_t v4 = *(NSObject **)(v1 + 8);
  if (v4)
  {
    dispatch_group_leave(v4);
    uint64_t v5 = *(NSObject **)(v1 + 8);
    if (v5) {
      dispatch_release(v5);
    }
  }
  _Unwind_Resume(a1);
}

void sub_100E5D248(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  sub_1000577C4((const void **)(a1 + 16));
  unsigned int v3 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    unint64_t v4 = *(NSObject **)(a1 + 8);
    if (v4)
    {
      dispatch_release(v4);
    }
  }
}

void **sub_100E5D2BC(uint64_t a1)
{
  unint64_t v4 = (void *)a1;
  memset(v5, 0, sizeof(v5));
  sub_10055D914(v5, **(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 8), (uint64_t)(*(void *)(*(void *)(a1 + 32) + 8) - **(void **)(a1 + 32)) >> 4);
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, v5);
  int v6 = v5;
  sub_10055D640((void ***)&v6);
  return sub_10055E294(&v4);
}

void sub_100E5D354(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10055E294((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5D380(uint64_t a1)
{
  *(void *)a1 = off_101A63778;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_10055E178((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100E5D3F4(uint64_t a1)
{
  *(void *)a1 = off_101A63778;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_10055E178((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100E5D488(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x70uLL);
  void *v2 = off_101A63778;
  sub_100E5D880((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100E5D4DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5D4F0(uint64_t a1, void *a2)
{
  *a2 = off_101A63778;
  return sub_100E5D880((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100E5D51C(uint64_t a1)
{
}

void sub_100E5D524(void *a1)
{
  sub_10055EB44((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100E5D560(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(NSObject **)(v3 + 40);
  if (*a2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = a1 + 64;
      if (*(char *)(a1 + 87) < 0) {
        uint64_t v5 = *(void *)(a1 + 64);
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Update has been successfully downloaded at %{public}s", buf, 0xCu);
    }
    char v6 = 4;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to download and save the update", buf, 2u);
    }
    char v6 = 6;
  }
  sub_10055E430((uint64_t)buf, a1 + 32);
  char v10 = v6;
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(v11, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    *(_OWORD *)uint64_t v11 = *(_OWORD *)(a1 + 64);
    v11[2] = *(void **)(a1 + 80);
  }
  if (*(char *)(a1 + 111) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 88), *(void *)(a1 + 96));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 88);
    __p[2] = *(void **)(a1 + 104);
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(v3 + 8));
  operator new();
}

void sub_100E5D7E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_10055E178(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100E5D834(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E5D874()
{
}

uint64_t sub_100E5D880(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10055E430(a1 + 24, a2 + 24);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  char v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)char v6 = v7;
  }
  return a1;
}

void sub_100E5D93C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v3);
  }
  sub_10055E178(v2);
  long long v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100E5D97C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  sub_10055ED08((uint64_t)v6, (unsigned char *)(v1 + 32), (long long *)(v1 + 40), (long long *)(v1 + 64));
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 48))(v2, v6);
  if (v10 < 0) {
    operator delete(__p);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  sub_10055EC9C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100E5DA24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void sub_100E5DA68(uint64_t a1)
{
  uint64_t v8 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v5 = 0u;
  abm::Overrides::Overrides((abm::Overrides *)&v5);
  LOBYTE(v8) = 0;
  Registry::getServerConnection((uint64_t *)&v4, *(Registry **)(a1 + 8));
  long long v2 = v4;
  long long v4 = 0uLL;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  long long v6 = v2;
  if (v3)
  {
    sub_10004D2C8(v3);
    if (*((void *)&v4 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v4 + 1));
    }
  }
  getprogname();
  abm::InitServer();
}

void sub_100E5DB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100E5DB2C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100E5DB2C(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[1];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100E5DB74(abm **a1@<X8>)
{
  long long v2 = (abm *)dispatch_group_create();
  *a1 = v2;
  abm::ShutdownServer(v2, v3);
}

void sub_100E5DBA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E5DBBC(abm **a1@<X8>)
{
  long long v2 = (abm *)dispatch_group_create();
  *a1 = v2;
  abm::StartServer(v2, v3);
}

void sub_100E5DBEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E5DC04(abm **a1@<X8>)
{
  long long v2 = (abm *)dispatch_group_create();
  *a1 = v2;
  abm::StopServer(v2, v3);
}

void sub_100E5DC34(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E5DC4C(uint64_t a1, os_log_t *a2)
{
  long long v2 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Action: fixed to use ABM", v3, 2u);
  }
}

void sub_100E5DCAC(BasebandModeAction *this)
{
  *(void *)this = off_101A637F8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  BasebandModeAction::~BasebandModeAction(this);
}

void sub_100E5DD08(BasebandModeAction *this)
{
  *(void *)this = off_101A637F8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BasebandModeAction::~BasebandModeAction(this);

  operator delete();
}

void sub_100E5E0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000F25E0((uint64_t *)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  _Unwind_Resume(a1);
}

void sub_100E5E4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10030D458((uint64_t *)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  _Unwind_Resume(a1);
}

void sub_100E5E8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100060644((uint64_t *)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  _Unwind_Resume(a1);
}

void sub_100E5EB94(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E5EF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100060644((uint64_t *)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  _Unwind_Resume(a1);
}

void sub_100E5F5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  sub_1002F1208((uint64_t)&a50);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

void sub_100E5FACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v46);
  }

  _Unwind_Resume(a1);
}

void sub_100E5FE1C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E605F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  sub_1002F1208((uint64_t)&a50);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

void sub_100E60D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  sub_1002F1208((uint64_t)&a27);
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v47);
  }

  _Unwind_Resume(a1);
}

void sub_100E613E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_1002F1208((uint64_t)&a28);
  if ((a10 & 1) == 0) {
    sub_10004D2C8(v48);
  }

  _Unwind_Resume(a1);
}

void sub_100E618CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10030D4DC((uint64_t *)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100E61954(uint64_t a1)
{
  return a1;
}

void sub_100E61988(uint64_t a1)
{
  operator delete();
}

void *sub_100E619DC(uint64_t a1)
{
  long long v2 = operator new(0x18uLL);
  void *v2 = off_101A63880;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100E61A40(uint64_t a1, void *a2)
{
  *a2 = off_101A63880;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100E61A98(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 8);
}

void sub_100E61AD4(id *a1)
{
  operator delete(a1);
}

void sub_100E61B18(uint64_t a1, _WORD *a2)
{
  if ((unsigned __int16)*a2 > 0xFFu)
  {
    +[NSNumber numberWithBool:*a2 != 0];
    id v7 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 8);
    if (v3)
    {
      [v3 getLogContext];
      char v4 = v9;
    }
    else
    {
      char v4 = 0;
      *(void *)long long buf = 0;
      uint64_t v9 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No private network sim found for slot", buf, 2u);
    }
    uint64_t v5 = *(void *)(a1 + 16);
    long long v6 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v5 + 16))(v5, 0, v6);
  }
}

void sub_100E61C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E61C70(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A638E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E61CB0()
{
  return &off_101A638E0;
}

uint64_t sub_100E61CBC(uint64_t a1)
{
  return a1;
}

void sub_100E61CF0(uint64_t a1)
{
  operator delete();
}

void *sub_100E61D44(uint64_t a1)
{
  long long v2 = operator new(0x18uLL);
  void *v2 = off_101A63900;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100E61DA8(uint64_t a1, void *a2)
{
  *a2 = off_101A63900;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100E61E00(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 8);
}

void sub_100E61E3C(id *a1)
{
  operator delete(a1);
}

void sub_100E61E80(uint64_t a1, int *a2)
{
  if (*((unsigned char *)a2 + 4))
  {
    int v5 = *a2;
    id v8 = (id)objc_opt_new();
    [v8 setIsPrivateNetworkSIM:v5 != 0];
    [v8 setIsPrivateNetworkPreferredOverWifi:(v5 & 0xFF00) != 0];
    [v8 setIsPrivateNetworkModeEnabled:(*(void *)&v5 & 0xFF0000) != 0];
    [v8 setHideDataRoaming:(v5 & 0xFF000000) != 0];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 8);
    if (v3)
    {
      [v3 getLogContext];
      char v4 = v10;
    }
    else
    {
      char v4 = 0;
      *(void *)long long buf = 0;
      char v10 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No private network sim found for slot", buf, 2u);
    }
    uint64_t v6 = *(void *)(a1 + 16);
    id v7 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v7);
  }
}

void sub_100E61FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E62010(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63970)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62050()
{
  return &off_101A63970;
}

uint64_t sub_100E6205C(uint64_t a1)
{
  return a1;
}

void sub_100E62088(uint64_t a1)
{
  operator delete();
}

void *sub_100E620D4(uint64_t a1)
{
  long long v2 = operator new(0x10uLL);
  void *v2 = off_101A63990;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E6212C(uint64_t a1, void *a2)
{
  *a2 = off_101A63990;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E62174(uint64_t a1)
{
}

void sub_100E6217C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100E621B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100E621D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A639F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62210()
{
  return &off_101A639F0;
}

uint64_t sub_100E6221C(uint64_t a1)
{
  return a1;
}

void sub_100E62248(uint64_t a1)
{
  operator delete();
}

void *sub_100E62294(uint64_t a1)
{
  long long v2 = operator new(0x10uLL);
  void *v2 = off_101A63A10;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E622EC(uint64_t a1, void *a2)
{
  *a2 = off_101A63A10;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E62334(uint64_t a1)
{
}

void sub_100E6233C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100E62378(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100E62390(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63A70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E623D0()
{
  return &off_101A63A70;
}

uint64_t sub_100E623DC(uint64_t a1)
{
  return a1;
}

void sub_100E62408(uint64_t a1)
{
  operator delete();
}

void *sub_100E62454(uint64_t a1)
{
  long long v2 = operator new(0x10uLL);
  void *v2 = off_101A63A90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E624AC(uint64_t a1, void *a2)
{
  *a2 = off_101A63A90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E624F4(uint64_t a1)
{
}

void sub_100E624FC(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100E62538(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100E6254C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63AF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E6258C()
{
  return &off_101A63AF0;
}

uint64_t sub_100E62598(uint64_t a1)
{
  return a1;
}

void sub_100E625C4(uint64_t a1)
{
  operator delete();
}

void *sub_100E62610(uint64_t a1)
{
  long long v2 = operator new(0x10uLL);
  void *v2 = off_101A63B10;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E62668(uint64_t a1, void *a2)
{
  *a2 = off_101A63B10;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E626B0(uint64_t a1)
{
}

void sub_100E626B8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100E626F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100E62708(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63B70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62748()
{
  return &off_101A63B70;
}

uint64_t sub_100E62754(uint64_t a1)
{
  return a1;
}

void sub_100E62780(uint64_t a1)
{
  operator delete();
}

void *sub_100E627CC(uint64_t a1)
{
  long long v2 = operator new(0x10uLL);
  void *v2 = off_101A63B90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E62824(uint64_t a1, void *a2)
{
  *a2 = off_101A63B90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E6286C(uint64_t a1)
{
}

void sub_100E62874(id *a1)
{
  operator delete(a1);
}

void sub_100E628B0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100E62914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E62928(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63BF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62968()
{
  return &off_101A63BF0;
}

uint64_t sub_100E62974(uint64_t a1)
{
  return a1;
}

void sub_100E629A0(uint64_t a1)
{
  operator delete();
}

void *sub_100E629EC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A63C10;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E62A44(uint64_t a1, void *a2)
{
  *a2 = off_101A63C10;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E62A8C(uint64_t a1)
{
}

void sub_100E62A94(id *a1)
{
  operator delete(a1);
}

void sub_100E62AD0(uint64_t a1, void *a2)
{
  if ((*a2 & 0xFF00000000) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *a2 - 1;
    if (v3 < 5) {
      uint64_t v4 = v3 + 1;
    }
    else {
      uint64_t v4 = 0;
    }
    id v6 = +[NSError errorWithDomain:&stru_101AC1B28 code:v4 userInfo:0];
    (*(void (**)(uint64_t))(v2 + 16))(v2);
  }
  else
  {
    int v5 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
    v5();
  }
}

void sub_100E62B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E62B9C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63C70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62BDC()
{
  return &off_101A63C70;
}

uint64_t sub_100E62BE8(uint64_t a1)
{
  return a1;
}

void sub_100E62C14(uint64_t a1)
{
  operator delete();
}

void *sub_100E62C60(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A63C90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E62CB8(uint64_t a1, void *a2)
{
  *a2 = off_101A63C90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E62D00(uint64_t a1)
{
}

void sub_100E62D08(id *a1)
{
  operator delete(a1);
}

void sub_100E62D44(uint64_t a1, void *a2)
{
  if ((*a2 & 0xFF00000000) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *a2 - 1;
    if (v3 < 5) {
      uint64_t v4 = v3 + 1;
    }
    else {
      uint64_t v4 = 0;
    }
    id v6 = +[NSError errorWithDomain:&stru_101AC1B28 code:v4 userInfo:0];
    (*(void (**)(uint64_t))(v2 + 16))(v2);
  }
  else
  {
    int v5 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
    v5();
  }
}

void sub_100E62DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E62E10(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63CF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E62E50()
{
  return &off_101A63CF0;
}

uint64_t sub_100E62E5C(uint64_t a1)
{
  return a1;
}

void sub_100E62E88(uint64_t a1)
{
  operator delete();
}

void *sub_100E62ED4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A63D10;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100E62F2C(uint64_t a1, void *a2)
{
  *a2 = off_101A63D10;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100E62F74(uint64_t a1)
{
}

void sub_100E62F7C(id *a1)
{
  operator delete(a1);
}

void sub_100E62FB8(uint64_t a1, void *a2)
{
  if ((*a2 & 0xFF00000000) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *a2 - 1;
    if (v3 < 5) {
      uint64_t v4 = v3 + 1;
    }
    else {
      uint64_t v4 = 0;
    }
    id v6 = +[NSError errorWithDomain:&stru_101AC1B28 code:v4 userInfo:0];
    (*(void (**)(uint64_t))(v2 + 16))(v2);
  }
  else
  {
    int v5 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
    v5();
  }
}

void sub_100E63070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100E63084(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63D70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E630C4()
{
  return &off_101A63D70;
}

uint64_t sub_100E630D0(uint64_t a1)
{
  return a1;
}

void sub_100E63104(uint64_t a1)
{
  operator delete();
}

void *sub_100E63158(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A63D90;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100E631BC(uint64_t a1, void *a2)
{
  *a2 = off_101A63D90;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100E63214(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100E63250(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100E63294(uint64_t a1, long long *a2)
{
  LOBYTE(v14) = 0;
  char v20 = 0;
  if (*((unsigned char *)a2 + 64))
  {
    unsigned __int8 v16 = 0;
    if (*((unsigned char *)a2 + 24))
    {
      long long v14 = *a2;
      uint64_t v15 = *((void *)a2 + 2);
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      *(void *)a2 = 0;
      unsigned __int8 v16 = 1;
    }
    LOBYTE(v17) = 0;
    unsigned __int8 v19 = 0;
    if (*((unsigned char *)a2 + 56))
    {
      long long v17 = a2[2];
      uint64_t v18 = *((void *)a2 + 6);
      *((void *)a2 + 5) = 0;
      *((void *)a2 + 6) = 0;
      *((void *)a2 + 4) = 0;
      unsigned __int8 v19 = 1;
    }
    char v20 = 1;
    uint64_t v3 = objc_opt_new();
    int v4 = v16;
    if (v16)
    {
      if (v15 >= 0) {
        int v5 = &v14;
      }
      else {
        int v5 = (long long *)v14;
      }
      id v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5, v14, v15);
    }
    else
    {
      id v6 = 0;
    }
    objc_msgSend(v3, "setCsgNetworkIdentifier:", v6, (void)v14);
    if (v4) {

    }
    int v9 = v19;
    if (v19)
    {
      if (v18 >= 0) {
        char v10 = &v17;
      }
      else {
        char v10 = (long long *)v17;
      }
      uint64_t v11 = +[NSString stringWithUTF8String:v10];
    }
    else
    {
      uint64_t v11 = 0;
    }
    [v3 setNetworkIdentifier:v11];
    if (v9) {

    }
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    id v7 = *(void **)(a1 + 8);
    if (v7)
    {
      [v7 getLogContext];
      id v8 = v22;
    }
    else
    {
      id v8 = 0;
      *(void *)long long buf = 0;
      unint64_t v22 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No private network sim found for slot", buf, 2u);
    }
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v3 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 6, 0, (void)v14);
    (*(void (**)(uint64_t, void, void *))(v12 + 16))(v12, 0, v3);
  }

  return sub_100335E2C((uint64_t)&v14);
}

void sub_100E634B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100335E2C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100E634F0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A63E00)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E63530()
{
  return &off_101A63E00;
}

void sub_100E6353C()
{
}

void sub_100E63564()
{
}

uint64_t sub_100E635A0@<X0>(dispatch_object_t *a1@<X1>, void *a2@<X8>)
{
  a2[1] = 0;
  a2[2] = 0;
  *a2 = a2 + 1;
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v3 = v6;
  if (v6 != v7)
  {
    while (1)
    {
      uint64_t result = v8(*v3);
      if (result) {
        break;
      }
      if (++v3 == v7)
      {
        uint64_t v3 = v7;
        break;
      }
    }
    if (v3 != v7)
    {
      if (*a1) {
        dispatch_retain(*a1);
      }
      sub_1003B7BD4(&v5);
    }
  }
  return result;
}

void sub_100E63750(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100E63798(CellMonitorFactoryInterface *this)
{
  *(void *)this = off_101A63E20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CellMonitorFactoryInterface::~CellMonitorFactoryInterface(this);
}

void sub_100E637F4(CellMonitorFactoryInterface *this)
{
  *(void *)this = off_101A63E20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CellMonitorFactoryInterface::~CellMonitorFactoryInterface(this);

  operator delete();
}

void sub_100E63864(void ***a1)
{
  *a1 = (void **)off_101A63E68;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_100E638BC(void ***a1)
{
  *a1 = (void **)off_101A63E68;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

uint64_t sub_100E63928(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  long long v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  char v6 = *(unsigned char *)(a1 + 24);
  if (v6)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 16));
    char v6 = *(unsigned char *)(a1 + 24);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 20));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100E639BC(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 > 0xFFFFFFFFFFFFFFF5 || v23 + 10 > v24)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v28 = 0;
          if (v24 <= v23) {
            unint64_t v24 = *((void *)this + 1);
          }
          while (1)
          {
            if (v24 == v23)
            {
              LODWORD(v28) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_52;
            }
            unint64_t v37 = v23 + 1;
            char v38 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v37;
            v28 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v35 += 7;
            unint64_t v23 = v37;
            BOOL v14 = v36++ > 8;
            if (v14)
            {
LABEL_46:
              LODWORD(v28) = 0;
              goto LABEL_52;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v28) = 0;
          }
        }
        else
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          while (1)
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
            if (v14) {
              goto LABEL_46;
            }
          }
        }
LABEL_52:
        *(_DWORD *)(a1 + 16) = v28;
      }
      else if (v20 == 2)
      {
        *(unsigned char *)(a1 + 24) |= 2u;
        unint64_t v31 = *((void *)this + 1);
        if (v31 >= *((void *)this + 2))
        {
          BOOL v34 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v32 = v31 + 1;
          int v33 = *(unsigned __int8 *)(*(void *)this + v31);
          *((void *)this + 1) = v32;
          BOOL v34 = v33 != 0;
        }
        *(unsigned char *)(a1 + 20) = v34;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100E63C9C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  char v5 = *(unsigned char *)(v3 + 24);
  if ((v5 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 20), 2u);
    char v5 = *(unsigned char *)(v3 + 24);
  }
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 16);
    return PB::Writer::writeVarInt(this, v6, 3u);
  }
  return result;
}

const void **sub_100E63D1C@<X0>(const __CFString *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  if (sub_100013084(a1, &v11, &v10)
    && (v11 ? (uint64_t v3 = sub_1000810B8) : (uint64_t v3 = 0), v3 && (v10 ? (v4 = sub_1000810B8) : (v4 = 0), v4)))
  {
    uint64_t v12 = 0;
    long long v13 = 0uLL;
    ctu::cf::assign();
    uint64_t v5 = v12;
    v14[0] = v13;
    *(void *)((char *)v14 + 7) = *(void *)((char *)&v13 + 7);
    char v6 = HIBYTE(v13);
    uint64_t v12 = 0;
    long long v13 = 0uLL;
    ctu::cf::assign();
    uint64_t v7 = v13;
    *(void *)(a2 + 24) = v12;
    *(void *)(a2 + 32) = v7;
    *(void *)(a2 + 39) = *(void *)((char *)&v13 + 7);
    LOBYTE(v7) = HIBYTE(v13);
    uint64_t v8 = v14[0];
    *(void *)a2 = v5;
    *(void *)(a2 + 8) = v8;
    *(void *)(a2 + 15) = *(void *)((char *)v14 + 7);
    *(unsigned char *)(a2 + 23) = v6;
    *(unsigned char *)(a2 + 47) = v7;
  }
  else
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
  sub_1000558F4(&v10);
  return sub_1000558F4(&v11);
}

void sub_100E63E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  sub_1000558F4((const void **)&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

const void **sub_100E63EA4@<X0>(uint64_t a1@<X8>)
{
  CFStringRef v4 = 0;
  CFStringRef v5 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v2 = v4;
    CFStringRef v4 = v5;
    CFStringRef v6 = v2;
    sub_1000558F4((const void **)&v6);
  }
  sub_100E63D1C(v4, a1);
  return sub_1000558F4((const void **)&v4);
}

void sub_100E63F1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

unint64_t *sub_100E63F30(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (unsigned char *)a1[1];
    do
    {
      char v8 = *(unsigned char *)(a2 + v6);
      unint64_t v9 = a1[2];
      if ((unint64_t)v7 >= v9)
      {
        unint64_t v11 = *a1;
        uint64_t v12 = &v7[-*a1];
        unint64_t v13 = (unint64_t)(v12 + 1);
        if ((uint64_t)(v12 + 1) < 0) {
          sub_10006A748();
        }
        unint64_t v14 = v9 - v11;
        if (2 * v14 > v13) {
          unint64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unsigned int v16 = (char *)operator new(v15);
        }
        else {
          unsigned int v16 = 0;
        }
        int v17 = &v12[(void)v16];
        char v18 = &v12[(void)v16];
        *char v18 = v8;
        unsigned int v10 = v18 + 1;
        if (v7 != (unsigned char *)v11)
        {
          unsigned __int8 v19 = &v7[~v11];
          do
          {
            char v20 = *--v7;
            (v19--)[(void)v16] = v20;
          }
          while (v7 != (unsigned char *)v11);
          uint64_t v7 = (unsigned char *)*a1;
          int v17 = v16;
        }
        *a1 = (unint64_t)v17;
        a1[1] = (unint64_t)v10;
        a1[2] = (unint64_t)&v16[v15];
        if (v7) {
          operator delete(v7);
        }
      }
      else
      {
        unsigned char *v7 = v8;
        unsigned int v10 = v7 + 1;
      }
      a1[1] = (unint64_t)v10;
      ++v6;
      uint64_t v7 = v10;
    }
    while (v6 != a3);
  }
  return a1;
}

unint64_t *sub_100E64054(unint64_t *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = *(void *)(a2 + 8);
    if (*(char *)(a2 + 23) >= 0)
    {
      uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
    }
    else
    {
      a2 = *(void *)a2;
      uint64_t v3 = v2;
    }
    return sub_100E63F30(result, a2, v3);
  }
  return result;
}

unint64_t *sub_100E6408C(unint64_t *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);

  return sub_100E63F30(a1, (uint64_t)BytePtr, Length);
}

uint64_t sub_100E640E8(uint64_t a1, CFDictionaryRef theDict)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  uint64_t v3 = a1 + 32;
  *(unsigned char *)(a1 + 56) = 0;
  if (theDict)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"imsi");
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFStringGetTypeID())
      {
        memset(v54, 0, sizeof(v54));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = 0uLL;
        uint64_t v53 = 0;
        sub_10008BE4C(a1, (long long *)__p);
        if (SHIBYTE(v53) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    uint64_t v7 = CFDictionaryGetValue(theDict, @"smsc");
    if (v7)
    {
      CFTypeID v8 = CFGetTypeID(v7);
      if (v8 == CFStringGetTypeID())
      {
        memset(v54, 0, sizeof(v54));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)v54;
        uint64_t v53 = *(void *)&v54[16];
        sub_10008BE4C(v3, (long long *)__p);
        if (SHIBYTE(v53) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(void *)(a1 + 112) = 0;
    *(_OWORD *)(a1 + 64) = 0u;
    unint64_t v9 = CFDictionaryGetValue(theDict, @"iwf-keyid");
    unsigned int v10 = v9;
    if (v9)
    {
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFStringGetTypeID()) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    *(void *)CFTypeID v54 = v12;
    sub_100013168((const void **)(a1 + 80), (CFTypeRef *)v54);
    unint64_t v13 = CFDictionaryGetValue(theDict, @"iwf-pubkey");
    unint64_t v14 = v13;
    if (v13)
    {
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 == CFDataGetTypeID()) {
        unsigned int v16 = v14;
      }
      else {
        unsigned int v16 = 0;
      }
    }
    else
    {
      unsigned int v16 = 0;
    }
    *(void *)CFTypeID v54 = v16;
    sub_10015E5D4((const void **)(a1 + 88), (CFTypeRef *)v54);
    int v17 = CFDictionaryGetValue(theDict, @"iwf-cn");
    char v18 = v17;
    if (v17)
    {
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 == CFStringGetTypeID()) {
        char v20 = v18;
      }
      else {
        char v20 = 0;
      }
    }
    else
    {
      char v20 = 0;
    }
    *(void *)CFTypeID v54 = v20;
    sub_100013168((const void **)(a1 + 96), (CFTypeRef *)v54);
    uint64_t v21 = CFDictionaryGetValue(theDict, @"iwf-cert");
    unint64_t v22 = v21;
    if (v21)
    {
      CFTypeID v23 = CFGetTypeID(v21);
      if (v23 == CFStringGetTypeID()) {
        unint64_t v24 = v22;
      }
      else {
        unint64_t v24 = 0;
      }
    }
    else
    {
      unint64_t v24 = 0;
    }
    *(void *)CFTypeID v54 = v24;
    sub_100013168((const void **)(a1 + 104), (CFTypeRef *)v54);
    uint64_t v25 = CFDictionaryGetValue(theDict, @"iwf-chain");
    char v26 = v25;
    if (v25)
    {
      CFTypeID v27 = CFGetTypeID(v25);
      if (v27 == CFArrayGetTypeID()) {
        uint64_t v28 = v26;
      }
      else {
        uint64_t v28 = 0;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    *(void *)CFTypeID v54 = v28;
    sub_1002824E4((const void **)(a1 + 112), (CFTypeRef *)v54);
    CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(theDict, @"contacts");
    CFArrayRef v30 = v29;
    if (v29 && (CFTypeID v31 = CFGetTypeID(v29), v31 == CFArrayGetTypeID()))
    {
      unint64_t Count = CFArrayGetCount(v30);
      int v33 = (std::__shared_weak_count *)operator new(0x30uLL);
      v33->__shared_owners_ = 0;
      v33->__shared_weak_owners_ = 0;
      v33->__vftable = (std::__shared_weak_count_vtbl *)off_101999A28;
      v33[1].__vftable = 0;
      BOOL v34 = (const void ***)&v33[1];
      v33[1].__shared_owners_ = 0;
      v33[1].__shared_weak_owners_ = 0;
      if (Count)
      {
        if (Count >> 61) {
          sub_10006A748();
        }
        p_uint64_t shared_weak_owners = &v33[1].__shared_weak_owners_;
        char v35 = (std::__shared_weak_count_vtbl *)sub_10004EF74((uint64_t)&v33[1].__shared_weak_owners_, Count);
        char v38 = v33[1].__vftable;
        uint64_t shared_owners = (std::__shared_weak_count_vtbl *)v33[1].__shared_owners_;
        if (shared_owners == v38)
        {
          int64x2_t v41 = vdupq_n_s64((unint64_t)shared_owners);
          char v39 = v35;
        }
        else
        {
          char v39 = v35;
          do
          {
            v39[-1].__on_zero_shared_weak = 0;
            char v39 = (std::__shared_weak_count_vtbl *)((char *)v39 - 8);
            on_zero_shared_weak = shared_owners[-1].__on_zero_shared_weak;
            uint64_t shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners - 8);
            v39->~__shared_weak_count = on_zero_shared_weak;
            shared_owners->~__shared_weak_count = 0;
          }
          while (shared_owners != v38);
          int64x2_t v41 = *(int64x2_t *)v34;
        }
        v33[1].__vftable = v39;
        v33[1].__shared_owners_ = (uint64_t)v35;
        *(int64x2_t *)&v54[8] = v41;
        uint64_t shared_weak_owners = v33[1].__shared_weak_owners_;
        v33[1].__shared_weak_owners_ = (uint64_t)v35 + 8 * v36;
        uint64_t v55 = shared_weak_owners;
        *(void *)CFTypeID v54 = v41.i64[0];
        sub_100083DDC((uint64_t)v54);
        for (CFIndex i = 0; i != Count; ++i)
        {
          *(void *)CFTypeID v54 = 0;
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v30, i);
          uint64_t v46 = ValueAtIndex;
          if (ValueAtIndex && (CFTypeID v47 = CFGetTypeID(ValueAtIndex), v47 == CFStringGetTypeID()))
          {
            *(void *)CFTypeID v54 = v46;
            CFRetain(v46);
            uint64_t v48 = *(void *)v54;
          }
          else
          {
            uint64_t v48 = 0;
            *(void *)CFTypeID v54 = 0;
          }
          if (v48) {
            long long v49 = sub_1000810B8;
          }
          else {
            long long v49 = 0;
          }
          if (v49) {
            sub_1000C06D8(v34, (const void **)v54);
          }
          sub_1000558F4((const void **)v54);
        }
      }
      char v42 = 0;
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      int v33 = 0;
      BOOL v34 = 0;
      char v42 = 1;
    }
    char v50 = *(std::__shared_weak_count **)(a1 + 72);
    *(void *)(a1 + 64) = v34;
    *(void *)(a1 + 72) = v33;
    if (v50) {
      sub_10004D2C8(v50);
    }
    if ((v42 & 1) == 0) {
      sub_10004D2C8(v33);
    }
  }
  else
  {
    *(void *)(a1 + 112) = 0;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
  }
  return a1;
}

void sub_100E645A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void **a9, const void **a10, uint64_t a11, const void **a12)
{
  sub_100044D00(v14);
  sub_1000558F4(a12);
  sub_1000558F4(a9);
  sub_100030068(a10);
  sub_1000558F4(v13);
  unsigned int v16 = *(std::__shared_weak_count **)(v12 + 72);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_1005EC5F8(v12);
  _Unwind_Resume(a1);
}

void sub_100E646AC(const void **a1, uint64_t a2, const void **a3)
{
  if (*a3) {
    CFTypeID v6 = sub_1000C06D0;
  }
  else {
    CFTypeID v6 = 0;
  }
  if (!v6)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFTypeID v8 = *a3;
      *a3 = Mutable;
      *(void *)&long long v40 = v8;
      sub_10005717C((const void **)&v40);
    }
  }
  sub_100057240((const void **)&v30, a3);
  unint64_t v9 = v30;
  if (v30) {
    unsigned int v10 = sub_1000C06D0;
  }
  else {
    unsigned int v10 = 0;
  }
  if (!v10)
  {
    CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    unint64_t v9 = v30;
    if (v11)
    {
      CFArrayRef v30 = v11;
      *(void *)&long long v40 = v9;
      sub_10005717C((const void **)&v40);
      unint64_t v9 = v30;
    }
  }
  if (*(unsigned char *)(a2 + 24))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v36 = *(void *)(a2 + 16);
    }
    if (SHIBYTE(v36) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v39 = v36;
    }
    char v42 = 0;
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(&v40, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v40 = *(_OWORD *)__p;
      uint64_t v41 = v39;
    }
    uint64_t v43 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v12 = v42;
      char v42 = v43;
      v32[0] = v12;
      sub_1000558F4((const void **)v32);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)v40);
    }
    unsigned int value = v42;
    char v42 = 0;
    sub_1000558F4((const void **)&v42);
    if (SHIBYTE(v39) < 0) {
      operator delete(__p[0]);
    }
    CFDictionarySetValue(v9, @"imsi", value);
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v36) < 0) {
      operator delete(__dst[0]);
    }
    unint64_t v9 = v30;
  }
  if (*(unsigned char *)(a2 + 56))
  {
    if (*(char *)(a2 + 55) < 0)
    {
      sub_10004FC84(v32, *(void **)(a2 + 32), *(void *)(a2 + 40));
    }
    else
    {
      *(_OWORD *)unint64_t v32 = *(_OWORD *)(a2 + 32);
      uint64_t v33 = *(void *)(a2 + 48);
    }
    if (SHIBYTE(v33) < 0)
    {
      sub_10004FC84(__p, v32[0], (unint64_t)v32[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v32;
      uint64_t v39 = v33;
    }
    unsigned int value = 0;
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(&v40, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v40 = *(_OWORD *)__p;
      uint64_t v41 = v39;
    }
    char v42 = 0;
    if (ctu::cf::convert_copy())
    {
      unint64_t v13 = value;
      unsigned int value = v42;
      uint64_t v43 = v13;
      sub_1000558F4((const void **)&v43);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)v40);
    }
    unint64_t v14 = value;
    BOOL v34 = value;
    unsigned int value = 0;
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v39) < 0) {
      operator delete(__p[0]);
    }
    CFDictionarySetValue(v9, @"smsc", v14);
    sub_1000558F4((const void **)&v34);
    if (SHIBYTE(v33) < 0) {
      operator delete(v32[0]);
    }
    unint64_t v9 = v30;
  }
  CFArrayRef v30 = 0;
  CFTypeID v31 = v9;
  if (&v31 != (__CFDictionary **)a3)
  {
    *(void *)&long long v40 = *a3;
    *a3 = v9;
    CFTypeID v31 = 0;
    sub_10005717C((const void **)&v40);
  }
  sub_10005717C((const void **)&v31);
  sub_10005717C((const void **)&v30);
  CFTypeID v15 = *(const void **)(a2 + 80);
  if (v15) {
    unsigned int v16 = sub_1000810B8;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16) {
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"iwf-keyid", v15);
  }
  int v17 = *(const void **)(a2 + 88);
  if (v17) {
    char v18 = sub_10008324C;
  }
  else {
    char v18 = 0;
  }
  if (v18) {
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"iwf-pubkey", v17);
  }
  CFTypeID v19 = *(const void **)(a2 + 96);
  if (v19) {
    char v20 = sub_1000810B8;
  }
  else {
    char v20 = 0;
  }
  if (v20) {
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"iwf-cn", v19);
  }
  uint64_t v21 = *(const void **)(a2 + 104);
  if (v21) {
    unint64_t v22 = sub_1000810B8;
  }
  else {
    unint64_t v22 = 0;
  }
  if (v22) {
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"iwf-cert", v21);
  }
  CFTypeID v23 = *(const void **)(a2 + 112);
  if (v23) {
    unint64_t v24 = sub_100083F10;
  }
  else {
    unint64_t v24 = 0;
  }
  if (v24) {
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"iwf-chain", v23);
  }
  if (*(void *)(a2 + 64))
  {
    __p[0] = 0;
    CFMutableArrayRef v25 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v25)
    {
      char v26 = __p[0];
      __p[0] = v25;
      *(void *)&long long v40 = v26;
      sub_1000440D4((const void **)&v40);
    }
    CFTypeID v27 = *(const void ****)(a2 + 64);
    uint64_t v28 = *v27;
    CFArrayRef v29 = v27[1];
    while (v28 != v29)
      CFArrayAppendValue((CFMutableArrayRef)__p[0], *v28++);
    CFDictionarySetValue((CFMutableDictionaryRef)*a3, @"contacts", __p[0]);
    sub_1000440D4((const void **)__p);
  }
  *a1 = *a3;
  *a3 = 0;
}

void sub_100E64B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10005717C((const void **)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100E64C7C(uint64_t a1)
{
  *(void *)a1 = off_101A63EB8;
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  sub_1001FEC70(*(void **)(a1 + 56));
  sub_10026D080(*(char **)(a1 + 32));
  sub_10012577C((const void **)(a1 + 8));
  return a1;
}

void sub_100E64CF0(SatMsg_ProvisioningXpc *a1)
{
  SatMsg_ProvisioningXpc::~SatMsg_ProvisioningXpc(a1);

  operator delete();
}

uint64_t sub_100E64D28(uint64_t a1)
{
  *(void *)a1 = off_101A63F98;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 360);
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v14 = (void **)(a1 + 328);
  sub_100E79514(&v14);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 320);
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFStringRef v4 = *(std::__shared_weak_count **)(a1 + 296);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10012577C((const void **)(a1 + 280));
  uint64_t v5 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  CFTypeID v6 = *(std::__shared_weak_count **)(a1 + 256);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 240);
  if (v7) {
    sub_10004D2C8(v7);
  }
  CFTypeID v8 = *(std::__shared_weak_count **)(a1 + 224);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_1001FEC70(*(void **)(a1 + 184));
  unint64_t v9 = *(std::__shared_weak_count **)(a1 + 168);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_1000346F8(a1 + 128, *(void **)(a1 + 136));
  sub_100399174(a1 + 104, *(void **)(a1 + 112));
  unsigned int v10 = *(NSObject **)(a1 + 80);
  if (v10) {
    dispatch_release(v10);
  }
  CFMutableDictionaryRef v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 56);
  if (v12) {
    sub_10004D2C8(v12);
  }
  SatMsg_ProvisioningXpc::~SatMsg_ProvisioningXpc((SatMsg_ProvisioningXpc *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100E64E78(uint64_t a1)
{
  sub_100E64D28(a1);

  operator delete();
}

void sub_100E64EB0()
{
}

void sub_100E6527C()
{
}

void sub_100E652AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
}

void *sub_100E6544C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  if (_os_feature_enabled_impl()) {
    sub_100E64EB0();
  }
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = off_101A64378;
  result[3] = off_101A63EF0;
  *a1 = result + 3;
  a1[1] = result;
  return result;
}

void sub_100E6550C(void *a1, long long *a2)
{
  long long v3 = *a2;
  uint64_t v5 = (char *)a1[42];
  unint64_t v4 = a1[43];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (char *)a1[41];
    uint64_t v8 = (v5 - v7) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      sub_10006A748();
    }
    long long v18 = *a2;
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11 >> 60) {
      sub_10006A7CC();
    }
    uint64_t v12 = (char *)operator new(16 * v11);
    unint64_t v13 = &v12[16 * v8];
    *(_OWORD *)unint64_t v13 = v18;
    if (*((void *)&v18 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v18 + 1) + 16), 1uLL, memory_order_relaxed);
      uint64_t v7 = (char *)a1[41];
      uint64_t v5 = (char *)a1[42];
    }
    unint64_t v14 = &v12[16 * v11];
    CFTypeID v6 = v13 + 16;
    if (v5 == v7)
    {
      a1[41] = v13;
      a1[42] = v6;
      a1[43] = v14;
    }
    else
    {
      do
      {
        long long v15 = *((_OWORD *)v5 - 1);
        v5 -= 16;
        *((_OWORD *)v13 - 1) = v15;
        v13 -= 16;
        *(void *)uint64_t v5 = 0;
        *((void *)v5 + 1) = 0;
      }
      while (v5 != v7);
      uint64_t v7 = (char *)a1[41];
      unsigned int v16 = (char *)a1[42];
      a1[41] = v13;
      a1[42] = v6;
      a1[43] = v14;
      while (v16 != v7)
      {
        int v17 = (std::__shared_weak_count *)*((void *)v16 - 1);
        if (v17) {
          std::__shared_weak_count::__release_weak(v17);
        }
        v16 -= 16;
      }
    }
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v5 = v3;
    if (*((void *)&v3 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v3 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    CFTypeID v6 = v5 + 16;
  }
  a1[42] = v6;
}

void sub_100E65650(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 328);
  if (v2 != *(void **)(a1 + 336))
  {
    while (1)
    {
      uint64_t v5 = (std::__shared_weak_count *)v2[1];
      if (!v5) {
        break;
      }
      CFTypeID v6 = std::__shared_weak_count::lock(v5);
      if (!v6 || !*v2 || *v2 == a2) {
        goto LABEL_8;
      }
      v2 += 2;
LABEL_19:
      sub_10004D2C8(v6);
      unint64_t v11 = *(void **)(a1 + 336);
LABEL_20:
      if (v2 == v11) {
        return;
      }
    }
    CFTypeID v6 = 0;
LABEL_8:
    uint64_t v7 = v2 + 2;
    uint64_t v8 = *(void **)(a1 + 336);
    if (v2 + 2 == v8)
    {
      unint64_t v11 = v2;
    }
    else
    {
      do
      {
        long long v9 = *(_OWORD *)v7;
        void *v7 = 0;
        v7[1] = 0;
        uint64_t v10 = (std::__shared_weak_count *)*(v7 - 1);
        *((_OWORD *)v7 - 1) = v9;
        if (v10) {
          std::__shared_weak_count::__release_weak(v10);
        }
        v7 += 2;
      }
      while (v7 != v8);
      unint64_t v11 = v7 - 2;
      uint64_t v7 = *(void **)(a1 + 336);
    }
    while (v7 != v11)
    {
      uint64_t v12 = (std::__shared_weak_count *)*(v7 - 1);
      if (v12) {
        std::__shared_weak_count::__release_weak(v12);
      }
      v7 -= 2;
    }
    *(void *)(a1 + 336) = v11;
    if (!v6) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
}

const void **sub_100E6573C(uint64_t a1, uint64_t a2)
{
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (v5 = *(void *)(a1 + 8), (CFTypeID v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  sub_100058DB0(&__p, "/cc/props/imsi_identity_ready");
  uint64_t v8 = operator new(0x28uLL);
  void *v8 = off_101A643C8;
  v8[1] = a1 + 104;
  void v8[2] = a1;
  v8[3] = v5;
  void v8[4] = v7;
  *(void *)&long long v198 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v195) < 0) {
    operator delete(__p);
  }
  long long v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v9 || (v10 = *(void *)(a1 + 8), (unint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v11;
  atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  sub_100058DB0(&__p, "/cc/props/smsc_address_available");
  unint64_t v13 = operator new(0x28uLL);
  void *v13 = off_101A64448;
  v13[1] = a1 + 128;
  v13[2] = a1;
  v13[3] = v10;
  v13[4] = v12;
  *(void *)&long long v198 = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  unint64_t v14 = (uint64_t *)SHIBYTE(v195);
  if ((v14 & 0x80000000) != 0) {
    operator delete(__p);
  }
  int v189 = 0;
  long long v15 = (Registry **)(a1 + 48);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 48));
  int v17 = ServiceMap;
  long long v18 = "8UStorage";
  CFTypeID v19 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    char v20 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      CFTypeID v19 = (const char *)v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v19;
  CFTypeID v23 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
  uint64_t v185 = a2;
  if (v23)
  {
    CFMutableArrayRef v25 = (os_unfair_lock_s *)v23[3];
    unint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    CFMutableArrayRef v25 = 0;
  }
  std::mutex::unlock(v17);
  unint64_t v24 = 0;
  char v26 = 1;
LABEL_17:
  sub_100083254(v25, @"bucket", @"SatMsg", 0, 2u, &__p);
  sub_1000842D0(&v189, (CFTypeRef *)&__p);
  sub_1000577C4((const void **)&__p);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (v189) {
    uint64_t v28 = sub_100081E58;
  }
  else {
    uint64_t v28 = 0;
  }
  if (v28)
  {
    *(_DWORD *)long long buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v189, v27);
    *(_DWORD *)(a1 + 204) = *(_DWORD *)buf != 0;
    *(unsigned char *)(a1 + 208) = 1;
  }
  else
  {
    CFArrayRef v29 = (uint64_t *)*(unsigned __int8 *)(a1 + 208);
    if (!*(unsigned char *)(a1 + 208)) {
      goto LABEL_76;
    }
  }
  CFArrayRef v30 = (os_log_t *)(a1 + 40);
  CFTypeID v31 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = "???";
    int v34 = *(_DWORD *)(a1 + 204);
    if (v34 == 1) {
      uint64_t v33 = "b1";
    }
    if (!v34) {
      uint64_t v33 = "b0";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I last known bucket ID: %s", buf, 0xCu);
  }
  std::string __p = 0;
  char v35 = (std::mutex *)Registry::getServiceMap(v32, *v15);
  uint64_t v36 = v35;
  unint64_t v37 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    char v38 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v39 = 5381;
    do
    {
      unint64_t v37 = (const char *)v39;
      unsigned int v40 = *v38++;
      uint64_t v39 = (33 * v39) ^ v40;
    }
    while (v40);
  }
  std::mutex::lock(v35);
  *(void *)long long buf = v37;
  uint64_t v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)buf);
  if (v41)
  {
    uint64_t v43 = (os_unfair_lock_s *)v41[3];
    char v42 = (std::__shared_weak_count *)v41[4];
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v36);
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v42);
      char v44 = 0;
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v43 = 0;
  }
  std::mutex::unlock(v36);
  char v42 = 0;
  char v44 = 1;
LABEL_39:
  sub_100083254(v43, @"SettledConfig", @"SatMsg", 0, 2u, &v192);
  sub_10004EFE4(&__p, (CFTypeRef *)&v192);
  sub_1000577C4((const void **)&v192);
  if ((v44 & 1) == 0) {
    sub_10004D2C8(v42);
  }
  if (__p) {
    long long v45 = sub_100080778;
  }
  else {
    long long v45 = 0;
  }
  if (!v45) {
    goto LABEL_75;
  }
  sub_100E7A274((const __CFUUID ***)buf, (Registry **)(a1 + 48), (const __CFDictionary *)__p, (os_log_t *)(a1 + 40));
  uint64_t v46 = *(std::__shared_weak_count **)(a1 + 224);
  CFTypeID v47 = *(uint64_t **)buf;
  *(_OWORD *)(a1 + 216) = *(_OWORD *)buf;
  if (v46)
  {
    sub_10004D2C8(v46);
    uint64_t v48 = *(uint64_t **)(a1 + 216);
    if (!v48) {
      goto LABEL_75;
    }
LABEL_49:
    long long v49 = (uint64_t *)v48[9];
    if (v49 == v48 + 10)
    {
LABEL_73:
      CFDictionaryRef v68 = *v30;
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v69 = *v48;
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "<settled>";
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v69;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I loaded %s config %@", buf, 0x16u);
      }
      goto LABEL_75;
    }
    char v50 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    while (1)
    {
      std::string::size_type v51 = (std::mutex *)v49[7];
      if (!sub_100E66D88((uint64_t)v51)) {
        break;
      }
      BOOL v52 = (uint64_t *)v49[1];
      if (v52)
      {
        do
        {
          uint64_t v53 = v52;
          BOOL v52 = (uint64_t *)*v52;
        }
        while (v52);
      }
      else
      {
        do
        {
          uint64_t v53 = (uint64_t *)v49[2];
          BOOL v54 = *v53 == (void)v49;
          long long v49 = v53;
        }
        while (!v54);
      }
      long long v49 = v53;
      if (v53 == v48 + 10)
      {
        if (v48) {
          goto LABEL_73;
        }
        goto LABEL_75;
      }
    }
    uint64_t v55 = *v30;
    if (os_log_type_enabled(*v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v179 = *v48;
      std::string::size_type v182 = (const char *)v49[4];
      char v181 = (const char *)(v49 + 4);
      CFTypeID v180 = v182;
      uint64_t v183 = *((unsigned __int8 *)v181 + 23);
      int v184 = (char)v183;
      if ((v183 & 0x80u) != 0) {
        uint64_t v183 = *((void *)v181 + 1);
      }
      if (v184 >= 0) {
        CFTypeID v180 = v181;
      }
      if (!v183) {
        CFTypeID v180 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "<settled>";
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v179;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&long long v198 = v180;
      _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "something went very wrong. key is missing in %s config %@ for %s", buf, 0x20u);
      std::string::size_type v51 = (std::mutex *)*((void *)v181 + 3);
    }
    sub_100E66E48(&v192, v51);
    *(void *)long long buf = off_101A64568;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)&long long v198 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
    sub_100057D78((const void **)&v192);
    sub_100E670C0(*(void *)(a1 + 216), (Registry **)(a1 + 48), v56);
    std::string::size_type v58 = (std::mutex *)Registry::getServiceMap(v57, *v15);
    xpc_object_t v59 = v58;
    long long v60 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      uint64_t v61 = 5381;
      do
      {
        long long v60 = (const char *)v61;
        unsigned int v62 = *v50++;
        uint64_t v61 = (33 * v61) ^ v62;
      }
      while (v62);
    }
    std::mutex::lock(v58);
    *(void *)long long buf = v60;
    std::string v63 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)buf);
    if (v63)
    {
      CFDictionaryRef v65 = (os_unfair_lock_s *)v63[3];
      xpc_object_t v64 = (std::__shared_weak_count *)v63[4];
      if (v64)
      {
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v59);
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v64);
        char v66 = 0;
        goto LABEL_69;
      }
    }
    else
    {
      CFDictionaryRef v65 = 0;
    }
    std::mutex::unlock(v59);
    xpc_object_t v64 = 0;
    char v66 = 1;
LABEL_69:
    sub_1000832B0(v65, @"SettledConfig", @"SatMsg", 0, 2u);
    if ((v66 & 1) == 0) {
      sub_10004D2C8(v64);
    }
    CFTypeID v67 = *(std::__shared_weak_count **)(a1 + 224);
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    if (!v67) {
      goto LABEL_75;
    }
    sub_10004D2C8(v67);
    uint64_t v48 = *(uint64_t **)(a1 + 216);
    if (!v48) {
      goto LABEL_75;
    }
    goto LABEL_73;
  }
  uint64_t v48 = v47;
  if (v47) {
    goto LABEL_49;
  }
LABEL_75:
  sub_100057D78((const void **)&__p);
LABEL_76:
  CFDictionaryRef v188 = 0;
  CFTypeID v70 = (std::mutex *)Registry::getServiceMap(v29, *v15);
  xpc_object_t v71 = v70;
  xpc_object_t v72 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFTypeID v73 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v74 = 5381;
    do
    {
      xpc_object_t v72 = (const char *)v74;
      unsigned int v75 = *v73++;
      uint64_t v74 = (33 * v74) ^ v75;
    }
    while (v75);
  }
  std::mutex::lock(v70);
  *(void *)long long buf = v72;
  xpc_object_t v76 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)buf);
  if (v76)
  {
    CFIndex v78 = (os_unfair_lock_s *)v76[3];
    xpc_object_t v77 = (std::__shared_weak_count *)v76[4];
    if (v77)
    {
      atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v71);
      atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v77);
      char v79 = 0;
      goto LABEL_84;
    }
  }
  else
  {
    CFIndex v78 = 0;
  }
  std::mutex::unlock(v71);
  xpc_object_t v77 = 0;
  char v79 = 1;
LABEL_84:
  sub_100083254(v78, @"ProposedConfig", @"SatMsg", 0, 2u, &__p);
  sub_10004EFE4(&v188, (CFTypeRef *)&__p);
  sub_1000577C4((const void **)&__p);
  if ((v79 & 1) == 0) {
    sub_10004D2C8(v77);
  }
  if (v188) {
    xpc_object_t v80 = (uint64_t *)sub_100080778;
  }
  else {
    xpc_object_t v80 = 0;
  }
  if (v80)
  {
    xpc_object_t v81 = (os_log_t *)(a1 + 40);
    sub_100E7A274((const __CFUUID ***)buf, (Registry **)(a1 + 48), v188, (os_log_t *)(a1 + 40));
    CFTypeID v82 = *(std::__shared_weak_count **)(a1 + 240);
    CFNumberRef v83 = *(uint64_t **)buf;
    *(_OWORD *)(a1 + 232) = *(_OWORD *)buf;
    if (v82)
    {
      sub_10004D2C8(v82);
      unsigned __int8 v84 = *(uint64_t **)(a1 + 232);
    }
    else
    {
      unsigned __int8 v84 = v83;
    }
    xpc_object_t v85 = (uint64_t *)v84[9];
    if (v85 == v84 + 10)
    {
LABEL_117:
      long long v102 = *v81;
      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v103 = *v84;
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "<proposed>";
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v103;
        _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I loaded %s config %@", buf, 0x16u);
      }
      goto LABEL_119;
    }
    uint64_t v86 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    while (1)
    {
      xpc_object_t v87 = (std::mutex *)v85[7];
      if (!sub_100E677C0((uint64_t)v87)) {
        break;
      }
      xpc_object_t v88 = (uint64_t *)v85[1];
      if (v88)
      {
        do
        {
          xpc_object_t v80 = v88;
          xpc_object_t v88 = (uint64_t *)*v88;
        }
        while (v88);
      }
      else
      {
        do
        {
          xpc_object_t v80 = (uint64_t *)v85[2];
          BOOL v54 = *v80 == (void)v85;
          xpc_object_t v85 = v80;
        }
        while (!v54);
      }
      xpc_object_t v85 = v80;
      if (v80 == v84 + 10)
      {
        if (v84) {
          goto LABEL_117;
        }
        goto LABEL_119;
      }
    }
    uint64_t v89 = *v81;
    if (os_log_type_enabled(*v81, OS_LOG_TYPE_ERROR))
    {
      uint64_t v173 = *v84;
      CFIndex v176 = (const char *)v85[4];
      CFIndex v175 = (const char *)(v85 + 4);
      BOOL v174 = v176;
      uint64_t v177 = *((unsigned __int8 *)v175 + 23);
      int v178 = (char)v177;
      if ((v177 & 0x80u) != 0) {
        uint64_t v177 = *((void *)v175 + 1);
      }
      if (v178 >= 0) {
        BOOL v174 = v175;
      }
      if (!v177) {
        BOOL v174 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "<proposed>";
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v173;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&long long v198 = v174;
      _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "something went very wrong. some key is missing in %s config %@ for %s", buf, 0x20u);
      xpc_object_t v87 = (std::mutex *)*((void *)v175 + 3);
    }
    sub_100E66E48(&__p, v87);
    *(void *)long long buf = off_101A645E8;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)&long long v198 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
    sub_100057D78((const void **)&__p);
    sub_100E670C0(*(void *)(a1 + 232), (Registry **)(a1 + 48), v90);
    CFDictionaryRef v92 = (std::mutex *)Registry::getServiceMap(v91, *v15);
    CFDictionaryRef v93 = v92;
    CFTypeID v94 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      uint64_t v95 = 5381;
      do
      {
        CFTypeID v94 = (const char *)v95;
        unsigned int v96 = *v86++;
        uint64_t v95 = (33 * v95) ^ v96;
      }
      while (v96);
    }
    std::mutex::lock(v92);
    *(void *)long long buf = v94;
    unsigned int v97 = sub_10004D37C(&v93[1].__m_.__sig, (unint64_t *)buf);
    if (v97)
    {
      long long v99 = (os_unfair_lock_s *)v97[3];
      long long v98 = (std::__shared_weak_count *)v97[4];
      if (v98)
      {
        atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v93);
        atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v98);
        char v100 = 0;
        goto LABEL_113;
      }
    }
    else
    {
      long long v99 = 0;
    }
    std::mutex::unlock(v93);
    long long v98 = 0;
    char v100 = 1;
LABEL_113:
    sub_1000832B0(v99, @"ProposedConfig", @"SatMsg", 0, 2u);
    if ((v100 & 1) == 0) {
      sub_10004D2C8(v98);
    }
    std::string::size_type v101 = *(std::__shared_weak_count **)(a1 + 240);
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    if (!v101) {
      goto LABEL_119;
    }
    sub_10004D2C8(v101);
    unsigned __int8 v84 = *(uint64_t **)(a1 + 232);
    if (!v84) {
      goto LABEL_119;
    }
    goto LABEL_117;
  }
LABEL_119:
  CFDictionaryRef v187 = 0;
  unsigned int v104 = (std::mutex *)Registry::getServiceMap(v80, *v15);
  long long v105 = v104;
  long long v106 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    uint64_t v107 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v108 = 5381;
    do
    {
      long long v106 = (const char *)v108;
      unsigned int v109 = *v107++;
      uint64_t v108 = (33 * v108) ^ v109;
    }
    while (v109);
  }
  std::mutex::lock(v104);
  *(void *)long long buf = v106;
  long long v110 = sub_10004D37C(&v105[1].__m_.__sig, (unint64_t *)buf);
  if (v110)
  {
    uint64_t v112 = (os_unfair_lock_s *)v110[3];
    uint64_t v111 = (std::__shared_weak_count *)v110[4];
    if (v111)
    {
      atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v105);
      atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v111);
      char v113 = 0;
      goto LABEL_127;
    }
  }
  else
  {
    uint64_t v112 = 0;
  }
  std::mutex::unlock(v105);
  uint64_t v111 = 0;
  char v113 = 1;
LABEL_127:
  sub_100083254(v112, @"UpcomingConfig", @"SatMsg", 0, 2u, &__p);
  sub_10004EFE4(&v187, (CFTypeRef *)&__p);
  sub_1000577C4((const void **)&__p);
  if ((v113 & 1) == 0) {
    sub_10004D2C8(v111);
  }
  if (v187) {
    uint64_t v114 = (uint64_t *)sub_100080778;
  }
  else {
    uint64_t v114 = 0;
  }
  if (!v114) {
    goto LABEL_157;
  }
  std::string::size_type v115 = (os_log_t *)(a1 + 40);
  sub_100E7A274((const __CFUUID ***)buf, (Registry **)(a1 + 48), v187, (os_log_t *)(a1 + 40));
  v116 = *(std::__shared_weak_count **)(a1 + 256);
  std::string::size_type v117 = *(uint64_t **)buf;
  *(_OWORD *)(a1 + 248) = *(_OWORD *)buf;
  if (v116)
  {
    sub_10004D2C8(v116);
    uint64_t v118 = *(uint64_t **)(a1 + 248);
  }
  else
  {
    uint64_t v118 = v117;
  }
  if (*v118) {
    char v119 = sub_100136254;
  }
  else {
    char v119 = 0;
  }
  long long v120 = *v115;
  if (v119)
  {
LABEL_140:
    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v121 = *v118;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "<upcoming>";
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v121;
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I loaded %s config %@", buf, 0x16u);
    }
    goto LABEL_157;
  }
  if (os_log_type_enabled(*v115, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "<upcoming>";
    _os_log_error_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "%s config is of bad format - cleaning up", buf, 0xCu);
  }
  *(void *)long long buf = off_101A64668;
  *(void *)&uint8_t buf[8] = a1;
  *(void *)&long long v198 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  sub_100E670C0(*(void *)(a1 + 248), (Registry **)(a1 + 48), v122);
  CFDictionaryRef v124 = (std::mutex *)Registry::getServiceMap(v123, *v15);
  CFTypeID v125 = v124;
  CFDictionaryRef v126 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFDictionaryRef v127 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v128 = 5381;
    do
    {
      CFDictionaryRef v126 = (const char *)v128;
      unsigned int v129 = *v127++;
      uint64_t v128 = (33 * v128) ^ v129;
    }
    while (v129);
  }
  std::mutex::lock(v124);
  *(void *)long long buf = v126;
  CFStringRef v130 = sub_10004D37C(&v125[1].__m_.__sig, (unint64_t *)buf);
  if (v130)
  {
    CFStringRef v132 = (os_unfair_lock_s *)v130[3];
    CFTypeID v131 = (std::__shared_weak_count *)v130[4];
    if (v131)
    {
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v125);
      atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v131);
      char v133 = 0;
      goto LABEL_152;
    }
  }
  else
  {
    CFStringRef v132 = 0;
  }
  std::mutex::unlock(v125);
  CFTypeID v131 = 0;
  char v133 = 1;
LABEL_152:
  sub_1000832B0(v132, @"UpcomingConfig", @"SatMsg", 0, 2u);
  if ((v133 & 1) == 0) {
    sub_10004D2C8(v131);
  }
  CFTypeID v134 = *(std::__shared_weak_count **)(a1 + 256);
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  if (v134)
  {
    sub_10004D2C8(v134);
    uint64_t v118 = *(uint64_t **)(a1 + 248);
    if (v118)
    {
      long long v120 = *v115;
      goto LABEL_140;
    }
  }
LABEL_157:
  CFDictionaryRef v135 = (std::mutex *)Registry::getServiceMap(v114, *v15);
  CFDictionaryRef v136 = v135;
  CFTypeID v137 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFArrayRef v138 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v139 = 5381;
    do
    {
      CFTypeID v137 = (const char *)v139;
      unsigned int v140 = *v138++;
      uint64_t v139 = (33 * v139) ^ v140;
    }
    while (v140);
  }
  std::mutex::lock(v135);
  *(void *)long long buf = v137;
  CFArrayRef v141 = sub_10004D37C(&v136[1].__m_.__sig, (unint64_t *)buf);
  if (v141)
  {
    CFStringRef v143 = (os_unfair_lock_s *)v141[3];
    os_log_t v142 = (std::__shared_weak_count *)v141[4];
    if (v142)
    {
      atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v136);
      atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v142);
      char v144 = 0;
      goto LABEL_165;
    }
  }
  else
  {
    CFStringRef v143 = 0;
  }
  std::mutex::unlock(v136);
  os_log_t v142 = 0;
  char v144 = 1;
LABEL_165:
  sub_100083254(v143, @"need-reprovisioning", @"SatMsg", 0, 2u, &__p);
  if (__p) {
    os_log_t v145 = sub_100080934;
  }
  else {
    os_log_t v145 = 0;
  }
  *(unsigned char *)(a1 + 272) = v145 != 0;
  sub_1000577C4((const void **)&__p);
  if ((v144 & 1) == 0) {
    sub_10004D2C8(v142);
  }
  CFStringRef v186 = 0;
  CFArrayRef v147 = (std::mutex *)Registry::getServiceMap(v146, *v15);
  CFArrayRef v148 = v147;
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFTypeID v149 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v150 = 5381;
    do
    {
      long long v18 = (const char *)v150;
      unsigned int v151 = *v149++;
      uint64_t v150 = (33 * v150) ^ v151;
    }
    while (v151);
  }
  std::mutex::lock(v147);
  *(void *)long long buf = v18;
  v152 = sub_10004D37C(&v148[1].__m_.__sig, (unint64_t *)buf);
  if (v152)
  {
    dispatch_group_t v154 = (os_unfair_lock_s *)v152[3];
    CFTypeID v153 = (std::__shared_weak_count *)v152[4];
    if (v153)
    {
      atomic_fetch_add_explicit(&v153->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v148);
      atomic_fetch_add_explicit(&v153->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v153);
      char v155 = 0;
      goto LABEL_178;
    }
  }
  else
  {
    dispatch_group_t v154 = 0;
  }
  std::mutex::unlock(v148);
  CFTypeID v153 = 0;
  char v155 = 1;
LABEL_178:
  sub_100083254(v154, @"need-clean-push", @"SatMsg", 0, 2u, &__p);
  sub_100056248(&v186, (CFTypeRef *)&__p);
  sub_1000577C4((const void **)&__p);
  if ((v155 & 1) == 0) {
    sub_10004D2C8(v153);
  }
  if (v186) {
    CFIndex v156 = sub_1000810B8;
  }
  else {
    CFIndex v156 = 0;
  }
  if (v156)
  {
    sub_100E67834((const void **)&__p, v186);
    BOOL v157 = (void **)(a1 + 280);
    if ((void **)(a1 + 280) != &__p)
    {
      *(void *)long long buf = *v157;
      *BOOL v157 = __p;
      std::string __p = 0;
      sub_10012577C((const void **)buf);
    }
    sub_10012577C((const void **)&__p);
  }
  *(_WORD *)(a1 + 96) = *(_WORD *)v185;
  dispatch_group_t v158 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_object_t v159 = "YES";
    if (!*(unsigned char *)v185) {
      dispatch_object_t v159 = "NO";
    }
    if (*(unsigned char *)(v185 + 1)) {
      CFTypeID v160 = v159;
    }
    else {
      CFTypeID v160 = "unknown";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v160;
    _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I initial configInUse: %s", buf, 0xCu);
  }
  char v161 = operator new(0x48uLL);
  v161[1] = 0;
  v161[2] = 0;
  *char v161 = off_101A646E8;
  v161[4] = 0;
  v161[3] = v161 + 4;
  v161[7] = 0;
  v161[8] = 0;
  v161[5] = 0;
  v161[6] = v161 + 7;
  std::string::size_type v162 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 160) = v161 + 3;
  *(void *)(a1 + 168) = v161;
  if (v162) {
    sub_10004D2C8(v162);
  }
  uint64_t v163 = *(void *)(*(void *)(a1 + 88) + 152);
  std::string __p = 0;
  uint64_t v194 = 0;
  uint64_t v195 = 0;
  uint64_t v196 = 0;
  sub_1005B26C0(&__p, *(void **)v163, *(void **)(v163 + 8), (uint64_t)(*(void *)(v163 + 8) - *(void *)v163) >> 4);
  LOBYTE(v196) = *(unsigned char *)(v163 + 24);
  int v164 = (std::__shared_weak_count **)__p;
  v165 = v194;
  if (__p != v194)
  {
    do
    {
      if (sub_100E67A44((uint64_t *)v164))
      {
        if ((void **)(a1 + 184) == sub_100046F68(a1 + 176, (void **)&(*v164)[1].__vftable))
        {
          uint64_t v166 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
          {
            v167 = (const char *)&(*v164)[1];
            uint64_t shared_weak_owners_high = HIBYTE((*v164)[1].__shared_weak_owners_);
            int v169 = (char)shared_weak_owners_high;
            if ((shared_weak_owners_high & 0x80u) != 0) {
              uint64_t shared_weak_owners_high = (*v164)[1].__shared_owners_;
            }
            if (v169 < 0) {
              v167 = (const char *)(*v164)[1].__vftable;
            }
            if (!shared_weak_owners_high) {
              v167 = "<invalid>";
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v167;
            _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "#I adding %s model", buf, 0xCu);
          }
          int v170 = *v164;
          sub_100E7BD1C(&v192, (uint64_t)*v164, v164[1]);
          if (SHIBYTE(v170[1].__shared_weak_owners_) < 0)
          {
            sub_10004FC84(buf, v170[1].__vftable, v170[1].__shared_owners_);
          }
          else
          {
            *(std::__shared_count *)long long buf = v170[1].std::__shared_count;
            *(void *)&uint8_t buf[16] = v170[1].__shared_weak_owners_;
          }
          long long v198 = v192;
          sub_100E7BF10((uint64_t **)(a1 + 176), (void **)buf, (uint64_t)buf);
          if (*((void *)&v198 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v198 + 1));
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        if (LOBYTE((*v164)[2].__vftable))
        {
          sub_100E67AA4(&v190, a1, (uint64_t)&(*v164)[1]);
          if (v191) {
            sub_10004D2C8(v191);
          }
        }
      }
      v164 += 2;
    }
    while (v164 != v165);
  }
  sub_100E67FAC(a1);
  *(void *)long long buf = &__p;
  sub_10005CBF0((void ***)buf);
  if (*(void *)(a1 + 216) || *(void *)(a1 + 232)) {
    sub_100E67890(a1);
  }
  int v171 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v171, OS_LOG_TYPE_DEFAULT, "#I bootstrap complete", buf, 2u);
  }
  sub_1000558F4((const void **)&v186);
  sub_100057D78((const void **)&v187);
  sub_100057D78((const void **)&v188);
  return sub_1000570E8((const void **)&v189);
}

void sub_100E66A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, int a20,const void *a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33)
{
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  sub_100057D78((const void **)&__p);
  sub_1000570E8(&a21);
  _Unwind_Resume(a1);
}

void sub_100E66CC0(Registry *this@<X1>, void *a2@<X0>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  CFTypeID v6 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      CFTypeID v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v13);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  *a2 = v12;
  a2[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
}

BOOL sub_100E66D88(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    uint64_t v1 = sub_10008324C;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    return 0;
  }
  if (!(*(void *)(a1 + 88) ? sub_10008324C : 0)) {
    return 0;
  }
  if (!(*(void *)(a1 + 152) ? sub_10008324C : 0)) {
    return 0;
  }
  if (!(*(void *)(a1 + 184) ? sub_10008324C : 0)) {
    return 0;
  }
  if (!*(_WORD *)(a1 + 96)) {
    return 1;
  }
  if (*(void *)(a1 + 120)) {
    uint64_t v5 = sub_10008324C;
  }
  else {
    uint64_t v5 = 0;
  }
  return v5 != 0;
}

void sub_100E66E48(void *a1, std::mutex *this)
{
  std::mutex::lock(this);
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    unsigned int value = v5;
    sub_10005717C((const void **)&value);
  }
  sig = (const void *)this[1].__m_.__sig;
  if (sig) {
    uint64_t v7 = sub_10008324C;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7) {
    CFDictionarySetValue(theDict, @"ue-pub-key", sig);
  }
  uint64_t v8 = *(const void **)this[1].__m_.__opaque;
  if (v8) {
    unsigned int v9 = sub_10008324C;
  }
  else {
    unsigned int v9 = 0;
  }
  if (v9) {
    CFDictionarySetValue(theDict, @"cred-key", v8);
  }
  uint64_t v10 = *(const void **)&this[1].__m_.__opaque[8];
  if (v10) {
    unint64_t v11 = sub_10008324C;
  }
  else {
    unint64_t v11 = 0;
  }
  if (v11) {
    CFDictionarySetValue(theDict, @"msisdn-key", v10);
  }
  uint64_t v12 = *(const void **)&this[2].__m_.__opaque[48];
  if (v12) {
    unint64_t v13 = sub_10008324C;
  }
  else {
    unint64_t v13 = 0;
  }
  if (v13) {
    CFDictionarySetValue(theDict, @"hmac-link-key", v12);
  }
  if (*(void *)&this[1].__m_.__opaque[16]) {
    unint64_t v14 = sub_10008324C;
  }
  else {
    unint64_t v14 = 0;
  }
  if (v14)
  {
    sub_100E7959C(&value, (uint64_t)&this[1].__m_.__opaque[16]);
    CFDictionarySetValue(theDict, @"mt-key", value);
    sub_1000577C4((const void **)&value);
  }
  if (*(void *)&this[1].__m_.__opaque[48]) {
    long long v15 = sub_10008324C;
  }
  else {
    long long v15 = 0;
  }
  if (v15)
  {
    sub_100E7959C(&value, (uint64_t)&this[1].__m_.__opaque[48]);
    CFDictionarySetValue(theDict, @"mt-recovery-key", value);
    sub_1000577C4((const void **)&value);
  }
  if (*(void *)&this[2].__m_.__opaque[16]) {
    unsigned int v16 = sub_10008324C;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16)
  {
    sub_100E7959C(&value, (uint64_t)&this[2].__m_.__opaque[16]);
    CFDictionarySetValue(theDict, @"mo-key", value);
    sub_1000577C4((const void **)&value);
  }
  sub_10004EFE4(a1, (CFTypeRef *)&theDict);
  sub_10005717C((const void **)&theDict);
  std::mutex::unlock(this);
}

void sub_100E67080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a10);
  sub_10005717C(&a9);
  std::mutex::unlock(v10);
  _Unwind_Resume(a1);
}

void sub_100E670C0(uint64_t a1@<X0>, Registry **a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a2);
  CFMutableDictionaryRef v5 = ServiceMap;
  uint64_t v7 = (void *)v6;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = (void *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = v7;
  unint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (v11 && (uint64_t v12 = (std::__shared_weak_count *)v11[4]) != 0)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v55 = v12;
    sub_10004D2C8(v12);
    char v56 = 0;
  }
  else
  {
    std::mutex::unlock(v5);
    uint64_t v55 = 0;
    char v56 = 1;
  }
  std::string::size_type v58 = 0;
  sub_100E6EBA8(&v58, *(const __CFUUID **)a1);
  unint64_t v13 = *(void **)(a1 + 24);
  if (v13 != (void *)(a1 + 32))
  {
    do
    {
      CFUUIDRef v14 = *(const __CFUUID **)a1;
      long long v15 = (std::mutex *)Registry::getServiceMap((uint64_t *)a2, *a2);
      unsigned int v16 = v15;
      int v17 = (void *)v6;
      if ((v6 & 0x8000000000000000) != 0)
      {
        long long v18 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          int v17 = (void *)v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(v15);
      std::string __p = v17;
      uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&__p);
      if (v21)
      {
        uint64_t v23 = v21[3];
        unsigned int v22 = (std::__shared_weak_count *)v21[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v16);
      unsigned int v22 = 0;
      char v24 = 1;
LABEL_17:
      unsigned int v62 = 0;
      sub_100E6EBA8(&v62, v14);
      if (v23)
      {
        CFMutableArrayRef v25 = v62;
        if (v62 ? sub_1000810B8 : 0)
        {
          CFNumberRef v27 = operator new(8uLL);
          std::string __p = v27;
          void *v27 = v25;
          long long v60 = v27 + 1;
          uint64_t v61 = v27 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"ue-pub-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          uint64_t v28 = v62;
          CFArrayRef v29 = operator new(8uLL);
          std::string __p = v29;
          void *v29 = v28;
          long long v60 = v29 + 1;
          uint64_t v61 = v29 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"cred-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          CFArrayRef v30 = v62;
          CFTypeID v31 = operator new(8uLL);
          std::string __p = v31;
          void *v31 = v30;
          long long v60 = v31 + 1;
          uint64_t v61 = v31 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"msisdn-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          unint64_t v32 = v62;
          char v33 = operator new(8uLL);
          std::string __p = v33;
          *char v33 = v32;
          long long v60 = v33 + 1;
          uint64_t v61 = v33 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"hmac-link-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          int v34 = v62;
          char v35 = operator new(8uLL);
          std::string __p = v35;
          void *v35 = v34;
          long long v60 = v35 + 1;
          uint64_t v61 = v35 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"mt-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          uint64_t v36 = v62;
          unint64_t v37 = operator new(8uLL);
          std::string __p = v37;
          void *v37 = v36;
          long long v60 = v37 + 1;
          uint64_t v61 = v37 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"mt-recovery-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
          char v38 = v62;
          uint64_t v39 = operator new(8uLL);
          std::string __p = v39;
          *uint64_t v39 = v38;
          long long v60 = v39 + 1;
          uint64_t v61 = v39 + 1;
          (*(void (**)(uint64_t, void *, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v23 + 32))(v23, v13 + 5, @"mo-key", @"SatMsg", &__p, 4);
          if (__p)
          {
            long long v60 = __p;
            operator delete(__p);
          }
        }
      }
      sub_1000558F4(&v62);
      if ((v24 & 1) == 0) {
        sub_10004D2C8(v22);
      }
      unsigned int v40 = (void *)v13[1];
      if (v40)
      {
        do
        {
          uint64_t v41 = v40;
          unsigned int v40 = (void *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          uint64_t v41 = (void *)v13[2];
          BOOL v42 = *v41 == (void)v13;
          unint64_t v13 = v41;
        }
        while (!v42);
      }
      unint64_t v13 = v41;
    }
    while (v41 != (void *)(a1 + 32));
  }
  uint64_t v43 = (std::mutex *)Registry::getServiceMap((uint64_t *)a2, *a2);
  char v44 = v43;
  long long v45 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    uint64_t v46 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v47 = 5381;
    do
    {
      long long v45 = (char *)v47;
      unsigned int v48 = *v46++;
      uint64_t v47 = (33 * v47) ^ v48;
    }
    while (v48);
  }
  std::mutex::lock(v43);
  std::string __p = v45;
  long long v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)&__p);
  if (v49)
  {
    std::string::size_type v51 = (os_unfair_lock_s *)v49[3];
    char v50 = (std::__shared_weak_count *)v49[4];
    if (v50)
    {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v44);
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v50);
      char v52 = 0;
      goto LABEL_52;
    }
  }
  else
  {
    std::string::size_type v51 = 0;
  }
  std::mutex::unlock(v44);
  char v50 = 0;
  char v52 = 1;
LABEL_52:
  uint64_t v53 = v58;
  BOOL v54 = operator new(8uLL);
  std::string __p = v54;
  *BOOL v54 = v53;
  long long v60 = v54 + 1;
  uint64_t v61 = v54 + 1;
  sub_1000832B0(v51, @"offgridKey", @"SatMsg", (char **)&__p, 4u);
  if (__p)
  {
    long long v60 = __p;
    operator delete(__p);
  }
  if ((v52 & 1) == 0) {
    sub_10004D2C8(v50);
  }
  sub_1000558F4(&v58);
  if ((v56 & 1) == 0) {
    sub_10004D2C8(v55);
  }
}

void sub_100E676D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, uint64_t a14, const void *a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  sub_1000558F4(&a15);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100E677C0(uint64_t a1)
{
  BOOL result = sub_100E66D88(a1);
  if (result)
  {
    if (*(void *)(a1 + 72)) {
      long long v3 = sub_10008324C;
    }
    else {
      long long v3 = 0;
    }
    if (v3)
    {
      if (*(void *)(a1 + 80)) {
        unint64_t v4 = sub_10008324C;
      }
      else {
        unint64_t v4 = 0;
      }
      return v4 != 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const void **sub_100E67834(const void **result, const __CFString *a2)
{
  *BOOL result = 0;
  if (a2)
  {
    *BOOL result = CFUUIDCreateFromString(0, a2);
    uint64_t v2 = 0;
    return sub_10012577C(&v2);
  }
  return result;
}

void sub_100E6787C(_Unwind_Exception *a1)
{
  sub_10012577C(v1);
  _Unwind_Resume(a1);
}

void sub_100E67890(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I scheduling certificate validation", buf, 2u);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    unint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      p_uint64_t shared_weak_owners = &v4->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      sub_100D2040C();
    }
  }
  sub_100088B9C();
}

void sub_100E67A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E67A44(uint64_t *a1)
{
  if (*(unsigned char *)(*a1 + 49)) {
    return 0;
  }
  uint64_t result = isReal();
  if (result)
  {
    uint64_t v3 = *a1;
    if (!*(unsigned char *)(*a1 + 62) && !*(unsigned char *)(v3 + 63)) {
      return *(unsigned __int8 *)(v3 + 96) == 0;
    }
    return 0;
  }
  return result;
}

void sub_100E67AA4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 160);
  if (!v4) {
    __assert_rtn("addSimToConfig", "SatMsg_ProvisioningImpl_ios.mm", 1334, "isBootstrapped()");
  }
  *a1 = 0;
  a1[1] = 0;
  uint64_t v7 = sub_100046F68(v4, (void **)a3);
  uint64_t v8 = *(void *)(a2 + 160) + 8;
  uint64_t v9 = *(NSObject **)(a2 + 40);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if ((void **)v8 != v7)
  {
    if (v10)
    {
      uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
      BOOL v13 = (v12 & 0x80u) != 0;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a3 + 8);
      }
      if (v13) {
        CFUUIDRef v14 = *(const char **)a3;
      }
      else {
        CFUUIDRef v14 = (const char *)a3;
      }
      if (v12) {
        long long v15 = v14;
      }
      else {
        long long v15 = "<invalid>";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s config already exist", buf, 0xCu);
    }
    int v17 = v7[7];
    unsigned int v16 = (atomic_ullong *)v7[8];
    if (v16) {
      atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
    }
    *a1 = (uint64_t)v17;
    a1[1] = (uint64_t)v16;
    return;
  }
  if (v10)
  {
    uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
    BOOL v19 = (v18 & 0x80u) != 0;
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a3 + 8);
    }
    if (v19) {
      char v20 = *(const char **)a3;
    }
    else {
      char v20 = (const char *)a3;
    }
    if (v18) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I adding %s config", buf, 0xCu);
  }
  CFDictionaryRef v49 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a2 + 48));
  uint64_t v23 = ServiceMap;
  if (v24 < 0)
  {
    CFMutableArrayRef v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v24;
  uint64_t v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)buf);
  if (!v28)
  {
    uint64_t v30 = 0;
    goto LABEL_33;
  }
  uint64_t v30 = v28[3];
  CFArrayRef v29 = (std::__shared_weak_count *)v28[4];
  if (!v29)
  {
LABEL_33:
    std::mutex::unlock(v23);
    CFArrayRef v29 = 0;
    char v31 = 1;
    goto LABEL_34;
  }
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v23);
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v29);
  char v31 = 0;
LABEL_34:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v30 + 24))(&v48, v30, a3, @"sim-cfg", @"SatMsg", 0, 2);
  sub_10004EFE4(&v49, &v48);
  sub_1000577C4(&v48);
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  CFDictionaryRef v32 = v49;
  char v33 = operator new(0x90uLL);
  v33[1] = 0;
  v33[2] = 0;
  *char v33 = off_101A642C8;
  uint64_t v34 = sub_100E640E8((uint64_t)(v33 + 3), v32);
  char v35 = (std::__shared_weak_count *)a1[1];
  *a1 = v34;
  a1[1] = (uint64_t)v33;
  if (v35) {
    sub_10004D2C8(v35);
  }
  uint64_t v36 = *(void **)(a2 + 328);
  unint64_t v37 = *(void **)(a2 + 336);
  if (v36 == v37)
  {
    char v38 = 0;
    goto LABEL_57;
  }
  char v38 = 0;
  while (1)
  {
    uint64_t v39 = (std::__shared_weak_count *)v36[1];
    if (!v39) {
      goto LABEL_49;
    }
    unsigned int v40 = std::__shared_weak_count::lock(v39);
    if (!v40) {
      goto LABEL_49;
    }
    uint64_t v41 = v40;
    if (*v36) {
      break;
    }
LABEL_48:
    sub_10004D2C8(v41);
LABEL_49:
    v36 += 2;
    if (v36 == v37) {
      goto LABEL_57;
    }
  }
  (*(void (**)(uint8_t *__return_ptr))(*(void *)*v36 + 24))(buf);
  uint64_t v43 = *(void *)buf;
  BOOL v42 = *(std::__shared_weak_count **)&buf[8];
  memset(buf, 0, sizeof(buf));
  if (v38)
  {
    sub_10004D2C8(v38);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (!v43)
  {
    char v38 = v42;
    goto LABEL_48;
  }
  sub_10004D2C8(v41);
  uint64_t v44 = *a1;
  if (v42) {
    atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v45 = *(std::__shared_weak_count **)(v44 + 72);
  *(void *)(v44 + 64) = v43;
  *(void *)(v44 + 72) = v42;
  if (v45) {
    sub_10004D2C8(v45);
  }
  char v38 = v42;
LABEL_57:
  uint64_t v46 = *(uint64_t ***)(a2 + 160);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)a3;
    uint64_t v51 = *(void *)(a3 + 16);
  }
  uint64_t v47 = (std::__shared_weak_count *)a1[1];
  uint64_t v52 = *a1;
  uint64_t v53 = v47;
  if (v47) {
    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100E79984(v46, (void **)buf, (uint64_t)buf);
  if (v53) {
    sub_10004D2C8(v53);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete(*(void **)buf);
  }
  sub_100E6CD40(a2);
  sub_100E6D378(a2);
  if (v38) {
    sub_10004D2C8(v38);
  }
  sub_100057D78((const void **)&v49);
}

void sub_100E67F04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100057D78((const void **)va);
  CFMutableDictionaryRef v5 = *(std::__shared_weak_count **)(v2 + 8);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_100E67FAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if (v2)
  {
    uint64_t v3 = *(unsigned __int8 **)(v2 + 24);
    uint64_t v4 = (unsigned __int8 *)(v2 + 32);
    if (v3 != (unsigned __int8 *)(v2 + 32))
    {
      char v5 = 0;
      while (1)
      {
        uint64_t v6 = *(void *)(*(void *)(a1 + 88) + 152);
        uint64_t v7 = *(void **)v6;
        uint64_t v8 = *(void **)(v6 + 8);
        if (*(void **)v6 == v8) {
          break;
        }
        while (!sub_10001D294((unsigned __int8 *)(*v7 + 24), v3 + 40))
        {
          v7 += 2;
          if (v7 == v8)
          {
            uint64_t v7 = v8;
            break;
          }
        }
        if (v7 == *(void **)(v6 + 8)) {
          break;
        }
        uint64_t v10 = *v7;
        uint64_t v9 = (std::__shared_weak_count *)v7[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v10 || !*(unsigned char *)(v10 + 48)) {
          goto LABEL_16;
        }
        int v11 = 0;
        char v5 = 1;
        if (v9) {
          goto LABEL_17;
        }
LABEL_18:
        if (v11)
        {
          uint64_t v12 = (unsigned __int8 *)*((void *)v3 + 1);
          if (v12)
          {
            do
            {
              BOOL v13 = v12;
              uint64_t v12 = *(unsigned __int8 **)v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              BOOL v13 = (unsigned __int8 *)*((void *)v3 + 2);
              BOOL v14 = *(void *)v13 == (void)v3;
              uint64_t v3 = v13;
            }
            while (!v14);
          }
          uint64_t v3 = v13;
          if (v13 != v4) {
            continue;
          }
        }
        goto LABEL_28;
      }
      uint64_t v9 = 0;
LABEL_16:
      int v11 = 1;
      if (!v9) {
        goto LABEL_18;
      }
LABEL_17:
      sub_10004D2C8(v9);
      goto LABEL_18;
    }
    char v5 = 0;
LABEL_28:
    int v15 = v5 & 1;
  }
  else
  {
    int v15 = 0;
  }
  if (*(unsigned __int8 *)(a1 + 200) != v15)
  {
    *(unsigned char *)(a1 + 200) = v15;
    unsigned int v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asStringBool(v15);
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I reevaluateProvisioningState to %s", buf, 0xCu);
    }
    int v17 = *(std::__shared_weak_count **)(a1 + 16);
    if (v17)
    {
      if (std::__shared_weak_count::lock(v17)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
}

void sub_100E6821C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100E6822C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 97) && !*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      if (*(void *)(a1 + 264)) {
        uint64_t v3 = "Res";
      }
      else {
        uint64_t v3 = "S";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %scheduling new proposition", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v4 || (v5 = *(void *)(a1 + 8), (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v7 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v6);
    Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 48));
    uint64_t v8 = buf;
    sub_100058DB0(__p, "proposing new config");
    uint64_t v9 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v9;
    if (v9) {
      dispatch_retain(v9);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 3321888768;
    aBlock[2] = sub_100E68518;
    aBlock[3] = &unk_101A64030;
    aBlock[4] = a1;
    aBlock[5] = v5;
    BOOL v14 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    int v15 = _Block_copy(aBlock);
    sub_100118A44(v8, (uint64_t)__p, 1, 5000000, &object, &v15);
    uint64_t v10 = v19;
    uint64_t v19 = 0;
    uint64_t v11 = *(void *)(a1 + 264);
    *(void *)(a1 + 264) = v10;
    if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      uint64_t v12 = v19;
      uint64_t v19 = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
    if (v15) {
      _Block_release(v15);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (v14) {
      std::__shared_weak_count::__release_weak(v14);
    }
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_100E68494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E68518(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5]) {
        goto LABEL_10;
      }
      uint64_t v6 = *(void *)(v3 + 264);
      *(void *)(v3 + 264) = 0;
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      }
      uint64_t v7 = (os_log_t *)(v3 + 40);
      uint64_t v8 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I waiting timeout expired - now we can propose new config, if needed", buf, 2u);
      }
      if (!*(unsigned char *)(v3 + 97) || *(unsigned char *)(v3 + 96)) {
        goto LABEL_10;
      }
      uint64_t v9 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ***** proposeNewConfig ****", buf, 2u);
      }
      uint64_t v10 = *(void **)(v3 + 160);
      if (v10)
      {
        BOOL v13 = (void *)*v10;
        uint64_t v11 = v10 + 1;
        uint64_t v12 = v13;
        if (v13 == v11)
        {
          BOOL v26 = 0;
          char v15 = 1;
        }
        else
        {
          uint64_t v14 = 0;
          char v15 = 1;
          do
          {
            uint64_t v16 = *(void *)(v3 + 160);
            if ((void **)(v16 + 32) == sub_100046F68(v16 + 24, (void **)v12 + 4))
            {
              ++v14;
              uint64_t v17 = v12[7];
              if (!*(unsigned char *)(v17 + 24) || !*(unsigned char *)(v17 + 56) || !*(void *)(v17 + 64))
              {
                char v18 = *v7;
                if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v19 = *((unsigned __int8 *)v12 + 55);
                  BOOL v20 = (v19 & 0x80u) != 0;
                  if ((v19 & 0x80u) != 0) {
                    uint64_t v19 = v12[5];
                  }
                  if (v20) {
                    uint64_t v21 = (const char *)v12[4];
                  }
                  else {
                    uint64_t v21 = (const char *)(v12 + 4);
                  }
                  BOOL v22 = v19 == 0;
                  uint64_t v23 = "<invalid>";
                  if (!v22) {
                    uint64_t v23 = v21;
                  }
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v23;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I config for %s is not ready yet", buf, 0xCu);
                }
                char v15 = 0;
              }
            }
            uint64_t v24 = (void *)v12[1];
            if (v24)
            {
              do
              {
                CFMutableArrayRef v25 = v24;
                uint64_t v24 = (void *)*v24;
              }
              while (v24);
            }
            else
            {
              do
              {
                CFMutableArrayRef v25 = (void *)v12[2];
                BOOL v22 = *v25 == (void)v12;
                uint64_t v12 = v25;
              }
              while (!v22);
            }
            uint64_t v12 = v25;
          }
          while (v25 != v11);
          BOOL v26 = v14 != 0;
          if ((v15 & (v14 != 0)) != 0)
          {
            uint64_t v27 = *(void *)(v3 + 248);
            if (v27 && !sub_100E6DC08(v3, v27, (uint64_t)"<upcoming>"))
            {
              unint64_t v37 = *v7;
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = "<upcoming>";
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I no need for changing %s", buf, 0xCu);
              }
              if (*(unsigned char *)(v3 + 152) && *(void *)(v3 + 248)) {
                sub_100E6A644(v3);
              }
            }
            else if (sub_100E6D750(v3))
            {
              uint64_t v28 = *(void *)(v3 + 248);
              if (v28)
              {
                CFArrayRef v29 = *v7;
                if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = "<upcoming>";
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I replacing previos %s", buf, 0xCu);
                  uint64_t v28 = *(void *)(v3 + 248);
                }
                sub_100E670C0(v28, (Registry **)(v3 + 48), v30);
                char v31 = *(std::__shared_weak_count **)(v3 + 256);
                *(void *)(v3 + 248) = 0;
                *(void *)(v3 + 256) = 0;
                if (v31) {
                  sub_10004D2C8(v31);
                }
              }
              sub_100E7C4D4((const __CFUUID ***)buf, (Registry **)(v3 + 48), *(void **)(v3 + 160), (os_log_t *)(v3 + 40));
              CFDictionaryRef v32 = *(std::__shared_weak_count **)(v3 + 256);
              uint64_t v33 = *(void *)buf;
              *(_OWORD *)(v3 + 248) = *(_OWORD *)buf;
              if (v32)
              {
                sub_10004D2C8(v32);
                uint64_t v34 = *(void *)(v3 + 248);
              }
              else
              {
                uint64_t v34 = v33;
              }
              unsigned int v40 = 0;
              sub_100E6E180(&v40, v34, 0);
              sub_100E66CC0(*(Registry **)(v3 + 48), buf, v38);
              sub_1000825C4(*(os_unfair_lock_s **)buf, @"UpcomingConfig", v40, @"SatMsg", 0, 2u, 0, 0);
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              uint64_t v39 = *v7;
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I compiled new config", buf, 2u);
              }
              *(void *)long long buf = off_101A64858;
              *(void *)&uint8_t buf[8] = v3;
              BOOL v42 = buf;
              logger::CFTypeRefLogger();
              sub_10012C330(buf);
              sub_100E6A644(v3);
              sub_100057D78(&v40);
            }
            goto LABEL_10;
          }
        }
        if ((v15 & 1) != 0 && !v26)
        {
          char v35 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v36 = "#I no SIMs in config - nothing to provision";
            goto LABEL_55;
          }
        }
      }
      else
      {
        char v35 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v36 = "#I Current config is not ready yet, module not bootstrapped";
LABEL_55:
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v36, buf, 2u);
        }
      }
LABEL_10:
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E68A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  sub_10004D2C8(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_100E68A70(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E68A8C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E68A9C(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I provisioning started", buf, 2u);
  }
  if (a1[20])
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        p_uint64_t shared_weak_owners = &v4->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v4);
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        sub_100D2040C();
      }
    }
    sub_100088B9C();
  }
  __assert_rtn("lazy_start", "SatMsg_ProvisioningImpl_ios.mm", 1166, "isBootstrapped()");
}

void sub_100E68C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v15);
  _Unwind_Resume(a1);
}

void sub_100E68C84(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        ++v3[38];
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v17 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I daily check", v17, 2u);
        }
        uint64_t v7 = (void *)v3[22];
        if (v7 != v3 + 23)
        {
          do
          {
            uint64_t v8 = v7[7];
            *(_DWORD *)(v8 + 104) = 0;
            *(unsigned char *)(v8 + 108) = 0;
            uint64_t v9 = (void *)v7[1];
            if (v9)
            {
              do
              {
                uint64_t v10 = v9;
                uint64_t v9 = (void *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                uint64_t v10 = (void *)v7[2];
                BOOL v11 = *v10 == (void)v7;
                uint64_t v7 = v10;
              }
              while (!v11);
            }
            uint64_t v7 = v10;
          }
          while (v10 != v3 + 23);
        }
        sub_100E6822C((uint64_t)v3);
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * v3[38]) <= 0x2492492492492492)
        {
          uint64_t v12 = v3[5];
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I weekly check", buf, 2u);
          }
          uint64_t v13 = v3[20];
          if (v13)
          {
            char v15 = *(char **)(v13 + 32);
            uint64_t v14 = (void *)(v13 + 32);
            sub_10005CD2C((uint64_t)(v14 - 1), v15);
            *(v14 - 1) = v14;
            void *v14 = 0;
            v14[1] = 0;
            sub_100E6822C((uint64_t)v3);
          }
        }
        uint64_t v16 = v3[36];
        if (v16) {
          sub_100D211E4(v16, 0);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E68E40(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E68E54(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E68E78(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

BOOL sub_100E68E88(uint64_t a1)
{
  return *(void *)(a1 + 216) != 0;
}

BOOL sub_100E68E98(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "NO";
    if (a2) {
      uint64_t v5 = "YES";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I changed ConfigInUse: %s", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 97))
  {
    if (*(unsigned __int8 *)(a1 + 96) == a2) {
      return *(unsigned __int8 *)(a1 + 96) == a2;
    }
    *(_WORD *)(a1 + 96) = a2 | 0x100;
    if ((a2 & 1) == 0)
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Config was unlocked, meaning was used - mark it as dirty and refresh", buf, 2u);
      }
      uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
      if (v7)
      {
        if (std::__shared_weak_count::lock(v7)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    *(_WORD *)(a1 + 96) = a2 | 0x100;
    if ((a2 & 1) == 0)
    {
      sub_100E6822C(a1);
      return *(unsigned __int8 *)(a1 + 96) == a2;
    }
  }
  uint64_t v8 = *(void *)(a1 + 232);
  if (v8)
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "<proposed>";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I config locked - dropping %s", buf, 0xCu);
      uint64_t v8 = *(void *)(a1 + 232);
    }
    sub_100E670C0(v8, (Registry **)(a1 + 48), v10);
    uint64_t v12 = *(std::__shared_weak_count **)(a1 + 240);
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 48));
    uint64_t v14 = ServiceMap;
    char v15 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      uint64_t v16 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        char v15 = (const char *)v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = (os_unfair_lock_s *)v19[3];
      BOOL v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    BOOL v20 = 0;
    char v22 = 1;
LABEL_28:
    sub_1000832B0(v21, @"ProposedConfig", @"SatMsg", 0, 2u);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
  }
  uint64_t v23 = *(void *)(a1 + 248);
  if (!v23) {
    return *(unsigned __int8 *)(a1 + 96) == a2;
  }
  uint64_t v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "<upcoming>";
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I config locked - dropping %s", buf, 0xCu);
    uint64_t v23 = *(void *)(a1 + 248);
  }
  sub_100E670C0(v23, (Registry **)(a1 + 48), v25);
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 256);
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(a1 + 48));
  CFArrayRef v29 = v28;
  uint64_t v30 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    char v31 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v32 = 5381;
    do
    {
      uint64_t v30 = (const char *)v32;
      unsigned int v33 = *v31++;
      uint64_t v32 = (33 * v32) ^ v33;
    }
    while (v33);
  }
  std::mutex::lock(v28);
  *(void *)long long buf = v30;
  uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
  if (v34)
  {
    uint64_t v36 = (os_unfair_lock_s *)v34[3];
    char v35 = (std::__shared_weak_count *)v34[4];
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v35);
      char v37 = 0;
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v36 = 0;
  }
  std::mutex::unlock(v29);
  char v35 = 0;
  char v37 = 1;
LABEL_43:
  sub_1000832B0(v36, @"UpcomingConfig", @"SatMsg", 0, 2u);
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  return *(unsigned __int8 *)(a1 + 96) == a2;
}

void sub_100E6930C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E6934C(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if (v2)
  {
    char v56 = a2;
    if (*(unsigned char *)(a1 + 208)) {
      int v3 = *(_DWORD *)(a1 + 204);
    }
    else {
      int v3 = 0;
    }
    uint64_t v5 = (char *)operator new(0xA8uLL);
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 2) = 0;
    *(void *)uint64_t v5 = off_101A64788;
    *((void *)v5 + 4) = 0;
    *((void *)v5 + 7) = 0;
    uint64_t v6 = v5 + 56;
    *((void *)v5 + 6) = v5 + 56;
    uint64_t v7 = (char **)(v5 + 48);
    *((void *)v5 + 3) = off_101A63EB8;
    *((void *)v5 + 10) = 0;
    uint64_t v8 = (char **)(v5 + 80);
    *((void *)v5 + 11) = 0;
    *((void *)v5 + 12) = 0;
    std::string::size_type v58 = v5 + 96;
    *((void *)v5 + 8) = 0;
    *((void *)v5 + 9) = v5 + 80;
    *((void *)v5 + 13) = 0;
    *((void *)v5 + 14) = 0;
    sub_100224390((const void **)v5 + 4, (const void **)v2);
    *((_DWORD *)v5 + 10) = v3;
    if (v5 + 24 != (char *)v2)
    {
      uint64_t v9 = *(void **)(v2 + 24);
      uint64_t v10 = (void *)(v2 + 32);
      if (*((void *)v5 + 8))
      {
        BOOL v11 = *v7;
        std::__shared_weak_count *v7 = v6;
        *(void *)(*(void *)v6 + 16) = 0;
        *(void *)uint64_t v6 = 0;
        *((void *)v5 + 8) = 0;
        if (*((void *)v11 + 1)) {
          uint64_t v12 = (char *)*((void *)v11 + 1);
        }
        else {
          uint64_t v12 = v11;
        }
        __p[0] = v5 + 48;
        __p[1] = v12;
        long long v60 = (uint64_t *)v12;
        if (!v12 || (__p[1] = sub_1000EA590((uint64_t)v12), v9 == v10))
        {
          uint64_t v17 = v9;
        }
        else
        {
          do
          {
            *((_DWORD *)v12 + 8) = *((_DWORD *)v9 + 8);
            std::string::operator=((std::string *)(v12 + 40), (const std::string *)(v9 + 5));
            uint64_t v13 = *(uint64_t **)v6;
            uint64_t v14 = (uint64_t **)(v5 + 56);
            char v15 = (uint64_t **)(v5 + 56);
            if (*(void *)v6)
            {
              do
              {
                while (1)
                {
                  uint64_t v14 = (uint64_t **)v13;
                  if (*((_DWORD *)v60 + 8) >= *((_DWORD *)v13 + 8)) {
                    break;
                  }
                  uint64_t v13 = (uint64_t *)*v13;
                  char v15 = v14;
                  if (!*v14) {
                    goto LABEL_19;
                  }
                }
                uint64_t v13 = (uint64_t *)v13[1];
              }
              while (v13);
              char v15 = v14 + 1;
            }
LABEL_19:
            sub_100046C38((uint64_t **)v5 + 6, (uint64_t)v14, v15, v60);
            uint64_t v12 = (char *)__p[1];
            long long v60 = (uint64_t *)__p[1];
            if (__p[1]) {
              __p[1] = sub_1000EA590((uint64_t)__p[1]);
            }
            uint64_t v16 = (void *)v9[1];
            if (v16)
            {
              do
              {
                uint64_t v17 = v16;
                uint64_t v16 = (void *)*v16;
              }
              while (v16);
            }
            else
            {
              do
              {
                uint64_t v17 = (void *)v9[2];
                BOOL v18 = *v17 == (void)v9;
                uint64_t v9 = v17;
              }
              while (!v18);
            }
            if (!v12) {
              break;
            }
            uint64_t v9 = v17;
          }
          while (v17 != v10);
        }
        sub_100E79AE0((uint64_t)__p);
        uint64_t v9 = v17;
      }
      if (v9 != v10)
      {
        do
        {
          uint64_t v19 = (char *)operator new(0x40uLL);
          *((_DWORD *)v19 + 8) = *((_DWORD *)v9 + 8);
          BOOL v20 = v19 + 40;
          if (*((char *)v9 + 63) < 0)
          {
            sub_10004FC84(v20, (void *)v9[5], v9[6]);
          }
          else
          {
            long long v21 = *(_OWORD *)(v9 + 5);
            *((void *)v19 + 7) = v9[7];
            *(_OWORD *)BOOL v20 = v21;
          }
          char v22 = *(uint64_t **)v6;
          uint64_t v23 = (uint64_t **)(v5 + 56);
          uint64_t v24 = (uint64_t **)(v5 + 56);
          if (*(void *)v6)
          {
            do
            {
              while (1)
              {
                uint64_t v23 = (uint64_t **)v22;
                if (*((_DWORD *)v19 + 8) >= *((_DWORD *)v22 + 8)) {
                  break;
                }
                char v22 = (uint64_t *)*v22;
                uint64_t v24 = v23;
                if (!*v23) {
                  goto LABEL_41;
                }
              }
              char v22 = (uint64_t *)v22[1];
            }
            while (v22);
            uint64_t v24 = v23 + 1;
          }
LABEL_41:
          sub_100046C38((uint64_t **)v5 + 6, (uint64_t)v23, v24, (uint64_t *)v19);
          CFMutableArrayRef v25 = (void *)v9[1];
          if (v25)
          {
            do
            {
              BOOL v26 = v25;
              CFMutableArrayRef v25 = (void *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              BOOL v26 = (void *)v9[2];
              BOOL v18 = *v26 == (void)v9;
              uint64_t v9 = v26;
            }
            while (!v18);
          }
          uint64_t v9 = v26;
        }
        while (v26 != v10);
      }
    }
    uint64_t v27 = *(void **)(v2 + 48);
    uint64_t v55 = v2;
    if (v27 != (void *)(v2 + 56))
    {
      do
      {
        uint64_t v28 = v27[7];
        CFArrayRef v29 = (char *)operator new(0x90uLL);
        *((void *)v29 + 1) = 0;
        *((void *)v29 + 2) = 0;
        *(void *)CFArrayRef v29 = off_101A642C8;
        uint8_t v29[24] = 0;
        v29[56] = 0;
        v29[48] = 0;
        v29[80] = 0;
        *(_OWORD *)(v29 + 88) = 0u;
        *(_OWORD *)(v29 + 104) = 0u;
        *(_OWORD *)(v29 + 120) = 0u;
        *((void *)v29 + 17) = 0;
        sub_100179AF8((std::string *)v29 + 1, (const std::string *)v28);
        sub_100179AF8((std::string *)(v29 + 56), (const std::string *)(v28 + 32));
        sub_100083EB8((const void **)v29 + 13, (const void **)(v28 + 80));
        sub_1003C5CD0((const void **)v29 + 14, (const void **)(v28 + 88));
        sub_100083EB8((const void **)v29 + 15, (const void **)(v28 + 96));
        uint64_t v31 = *(void *)(v28 + 64);
        uint64_t v30 = *(void *)(v28 + 72);
        if (v30) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v32 = (std::__shared_weak_count *)*((void *)v29 + 12);
        *((void *)v29 + 11) = v31;
        *((void *)v29 + 12) = v30;
        if (v32) {
          sub_10004D2C8(v32);
        }
        if (*((char *)v27 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v27[4], v27[5]);
        }
        else
        {
          *(_OWORD *)std::string __p = *((_OWORD *)v27 + 2);
          long long v60 = (uint64_t *)v27[6];
        }
        *(void *)&long long v61 = v29 + 24;
        *((void *)&v61 + 1) = v29;
        unsigned int v33 = (char **)(v5 + 80);
        uint64_t v34 = (char **)(v5 + 80);
        char v35 = *v8;
        if (!*v8) {
          goto LABEL_64;
        }
        unsigned int v33 = (char **)(v5 + 80);
        while (1)
        {
          while (1)
          {
            uint64_t v34 = (char **)v35;
            uint64_t v36 = v35 + 32;
            if ((sub_100046FE8(__p, (void **)v35 + 4) & 0x80) == 0) {
              break;
            }
            char v35 = *v34;
            unsigned int v33 = v34;
            if (!*v34) {
              goto LABEL_64;
            }
          }
          if ((sub_100046FE8(v36, __p) & 0x80) == 0) {
            break;
          }
          unsigned int v33 = v34 + 1;
          char v35 = v34[1];
          if (!v35) {
            goto LABEL_64;
          }
        }
        if (!*v33)
        {
LABEL_64:
          uint64_t v63 = 0;
          char v37 = (char *)operator new(0x48uLL);
          v62[0] = (uint64_t)v37;
          v62[1] = (uint64_t)(v5 + 80);
          char v38 = v37 + 32;
          if (SHIBYTE(v60) < 0)
          {
            sub_10004FC84(v38, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)char v38 = *(_OWORD *)__p;
            *((void *)v37 + 6) = v60;
          }
          *(_OWORD *)(v37 + 56) = v61;
          long long v61 = 0uLL;
          LOBYTE(v63) = 1;
          *(void *)char v37 = 0;
          *((void *)v37 + 1) = 0;
          *((void *)v37 + 2) = v34;
          *unsigned int v33 = v37;
          uint64_t v39 = **((void **)v5 + 9);
          if (v39)
          {
            *((void *)v5 + 9) = v39;
            char v37 = *v33;
          }
          sub_100046C90(*((uint64_t **)v5 + 10), (uint64_t *)v37);
          ++*((void *)v5 + 11);
          v62[0] = 0;
          sub_1001FEBC4((uint64_t)v62);
        }
        if (*((void *)&v61 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v61 + 1));
        }
        if (SHIBYTE(v60) < 0) {
          operator delete(__p[0]);
        }
        unsigned int v40 = (void *)v27[1];
        if (v40)
        {
          do
          {
            uint64_t v41 = v40;
            unsigned int v40 = (void *)*v40;
          }
          while (v40);
        }
        else
        {
          do
          {
            uint64_t v41 = (void *)v27[2];
            BOOL v18 = *v41 == (void)v27;
            uint64_t v27 = v41;
          }
          while (!v18);
        }
        uint64_t v27 = v41;
      }
      while (v41 != (void *)(v2 + 56));
    }
    if (v58 != (void *)(v2 + 96)) {
      sub_10006E4A8(v58, *(char **)(v2 + 96), *(char **)(v2 + 104), *(void *)(v2 + 104) - *(void *)(v2 + 96));
    }
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v5 + 120), (const ctu::OsLogLogger *)(a1 + 40));
    uint64_t v4 = v5 + 24;
    *((void *)v5 + 3) = off_101A64160;
    uint64_t v42 = *(void *)(a1 + 56);
    *((void *)v5 + 16) = *(void *)(a1 + 48);
    *((void *)v5 + 17) = v42;
    if (v42) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
    }
    *((void *)v5 + 19) = 0;
    *((void *)v5 + 20) = 0;
    uint64_t v43 = v5 + 152;
    *((void *)v5 + 18) = v5 + 152;
    uint64_t v44 = *(void ***)(v2 + 72);
    if (v44 != (void **)(v2 + 80))
    {
      while (1)
      {
        v62[0] = 0;
        long long v45 = (void *)*v43;
        if (*((void **)v5 + 18) == v43)
        {
          uint64_t v47 = v5 + 152;
          if (!v45) {
            goto LABEL_97;
          }
        }
        else
        {
          uint64_t v46 = v5 + 152;
          if (v45)
          {
            do
            {
              uint64_t v47 = v45;
              long long v45 = (void *)v45[1];
            }
            while (v45);
          }
          else
          {
            do
            {
              uint64_t v47 = (void *)*((void *)v46 + 2);
              BOOL v18 = *v47 == (void)v46;
              uint64_t v46 = (char *)v47;
            }
            while (v18);
          }
          if ((sub_100046FE8(v47 + 4, v44 + 4) & 0x80) == 0)
          {
            unsigned int v48 = (uint64_t **)sub_100046ED4((uint64_t)(v5 + 144), v62, v44 + 4);
            goto LABEL_94;
          }
          if (!*v43)
          {
LABEL_97:
            v62[0] = (uint64_t)(v5 + 152);
            unsigned int v48 = (uint64_t **)(v5 + 152);
LABEL_98:
            long long v60 = 0;
            CFDictionaryRef v49 = operator new(0x48uLL);
            __p[0] = v49;
            __p[1] = v5 + 152;
            char v50 = v49 + 4;
            if (*((char *)v44 + 55) < 0)
            {
              sub_10004FC84(v50, v44[4], (unint64_t)v44[5]);
            }
            else
            {
              long long v51 = *((_OWORD *)v44 + 2);
              v49[6] = v44[6];
              *(_OWORD *)char v50 = v51;
            }
            v49[7] = v44[7];
            uint64_t v52 = (atomic_ullong *)v44[8];
            v49[8] = v52;
            if (v52) {
              atomic_fetch_add_explicit(v52 + 1, 1uLL, memory_order_relaxed);
            }
            LOBYTE(v60) = 1;
            sub_100046C38((uint64_t **)v5 + 18, v62[0], v48, v49);
            __p[0] = 0;
            sub_1001FEBC4((uint64_t)__p);
            goto LABEL_104;
          }
        }
        v62[0] = (uint64_t)v47;
        unsigned int v48 = (uint64_t **)(v47 + 1);
LABEL_94:
        if (!*v48) {
          goto LABEL_98;
        }
LABEL_104:
        uint64_t v53 = (void **)v44[1];
        if (v53)
        {
          do
          {
            BOOL v54 = v53;
            uint64_t v53 = (void **)*v53;
          }
          while (v53);
        }
        else
        {
          do
          {
            BOOL v54 = (void **)v44[2];
            BOOL v18 = *v54 == v44;
            uint64_t v44 = v54;
          }
          while (!v18);
        }
        uint64_t v44 = v54;
        if (v54 == (void **)(v55 + 80))
        {
          uint64_t v4 = v5 + 24;
          break;
        }
      }
    }
    a2 = v56;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  *a2 = v4;
  a2[1] = v5;
}

void sub_100E69A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void **a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  uint64_t v17 = *a13;
  if (*a13)
  {
    v14[4].__shared_owners_ = (uint64_t)v17;
    operator delete(v17);
  }
  sub_1001FEC70(*v13);
  sub_10026D080(*v15);
  sub_10012577C(a9);
  std::__shared_weak_count::~__shared_weak_count(v14);
  operator delete(v18);
  _Unwind_Resume(a1);
}

void sub_100E69B6C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I invalidate currently settled config", (uint8_t *)&v16, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 216);
  if (v3)
  {
    *(unsigned char *)(v3 + 16) = 1;
    uint64_t v4 = &qword_101B12DC0;
    LOBYTE(v4) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B12DC0, memory_order_acquire);
    if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_101B12DC0))
    {
      CFStringRef v16 = @"SettledConfig";
      sub_100367E88(&unk_101B12DD8, &v16, 1uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, &unk_101B12DD8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B12DC0);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 48));
    uint64_t v6 = ServiceMap;
    uint64_t v7 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      uint64_t v8 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    CFStringRef v16 = (const __CFString *)v7;
    BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v16);
    if (v11)
    {
      uint64_t v13 = (os_unfair_lock_s *)v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_15:
        sub_1000825C4(v13, @"dirty", kCFBooleanTrue, @"SatMsg", (char **)&unk_101B12DD8, 2u, 0, 0);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        sub_100E6822C(a1);
        return;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_15;
  }
  char v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E nothing to invalidate", (uint8_t *)&v16, 2u);
  }
}

void sub_100E69DAC(_Unwind_Exception *a1)
{
}

void sub_100E69DF0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(void *)(a1 + 160))
  {
    if (sub_100E67A44(a3))
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        asString();
        uint64_t v7 = v38 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I event: %s", buf, 0xCu);
        if (SHIBYTE(v38) < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v8 = sub_100046F68(a1 + 176, (void **)a2);
      if ((void **)(a1 + 184) != v8)
      {
        uint64_t v9 = (uint64_t *)v8[7];
        unsigned int v10 = (std::__shared_weak_count *)v8[8];
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v9)
        {
          uint64_t v12 = *a3;
          uint64_t v11 = a3[1];
          if (v11) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v13 = (std::__shared_weak_count *)v9[1];
          *uint64_t v9 = v12;
          v9[1] = v11;
          if (v13) {
            sub_10004D2C8(v13);
          }
        }
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      switch(*(unsigned char *)(a2 + 24))
      {
        case 0:
          char v14 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = *(unsigned __int8 *)(a2 + 23);
            BOOL v16 = (v15 & 0x80u) != 0;
            if ((v15 & 0x80u) != 0) {
              uint64_t v15 = *(void *)(a2 + 8);
            }
            if (v16) {
              uint64_t v17 = *(const char **)a2;
            }
            else {
              uint64_t v17 = (const char *)a2;
            }
            if (v15) {
              BOOL v18 = v17;
            }
            else {
              BOOL v18 = "<invalid>";
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = (void *)v18;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I SIM %s added", (uint8_t *)__p, 0xCu);
          }
          if ((void **)(a1 + 184) == sub_100046F68(a1 + 176, (void **)a2))
          {
            sub_100E7BD1C(buf, *a3, (std::__shared_weak_count *)a3[1]);
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)a2;
              uint64_t v38 = *(void *)(a2 + 16);
            }
            long long v39 = *(_OWORD *)buf;
            sub_100E7BF10((uint64_t **)(a1 + 176), __p, (uint64_t)__p);
            if (*((void *)&v39 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
            }
            if (SHIBYTE(v38) < 0) {
              operator delete(__p[0]);
            }
          }
          break;
        case 1:
          BOOL v20 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = *(unsigned __int8 *)(a2 + 23);
            BOOL v22 = (v21 & 0x80u) != 0;
            if ((v21 & 0x80u) != 0) {
              uint64_t v21 = *(void *)(a2 + 8);
            }
            if (v22) {
              uint64_t v23 = *(const char **)a2;
            }
            else {
              uint64_t v23 = (const char *)a2;
            }
            if (v21) {
              uint64_t v24 = v23;
            }
            else {
              uint64_t v24 = "<invalid>";
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = (void *)v24;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I SIM %s become active", (uint8_t *)__p, 0xCu);
          }
          memset(buf, 0, sizeof(buf));
          sub_100E67AA4((uint64_t *)buf, a1, a2);
          CFMutableArrayRef v25 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v26 = *(unsigned __int8 *)(a2 + 23);
            BOOL v27 = (v26 & 0x80u) != 0;
            if ((v26 & 0x80u) != 0) {
              uint64_t v26 = *(void *)(a2 + 8);
            }
            if (v27) {
              uint64_t v28 = *(const char **)a2;
            }
            else {
              uint64_t v28 = (const char *)a2;
            }
            if (v26) {
              CFArrayRef v29 = v28;
            }
            else {
              CFArrayRef v29 = "<invalid>";
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = (void *)v29;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I simcfg %s:", (uint8_t *)__p, 0xCu);
          }
          char v35 = 0;
          sub_100E646AC(&v36, *(uint64_t *)buf, &v35);
          __p[0] = off_101A647D8;
          __p[1] = (void *)a1;
          *(void *)&long long v39 = __p;
          logger::CFTypeRefLogger();
          sub_10012C330(__p);
          sub_10005717C(&v36);
          sub_10005717C(&v35);
          sub_100E6822C(a1);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          break;
        case 2:
          uint64_t v30 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = *(unsigned __int8 *)(a2 + 23);
            BOOL v32 = (v31 & 0x80u) != 0;
            if ((v31 & 0x80u) != 0) {
              uint64_t v31 = *(void *)(a2 + 8);
            }
            if (v32) {
              unsigned int v33 = *(const char **)a2;
            }
            else {
              unsigned int v33 = (const char *)a2;
            }
            if (v31) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = "<invalid>";
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = (void *)v34;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I SIM %s become inactive", (uint8_t *)__p, 0xCu);
          }
          sub_100E7C424(*(void ****)(a1 + 160), (void **)a2);
          break;
        case 6:
          sub_100E6A33C(a1, (const char **)a2);
          break;
        case 7:
          goto LABEL_36;
        default:
          break;
      }
    }
    else
    {
      sub_100E6A33C(a1, (const char **)a2);
LABEL_36:
      sub_100E6A428((void *)a1, (const char **)a2);
    }
    sub_100E67FAC(a1);
  }
  else
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I module is not yet bootstrapped - ignore handlePersonalityEvent", (uint8_t *)__p, 2u);
    }
  }
}

void sub_100E6A2C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E6A33C(uint64_t a1, const char **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (const char *)*((unsigned __int8 *)a2 + 23);
    BOOL v6 = (char)v5 < 0;
    if ((char)v5 < 0) {
      uint64_t v5 = a2[1];
    }
    if (v6) {
      uint64_t v7 = *a2;
    }
    else {
      uint64_t v7 = (const char *)a2;
    }
    if (v5) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = "<invalid>";
    }
    int v10 = 136315138;
    uint64_t v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SIM %s removed from picture (detached)", (uint8_t *)&v10, 0xCu);
  }
  sub_100E7C424(*(void ****)(a1 + 160), (void **)a2);
  return sub_1000E9358((uint64_t **)(*(void *)(a1 + 160) + 24), (void **)a2);
}

void sub_100E6A428(void *a1, const char **a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (const char *)*((unsigned __int8 *)a2 + 23);
    BOOL v6 = (char)v5 < 0;
    if ((char)v5 < 0) {
      uint64_t v5 = a2[1];
    }
    if (v6) {
      uint64_t v7 = *a2;
    }
    else {
      uint64_t v7 = (const char *)a2;
    }
    if (v5) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = "<invalid>";
    }
    int v17 = 136315138;
    BOOL v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SIM %s removed from models (gone)", (uint8_t *)&v17, 0xCu);
  }
  uint64_t v9 = (void ***)(a1 + 22);
  int v10 = sub_100046F68((uint64_t)(a1 + 22), (void **)a2);
  if (a1 + 23 != v10)
  {
    uint64_t v11 = (uint64_t *)v10;
    uint64_t v12 = (void **)v10[1];
    if (v12)
    {
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = (void **)*v12;
      }
      while (v12);
    }
    else
    {
      char v14 = v10;
      do
      {
        uint64_t v13 = (void **)v14[2];
        BOOL v15 = *v13 == v14;
        char v14 = v13;
      }
      while (!v15);
    }
    if (*v9 == v10) {
      *uint64_t v9 = v13;
    }
    BOOL v16 = (uint64_t *)a1[23];
    --a1[24];
    sub_10005EE6C(v16, v11);
    sub_1001FEC1C((uint64_t)(v11 + 4));
    operator delete(v11);
  }
}

void sub_100E6A57C(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I internet state changes to %s", (uint8_t *)&v5, 0xCu);
  }
  *(unsigned char *)(a1 + 152) = a2;
  if (a2)
  {
    if (*(void *)(a1 + 248)) {
      sub_100E6A644(a1);
    }
  }
}

void sub_100E6A644(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 97) && !*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = (os_log_t *)(a1 + 40);
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I **** prepareAndPublish", buf, 2u);
    }
    uint64_t v4 = *(void *)(a1 + 248);
    if (!v4) {
      __assert_rtn("prepareAndPublish", "SatMsg_ProvisioningImpl_ios.mm", 1579, "fUpcoming");
    }
    int v5 = *(void **)(v4 + 48);
    uint64_t v6 = (void *)(v4 + 56);
    if (v5 == (void *)(v4 + 56)) {
      goto LABEL_391;
    }
    char v7 = 1;
    do
    {
      uint64_t v8 = *(void *)(a1 + 160);
      if ((void **)(v8 + 32) == sub_100046F68(v8 + 24, (void **)v5 + 4))
      {
        if ((uint64_t v9 = v5[7], !*(unsigned char *)(v9 + 24))
          || !*(unsigned char *)(v9 + 56)
          || !*(void *)(v9 + 64)
          || (*(void *)(v9 + 80) ? (int v10 = sub_1000810B8) : (int v10 = 0),
              !v10
           || (*(void *)(v9 + 88) ? (uint64_t v11 = sub_10008324C) : (uint64_t v11 = 0),
               !v11 || (*(void *)(v9 + 96) ? (uint64_t v12 = sub_1000810B8) : (uint64_t v12 = 0), !v12))))
        {
          uint64_t v13 = *v2;
          if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = *((unsigned __int8 *)v5 + 55);
            BOOL v15 = (v14 & 0x80u) != 0;
            if ((v14 & 0x80u) != 0) {
              uint64_t v14 = v5[5];
            }
            if (v15) {
              BOOL v16 = (const char *)v5[4];
            }
            else {
              BOOL v16 = (const char *)(v5 + 4);
            }
            if (v14) {
              int v17 = v16;
            }
            else {
              int v17 = "<invalid>";
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v17;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I no IWF key for %s yet", buf, 0xCu);
          }
          sub_100E6E814(a1, (const char **)v5 + 4);
          char v7 = 0;
        }
      }
      BOOL v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          BOOL v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v5[2];
          BOOL v20 = *v19 == (void)v5;
          int v5 = v19;
        }
        while (!v20);
      }
      int v5 = v19;
    }
    while (v19 != v6);
    if (v7)
    {
LABEL_391:
      if (sub_100E6D750(a1))
      {
        uint64_t v21 = *(void *)(a1 + 248);
        if (!v21) {
          __assert_rtn("prepareAndPublish", "SatMsg_ProvisioningImpl_ios.mm", 1597, "fUpcoming");
        }
        BOOL v22 = *(void ***)(v21 + 48);
        uint64_t v23 = (void **)(v21 + 56);
        if (v22 != (void **)(v21 + 56))
        {
          uint64_t v24 = a1 + 176;
          CFTypeID v210 = (Registry **)(a1 + 48);
          v212 = (void **)(v21 + 56);
          do
          {
            CFMutableArrayRef v25 = sub_100046F68(v24, v22 + 4);
            if ((void **)(a1 + 184) == v25)
            {
              uint64_t v26 = 0;
            }
            else
            {
              BOOL v27 = (PersonalityInfo **)v25[7];
              uint64_t v26 = (std::__shared_weak_count *)v25[8];
              if (v26) {
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (v27)
              {
                uint64_t v28 = v24;
                uint64_t v29 = *(void *)(a1 + 160);
                if ((void **)(v29 + 32) != sub_100046F68(v29 + 24, v22 + 4))
                {
                  uint64_t v30 = *v2;
                  uint64_t v24 = v28;
                  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v31 = (void *)*((unsigned __int8 *)v22 + 55);
                    BOOL v32 = (char)v31 < 0;
                    if ((char)v31 < 0) {
                      uint64_t v31 = v22[5];
                    }
                    if (v32) {
                      unsigned int v33 = (const char *)v22[4];
                    }
                    else {
                      unsigned int v33 = (const char *)(v22 + 4);
                    }
                    BOOL v20 = v31 == 0;
                    uint64_t v34 = "<invalid>";
                    if (!v20) {
                      uint64_t v34 = v33;
                    }
                    *(_DWORD *)long long buf = 136315138;
                    *(void *)&uint8_t buf[4] = v34;
                    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I excluding SIM %s from config as unsupported", buf, 0xCu);
                  }
                  goto LABEL_284;
                }
                uint64_t v42 = sub_100046F68(*(void *)(a1 + 248) + 72, v22 + 4);
                uint64_t v43 = (std::__shared_weak_count *)v42[8];
                uint64_t v214 = (uint64_t)v42[7];
                if (v43) {
                  atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                CFDictionaryRef v211 = v43;
                CFUUIDRef oslog = **(const __CFUUID ***)(a1 + 248);
                uint64_t v44 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v45 = PersonalityInfo::logPrefix(*v27);
                  uint64_t v46 = (char *)*v27 + 24;
                  uint64_t v47 = *((unsigned __int8 *)*v27 + 47);
                  int v48 = (char)v47;
                  if ((v47 & 0x80u) != 0) {
                    uint64_t v47 = *((void *)*v27 + 4);
                  }
                  if (v48 < 0) {
                    uint64_t v46 = (const char *)*((void *)*v27 + 3);
                  }
                  if (!v47) {
                    uint64_t v46 = "<invalid>";
                  }
                  *(_DWORD *)long long buf = 136315650;
                  *(void *)&uint8_t buf[4] = v45;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  v249[0] = v46;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s%srestOfEncryptionProvisioning %s", buf, 0x20u);
                }
                v243 = 0;
                CFTypeID v244 = 0;
                sub_10130EF84((NSObject **)(a1 + 40), @"com.apple.commcenter.ue.satmsg", (const void **)&v243);
                if (v244) {
                  CFDictionaryRef v49 = sub_1008A95D4;
                }
                else {
                  CFDictionaryRef v49 = 0;
                }
                char v50 = *v2;
                long long v51 = *v2;
                if (!v49)
                {
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v70 = PersonalityInfo::logPrefix(*v27);
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v70;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = " ";
                    _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "#E %s%scannot generate UE private key", buf, 0x16u);
                  }
                  goto LABEL_277;
                }
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v52 = PersonalityInfo::logPrefix(*v27);
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v52;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = " ";
                  _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I %s%sUE pubkey lbl:", buf, 0x16u);
                }
                *(void *)long long buf = off_101A64BD8;
                *(void *)&uint8_t buf[8] = a1;
                *(void *)&uint8_t buf[16] = v27;
                v249[0] = buf;
                logger::CFTypeRefLogger();
                sub_10012C330(buf);
                *(void *)&long long v252 = 0;
                *(void *)&long long v252 = SecKeyCopyPublicKey(v244);
                if ((void)v252) {
                  uint64_t v53 = sub_1008A95D4;
                }
                else {
                  uint64_t v53 = 0;
                }
                if (v53)
                {
                  uint64_t v54 = SecKeyCopySubjectPublicKeyInfo();
                  uint64_t v55 = *(void *)(v214 + 64);
                  *(void *)(v214 + 64) = v54;
                  *(void *)long long buf = v55;
                  sub_100030068((const void **)buf);
                  if (*(void *)(v214 + 64)) {
                    char v56 = sub_10008324C;
                  }
                  else {
                    char v56 = 0;
                  }
                  if (v56)
                  {
                    sub_100127DDC((const void **)&v252);
                    xpc_object_t v57 = *v2;
                    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v58 = PersonalityInfo::logPrefix(*v27);
                      *(_DWORD *)long long buf = 136315394;
                      *(void *)&uint8_t buf[4] = v58;
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = " ";
                      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I %s%sUE pubkey:", buf, 0x16u);
                    }
                    *(void *)long long buf = off_101A64C58;
                    *(void *)&uint8_t buf[8] = a1;
                    *(void *)&uint8_t buf[16] = v27;
                    v249[0] = buf;
                    logger::CFTypeRefLogger();
                    sub_10012C330(buf);
                    sub_100E733B0(*v210, (uint64_t)*v27 + 24, oslog, @"ue-pub-key", *(void *)(v214 + 64), (uint64_t *)v210);
                    SecKeyRef v242 = 0;
                    SecKeyRef v242 = (SecKeyRef)SecKeyCreateFromSubjectPublicKeyInfoData();
                    if (v242) {
                      xpc_object_t v59 = sub_1008A95D4;
                    }
                    else {
                      xpc_object_t v59 = 0;
                    }
                    if (v59)
                    {
                      std::string values = &off_101AE6490;
                      keys = (void *)kSecKeyKeyExchangeParameterRequestedSize;
                      CFDictionaryRef v241 = 0;
                      CFDictionaryRef v60 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      CFErrorRef error = 0;
                      CFDictionaryRef v241 = v60;
                      CFDataRef v239 = 0;
                      CFDataRef v239 = SecKeyCopyKeyExchangeResult(v244, kSecKeyAlgorithmECDHKeyExchangeStandard, v242, v60, &error);
                      if (v239) {
                        long long v61 = sub_10008324C;
                      }
                      else {
                        long long v61 = 0;
                      }
                      if (v61)
                      {
                        v237[0] = 0;
                        v237[1] = 0;
                        uint64_t v238 = 0;
                        memset(buf, 0, sizeof(buf));
                        ctu::cf::assign();
                        *(_OWORD *)std::string::size_type v237 = *(_OWORD *)buf;
                        uint64_t v238 = *(void *)&buf[16];
                        v234 = 0;
                        CFTypeID v235 = 0;
                        uint64_t v236 = 0;
                        sub_100E6408C((unint64_t *)&v234, *((CFDataRef *)v22[7] + 11));
                        sub_100E6408C((unint64_t *)&v234, *(CFDataRef *)(v214 + 64));
                        sub_100E63F30((unint64_t *)&v234, (uint64_t)"com.Midway.security.crypto.Mario.ExchangeCredentialKeyDiversifier", 65);
                        sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                        uint64_t v63 = *(void *)buf;
                        unsigned int v62 = *(std::__shared_weak_count **)&buf[8];
                        log = *v2;
                        BOOL v64 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                        v203 = v62;
                        if (v63)
                        {
                          if (v64)
                          {
                            uint64_t v65 = PersonalityInfo::logPrefix(*v27);
                            ctu::hex();
                            char v66 = &v252;
                            if (v253 < 0) {
                              char v66 = (long long *)v252;
                            }
                            *(_DWORD *)long long buf = 136315650;
                            *(void *)&uint8_t buf[4] = v65;
                            *(_WORD *)&unsigned char buf[12] = 2080;
                            *(void *)&buf[14] = " ";
                            *(_WORD *)&unsigned char buf[22] = 2080;
                            v249[0] = v66;
                            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I %s%scredKey: %s", buf, 0x20u);
                            if (SHIBYTE(v253) < 0) {
                              operator delete((void *)v252);
                            }
                          }
                          v232 = 0;
                          uint64_t v233 = 0;
                          std::string __p = 0;
                          sub_10005C928(&__p, *(const void **)v63, *(void *)(v63 + 8), *(void *)(v63 + 8) - *(void *)v63);
                          uint64_t v253 = 0;
                          long long v252 = 0uLL;
                          sub_10005C928(&v252, __p, (uint64_t)v232, v232 - (unsigned char *)__p);
                          CFDictionaryRef v222 = 0;
                          memset(buf, 0, sizeof(buf));
                          sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
                          std::string::size_type v225 = 0;
                          if (ctu::cf::convert_copy())
                          {
                            CFTypeID v67 = v222;
                            CFDictionaryRef v222 = v225;
                            v228 = v67;
                            sub_100030068((const void **)&v228);
                          }
                          if (*(void *)buf)
                          {
                            *(void *)&uint8_t buf[8] = *(void *)buf;
                            operator delete(*(void **)buf);
                          }
                          v218 = v222;
                          CFDictionaryRef v222 = 0;
                          sub_100030068((const void **)&v222);
                          if ((void)v252)
                          {
                            *((void *)&v252 + 1) = v252;
                            operator delete((void *)v252);
                          }
                          CFDictionaryRef v68 = (uint64_t *)(v214 + 72);
                          if ((void **)(v214 + 72) != &v218)
                          {
                            *(void *)long long buf = *v68;
                            uint64_t *v68 = (uint64_t)v218;
                            v218 = 0;
                            sub_100030068((const void **)buf);
                          }
                          sub_100030068((const void **)&v218);
                          if (__p)
                          {
                            v232 = __p;
                            operator delete(__p);
                          }
                          uint64_t v69 = *v68;
                          unsigned int v62 = v203;
                          sub_100E733B0(*v210, (uint64_t)*v27 + 24, oslog, @"cred-key", v69, (uint64_t *)v210);
                        }
                        else if (v64)
                        {
                          uint64_t v82 = PersonalityInfo::logPrefix(*v27);
                          *(_DWORD *)long long buf = 136315394;
                          *(void *)&uint8_t buf[4] = v82;
                          *(_WORD *)&unsigned char buf[12] = 2080;
                          *(void *)&buf[14] = " ";
                          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create credKey", buf, 0x16u);
                        }
                        if (v234)
                        {
                          CFTypeID v235 = (std::__shared_weak_count *)v234;
                          operator delete(v234);
                        }
                        if (v63)
                        {
                          long long v252 = 0uLL;
                          uint64_t v253 = 0;
                          CFNumberRef v83 = sub_100E6408C((unint64_t *)&v252, *((CFDataRef *)v22[7] + 11));
                          unsigned __int8 v84 = sub_100E6408C(v83, *(CFDataRef *)(v214 + 64));
                          xpc_object_t v85 = sub_100E63F30(v84, (uint64_t)"Mario", 5);
                          uint64_t v86 = sub_100E64054(v85, (uint64_t)v22[7]);
                          xpc_object_t v87 = sub_100E64054(v86, (uint64_t)v22[7] + 32);
                          sub_100E63F30(v87, (uint64_t)"com.Midway.security.crypto.Mario.ExchangePrimaryKeyDiversifier", 62);
                          xpc_object_t v88 = v62;
                          sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                          uint64_t v89 = *(NSObject **)buf;
                          unint64_t v200 = *v2;
                          v202 = *(std::__shared_weak_count **)&buf[8];
                          BOOL v90 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                          os_log_t loga = v89;
                          if (v89)
                          {
                            unsigned int v62 = v88;
                            if (v90)
                            {
                              uint64_t v91 = PersonalityInfo::logPrefix(*v27);
                              ctu::hex();
                              CFDictionaryRef v92 = &v234;
                              if (v236 < 0) {
                                CFDictionaryRef v92 = v234;
                              }
                              *(_DWORD *)long long buf = 136315650;
                              *(void *)&uint8_t buf[4] = v91;
                              *(_WORD *)&unsigned char buf[12] = 2080;
                              *(void *)&buf[14] = " ";
                              *(_WORD *)&unsigned char buf[22] = 2080;
                              v249[0] = v92;
                              _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "#I %s%sprimaryKey: %s", buf, 0x20u);
                              if (SHIBYTE(v236) < 0) {
                                operator delete(v234);
                              }
                              unsigned int v62 = v203;
                            }
                          }
                          else
                          {
                            unsigned int v62 = v88;
                            if (v90)
                            {
                              uint64_t v93 = PersonalityInfo::logPrefix(*v27);
                              *(_DWORD *)long long buf = 136315394;
                              *(void *)&uint8_t buf[4] = v93;
                              *(_WORD *)&unsigned char buf[12] = 2080;
                              *(void *)&buf[14] = " ";
                              _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create primaryKey", buf, 0x16u);
                            }
                          }
                          if ((void)v252)
                          {
                            *((void *)&v252 + 1) = v252;
                            operator delete((void *)v252);
                          }
                          if (loga)
                          {
                            v234 = 0;
                            CFTypeID v235 = 0;
                            uint64_t v236 = 0;
                            sub_100E63F30((unint64_t *)&v234, (uint64_t)"com.Midway.security.crypto.Mario.MTKeyInitialRatchetDiversifier", 63);
                            sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                            uint64_t v94 = *(void *)buf;
                            long long v198 = *v2;
                            unint64_t v201 = *(std::__shared_weak_count **)&buf[8];
                            BOOL v95 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                            if (v94)
                            {
                              if (v95)
                              {
                                uint64_t v96 = PersonalityInfo::logPrefix(*v27);
                                ctu::hex();
                                unsigned int v97 = &v252;
                                if (v253 < 0) {
                                  unsigned int v97 = (long long *)v252;
                                }
                                *(_DWORD *)long long buf = 136315650;
                                *(void *)&uint8_t buf[4] = v96;
                                *(_WORD *)&unsigned char buf[12] = 2080;
                                *(void *)&buf[14] = " ";
                                *(_WORD *)&unsigned char buf[22] = 2080;
                                v249[0] = v97;
                                _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_DEFAULT, "#I %s%smtRatchetKey: %s", buf, 0x20u);
                                if (SHIBYTE(v253) < 0) {
                                  operator delete((void *)v252);
                                }
                              }
                              v229 = 0;
                              uint64_t v230 = 0;
                              v228 = 0;
                              sub_10005C928(&v228, *(const void **)v94, *(void *)(v94 + 8), *(void *)(v94 + 8) - *(void *)v94);
                              uint64_t v253 = 0;
                              long long v252 = 0uLL;
                              sub_10005C928(&v252, v228, (uint64_t)v229, v229 - (unsigned char *)v228);
                              v218 = 0;
                              memset(buf, 0, sizeof(buf));
                              sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
                              CFDictionaryRef v222 = 0;
                              if (ctu::cf::convert_copy())
                              {
                                long long v98 = v218;
                                v218 = v222;
                                std::string::size_type v225 = v98;
                                sub_100030068((const void **)&v225);
                              }
                              if (*(void *)buf)
                              {
                                *(void *)&uint8_t buf[8] = *(void *)buf;
                                operator delete(*(void **)buf);
                              }
                              v247 = v218;
                              v218 = 0;
                              sub_100030068((const void **)&v218);
                              if ((void)v252)
                              {
                                *((void *)&v252 + 1) = v252;
                                operator delete((void *)v252);
                              }
                              long long v99 = (uint64_t *)(v214 + 88);
                              if ((void **)(v214 + 88) != &v247)
                              {
                                uint64_t v100 = *v99;
                                uint64_t *v99 = (uint64_t)v247;
                                v247 = 0;
                                *(void *)long long buf = v100;
                                sub_100030068((const void **)buf);
                              }
                              sub_100030068((const void **)&v247);
                              if (v228)
                              {
                                v229 = v228;
                                operator delete(v228);
                              }
                              unsigned int v62 = v203;
                              sub_100E7359C(*v210, (uint64_t)*v27 + 24, oslog, @"mt-key", (void *)(v214 + 88), (uint64_t *)v210);
                            }
                            else if (v95)
                            {
                              uint64_t v101 = PersonalityInfo::logPrefix(*v27);
                              *(_DWORD *)long long buf = 136315394;
                              *(void *)&uint8_t buf[4] = v101;
                              *(_WORD *)&unsigned char buf[12] = 2080;
                              *(void *)&buf[14] = " ";
                              _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create mtRatchetKey", buf, 0x16u);
                            }
                            if (v234)
                            {
                              CFTypeID v235 = (std::__shared_weak_count *)v234;
                              operator delete(v234);
                            }
                            if (v94)
                            {
                              v234 = 0;
                              CFTypeID v235 = 0;
                              uint64_t v236 = 0;
                              sub_100E63F30((unint64_t *)&v234, (uint64_t)"com.Midway.security.crypto.Mario.MOKeyInitialRatchetDiversifier", 63);
                              sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                              uint64_t v102 = *(void *)buf;
                              uint64_t v196 = *v2;
                              uint64_t v199 = *(std::__shared_weak_count **)&buf[8];
                              BOOL v103 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                              if (v102)
                              {
                                if (v103)
                                {
                                  uint64_t v104 = PersonalityInfo::logPrefix(*v27);
                                  ctu::hex();
                                  long long v105 = &v252;
                                  if (v253 < 0) {
                                    long long v105 = (long long *)v252;
                                  }
                                  *(_DWORD *)long long buf = 136315650;
                                  *(void *)&uint8_t buf[4] = v104;
                                  *(_WORD *)&unsigned char buf[12] = 2080;
                                  *(void *)&buf[14] = " ";
                                  *(_WORD *)&unsigned char buf[22] = 2080;
                                  v249[0] = v105;
                                  _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "#I %s%smoRatchetKey: %s", buf, 0x20u);
                                  if (SHIBYTE(v253) < 0) {
                                    operator delete((void *)v252);
                                  }
                                }
                                CFTypeID v226 = 0;
                                uint64_t v227 = 0;
                                std::string::size_type v225 = 0;
                                sub_10005C928(&v225, *(const void **)v102, *(void *)(v102 + 8), *(void *)(v102 + 8) - *(void *)v102);
                                uint64_t v253 = 0;
                                long long v252 = 0uLL;
                                sub_10005C928(&v252, v225, (uint64_t)v226, v226 - (unsigned char *)v225);
                                v247 = 0;
                                memset(buf, 0, sizeof(buf));
                                sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
                                v218 = 0;
                                if (ctu::cf::convert_copy())
                                {
                                  long long v106 = v247;
                                  v247 = v218;
                                  CFDictionaryRef v222 = v106;
                                  sub_100030068((const void **)&v222);
                                }
                                if (*(void *)buf)
                                {
                                  *(void *)&uint8_t buf[8] = *(void *)buf;
                                  operator delete(*(void **)buf);
                                }
                                v246 = v247;
                                v247 = 0;
                                sub_100030068((const void **)&v247);
                                if ((void)v252)
                                {
                                  *((void *)&v252 + 1) = v252;
                                  operator delete((void *)v252);
                                }
                                uint64_t v107 = (void *)(v214 + 152);
                                if ((void **)(v214 + 152) != &v246)
                                {
                                  *(void *)long long buf = *v107;
                                  void *v107 = v246;
                                  v246 = 0;
                                  sub_100030068((const void **)buf);
                                }
                                sub_100030068((const void **)&v246);
                                if (v225)
                                {
                                  CFTypeID v226 = v225;
                                  operator delete(v225);
                                }
                                sub_100E7359C(*v210, (uint64_t)*v27 + 24, oslog, @"mo-key", v107, (uint64_t *)v210);
                              }
                              else if (v103)
                              {
                                uint64_t v108 = PersonalityInfo::logPrefix(*v27);
                                *(_DWORD *)long long buf = 136315394;
                                *(void *)&uint8_t buf[4] = v108;
                                *(_WORD *)&unsigned char buf[12] = 2080;
                                *(void *)&buf[14] = " ";
                                _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create moRatchetKey", buf, 0x16u);
                              }
                              if (v234)
                              {
                                CFTypeID v235 = (std::__shared_weak_count *)v234;
                                operator delete(v234);
                              }
                              if (v102)
                              {
                                v234 = 0;
                                CFTypeID v235 = 0;
                                uint64_t v236 = 0;
                                sub_100E63F30((unint64_t *)&v234, (uint64_t)"com.Midway.security.crypto.Mario.HMACLinkKey", 44);
                                sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                                uint64_t v110 = *(void *)buf;
                                unsigned int v109 = *(std::__shared_weak_count **)&buf[8];
                                uint64_t v194 = *v2;
                                BOOL v111 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                                os_log_t v197 = (os_log_t)v109;
                                if (v110)
                                {
                                  if (v111)
                                  {
                                    uint64_t v112 = PersonalityInfo::logPrefix(*v27);
                                    ctu::hex();
                                    char v113 = &v252;
                                    if (v253 < 0) {
                                      char v113 = (long long *)v252;
                                    }
                                    *(_DWORD *)long long buf = 136315650;
                                    *(void *)&uint8_t buf[4] = v112;
                                    *(_WORD *)&unsigned char buf[12] = 2080;
                                    *(void *)&buf[14] = " ";
                                    *(_WORD *)&unsigned char buf[22] = 2080;
                                    v249[0] = v113;
                                    _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "#I %s%shmacLinkSymKey: %s", buf, 0x20u);
                                    if (SHIBYTE(v253) < 0) {
                                      operator delete((void *)v252);
                                    }
                                  }
                                  v223 = 0;
                                  uint64_t v224 = 0;
                                  CFDictionaryRef v222 = 0;
                                  sub_10005C928(&v222, *(const void **)v110, *(void *)(v110 + 8), *(void *)(v110 + 8) - *(void *)v110);
                                  uint64_t v253 = 0;
                                  long long v252 = 0uLL;
                                  sub_10005C928(&v252, v222, (uint64_t)v223, v223 - (unsigned char *)v222);
                                  v246 = 0;
                                  memset(buf, 0, sizeof(buf));
                                  sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
                                  v247 = 0;
                                  if (ctu::cf::convert_copy())
                                  {
                                    uint64_t v114 = v246;
                                    v246 = v247;
                                    v218 = v114;
                                    sub_100030068((const void **)&v218);
                                  }
                                  if (*(void *)buf)
                                  {
                                    *(void *)&uint8_t buf[8] = *(void *)buf;
                                    operator delete(*(void **)buf);
                                  }
                                  v245 = v246;
                                  v246 = 0;
                                  sub_100030068((const void **)&v246);
                                  if ((void)v252)
                                  {
                                    *((void *)&v252 + 1) = v252;
                                    operator delete((void *)v252);
                                  }
                                  std::string::size_type v115 = (uint64_t *)(v214 + 184);
                                  if ((void **)(v214 + 184) != &v245)
                                  {
                                    *(void *)long long buf = *v115;
                                    uint64_t *v115 = (uint64_t)v245;
                                    v245 = 0;
                                    sub_100030068((const void **)buf);
                                  }
                                  sub_100030068((const void **)&v245);
                                  if (v222)
                                  {
                                    v223 = v222;
                                    operator delete(v222);
                                  }
                                  uint64_t v116 = *v115;
                                  unsigned int v109 = (std::__shared_weak_count *)v197;
                                  sub_100E733B0(*v210, (uint64_t)*v27 + 24, oslog, @"hmac-link-key", v116, (uint64_t *)v210);
                                }
                                else if (v111)
                                {
                                  uint64_t v117 = PersonalityInfo::logPrefix(*v27);
                                  *(_DWORD *)long long buf = 136315394;
                                  *(void *)&uint8_t buf[4] = v117;
                                  *(_WORD *)&unsigned char buf[12] = 2080;
                                  *(void *)&buf[14] = " ";
                                  _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create hmacLinkSymKey", buf, 0x16u);
                                }
                                if (v234)
                                {
                                  CFTypeID v235 = (std::__shared_weak_count *)v234;
                                  operator delete(v234);
                                }
                                if (v110)
                                {
                                  v234 = 0;
                                  CFTypeID v235 = 0;
                                  uint64_t v236 = 0;
                                  sub_100E63F30((unint64_t *)&v234, (uint64_t)"com.Midway.security.crypto.Mario.PseudonymTagKeyDiversifier", 59);
                                  sub_100BCB554((os_log_t *)(a1 + 40), 0x20uLL, buf);
                                  uint64_t v118 = *(NSObject **)buf;
                                  BOOL v193 = *v2;
                                  os_log_t v195 = *(os_log_t *)&buf[8];
                                  BOOL v119 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
                                  os_log_t logb = v118;
                                  if (v118)
                                  {
                                    long long v120 = (std::__shared_weak_count *)v195;
                                    if (v119)
                                    {
                                      uint64_t v121 = PersonalityInfo::logPrefix(*v27);
                                      ctu::hex();
                                      CFIndex v122 = &v252;
                                      if (v253 < 0) {
                                        CFIndex v122 = (long long *)v252;
                                      }
                                      *(_DWORD *)long long buf = 136315650;
                                      *(void *)&uint8_t buf[4] = v121;
                                      *(_WORD *)&unsigned char buf[12] = 2080;
                                      *(void *)&buf[14] = " ";
                                      *(_WORD *)&unsigned char buf[22] = 2080;
                                      v249[0] = v122;
                                      _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "#I %s%smsisdnTagsKey: %s", buf, 0x20u);
                                      if (SHIBYTE(v253) < 0) {
                                        operator delete((void *)v252);
                                      }
                                    }
                                    v219 = 0;
                                    uint64_t v220 = 0;
                                    v218 = 0;
                                    sub_10005C928(&v218, logb->isa, (uint64_t)logb[1].isa, logb[1].isa - logb->isa);
                                    uint64_t v253 = 0;
                                    long long v252 = 0uLL;
                                    sub_10005C928(&v252, v218, (uint64_t)v219, v219 - (unsigned char *)v218);
                                    v245 = 0;
                                    memset(buf, 0, sizeof(buf));
                                    sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
                                    v246 = 0;
                                    if (ctu::cf::convert_copy())
                                    {
                                      uint64_t v123 = v245;
                                      v245 = v246;
                                      v247 = v123;
                                      sub_100030068((const void **)&v247);
                                    }
                                    if (*(void *)buf)
                                    {
                                      *(void *)&uint8_t buf[8] = *(void *)buf;
                                      operator delete(*(void **)buf);
                                    }
                                    uint64_t v221 = (uint64_t)v245;
                                    v245 = 0;
                                    sub_100030068((const void **)&v245);
                                    if ((void)v252)
                                    {
                                      *((void *)&v252 + 1) = v252;
                                      operator delete((void *)v252);
                                    }
                                    CFDictionaryRef v124 = (uint64_t *)(v214 + 80);
                                    if ((uint64_t *)(v214 + 80) != &v221)
                                    {
                                      *(void *)long long buf = *v124;
                                      uint64_t *v124 = v221;
                                      uint64_t v221 = 0;
                                      sub_100030068((const void **)buf);
                                    }
                                    sub_100030068((const void **)&v221);
                                    if (v218)
                                    {
                                      v219 = v218;
                                      operator delete(v218);
                                    }
                                    uint64_t v125 = *v124;
                                    unsigned int v109 = (std::__shared_weak_count *)v197;
                                    sub_100E733B0(*v210, (uint64_t)*v27 + 24, oslog, @"msisdn-key", v125, (uint64_t *)v210);
                                  }
                                  else
                                  {
                                    long long v120 = (std::__shared_weak_count *)v195;
                                    if (v119)
                                    {
                                      uint64_t v126 = PersonalityInfo::logPrefix(*v27);
                                      *(_DWORD *)long long buf = 136315394;
                                      *(void *)&uint8_t buf[4] = v126;
                                      *(_WORD *)&unsigned char buf[12] = 2080;
                                      *(void *)&buf[14] = " ";
                                      _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to create msisdnTagsKey", buf, 0x16u);
                                    }
                                  }
                                  if (v234)
                                  {
                                    CFTypeID v235 = (std::__shared_weak_count *)v234;
                                    operator delete(v234);
                                  }
                                  if (logb)
                                  {
                                    int v127 = sub_10130F4AC((uint64_t)v210, a1 + 40, v243);
                                    uint64_t v128 = *v2;
                                    if (v127)
                                    {
                                      osos_log_t loga = *v2;
                                      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
                                      {
                                        uint64_t v129 = PersonalityInfo::logPrefix(*v27);
                                        *(_DWORD *)long long buf = 136315906;
                                        *(void *)&uint8_t buf[4] = v129;
                                        *(_WORD *)&unsigned char buf[12] = 2080;
                                        *(void *)&buf[14] = " ";
                                        *(_WORD *)&unsigned char buf[22] = 1024;
                                        LODWORD(v249[0]) = v127;
                                        WORD2(v249[0]) = 2112;
                                        *(void *)((char *)v249 + 6) = v243;
                                        _os_log_impl((void *)&_mh_execute_header, osloga, OS_LOG_TYPE_DEFAULT, "#W %s%sfailed (err:%d) to remove key with lbl:%@", buf, 0x26u);
                                        uint64_t v128 = *v2;
                                      }
                                      else
                                      {
                                        uint64_t v128 = osloga;
                                      }
                                    }
                                    osos_log_t logb = v128;
                                    unsigned int v109 = (std::__shared_weak_count *)v197;
                                    if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
                                    {
                                      uint64_t v130 = PersonalityInfo::logPrefix(*v27);
                                      CFTypeID v131 = (char *)*v27 + 24;
                                      uint64_t v132 = *((unsigned __int8 *)*v27 + 47);
                                      int v133 = (char)v132;
                                      if ((v132 & 0x80u) != 0) {
                                        uint64_t v132 = *((void *)*v27 + 4);
                                      }
                                      if (v133 < 0) {
                                        CFTypeID v131 = (const char *)*((void *)*v27 + 3);
                                      }
                                      if (!v132) {
                                        CFTypeID v131 = "<invalid>";
                                      }
                                      *(_DWORD *)long long buf = 136315650;
                                      *(void *)&uint8_t buf[4] = v130;
                                      *(_WORD *)&unsigned char buf[12] = 2080;
                                      *(void *)&buf[14] = " ";
                                      *(_WORD *)&unsigned char buf[22] = 2080;
                                      v249[0] = v131;
                                      _os_log_impl((void *)&_mh_execute_header, oslogb, OS_LOG_TYPE_DEFAULT, "#I %s%sencryption for %s is ready", buf, 0x20u);
                                    }
                                  }
                                  if (v120) {
                                    sub_10004D2C8(v120);
                                  }
                                }
                                if (v109) {
                                  sub_10004D2C8(v109);
                                }
                              }
                              unsigned int v62 = v203;
                              if (v199) {
                                sub_10004D2C8(v199);
                              }
                            }
                            if (v201) {
                              sub_10004D2C8(v201);
                            }
                          }
                          if (v202) {
                            sub_10004D2C8(v202);
                          }
                        }
                        if (v62) {
                          sub_10004D2C8(v62);
                        }
                        if (v237[0])
                        {
                          v237[1] = v237[0];
                          operator delete(v237[0]);
                        }
                      }
                      else
                      {
                        xpc_object_t v80 = *v2;
                        if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v81 = PersonalityInfo::logPrefix(*v27);
                          *(_DWORD *)long long buf = 136315650;
                          *(void *)&uint8_t buf[4] = v81;
                          *(_WORD *)&unsigned char buf[12] = 2080;
                          *(void *)&buf[14] = " ";
                          *(_WORD *)&unsigned char buf[22] = 2112;
                          v249[0] = error;
                          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to generate shared secret, error:%@", buf, 0x20u);
                        }
                      }
                      sub_100030068((const void **)&v239);
                      sub_100057D78((const void **)&v241);
                    }
                    else
                    {
                      CFIndex v78 = *v2;
                      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v79 = PersonalityInfo::logPrefix(*v27);
                        *(_DWORD *)long long buf = 136315394;
                        *(void *)&uint8_t buf[4] = v79;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = " ";
                        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to import IWF pubkey", buf, 0x16u);
                      }
                    }
                    xpc_object_t v77 = (const void **)&v242;
LABEL_276:
                    sub_100127DDC(v77);
LABEL_277:
                    sub_100127DDC((const void **)&v244);
                    sub_100030068((const void **)&v243);
                    if (!sub_100E677C0(v214))
                    {
                      CFTypeID v134 = *v2;
                      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v135 = PersonalityInfo::logPrefix(*v27);
                        *(_DWORD *)long long buf = 136315394;
                        *(void *)&uint8_t buf[4] = v135;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = " ";
                        _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEFAULT, "#W %s%sfailed to complete encryption components", buf, 0x16u);
                      }
                      sub_100C36C48((uint64_t **)(*(void *)(a1 + 160) + 24), v22 + 4, (uint64_t)(v22 + 4));
                    }
                    if (v211) {
                      sub_10004D2C8(v211);
                    }
                    uint64_t v24 = v28;
LABEL_284:
                    uint64_t v23 = v212;
                    if (!v26) {
                      goto LABEL_73;
                    }
                    goto LABEL_72;
                  }
                  os_log_t v75 = *v2;
                  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v76 = PersonalityInfo::logPrefix(*v27);
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v76;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = " ";
                    CFTypeID v73 = v75;
                    uint64_t v74 = "#W %s%scannot export DER from UE public key";
LABEL_137:
                    _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, v74, buf, 0x16u);
                  }
                }
                else
                {
                  os_log_t v71 = *v2;
                  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v72 = PersonalityInfo::logPrefix(*v27);
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v72;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = " ";
                    CFTypeID v73 = v71;
                    uint64_t v74 = "#W %s%sFailed to get public key for private";
                    goto LABEL_137;
                  }
                }
                xpc_object_t v77 = (const void **)&v252;
                goto LABEL_276;
              }
            }
            char v35 = *v2;
            if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v36 = (void *)*((unsigned __int8 *)v22 + 55);
              BOOL v37 = (char)v36 < 0;
              if ((char)v36 < 0) {
                uint64_t v36 = v22[5];
              }
              if (v37) {
                uint64_t v38 = (const char *)v22[4];
              }
              else {
                uint64_t v38 = (const char *)(v22 + 4);
              }
              BOOL v20 = v36 == 0;
              long long v39 = "<invalid>";
              if (!v20) {
                long long v39 = v38;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v39;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#E model is not found for %s, strange but going forward", buf, 0xCu);
            }
            if (!v26) {
              goto LABEL_73;
            }
LABEL_72:
            sub_10004D2C8(v26);
LABEL_73:
            unsigned int v40 = (void **)v22[1];
            if (v40)
            {
              do
              {
                uint64_t v41 = v40;
                unsigned int v40 = (void **)*v40;
              }
              while (v40);
            }
            else
            {
              do
              {
                uint64_t v41 = (void **)v22[2];
                BOOL v20 = *v41 == v22;
                BOOL v22 = v41;
              }
              while (!v20);
            }
            BOOL v22 = v41;
          }
          while (v41 != v23);
        }
        if (sub_100E6D750(a1))
        {
          uint64_t v136 = *(void *)(a1 + 248);
          CFTypeID v137 = *(char **)(v136 + 96);
          buf[0] = 0;
          unint64_t v138 = *(void *)(v136 + 104) - (void)v137;
          if (v138 > 0xF)
          {
            if (v138 != 16) {
              *(void *)(v136 + 104) = v137 + 16;
            }
          }
          else
          {
            sub_1004A5238((void *)(v136 + 96), 16 - v138, buf);
            CFTypeID v137 = *(char **)(*(void *)(a1 + 248) + 96);
          }
          int v139 = SecRandomCopyBytes(kSecRandomDefault, 0x10uLL, v137);
          unsigned int v140 = *v2;
          BOOL v141 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
          if (!v139)
          {
            if (v141)
            {
              ctu::hex();
              CFStringRef v143 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
              LODWORD(v252) = 136315138;
              *(void *)((char *)&v252 + 4) = v143;
              _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "#I created offgrid key: %s", (uint8_t *)&v252, 0xCu);
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
            }
            CFDictionaryRef v222 = 0;
            sub_100E6EBA8((const void **)&v222, **(const __CFUUID ***)(a1 + 248));
            v237[0] = 0;
            v237[1] = 0;
            uint64_t v238 = 0;
            *(void *)long long buf = v222;
            sub_100367E88(v237, buf, 1uLL);
            sub_100E66CC0(*(Registry **)(a1 + 48), &v234, v144);
            os_log_t v145 = (os_unfair_lock_s *)v234;
            uint64_t v146 = *(void *)(a1 + 248);
            v216 = 0;
            uint64_t v217 = 0;
            std::string::size_type v215 = 0;
            sub_10005C928(&v215, *(const void **)(v146 + 96), *(void *)(v146 + 104), *(void *)(v146 + 104) - *(void *)(v146 + 96));
            uint64_t v253 = 0;
            long long v252 = 0uLL;
            sub_10005C928(&v252, v215, (uint64_t)v216, v216 - (unsigned char *)v215);
            std::string::size_type v225 = 0;
            memset(buf, 0, sizeof(buf));
            sub_10005C928(buf, (const void *)v252, *((uint64_t *)&v252 + 1), *((void *)&v252 + 1) - v252);
            v228 = 0;
            if (ctu::cf::convert_copy())
            {
              CFArrayRef v147 = v225;
              std::string::size_type v225 = v228;
              std::string __p = v147;
              sub_100030068((const void **)&__p);
            }
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              operator delete(*(void **)buf);
            }
            v218 = v225;
            std::string::size_type v225 = 0;
            sub_100030068((const void **)&v225);
            if ((void)v252)
            {
              *((void *)&v252 + 1) = v252;
              operator delete((void *)v252);
            }
            sub_1000825C4(v145, @"offgridKey", v218, @"SatMsg", (char **)v237, 4u, 0, 0);
            sub_100030068((const void **)&v218);
            if (v215)
            {
              v216 = v215;
              operator delete(v215);
            }
            std::string::size_type v213 = (Registry **)(a1 + 48);
            if (v235) {
              sub_10004D2C8(v235);
            }
            uint64_t v148 = *(void *)(a1 + 160);
            CFTypeID v149 = *(void **)(v148 + 24);
            uint64_t v150 = (void *)(v148 + 32);
            if (v149 != (void *)(v148 + 32))
            {
              do
              {
                unsigned int v151 = *v2;
                if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v152 = *((unsigned __int8 *)v149 + 55);
                  BOOL v153 = (v152 & 0x80u) != 0;
                  if ((v152 & 0x80u) != 0) {
                    uint64_t v152 = v149[5];
                  }
                  if (v153) {
                    dispatch_group_t v154 = (const char *)v149[4];
                  }
                  else {
                    dispatch_group_t v154 = (const char *)(v149 + 4);
                  }
                  BOOL v20 = v152 == 0;
                  char v155 = "<invalid>";
                  if (!v20) {
                    char v155 = v154;
                  }
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v155;
                  _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I making sure SIM %s is not in the config", buf, 0xCu);
                }
                sub_100E7C424((void ***)(*(void *)(a1 + 248) + 48), (void **)v149 + 4);
                uint64_t v156 = *(void *)(a1 + 248);
                BOOL v157 = (void ***)(v156 + 72);
                dispatch_group_t v158 = sub_100046F68(v156 + 72, (void **)v149 + 4);
                if ((void **)(v156 + 80) != v158)
                {
                  dispatch_object_t v159 = (uint64_t *)v158;
                  CFTypeID v160 = (void **)v158[1];
                  if (v160)
                  {
                    do
                    {
                      char v161 = v160;
                      CFTypeID v160 = (void **)*v160;
                    }
                    while (v160);
                  }
                  else
                  {
                    std::string::size_type v162 = v158;
                    do
                    {
                      char v161 = (void **)v162[2];
                      BOOL v20 = *v161 == v162;
                      std::string::size_type v162 = v161;
                    }
                    while (!v20);
                  }
                  if (*v157 == v158) {
                    *BOOL v157 = v161;
                  }
                  uint64_t v163 = *(uint64_t **)(v156 + 80);
                  --*(void *)(v156 + 88);
                  sub_10005EE6C(v163, v159);
                  sub_1001FEC1C((uint64_t)(v159 + 4));
                  operator delete(v159);
                }
                uint64_t v164 = *(void *)(a1 + 248);
                v165 = *(unsigned __int8 **)(v164 + 24);
                uint64_t v166 = (unsigned __int8 *)(v164 + 32);
                if (v165 != (unsigned __int8 *)(v164 + 32))
                {
                  while (!sub_10001D294(v165 + 40, (unsigned __int8 *)v149 + 32))
                  {
                    v167 = (unsigned __int8 *)*((void *)v165 + 1);
                    if (v167)
                    {
                      do
                      {
                        int v168 = v167;
                        v167 = *(unsigned __int8 **)v167;
                      }
                      while (v167);
                    }
                    else
                    {
                      do
                      {
                        int v168 = (unsigned __int8 *)*((void *)v165 + 2);
                        BOOL v20 = *(void *)v168 == (void)v165;
                        v165 = v168;
                      }
                      while (!v20);
                    }
                    v165 = v168;
                    if (v168 == v166) {
                      goto LABEL_361;
                    }
                  }
                  int v169 = *(void **)(a1 + 248);
                  int v170 = (uint64_t *)v169[4];
                  if (v170)
                  {
                    int v171 = *((_DWORD *)v165 + 8);
                    BOOL v172 = v169 + 4;
                    uint64_t v173 = v169[4];
                    do
                    {
                      int v174 = *(_DWORD *)(v173 + 32);
                      BOOL v175 = v174 < v171;
                      if (v174 >= v171) {
                        CFIndex v176 = (uint64_t *)v173;
                      }
                      else {
                        CFIndex v176 = (uint64_t *)(v173 + 8);
                      }
                      if (!v175) {
                        BOOL v172 = (void *)v173;
                      }
                      uint64_t v173 = *v176;
                    }
                    while (*v176);
                    if (v172 != v169 + 4 && *((_DWORD *)v172 + 8) <= v171)
                    {
                      uint64_t v177 = (void *)v172[1];
                      int v178 = v172;
                      if (v177)
                      {
                        do
                        {
                          uint64_t v179 = v177;
                          uint64_t v177 = (void *)*v177;
                        }
                        while (v177);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v179 = (void *)v178[2];
                          BOOL v20 = *v179 == (void)v178;
                          int v178 = v179;
                        }
                        while (!v20);
                      }
                      if ((void *)v169[3] == v172) {
                        v169[3] = v179;
                      }
                      --v169[5];
                      sub_10005EE6C(v170, v172);
                      if (*((char *)v172 + 63) < 0) {
                        operator delete((void *)v172[5]);
                      }
                      operator delete(v172);
                    }
                  }
                }
LABEL_361:
                CFTypeID v180 = (void *)v149[1];
                if (v180)
                {
                  do
                  {
                    char v181 = v180;
                    CFTypeID v180 = (void *)*v180;
                  }
                  while (v180);
                }
                else
                {
                  do
                  {
                    char v181 = (void *)v149[2];
                    BOOL v20 = *v181 == (void)v149;
                    CFTypeID v149 = v181;
                  }
                  while (!v20);
                }
                CFTypeID v149 = v181;
              }
              while (v181 != v150);
            }
            std::string::size_type v182 = *v2;
            if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = "<upcoming>";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "<proposed>";
              _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEFAULT, "#I moving %s to %s", buf, 0x16u);
            }
            uint64_t v184 = *(void *)(a1 + 232);
            if (v184)
            {
              sub_100E670C0(v184, v213, v183);
              sub_100E66CC0(*v213, buf, v185);
              sub_1000832B0(*(os_unfair_lock_s **)buf, @"ProposedConfig", @"SatMsg", 0, 2u);
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
            }
            uint64_t v187 = *(void *)(a1 + 248);
            CFStringRef v186 = *(uint64_t **)(a1 + 256);
            if (v186) {
              atomic_fetch_add_explicit(v186 + 1, 1uLL, memory_order_relaxed);
            }
            CFDictionaryRef v188 = *(std::__shared_weak_count **)(a1 + 240);
            *(void *)(a1 + 232) = v187;
            *(void *)(a1 + 240) = v186;
            if (v188) {
              sub_10004D2C8(v188);
            }
            int v189 = *(std::__shared_weak_count **)(a1 + 256);
            *(void *)(a1 + 248) = 0;
            *(void *)(a1 + 256) = 0;
            if (v189) {
              sub_10004D2C8(v189);
            }
            sub_100E66CC0(*v213, buf, v186);
            sub_1000832B0(*(os_unfair_lock_s **)buf, @"UpcomingConfig", @"SatMsg", 0, 2u);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            *(void *)&long long v252 = 0;
            sub_100E6E180(&v252, *(void *)(a1 + 232), 0);
            sub_100E66CC0(*v213, buf, v190);
            sub_1000825C4(*(os_unfair_lock_s **)buf, @"ProposedConfig", (const void *)v252, @"SatMsg", 0, 2u, 0, 0);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            sub_100057D78((const void **)&v252);
            if (v237[0])
            {
              v237[1] = v237[0];
              operator delete(v237[0]);
            }
            sub_1000558F4((const void **)&v222);
            int v191 = *v2;
            if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v192 = **(void **)(a1 + 232);
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v192;
              _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "#I config %@ is ready", buf, 0xCu);
            }
            *(void *)long long buf = a1;
            sub_10012A394((const void **)&buf[8], *(const void ***)(a1 + 232));
            sub_100E6EC0C(a1 + 8);
          }
          if (v141)
          {
            int v142 = *__error();
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v142;
            _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "#I SecRandomCopyBytes failed, errno %d", buf, 8u);
            unsigned int v140 = *v2;
          }
          *(void *)(*(void *)(a1 + 248) + 104) = *(void *)(*(void *)(a1 + 248) + 96);
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "#E config is not complete... see logs above", buf, 2u);
          }
        }
      }
    }
  }
}

void sub_100E6C834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, std::__shared_weak_count *a11, std::__shared_weak_count *a12, std::__shared_weak_count *a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,const void **a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,const void *a60)
{
  if (__p) {
    operator delete(__p);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a57) {
    operator delete(a57);
  }
  sub_100030068(&a60);
  sub_100057D78((const void **)(v61 - 248));
  sub_100127DDC((const void **)(v61 - 240));
  sub_100127DDC(a26);
  sub_100030068((const void **)(v61 - 232));
  if (a29) {
    sub_10004D2C8(a29);
  }
  if (v60) {
    sub_10004D2C8(v60);
  }
  _Unwind_Resume(a1);
}

void sub_100E6CD40(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 160);
  if (v1)
  {
    uint64_t v4 = (void **)*v1;
    uint64_t v3 = (void **)(v1 + 1);
    uint64_t v2 = v4;
    if (v4 != v3)
    {
      uint64_t v5 = a1 + 104;
      uint64_t v6 = (void **)(a1 + 112);
      uint64_t v49 = a1 + 176;
      int v48 = (void **)(a1 + 184);
      uint64_t v45 = a1 + 104;
      uint64_t v46 = a1 + 112;
      while (1)
      {
        char v7 = sub_100046F68(v5, v2 + 4);
        if (v6 != v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = sub_100046F68(v49, v2 + 4);
          if (v48 != v9) {
            break;
          }
        }
LABEL_64:
        uint64_t v41 = (void **)v2[1];
        if (v41)
        {
          do
          {
            uint64_t v42 = v41;
            uint64_t v41 = (void **)*v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            uint64_t v42 = (void **)v2[2];
            BOOL v43 = *v42 == v2;
            uint64_t v2 = v42;
          }
          while (!v43);
        }
        uint64_t v2 = v42;
        if (v42 == v3) {
          return;
        }
      }
      uint64_t v11 = (char *)v9[7];
      int v10 = (std::__shared_weak_count *)v9[8];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v11)
      {
LABEL_62:
        uint64_t v6 = (void **)v46;
        if (v10) {
          sub_10004D2C8(v10);
        }
        goto LABEL_64;
      }
      uint64_t v12 = (const void **)(v11 + 16);
      uint64_t v13 = v11[39];
      if ((v13 & 0x80u) == 0) {
        unint64_t v14 = v11[39];
      }
      else {
        unint64_t v14 = *((void *)v11 + 3);
      }
      BOOL v15 = (void *)*((unsigned __int8 *)v8 + 103);
      int v16 = (char)v15;
      if ((char)v15 < 0) {
        BOOL v15 = v8[11];
      }
      if ((void *)v14 == v15)
      {
        if (v16 >= 0) {
          int v17 = (unsigned __int8 *)(v8 + 10);
        }
        else {
          int v17 = (unsigned __int8 *)v8[10];
        }
        if ((v13 & 0x80) != 0)
        {
          if (!memcmp(*v12, v17, *((void *)v11 + 3))) {
            goto LABEL_62;
          }
        }
        else
        {
          if (!v11[39]) {
            goto LABEL_62;
          }
          BOOL v18 = (unsigned __int8 *)(v11 + 16);
          while (*v18 == *v17)
          {
            ++v18;
            ++v17;
            if (!--v13) {
              goto LABEL_62;
            }
          }
        }
      }
      std::string::operator=((std::string *)(v11 + 16), (const std::string *)(v8 + 10));
      uint64_t v19 = v11 + 40;
      std::string::operator=((std::string *)(v11 + 40), (const std::string *)(v8 + 13));
      BOOL v20 = (const std::string *)(v8 + 16);
      uint64_t v21 = v11 + 64;
      std::string::operator=((std::string *)(v11 + 64), v20);
      BOOL v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v11);
        uint64_t v24 = v11 + 16;
        if (v11[39] < 0) {
          uint64_t v24 = *v12;
        }
        if (v11[63] < 0) {
          uint64_t v19 = (void *)*v19;
        }
        if (v11[87] < 0) {
          uint64_t v21 = (void *)*v21;
        }
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        xpc_object_t v59 = v24;
        __int16 v60 = 2080;
        uint64_t v61 = v19;
        __int16 v62 = 2080;
        uint64_t v63 = v21;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sobtained IMSI:%s -> MCC:%s MNC:%s", buf, 0x34u);
      }
      if (!sub_100197A80((unsigned __int8 *)v2[7], (unsigned __int8 *)v11 + 16)) {
        goto LABEL_62;
      }
      sub_100093B44((std::string *)v2[7], (const std::string *)(v11 + 16));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12DC8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B12DC8))
      {
        qword_101B12DF0 = 0;
        qword_101B12DF8 = 0;
        qword_101B12E00 = 0;
        uint64_t v44 = operator new(8uLL);
        qword_101B12DF0 = (uint64_t)v44;
        void *v44 = @"sim-cfg";
        qword_101B12DF8 = (uint64_t)(v44 + 1);
        qword_101B12E00 = (uint64_t)(v44 + 1);
        __cxa_atexit((void (*)(void *))sub_100367F0C, &qword_101B12DF0, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_101B12DC8);
        uint64_t v5 = v45;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)a1, *(Registry **)(a1 + 48));
      uint64_t v26 = ServiceMap;
      if (v27 < 0)
      {
        uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v29 = 5381;
        do
        {
          uint64_t v27 = v29;
          unsigned int v30 = *v28++;
          uint64_t v29 = (33 * v29) ^ v30;
        }
        while (v30);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v27;
      uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
      if (v31)
      {
        uint64_t v33 = v31[3];
        uint64_t v32 = v31[4];
        if (v32)
        {
          uint64_t v34 = (std::__shared_weak_count *)v31[4];
          char v35 = (atomic_ullong *)(v32 + 8);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
          std::mutex::unlock(v26);
          atomic_fetch_add_explicit(v35, 1uLL, memory_order_relaxed);
          uint64_t v36 = v34;
          uint64_t v5 = v45;
          sub_10004D2C8(v36);
          char v37 = 0;
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      std::mutex::unlock(v26);
      uint64_t v36 = 0;
      char v37 = 1;
LABEL_43:
      if (v11[39] < 0)
      {
        sub_10004FC84(__dst, *((void **)v11 + 2), *((void *)v11 + 3));
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)v12;
        uint64_t v51 = *((void *)v11 + 4);
      }
      if (SHIBYTE(v51) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v55 = v51;
      }
      uint64_t v53 = 0;
      if (SHIBYTE(v55) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        *(void *)&uint8_t buf[16] = v55;
      }
      char v56 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v38 = v53;
        uint64_t v53 = v56;
        xpc_object_t v57 = v38;
        sub_1000558F4(&v57);
      }
      char v39 = v37;
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      unsigned int v40 = v53;
      uint64_t v52 = v53;
      uint64_t v53 = 0;
      sub_1000558F4(&v53);
      if (SHIBYTE(v55) < 0) {
        operator delete(__p[0]);
      }
      (*(void (**)(uint64_t, void **, const __CFString *, const void *, const __CFString *, uint64_t *, uint64_t, void))(*(void *)v33 + 16))(v33, v2 + 4, @"imsi", v40, @"SatMsg", &qword_101B12DF0, 2, 0);
      sub_1000558F4(&v52);
      if (SHIBYTE(v51) < 0)
      {
        operator delete(__dst[0]);
        if (v39) {
          goto LABEL_61;
        }
      }
      else if (v39)
      {
LABEL_61:
        sub_100E6822C(a1);
        goto LABEL_62;
      }
      sub_10004D2C8(v36);
      goto LABEL_61;
    }
  }
}

void sub_100E6D2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  __cxa_guard_abort(&qword_101B12DC8);
  if (v36) {
    sub_10004D2C8(v36);
  }
  _Unwind_Resume(a1);
}

void sub_100E6D378(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 160);
  if (v1)
  {
    uint64_t v4 = (unsigned __int8 *)*v1;
    uint64_t v2 = (unsigned __int8 *)(v1 + 1);
    uint64_t v3 = v4;
    if (v4 != v2)
    {
      uint64_t v6 = (void *)(a1 + 136);
      while (1)
      {
        uint64_t v42 = 0;
        BOOL v43 = 0;
        uint64_t v7 = *(void *)(*(void *)(a1 + 88) + 152);
        uint64_t v8 = *(void **)v7;
        uint64_t v9 = *(void **)(v7 + 8);
        if (*(void **)v7 != v9)
        {
          while (!sub_10001D294((unsigned __int8 *)(*v8 + 24), v3 + 32))
          {
            v8 += 2;
            if (v8 == v9)
            {
              uint64_t v8 = v9;
              break;
            }
          }
          if (v8 != *(void **)(v7 + 8)) {
            break;
          }
        }
        uint64_t v42 = 0;
        BOOL v43 = 0;
LABEL_32:
        if (v43) {
          sub_10004D2C8(v43);
        }
        unsigned int v30 = (unsigned __int8 *)*((void *)v3 + 1);
        if (v30)
        {
          do
          {
            uint64_t v31 = v30;
            unsigned int v30 = *(unsigned __int8 **)v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v31 = (unsigned __int8 *)*((void *)v3 + 2);
            BOOL v32 = *(void *)v31 == (void)v3;
            uint64_t v3 = v31;
          }
          while (!v32);
        }
        uint64_t v3 = v31;
        if (v31 == v2) {
          return;
        }
      }
      uint64_t v10 = *v8;
      uint64_t v11 = (std::__shared_weak_count *)v8[1];
      uint64_t v42 = *v8;
      BOOL v43 = v11;
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v10) {
        goto LABEL_32;
      }
      if (!sub_100E67A44(&v42)) {
        goto LABEL_32;
      }
      uint64_t v12 = *v6;
      if (!*v6) {
        goto LABEL_32;
      }
      int v13 = *(_DWORD *)(v10 + 52);
      unint64_t v14 = v6;
      do
      {
        int v15 = *(_DWORD *)(v12 + 28);
        BOOL v16 = v15 < v13;
        if (v15 >= v13) {
          int v17 = (uint64_t *)v12;
        }
        else {
          int v17 = (uint64_t *)(v12 + 8);
        }
        if (!v16) {
          unint64_t v14 = (void *)v12;
        }
        uint64_t v12 = *v17;
      }
      while (*v17);
      if (v14 == v6 || v13 < *((_DWORD *)v14 + 7)) {
        goto LABEL_32;
      }
      BOOL v18 = (uint64_t *)*((unsigned __int8 *)v14 + 32);
      if (!v18)
      {
        uint64_t v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v36 = *(const char **)(v10 + 24);
          uint64_t v35 = v10 + 24;
          uint64_t v34 = v36;
          uint64_t v37 = *(unsigned __int8 *)(v35 + 23);
          int v38 = (char)v37;
          if ((v37 & 0x80u) != 0) {
            uint64_t v37 = *(void *)(v35 + 8);
          }
          if (v38 >= 0) {
            uint64_t v34 = (const char *)v35;
          }
          if (!v37) {
            uint64_t v34 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I SMSC is not available for %s yet", buf, 0xCu);
        }
        goto LABEL_32;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 48));
      BOOL v20 = ServiceMap;
      if (v21 < 0)
      {
        BOOL v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v23 = 5381;
        do
        {
          uint64_t v21 = v23;
          unsigned int v24 = *v22++;
          uint64_t v23 = (33 * v23) ^ v24;
        }
        while (v24);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v21;
      CFMutableArrayRef v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
      if (v25)
      {
        uint64_t v27 = v25[3];
        uint64_t v26 = (std::__shared_weak_count *)v25[4];
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v20);
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v28 = v26;
          sub_10004D2C8(v26);
          char v29 = 0;
          if (!v27)
          {
LABEL_57:
            if ((v29 & 1) == 0) {
              sub_10004D2C8(v28);
            }
            goto LABEL_32;
          }
LABEL_51:
          char v41 = v29;
          uint64_t v39 = *(unsigned int *)(v10 + 52);
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v46 = 0;
          unsigned int v40 = operator new(0x20uLL);
          void *v40 = off_101A64DD8;
          v40[1] = a1;
          v40[2] = v10;
          v40[3] = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v46 = v40;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v27 + 344))(v27, v39, v45);
          sub_100217EB0(v45);
          char v29 = v41;
          if (v11) {
            sub_10004D2C8(v11);
          }
          goto LABEL_57;
        }
      }
      else
      {
        uint64_t v27 = 0;
      }
      std::mutex::unlock(v20);
      uint64_t v28 = 0;
      char v29 = 1;
      if (!v27) {
        goto LABEL_57;
      }
      goto LABEL_51;
    }
  }
}

void sub_100E6D6F0(_Unwind_Exception *a1, uint64_t a2, int a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, std::__shared_weak_count *a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_100217EB0((uint64_t *)va);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if ((a4 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (a8) {
    sub_10004D2C8(a8);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100E6D750(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 97) || *(unsigned char *)(a1 + 96)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 216);
  if (!v4 || (sub_100E6DC08(a1, v4, (uint64_t)"<settled>") & 1) != 0 || *(unsigned char *)(a1 + 272))
  {
    uint64_t v5 = *(void *)(a1 + 232);
    if (!v5 || (sub_100E6DC08(a1, v5, (uint64_t)"<proposed>") & 1) != 0)
    {
      BOOL v2 = 1;
      goto LABEL_46;
    }
    uint64_t v6 = *(void *)(a1 + 248);
    uint64_t v7 = *(NSObject **)(a1 + 40);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        *(_DWORD *)uint64_t v37 = 136315394;
        *(void *)&void v37[4] = "<proposed>";
        *(_WORD *)&v37[12] = 2080;
        *(void *)&v37[14] = "<upcoming>";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I current config match %s - dropping %s", v37, 0x16u);
        uint64_t v6 = *(void *)(a1 + 248);
      }
      sub_100E670C0(v6, (Registry **)(a1 + 48), v9);
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 256);
      *(void *)(a1 + 248) = 0;
      *(void *)(a1 + 256) = 0;
      if (v11) {
        sub_10004D2C8(v11);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 48));
      int v13 = ServiceMap;
      unint64_t v14 = "8UStorage";
      if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
      {
        int v15 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          unint64_t v14 = (const char *)v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v37 = v14;
      BOOL v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v37);
      if (v18)
      {
        BOOL v20 = (os_unfair_lock_s *)v18[3];
        uint64_t v19 = (std::__shared_weak_count *)v18[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          char v21 = 0;
          goto LABEL_36;
        }
      }
      else
      {
        BOOL v20 = 0;
      }
      std::mutex::unlock(v13);
      uint64_t v19 = 0;
      char v21 = 1;
LABEL_36:
      sub_1000832B0(v20, @"UpcomingConfig", @"SatMsg", 0, 2u);
      if ((v21 & 1) == 0)
      {
        char v29 = v19;
LABEL_44:
        sub_10004D2C8(v29);
      }
LABEL_45:
      BOOL v2 = 0;
      goto LABEL_46;
    }
    if (!v8) {
      goto LABEL_45;
    }
    *(_DWORD *)uint64_t v37 = 136315138;
    *(void *)&void v37[4] = "<proposed>";
    uint64_t v28 = v7;
LABEL_33:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I current config match %s - nothing to do", v37, 0xCu);
    goto LABEL_45;
  }
  uint64_t v22 = *(void *)(a1 + 232);
  if (v22)
  {
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v37 = 136315394;
      *(void *)&void v37[4] = "<settled>";
      *(_WORD *)&v37[12] = 2080;
      *(void *)&v37[14] = "<proposed>";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I current config match %s - dropping %s", v37, 0x16u);
      uint64_t v22 = *(void *)(a1 + 232);
    }
    sub_100E670C0(v22, (Registry **)(a1 + 48), v24);
    uint64_t v26 = *(std::__shared_weak_count **)(a1 + 240);
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    if (v26) {
      sub_10004D2C8(v26);
    }
    sub_100E66CC0(*(Registry **)(a1 + 48), v37, v25);
    sub_1000832B0(*(os_unfair_lock_s **)v37, @"ProposedConfig", @"SatMsg", 0, 2u);
    if (*(void *)&v37[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v37[8]);
    }
    uint64_t v27 = *(void *)(a1 + 248);
    if (!v27) {
      goto LABEL_45;
    }
LABEL_39:
    unsigned int v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v37 = 136315394;
      *(void *)&void v37[4] = "<settled>";
      *(_WORD *)&v37[12] = 2080;
      *(void *)&v37[14] = "<upcoming>";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I current config match %s - dropping %s", v37, 0x16u);
      uint64_t v27 = *(void *)(a1 + 248);
    }
    sub_100E670C0(v27, (Registry **)(a1 + 48), v31);
    uint64_t v33 = *(std::__shared_weak_count **)(a1 + 256);
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
    if (v33) {
      sub_10004D2C8(v33);
    }
    sub_100E66CC0(*(Registry **)(a1 + 48), v37, v32);
    sub_1000832B0(*(os_unfair_lock_s **)v37, @"UpcomingConfig", @"SatMsg", 0, 2u);
    char v29 = *(std::__shared_weak_count **)&v37[8];
    if (!*(void *)&v37[8]) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
  uint64_t v27 = *(void *)(a1 + 248);
  if (v27) {
    goto LABEL_39;
  }
  uint64_t v36 = *(NSObject **)(a1 + 40);
  BOOL v2 = 0;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v37 = 136315138;
    *(void *)&void v37[4] = "<settled>";
    uint64_t v28 = v36;
    goto LABEL_33;
  }
LABEL_46:
  uint64_t v34 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v35 = asStringBool(v2);
    *(_DWORD *)uint64_t v37 = 136315138;
    *(void *)&void v37[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I need to propose new config -> %s", v37, 0xCu);
  }
  return v2;
}

void sub_100E6DBC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E6DC08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 160);
  if (!v3) {
    __assert_rtn("needReprovisioning", "SatMsg_ProvisioningImpl_ios.mm", 1688, "isBootstrapped()");
  }
  uint64_t v4 = a3;
  BOOL v8 = (void *)*v3;
  uint64_t v7 = v3 + 1;
  uint64_t v6 = v8;
  uint64_t v9 = *(unsigned char *)(a2 + 16) != 0;
  if (v8 == v7) {
    goto LABEL_48;
  }
  BOOL v46 = *(unsigned char *)(a2 + 16) != 0;
  int v48 = (void **)(a2 + 56);
  uint64_t v49 = a2 + 48;
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 160);
    if ((void **)(v10 + 32) != sub_100046F68(v10 + 24, (void **)v6 + 4))
    {
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *((unsigned __int8 *)v6 + 55);
        BOOL v13 = (v12 & 0x80u) != 0;
        if ((v12 & 0x80u) != 0) {
          uint64_t v12 = v6[5];
        }
        if (v13) {
          unint64_t v14 = (const char *)v6[4];
        }
        else {
          unint64_t v14 = (const char *)(v6 + 4);
        }
        BOOL v15 = v12 == 0;
        uint64_t v16 = "<invalid>";
        if (!v15) {
          uint64_t v16 = v14;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v16;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I persona %s is unsupported - ignoring", buf, 0xCu);
      }
      goto LABEL_14;
    }
    uint64_t v19 = sub_100046F68(v49, (void **)v6 + 4);
    if (v48 == v19) {
      break;
    }
    BOOL v20 = v19;
    char v21 = (unsigned __int8 *)v19[7];
    uint64_t v22 = v6[7];
    if (!sub_1005A0BB8(v21, (unsigned __int8 *)v22)) {
      goto LABEL_32;
    }
    if (!sub_1005A0BB8(v21 + 32, (unsigned __int8 *)(v22 + 32))) {
      goto LABEL_32;
    }
    uint64_t v23 = (CFStringRef **)*((void *)v21 + 8);
    unsigned int v24 = *(void **)(v22 + 64);
    if ((v23 != 0) != (v24 != 0)) {
      goto LABEL_32;
    }
    uint64_t v26 = *v23;
    CFMutableArrayRef v25 = v23[1];
    if ((char *)v25 - (char *)*v23 != v24[1] - *v24) {
      goto LABEL_32;
    }
LABEL_26:
    if (v26 != v25)
    {
      uint64_t v27 = *(CFStringRef ***)(v22 + 64);
      char v29 = *v27;
      uint64_t v28 = v27[1];
      while (v29 != v28)
      {
        if (CFEqual(*v26, *v29))
        {
          ++v26;
          goto LABEL_26;
        }
        ++v29;
      }
LABEL_32:
      unsigned int v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = *((unsigned __int8 *)v6 + 55);
        BOOL v32 = (v31 & 0x80u) != 0;
        if ((v31 & 0x80u) != 0) {
          uint64_t v31 = v6[5];
        }
        if (v32) {
          uint64_t v33 = (const char *)v6[4];
        }
        else {
          uint64_t v33 = (const char *)(v6 + 4);
        }
        BOOL v15 = v31 == 0;
        uint64_t v34 = "<invalid>";
        if (!v15) {
          uint64_t v34 = v33;
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v4 = a3;
        *(void *)&uint8_t buf[4] = a3;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v34;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s simConfig for persona %s differs", buf, 0x16u);
        unsigned int v30 = *(NSObject **)(a1 + 40);
      }
      else
      {
        uint64_t v4 = a3;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I old one", buf, 2u);
      }
      uint64_t v35 = (uint64_t)v20[7];
      uint64_t v51 = 0;
      sub_100E646AC(&v52, v35, &v51);
      *(void *)long long buf = off_101A648D8;
      *(void *)&uint8_t buf[8] = a1;
      uint64_t v54 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      sub_10005717C(&v52);
      sub_10005717C(&v51);
      uint64_t v36 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I new one", buf, 2u);
      }
      uint64_t v37 = v6[7];
      char v50 = 0;
      sub_100E646AC(&v52, v37, &v50);
      *(void *)long long buf = off_101A64958;
      *(void *)&uint8_t buf[8] = a1;
      uint64_t v54 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      sub_10005717C(&v52);
      sub_10005717C(&v50);
LABEL_47:
      uint64_t v9 = 1;
      goto LABEL_48;
    }
LABEL_14:
    unsigned int v17 = (void *)v6[1];
    if (v17)
    {
      do
      {
        BOOL v18 = v17;
        unsigned int v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        BOOL v18 = (void *)v6[2];
        BOOL v15 = *v18 == (void)v6;
        uint64_t v6 = v18;
      }
      while (!v15);
    }
    uint64_t v6 = v18;
    if (v18 == v7)
    {
      uint64_t v4 = a3;
      uint64_t v9 = v46;
      goto LABEL_48;
    }
  }
  char v41 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v42 = *((unsigned __int8 *)v6 + 55);
    BOOL v43 = (v42 & 0x80u) != 0;
    if ((v42 & 0x80u) != 0) {
      uint64_t v42 = v6[5];
    }
    if (v43) {
      uint64_t v44 = (const char *)v6[4];
    }
    else {
      uint64_t v44 = (const char *)(v6 + 4);
    }
    BOOL v15 = v42 == 0;
    uint64_t v45 = "<invalid>";
    if (!v15) {
      uint64_t v45 = v44;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v45;
    *(_WORD *)&unsigned char buf[12] = 2080;
    uint64_t v4 = a3;
    *(void *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I persona %s is missing in %s", buf, 0x16u);
    goto LABEL_47;
  }
  uint64_t v9 = 1;
  uint64_t v4 = a3;
LABEL_48:
  int v38 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = "no ";
    if (v9) {
      uint64_t v39 = "";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v39;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I checked %s, %sreprovisioning needed", buf, 0x16u);
  }
  return v9;
}

void sub_100E6E128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, const void *);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, const void *);
  sub_10012C330((uint64_t *)va2);
  sub_10005717C((const void **)va1);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100E6E180(void *a1, uint64_t a2, int a3)
{
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v7 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    *(void *)&long long valuePtr = v7;
    sub_10005717C((const void **)&valuePtr);
  }
  sub_100E6EBA8((const void **)&valuePtr, *(const __CFUUID **)a2);
  CFDictionarySetValue(theDict, @"ver", (const void *)valuePtr);
  sub_1000558F4((const void **)&valuePtr);
  uint64_t v8 = *(void *)(a2 + 8);
  __p[0] = 0;
  *(void *)&long long valuePtr = v8;
  CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  if (v9)
  {
    uint64_t v10 = __p[0];
    __p[0] = v9;
    *(void *)&long long valuePtr = v10;
    sub_1000570E8((const void **)&valuePtr);
  }
  v52[0] = __p[0];
  __p[0] = 0;
  sub_1000570E8((const void **)__p);
  CFDictionarySetValue(theDict, @"ts", v52[0]);
  sub_1000570E8(v52);
  if (*(unsigned char *)(a2 + 16)) {
    CFDictionarySetValue(theDict, @"dirty", kCFBooleanTrue);
  }
  uint64_t v44 = 0;
  CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v34 = a1;
  if (v11)
  {
    uint64_t v12 = v44;
    uint64_t v44 = v11;
    *(void *)&long long valuePtr = v12;
    sub_1000440D4((const void **)&valuePtr);
  }
  BOOL v13 = *(void **)(a2 + 24);
  uint64_t v35 = a2;
  unint64_t v14 = (void *)(a2 + 32);
  if (v13 != (void *)(a2 + 32))
  {
    uint64_t v15 = a2 + 48;
    do
    {
      CFMutableDictionaryRef v43 = 0;
      uint64_t v16 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v16)
      {
        CFMutableDictionaryRef v17 = v43;
        CFMutableDictionaryRef v43 = v16;
        *(void *)&long long valuePtr = v17;
        sub_10005717C((const void **)&valuePtr);
      }
      BOOL v18 = v43;
      if (*((char *)v13 + 63) < 0)
      {
        sub_10004FC84(__dst, (void *)v13[5], v13[6]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)(v13 + 5);
        uint64_t v41 = v13[7];
      }
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v48 = v41;
      }
      BOOL v46 = 0;
      if (SHIBYTE(v48) < 0)
      {
        sub_10004FC84(&valuePtr, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long valuePtr = *(_OWORD *)__p;
        uint64_t v50 = v48;
      }
      uint64_t v51 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v19 = v46;
        BOOL v46 = v51;
        v52[0] = v19;
        sub_1000558F4(v52);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)valuePtr);
      }
      unsigned int value = v46;
      BOOL v46 = 0;
      sub_1000558F4((const void **)&v46);
      if (SHIBYTE(v48) < 0) {
        operator delete(__p[0]);
      }
      CFDictionarySetValue(v18, @"iccid", value);
      sub_1000558F4((const void **)&value);
      if (SHIBYTE(v41) < 0) {
        operator delete(__dst[0]);
      }
      if (*((_DWORD *)v13 + 8)) {
        CFStringRef v20 = @"B";
      }
      else {
        CFStringRef v20 = @"A";
      }
      CFDictionarySetValue(v43, @"name", v20);
      char v21 = sub_100046F68(v15, (void **)v13 + 5);
      if ((void **)(v35 + 56) != v21)
      {
        *(void *)&long long valuePtr = 0;
        uint64_t v22 = (uint64_t)v21[7];
        uint64_t v39 = 0;
        sub_100E646AC((const void **)&valuePtr, v22, &v39);
        sub_10005717C(&v39);
        CFDictionarySetValue(v43, @"sim-cfg", (const void *)valuePtr);
        sub_10005717C((const void **)&valuePtr);
      }
      if (a3)
      {
        uint64_t v23 = sub_100046F68(v35 + 72, (void **)v13 + 5);
        unsigned int v24 = (std::mutex *)v23[7];
        CFMutableArrayRef v25 = (std::__shared_weak_count *)v23[8];
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v26 = v43;
        sub_100E66E48(&valuePtr, v24);
        CFDictionarySetValue(v26, @"keys", (const void *)valuePtr);
        sub_100057D78((const void **)&valuePtr);
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
      CFArrayAppendValue(v44, v43);
      sub_10005717C((const void **)&v43);
      uint64_t v27 = (void *)v13[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          uint64_t v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v13[2];
          BOOL v29 = *v28 == (void)v13;
          BOOL v13 = v28;
        }
        while (!v29);
      }
      BOOL v13 = v28;
    }
    while (v28 != v14);
  }
  CFDictionarySetValue(theDict, @"sims", v44);
  if (a3)
  {
    unsigned int v30 = theDict;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v36 = 0;
    sub_10005C928(&v36, *(const void **)(v35 + 96), *(void *)(v35 + 104), *(void *)(v35 + 104) - *(void *)(v35 + 96));
    __p[1] = 0;
    uint64_t v48 = 0;
    __p[0] = 0;
    sub_10005C928(__p, v36, (uint64_t)v37, v37 - (unsigned char *)v36);
    BOOL v46 = 0;
    long long valuePtr = 0uLL;
    uint64_t v50 = 0;
    sub_10005C928(&valuePtr, __p[0], (uint64_t)__p[1], (char *)__p[1] - (char *)__p[0]);
    uint64_t v51 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v31 = v46;
      BOOL v46 = v51;
      v52[0] = v31;
      sub_100030068(v52);
    }
    if ((void)valuePtr)
    {
      *((void *)&valuePtr + 1) = valuePtr;
      operator delete((void *)valuePtr);
    }
    BOOL v32 = v46;
    CFMutableDictionaryRef v43 = (CFMutableDictionaryRef)v46;
    BOOL v46 = 0;
    sub_100030068((const void **)&v46);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    CFDictionarySetValue(v30, @"offgridKey", v32);
    sub_100030068((const void **)&v43);
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
  }
  sub_10004EFE4(v34, (CFTypeRef *)&theDict);
  sub_1000440D4((const void **)&v44);
  return sub_10005717C((const void **)&theDict);
}

void sub_100E6E6A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,const void *a23,const void *a24,const void *a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1000440D4(&a24);
  sub_10005717C(&a25);
  _Unwind_Resume(a1);
}

void sub_100E6E814(uint64_t a1, const char **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (const char *)*((unsigned __int8 *)a2 + 23);
    BOOL v6 = (char)v5 < 0;
    if ((char)v5 < 0) {
      uint64_t v5 = a2[1];
    }
    if (v6) {
      CFMutableDictionaryRef v7 = *a2;
    }
    else {
      CFMutableDictionaryRef v7 = (const char *)a2;
    }
    if (v5) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I triggerIWFCertDownloadIfNeeded %s", buf, 0xCu);
  }
  CFNumberRef v9 = sub_100046F68(a1 + 176, (void **)a2);
  if ((void **)(a1 + 184) != v9)
  {
    CFMutableArrayRef v11 = (char *)v9[7];
    uint64_t v10 = (std::__shared_weak_count *)v9[8];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v11) {
      goto LABEL_23;
    }
    if (*((void *)v11 + 11))
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v11);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      unint64_t v14 = "#I %s%sIWF pub key fetch in progress - bailing out";
      goto LABEL_21;
    }
    if (*((void *)v11 + 14))
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      uint64_t v15 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v11);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      unint64_t v14 = "#I %s%sIWF pub key fetch is already scheduled - bailing out";
      goto LABEL_21;
    }
    if (*((_DWORD *)v11 + 26) < 0xAu)
    {
      if (*(unsigned char *)(a1 + 152))
      {
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 3221225472;
        v24[2] = sub_100E70EB8;
        v24[3] = &unk_101A640F0;
        v24[4] = a1;
        CFStringRef v20 = _Block_copy(v24);
        CFMutableArrayRef v25 = v20;
        sub_100E6F318(buf, (void *)a1, (PersonalityInfo **)v11, &v25);
        long long v21 = *(_OWORD *)buf;
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        uint64_t v22 = (std::__shared_weak_count *)*((void *)v11 + 12);
        *(_OWORD *)(v11 + 88) = v21;
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v20) {
          _Block_release(v20);
        }
        goto LABEL_23;
      }
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v11);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        unint64_t v14 = "#W %s%sno connectivity to issue the request - bailing out";
LABEL_21:
        uint64_t v16 = v12;
        uint32_t v17 = 22;
LABEL_22:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v14, buf, v17);
      }
    }
    else
    {
      BOOL v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v11);
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v27 = 1024;
        int v28 = 10;
        unint64_t v14 = "#W %s%smax number of failures reached (%u) - bailing out";
        uint64_t v16 = v18;
        uint32_t v17 = 28;
        goto LABEL_22;
      }
    }
LABEL_23:
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_100E6EB58(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100E6EBA8(const void **result, const __CFUUID *a2)
{
  *uint64_t result = 0;
  if (a2)
  {
    *uint64_t result = CFUUIDCreateString(kCFAllocatorDefault, a2);
    BOOL v2 = 0;
    return sub_1000558F4(&v2);
  }
  return result;
}

void sub_100E6EBF8(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

void sub_100E6EC0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100E6ED00(void *a1, uint64_t a2, PersonalityInfo **a3, const __CFData *a4)
{
  CFTypeRef v45 = 0;
  CFTypeRef cf = 0;
  uint64_t v43 = 0;
  CFMutableArrayRef theArray = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v43);
  if (a4) {
    CFIndex Length = CFDataGetLength(a4);
  }
  else {
    CFIndex Length = 0;
  }
  CFNumberRef v9 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(*a3);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2048;
    uint64_t v48 = (unsigned char *)Length;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sReceived %zu bytes of data", buf, 0x20u);
    CFNumberRef v9 = *(NSObject **)(a2 + 40);
  }
  BOOL v11 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (!Length)
  {
    if (!v11) {
      goto LABEL_38;
    }
    uint64_t v29 = PersonalityInfo::logPrefix(*a3);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v29;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    unsigned int v30 = "#W %s%sEmpty JSON!";
    uint64_t v31 = v9;
LABEL_33:
    uint32_t v34 = 22;
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v34);
    goto LABEL_38;
  }
  if (v11)
  {
    uint64_t v12 = PersonalityInfo::logPrefix(*a3);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sRAW JSON Response:", buf, 0x16u);
  }
  *(void *)long long buf = off_101A649D8;
  *(void *)&uint8_t buf[8] = a2;
  *(void *)&uint8_t buf[16] = a3;
  uint64_t v48 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  uint64_t v42 = 0;
  CFDictionaryRef v13 = +[NSJSONSerialization JSONObjectWithData:a4 options:0 error:&v42];
  if (!v13)
  {
    BOOL v32 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_38;
    }
    uint64_t v33 = PersonalityInfo::logPrefix(*a3);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v33;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2112;
    uint64_t v48 = v42;
    unsigned int v30 = "#W %s%sInvalid JSON response, error: %@";
    uint64_t v31 = v32;
    uint32_t v34 = 32;
    goto LABEL_34;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    uint64_t v35 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_38;
    }
    uint64_t v36 = PersonalityInfo::logPrefix(*a3);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v36;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    unsigned int v30 = "#W %s%sUnexpected JSON format, should be Dictionary";
    uint64_t v31 = v35;
    goto LABEL_33;
  }
  CFDictionaryRef theDict = v13;
  CFRetain(v13);
  CFDictionaryRef Value = CFDictionaryGetValue(v13, @"key-identifier");
  uint64_t v15 = Value;
  if (Value)
  {
    CFTypeID v16 = CFGetTypeID(Value);
    if (v16 == CFStringGetTypeID())
    {
      *(void *)long long buf = v15;
      sub_100013168(&cf, (CFTypeRef *)buf);
    }
  }
  uint32_t v17 = CFDictionaryGetValue(theDict, @"certificate");
  BOOL v18 = v17;
  if (v17)
  {
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 == CFStringGetTypeID())
    {
      *(void *)long long buf = v18;
      sub_100013168(&v45, (CFTypeRef *)buf);
    }
  }
  CFArrayRef v20 = (const __CFArray *)CFDictionaryGetValue(theDict, @"caChain");
  CFArrayRef v21 = v20;
  if (v20)
  {
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 == CFArrayGetTypeID())
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        CFMutableArrayRef v24 = theArray;
        CFMutableArrayRef theArray = Mutable;
        *(void *)long long buf = v24;
        sub_1000440D4((const void **)buf);
      }
      for (unint64_t i = 0; i < CFArrayGetCount(v21); ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v21, i);
        __int16 v27 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v28 = CFGetTypeID(ValueAtIndex);
          if (v28 == CFStringGetTypeID()) {
            CFArrayAppendValue(theArray, v27);
          }
        }
      }
      if (!CFArrayGetCount(theArray))
      {
        CFMutableArrayRef v37 = theArray;
        CFMutableArrayRef theArray = 0;
        *(void *)long long buf = v37;
        sub_1000440D4((const void **)buf);
      }
    }
  }
  sub_100057D78((const void **)&theDict);
LABEL_38:
  CFTypeRef v38 = cf;
  *(void *)long long buf = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v39 = v45;
  *(void *)&uint8_t buf[8] = v45;
  if (v45) {
    CFRetain(v45);
  }
  *(void *)&uint8_t buf[16] = theArray;
  if (theArray) {
    CFRetain(theArray);
  }
  *a1 = v38;
  a1[1] = v39;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_100044D6C(a1 + 2, (CFTypeRef *)&buf[16]);
  sub_1000440D4((const void **)&buf[16]);
  sub_1000558F4((const void **)&buf[8]);
  sub_1000558F4((const void **)buf);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v43);
  sub_1000440D4((const void **)&theArray);
  sub_1000558F4(&v45);
  return sub_1000558F4(&cf);
}

void sub_100E6F214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, char a11, const void *a12, const void *a13, const void *a14)
{
}

const void **sub_100E6F2D4(const void **a1)
{
  sub_1000440D4(a1 + 2);
  sub_1000558F4(a1 + 1);

  return sub_1000558F4(a1);
}

void sub_100E6F318(void *a1, void *a2, PersonalityInfo **a3, void **a4)
{
  CFMutableDictionaryRef v7 = (PersonalityInfo *)*((unsigned __int8 *)a3 + 63);
  if ((char)v7 < 0) {
    CFMutableDictionaryRef v7 = a3[6];
  }
  if (v7)
  {
    uint64_t v8 = (uint64_t *)*((unsigned __int8 *)a3 + 87);
    if ((char)v8 < 0) {
      uint64_t v8 = (uint64_t *)a3[9];
    }
    if (v8)
    {
      uint64_t v10 = (Registry *)a2[6];
      BOOL v64 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v10);
      uint64_t v12 = ServiceMap;
      if ((v13 & 0x8000000000000000) != 0)
      {
        unint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          std::string::size_type v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v13;
      uint32_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&buf);
      uint64_t v52 = a4;
      if (v17)
      {
        uint64_t v19 = v17[3];
        BOOL v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
LABEL_18:
          uint64_t v23 = *((unsigned int *)*a3 + 13);
          CFMutableArrayRef v24 = operator new(0x10uLL);
          buf.__r_.__value_.__l.__size_ = (std::string::size_type)(v24 + 2);
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v24 + 2);
          void *v24 = @"SatMsg";
          v24[1] = @"IwfCertURL";
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
          (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, std::string *, const __CFString *, void))(*(void *)v19 + 104))(v79, v19, v23, 4, &buf, @"https://pbs2i.cdn-apple.com/keys/$mcc/$mnc/key", 0);
          sub_100056248(&v61, v79);
          __p.__r_.__value_.__r.__words[0] = 0;
          BOOL v64 = v61;
          uint64_t v61 = 0;
          sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)&v61);
          sub_1000577C4(v79);
          if (buf.__r_.__value_.__r.__words[0])
          {
            buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          memset(&__p, 0, sizeof(__p));
          memset(&buf, 0, sizeof(buf));
          ctu::cf::assign();
          std::string __p = buf;
          if (*((char *)a3 + 63) >= 0) {
            CFMutableArrayRef v25 = (const char *)(a3 + 5);
          }
          else {
            CFMutableArrayRef v25 = (const char *)a3[5];
          }
          sub_100E6FE14(&buf, (uint64_t)&__p, "$mcc", v25);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = buf;
          if (*((char *)a3 + 87) >= 0) {
            uint64_t v26 = (const char *)(a3 + 8);
          }
          else {
            uint64_t v26 = (const char *)a3[8];
          }
          sub_100E6FE14(&buf, (uint64_t)&__p, "$mnc", v26);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = buf;
          __int16 v27 = a2[5];
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v28 = PersonalityInfo::logPrefix(*a3);
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v28;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________>  Query IWF certificate", (uint8_t *)&buf, 0x16u);
          }
          *a1 = 0;
          a1[1] = 0;
          strcpy(v66, "Accept");
          strcpy(v81, "Accept-Encoding");
          strcpy(v80, "Content-Type");
          strcpy((char *)v79, "Content-Encoding");
          strcpy(__s, "User-Agent");
          strcpy(v65, "gzip");
          strcpy(v77, "application/json");
          strcpy(v76, "Apple device");
          uint64_t v61 = 0;
          v62[0] = 0;
          v62[1] = 0;
          sub_100E79688(&buf, v66, v77);
          sub_100E796DC(v71, v81, v65);
          sub_100637AF8(v72, v80, v77);
          sub_100E79730(v73, (char *)v79, v65);
          sub_100058DB0(v74, __s);
          sub_100058DB0(v75, v76);
          sub_1002369E0((uint64_t)&v61, (long long *)&buf, 5);
          for (uint64_t i = 0; i != -30; i -= 6)
          {
            unsigned int v30 = (void **)((char *)&buf.__r_.__value_.__l.__data_ + i * 8);
            if (SHIBYTE(v75[i + 2]) < 0) {
              operator delete(v30[27]);
            }
            if (*((char *)v30 + 215) < 0) {
              operator delete(v30[24]);
            }
          }
          uint64_t v31 = a2[5];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v32 = PersonalityInfo::logPrefix(*a3);
            p_p = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v32;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            CFDictionaryRef v68 = p_p;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%sRequesting: %s", (uint8_t *)&buf, 0x20u);
          }
          uint32_t v34 = v61;
          if (v61 != v62)
          {
            do
            {
              uint64_t v35 = a2[5];
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                std::string::size_type v36 = PersonalityInfo::logPrefix(*a3);
                CFMutableArrayRef v37 = (std::string *)(v34 + 4);
                if (*((char *)v34 + 55) < 0) {
                  CFMutableArrayRef v37 = (std::string *)v37->__r_.__value_.__r.__words[0];
                }
                CFTypeRef v38 = v34 + 7;
                if (*((char *)v34 + 79) < 0) {
                  CFTypeRef v38 = (void *)*v38;
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v36;
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                CFDictionaryRef v68 = v37;
                __int16 v69 = 2080;
                uint64_t v70 = v38;
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s%s  %s: %s", (uint8_t *)&buf, 0x2Au);
              }
              CFTypeRef v39 = (void *)v34[1];
              if (v39)
              {
                do
                {
                  unsigned int v40 = (void **)v39;
                  CFTypeRef v39 = (void *)*v39;
                }
                while (v39);
              }
              else
              {
                do
                {
                  unsigned int v40 = (void **)v34[2];
                  BOOL v41 = *v40 == v34;
                  uint32_t v34 = v40;
                }
                while (!v41);
              }
              uint32_t v34 = v40;
            }
            while (v40 != v62);
          }
          uint64_t v59 = 0;
          __int16 v60 = 0;
          ctu::Http::HttpRequest::create();
          long long v42 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
          *(_OWORD *)a1 = v42;
          if (v60) {
            sub_10004D2C8(v60);
          }
          if ((void)v42)
          {
            (*(void (**)(void, void))(*(void *)v42 + 8))(v42, a2[3]);
            memset(&buf, 0, sizeof(buf));
            uint64_t v43 = *a3;
            if (*((char *)*a3 + 47) < 0) {
              sub_10004FC84(&buf, *((void **)v43 + 3), *((void *)v43 + 4));
            }
            else {
              std::string buf = *(std::string *)((unsigned char *)v43 + 1);
            }
            BOOL v46 = (std::__shared_weak_count *)a2[2];
            if (!v46 || (v47 = a2[1], (uint64_t v48 = std::__shared_weak_count::lock(v46)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v49 = v48;
            p_uint64_t shared_weak_owners = &v48->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v48->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v48);
            v55[0] = _NSConcreteStackBlock;
            v55[1] = 3321888768;
            v55[2] = sub_100E6FFD8;
            v55[3] = &unk_101A640C0;
            v55[4] = a2;
            v55[5] = v47;
            char v56 = v49;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v57, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
            }
            else {
              std::string v57 = buf;
            }
            uint64_t v51 = *v52;
            if (*v52) {
              uint64_t v51 = _Block_copy(v51);
            }
            aBlock = v51;
            (*(void (**)(void, void *))(*(void *)v42 + 16))(v42, v55);
            v53[0] = 0;
            v53[1] = 0;
            uint64_t v54 = 0;
            (*(void (**)(void, void **))(*(void *)v42 + 40))(v42, v53);
            if (SHIBYTE(v54) < 0) {
              operator delete(v53[0]);
            }
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v57.__r_.__value_.__l.__data_);
            }
            if (v56) {
              std::__shared_weak_count::__release_weak(v56);
            }
            std::__shared_weak_count::__release_weak(v49);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
          else
          {
            uint64_t v44 = a2[5];
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v45 = PersonalityInfo::logPrefix(*a3);
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v45;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#W %s%sUnable to allocate request", (uint8_t *)&buf, 0x16u);
            }
          }
          sub_10010C0E0((uint64_t)&v61, v62[0]);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          sub_1000558F4(&v64);
          return;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      BOOL v18 = 0;
      char v20 = 1;
      goto LABEL_18;
    }
  }
  CFArrayRef v21 = a2[5];
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v22 = PersonalityInfo::logPrefix(*a3);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v22;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%sNo MCC/MNC - cannot build URL for queryIWFCertificate yet", (uint8_t *)&buf, 0x16u);
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_100E6FC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,uint64_t a25,uint64_t a26,void *aBlock,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,const void *a40)
{
  sub_10010C0E0((uint64_t)&a30, (void *)a31);
  if (v40) {
    sub_10004D2C8(v40);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_1000558F4(&a40);
  _Unwind_Resume(a1);
}

uint64_t sub_100E6FE14(std::string *a1, uint64_t a2, char *__s, const char *a4)
{
  uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v8 = *(void **)a2;
  if ((v7 & 0x80u) == 0) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = *(void *)a2;
  }
  uint64_t result = strlen(__s);
  int64_t v11 = result;
  if (result)
  {
    unint64_t v19 = *(void *)(a2 + 8);
    if ((v7 & 0x80u) == 0) {
      uint64_t v12 = v7;
    }
    else {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    if (v12 >= result)
    {
      uint64_t v13 = v9 + v12;
      int v14 = *__s;
      uint64_t result = v9;
      do
      {
        uint64_t v15 = v12 - v11;
        if (v15 == -1) {
          break;
        }
        uint64_t result = (uint64_t)memchr((void *)result, v14, v15 + 1);
        if (!result) {
          break;
        }
        uint64_t v16 = result;
        uint64_t result = memcmp((const void *)result, __s, v11);
        if (!result)
        {
          if (v16 == v13) {
            break;
          }
          int64_t v11 = v16 - v9;
          if (v16 - v9 == -1) {
            break;
          }
          goto LABEL_22;
        }
        uint64_t result = v16 + 1;
        uint64_t v12 = v13 - (v16 + 1);
      }
      while (v12 >= v11);
    }
    if ((v7 & 0x80) != 0)
    {
      return (uint64_t)sub_10004FC84(a1, v8, v19);
    }
    else
    {
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      a1->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
    }
  }
  else
  {
LABEL_22:
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if ((v7 & 0x80) != 0)
    {
      sub_10004FC84(a1, v8, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      a1->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
    }
    size_t v17 = strlen(__s);
    size_t v18 = strlen(a4);
    return (uint64_t)std::string::replace(a1, v11, v17, a4, v18);
  }
  return result;
}

void sub_100E6FFBC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E6FFD8(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_78;
      }
      uint64_t v8 = sub_100046F68(v5 + 176, (void **)(a1 + 56));
      if ((void **)(v5 + 184) == v8) {
        goto LABEL_78;
      }
      uint64_t v9 = v8[7];
      uint64_t v10 = (std::__shared_weak_count *)v8[8];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v9)
      {
        int64_t v11 = (std::__shared_weak_count *)*((void *)v9 + 12);
        *((void *)v9 + 11) = 0;
        *((void *)v9 + 12) = 0;
        if (v11) {
          sub_10004D2C8(v11);
        }
        uint64_t v12 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________<  Received response, or timed out", buf, 0x16u);
        }
        if (!*a2) {
          goto LABEL_43;
        }
        unint64_t v14 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
        uint64_t v15 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v50 = v10;
          uint64_t v49 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
          (*(void (**)(const void **__return_ptr))(*(void *)*a2 + 64))(v67);
          if (SHIBYTE(v68) >= 0) {
            uint64_t v16 = v67;
          }
          else {
            uint64_t v16 = (const void **)v67[0];
          }
          uint64_t v48 = v16;
          int v47 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
          (*(void (**)(void))(*(void *)*a2 + 16))();
          ctu::Http::asString();
          if (v66 >= 0) {
            size_t v18 = v65;
          }
          else {
            size_t v18 = (void **)v65[0];
          }
          BOOL v46 = v18;
          ctu::Http::asString((uint64_t *)v63, (ctu::Http *)v14, v17);
          if (v64 >= 0) {
            unint64_t v19 = v63;
          }
          else {
            unint64_t v19 = (void **)v63[0];
          }
          std::string::size_type v45 = v19;
          (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(v61);
          if (v62 >= 0) {
            char v20 = v61;
          }
          else {
            char v20 = (void **)v61[0];
          }
          uint64_t v44 = v20;
          uint64_t v21 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
          (*(void (**)(void))(*(void *)*a2 + 16))();
          (*(void (**)(void))(*(void *)*a2 + 32))();
          ctu::Http::asString();
          if (v60 >= 0) {
            std::string::size_type v22 = __p;
          }
          else {
            std::string::size_type v22 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136317442;
          *(void *)&uint8_t buf[4] = v49;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          __int16 v70 = 2080;
          *(void *)os_log_t v71 = v48;
          *(_WORD *)&v71[8] = 1024;
          int v72 = v47;
          __int16 v73 = 2080;
          uint64_t v74 = v46;
          __int16 v75 = 1024;
          unint64_t v14 = v14;
          int v76 = v14;
          __int16 v77 = 2080;
          CFIndex v78 = v45;
          __int16 v79 = 2080;
          xpc_object_t v80 = v44;
          __int16 v81 = 2048;
          uint64_t v82 = v21;
          __int16 v83 = 2080;
          unsigned __int8 v84 = v22;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sResponse: '%s', Result: %d (%s), Status: '%d' (%s), Response: '%s' ErrorCode: '%ld' (%s)", buf, 0x5Eu);
          if (v60 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v10 = v50;
          if (v62 < 0) {
            operator delete(v61[0]);
          }
          if (v64 < 0) {
            operator delete(v63[0]);
          }
          if (v66 < 0) {
            operator delete(v65[0]);
          }
          if (SHIBYTE(v68) < 0) {
            operator delete((void *)v67[0]);
          }
        }
        if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() != 1) {
          goto LABEL_43;
        }
        if ((v14 - 500) <= 4 && v14 != 501)
        {
          *((unsigned char *)v9 + 108) = 1;
LABEL_43:
          unsigned int v23 = *((_DWORD *)v9 + 26) + 1;
          *((_DWORD *)v9 + 26) = v23;
          CFMutableArrayRef v24 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v25 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
            int v26 = *((_DWORD *)v9 + 26);
            *(_DWORD *)std::string buf = 136315906;
            *(void *)&uint8_t buf[4] = v25;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int16 v70 = 1024;
            *(_DWORD *)os_log_t v71 = v26;
            *(_WORD *)&v71[4] = 1024;
            *(_DWORD *)&uint64_t v71[6] = 10;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sgot %u failure(s) from %u max allowed", buf, 0x22u);
            unsigned int v23 = *((_DWORD *)v9 + 26);
          }
          if (v23 < 0xA)
          {
            if (*((unsigned char *)v9 + 108)) {
              int v29 = 10;
            }
            else {
              int v29 = 1;
            }
            unsigned int v30 = 60 * v23 * v29;
            uint64_t v31 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v32 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
              *(_DWORD *)std::string buf = 136315650;
              *(void *)&uint8_t buf[4] = v32;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              __int16 v70 = 1024;
              *(_DWORD *)os_log_t v71 = v30;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%sschedule update in %u seconds", buf, 0x1Cu);
            }
            Registry::getTimerService((uint64_t *)buf, *(Registry **)(v5 + 48));
            uint64_t v33 = *(void *)buf;
            sub_100058DB0(v57, "SatMsg_ProvisioningImpl::backoff");
            uint32_t v34 = *(NSObject **)(v5 + 24);
            dispatch_object_t object = v34;
            if (v34) {
              dispatch_retain(v34);
            }
            v51[0] = _NSConcreteStackBlock;
            v51[1] = 3321888768;
            v51[2] = sub_100E70B5C;
            v51[3] = &unk_101A64090;
            uint64_t v36 = *(void *)(a1 + 40);
            uint64_t v35 = *(std::__shared_weak_count **)(a1 + 48);
            v51[4] = v5;
            v51[5] = v36;
            uint64_t v52 = v35;
            if (v35) {
              atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            if (*(char *)(a1 + 79) < 0)
            {
              sub_10004FC84(&v53, *(void **)(a1 + 56), *(void *)(a1 + 64));
            }
            else
            {
              long long v53 = *(_OWORD *)(a1 + 56);
              uint64_t v54 = *(void *)(a1 + 72);
            }
            uint64_t v55 = _Block_copy(v51);
            sub_100118A44(v33, (uint64_t)v57, 1, 1000000 * v30, &object, &v55);
            CFMutableArrayRef v37 = v67[0];
            v67[0] = 0;
            uint64_t v38 = *((void *)v9 + 14);
            *((void *)v9 + 14) = v37;
            if (v38)
            {
              (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
              CFTypeRef v39 = v67[0];
              v67[0] = 0;
              if (v39) {
                (*(void (**)(const void *))(*(void *)v39 + 8))(v39);
              }
            }
            if (v55) {
              _Block_release(v55);
            }
            if (object) {
              dispatch_release(object);
            }
            if (v58 < 0) {
              operator delete(v57[0]);
            }
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            if (SHIBYTE(v54) < 0) {
              operator delete((void *)v53);
            }
            if (v52) {
              std::__shared_weak_count::__release_weak(v52);
            }
            goto LABEL_76;
          }
          __int16 v27 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = v28;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int16 v70 = 1024;
            *(_DWORD *)os_log_t v71 = 10;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%smax number of failures reached (%u)", buf, 0x1Cu);
          }
          goto LABEL_48;
        }
        if (v14 != 200)
        {
          unsigned int v40 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v41 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
            ctu::Http::asString((uint64_t *)v67, (ctu::Http *)v14, v42);
            uint64_t v43 = SHIBYTE(v68) >= 0 ? v67 : (const void **)v67[0];
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = v41;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            __int16 v70 = 2080;
            *(void *)os_log_t v71 = v43;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#W %s%sCDN replied with '%s', blocking service for the SIM at this point...", buf, 0x20u);
            if (SHIBYTE(v68) < 0) {
              operator delete((void *)v67[0]);
            }
          }
LABEL_48:
          (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
          goto LABEL_76;
        }
        *((_DWORD *)v9 + 26) = 0;
        *((unsigned char *)v9 + 108) = 0;
        v65[0] = 0;
        v63[0] = 0;
        v61[0] = 0;
        (*(void (**)(void **__return_ptr))(*(void *)*a2 + 40))(__p);
        sub_100E6ED00(buf, v5, (PersonalityInfo **)v9, (const __CFData *)__p[0]);
        v67[0] = v65;
        v67[1] = v63;
        CFDictionaryRef v68 = v61;
        sub_100E79784(v67, (const void **)buf);
        sub_100E70B18((const void **)buf);
        sub_100030068((const void **)__p);
        (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
        sub_100044D00((const void **)v61);
        sub_1000558F4((const void **)v63);
        sub_1000558F4((const void **)v65);
      }
LABEL_76:
      if (v10) {
        sub_10004D2C8(v10);
      }
LABEL_78:
      sub_10004D2C8(v7);
    }
  }
}

void sub_100E70994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *aBlock,dispatch_object_t object,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (v59) {
    sub_10004D2C8(v59);
  }
  sub_10004D2C8(v58);
  _Unwind_Resume(a1);
}

const void **sub_100E70B18(const void **a1)
{
  sub_100044D00(a1 + 2);
  sub_1000558F4(a1 + 1);

  return sub_1000558F4(a1);
}

void sub_100E70B5C(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = a1 + 56;
        uint64_t v7 = sub_100046F68(v3 + 176, (void **)(a1 + 56));
        if ((void **)(v3 + 184) != v7)
        {
          uint64_t v9 = (PersonalityInfo **)v7[7];
          uint64_t v8 = (std::__shared_weak_count *)v7[8];
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v9)
          {
            uint64_t v10 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v11 = PersonalityInfo::logPrefix(*v9);
              int v13 = 136315394;
              uint64_t v14 = v11;
              __int16 v15 = 2080;
              uint64_t v16 = " ";
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sbackoff timer expired - issuing request if needed", (uint8_t *)&v13, 0x16u);
            }
            uint64_t v12 = v9[14];
            v9[14] = 0;
            if (v12) {
              (*(void (**)(PersonalityInfo *))(*(void *)v12 + 8))(v12);
            }
            sub_100E6E814(v3, v6);
          }
          if (v8) {
            sub_10004D2C8(v8);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E70CC8(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100E70CEC(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_100E70D54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E70D6C(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void *sub_100E70DC0(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  long long v5 = a1 + 7;
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    a1[9] = *(void *)(a2 + 72);
    *(_OWORD *)long long v5 = v6;
  }
  uint64_t result = *(void **)(a2 + 80);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[10] = result;
  return result;
}

void sub_100E70E38(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E70E54(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 80);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100E70EB8(uint64_t a1, PersonalityInfo **a2, void *a3, uint64_t a4, uint64_t a5)
{
  long long v6 = *(void **)(a1 + 32);
  if (a3)
  {
    uint64_t v7 = v6[31];
    if (v7)
    {
      uint64_t v11 = sub_100046F68(v7 + 48, (void **)*a2 + 3);
      if ((void **)(v6[31] + 56) != v11)
      {
        int v13 = (const void **)v11[7];
        uint64_t v12 = (std::__shared_weak_count *)v11[8];
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (CFEqual(a3, (CFTypeRef)qword_101B12DB8) == 1)
        {
          uint64_t v14 = v6[5];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = PersonalityInfo::logPrefix(*a2);
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v15;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sIWF doesn't support this carrier - exclude SIM from feature", buf, 0x16u);
          }
          sub_100C36C48((uint64_t **)(v6[20] + 24), (void **)*a2 + 3, (uint64_t)*a2 + 24);
          goto LABEL_79;
        }
        SecCertificateRef certificate = 0;
        sub_100E71900((uint64_t *)&certificate, (uint64_t)v6);
        uint64_t v28 = certificate;
        if (certificate) {
          int v29 = sub_100563580;
        }
        else {
          int v29 = 0;
        }
        if (!v29)
        {
          uint64_t v36 = v6[5];
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            uint64_t v54 = PersonalityInfo::logPrefix(*a2);
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = v54;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2112;
            char v66 = (uint8_t *)a3;
            _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "#E %s%sInvalid certificate, VALIDATION failed, key-identifier:%@ - mark as UNSUPPORTED", buf, 0x20u);
          }
          sub_100C36C48((uint64_t **)(v6[20] + 24), (void **)*a2 + 3, (uint64_t)*a2 + 24);
          goto LABEL_78;
        }
        CFTypeRef v60 = 0;
        *(_OWORD *)char v58 = 0u;
        long long v59 = 0u;
        memset(v64, 0, 15);
        CFTypeRef cf = SecCertificateCopyKey(certificate);
        if (cf) {
          unsigned int v30 = sub_1008A95D4;
        }
        else {
          unsigned int v30 = 0;
        }
        if (v30)
        {
          CFStringRef commonName = SecCertificateCopySubjectSummary(v28);
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          unint64_t v31 = *(void *)&buf[8];
          unint64_t __p = *(void *)buf;
          LODWORD(v64[1]) = *(_DWORD *)&buf[16];
          *(_DWORD *)((char *)&v64[1] + 3) = *(_DWORD *)&buf[19];
          int v32 = (char)buf[23];
          sub_1000558F4((const void **)&commonName);
          CFStringRef commonName = 0;
          if (SecCertificateCopyCommonName(v28, &commonName))
          {
            uint64_t v33 = v6[5];
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              uint64_t v55 = PersonalityInfo::logPrefix(*a2);
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = v55;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "#E %s%scannot extract CN from certificate", buf, 0x16u);
            }
            CFTypeRef v34 = cf;
            CFTypeRef cf = 0;
            *(void *)std::string buf = v34;
            sub_100127DDC((const void **)buf);
            if ((v32 & 0x80000000) == 0)
            {
              unint64_t v35 = __p & 0xFFFFFFFFFFFFFF00;
LABEL_42:
              unint64_t __p = v35;
              v58[0] = (void *)cf;
              if (cf) {
                CFRetain(cf);
              }
              LOBYTE(v32) = 0;
              goto LABEL_45;
            }
            uint64_t v41 = (void *)__p;
            *(unsigned char *)unint64_t __p = 0;
            sub_100637AC0((const void **)v58, &cf);
            unint64_t v31 = 0;
          }
          else
          {
            CFTypeRef v40 = v64[0];
            v64[0] = commonName;
            *(void *)std::string buf = v40;
            sub_1000558F4((const void **)buf);
            sub_100637AC0((const void **)v58, &cf);
            if ((v32 & 0x80000000) == 0)
            {
LABEL_45:
              int v39 = 0;
              v58[1] = (void *)__p;
              *(void *)&long long v59 = v31;
              DWORD2(v59) = v64[1];
              *(_DWORD *)((char *)&v59 + 11) = *(_DWORD *)((char *)&v64[1] + 3);
              HIBYTE(v59) = v32;
              goto LABEL_50;
            }
            uint64_t v41 = (void *)__p;
          }
          sub_10004FC84(&v58[1], v41, v31);
          int v39 = 1;
LABEL_50:
          CFTypeRef v60 = v64[0];
          if (v64[0]) {
            CFRetain(v64[0]);
          }
          sub_100127DDC(&cf);
          sub_1000558F4(v64);
          if (v39) {
            operator delete((void *)__p);
          }
          int v42 = v6[5];
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = PersonalityInfo::logPrefix(*a2);
            uint64_t v44 = &v58[1];
            if (v59 < 0) {
              uint64_t v44 = (void **)v58[1];
            }
            *(_DWORD *)std::string buf = 136316162;
            *(void *)&uint8_t buf[4] = v43;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2112;
            char v66 = (uint8_t *)a3;
            __int16 v67 = 2080;
            CFDictionaryRef v68 = v44;
            __int16 v69 = 2112;
            __int16 v70 = v60;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%sGot certificate key-ident:'%@', subj:'%s', CN:%@", buf, 0x34u);
          }
          if (v58[0]) {
            std::string::size_type v45 = sub_1008A95D4;
          }
          else {
            std::string::size_type v45 = 0;
          }
          if (v45)
          {
            *(void *)std::string buf = a3;
            sub_100013168(v13 + 10, (CFTypeRef *)buf);
            sub_100083EB8(v13 + 12, &v60);
            *(void *)std::string buf = a4;
            sub_100013168(v13 + 13, (CFTypeRef *)buf);
            *(void *)std::string buf = a5;
            sub_1002824E4(v13 + 14, (CFTypeRef *)buf);
            uint64_t v46 = SecKeyCopySubjectPublicKeyInfo();
            int v47 = v13[11];
            v13[11] = (const void *)v46;
            *(void *)std::string buf = v47;
            sub_100030068((const void **)buf);
            if (v13[11]) {
              uint64_t v48 = sub_10008324C;
            }
            else {
              uint64_t v48 = 0;
            }
            uint64_t v49 = v6[5];
            if (v48)
            {
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v50 = PersonalityInfo::logPrefix(*a2);
                *(_DWORD *)std::string buf = 136315394;
                *(void *)&uint8_t buf[4] = v50;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%sIWF pubkey successfully acquired", buf, 0x16u);
                uint64_t v49 = v6[5];
              }
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v51 = PersonalityInfo::logPrefix(*a2);
                *(_DWORD *)std::string buf = 136315394;
                *(void *)&uint8_t buf[4] = v51;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%sIWF pubkey:", buf, 0x16u);
              }
              *(void *)std::string buf = off_101A64A58;
              *(void *)&uint8_t buf[8] = v6;
              *(void *)&uint8_t buf[16] = a2;
              char v66 = buf;
              logger::CFTypeRefLogger();
              sub_10012C330(buf);
              goto LABEL_75;
            }
            if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
LABEL_74:
              sub_100C36C48((uint64_t **)(v6[20] + 24), (void **)*a2 + 3, (uint64_t)*a2 + 24);
LABEL_75:
              sub_1000558F4(&v60);
              if (SHIBYTE(v59) < 0) {
                operator delete(v58[1]);
              }
              sub_100127DDC((const void **)v58);
LABEL_78:
              sub_100120040((const void **)&certificate);
LABEL_79:
              sub_100E6A644(v6);
              if (v12) {
                sub_10004D2C8(v12);
              }
              return;
            }
            uint64_t v56 = PersonalityInfo::logPrefix(*a2);
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v56;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            long long v53 = "#E %s%sunable to SecKeyCopySubjectPublicKeyInfo - mark as UNSUPPORTED";
          }
          else
          {
            uint64_t v49 = v6[5];
            if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
              goto LABEL_74;
            }
            uint64_t v52 = PersonalityInfo::logPrefix(*a2);
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v52;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            long long v53 = "#E %s%sInvalid certificate, unable to extract pub key from it - mark as UNSUPPORTED";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, v53, buf, 0x16u);
          goto LABEL_74;
        }
        CFMutableArrayRef v37 = v6[5];
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = PersonalityInfo::logPrefix(*a2);
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%sfail to extract public key from certificate", buf, 0x16u);
        }
        unint64_t v31 = 0;
        unint64_t v35 = 0;
        goto LABEL_42;
      }
      unsigned int v23 = v6[5];
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v24 = PersonalityInfo::logPrefix(*a2);
      uint64_t v25 = (char *)*a2 + 24;
      uint64_t v26 = *((unsigned __int8 *)*a2 + 47);
      int v27 = (char)v26;
      if ((v26 & 0x80u) != 0) {
        uint64_t v26 = *((void *)*a2 + 4);
      }
      if (v27 < 0) {
        uint64_t v25 = (const char *)*((void *)*a2 + 3);
      }
      if (!v26) {
        uint64_t v25 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v24;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      char v66 = (uint8_t *)v25;
      char v20 = "#E %s%sno personality %s in the Proposed config";
      uint64_t v21 = v23;
      uint32_t v22 = 32;
    }
    else
    {
      size_t v18 = v6[5];
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v19 = PersonalityInfo::logPrefix(*a2);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      char v20 = "#E %s%sfUpcoming revoked?!";
      uint64_t v21 = v18;
      uint32_t v22 = 22;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
    return;
  }
  uint64_t v16 = v6[5];
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = PersonalityInfo::logPrefix(*a2);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#W %s%sunable to fetch IWF certificate... Stopped trying", buf, 0x16u);
  }
}

void sub_100E717F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_100E72CA8((uint64_t)&a11);
  sub_100120040(&a16);
  if (v34) {
    sub_10004D2C8(v34);
  }
  _Unwind_Resume(a1);
}

void sub_100E71900(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  memset(buf, 0, sizeof(buf));
  uint64_t v12 = 0;
  ctu::cf::assign();
  long long v9 = 0u;
  uint64_t v10 = 0;
  ctu::base64::decode();
  uint64_t v4 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E unable to decode base64", buf, 2u);
  }
  uint64_t v5 = *a1;
  *a1 = 0;
  *(void *)std::string buf = v5;
  sub_100120040((const void **)buf);
}

void sub_100E72908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void **a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,__int16 a39,char a40,char a41,void *__p,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
  sub_100044D00((const void **)(v50 - 184));
  if (*(char *)(v50 - 201) < 0) {
    operator delete(*(void **)(v50 - 224));
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  uint64_t v52 = *(void **)(v50 - 256);
  if (v52)
  {
    *(void *)(v50 - 248) = v52;
    operator delete(v52);
  }
  sub_100120040(a13);
  _Unwind_Resume(a1);
}

const void **sub_100E72CA8(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  return sub_100127DDC((const void **)a1);
}

void sub_100E72CF4(void *a1)
{
  BOOL v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_58:
        sub_10004D2C8(v5);
        return;
      }
      if (!*(unsigned char *)(v3 + 97) || !*(unsigned char *)(v3 + 96))
      {
        int v20 = 0;
        goto LABEL_52;
      }
      uint64_t v6 = *(void *)(v3 + 216);
      if (!v6 || (v7 = *(void **)(v6 + 48), uint64_t v8 = (void *)(v6 + 56), v7 == (void *)(v6 + 56)))
      {
LABEL_28:
        int v20 = 0;
        goto LABEL_29;
      }
      while (1)
      {
        sub_100E71900((uint64_t *)buf, v3);
        long long v9 = *(void *)buf ? sub_100563580 : 0;
        sub_100120040((const void **)buf);
        uint64_t v10 = *(NSObject **)(v3 + 40);
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if (!v9) {
          break;
        }
        if (v11)
        {
          uint64_t v13 = *((unsigned __int8 *)v7 + 55);
          BOOL v14 = (v13 & 0x80u) != 0;
          if ((v13 & 0x80u) != 0) {
            uint64_t v13 = v7[5];
          }
          if (v14) {
            uint64_t v15 = (const char *)v7[4];
          }
          else {
            uint64_t v15 = (const char *)(v7 + 4);
          }
          if (v13) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = "<invalid>";
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I settled, certificates for sim %s are OK", buf, 0xCu);
        }
        uint64_t v17 = (void *)v7[1];
        if (v17)
        {
          do
          {
            size_t v18 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            size_t v18 = (void *)v7[2];
            BOOL v19 = *v18 == (void)v7;
            uint64_t v7 = v18;
          }
          while (!v19);
        }
        uint64_t v7 = v18;
        if (v18 == v8) {
          goto LABEL_28;
        }
      }
      if (v11)
      {
        uint64_t v35 = *((unsigned __int8 *)v7 + 55);
        BOOL v36 = (v35 & 0x80u) != 0;
        if ((v35 & 0x80u) != 0) {
          uint64_t v35 = v7[5];
        }
        if (v36) {
          CFMutableArrayRef v37 = (const char *)v7[4];
        }
        else {
          CFMutableArrayRef v37 = (const char *)(v7 + 4);
        }
        if (v35) {
          uint64_t v38 = v37;
        }
        else {
          uint64_t v38 = "<invalid>";
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v38;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I settled, check certificates for sim %s - FAILED - requires reprovisioning", buf, 0xCu);
      }
      sub_100E670C0(*(void *)(v3 + 216), (Registry **)(v3 + 48), v12);
      CFTypeRef v40 = *(std::__shared_weak_count **)(v3 + 224);
      *(void *)(v3 + 216) = 0;
      *(void *)(v3 + 224) = 0;
      if (v40) {
        sub_10004D2C8(v40);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v39, *(Registry **)(v3 + 48));
      int v42 = ServiceMap;
      uint64_t v43 = "8UStorage";
      if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
      {
        uint64_t v44 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v45 = 5381;
        do
        {
          uint64_t v43 = (const char *)v45;
          unsigned int v46 = *v44++;
          uint64_t v45 = (33 * v45) ^ v46;
        }
        while (v46);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v43;
      int v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)buf);
      if (v47)
      {
        uint64_t v49 = (os_unfair_lock_s *)v47[3];
        uint64_t v48 = (std::__shared_weak_count *)v47[4];
        if (v48)
        {
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v42);
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v48);
          char v50 = 0;
LABEL_97:
          sub_1000832B0(v49, @"SettledConfig", @"SatMsg", 0, 2u);
          if ((v50 & 1) == 0) {
            sub_10004D2C8(v48);
          }
          int v20 = 1;
LABEL_29:
          if (*(void *)(v3 + 232))
          {
            uint64_t v21 = *(void *)(v3 + 216);
            uint32_t v22 = *(void **)(v21 + 48);
            unsigned int v23 = (void *)(v21 + 56);
            if (v22 != (void *)(v21 + 56))
            {
              while (1)
              {
                sub_100E71900((uint64_t *)buf, v3);
                uint64_t v24 = *(void *)buf ? sub_100563580 : 0;
                sub_100120040((const void **)buf);
                uint64_t v25 = *(NSObject **)(v3 + 40);
                BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
                if (!v24) {
                  break;
                }
                if (v26)
                {
                  uint64_t v28 = *((unsigned __int8 *)v22 + 55);
                  BOOL v29 = (v28 & 0x80u) != 0;
                  if ((v28 & 0x80u) != 0) {
                    uint64_t v28 = v22[5];
                  }
                  if (v29) {
                    unsigned int v30 = (const char *)v22[4];
                  }
                  else {
                    unsigned int v30 = (const char *)(v22 + 4);
                  }
                  BOOL v19 = v28 == 0;
                  unint64_t v31 = "<invalid>";
                  if (!v19) {
                    unint64_t v31 = v30;
                  }
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v31;
                  _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I proposed, certificates for sim %s are OK", buf, 0xCu);
                }
                int v32 = (void *)v22[1];
                if (v32)
                {
                  do
                  {
                    uint64_t v33 = v32;
                    int v32 = (void *)*v32;
                  }
                  while (v32);
                }
                else
                {
                  do
                  {
                    uint64_t v33 = (void *)v22[2];
                    BOOL v19 = *v33 == (void)v22;
                    uint32_t v22 = v33;
                  }
                  while (!v19);
                }
                uint32_t v22 = v33;
                if (v33 == v23) {
                  goto LABEL_52;
                }
              }
              if (v26)
              {
                uint64_t v51 = *((unsigned __int8 *)v22 + 55);
                BOOL v52 = (v51 & 0x80u) != 0;
                if ((v51 & 0x80u) != 0) {
                  uint64_t v51 = v22[5];
                }
                if (v52) {
                  long long v53 = (const char *)v22[4];
                }
                else {
                  long long v53 = (const char *)(v22 + 4);
                }
                BOOL v19 = v51 == 0;
                uint64_t v54 = "<invalid>";
                if (!v19) {
                  uint64_t v54 = v53;
                }
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v54;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I proposed, check certificates for sim %s - FAILED - requires reprovisioning", buf, 0xCu);
              }
              sub_100E670C0(*(void *)(v3 + 232), (Registry **)(v3 + 48), v27);
              uint64_t v56 = *(std::__shared_weak_count **)(v3 + 240);
              *(void *)(v3 + 232) = 0;
              *(void *)(v3 + 240) = 0;
              if (v56) {
                sub_10004D2C8(v56);
              }
              std::string v57 = (std::mutex *)Registry::getServiceMap(v55, *(Registry **)(v3 + 48));
              char v58 = v57;
              long long v59 = "8UStorage";
              if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
              {
                CFTypeRef v60 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v61 = 5381;
                do
                {
                  long long v59 = (const char *)v61;
                  unsigned int v62 = *v60++;
                  uint64_t v61 = (33 * v61) ^ v62;
                }
                while (v62);
              }
              std::mutex::lock(v57);
              *(void *)std::string buf = v59;
              uint64_t v63 = sub_10004D37C(&v58[1].__m_.__sig, (unint64_t *)buf);
              if (v63)
              {
                uint64_t v65 = (os_unfair_lock_s *)v63[3];
                char v64 = (std::__shared_weak_count *)v63[4];
                if (v64)
                {
                  atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v58);
                  atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v64);
                  char v66 = 0;
LABEL_102:
                  sub_1000832B0(v65, @"ProposedConfig", @"SatMsg", 0, 2u);
                  if ((v66 & 1) == 0) {
                    sub_10004D2C8(v64);
                  }
                  int v20 = 1;
                  goto LABEL_52;
                }
              }
              else
              {
                uint64_t v65 = 0;
              }
              std::mutex::unlock(v58);
              char v64 = 0;
              char v66 = 1;
              goto LABEL_102;
            }
          }
LABEL_52:
          if (*(void *)(v3 + 216) && (uint64_t v34 = *(void *)(v3 + 312)) != 0) {
            sub_100D211E4(v34, 0);
          }
          else {
            sub_100E7331C((void *)v3);
          }
          if (v20) {
            sub_100E6822C(v3);
          }
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v49 = 0;
      }
      std::mutex::unlock(v42);
      uint64_t v48 = 0;
      char v50 = 1;
      goto LABEL_97;
    }
  }
}

void sub_100E73290(_Unwind_Exception *a1)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E732E8(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E7330C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E7331C(void *a1)
{
  uint64_t v1 = a1[39];
  if (v1)
  {
    uint64_t v3 = a1 + 39;
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I canceling certificate validation", v6, 2u);
      uint64_t v1 = *v3;
    }
    sub_100D20DC0(v1);
    uint64_t v5 = (std::__shared_weak_count *)a1[40];
    uint64_t *v3 = 0;
    v3[1] = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E733B0(Registry *a1@<X0>, uint64_t a2@<X1>, const __CFUUID *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a6, a1);
  BOOL v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t __p = (void *)v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&__p);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
LABEL_9:
  BOOL v26 = 0;
  sub_100E6EBA8(&v26, a3);
  if (a4 && a5 && v18)
  {
    int v20 = v26;
    if (v26 ? sub_1000810B8 : 0)
    {
      uint32_t v22 = operator new(8uLL);
      unint64_t __p = v22;
      *uint32_t v22 = v20;
      uint64_t v24 = v22 + 1;
      uint64_t v25 = v22 + 1;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, const __CFString *, void **, uint64_t, void))(*(void *)v18 + 16))(v18, a2, a4, a5, @"SatMsg", &__p, 4, 0);
      if (__p)
      {
        uint64_t v24 = __p;
        operator delete(__p);
      }
    }
  }
  sub_1000558F4(&v26);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100E73554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, const void *a12)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_100E7359C(Registry *a1@<X0>, uint64_t a2@<X1>, const __CFUUID *a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, uint64_t *a6@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a6, a1);
  BOOL v11 = ServiceMap;
  if (v12 < 0)
  {
    char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t __p = (void *)v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&__p);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_8;
  }
  uint64_t v18 = v16[3];
  uint64_t v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_8:
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_9:
  BOOL v29 = 0;
  sub_100E6EBA8(&v29, a3);
  if (a4)
  {
    int v20 = *a5 ? sub_10008324C : 0;
    if (v20 && v18)
    {
      if (v29 ? sub_1000810B8 : 0)
      {
        sub_100E7959C(&v28, (uint64_t)a5);
        uint32_t v22 = v28;
        unsigned int v23 = v29;
        uint64_t v24 = operator new(8uLL);
        unint64_t __p = v24;
        void *v24 = v23;
        BOOL v26 = v24 + 1;
        int v27 = v24 + 1;
        (*(void (**)(uint64_t, uint64_t, uint64_t, const void *, const __CFString *, void **, uint64_t, void))(*(void *)v18 + 16))(v18, a2, a4, v22, @"SatMsg", &__p, 4, 0);
        if (__p)
        {
          BOOL v26 = __p;
          operator delete(__p);
        }
        sub_1000577C4(&v28);
      }
    }
  }
  sub_1000558F4(&v29);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100E73774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13, const void *a14)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1000577C4(&a13);
  sub_1000558F4(&a14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

const void **sub_100E737CC(void *a1, uint64_t a2, long long *a3, uint64_t a4)
{
  CFMutableDictionaryRef v60 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v9 = v60;
    CFMutableDictionaryRef v60 = Mutable;
    *(void *)std::string buf = v9;
    sub_10005717C((const void **)buf);
  }
  unsigned int value = 0;
  theDict[0] = 0;
  uint64_t v10 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  std::string v57 = a1;
  if (v10)
  {
    CFMutableDictionaryRef v11 = theDict[0];
    theDict[0] = v10;
    *(void *)std::string buf = v11;
    sub_10005717C((const void **)buf);
  }
  if (*((void *)a3 + 8))
  {
    CFMutableArrayRef theArray = 0;
    uint64_t v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    uint64_t v55 = a2;
    if (v12)
    {
      CFMutableArrayRef v13 = theArray;
      CFMutableArrayRef theArray = v12;
      *(void *)std::string buf = v13;
      sub_1000440D4((const void **)buf);
    }
    uint64_t v14 = (uint64_t *)*((void *)a3 + 8);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    if (*v14 != v16)
    {
      uint64_t v17 = a2 + 40;
      do
      {
        CFMutableArrayRef v85 = 0;
        uint64_t v18 = operator new(0x30uLL);
        *((void *)v18 + 1) = 0;
        *((void *)v18 + 2) = 0;
        *((void *)v18 + 3) = 0;
        *(void *)uint64_t v18 = off_1019B47B8;
        *((void *)v18 + 4) = 0;
        *((void *)v18 + 5) = 0;
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        long long __dst = *(_OWORD *)buf;
        uint64_t v83 = *(void *)&buf[16];
        *(void *)std::string buf = off_1019D84C8;
        *(void *)&uint8_t buf[8] = v17;
        BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a4 + 80));
        CFIndex Length = (const void *)CFDataGetLength(*(CFDataRef *)(a4 + 80));
        if (v83 >= 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (long long *)__dst;
        }
        if (v83 >= 0) {
          uint32_t v22 = (const void *)HIBYTE(v83);
        }
        else {
          uint32_t v22 = (const void *)*((void *)&__dst + 1);
        }
        char v23 = sub_1004DCFBC((void **)buf, BytePtr, Length, p_dst, v22, (unint64_t *)v18 + 3);
        char v24 = v23;
        if (SHIBYTE(v83) < 0)
        {
          operator delete((void *)__dst);
          if (v24)
          {
LABEL_18:
            long long v78 = 0uLL;
            uint64_t v79 = 0;
            ctu::base64::encode();
            if (SHIBYTE(v79) < 0)
            {
              sub_10004FC84(&__p, (void *)v78, *((unint64_t *)&v78 + 1));
            }
            else
            {
              long long __p = v78;
              uint64_t v77 = v79;
            }
            if (SHIBYTE(v77) < 0)
            {
              sub_10004FC84(&__dst, (void *)__p, *((unint64_t *)&__p + 1));
            }
            else
            {
              long long __dst = __p;
              uint64_t v83 = v77;
            }
            v64[0] = 0;
            if (SHIBYTE(v83) < 0)
            {
              sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
            }
            else
            {
              *(_OWORD *)std::string buf = __dst;
              *(void *)&uint8_t buf[16] = v83;
            }
            CFDictionaryRef v68 = 0;
            if (ctu::cf::convert_copy())
            {
              BOOL v26 = v64[0];
              v64[0] = v68;
              *(void *)&long long v74 = v26;
              sub_1000558F4((const void **)&v74);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            CFMutableArrayRef v85 = (CFMutableArrayRef)v64[0];
            v64[0] = 0;
            sub_1000558F4((const void **)v64);
            if (SHIBYTE(v83) < 0) {
              operator delete((void *)__dst);
            }
            if (SHIBYTE(v77) < 0) {
              operator delete((void *)__p);
            }
            if (SHIBYTE(v79) < 0) {
              operator delete((void *)v78);
            }
            sub_10004D2C8((std::__shared_weak_count *)v18);
            CFMutableArrayRef v25 = v85;
            goto LABEL_40;
          }
        }
        else if (v23)
        {
          goto LABEL_18;
        }
        sub_10004D2C8((std::__shared_weak_count *)v18);
        CFMutableArrayRef v25 = 0;
        CFMutableArrayRef v85 = 0;
LABEL_40:
        if (v25) {
          int v27 = sub_1000810B8;
        }
        else {
          int v27 = 0;
        }
        if (v27) {
          CFArrayAppendValue(theArray, v25);
        }
        sub_1000558F4((const void **)&v85);
        v15 += 8;
      }
      while (v15 != v16);
    }
    CFDictionarySetValue(theDict[0], @"primaryContacts", theArray);
    a2 = v55;
    sub_1000440D4((const void **)&theArray);
    sub_10004EFE4(&__dst, (CFTypeRef *)theDict);
    *(void *)std::string buf = 0;
    unsigned int value = (void *)__dst;
    *(void *)&long long __dst = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&__dst);
  }
  else
  {
    uint64_t v28 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "no Contacts for Budgie!", buf, 2u);
    }
  }
  sub_10005717C((const void **)theDict);
  char v58 = 0;
  xpc_object_t v80 = 0;
  CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v29)
  {
    unsigned int v30 = v80;
    xpc_object_t v80 = v29;
    *(void *)std::string buf = v30;
    sub_10005717C((const void **)buf);
  }
  long long v78 = 0uLL;
  uint64_t v79 = 0;
  sub_100E63F30((unint64_t *)&v78, (uint64_t)"com.apple.security.crypto.PSPS.clientEncryptedPublicKeyDiversifier", 66);
  CFDictionaryRef v68 = 0;
  __int16 v69 = 0;
  unint64_t v31 = (NSObject **)(a2 + 40);
  sub_100BCAEB4(v31, 16, (void ***)&v68);
  int v32 = v68;
  if (v68)
  {
    long long __p = 0uLL;
    uint64_t v77 = 0;
    ctu::base64::encode();
    uint64_t v33 = v80;
    if (SHIBYTE(v77) < 0)
    {
      sub_10004FC84(&v74, (void *)__p, *((unint64_t *)&__p + 1));
    }
    else
    {
      long long v74 = __p;
      uint64_t v75 = v77;
    }
    if (SHIBYTE(v75) < 0)
    {
      sub_10004FC84(&__dst, (void *)v74, *((unint64_t *)&v74 + 1));
    }
    else
    {
      long long __dst = v74;
      uint64_t v83 = v75;
    }
    CFMutableArrayRef theArray = 0;
    if (SHIBYTE(v83) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)std::string buf = __dst;
      *(void *)&uint8_t buf[16] = v83;
    }
    theDict[0] = 0;
    if (ctu::cf::convert_copy())
    {
      CFMutableArrayRef v35 = theArray;
      CFMutableArrayRef theArray = theDict[0];
      v64[0] = v35;
      sub_1000558F4((const void **)v64);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    CFMutableArrayRef v85 = theArray;
    CFMutableArrayRef theArray = 0;
    sub_1000558F4((const void **)&theArray);
    if (SHIBYTE(v83) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionarySetValue(v33, @"devicePublicKey", v85);
    sub_1000558F4((const void **)&v85);
    if (SHIBYTE(v75) < 0) {
      operator delete((void *)v74);
    }
    if (SHIBYTE(v77) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    uint64_t v34 = *v31;
    if (os_log_type_enabled(*v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "unable to encrypt UE pub key", buf, 2u);
    }
  }
  if (v69) {
    sub_10004D2C8(v69);
  }
  if ((void)v78)
  {
    *((void *)&v78 + 1) = v78;
    operator delete((void *)v78);
  }
  if (v32)
  {
    CFDictionarySetValue(v80, @"iwfPublicKey", *((const void **)a3 + 10));
    CFMutableDictionaryRef v73 = 0;
    BOOL v36 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v36)
    {
      CFMutableDictionaryRef v37 = v73;
      CFMutableDictionaryRef v73 = v36;
      *(void *)std::string buf = v37;
      sub_10005717C((const void **)buf);
    }
    uint64_t v38 = v73;
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(&v78, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long v78 = *a3;
      uint64_t v79 = *((void *)a3 + 2);
    }
    if (SHIBYTE(v79) < 0)
    {
      sub_10004FC84(&__dst, (void *)v78, *((unint64_t *)&v78 + 1));
    }
    else
    {
      long long __dst = v78;
      uint64_t v83 = v79;
    }
    v64[0] = 0;
    if (SHIBYTE(v83) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)std::string buf = __dst;
      *(void *)&uint8_t buf[16] = v83;
    }
    CFDictionaryRef v68 = 0;
    if (ctu::cf::convert_copy())
    {
      int v39 = v64[0];
      v64[0] = v68;
      *(void *)&long long __p = v39;
      sub_1000558F4((const void **)&__p);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    theDict[0] = (CFMutableDictionaryRef)v64[0];
    v64[0] = 0;
    sub_1000558F4((const void **)v64);
    if (SHIBYTE(v83) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionarySetValue(v38, @"ueIMSI", theDict[0]);
    sub_1000558F4((const void **)theDict);
    if (SHIBYTE(v79) < 0) {
      operator delete((void *)v78);
    }
    CFTypeRef v40 = v73;
    if (*((char *)a3 + 55) < 0)
    {
      sub_10004FC84(&__p, *((void **)a3 + 4), *((void *)a3 + 5));
    }
    else
    {
      long long __p = a3[2];
      uint64_t v77 = *((void *)a3 + 6);
    }
    if (SHIBYTE(v77) < 0)
    {
      sub_10004FC84(&__dst, (void *)__p, *((unint64_t *)&__p + 1));
    }
    else
    {
      long long __dst = __p;
      uint64_t v83 = v77;
    }
    theDict[0] = 0;
    if (SHIBYTE(v83) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)std::string buf = __dst;
      *(void *)&uint8_t buf[16] = v83;
    }
    v64[0] = 0;
    if (ctu::cf::convert_copy())
    {
      CFMutableDictionaryRef v41 = theDict[0];
      theDict[0] = (CFMutableDictionaryRef)v64[0];
      CFDictionaryRef v68 = v41;
      sub_1000558F4((const void **)&v68);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    CFMutableArrayRef theArray = theDict[0];
    theDict[0] = 0;
    sub_1000558F4((const void **)theDict);
    if (SHIBYTE(v83) < 0) {
      operator delete((void *)__dst);
    }
    CFDictionarySetValue(v40, @"ueSMSC", theArray);
    sub_1000558F4((const void **)&theArray);
    if (SHIBYTE(v77) < 0) {
      operator delete((void *)__p);
    }
    CFDictionarySetValue(v73, @"version", &off_101AE64A8);
    os_log_t v71 = 0;
    uint64_t v72 = 0;
    int v42 = +[NSJSONSerialization dataWithJSONObject:v73 options:1 error:&v72];
    os_log_t v71 = v42;
    if (v42) {
      CFRetain(v42);
    }
    CFDictionaryRef v68 = 0;
    __int16 v69 = 0;
    uint64_t v70 = 0;
    sub_100E6408C((unint64_t *)&v68, *((CFDataRef *)a3 + 11));
    sub_100E6408C((unint64_t *)&v68, *(CFDataRef *)(a4 + 64));
    sub_100E63F30((unint64_t *)&v68, (uint64_t)"Mario", 5);
    sub_100E63F30((unint64_t *)&v68, (uint64_t)"com.Midway.security.crypto.Mario.EncryptedCredentialADDiversifier", 65);
    CFMutableArrayRef theArray = 0;
    __int16 v67 = 0;
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v56 = *(void **)buf;
    long long __dst = *(_OWORD *)buf;
    uint64_t v83 = *(void *)&buf[16];
    sub_100BCAEB4(v31, 16, (void ***)&theArray);
    if (v56) {
      operator delete(v56);
    }
    CFMutableArrayRef v43 = theArray;
    if (theArray)
    {
      v64[0] = 0;
      v64[1] = 0;
      uint64_t v65 = 0;
      ctu::base64::encode();
      uint64_t v44 = v80;
      if (SHIBYTE(v65) < 0)
      {
        sub_10004FC84(theDict, v64[0], (unint64_t)v64[1]);
      }
      else
      {
        *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)v64;
        uint64_t v62 = v65;
      }
      if (SHIBYTE(v62) < 0)
      {
        sub_10004FC84(&__dst, theDict[0], (unint64_t)theDict[1]);
      }
      else
      {
        long long __dst = *(_OWORD *)theDict;
        uint64_t v83 = v62;
      }
      __int16 v81 = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        *(_OWORD *)std::string buf = __dst;
        *(void *)&uint8_t buf[16] = v83;
      }
      unsigned __int8 v84 = 0;
      if (ctu::cf::convert_copy())
      {
        unsigned int v46 = v81;
        __int16 v81 = v84;
        CFMutableArrayRef v85 = v46;
        sub_1000558F4((const void **)&v85);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      int v47 = v81;
      uint64_t v63 = v81;
      __int16 v81 = 0;
      sub_1000558F4((const void **)&v81);
      if (SHIBYTE(v83) < 0) {
        operator delete((void *)__dst);
      }
      CFDictionarySetValue(v44, @"encryptedSimCredentials", v47);
      sub_1000558F4((const void **)&v63);
      if (SHIBYTE(v62) < 0) {
        operator delete(theDict[0]);
      }
      if (SHIBYTE(v65) < 0) {
        operator delete(v64[0]);
      }
    }
    else
    {
      uint64_t v45 = *v31;
      if (os_log_type_enabled(*v31, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "unable to encrypt credentials", buf, 2u);
      }
    }
    if (v67) {
      sub_10004D2C8(v67);
    }
    if (v68)
    {
      __int16 v69 = (std::__shared_weak_count *)v68;
      operator delete(v68);
    }
    sub_100030068((const void **)&v71);
    sub_10005717C((const void **)&v73);
    if (v43)
    {
      sub_10004EFE4(&__dst, (CFTypeRef *)&v80);
      *(void *)std::string buf = 0;
      char v58 = (void *)__dst;
      *(void *)&long long __dst = 0;
      sub_100057D78((const void **)buf);
      sub_100057D78((const void **)&__dst);
    }
  }
  sub_10005717C((const void **)&v80);
  if (value) {
    uint64_t v48 = sub_100080778;
  }
  else {
    uint64_t v48 = 0;
  }
  if (v48 && (v58 ? (uint64_t v49 = sub_100080778) : (uint64_t v49 = 0), v49))
  {
    CFDictionarySetValue(v60, @"budgie", value);
    CFDictionarySetValue(v60, @"iwf", v58);
    sub_10004EFE4(v57, (CFTypeRef *)&v60);
  }
  else
  {
    char v50 = *v31;
    if (os_log_type_enabled(*v31, OS_LOG_TYPE_ERROR))
    {
      BOOL v52 = "present";
      if (v48) {
        long long v53 = "present";
      }
      else {
        long long v53 = "missing";
      }
      if (v58) {
        uint64_t v54 = sub_100080778;
      }
      else {
        uint64_t v54 = 0;
      }
      if (!v54) {
        BOOL v52 = "missing";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v53;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v52;
      _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "failed to compile subscription description: budgie:%s iwf:%s", buf, 0x16u);
    }
    void *v57 = 0;
  }
  sub_100057D78((const void **)&v58);
  sub_100057D78((const void **)&value);
  return sub_10005717C((const void **)&v60);
}

void sub_100E744BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,std::__shared_weak_count *a33,void *a34,uint64_t a35,uint64_t a36,const void *a37,uint64_t a38,const void *a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  sub_1000558F4((const void **)(v52 - 184));
  if (*(char *)(v52 - 153) < 0) {
    operator delete(*(void **)(v52 - 176));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a33) {
    sub_10004D2C8(a33);
  }
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  sub_100030068(&a37);
  sub_10005717C(&a39);
  sub_10005717C((const void **)(v52 - 192));
  sub_100057D78(&a15);
  sub_100057D78(&a16);
  sub_10005717C(&a17);
  _Unwind_Resume(a1);
}

const void **sub_100E74840(void *a1, uint64_t a2, uint64_t a3)
{
  int v39 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v7 = v39;
    int v39 = Mutable;
    *(void *)long long valuePtr = v7;
    sub_10005717C((const void **)valuePtr);
  }
  CFMutableDictionaryRef theDict = 0;
  uint64_t v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v8)
  {
    CFMutableDictionaryRef v9 = theDict;
    CFMutableDictionaryRef theDict = v8;
    *(void *)long long valuePtr = v9;
    sub_10005717C((const void **)valuePtr);
  }
  CFMutableDictionaryRef v11 = (uint64_t *)(a3 + 32);
  uint64_t v10 = *(void *)(a3 + 32);
  if (!v10) {
    goto LABEL_31;
  }
  uint64_t v12 = a3 + 32;
  do
  {
    int v13 = *(_DWORD *)(v10 + 32);
    BOOL v14 = v13 < 0;
    if (v13 >= 0) {
      uint64_t v15 = (uint64_t *)v10;
    }
    else {
      uint64_t v15 = (uint64_t *)(v10 + 8);
    }
    if (!v14) {
      uint64_t v12 = v10;
    }
    uint64_t v10 = *v15;
  }
  while (*v15);
  if ((uint64_t *)v12 != v11 && *(int *)(v12 + 32) <= 0)
  {
    unint64_t v31 = (void **)(v12 + 40);
    int v32 = sub_100046F68(a3 + 48, (void **)(v12 + 40));
    if ((void **)(a3 + 56) != v32)
    {
      unsigned int value = 0;
      uint64_t v33 = (long long *)v32[7];
      uint64_t v34 = sub_100046F68(a3 + 72, v31);
      sub_100E737CC(&value, a2, v33, (uint64_t)v34[7]);
      if (value) {
        CFMutableArrayRef v35 = sub_100080778;
      }
      else {
        CFMutableArrayRef v35 = 0;
      }
      if (!v35)
      {
        BOOL v36 = *(NSObject **)(a2 + 40);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
LABEL_44:
          *a1 = 0;
          sub_100057D78((const void **)&value);
          goto LABEL_34;
        }
        *(_DWORD *)long long valuePtr = 136315138;
        *(void *)&valuePtr[4] = "s0";
LABEL_46:
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "failed to compile subscription %s", valuePtr, 0xCu);
        goto LABEL_44;
      }
      CFDictionarySetValue(theDict, @"0", value);
      sub_100057D78((const void **)&value);
    }
  }
  uint64_t v16 = *v11;
  if (!*v11) {
    goto LABEL_31;
  }
  uint64_t v17 = a3 + 32;
  do
  {
    int v18 = *(_DWORD *)(v16 + 32);
    BOOL v19 = v18 < 1;
    if (v18 >= 1) {
      int v20 = (uint64_t *)v16;
    }
    else {
      int v20 = (uint64_t *)(v16 + 8);
    }
    if (!v19) {
      uint64_t v17 = v16;
    }
    uint64_t v16 = *v20;
  }
  while (*v20);
  if ((uint64_t *)v17 == v11) {
    goto LABEL_31;
  }
  if (*(int *)(v17 + 32) > 1) {
    goto LABEL_31;
  }
  uint64_t v21 = (void **)(v17 + 40);
  uint32_t v22 = sub_100046F68(a3 + 48, (void **)(v17 + 40));
  if ((void **)(a3 + 56) == v22) {
    goto LABEL_31;
  }
  unsigned int value = 0;
  char v23 = (long long *)v22[7];
  char v24 = sub_100046F68(a3 + 72, v21);
  sub_100E737CC(&value, a2, v23, (uint64_t)v24[7]);
  if (value) {
    CFMutableArrayRef v25 = sub_100080778;
  }
  else {
    CFMutableArrayRef v25 = 0;
  }
  if (!v25)
  {
    BOOL v36 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      goto LABEL_44;
    }
    *(_DWORD *)long long valuePtr = 136315138;
    *(void *)&valuePtr[4] = "s1";
    goto LABEL_46;
  }
  CFDictionarySetValue(theDict, @"1", value);
  sub_100057D78((const void **)&value);
LABEL_31:
  CFDictionarySetValue(v39, @"simConfigs", theDict);
  sub_100E6EBA8((const void **)valuePtr, *(const __CFUUID **)a3);
  CFDictionarySetValue(v39, @"uuid", *(const void **)valuePtr);
  sub_1000558F4((const void **)valuePtr);
  uint64_t v26 = *(void *)(a3 + 8);
  unsigned int value = 0;
  *(void *)long long valuePtr = v26;
  CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, valuePtr);
  if (v27)
  {
    uint64_t v28 = value;
    unsigned int value = v27;
    *(void *)long long valuePtr = v28;
    sub_1000570E8((const void **)valuePtr);
  }
  CFMutableDictionaryRef v29 = value;
  CFMutableDictionaryRef v37 = value;
  unsigned int value = 0;
  sub_1000570E8((const void **)&value);
  CFDictionarySetValue(v39, @"generatedAt", v29);
  sub_1000570E8((const void **)&v37);
  sub_10004EFE4(a1, (CFTypeRef *)&v39);
LABEL_34:
  sub_10005717C((const void **)&theDict);
  return sub_10005717C((const void **)&v39);
}

void sub_100E74C0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  sub_100057D78((const void **)va2);
  sub_10005717C((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100E74C7C(uint64_t a1, uint64_t a2)
{
  CFUUIDRef v23 = 0;
  uint64_t v24 = 0;
  uint64_t v4 = *(const void ***)(a1 + 232);
  if (v4)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 240);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
LABEL_8:
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v8 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      *(void *)&long long value = v8;
      sub_10005717C((const void **)&value);
    }
    uint64_t v9 = *(void *)(a1 + 216);
    if (v9)
    {
      *(void *)&long long value = 0;
      sub_100E74840(&value, a1, v9);
      if ((void)value) {
        uint64_t v10 = sub_100080778;
      }
      else {
        uint64_t v10 = 0;
      }
      if (!v10)
      {
        BOOL v14 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
        LOWORD(v21) = 0;
        uint64_t v15 = "failed to compile settled bucket";
        goto LABEL_46;
      }
      if (*(unsigned char *)(a1 + 208) && *(_DWORD *)(a1 + 204)) {
        CFStringRef v11 = @"parakeetConfig_1";
      }
      else {
        CFStringRef v11 = @"parakeetConfig_0";
      }
      CFDictionarySetValue(theDict, v11, (const void *)value);
      sub_100057D78((const void **)&value);
    }
    if (!v4)
    {
      uint64_t v4 = (const void **)(a1 + 280);
LABEL_37:
      sub_100224390((const void **)&v23, v4);
      sub_100E6EBA8((const void **)&value, v23);
      CFDictionarySetValue(theDict, @"uuid", (const void *)value);
      sub_1000558F4((const void **)&value);
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(value) = 138412290;
        *(void *)((char *)&value + 4) = v23;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I getSatelliteMsgCfgToUpdate, created update with ID:%@", (uint8_t *)&value, 0xCu);
      }
      *(void *)&long long value = off_101A64CD8;
      *((void *)&value + 1) = a1;
      p_long long value = &value;
      logger::CFTypeRefLogger();
      sub_10012C330(&value);
      uint64_t v21 = 0;
      *(void *)&long long value = +[NSJSONSerialization dataWithJSONObject:theDict options:1 error:&v21];
      sub_10015E5D4((const void **)&v24, (CFTypeRef *)&value);
      BOOL v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(value) = 138412290;
        *(void *)((char *)&value + 4) = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I getSatelliteMsgCfgToUpdate, giving out JSON with err:%@", (uint8_t *)&value, 0xCu);
      }
      *(void *)&long long value = off_101A64D58;
      *((void *)&value + 1) = a1;
      p_long long value = &value;
      logger::CFTypeRefLogger();
      sub_10012C330(&value);
      goto LABEL_42;
    }
    *(void *)&long long value = 0;
    sub_100E74840(&value, a1, (uint64_t)v4);
    if ((void)value) {
      uint64_t v12 = sub_100080778;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v12)
    {
      if (*(unsigned char *)(a1 + 208) && !*(_DWORD *)(a1 + 204)) {
        CFStringRef v13 = @"parakeetConfig_1";
      }
      else {
        CFStringRef v13 = @"parakeetConfig_0";
      }
      CFDictionarySetValue(theDict, v13, (const void *)value);
      sub_100057D78((const void **)&value);
      goto LABEL_37;
    }
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_32:
      sub_100057D78((const void **)&value);
LABEL_42:
      sub_10005717C((const void **)&theDict);
      if (v5) {
        sub_10004D2C8(v5);
      }
      goto LABEL_44;
    }
    LOWORD(v21) = 0;
    uint64_t v15 = "failed to compile proposed bucket";
LABEL_46:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v21, 2u);
    goto LABEL_32;
  }
  uint64_t v5 = 0;
  if (*(void *)(a1 + 280)) {
    uint64_t v6 = sub_100136254;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6) {
    goto LABEL_8;
  }
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(value) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I getSatelliteMsgCfgToUpdate - nothing to sync", (uint8_t *)&value, 2u);
  }
LABEL_44:
  sub_100E75138(*(void *)(a2 + 24), (uint64_t)v23, v24);
  sub_10012577C((const void **)&v23);
  return sub_100030068((const void **)&v24);
}

void sub_100E750AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFMutableDictionaryRef v8 = va_arg(va3, const void *);
  sub_100057D78((const void **)va3);
  sub_10005717C((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10012577C((const void **)va1);
  sub_100030068((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100E75138(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a2;
  uint64_t v4 = 0;
  uint64_t v5 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v6, &v5, &v4);
}

void sub_100E75194(uint64_t a1, uint64_t a2, const void *a3, const char *a4)
{
  CFMutableDictionaryRef v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (!v9) {
      return;
    }
    *(_DWORD *)std::string buf = 138412290;
    *(void *)&uint8_t buf[4] = a2;
    uint64_t v10 = "#I setSatelliteMsgCfgUpdated failed with %@";
    CFStringRef v11 = v8;
    uint32_t v12 = 12;
    goto LABEL_36;
  }
  if (v9)
  {
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = a3;
    __int16 v119 = 2112;
    long long v120 = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I setSatelliteMsgCfgUpdated success, cfg_id:%@, sps:%@", buf, 0x16u);
  }
  CFStringRef v13 = *(const void **)(a1 + 280);
  if (v13) {
    BOOL v14 = sub_100136254;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14 || CFEqual(v13, a3) != 1)
  {
    CFNumberRef v27 = *(CFTypeRef **)(a1 + 232);
    if (!v27)
    {
      int v42 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "#I ACK received while no configuration Proposed";
      CFStringRef v11 = v42;
      uint32_t v12 = 2;
      goto LABEL_36;
    }
    if (CFEqual(*v27, a3) != 1)
    {
      CFMutableArrayRef v43 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v44 = **(const char ***)(a1 + 232);
      *(_DWORD *)std::string buf = 138412546;
      *(void *)&uint8_t buf[4] = a3;
      __int16 v119 = 2112;
      long long v120 = v44;
      uint64_t v10 = "#I ACK received with %@ while Proposed is %@";
      CFStringRef v11 = v43;
      goto LABEL_35;
    }
    *(unsigned char *)(a1 + 272) = 0;
    uint64_t v28 = *(void *)(a1 + 280);
    *(void *)(a1 + 280) = 0;
    *(void *)std::string buf = v28;
    sub_10012577C((const void **)buf);
    CFMutableDictionaryRef v29 = (Registry **)(a1 + 48);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v30, *(Registry **)(a1 + 48));
    int v32 = ServiceMap;
    uint64_t v33 = "8UStorage";
    uint64_t v34 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      CFMutableArrayRef v35 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v36 = 5381;
      do
      {
        uint64_t v34 = (const char *)v36;
        unsigned int v37 = *v35++;
        uint64_t v36 = (33 * v36) ^ v37;
      }
      while (v37);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v34;
    uint64_t v38 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)buf);
    if (v38)
    {
      CFTypeRef v40 = (os_unfair_lock_s *)v38[3];
      int v39 = (std::__shared_weak_count *)v38[4];
      if (v39)
      {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v32);
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v39);
        char v41 = 0;
        goto LABEL_40;
      }
    }
    else
    {
      CFTypeRef v40 = 0;
    }
    std::mutex::unlock(v32);
    int v39 = 0;
    char v41 = 1;
LABEL_40:
    sub_1000832B0(v40, @"need-reprovisioning", @"SatMsg", 0, 2u);
    if ((v41 & 1) == 0) {
      sub_10004D2C8(v39);
    }
    int v47 = (std::mutex *)Registry::getServiceMap(v46, *v29);
    uint64_t v48 = v47;
    uint64_t v49 = "8UStorage";
    if ((uint64_t)"8UStorage" < 0)
    {
      char v50 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v51 = 5381;
      do
      {
        uint64_t v49 = (const char *)v51;
        unsigned int v52 = *v50++;
        uint64_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v47);
    *(void *)std::string buf = v49;
    long long v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
    if (v53)
    {
      uint64_t v55 = (os_unfair_lock_s *)v53[3];
      uint64_t v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v48);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        char v56 = 0;
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    std::mutex::unlock(v48);
    uint64_t v54 = 0;
    char v56 = 1;
LABEL_50:
    sub_1000832B0(v55, @"need-clean-push", @"SatMsg", 0, 2u);
    if ((v56 & 1) == 0) {
      sub_10004D2C8(v54);
    }
    int v57 = *(unsigned __int8 *)(a1 + 208);
    if (*(unsigned char *)(a1 + 208)) {
      int v57 = *(_DWORD *)(a1 + 204) == 0;
    }
    *(_DWORD *)(a1 + 204) = v57;
    *(unsigned char *)(a1 + 208) = 1;
    char v58 = (std::mutex *)Registry::getServiceMap((uint64_t *)1, *(Registry **)(a1 + 48));
    long long v59 = v58;
    CFMutableDictionaryRef v60 = "8UStorage";
    if ((uint64_t)"8UStorage" < 0)
    {
      uint64_t v61 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v62 = 5381;
      do
      {
        CFMutableDictionaryRef v60 = (const char *)v62;
        unsigned int v63 = *v61++;
        uint64_t v62 = (33 * v62) ^ v63;
      }
      while (v63);
    }
    std::mutex::lock(v58);
    *(void *)std::string buf = v60;
    char v64 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)buf);
    if (v64)
    {
      char v66 = (os_unfair_lock_s *)v64[3];
      uint64_t v65 = (std::__shared_weak_count *)v64[4];
      if (v65)
      {
        atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v59);
        atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v65);
        char v67 = 0;
        goto LABEL_62;
      }
    }
    else
    {
      char v66 = 0;
    }
    std::mutex::unlock(v59);
    uint64_t v65 = 0;
    char v67 = 1;
LABEL_62:
    uint64_t v68 = *(unsigned int *)(a1 + 204);
    CFNumberRef v117 = 0;
    *(void *)std::string buf = v68;
    CFNumberRef v69 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
    if (v69)
    {
      CFNumberRef v70 = v117;
      CFNumberRef v117 = v69;
      *(void *)std::string buf = v70;
      sub_1000570E8((const void **)buf);
    }
    CFNumberRef v116 = v117;
    CFNumberRef v117 = 0;
    sub_1000570E8((const void **)&v117);
    sub_1000825C4(v66, @"bucket", v116, @"SatMsg", 0, 2u, 0, 0);
    sub_1000570E8((const void **)&v116);
    if ((v67 & 1) == 0) {
      sub_10004D2C8(v65);
    }
    uint64_t v71 = *(void *)(a1 + 216);
    if (!v71)
    {
LABEL_81:
      uint64_t v89 = *(void *)(a1 + 232);
      xpc_object_t v88 = *(uint64_t **)(a1 + 240);
      if (v88) {
        atomic_fetch_add_explicit(v88 + 1, 1uLL, memory_order_relaxed);
      }
      BOOL v90 = *(std::__shared_weak_count **)(a1 + 224);
      *(void *)(a1 + 216) = v89;
      *(void *)(a1 + 224) = v88;
      if (v90) {
        sub_10004D2C8(v90);
      }
      uint64_t v91 = *(std::__shared_weak_count **)(a1 + 240);
      *(void *)(a1 + 232) = 0;
      *(void *)(a1 + 240) = 0;
      if (v91) {
        sub_10004D2C8(v91);
      }
      CFDictionaryRef v92 = (std::mutex *)Registry::getServiceMap(v88, *v29);
      uint64_t v93 = v92;
      uint64_t v94 = "8UStorage";
      if ((uint64_t)"8UStorage" < 0)
      {
        BOOL v95 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v96 = 5381;
        do
        {
          uint64_t v94 = (const char *)v96;
          unsigned int v97 = *v95++;
          uint64_t v96 = (33 * v96) ^ v97;
        }
        while (v97);
      }
      std::mutex::lock(v92);
      *(void *)std::string buf = v94;
      long long v98 = sub_10004D37C(&v93[1].__m_.__sig, (unint64_t *)buf);
      if (v98)
      {
        uint64_t v100 = (os_unfair_lock_s *)v98[3];
        long long v99 = (std::__shared_weak_count *)v98[4];
        if (v99)
        {
          atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v93);
          atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v99);
          char v101 = 0;
          goto LABEL_95;
        }
      }
      else
      {
        uint64_t v100 = 0;
      }
      std::mutex::unlock(v93);
      long long v99 = 0;
      char v101 = 1;
LABEL_95:
      sub_1000832B0(v100, @"ProposedConfig", @"SatMsg", 0, 2u);
      if ((v101 & 1) == 0) {
        sub_10004D2C8(v99);
      }
      BOOL v103 = (std::mutex *)Registry::getServiceMap(v102, *v29);
      uint64_t v104 = v103;
      if ((uint64_t)"8UStorage" < 0)
      {
        long long v105 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v106 = 5381;
        do
        {
          uint64_t v33 = (const char *)v106;
          unsigned int v107 = *v105++;
          uint64_t v106 = (33 * v106) ^ v107;
        }
        while (v107);
      }
      std::mutex::lock(v103);
      *(void *)std::string buf = v33;
      uint64_t v108 = sub_10004D37C(&v104[1].__m_.__sig, (unint64_t *)buf);
      if (v108)
      {
        uint64_t v110 = (os_unfair_lock_s *)v108[3];
        unsigned int v109 = (std::__shared_weak_count *)v108[4];
        if (v109)
        {
          atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v104);
          atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v109);
          char v111 = 0;
          goto LABEL_105;
        }
      }
      else
      {
        uint64_t v110 = 0;
      }
      std::mutex::unlock(v104);
      unsigned int v109 = 0;
      char v111 = 1;
LABEL_105:
      sub_100E6E180(buf, *(void *)(a1 + 216), 0);
      sub_1000825C4(v110, @"SettledConfig", *(const void **)buf, @"SatMsg", 0, 2u, 0, 0);
      sub_100057D78((const void **)buf);
      if ((v111 & 1) == 0) {
        sub_10004D2C8(v109);
      }
      uint64_t v112 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v113 = **(void **)(a1 + 216);
        if (!*(unsigned char *)(a1 + 208)) {
          goto LABEL_112;
        }
        int v114 = *(_DWORD *)(a1 + 204);
        std::string::size_type v115 = "???";
        if (v114 == 1) {
          std::string::size_type v115 = "b1";
        }
        if (!v114) {
LABEL_112:
        }
          std::string::size_type v115 = "b0";
        *(_DWORD *)std::string buf = 138412546;
        *(void *)&uint8_t buf[4] = v113;
        __int16 v119 = 2080;
        long long v120 = v115;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I new Settled config is %@, bucket %s", buf, 0x16u);
      }
      sub_100E67FAC(a1);
      sub_100E67890(a1);
    }
    uint64_t v72 = (uint64_t *)*(unsigned __int8 *)(v71 + 16);
    if (!v72)
    {
LABEL_80:
      sub_100E670C0(*(void *)(a1 + 216), (Registry **)(a1 + 48), v72);
      goto LABEL_81;
    }
    CFUUIDRef v73 = CFUUIDCreate(0);
    uint64_t v74 = *(void *)(a1 + 280);
    *(void *)(a1 + 280) = v73;
    *(void *)std::string buf = v74;
    sub_10012577C((const void **)buf);
    uint64_t v75 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v77 = *(void *)(a1 + 280);
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v77;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I previous configuration was used so need to make one more push to server to wipe old config. Clean push ID: %@", buf, 0xCu);
    }
    long long v78 = (std::mutex *)Registry::getServiceMap(v76, *v29);
    uint64_t v79 = v78;
    xpc_object_t v80 = "8UStorage";
    if ((uint64_t)"8UStorage" < 0)
    {
      __int16 v81 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v82 = 5381;
      do
      {
        xpc_object_t v80 = (const char *)v82;
        unsigned int v83 = *v81++;
        uint64_t v82 = (33 * v82) ^ v83;
      }
      while (v83);
    }
    std::mutex::lock(v78);
    *(void *)std::string buf = v80;
    unsigned __int8 v84 = sub_10004D37C(&v79[1].__m_.__sig, (unint64_t *)buf);
    if (v84)
    {
      uint64_t v86 = (os_unfair_lock_s *)v84[3];
      CFMutableArrayRef v85 = (std::__shared_weak_count *)v84[4];
      if (v85)
      {
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v79);
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v85);
        char v87 = 0;
        goto LABEL_78;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    std::mutex::unlock(v79);
    CFMutableArrayRef v85 = 0;
    char v87 = 1;
LABEL_78:
    sub_100E6EBA8((const void **)buf, *(const __CFUUID **)(a1 + 280));
    sub_1000825C4(v86, @"need-clean-push", *(const void **)buf, @"SatMsg", 0, 2u, 0, 0);
    sub_1000558F4((const void **)buf);
    if ((v87 & 1) == 0) {
      sub_10004D2C8(v85);
    }
    goto LABEL_80;
  }
  uint64_t v15 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = 0;
  *(void *)std::string buf = v15;
  sub_10012577C((const void **)buf);
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(a1 + 48));
  int v18 = v17;
  BOOL v19 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    int v20 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      BOOL v19 = (const char *)v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  *(void *)std::string buf = v19;
  CFUUIDRef v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    CFMutableArrayRef v25 = (os_unfair_lock_s *)v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    CFMutableArrayRef v25 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_31:
  sub_1000832B0(v25, @"need-clean-push", @"SatMsg", 0, 2u);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  uint64_t v45 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = a3;
    __int16 v119 = 2112;
    long long v120 = a4;
    uint64_t v10 = "#I clean config push succeed, cfg_id:%@, sps:%@";
    CFStringRef v11 = v45;
LABEL_35:
    uint32_t v12 = 22;
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
  }
}

void sub_100E75C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100E75CD0(uint64_t a1, BOOL a2)
{
  char v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v47 = 136315138;
    *(void *)&v47[4] = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I reprovisionSatelliteMsg, wipeAll:%s", v47, 0xCu);
  }
  uint64_t v6 = *(uint64_t **)(a1 + 232);
  if (v6)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *v6;
      *(_DWORD *)int v47 = 138412290;
      *(void *)&v47[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I removing proposed config:%@", v47, 0xCu);
      uint64_t v6 = *(uint64_t **)(a1 + 232);
    }
    sub_100E670C0((uint64_t)v6, (Registry **)(a1 + 48), v8);
    CFStringRef v11 = *(std::__shared_weak_count **)(a1 + 240);
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    if (v11) {
      sub_10004D2C8(v11);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 48));
    CFStringRef v13 = ServiceMap;
    BOOL v14 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        BOOL v14 = (const char *)v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int v47 = v14;
    int v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v47);
    if (v18)
    {
      int v20 = (os_unfair_lock_s *)v18[3];
      BOOL v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      int v20 = 0;
    }
    std::mutex::unlock(v13);
    BOOL v19 = 0;
    char v21 = 1;
LABEL_16:
    sub_1000832B0(v20, @"ProposedConfig", @"SatMsg", 0, 2u);
    if ((v21 & 1) == 0) {
      sub_10004D2C8(v19);
    }
  }
  if (!a2) {
    goto LABEL_36;
  }
  unsigned int v22 = *(uint64_t **)(a1 + 216);
  if (v22)
  {
    CFUUIDRef v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = *v22;
      *(_DWORD *)int v47 = 138412290;
      *(void *)&v47[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I removing settled config:%@", v47, 0xCu);
      unsigned int v22 = *(uint64_t **)(a1 + 216);
    }
    sub_100E670C0((uint64_t)v22, (Registry **)(a1 + 48), v24);
  }
  char v26 = *(std::__shared_weak_count **)(a1 + 224);
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  if (v26) {
    sub_10004D2C8(v26);
  }
  CFNumberRef v27 = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 48));
  uint64_t v28 = v27;
  CFMutableDictionaryRef v29 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    unsigned int v30 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      CFMutableDictionaryRef v29 = (const char *)v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  *(void *)int v47 = v29;
  uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)v47);
  if (!v33)
  {
    CFMutableArrayRef v35 = 0;
    goto LABEL_32;
  }
  CFMutableArrayRef v35 = (os_unfair_lock_s *)v33[3];
  uint64_t v34 = (std::__shared_weak_count *)v33[4];
  if (!v34)
  {
LABEL_32:
    std::mutex::unlock(v28);
    uint64_t v34 = 0;
    char v36 = 1;
    goto LABEL_33;
  }
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v28);
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v34);
  char v36 = 0;
LABEL_33:
  sub_1000832B0(v35, @"SettledConfig", @"SatMsg", 0, 2u);
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  sub_100E7331C((void *)a1);
LABEL_36:
  if (!*(void *)(a1 + 216)) {
    goto LABEL_47;
  }
  *(unsigned char *)(a1 + 272) = 1;
  unsigned int v37 = (std::mutex *)Registry::getServiceMap((uint64_t *)1, *(Registry **)(a1 + 48));
  uint64_t v38 = v37;
  int v39 = "8UStorage";
  if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
  {
    CFTypeRef v40 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = 5381;
    do
    {
      int v39 = (const char *)v41;
      unsigned int v42 = *v40++;
      uint64_t v41 = (33 * v41) ^ v42;
    }
    while (v42);
  }
  std::mutex::lock(v37);
  *(void *)int v47 = v39;
  CFMutableArrayRef v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)v47);
  if (v43)
  {
    uint64_t v45 = (os_unfair_lock_s *)v43[3];
    uint64_t v44 = (std::__shared_weak_count *)v43[4];
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v38);
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v44);
      char v46 = 0;
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v45 = 0;
  }
  std::mutex::unlock(v38);
  uint64_t v44 = 0;
  char v46 = 1;
LABEL_45:
  sub_1000825C4(v45, @"need-reprovisioning", kCFBooleanTrue, @"SatMsg", 0, 2u, 0, 0);
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v44);
  }
LABEL_47:
  sub_100E6822C(a1);
}

void sub_100E760EC(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E76134(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E76214(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I  |--- Satellite messaging provisioning:", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 160)) {
      uint64_t v3 = "";
    }
    else {
      uint64_t v3 = " -";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I  | fCurrentState:%s", buf, 0xCu);
  }
  char v4 = *(void **)(a1 + 160);
  if (v4)
  {
    uint64_t v7 = (void *)*v4;
    uint64_t v5 = v4 + 1;
    uint64_t v6 = v7;
    if (v7 != v5)
    {
      do
      {
        CFMutableDictionaryRef v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = (const char *)v6[4];
          uint64_t v10 = *((unsigned __int8 *)v6 + 55);
          int v11 = (char)v10;
          if ((v10 & 0x80u) != 0) {
            uint64_t v10 = v6[5];
          }
          if (v11 >= 0) {
            uint64_t v9 = (const char *)(v6 + 4);
          }
          if (v10) {
            uint32_t v12 = v9;
          }
          else {
            uint32_t v12 = "<invalid>";
          }
          uint64_t v13 = *(void *)(a1 + 160);
          BOOL v14 = sub_100046F68(v13 + 24, (void **)v6 + 4);
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v15 = " UNSUPPORTED";
          if ((void **)(v13 + 32) == v14) {
            uint64_t v15 = "";
          }
          *(void *)&uint8_t buf[4] = v12;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v15;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I  |  [%s]:%s", buf, 0x16u);
        }
        uint64_t v16 = v6[7];
        uint64_t v54 = 0;
        sub_100E646AC(&v55, v16, &v54);
        *(void *)std::string buf = off_101A64E58;
        *(void *)&uint8_t buf[8] = a1;
        char v58 = buf;
        logger::CFTypeRefLogger();
        sub_10012C330(buf);
        sub_10005717C(&v55);
        sub_10005717C(&v54);
        unsigned int v17 = (void *)v6[1];
        if (v17)
        {
          do
          {
            int v18 = v17;
            unsigned int v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            int v18 = (void *)v6[2];
            BOOL v19 = *v18 == (void)v6;
            uint64_t v6 = v18;
          }
          while (!v19);
        }
        uint64_t v6 = v18;
      }
      while (v18 != v5);
    }
  }
  int v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = asStringBool(*(unsigned char *)(a1 + 200));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I  | fLastReportedProvisioningState: %s", buf, 0xCu);
    int v20 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I  | fSettled:", buf, 2u);
  }
  uint64_t v22 = *(void *)(a1 + 216);
  if (v22) {
    sub_100E6E180(&v55, *(void *)(a1 + 216), 1);
  }
  *(void *)std::string buf = off_101A64ED8;
  *(void *)&uint8_t buf[8] = a1;
  char v58 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  if (v22) {
    sub_100057D78(&v55);
  }
  CFUUIDRef v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I  | fProposed:", buf, 2u);
  }
  uint64_t v24 = *(void *)(a1 + 232);
  if (v24) {
    sub_100E6E180(&v53, *(void *)(a1 + 232), 1);
  }
  *(void *)std::string buf = off_101A64F58;
  *(void *)&uint8_t buf[8] = a1;
  char v58 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  if (v24) {
    sub_100057D78(&v53);
  }
  uint64_t v25 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I  | fUpcoming:", buf, 2u);
  }
  uint64_t v26 = *(void *)(a1 + 248);
  if (v26) {
    sub_100E6E180(&v52, *(void *)(a1 + 248), 1);
  }
  *(void *)std::string buf = off_101A64FD8;
  *(void *)&uint8_t buf[8] = a1;
  char v58 = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  if (v26) {
    sub_100057D78(&v52);
  }
  CFNumberRef v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 208))
    {
      int v28 = *(_DWORD *)(a1 + 204);
      CFMutableDictionaryRef v29 = "???";
      if (v28 == 1) {
        CFMutableDictionaryRef v29 = "b1";
      }
      if (v28) {
        unsigned int v30 = v29;
      }
      else {
        unsigned int v30 = "b0";
      }
    }
    else
    {
      unsigned int v30 = "-";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | settled bucket: %s", buf, 0xCu);
    CFNumberRef v27 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 264)) {
      uint64_t v31 = "";
    }
    else {
      uint64_t v31 = "not ";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v31;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | fProposingBackoffTimer: %sengaged", buf, 0xCu);
    CFNumberRef v27 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = asStringBool(*(unsigned char *)(a1 + 272));
    uint64_t v33 = *(void *)(a1 + 280);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v33;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | fReprovisioningRequested: %s, fCleanPushUUID: %@", buf, 0x16u);
    CFNumberRef v27 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 312)) {
      uint64_t v34 = "";
    }
    else {
      uint64_t v34 = "NOT ";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | certificate check %sscheduled", buf, 0xCu);
    CFNumberRef v27 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v35 = asStringBool(*(unsigned char *)(a1 + 152));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | fHaveInternet: %s", buf, 0xCu);
    CFNumberRef v27 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = *(void *)(a1 + 192);
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v36;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I  | Models: %zu", buf, 0xCu);
  }
  unsigned int v37 = *(void **)(a1 + 176);
  if (v37 != (void *)(a1 + 184))
  {
    do
    {
      uint64_t v38 = v37[7];
      int v39 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v38);
        uint64_t v41 = (const char *)(v38 + 16);
        if (*(char *)(v38 + 39) < 0) {
          uint64_t v41 = *(const char **)v41;
        }
        unsigned int v42 = (void *)(v38 + 40);
        if (*(char *)(v38 + 63) < 0) {
          unsigned int v42 = (void *)*v42;
        }
        CFMutableArrayRef v43 = (void *)(v38 + 64);
        if (*(char *)(v38 + 87) < 0) {
          CFMutableArrayRef v43 = (void *)*v43;
        }
        *(_DWORD *)std::string buf = 136316162;
        *(void *)&uint8_t buf[4] = v40;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v57 = 2080;
        char v58 = v41;
        __int16 v59 = 2080;
        *(void *)CFMutableDictionaryRef v60 = v42;
        *(_WORD *)&v60[8] = 2080;
        *(void *)&v60[10] = v43;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s |  fImsi '%s', fMcc '%s', fMnc '%s'", buf, 0x34u);
        int v39 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v38);
        if (*(void *)(v38 + 88)) {
          uint64_t v45 = "";
        }
        else {
          uint64_t v45 = "not ";
        }
        int v46 = *(_DWORD *)(v38 + 104);
        uint64_t v47 = asStringBool(*(unsigned char *)(v38 + 108));
        *(_DWORD *)std::string buf = 136316162;
        *(void *)&uint8_t buf[4] = v44;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v57 = 2080;
        char v58 = v45;
        __int16 v59 = 1024;
        *(_DWORD *)CFMutableDictionaryRef v60 = v46;
        *(_WORD *)&v60[4] = 2080;
        *(void *)&v60[6] = v47;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s |  fIWFKeyFetchRequest %sissued, fFetchFailures %u, fServerIssueDetected: %s", buf, 0x30u);
        int v39 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v48 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v38);
        uint64_t v49 = "";
        if (!*(void *)(v38 + 112)) {
          uint64_t v49 = "not ";
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v48;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v57 = 2080;
        char v58 = v49;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s |  fRequestBackoffTimer %sactive", buf, 0x20u);
      }
      char v50 = (void *)v37[1];
      if (v50)
      {
        do
        {
          uint64_t v51 = v50;
          char v50 = (void *)*v50;
        }
        while (v50);
      }
      else
      {
        do
        {
          uint64_t v51 = (void *)v37[2];
          BOOL v19 = *v51 == (void)v37;
          unsigned int v37 = v51;
        }
        while (!v19);
      }
      unsigned int v37 = v51;
    }
    while (v51 != (void *)(a1 + 184));
  }
}

void sub_100E76B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, const void *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_10012C330((uint64_t *)va1);
  if (v5) {
    sub_100057D78((const void **)va);
  }
  _Unwind_Resume(a1);
}

void sub_100E76BB4(uint64_t a1, const void *a2, uint64_t a3)
{
  xpc_object_t object = 0;
  valuePtr[0] = a2;
  valuePtr[1] = "contacts";
  sub_100048BAC((uint64_t)valuePtr, &object);
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_null)
  {
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v7 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      valuePtr[0] = v7;
      sub_10005717C(valuePtr);
    }
    uint64_t v8 = *(void *)(a1 + 216);
    if (v8)
    {
      uint64_t v9 = theDict;
      uint64_t v10 = *(const void **)(v8 + 8);
      CFMutableArrayRef theArray = 0;
      valuePtr[0] = v10;
      uint64_t v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, valuePtr);
      if (v11)
      {
        CFMutableArrayRef v12 = theArray;
        CFMutableArrayRef theArray = v11;
        valuePtr[0] = v12;
        sub_1000570E8(valuePtr);
      }
      long long value = theArray;
      CFMutableArrayRef theArray = 0;
      sub_1000570E8((const void **)&theArray);
      CFDictionarySetValue(v9, @"created_at", value);
      sub_1000570E8((const void **)&value);
      CFMutableArrayRef theArray = 0;
      uint64_t v13 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v13)
      {
        CFMutableArrayRef v14 = theArray;
        CFMutableArrayRef theArray = v13;
        valuePtr[0] = v14;
        sub_1000440D4(valuePtr);
      }
      uint64_t v15 = *(void *)(a1 + 216);
      uint64_t v16 = *(void *)(v15 + 48);
      if (v16 != v15 + 56)
      {
        unsigned int v17 = *(const void ****)(*(void *)(v16 + 56) + 64);
        if (v17)
        {
          int v18 = *v17;
          BOOL v19 = v17[1];
          while (v18 != v19)
            CFArrayAppendValue(theArray, *v18++);
        }
      }
      CFDictionarySetValue(theDict, @"contacts", theArray);
      sub_1000440D4((const void **)&theArray);
    }
    sub_100058DB0(valuePtr, "");
    sub_100C04F1C(a3, (uint64_t)valuePtr, (uint64_t)theDict);
    if (v21 < 0) {
      operator delete((void *)valuePtr[0]);
    }
    sub_10005717C((const void **)&theDict);
  }
  xpc_release(object);
  if (type == (xpc_type_t)&_xpc_type_null)
  {
    sub_100058DB0(valuePtr, "sat-msg-provisioning: no subcommand detected");
    sub_100C04F1C(a3, (uint64_t)valuePtr, 0);
    if (v21 < 0) {
      operator delete((void *)valuePtr[0]);
    }
  }
}

void sub_100E76DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E76E74(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X2>, char **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v11 = a1 + 32;
  do
  {
    int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      CFMutableArrayRef v14 = (uint64_t *)v8;
    }
    else {
      CFMutableArrayRef v14 = (uint64_t *)(v8 + 8);
    }
    if (!v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }
  while (*v14);
  if (v11 == a1 + 32 || *(_DWORD *)(v11 + 32) > a2)
  {
LABEL_11:
    uint64_t v15 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      *(_DWORD *)a5 = 1;
      *(void *)(a5 + 8) = 0;
      *(void *)(a5 + 16) = 0;
      return;
    }
    char v50 = "s1";
    if (!a2) {
      char v50 = "s0";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v50;
    uint64_t v49 = "encrypt_msg for SatMsg_SubscriptionID %s - missing";
    uint64_t v51 = v15;
LABEL_69:
    _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, v49, buf, 0xCu);
    goto LABEL_12;
  }
  uint64_t v16 = (const char *)(v11 + 40);
  unsigned int v17 = sub_100046F68(a1 + 120, (void **)(v11 + 40));
  if ((void **)(a1 + 128) == v17)
  {
    uint64_t v44 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v45 = *(unsigned __int8 *)(v11 + 63);
    BOOL v46 = (v45 & 0x80u) != 0;
    if ((v45 & 0x80u) != 0) {
      uint64_t v45 = *(void *)(v11 + 48);
    }
    if (v46) {
      uint64_t v47 = *(const char **)(v11 + 40);
    }
    else {
      uint64_t v47 = (const char *)(v11 + 40);
    }
    if (v45) {
      uint64_t v48 = v47;
    }
    else {
      uint64_t v48 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v48;
    uint64_t v49 = "encrypt_msg for '%s' - missing keys";
    goto LABEL_80;
  }
  int v18 = v17;
  BOOL v19 = sub_100046F68(a1 + 48, (void **)(v11 + 40));
  if ((void **)(a1 + 56) == v19)
  {
    uint64_t v44 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v52 = *(unsigned __int8 *)(v11 + 63);
    BOOL v53 = (v52 & 0x80u) != 0;
    if ((v52 & 0x80u) != 0) {
      uint64_t v52 = *(void *)(v11 + 48);
    }
    if (v53) {
      uint64_t v54 = *(const char **)(v11 + 40);
    }
    else {
      uint64_t v54 = (const char *)(v11 + 40);
    }
    if (v52) {
      uint64_t v55 = v54;
    }
    else {
      uint64_t v55 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v55;
    uint64_t v49 = "encrypt_msg for '%s' - missing cfg";
LABEL_80:
    uint64_t v51 = v44;
    goto LABEL_69;
  }
  int v20 = v19;
  CFNumberRef v70 = (std::mutex *)v18[7];
  std::mutex::lock(v70);
  memset(buf, 0, 24);
  ctu::cf::assign();
  CFNumberRef v69 = v20;
  char v21 = (char *)operator new(0x30uLL);
  *((void *)v21 + 1) = 0;
  uint64_t v68 = (atomic_ullong *)(v21 + 8);
  *((void *)v21 + 2) = 0;
  *(void *)char v21 = off_1019B47B8;
  *(_OWORD *)(v21 + 24) = 0u;
  *((void *)v21 + 5) = 0;
  int v76 = v21 + 24;
  uint64_t v77 = v21;
  int v71 = *((unsigned __int16 *)v18[7] + 80);
  uint64_t v22 = (os_log_t *)(a1 + 96);
  CFUUIDRef v23 = *(NSObject **)(a1 + 96);
  uint64_t v72 = (os_log_t *)(a1 + 96);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    char v64 = v21;
    char v66 = v18;
    uint64_t v24 = *(unsigned __int8 *)(v11 + 63);
    uint64_t v26 = *(const char **)(v11 + 40);
    uint64_t v25 = *(void *)(v11 + 48);
    ctu::hex();
    if ((v24 & 0x80u) == 0) {
      uint64_t v27 = v24;
    }
    else {
      uint64_t v27 = v25;
    }
    if ((v24 & 0x80u) == 0) {
      int v28 = (const char *)(v11 + 40);
    }
    else {
      int v28 = v26;
    }
    if (!v27) {
      int v28 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v28;
    CFMutableDictionaryRef v29 = (void **)&v86;
    if (v88 < 0) {
      CFMutableDictionaryRef v29 = v86;
    }
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v71;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I this MO for %s: idx:%hu, %s", buf, 0x1Cu);
    if (SHIBYTE(v88) < 0) {
      operator delete(v86);
    }
    char v21 = v64;
    int v18 = v66;
    uint64_t v22 = (os_log_t *)(a1 + 96);
  }
  CFUUIDRef v73 = 0;
  long long __dst = 0;
  sub_100E79248(&v73, v22, (uint64_t *)&v76, 1, "com.Midway.security.crypto.Mario.MOStepRatchetDiversifierForChainKey");
  if (v73)
  {
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    long long __p = 0;
    sub_10005C928(&__p, *(const void **)v73, *((void *)v73 + 1), *((void *)v73 + 1) - *(void *)v73);
    char v87 = 0;
    uint64_t v88 = 0;
    uint64_t v86 = 0;
    sub_10005C928(&v86, __p, (uint64_t)v82, v82 - (unsigned char *)__p);
    CFMutableArrayRef v85 = 0;
    memset(buf, 0, 24);
    sub_10005C928(buf, v86, (uint64_t)v87, (char *)v87 - (char *)v86);
    *(void *)BOOL v90 = 0;
    if (ctu::cf::convert_copy())
    {
      unsigned int v30 = v85;
      CFMutableArrayRef v85 = *(const void ***)v90;
      uint64_t v79 = v30;
      sub_100030068((const void **)&v79);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    uint64_t v31 = v85;
    unsigned __int8 v84 = v85;
    CFMutableArrayRef v85 = 0;
    sub_100030068((const void **)&v85);
    if (v86)
    {
      char v87 = v86;
      operator delete(v86);
    }
    uint64_t v32 = (const void **)((char *)v18[7] + 152);
    if (v32 != (const void **)&v84)
    {
      *(void *)std::string buf = *v32;
      *uint64_t v32 = v31;
      unsigned __int8 v84 = 0;
      sub_100030068((const void **)buf);
    }
    sub_100030068((const void **)&v84);
    if (__p)
    {
      uint64_t v82 = __p;
      operator delete(__p);
    }
    uint64_t v33 = v18[7];
    ++v33[80];
    sub_100E7359C(*(Registry **)(a1 + 104), v11 + 40, *(const __CFUUID **)(a1 + 8), @"mo-key", (void *)v33 + 19, (uint64_t *)v33);
    uint64_t v22 = (os_log_t *)(a1 + 96);
    uint64_t v34 = *v72;
    if (os_log_type_enabled(*v72, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = *(unsigned __int8 *)(v11 + 63);
      uint64_t v36 = v18;
      uint64_t v39 = v11 + 40;
      uint64_t v38 = *(const char **)(v11 + 40);
      uint64_t v37 = *(void *)(v39 + 8);
      char v67 = v36;
      int v65 = *((unsigned __int16 *)v36[7] + 80);
      ctu::hex();
      if ((v35 & 0x80u) == 0) {
        uint64_t v40 = v35;
      }
      else {
        uint64_t v40 = v37;
      }
      if ((v35 & 0x80u) == 0) {
        uint64_t v41 = v16;
      }
      else {
        uint64_t v41 = v38;
      }
      if (v40) {
        unsigned int v42 = v41;
      }
      else {
        unsigned int v42 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v42;
      CFMutableArrayRef v43 = (void **)&v86;
      if (v88 < 0) {
        CFMutableArrayRef v43 = v86;
      }
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v65;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v43;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I next MO key for %s will be: idx:%hu, %s", buf, 0x1Cu);
      if (SHIBYTE(v88) < 0) {
        operator delete(v86);
      }
      int v18 = v67;
      uint64_t v22 = v72;
    }
  }
  else
  {
    char v56 = *v22;
    if (os_log_type_enabled(*v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "failed to roll MO", buf, 2u);
    }
  }
  atomic_fetch_add_explicit(v68, 1uLL, memory_order_relaxed);
  if (__dst) {
    sub_10004D2C8((std::__shared_weak_count *)__dst);
  }
  sub_10004D2C8((std::__shared_weak_count *)v21);
  std::mutex::unlock(v70);
  uint64_t v86 = 0;
  char v87 = 0;
  uint64_t v88 = 0;
  sub_100E63F30((unint64_t *)&v86, (uint64_t)"com.Midway.security.crypto.Mario.MOStepRatchetDiversifierForMessageKey", 70);
  uint64_t v79 = 0;
  xpc_object_t v80 = 0;
  sub_100BCB70C(v22, 0x30uLL, &v79);
  if (v79 && (unint64_t)((unsigned char *)v79[1] - (unsigned char *)*v79) >= 0x30)
  {
    long long __p = 0;
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    sub_10036CCEC(&__p, *v79, (uint64_t)*v79 + 32, 0x20uLL);
    int v76 = 0;
    uint64_t v77 = 0;
    uint64_t v78 = 0;
    sub_10036CCEC(&v76, (char *)*v79 + 32, (uint64_t)*v79 + 48, 0x10uLL);
    CFUUIDRef v73 = 0;
    long long __dst = 0;
    uint64_t v75 = 0;
    sub_1005F003C((unint64_t *)&v73, SBYTE1(v71));
    sub_1005F003C((unint64_t *)&v73, v71);
    sub_100E6408C((unint64_t *)&v73, *((CFDataRef *)v69[7] + 11));
    sub_100E6408C((unint64_t *)&v73, *((CFDataRef *)v18[7] + 8));
    sub_100E64054((unint64_t *)&v73, (uint64_t)v69[7]);
    sub_10005C748((uint64_t)&v73, (char *)__dst, *a4, a4[1], a4[1] - *a4);
    memset(buf, 0, sizeof(buf));
    sub_100BCB15C(v22, a3, &v76, 8uLL, (uint64_t)buf);
    if (*(void *)buf && *(void *)&buf[16])
    {
      __int16 v57 = (char *)operator new(0x50uLL);
      *((void *)v57 + 1) = 0;
      *((void *)v57 + 2) = 0;
      *(void *)__int16 v57 = off_101A65058;
      *(_OWORD *)(v57 + 24) = 0u;
      char v58 = (unsigned __int16 *)(v57 + 24);
      *(_OWORD *)(v57 + 40) = 0u;
      *(_OWORD *)(v57 + 56) = 0u;
      *((void *)v57 + 9) = 0;
      *((_WORD *)v57 + 12) = v71;
      v57[26] = sub_100E79124(v72, *((const __CFData **)v69[7] + 11));
      v57[27] = sub_100E79124(v72, *((const __CFData **)v18[7] + 8));
      sub_10005C9A4((uint64_t)(v57 + 32), *(__n128 **)buf);
      sub_10005C9A4((uint64_t)(v57 + 56), *(__n128 **)&buf[16]);
      __int16 v59 = *v72;
      if (os_log_type_enabled(*v72, OS_LOG_TYPE_DEFAULT))
      {
        int v60 = *v58;
        *(_DWORD *)BOOL v90 = 67109120;
        *(_DWORD *)&v90[4] = v60;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I message %hu encrypted", v90, 8u);
      }
      int v61 = 0;
    }
    else
    {
      unsigned int v63 = *v22;
      if (os_log_type_enabled(*v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)BOOL v90 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "failed to encrypt msg", v90, 2u);
      }
      __int16 v57 = 0;
      char v58 = 0;
      int v61 = 1;
    }
    sub_10025B9C0((uint64_t)buf);
    if (v73)
    {
      long long __dst = v73;
      operator delete(v73);
    }
    if (v76)
    {
      uint64_t v77 = v76;
      operator delete(v76);
    }
    if (__p)
    {
      uint64_t v82 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v62 = *v22;
    if (os_log_type_enabled(*v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "failed to expand msg key/iv", buf, 2u);
    }
    __int16 v57 = 0;
    char v58 = 0;
    int v61 = 1;
  }
  if (v80) {
    sub_10004D2C8(v80);
  }
  if (v86)
  {
    char v87 = v86;
    operator delete(v86);
  }
  sub_10004D2C8((std::__shared_weak_count *)v21);
  *(_DWORD *)a5 = v61;
  *(void *)(a5 + 8) = v58;
  *(void *)(a5 + 16) = v57;
  if (v57)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v57 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v57);
  }
}

void sub_100E777CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, uint64_t a15, uint64_t a16, long long a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  sub_10025B9C0(v31 - 144);
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a25) {
    sub_10004D2C8(a25);
  }
  uint64_t v33 = *(void **)(v31 - 168);
  if (v33)
  {
    *(void *)(v31 - 160) = v33;
    operator delete(v33);
  }
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

void sub_100E77954(uint64_t a1@<X0>, int a2@<W1>, unsigned __int16 *a3@<X2>, char **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v11 = a1 + 32;
  do
  {
    int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      CFMutableArrayRef v14 = (uint64_t *)v8;
    }
    else {
      CFMutableArrayRef v14 = (uint64_t *)(v8 + 8);
    }
    if (!v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }
  while (*v14);
  if (v11 == a1 + 32 || *(_DWORD *)(v11 + 32) > a2)
  {
LABEL_11:
    uint64_t v15 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      *(_DWORD *)a5 = 1;
      *(void *)(a5 + 8) = 0;
      *(void *)(a5 + 16) = 0;
      return;
    }
    uint64_t v34 = "s1";
    if (!a2) {
      uint64_t v34 = "s0";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    uint64_t v33 = "decrypt_msg for SatMsg_SubscriptionID %s - missing";
    uint64_t v35 = v15;
LABEL_34:
    _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v33, buf, 0xCu);
    goto LABEL_12;
  }
  uint64_t v16 = v11 + 40;
  unsigned int v17 = sub_100046F68(a1 + 120, (void **)(v11 + 40));
  if ((void **)(a1 + 128) == v17)
  {
    int v28 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v29 = *(unsigned __int8 *)(v11 + 63);
    BOOL v30 = (v29 & 0x80u) != 0;
    if ((v29 & 0x80u) != 0) {
      uint64_t v29 = *(void *)(v11 + 48);
    }
    if (v30) {
      uint64_t v31 = *(const char **)(v11 + 40);
    }
    else {
      uint64_t v31 = (const char *)(v11 + 40);
    }
    if (v29) {
      uint64_t v32 = v31;
    }
    else {
      uint64_t v32 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v32;
    uint64_t v33 = "decrypt_msg for '%s' - missing keys";
    goto LABEL_45;
  }
  int v18 = v17;
  BOOL v19 = sub_100046F68(a1 + 48, (void **)(v11 + 40));
  if ((void **)(a1 + 56) == v19)
  {
    int v28 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v36 = *(unsigned __int8 *)(v11 + 63);
    BOOL v37 = (v36 & 0x80u) != 0;
    if ((v36 & 0x80u) != 0) {
      uint64_t v36 = *(void *)(v11 + 48);
    }
    if (v37) {
      uint64_t v38 = *(const char **)(v11 + 40);
    }
    else {
      uint64_t v38 = (const char *)(v11 + 40);
    }
    if (v36) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v39;
    uint64_t v33 = "decrypt_msg for '%s' - missing cfg";
LABEL_45:
    uint64_t v35 = v28;
    goto LABEL_34;
  }
  uint64_t v100 = v19;
  int v20 = *a3;
  char v21 = (std::mutex *)v18[7];
  std::mutex::lock(v21);
  uint64_t v22 = (unsigned __int16 *)v18[7];
  int v23 = v22[48];
  int v102 = v20;
  unsigned __int16 v24 = v20 - v23;
  if ((v24 & 0x8000) != 0)
  {
    char v101 = v21;
    if (*((void *)v22 + 15)) {
      uint64_t v40 = sub_10008324C;
    }
    else {
      uint64_t v40 = 0;
    }
    if (v40)
    {
      long long v105 = v18;
      int v41 = v22[64];
      log = *(NSObject **)(a1 + 96);
      BOOL v42 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
      if ((((_WORD)v102 - (_WORD)v41) & 0x8000) != 0)
      {
        if (v42)
        {
          *(_DWORD *)std::string buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v102;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v23;
          *(_WORD *)&buf[14] = 1024;
          LODWORD(v124[0]) = (unsigned __int16)-v24;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#E requested MT ratchet counter is too far behind, %hu while at %hu - gap %hu - failing", buf, 0x14u);
        }
        int v27 = 2;
        goto LABEL_107;
      }
      unsigned __int16 v43 = v102 - v41;
      if (v42)
      {
        *(_DWORD *)std::string buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = v102;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v23;
        *(_WORD *)&buf[14] = 1024;
        LODWORD(v124[0]) = v41;
        WORD2(v124[0]) = 1024;
        *(_DWORD *)((char *)v124 + 6) = (unsigned __int16)(v102 - v41);
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I calculating MT key %hu from recovery. Current:%hu, Recovery:%hu, steps:%hu", buf, 0x1Au);
      }
      memset(buf, 0, sizeof(buf));
      v124[0] = 0;
      ctu::cf::assign();
      long long v103 = *(_OWORD *)buf;
      uint64_t v44 = v124[0];
      uint64_t v45 = (char *)operator new(0x30uLL);
      *((void *)v45 + 1) = 0;
      *((void *)v45 + 2) = 0;
      *(void *)uint64_t v45 = off_1019B47B8;
      *(_OWORD *)(v45 + 24) = v103;
      *((void *)v45 + 5) = v44;
      long long __p = v45 + 24;
      CFNumberRef v117 = v45;
      sub_100E79248(buf, (os_log_t *)(a1 + 96), (uint64_t *)&__p, v43, "com.Midway.security.crypto.Mario.MTStepRatchetDiversifierForChainKey");
      uint64_t v47 = *(void *)buf;
      BOOL v46 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)buf) {
        goto LABEL_125;
      }
      uint64_t v48 = *(NSObject **)(a1 + 96);
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        goto LABEL_127;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v49 = "MT roll_key (recovery) failed!!!";
LABEL_164:
      _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, v49, buf, 2u);
      goto LABEL_127;
    }
    uint64_t v51 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      int v27 = 2;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#E MT recovery key is not yet set, requested MT is behind initial point - failing", buf, 2u);
    }
    else
    {
      int v27 = 2;
    }
    char v21 = v101;
    goto LABEL_107;
  }
  long long v105 = v18;
  if (v24 >= 0x3E9u)
  {
    uint64_t v25 = v21;
    uint64_t v26 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v102;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v23;
      *(_WORD *)&buf[14] = 1024;
      LODWORD(v124[0]) = v24;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#E requested MT ratchet counter is too far ahead %hu while at %hu - gap %hu - failing", buf, 0x14u);
    }
    int v27 = 2;
    char v21 = v25;
    goto LABEL_107;
  }
  char v101 = v21;
  if (v24 >= 0xFu)
  {
    if (*((void *)v22 + 15)) {
      char v50 = sub_10008324C;
    }
    else {
      char v50 = 0;
    }
    if (!v50)
    {
      *(void *)std::string buf = 0;
      uint64_t v52 = sub_10002FD9C((const void **)buf, (const void **)v22 + 11);
      uint64_t v53 = *((void *)v22 + 15);
      *((void *)v22 + 15) = *(void *)buf;
      *(void *)std::string buf = v53;
      sub_100030068(v52);
      v22[64] = v22[48];
      sub_100E7359C(*(Registry **)(a1 + 104), v16, *(const __CFUUID **)(a1 + 8), @"mt-recovery-key", (void *)v18[7] + 15, (uint64_t *)v18[7]);
      uint64_t v22 = (unsigned __int16 *)v18[7];
    }
    unsigned __int16 v54 = v24 - 5;
    uint64_t v55 = *(NSObject **)(a1 + 96);
    os_log_t loga = (os_log_t *)(a1 + 96);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      int v56 = v22[48];
      unsigned __int16 v57 = v24 - 5;
      *(_DWORD *)std::string buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v54;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v56;
      *(_WORD *)&buf[14] = 1024;
      LODWORD(v124[0]) = (unsigned __int16)(v56 + v54);
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I shifting MT key by %hu. %hu -> %hu", buf, 0x14u);
    }
    else
    {
      unsigned __int16 v57 = v24 - 5;
    }
    memset(buf, 0, sizeof(buf));
    v124[0] = 0;
    ctu::cf::assign();
    long long v96 = *(_OWORD *)buf;
    uint64_t v58 = v124[0];
    __int16 v59 = (char *)operator new(0x30uLL);
    unsigned __int16 v60 = v57;
    *((void *)v59 + 1) = 0;
    *((void *)v59 + 2) = 0;
    *(void *)__int16 v59 = off_1019B47B8;
    *(_OWORD *)(v59 + 24) = v96;
    *((void *)v59 + 5) = v58;
    uint64_t v113 = v59 + 24;
    int v114 = (std::__shared_weak_count *)v59;
    *(void *)uint64_t v121 = 0;
    CFIndex v122 = 0;
    sub_100E79248(v121, loga, (uint64_t *)&v113, v57, "com.Midway.security.crypto.Mario.MTStepRatchetDiversifierForChainKey");
    int v61 = *(const void ***)v121;
    if (*(void *)v121)
    {
      uint64_t v110 = 0;
      uint64_t v111 = 0;
      unsigned int v109 = 0;
      sub_10005C928(&v109, **(const void ***)v121, *(void *)(*(void *)v121 + 8), *(void *)(*(void *)v121 + 8) - **(void **)v121);
      CFNumberRef v117 = 0;
      uint64_t v118 = 0;
      long long __p = 0;
      sub_10005C928(&__p, v109, (uint64_t)v110, v110 - (unsigned char *)v109);
      std::string::size_type v115 = 0;
      memset(buf, 0, sizeof(buf));
      v124[0] = 0;
      sub_10005C928(buf, __p, (uint64_t)v117, v117 - (unsigned char *)__p);
      __int16 v119 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v62 = v115;
        std::string::size_type v115 = v119;
        long long v120 = v62;
        sub_100030068(&v120);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      uint64_t v112 = v115;
      std::string::size_type v115 = 0;
      sub_100030068(&v115);
      if (__p)
      {
        CFNumberRef v117 = __p;
        operator delete(__p);
      }
      unsigned int v63 = (const void **)((char *)v105[7] + 88);
      if (v63 != &v112)
      {
        *(void *)std::string buf = *v63;
        NSObject *v63 = v112;
        uint64_t v112 = 0;
        sub_100030068((const void **)buf);
      }
      sub_100030068(&v112);
      if (v109)
      {
        uint64_t v110 = v109;
        operator delete(v109);
      }
      char v64 = v105[7];
      v64[48] += v57;
      sub_100E7359C(*(Registry **)(a1 + 104), v16, *(const __CFUUID **)(a1 + 8), @"mt-key", (void *)v64 + 11, (uint64_t *)v64);
    }
    else
    {
      int v65 = *loga;
      if (os_log_type_enabled(*loga, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v60;
        _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "shifting MT ratchet key by %hu, roll_key failed!!!", buf, 8u);
      }
    }
    if (v122) {
      sub_10004D2C8(v122);
    }
    sub_10004D2C8((std::__shared_weak_count *)v59);
    if (v61)
    {
      uint64_t v22 = (unsigned __int16 *)v105[7];
      unsigned __int16 v66 = v22[48] - 1000;
      int v67 = v22[64];
      int v97 = (__int16)(v66 - v67);
      if (v97 < 1)
      {
LABEL_121:
        unsigned __int16 v24 = 5;
        goto LABEL_122;
      }
      uint64_t v68 = *loga;
      if (os_log_type_enabled(*loga, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = (unsigned __int16)v97;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v67;
        *(_WORD *)&buf[14] = 1024;
        LODWORD(v124[0]) = v66;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I shifting recovery MT key by %hu. %hu -> %hu", buf, 0x14u);
      }
      memset(buf, 0, sizeof(buf));
      v124[0] = 0;
      ctu::cf::assign();
      long long v95 = *(_OWORD *)buf;
      uint64_t v69 = v124[0];
      CFNumberRef v70 = (char *)operator new(0x30uLL);
      *((void *)v70 + 1) = 0;
      *((void *)v70 + 2) = 0;
      *(void *)CFNumberRef v70 = off_1019B47B8;
      *(_OWORD *)(v70 + 24) = v95;
      *((void *)v70 + 5) = v69;
      uint64_t v113 = v70 + 24;
      int v114 = (std::__shared_weak_count *)v70;
      *(void *)uint64_t v121 = 0;
      CFIndex v122 = 0;
      sub_100E79248(v121, loga, (uint64_t *)&v113, (unsigned __int16)(v66 - v67), "com.Midway.security.crypto.Mario.MTStepRatchetDiversifierForChainKey");
      int v71 = *(const void ***)v121;
      if (*(void *)v121)
      {
        long long __dst = 0;
        uint64_t v108 = 0;
        uint64_t v106 = 0;
        sub_10005C928(&v106, **(const void ***)v121, *(void *)(*(void *)v121 + 8), *(void *)(*(void *)v121 + 8) - **(void **)v121);
        CFNumberRef v117 = 0;
        uint64_t v118 = 0;
        long long __p = 0;
        sub_10005C928(&__p, v106, (uint64_t)__dst, (unsigned char *)__dst - (unsigned char *)v106);
        std::string::size_type v115 = 0;
        memset(buf, 0, sizeof(buf));
        v124[0] = 0;
        sub_10005C928(buf, __p, (uint64_t)v117, v117 - (unsigned char *)__p);
        __int16 v119 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v72 = v115;
          std::string::size_type v115 = v119;
          long long v120 = v72;
          sub_100030068(&v120);
        }
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        uint64_t v112 = v115;
        std::string::size_type v115 = 0;
        sub_100030068(&v115);
        if (__p)
        {
          CFNumberRef v117 = __p;
          operator delete(__p);
        }
        CFUUIDRef v73 = (const void **)((char *)v105[7] + 120);
        if (v73 != &v112)
        {
          *(void *)std::string buf = *v73;
          *CFUUIDRef v73 = v112;
          uint64_t v112 = 0;
          sub_100030068((const void **)buf);
        }
        sub_100030068(&v112);
        if (v106)
        {
          long long __dst = v106;
          operator delete(v106);
        }
        uint64_t v74 = v105[7];
        v74[64] += v97;
        sub_100E7359C(*(Registry **)(a1 + 104), v16, *(const __CFUUID **)(a1 + 8), @"mt-recovery-key", (void *)v74 + 15, (uint64_t *)v74);
      }
      else
      {
        uint64_t v79 = *loga;
        if (os_log_type_enabled(*loga, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = (unsigned __int16)(v66 - v67);
          _os_log_error_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "shifting MT recovery key by %hu, roll_key failed!!!", buf, 8u);
        }
      }
      if (v122) {
        sub_10004D2C8(v122);
      }
      sub_10004D2C8((std::__shared_weak_count *)v70);
      if (v71)
      {
        uint64_t v22 = (unsigned __int16 *)v105[7];
        goto LABEL_121;
      }
    }
    int v27 = 1;
    char v21 = v101;
LABEL_107:
    std::mutex::unlock(v21);
    BOOL v46 = 0;
LABEL_108:
    uint64_t v75 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      int v76 = *a3;
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v76;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v27;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#E failed to get MT key for ratchet counter %hu. Status code: %d", buf, 0xEu);
    }
    uint64_t v77 = 0;
    uint64_t v78 = 0;
    goto LABEL_111;
  }
LABEL_122:
  xpc_object_t v80 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
  {
    int v81 = v22[48];
    int v82 = v22[64];
    *(_DWORD *)std::string buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v102;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v81;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v124[0]) = v82;
    WORD2(v124[0]) = 1024;
    *(_DWORD *)((char *)v124 + 6) = v24;
    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I calculating MT key %hu from current. Current:%hu, Recovery:%hu, steps:%hu", buf, 0x1Au);
  }
  memset(buf, 0, sizeof(buf));
  v124[0] = 0;
  ctu::cf::assign();
  long long v104 = *(_OWORD *)buf;
  uint64_t v83 = v124[0];
  uint64_t v45 = (char *)operator new(0x30uLL);
  *((void *)v45 + 1) = 0;
  *((void *)v45 + 2) = 0;
  *(void *)uint64_t v45 = off_1019B47B8;
  *(_OWORD *)(v45 + 24) = v104;
  *((void *)v45 + 5) = v83;
  long long __p = v45 + 24;
  CFNumberRef v117 = v45;
  sub_100E79248(buf, (os_log_t *)(a1 + 96), (uint64_t *)&__p, v24, "com.Midway.security.crypto.Mario.MTStepRatchetDiversifierForChainKey");
  uint64_t v47 = *(void *)buf;
  BOOL v46 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)buf)
  {
LABEL_125:
    int v27 = 0;
    goto LABEL_128;
  }
  uint64_t v48 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v49 = "MT roll_key failed!!!";
    goto LABEL_164;
  }
LABEL_127:
  int v27 = 1;
LABEL_128:
  sub_10004D2C8((std::__shared_weak_count *)v45);
  if (v46)
  {
    atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v46);
  }
  std::mutex::unlock(v101);
  if (!v47) {
    goto LABEL_108;
  }
  unsigned __int8 v84 = (NSObject **)(a1 + 96);
  int v85 = sub_100E79124((NSObject **)(a1 + 96), *((const __CFData **)v100[7] + 11));
  int v86 = *((unsigned __int8 *)a3 + 2);
  if (v86 == v85)
  {
    int v87 = sub_100E79124(v84, *((const __CFData **)v105[7] + 8));
    int v88 = *((unsigned __int8 *)a3 + 3);
    if (v88 == v87)
    {
      memset(buf, 0, sizeof(buf));
      v124[0] = 0;
      sub_100E63F30((unint64_t *)buf, (uint64_t)"com.Midway.security.crypto.Mario.MTStepRatchetDiversifierForMessageKey", 70);
      uint64_t v113 = 0;
      int v114 = 0;
      sub_100BCB70C(v84, 0x30uLL, &v113);
      if (v113 && *((void *)v113 + 1) - *(void *)v113 > 0x2FuLL)
      {
        long long __p = 0;
        CFNumberRef v117 = 0;
        uint64_t v118 = 0;
        sub_10036CCEC(&__p, *(const void **)v113, *(void *)v113 + 32, 0x20uLL);
        unsigned int v109 = 0;
        uint64_t v110 = 0;
        uint64_t v111 = 0;
        sub_10036CCEC(&v109, (const void *)(*(void *)v113 + 32), *(void *)v113 + 48, 0x10uLL);
        uint64_t v106 = 0;
        long long __dst = 0;
        uint64_t v108 = 0;
        sub_1005F003C((unint64_t *)&v106, *((unsigned char *)a3 + 1));
        sub_1005F003C((unint64_t *)&v106, *(unsigned char *)a3);
        sub_100E6408C((unint64_t *)&v106, *((CFDataRef *)v100[7] + 11));
        sub_100E6408C((unint64_t *)&v106, *((CFDataRef *)v105[7] + 8));
        sub_100E64054((unint64_t *)&v106, (uint64_t)v100[7]);
        sub_10005C748((uint64_t)&v106, (char *)__dst, *a4, a4[1], a4[1] - *a4);
        sub_100BCB3D8(v84, (void *)a3 + 1, v121);
        uint64_t v78 = *(const void ***)v121;
        uint64_t v77 = v122;
        CFDictionaryRef v92 = *v84;
        BOOL v93 = os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT);
        if (v78)
        {
          if (v93)
          {
            int v94 = *a3;
            *(_DWORD *)uint64_t v121 = 67109120;
            *(_DWORD *)&v121[4] = v94;
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I message %hu decrypted", v121, 8u);
          }
          int v27 = 0;
        }
        else
        {
          if (v93)
          {
            *(_WORD *)uint64_t v121 = 0;
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I decryption failed", v121, 2u);
          }
          int v27 = 1;
        }
        if (v106)
        {
          long long __dst = v106;
          operator delete(v106);
        }
        if (v109)
        {
          uint64_t v110 = v109;
          operator delete(v109);
        }
        if (__p)
        {
          CFNumberRef v117 = __p;
          operator delete(__p);
        }
      }
      else
      {
        uint64_t v89 = *v84;
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p) = 0;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#E unable to expand MT key", (uint8_t *)&__p, 2u);
        }
        uint64_t v77 = 0;
        uint64_t v78 = 0;
        int v27 = 1;
      }
      if (v114) {
        sub_10004D2C8(v114);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      goto LABEL_111;
    }
    BOOL v90 = *v84;
    if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_145;
    }
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v87;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v88;
    uint64_t v91 = "#E UE pub key digest mismatch: mine 0x%2X vs remote 0x%2X";
    goto LABEL_144;
  }
  BOOL v90 = *v84;
  if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v85;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v86;
    uint64_t v91 = "#E IWF pub key digest mismatch: mine 0x%2X vs remote 0x%2X";
LABEL_144:
    _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, v91, buf, 0xEu);
  }
LABEL_145:
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  int v27 = 1;
LABEL_111:
  if (v46) {
    sub_10004D2C8(v46);
  }
  *(_DWORD *)a5 = v27;
  *(void *)(a5 + 8) = v78;
  *(void *)(a5 + 16) = v77;
  if (v77)
  {
    atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v77);
  }
}

void sub_100E789E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, long long a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, long long a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,char a27,void *a28,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a28) {
    operator delete(a28);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  uint64_t v32 = *(void **)(v30 - 144);
  if (v32)
  {
    *(void *)(v30 - 136) = v32;
    operator delete(v32);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E78BC0(uint64_t a1@<X0>, int a2@<W1>, char **a3@<X2>, char **a4@<X3>, void *a5@<X8>)
{
  uint64_t v8 = *(void *)(a1 + 32);
  *a5 = 0;
  a5[1] = 0;
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v11 = a1 + 32;
  do
  {
    int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      CFMutableArrayRef v14 = (uint64_t *)v8;
    }
    else {
      CFMutableArrayRef v14 = (uint64_t *)(v8 + 8);
    }
    if (!v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }
  while (*v14);
  if (v11 == a1 + 32 || *(_DWORD *)(v11 + 32) > a2)
  {
LABEL_11:
    uint64_t v15 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v30 = "s1";
    if (!a2) {
      uint64_t v30 = "s0";
    }
    LODWORD(v50) = 136315138;
    *(void *)((char *)&v50 + 4) = v30;
    uint64_t v29 = "aka_hmac_tag for SatMsg_SubscriptionID %s - missing";
LABEL_38:
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&v50, 0xCu);
    return;
  }
  uint64_t v16 = sub_100046F68(a1 + 120, (void **)(v11 + 40));
  if ((void **)(a1 + 128) == v16)
  {
    uint64_t v15 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = *(unsigned __int8 *)(v11 + 63);
      BOOL v26 = (v25 & 0x80u) != 0;
      if ((v25 & 0x80u) != 0) {
        uint64_t v25 = *(void *)(v11 + 48);
      }
      if (v26) {
        int v27 = *(const char **)(v11 + 40);
      }
      else {
        int v27 = (const char *)(v11 + 40);
      }
      if (v25) {
        int v28 = v27;
      }
      else {
        int v28 = "<invalid>";
      }
      LODWORD(v50) = 136315138;
      *(void *)((char *)&v50 + 4) = v28;
      uint64_t v29 = "aka_hmac_tag for '%s' - missing keys";
      goto LABEL_38;
    }
  }
  else
  {
    unsigned int v17 = v16;
    int v18 = sub_100046F68(a1 + 48, (void **)(v11 + 40));
    if ((void **)(a1 + 56) == v18)
    {
      uint64_t v15 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v31 = *(unsigned __int8 *)(v11 + 63);
        BOOL v32 = (v31 & 0x80u) != 0;
        if ((v31 & 0x80u) != 0) {
          uint64_t v31 = *(void *)(v11 + 48);
        }
        if (v32) {
          uint64_t v33 = *(const char **)(v11 + 40);
        }
        else {
          uint64_t v33 = (const char *)(v11 + 40);
        }
        if (v31) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = "<invalid>";
        }
        LODWORD(v50) = 136315138;
        *(void *)((char *)&v50 + 4) = v34;
        uint64_t v29 = "aka_hmac_tag for '%s' - missing cfg";
        goto LABEL_38;
      }
    }
    else
    {
      BOOL v19 = v18;
      long long v50 = 0uLL;
      uint64_t v51 = 0;
      sub_10005C748((uint64_t)&v50, 0, *a3, a3[1], a3[1] - *a3);
      sub_10005C748((uint64_t)&v50, *((char **)&v50 + 1), *a4, a4[1], a4[1] - *a4);
      sub_100E6408C((unint64_t *)&v50, *((CFDataRef *)v17[7] + 23));
      uint64_t v45 = 0;
      BOOL v46 = 0;
      uint64_t v47 = 0;
      sub_100E63F30((unint64_t *)&v45, (uint64_t)"com.Midway.security.crypto.Mario.HMACLinkToAKAKey", 49);
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      int v20 = (os_log_t *)(a1 + 96);
      sub_100BCB554(v20, 0x20uLL, &v43);
      if (v43)
      {
        *(void *)uint64_t v40 = 0;
        int v41 = 0;
        uint64_t v42 = 0;
        sub_100E6408C((unint64_t *)v40, *((CFDataRef *)v19[7] + 11));
        sub_100E6408C((unint64_t *)v40, *((CFDataRef *)v17[7] + 8));
        sub_100E63F30((unint64_t *)v40, (uint64_t)"Mario", 5);
        sub_100E64054((unint64_t *)v40, (uint64_t)v19[7]);
        sub_100E64054((unint64_t *)v40, (uint64_t)v19[7] + 32);
        char v21 = (char *)operator new(0x30uLL);
        *((void *)v21 + 1) = 0;
        *((void *)v21 + 2) = 0;
        *(void *)char v21 = off_1019B47B8;
        *((void *)v21 + 3) = 0;
        *((void *)v21 + 4) = 0;
        *((void *)v21 + 5) = 0;
        v39[0] = off_1019D84C8;
        v39[1] = v20;
        if (sub_1004DCFBC(v39, *(void **)v43, (const void *)(*(void *)(v43 + 8) - *(void *)v43), *(void **)v40, &v41[-*(void *)v40], (unint64_t *)v21 + 3))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v21 + 1, 1uLL, memory_order_relaxed);
          uint64_t v22 = (std::__shared_weak_count *)a5[1];
          *a5 = v21 + 24;
          a5[1] = v21;
          if (v22) {
            sub_10004D2C8(v22);
          }
          int v23 = *v20;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            ctu::hex();
            unsigned __int16 v24 = v38 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v49 = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I aka_hmac_tag calculated: %s", buf, 0xCu);
            if (v38 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        else
        {
          uint64_t v36 = *v20;
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "failed to sha256Algo.computeHmac", (uint8_t *)__p, 2u);
          }
        }
        sub_10004D2C8((std::__shared_weak_count *)v21);
        if (*(void *)v40)
        {
          int v41 = *(char **)v40;
          operator delete(*(void **)v40);
        }
      }
      else
      {
        uint64_t v35 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v40 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "failed to derive akaHMACLinkedKey key", v40, 2u);
        }
      }
      if (v44) {
        sub_10004D2C8(v44);
      }
      if (v45)
      {
        BOOL v46 = v45;
        operator delete(v45);
      }
      if ((void)v50)
      {
        *((void *)&v50 + 1) = v50;
        operator delete((void *)v50);
      }
    }
  }
}

void sub_100E790A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21)
{
  sub_10004D2C8(v22);
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a20) {
    operator delete(a20);
  }
  uint64_t v25 = *(void **)(v23 - 112);
  if (v25)
  {
    *(void *)(v23 - 104) = v25;
    operator delete(v25);
  }
  BOOL v26 = *(std::__shared_weak_count **)(v21 + 8);
  if (v26) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E79124(NSObject **a1, const __CFData *a2)
{
  data = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  sub_100E6408C((unint64_t *)&data, a2);
  sub_100E63F30((unint64_t *)&data, (uint64_t)"com.Midway.security.crypto.Mario.publicKeyHashHintDiversifier", 61);
  md = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10008E4E8(&md, 0x20uLL);
  if (CC_SHA256(data, (int)v12 - (int)data, md))
  {
    uint64_t v3 = md;
    uint64_t v4 = *md;
LABEL_6:
    uint64_t v9 = v3;
    operator delete(v3);
    goto LABEL_7;
  }
  uint64_t v5 = *a1;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFMutableDictionaryRef v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CC_SHA256 failed!", v7, 2u);
  }
  uint64_t v3 = md;
  uint64_t v4 = 255;
  if (md) {
    goto LABEL_6;
  }
LABEL_7:
  if (data)
  {
    int v12 = data;
    operator delete(data);
  }
  return v4;
}

void sub_100E79210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E79248(void *a1, os_log_t *a2, uint64_t *a3, uint64_t a4, char *__s)
{
  long long __p = 0;
  unsigned int v17 = 0;
  uint64_t v18 = 0;
  size_t v10 = strlen(__s);
  sub_100E63F30((unint64_t *)&__p, (uint64_t)__s, v10);
  uint64_t v11 = *a3;
  int v12 = (std::__shared_weak_count *)a3[1];
  *a1 = v11;
  a1[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  for (; a4; --a4)
  {
    if (!v11) {
      break;
    }
    sub_100BCB70C(a2, 0x20uLL, &v14);
    uint64_t v11 = v14;
    uint64_t v13 = v15;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    *a1 = v11;
    a1[1] = v13;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    int v12 = v13;
  }
  if (__p)
  {
    unsigned int v17 = __p;
    operator delete(__p);
  }
}

void sub_100E79328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E79358(uint64_t a1)
{
  *(void *)a1 = off_101A64160;
  sub_1001FEC70(*(void **)(a1 + 128));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 96));

  return sub_100E64C7C(a1);
}

void sub_100E793C4(uint64_t a1)
{
  *(void *)a1 = off_101A64160;
  sub_1001FEC70(*(void **)(a1 + 128));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 96));
  sub_100E64C7C(a1);

  operator delete();
}

uint64_t sub_100E79444(uint64_t a1, uint64_t a2)
{
  return sub_100E75138(*(void *)(a2 + 24), 0, 0);
}

uint64_t sub_100E7947C()
{
  return 0;
}

uint64_t sub_100E79484()
{
  return 0;
}

void sub_100E7948C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void sub_100E7949C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100058DB0(__p, "unsupported device");
  sub_100C04F1C(a3, (uint64_t)__p, 0);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100E794F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E79514(void ***a1)
{
  char v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    char v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

const void **sub_100E7959C(void *a1, uint64_t a2)
{
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v9 = v5;
    sub_10005717C((const void **)&v9);
  }
  if (*(void *)a2) {
    uint64_t v6 = sub_10008324C;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    CFDictionarySetValue(theDict, *(const void **)(a2 + 16), *(const void **)a2);
    CFDictionarySetValue(theDict, *(const void **)(a2 + 24), +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a2 + 8)]);
  }
  sub_100062708(a1, theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_100E79674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void *sub_100E79688(void *a1, char *a2, char *a3)
{
  CFMutableDictionaryRef v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100E796C0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E796DC(void *a1, char *a2, char *a3)
{
  CFMutableDictionaryRef v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100E79714(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E79730(void *a1, char *a2, char *a3)
{
  CFMutableDictionaryRef v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100E79768(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100E79784(const void **result, const void **a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (const void **)*result;
  if (*result != a2)
  {
    CFMutableDictionaryRef v5 = *v4;
    *uint64_t v4 = 0;
    int v12 = v5;
    *uint64_t v4 = *a2;
    *a2 = 0;
    uint64_t result = sub_1000558F4(&v12);
  }
  uint64_t v6 = a2 + 1;
  CFMutableDictionaryRef v7 = (const void **)v3[1];
  if (v7 != a2 + 1)
  {
    uint64_t v8 = *v7;
    const void *v7 = 0;
    int v12 = v8;
    const void *v7 = *v6;
    *uint64_t v6 = 0;
    uint64_t result = sub_1000558F4(&v12);
  }
  CFMutableDictionaryRef v9 = a2 + 2;
  size_t v10 = (const void **)v3[2];
  if (v10 != a2 + 2)
  {
    uint64_t v11 = *v10;
    const void *v10 = 0;
    int v12 = v11;
    const void *v10 = *v9;
    *CFMutableDictionaryRef v9 = 0;
    return sub_100044D00(&v12);
  }
  return result;
}

const void **sub_100E7983C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_100E79870(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A642C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E79890(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A642C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E798E4(uint64_t a1)
{
  sub_100044D00((const void **)(a1 + 136));
  sub_1000558F4((const void **)(a1 + 128));
  sub_1000558F4((const void **)(a1 + 120));
  sub_100030068((const void **)(a1 + 112));
  sub_1000558F4((const void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    operator delete(v3);
  }
}

void sub_100E79984(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  CFMutableDictionaryRef v5 = (char *)a1[1];
  CFMutableDictionaryRef v7 = (char **)(a1 + 1);
  uint64_t v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  CFMutableDictionaryRef v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (char **)v5;
      size_t v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      CFMutableDictionaryRef v5 = *v8;
      CFMutableDictionaryRef v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    CFMutableDictionaryRef v7 = v8 + 1;
    CFMutableDictionaryRef v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  if (!*v7)
  {
LABEL_10:
    uint64_t v15 = 0;
    uint64_t v11 = (char *)operator new(0x48uLL);
    v14[0] = v11;
    v14[1] = v6;
    int v12 = v11 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)int v12 = *(_OWORD *)a3;
      *((void *)v11 + 6) = *(void *)(a3 + 16);
    }
    *(_OWORD *)(v11 + 56) = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    LOBYTE(v15) = 1;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    const void *v7 = v11;
    uint64_t v13 = (uint64_t *)**a1;
    if (v13)
    {
      *a1 = v13;
      uint64_t v11 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v14[0] = 0;
    sub_1001FEBC4((uint64_t)v14);
  }
}

void sub_100E79ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100E79AE0(uint64_t a1)
{
  sub_10026D080(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10026D080((char *)v2);
  }
  return a1;
}

void sub_100E79B34(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E79B6C(uint64_t a1)
{
}

uint64_t sub_100E79B88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E79BCC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t *sub_100E79BF8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFMutableDictionaryRef v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I initialized", buf, 2u);
  }
  sub_1000E3958(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100E79C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1000E3958(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100E79CC8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A64378;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E79CE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A64378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E79D3C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 24))();
}

void *sub_100E79D64(void *a1)
{
  *a1 = off_101A643C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E79DB0(void *a1)
{
  *a1 = off_101A643C8;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100E79E1C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A643C8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E79E80(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A643C8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E79EC0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E79ED0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E79F10(uint64_t *a1, xpc_object_t *a2)
{
  sub_10039A458(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    CFMutableDictionaryRef v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3]) {
        sub_100E6CD40(v4);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100E79F8C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E79FA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E79FE0()
{
}

void *sub_100E79FEC(void *a1)
{
  *a1 = off_101A64448;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E7A038(void *a1)
{
  *a1 = off_101A64448;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100E7A0A4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A64448;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E7A108(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A64448;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E7A148(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E7A158(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E7A198(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    CFMutableDictionaryRef v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3]) {
        sub_100E6D378(v4);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100E7A214(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E7A228(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7A268()
{
}

void sub_100E7A274(const __CFUUID ***a1, Registry **a2, const __CFDictionary *a3, os_log_t *a4)
{
  uint64_t v6 = (char *)operator new(0x90uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)uint64_t v6 = off_101A644C8;
  *((void *)v6 + 3) = 0;
  char v64 = (const __CFUUID **)(v6 + 24);
  *((void *)v6 + 7) = 0;
  v6[40] = 0;
  *((void *)v6 + 6) = v6 + 56;
  *((void *)v6 + 8) = 0;
  *((void *)v6 + 10) = 0;
  *((void *)v6 + 9) = v6 + 80;
  *((void *)v6 + 11) = 0;
  *((void *)v6 + 13) = 0;
  *((void *)v6 + 12) = v6 + 104;
  *((void *)v6 + 14) = 0;
  *((void *)v6 + 15) = 0;
  __int16 v59 = (void **)(v6 + 120);
  *((void *)v6 + 16) = 0;
  *((void *)v6 + 17) = 0;
  if (a3)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, @"ver");
    CFStringRef cf = Value;
    if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFStringGetTypeID()))
    {
      sub_100E67834((const void **)__p, cf);
      *(void *)std::string buf = *v64;
      _WORD *v64 = (const __CFUUID *)__p[0];
      __p[0] = 0;
      sub_10012577C((const void **)buf);
      sub_10012577C((const void **)__p);
      char v58 = 0;
    }
    else
    {
      CFStringRef cf = 0;
      char v58 = 1;
    }
    if (*v64 ? sub_100136254 : 0)
    {
      size_t v10 = (uint64_t *)CFDictionaryGetValue(a3, @"ts");
      int v12 = v10;
      if (v10)
      {
        CFTypeID v13 = CFGetTypeID(v10);
        if (v13 == CFNumberGetTypeID()) {
          uint64_t v14 = v12;
        }
        else {
          uint64_t v14 = 0;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      *(void *)std::string buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v14, v11);
      *((void *)v6 + 4) = *(void *)buf;
      v6[40] = CFDictionaryGetValue(a3, @"dirty") != 0;
      CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(a3, @"sims");
      CFArrayRef v16 = v15;
      if (v15)
      {
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount(v16);
          if (Count)
          {
            for (CFIndex i = 0; Count != i; ++i)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, i);
              CFDictionaryRef v21 = ValueAtIndex;
              if (ValueAtIndex && (CFTypeID v22 = CFGetTypeID(ValueAtIndex), v22 == CFDictionaryGetTypeID()))
              {
                uint64_t v23 = CFDictionaryGetValue(v21, @"iccid");
                unsigned __int16 v24 = v23;
                if (v23)
                {
                  CFTypeID v25 = CFGetTypeID(v23);
                  if (v25 == CFStringGetTypeID()) {
                    BOOL v26 = v24;
                  }
                  else {
                    BOOL v26 = 0;
                  }
                }
                else
                {
                  BOOL v26 = 0;
                }
                uint64_t v30 = CFDictionaryGetValue(v21, @"name");
                uint64_t v31 = v30;
                if (v30)
                {
                  CFTypeID v32 = CFGetTypeID(v30);
                  if (v32 != CFStringGetTypeID()) {
                    uint64_t v31 = 0;
                  }
                }
                CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v21, @"sim-cfg");
                CFDictionaryRef v34 = v33;
                if (v33)
                {
                  CFTypeID v35 = CFGetTypeID(v33);
                  if (v35 == CFDictionaryGetTypeID() && v26 && v31)
                  {
                    __p[0] = 0;
                    __p[1] = 0;
                    uint64_t v68 = 0;
                    memset(buf, 0, sizeof(buf));
                    ctu::cf::assign();
                    uint64_t v36 = *(void **)buf;
                    LODWORD(v70) = *(_DWORD *)&buf[16];
                    *(_DWORD *)((char *)&v70 + 3) = *(_DWORD *)&buf[19];
                    if ((char)buf[23] < 0)
                    {
                      sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
                      operator delete(v36);
                    }
                    else
                    {
                      __p[0] = *(void **)buf;
                      __p[1] = *(void **)&buf[8];
                      LODWORD(v68) = v70;
                      *(_DWORD *)((char *)&v68 + 3) = *(_DWORD *)((char *)&v70 + 3);
                      HIBYTE(v68) = buf[23];
                    }
                    if (CFEqual(v31, @"A"))
                    {
                      int v38 = 0;
                      goto LABEL_47;
                    }
                    if (CFEqual(v31, @"B"))
                    {
                      int v38 = 1;
LABEL_47:
                      uint64_t v39 = (std::__shared_weak_count *)operator new(0x90uLL);
                      v39->__shared_owners_ = 0;
                      v39->__shared_weak_owners_ = 0;
                      v39->__vftable = (std::__shared_weak_count_vtbl *)off_101A642C8;
                      sub_100E640E8((uint64_t)&v39[1], v34);
                      *(_DWORD *)std::string buf = v38;
                      if (SHIBYTE(v68) < 0)
                      {
                        sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
                        int v38 = *(_DWORD *)buf;
                      }
                      else
                      {
                        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
                        uint64_t v72 = v68;
                      }
                      sub_100E7AD30((uint64_t *)v6 + 6, v38, (uint64_t)buf);
                      if (SHIBYTE(v72) < 0) {
                        operator delete(*(void **)&buf[8]);
                      }
                      if (SHIBYTE(v68) < 0)
                      {
                        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
                      }
                      else
                      {
                        *(_OWORD *)std::string buf = *(_OWORD *)__p;
                        *(void *)&uint8_t buf[16] = v68;
                      }
                      uint64_t v72 = v39 + 1;
                      CFUUIDRef v73 = v39;
                      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
                      sub_100E79984((uint64_t **)v6 + 9, (void **)buf, (uint64_t)buf);
                      if (v73) {
                        sub_10004D2C8(v73);
                      }
                      if ((char)buf[23] < 0) {
                        operator delete(*(void **)buf);
                      }
                      CFUUIDRef v40 = *v64;
                      int v41 = (std::__shared_weak_count *)operator new(0xD8uLL);
                      v41->__shared_owners_ = 0;
                      v41->__shared_weak_owners_ = 0;
                      v41->__vftable = (std::__shared_weak_count_vtbl *)off_101A64518;
                      sub_100E7AFFC((uint64_t)&v41[1], a2, (uint64_t)__p, v40);
                      if (SHIBYTE(v68) < 0)
                      {
                        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
                      }
                      else
                      {
                        *(_OWORD *)std::string buf = *(_OWORD *)__p;
                        *(void *)&uint8_t buf[16] = v68;
                      }
                      uint64_t v72 = v41 + 1;
                      CFUUIDRef v73 = v41;
                      sub_100E7AE30((uint64_t **)v6 + 12, (void **)buf, (uint64_t)buf);
                      if (v73) {
                        sub_10004D2C8(v73);
                      }
                      if ((char)buf[23] < 0) {
                        operator delete(*(void **)buf);
                      }
                      sub_10004D2C8(v39);
                    }
                    else
                    {
                      uint64_t v42 = *a4;
                      if (os_log_type_enabled(*a4, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)std::string buf = 138412290;
                        *(void *)&uint8_t buf[4] = v31;
                        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#E fail to load configuration, incorrect subscription name: %@", buf, 0xCu);
                      }
                    }
                    if (SHIBYTE(v68) < 0) {
                      operator delete(__p[0]);
                    }
                    continue;
                  }
                }
                os_log_t v37 = *a4;
                if (os_log_type_enabled(*a4, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  int v28 = v37;
                  uint64_t v29 = "#E fail to load configuration, incomplete set of parameters";
                  goto LABEL_39;
                }
              }
              else
              {
                os_log_t v27 = *a4;
                if (os_log_type_enabled(*a4, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  int v28 = v27;
                  uint64_t v29 = "#E fail to load configuration, incorrect object type in array";
LABEL_39:
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 2u);
                }
              }
            }
          }
        }
      }
      if ((v58 & 1) == 0)
      {
        ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)a2, *a2);
        uint64_t v44 = ServiceMap;
        uint64_t v45 = "8UStorage";
        if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
        {
          BOOL v46 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v47 = 5381;
          do
          {
            uint64_t v45 = (const char *)v47;
            unsigned int v48 = *v46++;
            uint64_t v47 = (33 * v47) ^ v48;
          }
          while (v48);
        }
        std::mutex::lock(ServiceMap);
        *(void *)std::string buf = v45;
        uint64_t v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)buf);
        if (v49)
        {
          uint64_t v51 = (os_unfair_lock_s *)v49[3];
          long long v50 = (std::__shared_weak_count *)v49[4];
          if (v50)
          {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v44);
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v50);
            char v52 = 0;
LABEL_80:
            uint64_t v53 = operator new(8uLL);
            __p[0] = v53;
            void *v53 = cf;
            __p[1] = v53 + 1;
            uint64_t v68 = (std::__shared_weak_count *)(v53 + 1);
            sub_100083254(v51, @"offgridKey", @"SatMsg", (char **)__p, 4u, &v65);
            CFTypeRef v70 = v65;
            if (v65) {
              CFRetain(v65);
            }
            uint64_t v69 = 0;
            *(void *)std::string buf = 0;
            sub_1000C15D8(buf, &v70);
            if (*(void *)buf) {
              unsigned __int16 v54 = sub_10008324C;
            }
            else {
              unsigned __int16 v54 = 0;
            }
            if (v54) {
              sub_1003C5CD0(&v69, (const void **)buf);
            }
            sub_100030068((const void **)buf);
            unsigned __int16 v66 = v69;
            uint64_t v69 = 0;
            sub_100030068(&v69);
            sub_1000577C4(&v70);
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            long long v55 = *(_OWORD *)buf;
            uint64_t v56 = *(void *)&buf[16];
            unsigned __int16 v57 = *v59;
            if (*v59)
            {
              *((void *)v6 + 16) = v57;
              *(_OWORD *)cfa = v55;
              operator delete(v57);
              long long v55 = *(_OWORD *)cfa;
              *__int16 v59 = 0;
              *((void *)v6 + 16) = 0;
              *((void *)v6 + 17) = 0;
            }
            *(_OWORD *)(v6 + 120) = v55;
            *((void *)v6 + 17) = v56;
            sub_100030068(&v66);
            sub_1000577C4(&v65);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if ((v52 & 1) == 0) {
              sub_10004D2C8(v50);
            }
            goto LABEL_93;
          }
        }
        else
        {
          uint64_t v51 = 0;
        }
        std::mutex::unlock(v44);
        long long v50 = 0;
        char v52 = 1;
        goto LABEL_80;
      }
    }
  }
LABEL_93:
  *a1 = v64;
  a1[1] = (const __CFUUID **)v6;
}

void sub_100E7AAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,const void **a23,char a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  sub_10004D2C8(v36);
  sub_10004D2C8(v37);
  if (a34 < 0) {
    operator delete(__p);
  }
  uint64_t v39 = *a18;
  if (*a18)
  {
    *(void *)(v35 + 128) = v39;
    operator delete(v39);
  }
  sub_1001FEC70(*(void **)(v35 + 104));
  sub_1001FEC70(*(void **)(v35 + 80));
  sub_10026D080(*(char **)(v35 + 56));
  sub_10012577C(a23);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v35);
  operator delete(v40);
  _Unwind_Resume(a1);
}

void sub_100E7AC58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A644C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7AC78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A644C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_100E7ACCC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    *(void *)(a1 + 128) = v2;
    operator delete(v2);
  }
  sub_1001FEC70(*(void **)(a1 + 104));
  sub_1001FEC70(*(void **)(a1 + 80));
  sub_10026D080(*(char **)(a1 + 56));

  return sub_10012577C((const void **)(a1 + 24));
}

uint64_t *sub_100E7AD30(uint64_t *result, int a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t **)result;
  uint64_t v6 = (uint64_t **)(result + 1);
  CFMutableDictionaryRef v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        CFMutableDictionaryRef v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        CFMutableDictionaryRef v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      CFMutableDictionaryRef v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    CFMutableDictionaryRef v7 = (uint64_t **)(result + 1);
LABEL_9:
    CFMutableDictionaryRef v9 = (char *)operator new(0x40uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    size_t v10 = v9 + 40;
    if (*(char *)(a3 + 31) < 0)
    {
      sub_10004FC84(v10, *(void **)(a3 + 8), *(void *)(a3 + 16));
    }
    else
    {
      *(_OWORD *)size_t v10 = *(_OWORD *)(a3 + 8);
      *((void *)v9 + 7) = *(void *)(a3 + 24);
    }
    return sub_100046C38(v4, (uint64_t)v7, v6, (uint64_t *)v9);
  }
  return result;
}

void sub_100E7AE1C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100E7AE30(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v11 = 0;
  CFMutableDictionaryRef v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  if (!*v5)
  {
    uint64_t v6 = v5;
    uint64_t v10 = 0;
    CFMutableDictionaryRef v7 = (char *)operator new(0x48uLL);
    v9[0] = v7;
    v9[1] = a1 + 1;
    int v8 = v7 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v8, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)int v8 = *(_OWORD *)a3;
      *((void *)v7 + 6) = *(void *)(a3 + 16);
    }
    *(_OWORD *)(v7 + 56) = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    LOBYTE(v10) = 1;
    sub_100046C38(a1, v11, v6, (uint64_t *)v7);
    v9[0] = 0;
    sub_1001FEBC4((uint64_t)v9);
  }
}

void sub_100E7AF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100E7AF14(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A64518;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7AF34(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A64518;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E7AF88(const void **a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 3);
  sub_100030068(a1 + 26);
  sub_100030068(a1 + 22);
  sub_100030068(a1 + 18);
  sub_100030068(a1 + 14);
  sub_100030068(a1 + 13);
  sub_100030068(a1 + 12);
  sub_100030068(a1 + 11);

  std::mutex::~mutex(v2);
}

uint64_t sub_100E7AFFC(uint64_t a1, Registry **a2, uint64_t a3, const __CFUUID *a4)
{
  *(void *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 82) = 0u;
  *(void *)(a1 + 104) = @"key";
  *(void *)(a1 + 112) = @"counter";
  *(void *)(a1 + 120) = 0;
  CFTypeID v7 = a1 + 120;
  *(_WORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = @"key";
  *(void *)(a1 + 144) = @"counter";
  *(void *)(a1 + 152) = 0;
  CFTypeID v8 = a1 + 152;
  *(_WORD *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = @"key";
  *(void *)(a1 + 176) = @"counter";
  *(void *)(a1 + 184) = 0;
  CFMutableDictionaryRef v9 = (CFTypeRef *)(a1 + 184);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)@"key", *a2);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    CFTypeID v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  long long __p = (void *)v12;
  CFArrayRef v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&__p);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_8;
  }
  uint64_t v18 = v16[3];
  CFTypeID v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_8:
    std::mutex::unlock(v11);
    CFTypeID v17 = 0;
    char v19 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_9:
  uint64_t v44 = 0;
  sub_100E6EBA8(&v44, a4);
  if (v18)
  {
    int v20 = v44;
    if (v44 ? sub_1000810B8 : 0)
    {
      CFTypeID v22 = operator new(8uLL);
      long long __p = v22;
      *CFTypeID v22 = v20;
      CFUUIDRef v40 = v22 + 1;
      int v41 = v22 + 1;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&v42, v18, a3, @"ue-pub-key", @"SatMsg", &__p, 4);
      sub_1000C15D8(&v43, &v42);
      uint64_t v23 = (CFTypeRef *)(a1 + 64);
      if ((const void **)(a1 + 64) != &v43)
      {
        CFTypeRef cf = *v23;
        CFTypeRef *v23 = v43;
        uint64_t v43 = 0;
        sub_100030068(&cf);
      }
      sub_100030068(&v43);
      sub_1000577C4(&v42);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      unsigned __int16 v24 = v44;
      CFTypeID v25 = operator new(8uLL);
      long long __p = v25;
      void *v25 = v24;
      CFUUIDRef v40 = v25 + 1;
      int v41 = v25 + 1;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&v42, v18, a3, @"cred-key", @"SatMsg", &__p, 4);
      sub_1000C15D8(&v43, &v42);
      BOOL v26 = (CFTypeRef *)(a1 + 72);
      if ((const void **)(a1 + 72) != &v43)
      {
        CFTypeRef cf = *v26;
        CFTypeRef *v26 = v43;
        uint64_t v43 = 0;
        sub_100030068(&cf);
      }
      sub_100030068(&v43);
      sub_1000577C4(&v42);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      os_log_t v27 = v44;
      int v28 = operator new(8uLL);
      long long __p = v28;
      void *v28 = v27;
      CFUUIDRef v40 = v28 + 1;
      int v41 = v28 + 1;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&v42, v18, a3, @"msisdn-key", @"SatMsg", &__p, 4);
      sub_1000C15D8(&v43, &v42);
      uint64_t v29 = (CFTypeRef *)(a1 + 80);
      if ((const void **)(a1 + 80) != &v43)
      {
        CFTypeRef cf = *v29;
        CFTypeRef *v29 = v43;
        uint64_t v43 = 0;
        sub_100030068(&cf);
      }
      sub_100030068(&v43);
      sub_1000577C4(&v42);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      uint64_t v30 = v44;
      uint64_t v31 = operator new(8uLL);
      long long __p = v31;
      void *v31 = v30;
      CFUUIDRef v40 = v31 + 1;
      int v41 = v31 + 1;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&v42, v18, a3, @"hmac-link-key", @"SatMsg", &__p, 4);
      sub_1000C15D8(&v43, &v42);
      if (v9 != &v43)
      {
        CFTypeRef cf = *v9;
        *CFMutableDictionaryRef v9 = v43;
        uint64_t v43 = 0;
        sub_100030068(&cf);
      }
      sub_100030068(&v43);
      sub_1000577C4(&v42);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      CFTypeID v32 = v44;
      CFDictionaryRef v33 = operator new(8uLL);
      long long __p = v33;
      *CFDictionaryRef v33 = v32;
      CFUUIDRef v40 = v33 + 1;
      int v41 = v33 + 1;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&cf, v18, a3, @"mt-key", @"SatMsg", &__p, 4);
      sub_100E7B6E8(a1 + 88, cf);
      sub_1000577C4(&cf);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      CFDictionaryRef v34 = v44;
      uint64_t v35 = operator new(8uLL);
      long long __p = v35;
      void *v35 = v34;
      CFUUIDRef v40 = v35 + 1;
      int v41 = v35 + 1;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&cf, v18, a3, @"mt-recovery-key", @"SatMsg", &__p, 4);
      sub_100E7B6E8(v7, cf);
      sub_1000577C4(&cf);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
      uint64_t v36 = v44;
      os_log_t v37 = operator new(8uLL);
      long long __p = v37;
      void *v37 = v36;
      CFUUIDRef v40 = v37 + 1;
      int v41 = v37 + 1;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void **, uint64_t))(*(void *)v18 + 24))(&cf, v18, a3, @"mo-key", @"SatMsg", &__p, 4);
      sub_100E7B6E8(v8, cf);
      sub_1000577C4(&cf);
      if (__p)
      {
        CFUUIDRef v40 = __p;
        operator delete(__p);
      }
    }
  }
  sub_1000558F4(&v44);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  return a1;
}

void sub_100E7B5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, const void *a15, const void *a16)
{
  sub_1000577C4(&a16);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a15);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  sub_100030068(v19);
  sub_100030068(v18);
  sub_100030068(v17);
  sub_100030068((const void **)(v16 + 88));
  sub_100030068((const void **)(v16 + 80));
  sub_100030068((const void **)(v16 + 72));
  sub_100030068((const void **)(v16 + 64));
  std::mutex::~mutex((std::mutex *)v16);
  _Unwind_Resume(a1);
}

CFTypeID sub_100E7B6E8(CFTypeID result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, *(const void **)(v3 + 16));
      if (Value)
      {
        uint64_t v6 = Value;
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFDataGetTypeID()) {
          CFTypeID v8 = v6;
        }
        else {
          CFTypeID v8 = 0;
        }
      }
      else
      {
        CFTypeID v8 = 0;
      }
      CFTypeRef v14 = v8;
      sub_10015E5D4((const void **)v3, &v14);
      CFMutableDictionaryRef v9 = (unsigned __int16 *)CFDictionaryGetValue((CFDictionaryRef)cf, *(const void **)(v3 + 24));
      if (v9)
      {
        uint64_t v11 = v9;
        CFTypeID v12 = CFGetTypeID(v9);
        if (v12 == CFNumberGetTypeID()) {
          CFTypeID v13 = v11;
        }
        else {
          CFTypeID v13 = 0;
        }
      }
      else
      {
        CFTypeID v13 = 0;
      }
      __int16 v15 = 0;
      uint64_t result = ctu::cf::assign((ctu::cf *)&v15, v13, v10);
      *(_WORD *)(v3 + 8) = v15;
    }
  }
  return result;
}

void sub_100E7B7C4()
{
}

void *sub_100E7B7D8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A64568;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7B820(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64568;
  a2[1] = v2;
  return result;
}

void sub_100E7B84C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFTypeID v4 = a2;
    }
    else {
      CFTypeID v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7B900(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7B940()
{
}

void sub_100E7B950()
{
}

void *sub_100E7B964(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A645E8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7B9AC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A645E8;
  a2[1] = v2;
  return result;
}

void sub_100E7B9D8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFTypeID v4 = a2;
    }
    else {
      CFTypeID v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7BA8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7BACC()
{
}

void sub_100E7BADC()
{
}

void *sub_100E7BAF0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A64668;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7BB38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64668;
  a2[1] = v2;
  return result;
}

void sub_100E7BB64(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFTypeID v4 = a2;
    }
    else {
      CFTypeID v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7BC18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7BC58()
{
}

void sub_100E7BC64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A646E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7BC84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A646E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E7BCD8(uint64_t a1)
{
  sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 32);

  sub_1001FEC70(v2);
}

void sub_100E7BD1C(void *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  uint64_t v6 = (char *)operator new(0x90uLL);
  CFTypeID v7 = v6;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)uint64_t v6 = off_101A64738;
  CFTypeID v8 = v6 + 24;
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *((void *)v6 + 3) = a2;
    *((void *)v6 + 4) = a3;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    *((void *)v6 + 17) = 0;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 104) = 0u;
    *(_OWORD *)(v6 + 117) = 0u;
    sub_10004D2C8(a3);
  }
  else
  {
    *((void *)v6 + 3) = a2;
    *((void *)v6 + 17) = 0;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *(void *)(v6 + 125) = 0;
  }
  *a1 = v8;
  a1[1] = v7;
}

void sub_100E7BDE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A64738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7BE08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A64738;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E7BE5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  CFTypeID v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100E7BF10(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = (char *)a1[1];
  CFTypeID v7 = (char **)(a1 + 1);
  CFTypeID v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  CFTypeID v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      CFTypeID v8 = (char **)v5;
      CFNumberRef v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      int v5 = *v8;
      CFTypeID v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    CFTypeID v7 = v8 + 1;
    int v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  if (!*v7)
  {
LABEL_10:
    uint64_t v15 = 0;
    uint64_t v11 = (char *)operator new(0x48uLL);
    v14[0] = v11;
    v14[1] = v6;
    CFTypeID v12 = v11 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)CFTypeID v12 = *(_OWORD *)a3;
      *((void *)v11 + 6) = *(void *)(a3 + 16);
    }
    *(_OWORD *)(v11 + 56) = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    LOBYTE(v15) = 1;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    char *v7 = v11;
    CFTypeID v13 = (uint64_t *)**a1;
    if (v13)
    {
      *a1 = v13;
      uint64_t v11 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v14[0] = 0;
    sub_1001FEBC4((uint64_t)v14);
  }
}

void sub_100E7C058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100E7C06C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void **)(v1 + 328);
  uint64_t v3 = *(void **)(v1 + 336);
  while (v2 != v3)
  {
    CFTypeID v4 = (std::__shared_weak_count *)v2[1];
    if (v4)
    {
      int v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        uint64_t v6 = v5;
        if (*v2) {
          (*(void (**)(void, void))(*(void *)*v2 + 16))(*v2, *(unsigned __int8 *)(v1 + 200));
        }
        sub_10004D2C8(v6);
      }
    }
    v2 += 2;
  }
  operator delete();
}

void sub_100E7C12C()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100E7C160(void **a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(*(void *)**a1 + 128))(**a1);
  operator delete();
}

void sub_100E7C1D4()
{
}

void sub_100E7C200(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A64788;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7C220(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A64788;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E7C274(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100E7C2A0()
{
}

void *sub_100E7C2B4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A647D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7C2FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A647D8;
  a2[1] = v2;
  return result;
}

void sub_100E7C328(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFTypeID v4 = a2;
    }
    else {
      CFTypeID v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7C3D8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7C418()
{
}

void sub_100E7C424(void ***a1, void **a2)
{
  uint64_t v3 = sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (void ***)v3)
  {
    CFTypeID v4 = (uint64_t *)v3;
    int v5 = (void **)v3[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        int v5 = (void **)*v5;
      }
      while (v5);
    }
    else
    {
      CFTypeID v7 = v3;
      do
      {
        uint64_t v6 = (void **)v7[2];
        BOOL v8 = *v6 == v7;
        CFTypeID v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3) {
      *a1 = v6;
    }
    CFMutableDictionaryRef v9 = (uint64_t *)a1[1];
    a1[2] = (void **)((char *)a1[2] - 1);
    sub_10005EE6C(v9, v4);
    sub_1001FEC1C((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

void sub_100E7C4D4(const __CFUUID ***a1, Registry **a2, void *a3, os_log_t *a4)
{
  CFTypeID v7 = (char *)operator new(0x90uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *((void *)v7 + 3) = 0;
  *(void *)CFTypeID v7 = off_101A644C8;
  *((void *)v7 + 7) = 0;
  v7[40] = 0;
  *((void *)v7 + 6) = v7 + 56;
  uint64_t v29 = (const __CFUUID **)(v7 + 24);
  *((void *)v7 + 8) = 0;
  *((void *)v7 + 10) = 0;
  *((void *)v7 + 9) = v7 + 80;
  *((void *)v7 + 11) = 0;
  *((void *)v7 + 13) = 0;
  *((void *)v7 + 12) = v7 + 104;
  *((void *)v7 + 14) = 0;
  *((void *)v7 + 15) = 0;
  *((void *)v7 + 16) = 0;
  *((void *)v7 + 17) = 0;
  CFUUIDRef v8 = CFUUIDCreate(0);
  BOOL v26 = a4;
  os_log_t v27 = a1;
  uint64_t v9 = *((void *)v7 + 3);
  *((void *)v7 + 3) = v8;
  *(void *)long long __p = v9;
  sub_10012577C((const void **)__p);
  *((void *)v7 + 4) = time(0);
  CFNumberRef v10 = a3 + 1;
  uint64_t v11 = (void *)*a3;
  if ((void *)*a3 == a3 + 1) {
    goto LABEL_36;
  }
  int v12 = 0;
  uint64_t v13 = (uint64_t)(a3 + 3);
  CFTypeRef v14 = (void **)(a3 + 4);
  while (1)
  {
    uint64_t v15 = v11 + 4;
    if (v14 == sub_100046F68(v13, (void **)v11 + 4)) {
      break;
    }
LABEL_27:
    CFTypeID v22 = (void *)v11[1];
    if (v22)
    {
      do
      {
        uint64_t v23 = v22;
        CFTypeID v22 = (void *)*v22;
      }
      while (v22);
    }
    else
    {
      do
      {
        uint64_t v23 = (void *)v11[2];
        BOOL v24 = *v23 == (void)v11;
        uint64_t v11 = v23;
      }
      while (!v24);
    }
    uint64_t v11 = v23;
    if (v23 == v10) {
      goto LABEL_36;
    }
  }
  if (v12 < 2)
  {
    *(_DWORD *)long long __p = v12;
    if (*((char *)v11 + 55) < 0)
    {
      sub_10004FC84(&__p[8], (void *)v11[4], v11[5]);
      int v16 = *(_DWORD *)__p;
    }
    else
    {
      *(_OWORD *)&__p[8] = *v15;
      uint64_t v31 = (std::__shared_weak_count *)v11[6];
      int v16 = v12;
    }
    sub_100E7AD30((uint64_t *)v7 + 6, v16, (uint64_t)__p);
    if (SHIBYTE(v31) < 0) {
      operator delete(*(void **)&__p[8]);
    }
    uint64_t v17 = v11[7];
    uint64_t v18 = (char *)operator new(0x90uLL);
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = 0;
    *(void *)uint64_t v18 = off_101A642C8;
    sub_1000593FC((uint64_t)(v18 + 24), (long long *)v17);
    sub_1000593FC((uint64_t)(v18 + 56), (long long *)(v17 + 32));
    *((void *)v18 + 11) = *(void *)(v17 + 64);
    uint64_t v19 = *(void *)(v17 + 72);
    *((void *)v18 + 12) = v19;
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100083DA4((const void **)v18 + 13, (const void **)(v17 + 80));
    sub_10002FD9C((const void **)v18 + 14, (const void **)(v17 + 88));
    sub_100083DA4((const void **)v18 + 15, (const void **)(v17 + 96));
    sub_100083DA4((const void **)v18 + 16, (const void **)(v17 + 104));
    sub_100062740((const void **)v18 + 17, (const void **)(v17 + 112));
    if (*((char *)v11 + 55) < 0)
    {
      sub_10004FC84(__p, (void *)v11[4], v11[5]);
    }
    else
    {
      *(_OWORD *)long long __p = *v15;
      *(void *)&__p[16] = v11[6];
    }
    uint64_t v31 = (std::__shared_weak_count *)(v18 + 24);
    CFTypeID v32 = (std::__shared_weak_count *)v18;
    sub_100E79984((uint64_t **)v7 + 9, (void **)__p, (uint64_t)__p);
    if (v32) {
      sub_10004D2C8(v32);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    CFUUIDRef v20 = *v29;
    char v21 = (std::__shared_weak_count *)operator new(0xD8uLL);
    v21->__shared_owners_ = 0;
    v21->__shared_weak_owners_ = 0;
    v21->__vftable = (std::__shared_weak_count_vtbl *)off_101A64518;
    sub_100E7AFFC((uint64_t)&v21[1], a2, (uint64_t)(v11 + 4), v20);
    if (*((char *)v11 + 55) < 0)
    {
      sub_10004FC84(__p, (void *)v11[4], v11[5]);
    }
    else
    {
      *(_OWORD *)long long __p = *v15;
      *(void *)&__p[16] = v11[6];
    }
    uint64_t v31 = v21 + 1;
    CFTypeID v32 = v21;
    sub_100E7AE30((uint64_t **)v7 + 12, (void **)__p, (uint64_t)__p);
    if (v32) {
      sub_10004D2C8(v32);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    ++v12;
    goto LABEL_27;
  }
  CFTypeID v25 = *v26;
  if (os_log_type_enabled(*v26, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = "s1";
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "highest possible simID is %s - ignoring the rest", __p, 0xCu);
  }
LABEL_36:
  const void *v27 = v29;
  v27[1] = (const __CFUUID **)v7;
}

void sub_100E7C8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void **a18)
{
  CFUUIDRef v20 = *a10;
  if (*a10)
  {
    *(void *)(v18 + 128) = v20;
    operator delete(v20);
  }
  sub_1001FEC70(*(void **)(v18 + 104));
  sub_1001FEC70(*(void **)(v18 + 80));
  sub_10026D080(*(char **)(v18 + 56));
  sub_10012577C(a18);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v18);
  operator delete(v21);
  _Unwind_Resume(a1);
}

void sub_100E7C9E8()
{
}

void *sub_100E7C9FC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A64858;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7CA44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64858;
  a2[1] = v2;
  return result;
}

void sub_100E7CA70(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      CFTypeID v4 = a2;
    }
    else {
      CFTypeID v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7CB20(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7CB60()
{
}

uint64_t *sub_100E7CB6C(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  CFTypeID v7 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1[1];
    *(_DWORD *)std::string buf = 138412290;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I notify IDS new config %@ is available", buf, 0xCu);
  }
  (*(void (**)(void))(**(void **)(v2 + 352) + 16))(*(void *)(v2 + 352));
  sub_100556354((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100E7CC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100E7CC74()
{
}

void *sub_100E7CC88(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A648D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7CCD0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A648D8;
  a2[1] = v2;
  return result;
}

void sub_100E7CCFC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7CDAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7CDEC()
{
}

void sub_100E7CDFC()
{
}

void *sub_100E7CE10(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A64958;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7CE58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64958;
  a2[1] = v2;
  return result;
}

void sub_100E7CE84(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7CF34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7CF74()
{
}

void sub_100E7CF84()
{
}

__n128 sub_100E7CF98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A649D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E7CFE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A649D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E7D014(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    CFNumberRef v10 = " ";
    __int16 v11 = 2080;
    int v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_100E7D0F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7D138()
{
}

void sub_100E7D148()
{
}

__n128 sub_100E7D15C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A64A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E7D1A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A64A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E7D1D8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    CFNumberRef v10 = " ";
    __int16 v11 = 2080;
    int v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_100E7D2BC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A64AB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7D2FC()
{
  return &off_101A64AB8;
}

void sub_100E7D30C()
{
}

void *sub_100E7D320(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64AD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7D368(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64AD8;
  a2[1] = v2;
  return result;
}

void sub_100E7D394(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7D444(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7D484()
{
}

void sub_100E7D494()
{
}

void *sub_100E7D4A8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64B58;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7D4F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64B58;
  a2[1] = v2;
  return result;
}

void sub_100E7D51C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7D5CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7D60C()
{
}

void sub_100E7D61C()
{
}

__n128 sub_100E7D630(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A64BD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E7D67C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A64BD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E7D6AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    CFNumberRef v10 = " ";
    __int16 v11 = 2080;
    int v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_100E7D790(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7D7D0()
{
}

void sub_100E7D7E0()
{
}

__n128 sub_100E7D7F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A64C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E7D840(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A64C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E7D870(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 16));
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    CFNumberRef v10 = " ";
    __int16 v11 = 2080;
    int v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_100E7D954(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7D994()
{
}

void sub_100E7D9A4()
{
}

void *sub_100E7D9B8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64CD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7DA00(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64CD8;
  a2[1] = v2;
  return result;
}

void sub_100E7DA2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7DADC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7DB1C()
{
}

void sub_100E7DB2C()
{
}

void *sub_100E7DB40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64D58;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7DB88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64D58;
  a2[1] = v2;
  return result;
}

void sub_100E7DBB4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7DC64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E7DCA4()
{
}

void sub_100E7DCB0(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I notify IDS new re-sync is needed", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 352) + 16))(*(void *)(v1 + 352));
  operator delete();
}

void sub_100E7DD6C()
{
}

void *sub_100E7DD98(void *a1)
{
  *a1 = off_101A64DD8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100E7DDE4(void *a1)
{
  *a1 = off_101A64DD8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100E7DE50(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A64DD8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E7DEB4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A64DD8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E7DEF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100E7DF04(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100E7DF44(uint64_t a1, void *a2)
{
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  long long v2 = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E7E0D8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E7E0E8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7E128()
{
}

uint64_t *sub_100E7E134(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v35 = a1;
  uint64_t v36 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(char *)(v1 + 47) < 0)
  {
    if (*(void *)(v1 + 32)) {
      goto LABEL_3;
    }
  }
  else if (*(unsigned char *)(v1 + 47))
  {
LABEL_3:
    uint64_t v3 = *(void *)(v2 + 160);
    if (!v3) {
      goto LABEL_57;
    }
    uint64_t v4 = sub_100046F68(v3, (void **)(*(void *)(v1 + 8) + 24));
    if ((void **)(*(void *)(v2 + 160) + 8) == v4) {
      goto LABEL_57;
    }
    int v5 = v4;
    uint64_t v6 = *(void *)(v1 + 8);
    if (!sub_100197A80((unsigned __int8 *)v4[7] + 32, (unsigned __int8 *)(v1 + 24))) {
      goto LABEL_57;
    }
    sub_100093B44((std::string *)((char *)v5[7] + 32), (const std::string *)(v1 + 24));
    uint64_t v7 = v6 + 24;
    uint64_t v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v1 + 47) >= 0) {
        uint64_t v9 = v1 + 24;
      }
      else {
        uint64_t v9 = *(void *)(v1 + 24);
      }
      uint64_t v10 = *(unsigned __int8 *)(v6 + 47);
      BOOL v11 = (v10 & 0x80u) != 0;
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(v6 + 32);
      }
      if (v11) {
        int v12 = *(const char **)(v6 + 24);
      }
      else {
        int v12 = (const char *)(v6 + 24);
      }
      if (v10) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SMSC %s was set for persona %s", buf, 0x16u);
    }
    CFTypeRef v14 = &qword_101B12DD0;
    LOBYTE(v14) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B12DD0, memory_order_acquire);
    if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_101B12DD0))
    {
      *(void *)std::string buf = @"sim-cfg";
      sub_100367E88(qword_101B12E08, buf, 1uLL);
      __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B12E08, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B12DD0);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(v2 + 48));
    int v16 = ServiceMap;
    if (v17 < 0)
    {
      uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v17;
    char v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      CFTypeID v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
LABEL_37:
        if (*(char *)(v1 + 47) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v1 + 24), *(void *)(v1 + 32));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v1 + 24);
          uint64_t v38 = *(void *)(v1 + 40);
        }
        if (SHIBYTE(v38) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v42 = v38;
        }
        CFUUIDRef v40 = 0;
        if (SHIBYTE(v42) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v42;
        }
        uint64_t v43 = 0;
        if (ctu::cf::convert_copy())
        {
          CFTypeID v32 = v40;
          CFUUIDRef v40 = v43;
          uint64_t v44 = v32;
          sub_1000558F4(&v44);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        CFDictionaryRef v33 = v40;
        uint64_t v39 = v40;
        CFUUIDRef v40 = 0;
        sub_1000558F4(&v40);
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, const __CFString *, void *, uint64_t, void, uint64_t *, uint64_t))(*(void *)v23 + 16))(v23, v7, @"smsc", v33, @"SatMsg", qword_101B12E08, 2, 0, v35, v36);
        sub_1000558F4(&v39);
        if (SHIBYTE(v38) < 0) {
          operator delete(__dst[0]);
        }
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        sub_100E6822C(v2);
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    CFTypeID v22 = 0;
    char v24 = 1;
    goto LABEL_37;
  }
  CFTypeID v25 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = *(void *)(v1 + 8);
    uint64_t v29 = *(const char **)(v26 + 24);
    os_log_t v27 = (const char *)(v26 + 24);
    int v28 = v29;
    uint64_t v30 = *((unsigned __int8 *)v27 + 23);
    int v31 = (char)v30;
    if ((v30 & 0x80u) != 0) {
      uint64_t v30 = *((void *)v27 + 1);
    }
    if (v31 < 0) {
      os_log_t v27 = v28;
    }
    if (!v30) {
      os_log_t v27 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I no SMSC for %s reported...", buf, 0xCu);
  }
LABEL_57:
  sub_100E7E65C(&v36);
  return sub_100046B58((uint64_t *)&v35);
}

void sub_100E7E5A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

uint64_t *sub_100E7E65C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100E7E6C0(void ***a1)
{
  uint64_t v1 = **a1;
  if (!v1[20]) {
    goto LABEL_20;
  }
  uint64_t v2 = (void *)v1[41];
  uint64_t v3 = (void *)v1[42];
  if (v2 != v3)
  {
    uint64_t v4 = 0;
    while (1)
    {
      int v5 = (std::__shared_weak_count *)v2[1];
      if (v5)
      {
        uint64_t v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          uint64_t v7 = v6;
          if (*v2)
          {
            (*(void (**)(uint8_t *__return_ptr))(*(void *)*v2 + 24))(buf);
            long long v8 = *(_OWORD *)buf;
            *(_OWORD *)std::string buf = 0uLL;
            if (v4)
            {
              sub_10004D2C8(v4);
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
            }
            if ((void)v8)
            {
              sub_10004D2C8(v7);
              uint64_t v10 = v1[5];
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v11 = (uint64_t)(*(void *)(v8 + 8) - *(void *)v8) >> 3;
                *(_DWORD *)std::string buf = 134217984;
                *(void *)&uint8_t buf[4] = v11;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I updating contacts: %zu elems", buf, 0xCu);
              }
              int v12 = (void *)v1[20];
              uint64_t v15 = (void *)*v12;
              uint64_t v13 = v12 + 1;
              CFTypeRef v14 = v15;
              if (v15 != v13)
              {
                do
                {
                  uint64_t v16 = v14[7];
                  if (*((void *)&v8 + 1)) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v17 = *(std::__shared_weak_count **)(v16 + 72);
                  *(_OWORD *)(v16 + 64) = v8;
                  if (v17) {
                    sub_10004D2C8(v17);
                  }
                  uint64_t v18 = (void *)v14[1];
                  if (v18)
                  {
                    do
                    {
                      uint64_t v19 = v18;
                      uint64_t v18 = (void *)*v18;
                    }
                    while (v18);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v19 = (void *)v14[2];
                      BOOL v20 = *v19 == (void)v14;
                      CFTypeRef v14 = v19;
                    }
                    while (!v20);
                  }
                  CFTypeRef v14 = v19;
                }
                while (v19 != v13);
              }
              sub_100E6822C((uint64_t)v1);
              uint64_t v4 = (std::__shared_weak_count *)*((void *)&v8 + 1);
              if (!*((void *)&v8 + 1)) {
                goto LABEL_20;
              }
              goto LABEL_19;
            }
            uint64_t v4 = (std::__shared_weak_count *)*((void *)&v8 + 1);
          }
          sub_10004D2C8(v7);
        }
      }
      v2 += 2;
      if (v2 == v3) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v4 = 0;
LABEL_16:
  uint64_t v9 = v1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I NO contacts yet to set", buf, 2u);
  }
  if (!v4) {
LABEL_20:
  }
    operator delete();
LABEL_19:
  sub_10004D2C8(v4);
  goto LABEL_20;
}

void sub_100E7E918()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_100E7E968()
{
}

void *sub_100E7E97C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64E58;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7E9C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64E58;
  a2[1] = v2;
  return result;
}

void sub_100E7E9F0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7EAA0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7EAE0()
{
}

void sub_100E7EAF0()
{
}

void *sub_100E7EB04(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64ED8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7EB4C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64ED8;
  a2[1] = v2;
  return result;
}

void sub_100E7EB78(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7EC28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7EC68()
{
}

void sub_100E7EC78()
{
}

void *sub_100E7EC8C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64F58;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7ECD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64F58;
  a2[1] = v2;
  return result;
}

void sub_100E7ED00(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7EDB0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7EDF0()
{
}

void sub_100E7EE00()
{
}

void *sub_100E7EE14(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A64FD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7EE5C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A64FD8;
  a2[1] = v2;
  return result;
}

void sub_100E7EE88(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100E7EF38(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E7EF78()
{
}

void sub_100E7EF84(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A65058;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E7EFA4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A65058;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E7EFF8(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
}

void sub_100E7F054()
{
  qword_101B12DB8 = (uint64_t)kCFNull;
}

void **sub_100E7F06C(void **a1)
{
  uint64_t v3 = a1;
  sub_100047F64(&v3);
  return a1;
}

uint64_t sub_100E7F0A4(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = sub_100A3A7DC(a1, a2);
  *(void *)uint64_t v3 = off_101A650A8;
  *(void *)(v3 + 176) = 0;
  *(void *)(v3 + 184) = 0;
  *(void *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(unsigned char *)(v3 + 160) = 0;
  uint64_t v4 = **(NSObject ***)(v3 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 136315394;
    uint64_t v7 = "Digest";
    __int16 v8 = 2080;
    uint64_t v9 = ", ";
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%screated DigestAuthScheme", (uint8_t *)&v6, 0x16u);
  }
  return a1;
}

uint64_t sub_100E7F1A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100A3A8C8(a1, a2);
  *(_OWORD *)(v4 + 64) = 0u;
  *(void *)uint64_t v4 = off_101A650A8;
  uint64_t v5 = v4 + 88;
  *(_OWORD *)(v4 + 112) = 0u;
  int v6 = (std::string *)(v4 + 112);
  uint64_t v7 = (std::string *)(v4 + 136);
  *(void *)(v4 + 168) = 0;
  uint64_t v8 = v4 + 168;
  *(void *)(v4 + 176) = 0;
  *(void *)(v4 + 184) = 0;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_DWORD *)(v4 + 56) = *(_DWORD *)(a2 + 56);
  std::string::operator=((std::string *)(v4 + 64), (const std::string *)(a2 + 64));
  if (a1 != a2) {
    sub_10005CA3C(v5, *(std::string **)(a2 + 88), *(long long **)(a2 + 96), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3));
  }
  std::string::operator=(v6, (const std::string *)(a2 + 112));
  *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
  std::string::operator=(v7, (const std::string *)(a2 + 136));
  if (a1 != a2) {
    sub_10005CA3C(v8, *(std::string **)(a2 + 168), *(long long **)(a2 + 176), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 176) - *(void *)(a2 + 168)) >> 3));
  }
  uint64_t v9 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    int v12 = 136315394;
    uint64_t v13 = v11;
    __int16 v14 = 2080;
    uint64_t v15 = ", ";
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#D %s%scloned DigestAuthScheme", (uint8_t *)&v12, 0x16u);
  }
  return a1;
}

void sub_100E7F37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_100047F64(&a9);
  if (*(char *)(v9 + 159) < 0) {
    operator delete(*v12);
  }
  if (*(char *)(v9 + 135) < 0) {
    operator delete(*v11);
  }
  sub_100047F64(&a9);
  if (*(char *)(v9 + 87) < 0) {
    operator delete(*v10);
  }
  *(void *)uint64_t v9 = off_101A2EB80;
  sub_100343DF4(v9 + 16);
  _Unwind_Resume(a1);
}

void sub_100E7F3F8(uint64_t a1)
{
  *(_DWORD *)(a1 + 56) = 0;
  if (*(char *)(a1 + 87) < 0)
  {
    **(unsigned char **)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 64) = 0;
    *(unsigned char *)(a1 + 87) = 0;
  }
  sub_100047FB8((uint64_t *)(a1 + 88));
  if (*(char *)(a1 + 135) < 0)
  {
    **(unsigned char **)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 112) = 0;
    *(unsigned char *)(a1 + 135) = 0;
  }
  *(unsigned char *)(a1 + 160) = 0;
  if (*(char *)(a1 + 159) < 0)
  {
    **(unsigned char **)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 136) = 0;
    *(unsigned char *)(a1 + 159) = 0;
  }
}

uint64_t sub_100E7F488(uint64_t a1, void *a2)
{
  char v5 = 48;
  uint64_t v2 = sub_1004DC904(a2, &v5);
  uint64_t v3 = *v2;
  *(uint64_t *)((char *)v2 + *(void *)(*v2 - 24) + 24) = 8;
  *(_DWORD *)((char *)v2 + *(void *)(v3 - 24) + 8) = *(_DWORD *)((unsigned char *)v2 + *(void *)(v3 - 24) + 8) & 0xFFFFFFB5 | 8;
  return std::ostream::operator<<();
}

uint64_t sub_100E7F538(uint64_t a1, uint64_t a2, int a3)
{
  sub_100A3AED0(a1, a2);
  if (!a3)
  {
    uint64_t v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    sub_10004DE24((uint64_t)&v40);
    sub_10004B96C(&v40, (uint64_t)"\"", 1);
    uint64_t v6 = *(void *)(a1 + 88);
    if (*(void *)(a1 + 96) != v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      do
      {
        if (v8)
        {
          __str.__r_.__value_.__s.__data_[0] = 44;
          sub_10004B96C(&v40, (uint64_t)&__str, 1);
          uint64_t v6 = *(void *)(a1 + 88);
        }
        uint64_t v9 = v6 + v7;
        int v10 = *(char *)(v9 + 23);
        if (v10 >= 0) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = *(void *)v9;
        }
        if (v10 >= 0) {
          uint64_t v12 = *(unsigned __int8 *)(v9 + 23);
        }
        else {
          uint64_t v12 = *(void *)(v9 + 8);
        }
        sub_10004B96C(&v40, v11, v12);
        ++v8;
        uint64_t v6 = *(void *)(a1 + 88);
        v7 += 24;
      }
      while (v8 < 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 96) - v6) >> 3));
    }
    __str.__r_.__value_.__s.__data_[0] = 34;
    sub_10004B96C(&v40, (uint64_t)&__str, 1);
    sub_10004BC98((uint64_t)&v40 + 8, &__str);
    uint64_t v36 = byte_101583230;
    uint64_t v13 = sub_100A3C118(a2, byte_101583230, (uint64_t)&unk_10144E20E, (long long **)&v36);
    __int16 v14 = (void **)(v13 + 40);
    if ((char)v13[63] < 0) {
      operator delete(*v14);
    }
    *(std::string *)__int16 v14 = __str;
    if (SHIBYTE(v45) < 0) {
      operator delete(*((void **)&v44 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    goto LABEL_48;
  }
  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 87)) {
      goto LABEL_36;
    }
LABEL_22:
    uint64_t v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    sub_10004DE24((uint64_t)&v40);
    __str.__r_.__value_.__s.__data_[0] = 34;
    uint64_t v15 = sub_10004B96C(&v40, (uint64_t)&__str, 1);
    int v16 = *(char *)(a1 + 87);
    if (v16 >= 0) {
      uint64_t v17 = a1 + 64;
    }
    else {
      uint64_t v17 = *(void *)(a1 + 64);
    }
    if (v16 >= 0) {
      uint64_t v18 = *(unsigned __int8 *)(a1 + 87);
    }
    else {
      uint64_t v18 = *(void *)(a1 + 72);
    }
    uint64_t v19 = sub_10004B96C(v15, v17, v18);
    __str.__r_.__value_.__s.__data_[0] = 34;
    sub_10004B96C(v19, (uint64_t)&__str, 1);
    sub_10004BC98((uint64_t)&v40 + 8, &__str);
    sub_100058DB0(&v36, "uri");
    *(void *)&long long v34 = &v36;
    BOOL v20 = sub_100E81C88(a2, (unsigned __int8 *)&v36, (long long **)&v34);
    char v21 = (void **)(v20 + 40);
    if ((char)v20[63] < 0) {
      operator delete(*v21);
    }
    *(std::string *)char v21 = __str;
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 0;
    __str.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v38) < 0)
    {
      operator delete(v36);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    if (SHIBYTE(v45) < 0) {
      operator delete(*((void **)&v44 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    goto LABEL_36;
  }
  if (*(void *)(a1 + 72)) {
    goto LABEL_22;
  }
LABEL_36:
  if (*(_DWORD *)(a1 + 56))
  {
    uint64_t v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    sub_10004DE24((uint64_t)&v40);
    sub_100E7F488(a1, &v40);
    sub_10004BC98((uint64_t)&v40 + 8, &__str);
    sub_100058DB0(&v36, "nc");
    *(void *)&long long v34 = &v36;
    CFTypeID v22 = sub_100E81C88(a2, (unsigned __int8 *)&v36, (long long **)&v34);
    uint64_t v23 = (void **)(v22 + 40);
    if ((char)v22[63] < 0) {
      operator delete(*v23);
    }
    *(std::string *)uint64_t v23 = __str;
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 0;
    __str.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v38) < 0)
    {
      operator delete(v36);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    if (SHIBYTE(v45) < 0) {
      operator delete(*((void **)&v44 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  if ((*(char *)(a1 + 135) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 135)) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  if (*(void *)(a1 + 120))
  {
LABEL_47:
    *(void *)&long long v40 = byte_101583230;
    char v24 = sub_100A3C118(a2, byte_101583230, (uint64_t)&unk_10144E20E, (long long **)&v40);
    std::string::operator=((std::string *)(v24 + 40), (const std::string *)(a1 + 112));
  }
LABEL_48:
  memset(&__str, 0, sizeof(__str));
  (*(void (**)(uint64_t, std::string *))(*(void *)a1 + 112))(a1, &__str);
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    *(void *)&long long v40 = "algorithm";
    uint64_t v26 = sub_100A3C118(a2, "algorithm", (uint64_t)&unk_10144E20E, (long long **)&v40);
    std::string::operator=((std::string *)(v26 + 40), &__str);
  }
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 80))(a1)) {
    (*(void (**)(uint64_t, void **))(*(void *)a1 + 96))(a1, &v36);
  }
  uint64_t v56 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  sub_10004DE24((uint64_t)&v40);
  LOBYTE(v34) = 34;
  os_log_t v27 = sub_10004B96C(&v40, (uint64_t)&v34, 1);
  if (v38 >= 0) {
    int v28 = &v36;
  }
  else {
    int v28 = v36;
  }
  if (v38 >= 0) {
    uint64_t v29 = HIBYTE(v38);
  }
  else {
    uint64_t v29 = v37;
  }
  uint64_t v30 = sub_10004B96C(v27, (uint64_t)v28, v29);
  LOBYTE(v34) = 34;
  sub_10004B96C(v30, (uint64_t)&v34, 1);
  sub_10004BC98((uint64_t)&v40 + 8, &v34);
  unsigned __int16 v57 = "nonce";
  int v31 = sub_100A3C118(a2, "nonce", (uint64_t)&unk_10144E20E, (long long **)&v57);
  CFTypeID v32 = v31 + 40;
  if ((char)v31[63] < 0) {
    operator delete(*(void **)v32);
  }
  *(_OWORD *)CFTypeID v32 = v34;
  *((void *)v32 + 2) = v35;
  if (SHIBYTE(v45) < 0) {
    operator delete(*((void **)&v44 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  if (SHIBYTE(v38) < 0) {
    operator delete(v36);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return 1;
}

void sub_100E7FE3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_1000C937C((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100E7FF04(uint64_t a1, std::string::size_type a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  switch(v5)
  {
    case 2:
      if (v6 >= 0) {
        uint64_t v7 = (unsigned __int16 *)a2;
      }
      else {
        uint64_t v7 = *(unsigned __int16 **)a2;
      }
      if (*v7 != 25454) {
        goto LABEL_51;
      }
      if (*(char *)(a3 + 23) >= 0) {
        unint64_t v8 = (const char *)a3;
      }
      else {
        unint64_t v8 = *(const char **)a3;
      }
      *(_DWORD *)(a1 + 56) = strtoul(v8, 0, 16);
      return 1;
    case 3:
      if (v6 >= 0) {
        uint64_t v9 = (unsigned __int16 *)a2;
      }
      else {
        uint64_t v9 = *(unsigned __int16 **)a2;
      }
      if (*v9 == 29301 && *((unsigned char *)v9 + 2) == 105)
      {
        int v28 = (std::string *)(a1 + 64);
        goto LABEL_52;
      }
      int v11 = *v9;
      int v12 = *((unsigned __int8 *)v9 + 2);
      if (v11 != 28529 || v12 != 112)
      {
LABEL_51:
        __p.__r_.__value_.__r.__words[0] = a2;
        int v28 = (std::string *)(sub_100A3C118(a1 + 16, (unsigned __int8 *)a2, (uint64_t)&unk_10144E20E, (long long **)&__p)
                            + 40);
LABEL_52:
        std::string::operator=(v28, (const std::string *)a3);
        return 1;
      }
      std::string::size_type v14 = 0;
      memset(&__p, 0, sizeof(__p));
      while (1)
      {
        std::string::size_type v14 = sub_100A3BA88((std::string *)a3, v14, &__p, 0x2Cu);
        if (v14 == -1) {
          break;
        }
        sub_100A3B6FC(&__p, "\r\n\t ", 3);
        unint64_t v15 = *(void *)(a1 + 96);
        if (v15 >= *(void *)(a1 + 104))
        {
          uint64_t v17 = sub_100048008((uint64_t *)(a1 + 88), (long long *)&__p);
        }
        else
        {
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(*(unsigned char **)(a1 + 96), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else
          {
            long long v16 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(void *)(v15 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)unint64_t v15 = v16;
          }
          uint64_t v17 = v15 + 24;
          *(void *)(a1 + 96) = v15 + 24;
        }
        *(void *)(a1 + 96) = v17;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (std::string::find((const std::string *)a3, 44, 0) == -1)
      {
        int v28 = (std::string *)(a1 + 112);
        goto LABEL_52;
      }
      return 1;
    case 5:
      if (v6 >= 0) {
        uint64_t v18 = (unsigned __int16 *)a2;
      }
      else {
        uint64_t v18 = *(unsigned __int16 **)a2;
      }
      int v19 = *(_DWORD *)v18;
      int v20 = *((unsigned __int8 *)v18 + 4);
      if (v19 != 1668181870 || v20 != 101) {
        goto LABEL_51;
      }
      CFTypeID v22 = *(uint64_t (**)(void))(*(void *)a1 + 88);
      return v22();
    case 9:
      if (v6 >= 0) {
        char v24 = (unsigned __int16 *)a2;
      }
      else {
        char v24 = *(unsigned __int16 **)a2;
      }
      uint64_t v25 = *(void *)v24;
      int v26 = *((unsigned __int8 *)v24 + 8);
      if (v25 != 0x687469726F676C61 || v26 != 109) {
        goto LABEL_51;
      }
      CFTypeID v22 = *(uint64_t (**)(void))(*(void *)a1 + 104);
      return v22();
    default:
      goto LABEL_51;
  }
}

void sub_100E80204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  *(void *)(v14 + 96) = v15;
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E8024C(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, ctu *a5, const void *a6)
{
  memset(&__dst, 0, sizeof(__dst));
  if (*(char *)(a1 + 159) < 0) {
    sub_10004FC84(&__dst, *(void **)(a1 + 136), *(void *)(a1 + 144));
  }
  else {
    std::string __dst = *(std::string *)(a1 + 136);
  }
  uint64_t v30 = a6;
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (!size) {
    std::string::operator=(&__dst, (const std::string *)"MD5");
  }
  int v12 = *(os_log_t **)(a1 + 8);
  uint64_t v13 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v28 = a1;
    uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    int v14 = *((char *)a2 + 23);
    int v26 = (uint64_t *)*a2;
    int v15 = *((char *)a3 + 23);
    long long v16 = (uint64_t *)*a3;
    int v17 = *((char *)a4 + 23);
    uint64_t v18 = a3;
    int v19 = (uint64_t *)*a4;
    ctu::hex((uint64_t *)&__p, a5, v30, v20);
    if (v17 >= 0) {
      char v21 = a4;
    }
    else {
      char v21 = v19;
    }
    p_p = __p;
    if (v15 >= 0) {
      uint64_t v23 = v18;
    }
    else {
      uint64_t v23 = v16;
    }
    char v24 = v26;
    if (v14 >= 0) {
      char v24 = a2;
    }
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    if (v34 >= 0) {
      p_p = &__p;
    }
    buf[0] = 136316930;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    *(void *)&buf[1] = v27;
    __int16 v36 = 2080;
    uint64_t v37 = ", ";
    __int16 v38 = 2080;
    uint64_t v39 = v24;
    __int16 v40 = 2080;
    long long v41 = v23;
    __int16 v42 = 2080;
    long long v43 = v21;
    __int16 v44 = 2080;
    long long v45 = p_p;
    __int16 v46 = 2048;
    long long v47 = v30;
    v48[0] = 2080;
    *(void *)&v48[1] = p_dst;
    _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "#D %s%scomputeResponse, '%s', '%s', '%s', 0x%s, passwdlen: %zu, %s", (uint8_t *)buf, 0x52u);
    if (SHIBYTE(v34) < 0) {
      operator delete(__p);
    }
    int v12 = *(os_log_t **)(v28 + 8);
  }
  memset(v31, 0, sizeof(v31));
  sub_1004DD20C((uint64_t)v31, (uint64_t)v12);
}

void sub_100E819CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  sub_100E81C2C(&a48);
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  sub_1000C937C((uint64_t)&a66);
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  sub_1004DD2CC((uint64_t)&a35);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Unwind_Resume(a1);
}

const char *sub_100E81BF0()
{
  return "Digest";
}

const char *sub_100E81BFC()
{
  return "Digest";
}

uint64_t sub_100E81C08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 80))();
}

void *sub_100E81C2C(void *result)
{
  if (result[1]) {
    operator delete();
  }
  if (*result) {
    operator delete();
  }
  return result;
}

unsigned __int8 *sub_100E81C88(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  int v6 = (void *)(a1 + 24);
  unint64_t v7 = sub_100206390(a1 + 24, (uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }
    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      for (CFIndex i = *v13; i; CFIndex i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v8)
        {
          if (sub_1000609C0(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v15 >= v9) {
              v15 %= v9;
            }
          }
          else
          {
            v15 &= v9 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  v28[2] = 1;
  long long v16 = operator new(0x40uLL);
  v28[0] = v16;
  v28[1] = a1 + 16;
  *long long v16 = 0;
  v16[1] = v8;
  int v17 = *a3;
  long long v18 = **a3;
  v16[4] = *((void *)*a3 + 2);
  *((_OWORD *)v16 + 1) = v18;
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *(void *)int v17 = 0;
  v16[6] = 0;
  v16[7] = 0;
  v16[5] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    sub_1001369F0(a1, v24);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v12);
  if (v25)
  {
    *(void *)v28[0] = *v25;
    void *v25 = v28[0];
  }
  else
  {
    *(void *)v28[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v28[0];
    *(void *)(*(void *)a1 + 8 * v12) = a1 + 16;
    if (*(void *)v28[0])
    {
      unint64_t v26 = *(void *)(*(void *)v28[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v26 >= v9) {
          v26 %= v9;
        }
      }
      else
      {
        v26 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v26) = v28[0];
    }
  }
  CFIndex i = (unsigned __int8 *)v28[0];
  v28[0] = 0;
  ++*v6;
  sub_100343D9C((uint64_t)v28, 0);
  return i;
}

void sub_100E81F10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100343D9C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100E81F28()
{
  sub_100058DB0(&v2, "auth");
  sub_100058DB0(v3, "auth-int");
  qword_101B12E20 = 0;
  qword_101B12E28 = 0;
  qword_101B12E30 = 0;
  qword_101B12E20 = (uint64_t)operator new(0x30uLL);
  qword_101B12E28 = qword_101B12E20;
  qword_101B12E30 = qword_101B12E20 + 48;
  uint64_t v0 = 0;
  qword_101B12E28 = (uint64_t)sub_1000D8A18((uint64_t)&qword_101B12E30, &v2, &v4, (char *)qword_101B12E20);
  do
  {
    if (SHIBYTE(v3[v0 + 2]) < 0) {
      operator delete((void *)v3[v0]);
    }
    v0 -= 3;
  }
  while (v0 != -6);
  return __cxa_atexit((void (*)(void *))sub_100E7F06C, &qword_101B12E20, (void *)&_mh_execute_header);
}

void sub_100E82038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  qword_101B12E28 = v23;
  sub_100047F64(&a10);
  uint64_t v25 = 0;
  while (1)
  {
    if (*(&a23 + v25) < 0) {
      operator delete(*(void **)((char *)&a18 + v25));
    }
    v25 -= 24;
    if (v25 == -48) {
      _Unwind_Resume(a1);
    }
  }
}

void sub_100E820A4()
{
}

void sub_100E8216C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E821A0(uint64_t a1, NSObject **a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "diag.cellular.health");
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  int v6 = *a2;
  *(void *)(a1 + 16) = *a2;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 24) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)(a1 + 40) = *a3;
  uint64_t v7 = a3[1];
  *(void *)(a1 + 48) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CellularHealth");
  unint64_t v8 = *(NSObject **)(a1 + 16);
  uint8x8_t v10 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  ctu::RestModule::RestModule();
  if (v10) {
    dispatch_release(v10);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 108) = -1;
  *(_DWORD *)(a1 + 112) = -1;
  return a1;
}

void sub_100E822E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  float v20 = (std::__shared_weak_count *)v17[6];
  if (v20) {
    sub_10004D2C8(v20);
  }
  ctu::OsLogLogger::~OsLogLogger(v18);
  sub_100087E88(v17);
  _Unwind_Resume(a1);
}

void sub_100E82360(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v6, *(Registry **)(a1 + 40));
  ctu::RestModule::connect();
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100058DB0(__p, "/cc/props/radio_state");
  int v2 = operator new(0x28uLL);
  void *v2 = off_101A65280;
  v2[1] = a1 + 72;
  void v2[2] = a1;
  v2[3] = sub_100E82A08;
  v2[4] = 0;
  int v17 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v13 = 0;
  aBlock = 0;
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  unint64_t v9 = sub_100E83FC0;
  uint8x8_t v10 = &unk_101A652F0;
  uint64_t v11 = a1;
  char v12 = sub_100E831A8;
  aBlock = _Block_copy(__p);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    long long v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      sub_1004F93C4(v15, &aBlock, *(dispatch_object_t *)(a1 + 16));
      sub_1004F940C(&v16, v15);
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E828A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_object_t object, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E82A08(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  long long v4 = *(NSObject **)(a1 + 32);
  int v61 = (os_log_t *)(a1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "handleRadioStateChanged_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = radioStateAsString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: %s", buf, 0x16u);
  }
  unsigned int v5 = *(_DWORD *)(v3 + 72);
  if (v5 == a2 || v5 - 5 > 0xFFFFFFFD) {
    return;
  }
  uint64_t v7 = (Registry **)(v3 + 40);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 40));
  unint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unint64_t v15 = 0;
  char v17 = 1;
LABEL_15:
  unsigned __int16 v60 = v15;
  if (v16)
  {
    unsigned int v56 = v5;
    unsigned __int16 v57 = (Registry **)(v3 + 40);
    uint64_t v58 = v3;
    subscriber::makeSimSlotRange();
    char v59 = v17;
    float v19 = *(unsigned int **)buf;
    long long v18 = *(unsigned int **)&buf[8];
    if (*(void *)buf == *(void *)&buf[8]) {
      goto LABEL_35;
    }
    float v20 = *(uint64_t (**)(void))&buf[16];
    while ((v20(*v19) & 1) == 0)
    {
      if (++v19 == v18)
      {
        float v19 = v18;
        break;
      }
    }
    BOOL v21 = *(unsigned int **)&buf[8];
    if (v19 == *(unsigned int **)&buf[8])
    {
LABEL_35:
      int v22 = 0xFFFF;
    }
    else
    {
      int v22 = 0xFFFF;
      do
      {
        uint64_t v23 = *v19;
        CFTypeRef cf = 0;
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v16 + 96))(&cf, v16, v23, 1, @"ReportHealthIssueMask", 0, 0);
        size_t v24 = (unsigned __int16 *)cf;
        *(_WORD *)unsigned int v63 = -1;
        if (cf)
        {
          CFTypeID v25 = CFGetTypeID(cf);
          if (v25 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)v63, v24, v26);
          }
        }
        int v27 = *(unsigned __int16 *)v63;
        uint64_t v28 = *v61;
        if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unsigned int v63 = 67109376;
          *(_DWORD *)&v63[4] = v23;
          __int16 v64 = 1024;
          int v65 = v27;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Read ReportHealthIssueMask on slot%d: 0x%hx", v63, 0xEu);
        }
        sub_1000577C4(&cf);
        uint64_t v29 = v19 + 1;
        float v19 = v18;
        if (v29 != v18)
        {
          float v19 = v29;
          while ((v20(*v19) & 1) == 0)
          {
            if (++v19 == v18)
            {
              float v19 = v18;
              break;
            }
          }
        }
        v22 &= v27;
      }
      while (v19 != v21);
    }
    uint64_t v3 = v58;
    *(_WORD *)(v58 + 108) = v22;
    uint64_t v30 = *(NSObject **)(v58 + 32);
    uint64_t v7 = v57;
    unsigned int v5 = v56;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Update ReportHealthIssue Mask: 0x%hx", buf, 8u);
    }
    if ((v59 & 1) == 0) {
      goto LABEL_39;
    }
  }
  else
  {
    CFTypeID v32 = *v61;
    if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I CarrierSettings is not ready", buf, 2u);
    }
    *(_WORD *)(v3 + 108) = -1;
    if ((v17 & 1) == 0) {
LABEL_39:
    }
      sub_10004D2C8(v60);
  }
  if (v5 > 6) {
    goto LABEL_53;
  }
  if (((1 << v5) & 0x47) != 0)
  {
    *(_DWORD *)(v3 + 104) = 1;
    int v31 = *(NSObject **)(v3 + 16);
    *(void *)unsigned int v63 = v31;
    if (v31) {
      dispatch_retain(v31);
    }
    sub_101024944(0, (NSObject **)v63, v61);
  }
  else
  {
    if (((1 << v5) & 0x18) != 0)
    {
      *(_DWORD *)(v3 + 104) = 0;
      goto LABEL_53;
    }
    *(_DWORD *)(v3 + 104) = 2;
    long long v50 = *(NSObject **)(v3 + 16);
    *(void *)unsigned int v63 = v50;
    if (v50) {
      dispatch_retain(v50);
    }
    sub_101024944(1, (NSObject **)v63, v61);
  }
  if (*(void *)v63) {
    dispatch_release(*(dispatch_object_t *)v63);
  }
LABEL_53:
  CFDictionaryRef v33 = *v61;
  BOOL v34 = os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT);
  if (v34)
  {
    uint64_t v35 = *(int *)(v3 + 104);
    if (v35 > 2) {
      __int16 v36 = "???";
    }
    else {
      __int16 v36 = off_101A65450[v35];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v36;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Set Baseband FW health status to %s", buf, 0xCu);
  }
  uint64_t v37 = (capabilities::euicc *)capabilities::ct::supportsVinylFirmwareUpdate((capabilities::ct *)v34);
  if (!v37 || capabilities::euicc::supportsEOS(v37))
  {
    __int16 v38 = *v61;
    if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I EUICC Health check is not supported", buf, 2u);
    }
    sub_100E839F4(v3, 0);
    return;
  }
  uint64_t v39 = (std::mutex *)Registry::getServiceMap(*v7);
  __int16 v40 = v39;
  if (v41 < 0)
  {
    __int16 v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v43 = 5381;
    do
    {
      uint64_t v41 = v43;
      unsigned int v44 = *v42++;
      uint64_t v43 = (33 * v43) ^ v44;
    }
    while (v44);
  }
  std::mutex::lock(v39);
  *(void *)std::string buf = v41;
  long long v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
  if (v45)
  {
    uint64_t v47 = v45[3];
    __int16 v46 = (std::__shared_weak_count *)v45[4];
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v40);
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v46);
      char v48 = 0;
      if (!v47) {
        goto LABEL_70;
      }
LABEL_79:
      long long v51 = *(std::__shared_weak_count **)(v3 + 8);
      if (!v51 || (uint64_t v52 = *(void *)v3, (v53 = std::__shared_weak_count::lock(v51)) == 0)) {
        sub_100088B9C();
      }
      long long v54 = v53;
      p_uint64_t shared_weak_owners = &v53->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v53);
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_100E83AB4;
      int v67 = &unk_101A651E0;
      uint64_t v68 = v3;
      uint64_t v69 = v52;
      CFTypeRef v70 = v54;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, uint64_t, unsigned char *, void))(*(void *)v47 + 136))(v47, 1, buf, 0);
      if (v70) {
        std::__shared_weak_count::__release_weak(v70);
      }
      std::__shared_weak_count::__release_weak(v54);
      if ((v48 & 1) == 0) {
        goto LABEL_84;
      }
      return;
    }
  }
  else
  {
    uint64_t v47 = 0;
  }
  std::mutex::unlock(v40);
  __int16 v46 = 0;
  char v48 = 1;
  if (v47) {
    goto LABEL_79;
  }
LABEL_70:
  long long v49 = *v61;
  if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I VinylController is not ready", buf, 2u);
  }
  sub_100E839F4(v3, 0);
  if ((v48 & 1) == 0) {
LABEL_84:
  }
    sub_10004D2C8(v46);
}

void sub_100E83104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, dispatch_object_t object,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E831A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E83298(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 40));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    unsigned int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    unint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_41;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  unint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (!v10) {
    goto LABEL_41;
  }
LABEL_10:
  xpc_object_t v32 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v32 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v32 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v13) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v14 = xpc_null_create();
LABEL_17:
    xpc_object_t v32 = v14;
    goto LABEL_18;
  }
  xpc_retain(v13);
LABEL_18:
  xpc_release(v13);
  uint64_t v15 = *(int *)(v1 + 104);
  if (v15 > 2) {
    uint64_t v16 = "???";
  }
  else {
    uint64_t v16 = off_101A65450[v15];
  }
  xpc_object_t object = xpc_string_create(v16);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)std::string buf = &v32;
  uint64_t v29 = "BasebandDeadStatus";
  sub_100035E70((uint64_t)buf, &object, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v17 = *(int *)(v1 + 100);
  if (v17 > 2) {
    long long v18 = "???";
  }
  else {
    long long v18 = off_101A65450[v17];
  }
  xpc_object_t v26 = xpc_string_create(v18);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  *(void *)std::string buf = &v32;
  uint64_t v29 = "eUICCStatus";
  sub_100035E70((uint64_t)buf, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  uint64_t v19 = *(int *)(v1 + 96);
  if (v19 > 2) {
    float v20 = "???";
  }
  else {
    float v20 = off_101A65450[v19];
  }
  xpc_object_t v24 = xpc_string_create(v20);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  *(void *)std::string buf = &v32;
  uint64_t v29 = "RffeScanStatus";
  sub_100035E70((uint64_t)buf, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_object_t v22 = xpc_int64_create(*(int *)(v1 + 112));
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)std::string buf = &v32;
  uint64_t v29 = "ReportedDiagCode";
  sub_100035E70((uint64_t)buf, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  BOOL v21 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Submitting metric for Cellular Health status", buf, 2u);
  }
  *(void *)std::string buf = v32;
  if (v32) {
    xpc_retain(v32);
  }
  else {
    *(void *)std::string buf = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v10 + 16))(v10, "commCenterCellularHealthStatus", buf);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)std::string buf = 0;
  xpc_release(v32);
LABEL_41:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100E8364C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v17 - 56));
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E836C4(uint64_t a1)
{
  char v2 = capabilities::ct::supportsCellularHealthDiagnostics((capabilities::ct *)a1);
  uint64_t v3 = *(NSObject **)(a1 + 32);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if ((v2 & 1) == 0)
  {
    if (v4)
    {
      LOWORD(v14) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cellular Health Diagnostics is not supported", (uint8_t *)&v14, 2u);
    }
    uint64_t v11 = 4294967294;
    goto LABEL_25;
  }
  if (v4)
  {
    __int16 v5 = *(_WORD *)(a1 + 108);
    uint64_t v6 = radioStateAsString();
    int v8 = *(_DWORD *)(a1 + 96);
    int v7 = *(_DWORD *)(a1 + 100);
    int v14 = 33555458;
    LOWORD(v15) = v5;
    HIWORD(v15) = 2080;
    uint64_t v16 = v6;
    __int16 v17 = 1024;
    int v18 = v7;
    __int16 v19 = 1024;
    int v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ReportHealthIssueMask: 0x%hx, RadioState: %s, eUICCStatus: %d, RffeScanStatus:%d ", (uint8_t *)&v14, 0x1Cu);
  }
  __int16 v9 = *(_WORD *)(a1 + 108);
  if (!v9) {
    goto LABEL_24;
  }
  if ((v9 & 1) != 0 && *(_DWORD *)(a1 + 104) == 2)
  {
    uint64_t v10 = *(NSObject **)(a1 + 32);
    uint64_t v11 = 1;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 67109120;
      int v15 = 1;
      xpc_object_t v12 = "#I Radio State is Dead. Returning Diagnostics Status as %d";
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v14, 8u);
      goto LABEL_25;
    }
    goto LABEL_25;
  }
  if ((v9 & 2) == 0 || *(_DWORD *)(a1 + 100) != 2)
  {
    if ((v9 & 4) != 0)
    {
      uint64_t v10 = *(NSObject **)(a1 + 32);
      if (*(_DWORD *)(a1 + 96) == 2)
      {
        uint64_t v11 = 3;
        if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEFAULT))
        {
          int v14 = 67109120;
          int v15 = 3;
          xpc_object_t v12 = "#I RFFE Scan Data shows failure. Returning Diagnostics Status as %d";
          goto LABEL_21;
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v10 = *(NSObject **)(a1 + 32);
    }
    uint64_t v11 = 0;
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_25;
    }
    int v14 = 67109120;
    int v15 = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I No issue. Returning Diagnostics Status as %d", (uint8_t *)&v14, 8u);
LABEL_24:
    uint64_t v11 = 0;
    goto LABEL_25;
  }
  uint64_t v10 = *(NSObject **)(a1 + 32);
  uint64_t v11 = 2;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 67109120;
    int v15 = 2;
    xpc_object_t v12 = "#I eUICC CSN not available. Returning Diagnostics Status as %d";
    goto LABEL_21;
  }
LABEL_25:
  *(_DWORD *)(a1 + 112) = v11;
  return v11;
}

void sub_100E83934(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 96) = a2;
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      BOOL v4 = "???";
    }
    else {
      BOOL v4 = off_101A65450[a2];
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Set RFFEScan health status to %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100E839F4(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 100) = a2;
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      BOOL v4 = "???";
    }
    else {
      BOOL v4 = off_101A65450[a2];
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Set eUICC health status to %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100E83AB4(void *a1, const void **a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        v8[0] = 0;
        v8[1] = 0;
        sub_1000C6188(v8, a2);
        int v7 = *(std::__shared_weak_count **)(v5 + 8);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

uint64_t sub_100E83C10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E83C2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E83C3C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100E83D08(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_100E83DE0);
  __cxa_rethrow();
}

void sub_100E83D30(_Unwind_Exception *a1)
{
}

void sub_100E83D48(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E83D80(uint64_t a1)
{
}

uint64_t sub_100E83D9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E83DE0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    sub_100160AF8((atomic_uint **)(result + 88));
    uint64_t v2 = (std::__shared_weak_count *)v1[8];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[6];
    if (v3) {
      sub_10004D2C8(v3);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_100E83E5C()
{
}

__n128 sub_100E83E70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A65280;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E83EC4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A65280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E83EFC(void *a1, xpc *this, uint64_t a3)
{
  BOOL v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  *BOOL v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, uint64_t))(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_100E83F74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E83FB4()
{
}

uint64_t sub_100E83FC0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100E83FE8(void *a1)
{
  *a1 = off_101A65320;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E84034(void *a1)
{
  *a1 = off_101A65320;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100E840A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100E84150(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100E84168(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100E84188()
{
}

void *sub_100E841F4(void *a1)
{
  *a1 = off_101A65370;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100E84240(void *a1)
{
  *a1 = off_101A65370;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100E842AC()
{
}

void sub_100E84318(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100E84390(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100E843A4(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100E843F0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100E84444(uint64_t ***a1)
{
  uint64_t v1 = **a1;
  if (((_BYTE)(*a1)[1] & 0xFE) == 2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    sub_100068A94(&v10);
    uint64_t v2 = v10;
    if (v10)
    {
      uint64_t v3 = (std::__shared_weak_count *)v1[1];
      if (!v3 || (uint64_t v4 = *v1, (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v6 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
      int v14 = 0;
      uint64_t v7 = operator new(0x20uLL);
      void *v7 = off_101A653E0;
      v7[1] = v1;
      void v7[2] = v4;
      v7[3] = v6;
      int v14 = v7;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v2 + 96))(v2, buf);
      sub_10065C870(buf);
    }
    else
    {
      __int16 v9 = v1[4];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I RadioModule is not ready", buf, 2u);
      }
      sub_100E83934((uint64_t)v1, 0);
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    int v8 = v1[4];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v13 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Operating mode is %s, skip RFFEScanData check", buf, 0xCu);
    }
  }
  operator delete();
}

void sub_100E84634(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  sub_10065C870((uint64_t *)va);
  if (a4) {
    sub_10004D2C8(a4);
  }
  operator delete();
}

void *sub_100E84694(void *a1)
{
  *a1 = off_101A653E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E846E0(void *a1)
{
  *a1 = off_101A653E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100E8474C(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A653E0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E847B0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A653E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E847F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E84800(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E84840(void *a1, uint64_t a2, long long *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      if (a1[2])
      {
        sub_100A65D7C((uint64_t)&v9, a3);
        int v8 = *(std::__shared_weak_count **)(v6 + 8);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100E849D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E849E8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E84A28()
{
}

void sub_100E84A34(uint64_t **a1)
{
  int v8 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*((unsigned char *)v1 + 8))
  {
    if (*((unsigned char *)v1 + 60)) {
      unsigned int v3 = 1;
    }
    else {
      unsigned int v3 = 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  sub_100E83934(v2, v3);
  uint64_t v4 = (void *)v1[19];
  if (v4)
  {
    v1[20] = (uint64_t)v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)v1[16];
  if (v5)
  {
    v1[17] = (uint64_t)v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)v1[13];
  if (v6)
  {
    v1[14] = (uint64_t)v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)v1[10];
  if (v7)
  {
    v1[11] = (uint64_t)v7;
    operator delete(v7);
  }
  operator delete();
}

uint64_t *sub_100E84AE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  if (v3 == 2)
  {
    uint64_t v4 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to get eUICC info: %s", buf, 0xCu);
    }
LABEL_15:
    sub_100E839F4(v2, 0);
    goto LABEL_21;
  }
  *(void *)std::string buf = 0;
  if (v3 != 1)
  {
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
  }
  sub_100058198((const void **)buf, (const void **)(v1 + 16));
  if (*(void *)buf) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (!v6)
  {
    int v8 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(object[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I No eUICC FwUpdateData returned", (uint8_t *)object, 2u);
    }
    sub_100057D78((const void **)buf);
    goto LABEL_15;
  }
  ctu::cf_to_xpc((uint64_t *)object, *(ctu **)buf, v5);
  xpc_object_t v7 = object[0];
  if (object[0] && xpc_get_type(object[0]) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object[0]);
  if (xpc_dictionary_get_value(v7, kVinylFwUpdateCsn)) {
    unsigned int v9 = 1;
  }
  else {
    unsigned int v9 = 2;
  }
  sub_100E839F4(v2, v9);
  xpc_release(v7);
  sub_100057D78((const void **)buf);
LABEL_21:
  sub_100E84D60(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100E84CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  __cxa_free_exception(v13);
  sub_100E84D60(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E84D60(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 8) == 1) {
      sub_100057D78((const void **)(v1 + 16));
    }
    *(unsigned char *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

void sub_100E84DC0(PB::Base *this)
{
  *(void *)this = &off_101A65478;
  uint64_t v4 = *((void *)this + 2);
  uint64_t v2 = (void *)((char *)this + 16);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 8, v5);
  }

  PB::Base::~Base(this);
}

void sub_100E84E38(PB::Base *a1)
{
  sub_100E84DC0(a1);

  operator delete();
}

uint64_t sub_100E84E70(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 28)) {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 24));
  }
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100E84F00(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3) {
        operator new();
      }
      if (v20 == 2)
      {
        *(unsigned char *)(a1 + 28) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 > 0xFFFFFFFFFFFFFFF5 || v22 + 10 > v23)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v27 = 0;
          if (v23 <= v22) {
            unint64_t v23 = *((void *)this + 1);
          }
          while (1)
          {
            if (v23 == v22)
            {
              LODWORD(v27) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_45;
            }
            unint64_t v32 = v22 + 1;
            char v33 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v32;
            v27 |= (unint64_t)(v33 & 0x7F) << v30;
            if ((v33 & 0x80) == 0) {
              break;
            }
            v30 += 7;
            unint64_t v22 = v32;
            BOOL v14 = v31++ > 8;
            if (v14)
            {
LABEL_41:
              LODWORD(v27) = 0;
              goto LABEL_45;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v27) = 0;
          }
        }
        else
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          while (1)
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              break;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
            if (v14) {
              goto LABEL_41;
            }
          }
        }
LABEL_45:
        *(_DWORD *)(a1 + 24) = v27;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100E85210(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  if (*(void *)(result + 8)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(unsigned char *)(v3 + 28)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 24), 2u);
  }
  if (*(void *)(v3 + 16))
  {
    return PB::Writer::write();
  }
  return result;
}

void sub_100E8528C(uint64_t a1)
{
  *(void *)a1 = off_101A654C8;
  sub_10005CD2C(a1 + 80, *(char **)(a1 + 88));
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  PersonalWallet::~PersonalWallet((PersonalWallet *)a1);
}

void sub_100E85314(uint64_t a1)
{
  sub_100E8528C(a1);

  operator delete();
}

void sub_100E8534C()
{
}

void sub_100E85710()
{
}

void sub_100E857A4(_Unwind_Exception *a1)
{
}

void sub_100E857B8(uint64_t a1, ...)
{
  va_start(va1, a1);
  va_start(va, a1);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  PersonalWallet::~PersonalWallet(v1);
  operator delete();
}

const void **sub_100E85830(uint64_t a1, uint64_t a2, const __CFString *a3, char **a4)
{
  uint64_t v18 = 0;
  unsigned __int8 v19 = 0;
  unint64_t v20 = 0;
  sub_100E85A80((uint64_t)&v18, a1, a2, a3, 0, a4);
  char v9 = v19;
  uint64_t v8 = v20;
  unsigned int v26 = 0;
  sub_100E863DC(&v26, a2);
  unsigned int v10 = v26;
  unint64_t v11 = operator new(0x18uLL);
  uint64_t v12 = (uint64_t)(v11 + 3);
  uint64_t v24 = (uint64_t)(v11 + 3);
  char v25 = v11 + 3;
  *unint64_t v11 = @"PersonalWallet";
  v11[1] = v10;
  v11[2] = @"s";
  unint64_t v22 = 0;
  std::string __p = v11;
  uint64_t v21 = 0;
  sub_1000810C0(0, 1, (uint64_t)&v21);
  if (!(_BYTE)v21)
  {
    char v13 = v22;
    if (v22 ? sub_1000810B8 : 0)
    {
      char v15 = operator new(0x30uLL);
      *(_OWORD *)char v15 = *(_OWORD *)v11;
      dispatch_object_t v15[2] = v11[2];
      v15[3] = v13;
      uint64_t v12 = (uint64_t)(v15 + 4);
      std::string __p = v15;
      char v25 = v15 + 6;
      operator delete(v11);
      uint64_t v24 = v12;
    }
  }
  sub_100083ACC((uint64_t)&__p, v12, *a4, a4[1], (a4[1] - *a4) >> 3);
  sub_100082674(*(void *)(a1 + 64), a3, v9, 0, (char **)&__p, 1u, v8, @"PWallet");
  sub_1000558F4(&v22);
  if (__p)
  {
    uint64_t v24 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&v26);
  if (v19) {
    unsigned int v16 = sub_100080934;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16) {
    sub_100E85DB4(a1, a2, a3, 0, a4);
  }
  sub_1000577C4(&v20);
  return sub_1000577C4(&v19);
}

void sub_100E85A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10, const void **a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, const void *a20)
{
  sub_1000558F4(v20);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a20);
  sub_1000577C4(a10);
  sub_1000577C4(a11);
  _Unwind_Resume(a1);
}

const void **sub_100E85A80(uint64_t a1, uint64_t a2, uint64_t a3, const __CFString *a4, const __CFString *a5, char **a6)
{
  unint64_t v23 = 0;
  sub_100E863DC(&v23, a3);
  unint64_t v11 = v23;
  uint64_t v12 = operator new(0x10uLL);
  uint64_t v13 = (uint64_t)(v12 + 2);
  uint64_t v21 = (uint64_t)(v12 + 2);
  unint64_t v22 = v12 + 2;
  *uint64_t v12 = @"PersonalWallet";
  v12[1] = v11;
  unsigned __int8 v19 = 0;
  std::string __p = v12;
  uint64_t v18 = 0;
  sub_1000810C0(a5, 1, (uint64_t)&v18);
  if ((_BYTE)v18)
  {
LABEL_7:
    if (!a6) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  BOOL v14 = v19;
  if (v19) {
    char v15 = sub_1000810B8;
  }
  else {
    char v15 = 0;
  }
  if (v15)
  {
    unsigned int v16 = operator new(0x20uLL);
    unint64_t v16[2] = v14;
    uint64_t v13 = (uint64_t)(v16 + 3);
    *(_OWORD *)unsigned int v16 = *(_OWORD *)v12;
    std::string __p = v16;
    unint64_t v22 = v16 + 4;
    operator delete(v12);
    a5 = 0;
    uint64_t v21 = v13;
    goto LABEL_7;
  }
  a5 = 0;
  if (a6) {
LABEL_8:
  }
    sub_100083ACC((uint64_t)&__p, v13, *a6, a6[1], (a6[1] - *a6) >> 3);
LABEL_9:
  sub_100082B50(*(void *)(a2 + 64), a4, a5, (char **)&__p, 1u, a1);
  sub_1000558F4(&v19);
  if (__p)
  {
    uint64_t v21 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v23);
}

void sub_100E85BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E85C2C(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t result = (const void **)isReal();
  if (result)
  {
    uint64_t v18 = 0;
    sub_100E863DC(&v18, a2);
    xpc_object_t v7 = v18;
    uint64_t v8 = operator new(0x10uLL);
    unsigned int v16 = v8 + 2;
    unint64_t v17 = v8 + 2;
    void *v8 = @"PersonalWallet";
    v8[1] = v7;
    BOOL v14 = 0;
    std::string __p = v8;
    uint64_t v13 = 0;
    sub_1000810C0(0, 1, (uint64_t)&v13);
    if (!(_BYTE)v13)
    {
      char v9 = v14;
      if (v14 ? sub_1000810B8 : 0)
      {
        unint64_t v11 = operator new(0x20uLL);
        v11[2] = v9;
        uint64_t v12 = (char *)(v11 + 3);
        *(_OWORD *)unint64_t v11 = *(_OWORD *)v8;
        std::string __p = v11;
        unint64_t v17 = v11 + 4;
        operator delete(v8);
        unsigned int v16 = v12;
      }
    }
    sub_100082674(*(void *)(a1 + 64), @"homeIMSI", a3, 0, (char **)&__p, 1u, 0, @"PWallet");
    sub_1000558F4(&v14);
    if (__p)
    {
      unsigned int v16 = __p;
      operator delete(__p);
    }
    return sub_1000558F4(&v18);
  }
  return result;
}

void sub_100E85D70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E85DB4(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, char **a5)
{
  uint64_t v21 = 0;
  sub_100E863DC(&v21, a2);
  char v9 = v21;
  unsigned int v10 = operator new(0x10uLL);
  uint64_t v11 = (uint64_t)(v10 + 2);
  uint64_t v19 = (uint64_t)(v10 + 2);
  unint64_t v20 = v10 + 2;
  void *v10 = @"PersonalWallet";
  v10[1] = v9;
  unint64_t v17 = 0;
  std::string __p = v10;
  uint64_t v16 = 0;
  sub_1000810C0(a4, 1, (uint64_t)&v16);
  if ((_BYTE)v16)
  {
LABEL_7:
    if (!a5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v12 = v17;
  if (v17) {
    uint64_t v13 = sub_1000810B8;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    BOOL v14 = operator new(0x20uLL);
    void v14[2] = v12;
    uint64_t v11 = (uint64_t)(v14 + 3);
    *(_OWORD *)BOOL v14 = *(_OWORD *)v10;
    std::string __p = v14;
    unint64_t v20 = v14 + 4;
    operator delete(v10);
    a4 = 0;
    uint64_t v19 = v11;
    goto LABEL_7;
  }
  a4 = 0;
  if (a5) {
LABEL_8:
  }
    sub_100083ACC((uint64_t)&__p, v11, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_9:
  sub_100083338(*(void *)(a1 + 64), a3, a4, (char **)&__p, 1u);
  sub_1000558F4(&v17);
  if (__p)
  {
    uint64_t v19 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v21);
}

void sub_100E85F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

void sub_100E85F54(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E86054(uint64_t a1, uint64_t a2)
{
  v4[0] = a2;
  v4[1] = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100E89DB4;
  block[3] = &unk_101A65778;
  void block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100E860DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  uint64_t v7 = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100E89EBC;
  block[3] = &unk_101A65798;
  void block[4] = v3;
  block[5] = __p;
  int v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

const void **sub_100E861A8(uint64_t a1, uint64_t a2)
{
  CFStringRef v26 = 0;
  sub_100E863DC(&v26, a2);
  uint64_t v3 = (os_unfair_lock_s *)(*(void *)(a1 + 64) + 32);
  os_unfair_lock_lock(v3);
  int v4 = (char *)operator new(8uLL);
  unsigned int v5 = 0;
  std::string __p = v4;
  *(void *)int v4 = @"PersonalWallet";
  uint64_t v24 = v4 + 8;
  char v25 = v4 + 8;
  do
  {
    CFStringRef v21 = 0;
    unint64_t v22 = 0;
    sub_1000811C4(*(void *)(a1 + 64), v5, &v21);
    isa = (const __CFString **)v21->isa;
    info = (const __CFString **)v21->info;
    while (isa != info)
      sub_100083338(*(void *)(a1 + 64), v26, *isa++, (char **)&__p, v5);
    if (v22) {
      sub_10004D2C8(v22);
    }
    ++v5;
  }
  while (v5 != 4);
  CFStringRef v8 = v26;
  char v9 = v24;
  if (v24 >= v25)
  {
    uint64_t v11 = (v24 - (unsigned char *)__p) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      sub_10006A748();
    }
    unint64_t v12 = (v25 - (unsigned char *)__p) >> 2;
    if (v12 <= v11 + 1) {
      unint64_t v12 = v11 + 1;
    }
    if ((unint64_t)(v25 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      BOOL v14 = (char *)sub_10004EF74((uint64_t)&v25, v13);
    }
    else {
      BOOL v14 = 0;
    }
    char v15 = (const __CFString **)&v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    *char v15 = v8;
    unsigned int v10 = (char *)(v15 + 1);
    uint64_t v18 = (char *)__p;
    unint64_t v17 = v24;
    if (v24 != __p)
    {
      do
      {
        CFStringRef v19 = (const __CFString *)*((void *)v17 - 1);
        v17 -= 8;
        *--char v15 = v19;
      }
      while (v17 != v18);
      unint64_t v17 = (char *)__p;
    }
    std::string __p = v15;
    uint64_t v24 = v10;
    char v25 = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *(void *)uint64_t v24 = v26;
    unsigned int v10 = v9 + 8;
  }
  uint64_t v24 = v10;
  CFStringRef v21 = 0;
  sub_100080968((const void ***)&__p, &v21);
  sub_100E8655C(a1, v21, 0);
  sub_1000558F4((const void **)&v21);
  if (__p)
  {
    uint64_t v24 = (char *)__p;
    operator delete(__p);
  }
  os_unfair_lock_unlock(v3);
  return sub_1000558F4((const void **)&v26);
}

void sub_100E8637C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  if (__p) {
    operator delete(__p);
  }
  os_unfair_lock_unlock(v14);
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

void sub_100E863DC(void *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v4, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v5) < 0)
  {
    sub_10004FC84(__dst, v4[0], (unint64_t)v4[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v4;
    uint64_t v8 = v5;
  }
  uint64_t v6 = 0;
  if (SHIBYTE(v8) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v10 = v8;
  }
  uint64_t v11 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v3 = v6;
    uint64_t v6 = v11;
    unint64_t v12 = v3;
    sub_1000558F4(&v12);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  *a1 = v6;
  uint64_t v6 = 0;
  sub_1000558F4(&v6);
  if (SHIBYTE(v8) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v5) < 0) {
    operator delete(v4[0]);
  }
}

void sub_100E86508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_100E8655C(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v4 = a1 + 48;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (!sub_1000C02E0(a1 + 48, 0, a2, (const void ***)&v7))
  {
    uint64_t v5 = v7;
    uint64_t v6 = v8;
    while (v5 != v6)
    {
      if (!a3 || !CFStringHasPrefix((CFStringRef)*v5, a3)) {
        sub_1000C0E74(v4, *v5);
      }
      ++v5;
    }
  }
  uint64_t v10 = (const void ***)&v7;
  sub_100084178((void ***)&v10);
}

void sub_100E865F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100084178(&a12);
  _Unwind_Resume(a1);
}

void sub_100E86614(uint64_t a1, const __CFString *a2)
{
  uint64_t v3 = a1 + 48;
  char v25 = 0;
  CFStringRef v26 = 0;
  uint64_t v27 = 0;
  if (!sub_1000C02E0(a1 + 48, 0, a2, (const void ***)&v25))
  {
    std::string::size_type Length = CFStringGetLength(a2);
    memset(&v30, 0, sizeof(v30));
    ctu::cf::assign();
    std::string v24 = v30;
    uint64_t v5 = v25;
    uint64_t v6 = (void **)v26;
    if (v25 != (void **)v26)
    {
      while (1)
      {
        unint64_t v22 = 0;
        unint64_t v23 = 0;
        CFStringRef v21 = 0;
        if (!sub_1000BF024(v3, *v5, (uint64_t *)&v23, (uint64_t *)&v22, (uint64_t *)&v21)) {
          break;
        }
LABEL_33:
        sub_1000C0E74(v3, *v5);
        sub_1000558F4(&v21);
        sub_100030068(&v22);
        sub_100030068(&v23);
        if (++v5 == v6) {
          goto LABEL_38;
        }
      }
      memset(&__str, 0, sizeof(__str));
      memset(&v30, 0, sizeof(v30));
      ctu::cf::assign();
      std::string __str = v30;
      std::string::size_type size = v30.__r_.__value_.__l.__size_;
      char v8 = HIBYTE(v30.__r_.__value_.__r.__words[2]);
      if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      if (size <= Length)
      {
LABEL_31:
        if (v8 < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_33;
      }
      uint64_t v9 = std::string::basic_string(&v30, &__str, Length, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v10 = &v24;
      }
      else {
        uint64_t v10 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v11 = HIBYTE(v24.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v11 = v24.__r_.__value_.__l.__size_;
      }
      unint64_t v12 = std::string::insert(v9, 0, (const std::string::value_type *)v10, v11);
      unint64_t v13 = (void *)v12->__r_.__value_.__r.__words[0];
      std::string::size_type v14 = v12->__r_.__value_.__l.__size_;
      v19[0] = v12->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v19 + 3) = *(_DWORD *)((char *)&v12->__r_.__value_.__r.__words[2] + 3);
      int v15 = SHIBYTE(v12->__r_.__value_.__r.__words[2]);
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v30.__r_.__value_.__l.__data_);
        if ((v15 & 0x80000000) == 0) {
          goto LABEL_15;
        }
      }
      else if ((v15 & 0x80000000) == 0)
      {
LABEL_15:
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
        __dst.__r_.__value_.__l.__size_ = v14;
        LODWORD(__dst.__r_.__value_.__r.__words[2]) = v19[0];
        *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v19 + 3);
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v15;
        goto LABEL_18;
      }
      sub_10004FC84(&__dst, v13, v14);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
LABEL_19:
        unint64_t v28 = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v30, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else {
          std::string v30 = __p;
        }
        unsigned int v31 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v16 = v28;
          unint64_t v28 = v31;
          unint64_t v32 = v16;
          sub_1000558F4(&v32);
        }
        if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v30.__r_.__value_.__l.__data_);
        }
        uint64_t v18 = (void *)v28;
        unint64_t v28 = 0;
        sub_1000558F4(&v28);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        sub_1000C07FC(v3, v18, &v23, &v22, v21);
        sub_1000558F4((const void **)&v18);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
          if ((v15 & 0x80000000) == 0) {
            goto LABEL_30;
          }
        }
        else if ((v15 & 0x80000000) == 0)
        {
LABEL_30:
          char v8 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          goto LABEL_31;
        }
        operator delete(v13);
        goto LABEL_30;
      }
LABEL_18:
      std::string __p = __dst;
      goto LABEL_19;
    }
LABEL_38:
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
  }
  v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v25;
  sub_100084178((void ***)&v30);
}

void sub_100E8694C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,const void *a25,const void *a26,char *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v44 < 0) {
    operator delete(v43);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_1000558F4(&a24);
  sub_100030068(&a25);
  sub_100030068(&a26);
  if (a32 < 0) {
    operator delete(a27);
  }
  a27 = &a34;
  sub_100084178((void ***)&a27);
  _Unwind_Resume(a1);
}

void sub_100E86A6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v8) {
      uint64_t v9 = *(const char **)a2;
    }
    else {
      uint64_t v9 = (const char *)a2;
    }
    if (v7) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = "<invalid>";
    }
    uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
    BOOL v12 = (v11 & 0x80u) != 0;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a3 + 8);
    }
    if (v12) {
      unint64_t v13 = *(const char **)a3;
    }
    else {
      unint64_t v13 = (const char *)a3;
    }
    if (v11) {
      std::string::size_type v14 = v13;
    }
    else {
      std::string::size_type v14 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I renaming wallet %s to %s", buf, 0x16u);
  }
  if (isReal() && isReal())
  {
    CFStringRef v42 = 0;
    sub_100E863DC(&v42, a2);
    CFStringRef v41 = 0;
    sub_100E863DC(&v41, a3);
    int v15 = (os_unfair_lock_s *)(*(void *)(a1 + 64) + 32);
    os_unfair_lock_lock(v15);
    uint64_t v16 = operator new(8uLL);
    unsigned int v17 = 0;
    *(void *)std::string buf = v16;
    *uint64_t v16 = @"PersonalWallet";
    *(void *)&uint8_t buf[8] = v16 + 1;
    *(void *)&uint8_t buf[16] = v16 + 1;
    do
    {
      std::string __p = 0;
      __int16 v36 = 0;
      sub_1000811C4(*(void *)(a1 + 64), v17, &__p);
      uint64_t v18 = *(const __CFString ***)__p;
      CFStringRef v19 = (const __CFString **)*((void *)__p + 1);
      while (v18 != v19)
      {
        __int16 v38 = 0;
        uint64_t v39 = 0;
        __int16 v40 = 0;
        sub_100082B50(*(void *)(a1 + 64), v42, *v18, (char **)buf, v17, (uint64_t)&v38);
        sub_100082674(*(void *)(a1 + 64), v41, v39, *v18, (char **)buf, v17, 0, 0);
        sub_100083338(*(void *)(a1 + 64), v42, *v18, (char **)buf, v17);
        sub_1000577C4(&v40);
        sub_1000577C4((const void **)&v39);
        ++v18;
      }
      if (v36) {
        sub_10004D2C8(v36);
      }
      ++v17;
    }
    while (v17 != 4);
    CFStringRef v20 = v42;
    CFStringRef v21 = operator new(0x10uLL);
    uint64_t v39 = v21 + 2;
    __int16 v40 = v21 + 2;
    void *v21 = @"PersonalWallet";
    v21[1] = v20;
    __int16 v38 = v21;
    CFStringRef v22 = v41;
    unint64_t v23 = (char *)operator new(0x10uLL);
    __int16 v36 = (std::__shared_weak_count *)(v23 + 16);
    uint64_t v37 = v23 + 16;
    *(void *)unint64_t v23 = @"PersonalWallet";
    *((void *)v23 + 1) = v22;
    CFStringRef v34 = 0;
    std::string __p = v23;
    sub_100080968((const void ***)&v38, &v34);
    char v33 = 0;
    sub_100080968((const void ***)&__p, (CFStringRef *)&v33);
    sub_100E86614(a1, v34);
    sub_1000558F4(&v33);
    sub_1000558F4((const void **)&v34);
    if (__p)
    {
      __int16 v36 = (std::__shared_weak_count *)__p;
      operator delete(__p);
    }
    if (v38)
    {
      uint64_t v39 = v38;
      operator delete(v38);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    os_unfair_lock_unlock(v15);
    sub_1000558F4((const void **)&v41);
    sub_1000558F4((const void **)&v42);
  }
  else
  {
    std::string v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = *(unsigned __int8 *)(a2 + 23);
      BOOL v26 = (v25 & 0x80u) != 0;
      if ((v25 & 0x80u) != 0) {
        uint64_t v25 = *(void *)(a2 + 8);
      }
      if (v26) {
        uint64_t v27 = *(const char **)a2;
      }
      else {
        uint64_t v27 = (const char *)a2;
      }
      if (v25) {
        unint64_t v28 = v27;
      }
      else {
        unint64_t v28 = "<invalid>";
      }
      uint64_t v29 = *(unsigned __int8 *)(a3 + 23);
      BOOL v30 = (v29 & 0x80u) != 0;
      if ((v29 & 0x80u) != 0) {
        uint64_t v29 = *(void *)(a3 + 8);
      }
      if (v30) {
        unsigned int v31 = *(const char **)a3;
      }
      else {
        unsigned int v31 = (const char *)a3;
      }
      if (v29) {
        unint64_t v32 = v31;
      }
      else {
        unint64_t v32 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v28;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v32;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#E cannot renameWallet since FROM '%s' or TO '%s' is invalid", buf, 0x16u);
    }
  }
}

void sub_100E86E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, const void *a17, const void *a18, void *a19, uint64_t a20)
{
  sub_1000558F4((const void **)&a9);
  sub_1000558F4(&a10);
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a14)
  {
    a15 = (uint64_t)a14;
    operator delete(a14);
  }
  if (a19)
  {
    a20 = (uint64_t)a19;
    operator delete(a19);
  }
  os_unfair_lock_unlock(v20);
  sub_1000558F4(&a17);
  sub_1000558F4(&a18);
  _Unwind_Resume(a1);
}

void sub_100E86ED0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v8) {
      uint64_t v9 = *(const char **)a2;
    }
    else {
      uint64_t v9 = (const char *)a2;
    }
    if (v7) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = "<invalid>";
    }
    uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
    BOOL v12 = (v11 & 0x80u) != 0;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a3 + 8);
    }
    if (v12) {
      unint64_t v13 = *(const char **)a3;
    }
    else {
      unint64_t v13 = (const char *)a3;
    }
    if (v11) {
      std::string::size_type v14 = v13;
    }
    else {
      std::string::size_type v14 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I transferring wallet %s to %s", buf, 0x16u);
  }
  if (isReal() && isReal())
  {
    unsigned int v63 = 0;
    sub_100E863DC(&v63, a2);
    uint64_t v62 = 0;
    sub_100E863DC(&v62, a3);
    int v15 = (os_unfair_lock_s *)(a1[8] + 32);
    os_unfair_lock_lock(v15);
    uint64_t v16 = v63;
    unsigned int v17 = operator new(0x10uLL);
    *(void *)&uint8_t buf[8] = v17 + 2;
    *(void *)&uint8_t buf[16] = v17 + 2;
    void *v17 = @"PersonalWallet";
    v17[1] = v16;
    *(void *)std::string buf = v17;
    uint64_t v18 = v62;
    CFStringRef v19 = (char *)operator new(0x10uLL);
    unsigned __int16 v60 = v19 + 16;
    int v61 = v19 + 16;
    *(void *)CFStringRef v19 = @"PersonalWallet";
    *((void *)v19 + 1) = v18;
    unsigned int v20 = 1;
    std::string __p = v19;
    do
    {
      unsigned __int16 v57 = 0;
      uint64_t v58 = 0;
      sub_1000811C4(a1[8], v20, &v57);
      CFStringRef v22 = *v57;
      CFStringRef v21 = v57[1];
      while (v22 != v21)
      {
        CFStringRef v54 = 0;
        long long v55 = 0;
        unsigned int v56 = 0;
        sub_100082B50(a1[8], @"s", *v22, (char **)buf, v20, (uint64_t)&v54);
        sub_100082674(a1[8], @"s", v55, *v22, (char **)&__p, v20, 0, 0);
        sub_1000577C4(&v56);
        sub_1000577C4(&v55);
        ++v22;
      }
      if (v58) {
        sub_10004D2C8(v58);
      }
      ++v20;
    }
    while (v20 != 4);
    uint64_t v23 = *(void *)&buf[8];
    if (*(void *)&buf[8] >= *(void *)&buf[16])
    {
      uint64_t v34 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
      if ((unint64_t)(v34 + 1) >> 61) {
        goto LABEL_84;
      }
      unint64_t v35 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2;
      if (v35 <= v34 + 1) {
        unint64_t v35 = v34 + 1;
      }
      if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFF8uLL) {
        unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v35;
      }
      if (v36) {
        uint64_t v37 = (char *)sub_10004EF74((uint64_t)&buf[16], v36);
      }
      else {
        uint64_t v37 = 0;
      }
      __int16 v38 = &v37[8 * v34];
      uint64_t v39 = &v37[8 * v36];
      *(void *)__int16 v38 = @"s";
      std::string v24 = v38 + 8;
      CFStringRef v41 = *(char **)buf;
      __int16 v40 = *(char **)&buf[8];
      if (*(void *)&buf[8] != *(void *)buf)
      {
        do
        {
          uint64_t v42 = *((void *)v40 - 1);
          v40 -= 8;
          *((void *)v38 - 1) = v42;
          v38 -= 8;
        }
        while (v40 != v41);
        __int16 v40 = *(char **)buf;
      }
      *(void *)std::string buf = v38;
      *(void *)&uint8_t buf[8] = v24;
      *(void *)&uint8_t buf[16] = v39;
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      **(void **)&uint8_t buf[8] = @"s";
      std::string v24 = (void *)(v23 + 8);
    }
    *(void *)&uint8_t buf[8] = v24;
    uint64_t v43 = v60;
    if (v60 < v61)
    {
      *(void *)unsigned __int16 v60 = @"s";
      int v44 = v43 + 8;
LABEL_78:
      unsigned __int16 v60 = v44;
      CFStringRef v54 = 0;
      sub_100080968((const void ***)buf, &v54);
      unsigned __int16 v57 = 0;
      sub_100080968((const void ***)&__p, (CFStringRef *)&v57);
      sub_100E86614((uint64_t)a1, v54);
      sub_1000558F4((const void **)&v57);
      sub_1000558F4((const void **)&v54);
      if (__p)
      {
        unsigned __int16 v60 = (char *)__p;
        operator delete(__p);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      os_unfair_lock_unlock(v15);
      (*(void (**)(void *, uint64_t))(*a1 + 112))(a1, a2);
      sub_1000558F4(&v62);
      sub_1000558F4(&v63);
      return;
    }
    uint64_t v45 = (v60 - (unsigned char *)__p) >> 3;
    if (!((unint64_t)(v45 + 1) >> 61))
    {
      unint64_t v46 = (v61 - (unsigned char *)__p) >> 2;
      if (v46 <= v45 + 1) {
        unint64_t v46 = v45 + 1;
      }
      if ((unint64_t)(v61 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v47 = v46;
      }
      if (v47) {
        char v48 = (char *)sub_10004EF74((uint64_t)&v61, v47);
      }
      else {
        char v48 = 0;
      }
      long long v49 = &v48[8 * v45];
      long long v50 = &v48[8 * v47];
      *(void *)long long v49 = @"s";
      int v44 = v49 + 8;
      uint64_t v52 = (char *)__p;
      long long v51 = v60;
      if (v60 != __p)
      {
        do
        {
          uint64_t v53 = *((void *)v51 - 1);
          v51 -= 8;
          *((void *)v49 - 1) = v53;
          v49 -= 8;
        }
        while (v51 != v52);
        long long v51 = (char *)__p;
      }
      std::string __p = v49;
      unsigned __int16 v60 = v44;
      int v61 = v50;
      if (v51) {
        operator delete(v51);
      }
      goto LABEL_78;
    }
LABEL_84:
    sub_10006A748();
  }
  uint64_t v25 = a1[5];
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = *(unsigned __int8 *)(a2 + 23);
    BOOL v27 = (v26 & 0x80u) != 0;
    if ((v26 & 0x80u) != 0) {
      uint64_t v26 = *(void *)(a2 + 8);
    }
    if (v27) {
      unint64_t v28 = *(const char **)a2;
    }
    else {
      unint64_t v28 = (const char *)a2;
    }
    if (v26) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = "<invalid>";
    }
    uint64_t v30 = *(unsigned __int8 *)(a3 + 23);
    BOOL v31 = (v30 & 0x80u) != 0;
    if ((v30 & 0x80u) != 0) {
      uint64_t v30 = *(void *)(a3 + 8);
    }
    if (v31) {
      unint64_t v32 = *(const char **)a3;
    }
    else {
      unint64_t v32 = (const char *)a3;
    }
    if (v30) {
      char v33 = v32;
    }
    else {
      char v33 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v29;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v33;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#E cannot transferWallet since FROM '%s' or TO '%s' is invalid", buf, 0x16u);
  }
}

void sub_100E873D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, const void *a19, const void *a20,void *a21,uint64_t a22)
{
}

void sub_100E87498(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
    BOOL v6 = (v5 & 0x80u) != 0;
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *(void *)(a2 + 8);
    }
    if (v6) {
      uint64_t v7 = *(const char **)a2;
    }
    else {
      uint64_t v7 = (const char *)a2;
    }
    if (v5) {
      BOOL v8 = v7;
    }
    else {
      BOOL v8 = "<invalid>";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I delete non-transferrable wallet part for %s", (uint8_t *)&buf, 0xCu);
  }
  if (isReal())
  {
    CFStringRef v33 = 0;
    sub_100E863DC(&v33, a2);
    uint64_t v9 = (os_unfair_lock_s *)(*(void *)(a1 + 64) + 32);
    os_unfair_lock_lock(v9);
    uint64_t v10 = operator new(8uLL);
    *(void *)&long long buf = v10;
    void *v10 = @"PersonalWallet";
    *((void *)&buf + 1) = v10 + 1;
    unint64_t v35 = v10 + 1;
    CFStringRef v11 = v33;
    BOOL v12 = operator new(0x10uLL);
    BOOL v31 = v12 + 2;
    unint64_t v32 = v12 + 2;
    *BOOL v12 = @"PersonalWallet";
    v12[1] = v11;
    uint64_t v30 = v12;
    unint64_t v13 = operator new(0x18uLL);
    unint64_t v28 = v13 + 3;
    uint64_t v29 = v13 + 3;
    void *v13 = @"PersonalWallet";
    v13[1] = v11;
    v13[2] = @"s";
    std::string __p = v13;
    for (unsigned int i = 1; i != 4; ++i)
    {
      CFStringRef v25 = 0;
      uint64_t v26 = 0;
      sub_1000811C4(*(void *)(a1 + 64), i, &v25);
      isa = (const __CFString **)v25->isa;
      info = (const __CFString **)v25->info;
      while (isa != info)
      {
        CFStringRef v22 = 0;
        uint64_t v23 = 0;
        std::string v24 = 0;
        sub_100082B50(*(void *)(a1 + 64), @"s", *isa, (char **)&v30, i, (uint64_t)&v22);
        sub_100083338(*(void *)(a1 + 64), v33, *isa, (char **)&buf, i);
        sub_100082674(*(void *)(a1 + 64), @"s", v23, *isa, (char **)&v30, i, 0, 0);
        sub_1000577C4(&v24);
        sub_1000577C4(&v23);
        ++isa;
      }
      if (v26) {
        sub_10004D2C8(v26);
      }
    }
    CFStringRef v22 = 0;
    sub_100080968((const void ***)&v30, &v22);
    CFStringRef v25 = 0;
    sub_100080968((const void ***)&__p, &v25);
    sub_100E8655C(a1, v22, v25);
    sub_1000558F4((const void **)&v25);
    sub_1000558F4((const void **)&v22);
    if (__p)
    {
      unint64_t v28 = __p;
      operator delete(__p);
    }
    if (v30)
    {
      BOOL v31 = v30;
      operator delete(v30);
    }
    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    os_unfair_lock_unlock(v9);
    sub_1000558F4((const void **)&v33);
  }
  else
  {
    unsigned int v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
      BOOL v19 = (v18 & 0x80u) != 0;
      if ((v18 & 0x80u) != 0) {
        uint64_t v18 = *(void *)(a2 + 8);
      }
      if (v19) {
        unsigned int v20 = *(const char **)a2;
      }
      else {
        unsigned int v20 = (const char *)a2;
      }
      if (v18) {
        CFStringRef v21 = v20;
      }
      else {
        CFStringRef v21 = "<invalid>";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E deleteNonTransferrableWalletPart, persona '%s' is invalid - ignore", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_100E877C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, const void *a20,void *a21,uint64_t a22)
{
  sub_1000558F4(&a12);
  sub_1000558F4((const void **)&a9);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  os_unfair_lock_unlock(v22);
  sub_1000558F4(&a20);
  _Unwind_Resume(a1);
}

void sub_100E87884(os_unfair_lock_s **a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  (*(void (**)(uint64_t *__return_ptr))&(*a1)[20]._os_unfair_lock_opaque)(&v4);
  uint64_t v2 = v4;
  uint64_t v3 = v5;
  while (v2 != v3)
  {
    (*(void (**)(os_unfair_lock_s **, uint64_t))&(*a1)[28]._os_unfair_lock_opaque)(a1, v2);
    v2 += 24;
  }
  sub_1000832B0(a1[8], @"unique-sim-label-store", 0, 0, 0);
  uint64_t v7 = (void **)&v4;
  sub_100047F64(&v7);
}

void sub_100E87954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100047F64(&a12);
  _Unwind_Resume(a1);
}

const void **sub_100E87974@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  CFDictionaryRef theDict = 0;
  sub_100083254(*(os_unfair_lock_s **)(a1 + 64), @"PersonalWallet", 0, 0, a2, &v29);
  sub_10004EFE4(&theDict, (CFTypeRef *)&v29);
  sub_1000577C4((const void **)&v29);
  if (theDict) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    keys = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    sub_10004EE3C(&keys, Count);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, 0);
    uint64_t v6 = keys;
    uint64_t v7 = v26;
    if (keys != v26)
    {
      while (1)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        BOOL v31 = 0;
        ctu::cf::assign();
        BOOL v8 = v29;
        int v22 = (int)v31;
        HIBYTE(v22) = BYTE3(v31);
        int v9 = SHIBYTE(v31);
        if (SHIBYTE(v31) < 0)
        {
          sub_10004FC84(__p, v29, (unint64_t)v30);
        }
        else
        {
          __p[0] = v29;
          __p[1] = v30;
          LODWORD(v24) = v22;
          *(_DWORD *)((char *)&v24 + 3) = *(_DWORD *)((char *)&v31 + 3);
          HIBYTE(v24) = HIBYTE(v31);
        }
        unint64_t v11 = a3[1];
        unint64_t v10 = a3[2];
        if (v11 >= v10)
        {
          unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a3) >> 3);
          unint64_t v14 = v13 + 1;
          if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A748();
          }
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *a3) >> 3);
          if (2 * v15 > v14) {
            unint64_t v14 = 2 * v15;
          }
          if (v15 >= 0x555555555555555) {
            unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v14;
          }
          CFStringRef v33 = a3 + 2;
          if (v16) {
            unsigned int v17 = (char *)sub_10004812C((uint64_t)(a3 + 2), v16);
          }
          else {
            unsigned int v17 = 0;
          }
          BOOL v19 = &v17[24 * v13];
          uint64_t v29 = v17;
          uint64_t v30 = v19;
          BOOL v31 = v19;
          unint64_t v32 = &v17[24 * v16];
          if (SHIBYTE(v24) < 0)
          {
            sub_10004FC84(v19, __p[0], (unint64_t)__p[1]);
            BOOL v19 = v31;
          }
          else
          {
            long long v20 = *(_OWORD *)__p;
            *((void *)v19 + 2) = v24;
            *(_OWORD *)BOOL v19 = v20;
          }
          BOOL v31 = v19 + 24;
          sub_100320734(a3, &v29);
          uint64_t v18 = a3[1];
          sub_100048174((uint64_t)&v29);
        }
        else
        {
          if (SHIBYTE(v24) < 0)
          {
            sub_10004FC84((unsigned char *)a3[1], __p[0], (unint64_t)__p[1]);
          }
          else
          {
            long long v12 = *(_OWORD *)__p;
            *(void *)(v11 + 16) = v24;
            *(_OWORD *)unint64_t v11 = v12;
          }
          uint64_t v18 = v11 + 24;
          a3[1] = v18;
        }
        a3[1] = v18;
        if (SHIBYTE(v24) < 0)
        {
          operator delete(__p[0]);
          if (v9 < 0) {
LABEL_32:
          }
            operator delete(v8);
        }
        else if (v9 < 0)
        {
          goto LABEL_32;
        }
        if (++v6 == v7)
        {
          uint64_t v6 = keys;
          break;
        }
      }
    }
    if (v6)
    {
      uint64_t v26 = v6;
      operator delete(v6);
    }
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100E87C28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100057D78(&a20);
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_100E87CDC(uint64_t a1, uint64_t a2, const __CFString *a3, const void *a4, const __CFString *a5, char **a6, unsigned int a7, const void *a8)
{
  if (!isReal()) {
    return 1;
  }
  uint64_t v29 = 0;
  sub_100E863DC(&v29, a2);
  unint64_t v16 = v29;
  unsigned int v17 = operator new(0x10uLL);
  uint64_t v18 = (uint64_t)(v17 + 2);
  uint64_t v27 = (uint64_t)(v17 + 2);
  unint64_t v28 = v17 + 2;
  void *v17 = @"PersonalWallet";
  v17[1] = v16;
  CFStringRef v25 = 0;
  std::string __p = v17;
  uint64_t v24 = 0;
  sub_1000810C0(a5, a7, (uint64_t)&v24);
  if (!(_BYTE)v24)
  {
    BOOL v19 = v25;
    if (v25) {
      long long v20 = sub_1000810B8;
    }
    else {
      long long v20 = 0;
    }
    if (!v20)
    {
      a5 = 0;
      if (!a6) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    CFStringRef v21 = operator new(0x20uLL);
    v21[2] = v19;
    uint64_t v18 = (uint64_t)(v21 + 3);
    *(_OWORD *)CFStringRef v21 = *(_OWORD *)v17;
    std::string __p = v21;
    unint64_t v28 = v21 + 4;
    operator delete(v17);
    a5 = 0;
    uint64_t v27 = v18;
  }
  if (a6) {
LABEL_9:
  }
    sub_100083ACC((uint64_t)&__p, v18, *a6, a6[1], (a6[1] - *a6) >> 3);
LABEL_10:
  uint64_t v22 = sub_1000825C4(*(os_unfair_lock_s **)(a1 + 64), a3, a4, a5, (char **)&__p, a7, a8, @"PWallet");
  sub_1000558F4(&v25);
  if (__p)
  {
    uint64_t v27 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&v29);
  return v22;
}

void sub_100E87E7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E87EC4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFString *a4@<X3>, char **a5@<X4>, unsigned int a6@<W5>, uint64_t a7@<X8>)
{
  CFStringRef v25 = 0;
  sub_100E863DC(&v25, a2);
  unint64_t v13 = v25;
  unint64_t v14 = operator new(0x10uLL);
  uint64_t v15 = (uint64_t)(v14 + 2);
  uint64_t v23 = (uint64_t)(v14 + 2);
  uint64_t v24 = v14 + 2;
  void *v14 = @"PersonalWallet";
  v14[1] = v13;
  CFStringRef v21 = 0;
  std::string __p = v14;
  uint64_t v20 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v20);
  if ((_BYTE)v20)
  {
LABEL_7:
    if (!a5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  unint64_t v16 = v21;
  if (v21) {
    unsigned int v17 = sub_1000810B8;
  }
  else {
    unsigned int v17 = 0;
  }
  if (v17)
  {
    uint64_t v18 = operator new(0x20uLL);
    v18[2] = v16;
    uint64_t v15 = (uint64_t)(v18 + 3);
    *(_OWORD *)uint64_t v18 = *(_OWORD *)v14;
    std::string __p = v18;
    uint64_t v24 = v18 + 4;
    operator delete(v14);
    a4 = 0;
    uint64_t v23 = v15;
    goto LABEL_7;
  }
  a4 = 0;
  if (a5) {
LABEL_8:
  }
    sub_100083ACC((uint64_t)&__p, v15, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_9:
  sub_100082AB4(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6, a7);
  sub_1000558F4(&v21);
  if (__p)
  {
    uint64_t v23 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v25);
}

void sub_100E88030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E88078@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFString *a4@<X3>, char **a5@<X4>, unsigned int a6@<W5>, void *a7@<X8>)
{
  CFStringRef v25 = 0;
  sub_100E863DC(&v25, a2);
  unint64_t v13 = v25;
  unint64_t v14 = operator new(0x10uLL);
  uint64_t v15 = (uint64_t)(v14 + 2);
  uint64_t v23 = (uint64_t)(v14 + 2);
  uint64_t v24 = v14 + 2;
  void *v14 = @"PersonalWallet";
  v14[1] = v13;
  CFStringRef v21 = 0;
  std::string __p = v14;
  uint64_t v20 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v20);
  if ((_BYTE)v20)
  {
LABEL_7:
    if (!a5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  unint64_t v16 = v21;
  if (v21) {
    unsigned int v17 = sub_1000810B8;
  }
  else {
    unsigned int v17 = 0;
  }
  if (v17)
  {
    uint64_t v18 = operator new(0x20uLL);
    v18[2] = v16;
    uint64_t v15 = (uint64_t)(v18 + 3);
    *(_OWORD *)uint64_t v18 = *(_OWORD *)v14;
    std::string __p = v18;
    uint64_t v24 = v18 + 4;
    operator delete(v14);
    a4 = 0;
    uint64_t v23 = v15;
    goto LABEL_7;
  }
  a4 = 0;
  if (a5) {
LABEL_8:
  }
    sub_100083ACC((uint64_t)&__p, v15, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_9:
  sub_100083254(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6, a7);
  sub_1000558F4(&v21);
  if (__p)
  {
    uint64_t v23 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v25);
}

void sub_100E881E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_100E8822C(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, char **a5, unsigned int a6)
{
  uint64_t v24 = 0;
  sub_100E863DC(&v24, a2);
  unint64_t v11 = v24;
  long long v12 = operator new(0x10uLL);
  uint64_t v13 = (uint64_t)(v12 + 2);
  uint64_t v22 = (uint64_t)(v12 + 2);
  uint64_t v23 = v12 + 2;
  *long long v12 = @"PersonalWallet";
  v12[1] = v11;
  uint64_t v20 = 0;
  std::string __p = v12;
  uint64_t v19 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v19);
  if ((_BYTE)v19)
  {
LABEL_7:
    if (!a5) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  unint64_t v14 = v20;
  if (v20) {
    uint64_t v15 = sub_1000810B8;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15)
  {
    unint64_t v16 = operator new(0x20uLL);
    unint64_t v16[2] = v14;
    uint64_t v13 = (uint64_t)(v16 + 3);
    *(_OWORD *)unint64_t v16 = *(_OWORD *)v12;
    std::string __p = v16;
    uint64_t v23 = v16 + 4;
    operator delete(v12);
    a4 = 0;
    uint64_t v22 = v13;
    goto LABEL_7;
  }
  a4 = 0;
  if (a5) {
LABEL_8:
  }
    sub_100083ACC((uint64_t)&__p, v13, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_9:
  uint64_t v17 = sub_1000832B0(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6);
  sub_1000558F4(&v20);
  if (__p)
  {
    uint64_t v22 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&v24);
  return v17;
}

void sub_100E88390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_100E883D8(uint64_t a1, uint64_t a2, const __CFString *a3, const void *a4, const __CFString *a5, char **a6, unsigned int a7, const void *a8)
{
  uint64_t v29 = 0;
  sub_100E863DC(&v29, a2);
  uint64_t v15 = v29;
  unint64_t v16 = operator new(0x18uLL);
  uint64_t v17 = (uint64_t)(v16 + 3);
  uint64_t v27 = (uint64_t)(v16 + 3);
  unint64_t v28 = v16 + 3;
  *unint64_t v16 = @"PersonalWallet";
  v16[1] = v15;
  unint64_t v16[2] = @"s";
  CFStringRef v25 = 0;
  std::string __p = v16;
  uint64_t v24 = 0;
  sub_1000810C0(a5, a7, (uint64_t)&v24);
  if ((_BYTE)v24)
  {
LABEL_9:
    if (!a6) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v18 = v25;
  if (v25) {
    uint64_t v19 = sub_1000810B8;
  }
  else {
    uint64_t v19 = 0;
  }
  if (v19)
  {
    uint64_t v20 = operator new(0x30uLL);
    uint64_t v21 = 0;
    unint64_t v20[3] = v18;
    uint64_t v17 = (uint64_t)(v20 + 4);
    do
    {
      v20[v21 + 2] = v16[v21 + 2];
      --v21;
    }
    while (v21 != -3);
    std::string __p = v20;
    unint64_t v28 = v20 + 6;
    operator delete(v16);
    a5 = 0;
    uint64_t v27 = v17;
    goto LABEL_9;
  }
  a5 = 0;
  if (a6) {
LABEL_10:
  }
    sub_100083ACC((uint64_t)&__p, v17, *a6, a6[1], (a6[1] - *a6) >> 3);
LABEL_11:
  uint64_t v22 = sub_1000825C4(*(os_unfair_lock_s **)(a1 + 64), a3, a4, a5, (char **)&__p, a7, a8, @"PWallet");
  sub_1000558F4(&v25);
  if (__p)
  {
    uint64_t v27 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&v29);
  return v22;
}

void sub_100E88588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E885D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFString *a4@<X3>, char **a5@<X4>, unsigned int a6@<W5>, uint64_t a7@<X8>)
{
  uint64_t v26 = 0;
  sub_100E863DC(&v26, a2);
  uint64_t v13 = v26;
  unint64_t v14 = operator new(0x18uLL);
  uint64_t v15 = (uint64_t)(v14 + 3);
  uint64_t v24 = (uint64_t)(v14 + 3);
  CFStringRef v25 = v14 + 3;
  void *v14 = @"PersonalWallet";
  v14[1] = v13;
  void v14[2] = @"s";
  uint64_t v22 = 0;
  std::string __p = v14;
  uint64_t v21 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v21);
  if ((_BYTE)v21)
  {
LABEL_9:
    if (!a5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v16 = v22;
  if (v22) {
    uint64_t v17 = sub_1000810B8;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17)
  {
    uint64_t v18 = operator new(0x30uLL);
    uint64_t v19 = 0;
    v18[3] = v16;
    uint64_t v15 = (uint64_t)(v18 + 4);
    do
    {
      v18[v19 + 2] = v14[v19 + 2];
      --v19;
    }
    while (v19 != -3);
    std::string __p = v18;
    CFStringRef v25 = v18 + 6;
    operator delete(v14);
    a4 = 0;
    uint64_t v24 = v15;
    goto LABEL_9;
  }
  a4 = 0;
  if (a5) {
LABEL_10:
  }
    sub_100083ACC((uint64_t)&__p, v15, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_11:
  sub_100082AB4(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6, a7);
  sub_1000558F4(&v22);
  if (__p)
  {
    uint64_t v24 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v26);
}

void sub_100E88768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E887B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFString *a4@<X3>, char **a5@<X4>, unsigned int a6@<W5>, void *a7@<X8>)
{
  uint64_t v26 = 0;
  sub_100E863DC(&v26, a2);
  uint64_t v13 = v26;
  unint64_t v14 = operator new(0x18uLL);
  uint64_t v15 = (uint64_t)(v14 + 3);
  uint64_t v24 = (uint64_t)(v14 + 3);
  CFStringRef v25 = v14 + 3;
  void *v14 = @"PersonalWallet";
  v14[1] = v13;
  void v14[2] = @"s";
  uint64_t v22 = 0;
  std::string __p = v14;
  uint64_t v21 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v21);
  if ((_BYTE)v21)
  {
LABEL_9:
    if (!a5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v16 = v22;
  if (v22) {
    uint64_t v17 = sub_1000810B8;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17)
  {
    uint64_t v18 = operator new(0x30uLL);
    uint64_t v19 = 0;
    v18[3] = v16;
    uint64_t v15 = (uint64_t)(v18 + 4);
    do
    {
      v18[v19 + 2] = v14[v19 + 2];
      --v19;
    }
    while (v19 != -3);
    std::string __p = v18;
    CFStringRef v25 = v18 + 6;
    operator delete(v14);
    a4 = 0;
    uint64_t v24 = v15;
    goto LABEL_9;
  }
  a4 = 0;
  if (a5) {
LABEL_10:
  }
    sub_100083ACC((uint64_t)&__p, v15, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_11:
  sub_100083254(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6, a7);
  sub_1000558F4(&v22);
  if (__p)
  {
    uint64_t v24 = (uint64_t)__p;
    operator delete(__p);
  }
  return sub_1000558F4(&v26);
}

void sub_100E88948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_100E88990(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, char **a5, unsigned int a6)
{
  CFStringRef v25 = 0;
  sub_100E863DC(&v25, a2);
  unint64_t v11 = v25;
  long long v12 = operator new(0x18uLL);
  uint64_t v13 = (uint64_t)(v12 + 3);
  uint64_t v23 = (uint64_t)(v12 + 3);
  uint64_t v24 = v12 + 3;
  *long long v12 = @"PersonalWallet";
  v12[1] = v11;
  CFTypeRef v12[2] = @"s";
  uint64_t v21 = 0;
  std::string __p = v12;
  uint64_t v20 = 0;
  sub_1000810C0(a4, a6, (uint64_t)&v20);
  if ((_BYTE)v20)
  {
LABEL_9:
    if (!a5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v14 = v21;
  if (v21) {
    uint64_t v15 = sub_1000810B8;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15)
  {
    unint64_t v16 = operator new(0x30uLL);
    uint64_t v17 = 0;
    v16[3] = v14;
    uint64_t v13 = (uint64_t)(v16 + 4);
    do
    {
      v16[v17 + 2] = v12[v17 + 2];
      --v17;
    }
    while (v17 != -3);
    std::string __p = v16;
    uint64_t v24 = v16 + 6;
    operator delete(v12);
    a4 = 0;
    uint64_t v23 = v13;
    goto LABEL_9;
  }
  a4 = 0;
  if (a5) {
LABEL_10:
  }
    sub_100083ACC((uint64_t)&__p, v13, *a5, a5[1], (a5[1] - *a5) >> 3);
LABEL_11:
  uint64_t v18 = sub_1000832B0(*(os_unfair_lock_s **)(a1 + 64), a3, a4, (char **)&__p, a6);
  sub_1000558F4(&v21);
  if (__p)
  {
    uint64_t v23 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&v25);
  return v18;
}

void sub_100E88B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14)
{
  sub_1000558F4(v14);
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100E88B68(uint64_t a1, uint64_t a2)
{
  sub_100056248(&v6, (CFTypeRef *)(a2 + 8));
  uint64_t v3 = *(const void ***)(a1 + 8);
  if (v3 != &v6)
  {
    uint64_t v4 = *v3;
    const void *v3 = 0;
    uint64_t v7 = v4;
    const void *v3 = v6;
    uint64_t v6 = 0;
    sub_1000558F4(&v7);
  }
  return sub_1000558F4(&v6);
}

void sub_100E88BD8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E88C10(uint64_t a1)
{
}

uint64_t sub_100E88C2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E88C70(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E88C9C(ServiceManager::Service *this)
{
  *(void *)this = off_101A65700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E88CF8(ServiceManager::Service *this)
{
  *(void *)this = off_101A65700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E88D68@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PersonalWallet");
}

unsigned char *sub_100E88D78@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E88DB8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100E85F54(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100E85F54(v4, 0);
}

uint64_t sub_100E88E3C()
{
  return 1;
}

uint64_t sub_100E88E44()
{
  return 1;
}

uint64_t sub_100E88E4C()
{
  return 2;
}

void sub_100E88E54(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  xpc_object_t v4 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  uint64_t v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
    dispatch_group_leave(v5);
    dispatch_release(v5);
  }
  xpc_release(v4);
}

void sub_100E88ECC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  xpc_object_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E88FE0(ServiceManager::Service *this)
{
  *(void *)this = off_101A65700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E8903C(ServiceManager::Service *this)
{
  *(void *)this = off_101A65700;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100E890AC()
{
  return 0;
}

uint64_t sub_100E890B4()
{
  return 0;
}

uint64_t *sub_100E890C0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v34 = a1;
  uint64_t v35 = v1;
  uint64_t v2 = *(void **)v1;
  sub_100083254(*(os_unfair_lock_s **)(*(void *)v1 + 64), @"pw_ver", 0, 0, 0, cf);
  uint64_t v3 = (int *)cf[0];
  LODWORD(v39) = 1;
  if (cf[0] && (CFTypeID v4 = CFGetTypeID(cf[0]), v4 == CFNumberGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v39, v3, v5);
    uint64_t v6 = v39;
    sub_1000577C4(cf);
    if (v6 > 2) {
      goto LABEL_59;
    }
    unsigned int v7 = v6;
  }
  else
  {
    sub_1000577C4(cf);
    uint64_t v6 = 1;
    unsigned int v7 = 1;
  }
  BOOL v8 = v2[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(cf[0]) = 134218240;
    *(CFTypeRef *)((char *)cf + 4) = (CFTypeRef)v6;
    WORD2(cf[1]) = 2048;
    *(CFTypeRef *)((char *)&cf[1] + 6) = (CFTypeRef)3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I migrating wallets from ver %zu to %zu", (uint8_t *)cf, 0x16u);
  }
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  (*(void (**)(uint64_t *__return_ptr, void *, void))(*v2 + 80))(&v36, v2, 0);
  lock = (os_unfair_lock_s *)(v2[8] + 32);
  os_unfair_lock_lock(lock);
  uint64_t v9 = v36;
  if (v7 <= 1)
  {
    uint64_t v10 = v37;
    if (v36 != v37)
    {
      do
      {
        memset(cf, 0, sizeof(cf));
        sub_100E85830((uint64_t)v2, v9, @"GSMASettingsSwitchState", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        unint64_t v11 = operator new(8uLL);
        cf[0] = v11;
        *unint64_t v11 = @"MaxDataRate";
        cf[1] = v11 + 1;
        cf[2] = v11 + 1;
        sub_100E85830((uint64_t)v2, v9, @"Enable5G", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        long long v12 = operator new(8uLL);
        cf[0] = v12;
        *long long v12 = @"MaxDataRate";
        cf[1] = v12 + 1;
        cf[2] = v12 + 1;
        sub_100E85830((uint64_t)v2, v9, @"EnableLTE", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v13 = operator new(8uLL);
        cf[0] = v13;
        void *v13 = @"MaxDataRate";
        cf[1] = v13 + 1;
        cf[2] = v13 + 1;
        sub_100E85830((uint64_t)v2, v9, @"Enable3G", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        unint64_t v14 = operator new(8uLL);
        cf[0] = v14;
        void *v14 = @"MaxDataRate";
        cf[1] = v14 + 1;
        cf[2] = v14 + 1;
        sub_100E85830((uint64_t)v2, v9, @"Enable5GSwitchSupport", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v15 = operator new(8uLL);
        cf[0] = v15;
        *uint64_t v15 = @"MaxDataRate";
        cf[1] = v15 + 1;
        cf[2] = v15 + 1;
        sub_100E85830((uint64_t)v2, v9, @"EnableLTESwitchSupport", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        unint64_t v16 = operator new(8uLL);
        cf[0] = v16;
        *unint64_t v16 = @"MaxDataRate";
        cf[1] = v16 + 1;
        cf[2] = v16 + 1;
        sub_100E85830((uint64_t)v2, v9, @"Enable3GSwitchSupport", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v17 = operator new(8uLL);
        cf[0] = v17;
        void *v17 = @"PhoneServices";
        cf[1] = v17 + 1;
        cf[2] = v17 + 1;
        sub_100E85830((uint64_t)v2, v9, @"VoLTEUserPreference", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v18 = operator new(8uLL);
        cf[0] = v18;
        *uint64_t v18 = @"PhoneServices";
        cf[1] = v18 + 1;
        cf[2] = v18 + 1;
        sub_100E85830((uint64_t)v2, v9, @"thumper.switch.status", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v19 = operator new(8uLL);
        cf[0] = v19;
        *uint64_t v19 = @"PhoneServices";
        cf[1] = v19 + 1;
        cf[2] = v19 + 1;
        sub_100E85830((uint64_t)v2, v9, @"last.icloud.ver", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v20 = operator new(8uLL);
        cf[0] = v20;
        *uint64_t v20 = @"PhoneServices";
        cf[1] = v20 + 1;
        cf[2] = v20 + 1;
        sub_100E85830((uint64_t)v2, v9, @"vowifi.switch.status", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v21 = operator new(8uLL);
        cf[0] = v21;
        void *v21 = @"PhoneServices";
        cf[1] = v21 + 1;
        cf[2] = v21 + 1;
        sub_100E85830((uint64_t)v2, v9, @"vowifi.roaming_switch.status", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v22 = operator new(8uLL);
        cf[0] = v22;
        *uint64_t v22 = @"RegistrationModel";
        cf[1] = v22 + 1;
        cf[2] = v22 + 1;
        sub_100E85830((uint64_t)v2, v9, @"5GStandaloneEnabled", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        memset(cf, 0, sizeof(cf));
        sub_100E85830((uint64_t)v2, v9, @"InternationalRoamingEDGE", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        uint64_t v23 = operator new(8uLL);
        cf[0] = v23;
        void *v23 = @"DataService";
        cf[1] = v23 + 1;
        cf[2] = v23 + 1;
        sub_100E85830((uint64_t)v2, v9, @"SupportDynamicDataSimSwitch", (char **)cf);
        if (cf[0])
        {
          cf[1] = cf[0];
          operator delete((void *)cf[0]);
        }
        v9 += 24;
      }
      while (v9 != v10);
      uint64_t v9 = v36;
    }
  }
  for (uint64_t i = v37; v9 != i; v9 += 24)
  {
    CFNumberRef v42 = 0;
    sub_100E85A80((uint64_t)cf, (uint64_t)v2, v9, @"lastGoodImsi", @"SatMsg", 0);
    CFNumberRef v39 = (CFNumberRef)&unk_1015836E3;
    __int16 v40 = (const void **)&v42;
    CFStringRef v41 = &unk_1015836E3;
    sub_100E88B68((uint64_t)&v39, (uint64_t)cf);
    sub_1000577C4(&cf[2]);
    sub_1000577C4(&cf[1]);
    if (v42) {
      CFStringRef v25 = sub_1000810B8;
    }
    else {
      CFStringRef v25 = 0;
    }
    if (v25)
    {
      sub_100E85C2C((uint64_t)v2, v9, v42);
      sub_100E85DB4((uint64_t)v2, v9, @"lastGoodImsi", @"SatMsg", 0);
    }
    else
    {
      sub_100E85A80((uint64_t)cf, (uint64_t)v2, v9, @"lastGoodImsi", @"CarrierEntitlements", 0);
      CFNumberRef v39 = (CFNumberRef)&unk_1015836E3;
      __int16 v40 = (const void **)&v42;
      CFStringRef v41 = &unk_1015836E3;
      sub_100E88B68((uint64_t)&v39, (uint64_t)cf);
      sub_1000577C4(&cf[2]);
      sub_1000577C4(&cf[1]);
      if (v42) {
        uint64_t v26 = sub_1000810B8;
      }
      else {
        uint64_t v26 = 0;
      }
      if (v26) {
        sub_100E85C2C((uint64_t)v2, v9, v42);
      }
    }
    sub_1000558F4((const void **)&v42);
  }
  uint64_t v27 = v2[8];
  CFNumberRef v42 = 0;
  cf[0] = (CFTypeRef)3;
  CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, cf);
  if (v28)
  {
    CFNumberRef v29 = v42;
    CFNumberRef v42 = v28;
    cf[0] = v29;
    sub_1000570E8(cf);
  }
  CFNumberRef v30 = v42;
  CFNumberRef v39 = v42;
  CFNumberRef v42 = 0;
  sub_1000570E8((const void **)&v42);
  sub_100082674(v27, @"pw_ver", v30, 0, 0, 0, 0, 0);
  sub_1000570E8((const void **)&v39);
  BOOL v31 = v2[5];
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(cf[0]) = 134217984;
    *(CFTypeRef *)((char *)cf + 4) = (CFTypeRef)3;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I migrated wallets to ver %zu", (uint8_t *)cf, 0xCu);
  }
  os_unfair_lock_unlock(lock);
  cf[0] = &v36;
  sub_100047F64((void ***)cf);
LABEL_59:
  sub_1000E3958(&v35);
  return sub_100046B58((uint64_t *)&v34);
}

void sub_100E89860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock, uint64_t a10, uint64_t a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, __int16 *a17, uint64_t a18, uint64_t a19, char a20,void *__p,uint64_t a22)
{
  a17 = &a12;
  sub_100047F64((void ***)&a17);
  sub_1000E3958(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100E8994C(uint64_t **a1)
{
  CFNumberRef v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*(void *)(v2 + 104))
  {
    os_state_remove_handler();
    *(void *)(v2 + 104) = 0;
  }
  uint64_t v3 = v1[1];
  if (v3)
  {
    dispatch_group_leave(v3);
    CFTypeID v4 = v1[1];
    if (v4) {
      dispatch_release(v4);
    }
  }
  operator delete();
}

void sub_100E899C4(uint64_t **a1)
{
  unsigned int v7 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v9 = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000;
  unint64_t v11 = sub_100E89AC8;
  long long v12 = &unk_101A65758;
  uint64_t v13 = v2;
  uint64_t v3 = os_state_add_handler();
  *(void *)(v2 + 104) = v3;
  if (!v3)
  {
    CFTypeID v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not add state capture handler", buf, 2u);
    }
  }
  CFNumberRef v5 = v1[1];
  if (v5)
  {
    dispatch_group_leave(v5);
    uint64_t v6 = v1[1];
    if (v6) {
      dispatch_release(v6);
    }
  }
  operator delete();
}

char *sub_100E89AC8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 16);
  if (v3 == 3)
  {
    CFPropertyListRef propertyList = 0;
    uint64_t v4 = kCommCenterPreferencesNoBackupAppID;
    *(void *)CFErrorRef error = CFPreferencesCopyValue(@"PersonalWallet", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100084068(&propertyList, (CFTypeRef *)error);
    if (propertyList) {
      CFNumberRef v5 = sub_100080778;
    }
    else {
      CFNumberRef v5 = 0;
    }
    if (v5)
    {
      CFErrorRef err = 0;
      *(void *)CFErrorRef error = 0;
      *(void *)&error[8] = &err;
      CFDataRef Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, (CFErrorRef *)error);
      theCFDataRef Data = Data;
      sub_100128064((const void **)error);
      if (Data) {
        unsigned int v7 = sub_10008324C;
      }
      else {
        unsigned int v7 = 0;
      }
      if (v7)
      {
        size_t Length = CFDataGetLength(Data);
        uint64_t v9 = (char *)malloc_type_calloc(1uLL, Length + 200, 0x5511DA9EuLL);
        *(_DWORD *)uint64_t v9 = 1;
        *((_DWORD *)v9 + 1) = Length;
        strlcpy(v9 + 136, "PersonalWallet", 0x40uLL);
        BytePtr = CFDataGetBytePtr(theData);
        memcpy(v9 + 200, BytePtr, Length);
      }
      else
      {
        CFStringRef v13 = CFErrorCopyDescription(err);
        CFStringRef v16 = v13;
        unint64_t v14 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CFErrorRef error = 138412290;
          *(void *)&error[4] = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not convert PersonalWallet to serialized CF representation: %@", error, 0xCu);
        }
        sub_1000558F4((const void **)&v16);
        uint64_t v9 = 0;
      }
      sub_100030068((const void **)&theData);
      sub_100127D74((const void **)&err);
      if (v7) {
        goto LABEL_21;
      }
    }
    else
    {
      long long v12 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CFErrorRef error = 138412546;
        *(void *)&error[4] = @"PersonalWallet";
        *(_WORD *)&error[12] = 2112;
        *(void *)&error[14] = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to get contents of %@ at %@", error, 0x16u);
      }
    }
    uint64_t v9 = 0;
LABEL_21:
    sub_100057D78(&propertyList);
    return v9;
  }
  unint64_t v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CFErrorRef error = 67109120;
    *(_DWORD *)&error[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Skipping state handler for %d", error, 8u);
  }
  return 0;
}

void sub_100E89D74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFNumberRef v5 = va_arg(va2, const void *);
  sub_100030068((const void **)va);
  sub_100127D74((const void **)va1);
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E89DB4(uint64_t a1)
{
  uint64_t v1 = *(void *****)(a1 + 40);
  uint64_t v2 = v1[1];
  uint64_t result = (uint64_t *)isReal();
  if (result)
  {
    uint64_t v4 = (uint64_t **)(v2 + 10);
    uint64_t result = (uint64_t *)sub_100046F68((uint64_t)(v2 + 10), (void **)*v1);
    if (v2 + 11 == (void ***)result)
    {
      CFNumberRef v5 = v2[5];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = (void **)*v1;
        unsigned int v7 = (void **)*((unsigned __int8 *)*v1 + 23);
        BOOL v8 = (char)v7 < 0;
        if ((char)v7 < 0) {
          unsigned int v7 = (*v1)[1];
        }
        if (v8) {
          uint64_t v6 = **v1;
        }
        if (!v7) {
          uint64_t v6 = (void **)"<invalid>";
        }
        int v9 = 136315138;
        uint64_t v10 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I activating wallet %s", (uint8_t *)&v9, 0xCu);
      }
      return sub_100C36C48(v4, (void **)*v1, (uint64_t)*v1);
    }
  }
  return result;
}

void sub_100E89EBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 24);
  int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(unsigned __int8 *)(v1 + 23);
    BOOL v5 = (v4 & 0x80u) != 0;
    if ((v4 & 0x80u) != 0) {
      uint64_t v4 = *(void *)(v1 + 8);
    }
    if (v5) {
      uint64_t v6 = *(const char **)v1;
    }
    else {
      uint64_t v6 = (const char *)v1;
    }
    if (v4) {
      unsigned int v7 = v6;
    }
    else {
      unsigned int v7 = "<invalid>";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I removing wallet %s", (uint8_t *)&buf, 0xCu);
  }
  sub_1000E9358((uint64_t **)(v2 + 80), (void **)v1);
  sub_100E861A8(v2, v1);
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x3802000000;
  CFNumberRef v28 = sub_100E8A2D8;
  uint64_t v30 = 0;
  BOOL v31 = 0;
  CFNumberRef v29 = sub_100E8A2E8;
  v22[0] = 0;
  v22[1] = v22;
  xpc_object_t v22[2] = 0x3802000000;
  v22[3] = sub_100E8A2F8;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  v22[4] = sub_100E8A308;
  BOOL v8 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v8 || (uint64_t v9 = *(void *)(v2 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v23 = v9;
  uint64_t v24 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  Registry::getTimerService(&v19, *(Registry **)(v2 + 48));
  uint64_t v11 = v19;
  sub_100058DB0(__p, "postmortem");
  long long v12 = *(NSObject **)(v2 + 24);
  dispatch_object_t object = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 1174405120;
  CFStringRef v33 = sub_100E8A318;
  uint64_t v34 = &unk_101A657C0;
  uint64_t v37 = v2;
  uint64_t v35 = v22;
  if (*(char *)(v1 + 23) < 0)
  {
    sub_10004FC84(&v38, *(void **)v1, *(void *)(v1 + 8));
  }
  else
  {
    long long v13 = *(_OWORD *)v1;
    uint64_t v39 = *(void *)(v1 + 16);
    long long v38 = v13;
  }
  uint64_t v36 = &v25;
  aBlock = _Block_copy(&buf);
  sub_100118A44(v11, (uint64_t)__p, 2, 5000000, &object, &aBlock);
  sub_1004DC2E0(v26 + 5, &v21);
  uint64_t v14 = v21;
  uint64_t v21 = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)v38);
  }
  _Block_object_dispose(v22, 8);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  _Block_object_dispose(&v25, 8);
  if (v31) {
    sub_10004D2C8(v31);
  }
}

void sub_100E8A1E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33)
{
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Block_object_dispose(&a20, 8);
  if (a26) {
    std::__shared_weak_count::__release_weak(a26);
  }
  _Block_object_dispose(&a27, 8);
  if (a33) {
    sub_10004D2C8(a33);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100E8A2D8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_100E8A2E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

__n128 sub_100E8A2F8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void sub_100E8A308(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E8A318(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  int v3 = *(std::__shared_weak_count **)(v2 + 48);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (*(void *)(v2 + 40) && (void **)(v4 + 88) == sub_100046F68(v4 + 80, (void **)(a1 + 56)))
      {
        unsigned int v7 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *(unsigned __int8 *)(a1 + 79);
          BOOL v9 = (v8 & 0x80u) != 0;
          if ((v8 & 0x80u) != 0) {
            uint64_t v8 = *(void *)(a1 + 64);
          }
          if (v9) {
            uint64_t v10 = *(const char **)(a1 + 56);
          }
          else {
            uint64_t v10 = (const char *)(a1 + 56);
          }
          if (v8) {
            uint64_t v11 = v10;
          }
          else {
            uint64_t v11 = "<invalid>";
          }
          int v14 = 136315138;
          uint64_t v15 = v11;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I postmortem wallet cleanup %s", (uint8_t *)&v14, 0xCu);
        }
        sub_100E861A8(v4, a1 + 56);
      }
      sub_10004D2C8(v6);
    }
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  long long v13 = *(std::__shared_weak_count **)(v12 + 48);
  *(void *)(v12 + 40) = 0;
  *(void *)(v12 + 48) = 0;
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100E8A45C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100E8A474(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v3 = *(_OWORD *)(a2 + 56);
  result[2] = *(void *)(a2 + 72);
  *(_OWORD *)__n128 result = v3;
  return result;
}

void sub_100E8A4A4(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
}

void sub_100E8A66C()
{
}

void sub_100E8A7B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8A8EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8A9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)IDSNearbyDelegate;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t sub_100E8AA94(uint64_t a1)
{
  return a1;
}

void sub_100E8AAC0(uint64_t a1)
{
  operator delete();
}

void sub_100E8AB0C()
{
}

void sub_100E8ABBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

id sub_100E8AC00(uint64_t a1)
{
  return [*(id *)(a1 + 8) isNearby];
}

void *sub_100E8AC08(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = off_101A65810;
  a1[1] = 0;
  uint64_t v6 = [IDSNearbyDelegate alloc];
  sub_1000DFC90((uint64_t)v10, a3);
  unsigned int v7 = [(IDSNearbyDelegate *)v6 initWithCallback:v10 queue:a2];
  uint64_t v8 = (void *)a1[1];
  a1[1] = v7;

  sub_100060644(v10);
  return a1;
}

void sub_100E8ACCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);

  _Unwind_Resume(a1);
}

id **sub_100E8ACF8(id **result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

void sub_100E8AD48(id *a1)
{
  uint64_t v2 = [*((id *)*a1 + 6) linkedDevicesWithRelationship:3];
  id v3 = *a1;
  id v4 = v2;
  operator new();
}

void sub_100E8AE08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100E8ACF8((id **)va);
  _Unwind_Resume(a1);
}

id **sub_100E8AE1C(id **result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_100E8AE74(id *a1)
{
  uint64_t v8 = a1;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = a1[1];
  uint64_t v3 = (uint64_t)[v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v10;
    while (2)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v10 != v4) {
          objc_enumerationMutation(v2);
        }
        uint64_t v6 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        if (v6
          && [*(id *)(*((void *)&v9 + 1) + 8 * i) isDefaultPairedDevice]
          && ([v6 isNearby] & 1) != 0)
        {
          uint64_t v3 = 1;
          goto LABEL_13;
        }
      }
      uint64_t v3 = (uint64_t)[v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3) {
        continue;
      }
      break;
    }
  }
LABEL_13:

  if (v3 != [*a1 fIsDeviceNearby])
  {
    [*a1 setFIsDeviceNearby:v3];
    if (*((void *)*a1 + 5)) {
      sub_1000607A8((uint64_t)*a1 + 16, v3);
    }
  }
  return sub_100E8AE1C(&v8);
}

void sub_100E8AFCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100E8AE1C((id **)va);
  _Unwind_Resume(a1);
}

void sub_100E8AFFC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100E8B064(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E8B0A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E8B0D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100E8B108(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

Class sub_100E8B14C@<X0>(void *a1@<X8>)
{
  Class result = off_101B0B2D8();
  *a1 = 0;
  a1[1] = 0;
  if (result) {
    operator new();
  }
  return result;
}

void sub_100E8B47C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t a9, std::__shared_weak_count *a10, dispatch_object_t object, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17)
{
  if (object) {
    (*((void (**)(dispatch_object_t))object->isa + 1))(object);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100E8B5D0(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E8B6F8(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 80) != a2)
  {
    sub_100E8B744(@"com.apple.coretelephony.ToggleAirplaneMode");
    sub_100E8B744(@"com.apple.coretelephony.ToggleCellularData");
  }
}

void sub_100E8B744(uint64_t a1)
{
  id v2 = [(objc_class *)off_101B0B2D8() sharedInstance];
  [v2 reloadControlsForExtension:a1 kind:a1 reason:@"com.apple.commcenter"];
}

void sub_100E8B7AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100E8B7C0(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 81) != a2) {
    sub_100E8B744(@"com.apple.coretelephony.ToggleCellularData");
  }
}

void sub_100E8B7DC(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v4 = *a2;
  if (v3 - v2 == a2[1] - *a2)
  {
    while (v2 != v3)
    {
      if (!BasicSimInfo::operator==()) {
        goto LABEL_5;
      }
      v2 += 168;
      v4 += 168;
    }
  }
  else
  {
LABEL_5:
    sub_100E8B744(@"com.apple.coretelephony.ToggleCellularData");
  }
}

void sub_100E8B864(uint64_t a1)
{
  *(void *)a1 = off_101A658C8;
  uint64_t v4 = (void **)(a1 + 88);
  sub_10008A88C(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  ToggleSettingsManagerInterface::~ToggleSettingsManagerInterface((ToggleSettingsManagerInterface *)a1);
}

void sub_100E8B8F0(uint64_t a1)
{
  sub_100E8B864(a1);

  operator delete();
}

Class sub_100E8B928()
{
  if (qword_101B12E48[0] != -1) {
    dispatch_once(qword_101B12E48, &stru_101A65980);
  }
  Class result = objc_getClass("CHSControlService");
  qword_101B12E40 = (uint64_t)result;
  off_101B0B2D8 = (uint64_t (*)())sub_100E8B98C;
  return result;
}

id sub_100E8B98C()
{
  return (id)qword_101B12E40;
}

void sub_100E8B998(id a1)
{
  qword_101B12E38 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/ChronoServices.framework/ChronoServices", 2);
}

void sub_100E8B9C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E8BA00(uint64_t a1)
{
}

uint64_t sub_100E8BA1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E8BA60(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100E8BA8C(ServiceManager::Service *this)
{
  *(void *)this = off_101A65A10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E8BAE8(ServiceManager::Service *this)
{
  *(void *)this = off_101A65A10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E8BB58@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ToggleSettingsManager");
}

unsigned char *sub_100E8BB68@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  Class result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E8BBA4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100E8B5D0(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100E8B5D0(v4, 0);
}

uint64_t sub_100E8BC28()
{
  return 0;
}

uint64_t sub_100E8BC30()
{
  return 1;
}

uint64_t sub_100E8BC38()
{
  return 0;
}

void sub_100E8BC48(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group, this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100E8BD70(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v23 = a1;
  uint64_t v24 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v25, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_101A65A90;
  v3[1] = v2 + 80;
  v3[2] = v2;
  void v3[3] = sub_100E8B6F8;
  void v3[4] = 0;
  uint64_t v30 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v29);
  if (v28 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/cellular_data_setting");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A65B10;
  v4[1] = v2 + 81;
  void v4[2] = v2;
  v4[3] = sub_100E8B7C0;
  v4[4] = 0;
  uint64_t v30 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v29);
  if (v28 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  BOOL v5 = operator new(0x28uLL);
  void *v5 = off_101A65B90;
  v5[1] = v2 + 88;
  _OWORD v5[2] = v2;
  v5[3] = sub_100E8B7DC;
  v5[4] = 0;
  uint64_t v30 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v29);
  if (v28 < 0) {
    operator delete(__p[0]);
  }
  sub_100E8B744(@"com.apple.coretelephony.ToggleAirplaneMode");
  sub_100E8B744(@"com.apple.coretelephony.ToggleCellularData");
  uint64_t v6 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v6 || (v7 = *(void *)(v2 + 8), (uint64_t v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  long long v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(v2 + 48));
  long long v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  v29[0] = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, v29);
  if (v17)
  {
    uint64_t v18 = v17[3];
    uint64_t v19 = (std::__shared_weak_count *)v17[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v20 = 0;
      if (!v18) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v19 = 0;
  char v20 = 1;
  if (!v18) {
    goto LABEL_21;
  }
LABEL_20:
  sub_100058DB0(__p, "ToggleSettingsManager");
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v30 = 0;
  uint64_t v21 = operator new(0x20uLL);
  void *v21 = off_101A65C10;
  v21[1] = v2;
  v21[2] = v7;
  v21[3] = v9;
  uint64_t v30 = v21;
  (*(void (**)(uint64_t, void **, unint64_t *))(*(void *)v18 + 112))(v18, __p, v29);
  sub_10003B34C(v29);
  if (v28 < 0)
  {
    operator delete(__p[0]);
    if (v20) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_21:
  if ((v20 & 1) == 0) {
LABEL_22:
  }
    sub_10004D2C8(v19);
LABEL_23:
  std::__shared_weak_count::__release_weak(v9);
  sub_100088C88(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_100E8C128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  sub_10003B34C(&a19);
  if (a18 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  std::__shared_weak_count::__release_weak(v19);
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100E8C1F8()
{
}

__n128 sub_100E8C20C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A65A90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E8C260(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A65A90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E8C298(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100E8C334(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8C374()
{
}

void sub_100E8C384()
{
}

__n128 sub_100E8C398(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A65B10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E8C3EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A65B10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E8C424(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100E8C4C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8C500()
{
}

void sub_100E8C510()
{
}

__n128 sub_100E8C524(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A65B90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E8C578(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A65B90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E8C5B0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  long long v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100E8C654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100E8C670(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8C6B0()
{
}

void *sub_100E8C6BC(void *a1)
{
  *a1 = off_101A65C10;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E8C708(void *a1)
{
  *a1 = off_101A65C10;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100E8C774(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A65C10;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E8C7D8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A65C10;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E8C818(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E8C828(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E8C868(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*(void *)(a1 + 16)) {
        sub_100E8B744(@"com.apple.coretelephony.ToggleCellularData");
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100E8C8D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E8C8E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8C924()
{
}

uint64_t *sub_100E8C930(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100113010(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100E8C978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_100E8C994(void *a1)
{
  *a1 = &off_101A65C90;
  id v2 = +[CTLocationManager sharedManager];
  return a1;
}

void sub_100E8C9E8(_Unwind_Exception *a1)
{
  LocationInterface::~LocationInterface(v1);
  _Unwind_Resume(a1);
}

void sub_100E8CA00(LocationInterface *a1)
{
  LocationInterface::~LocationInterface(a1);

  operator delete();
}

void sub_100E8CA38(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = +[CTLocationManager sharedManager];
  [v4 startLocationUpdatesWithReason:a2];
}

void sub_100E8CA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8CAAC()
{
  uint64_t v1 = +[CTLocationManager sharedManager];
  [v1 stopLocationUpdates];
}

void sub_100E8CB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100E8CB10()
{
  uint64_t v1 = +[CTLocationManager sharedManager];
  id v2 = [v1 isLocationServiceEnabled];

  return v2;
}

void sub_100E8CB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100E8CB78()
{
  uint64_t v1 = +[CTLocationManager sharedManager];
  id v2 = [v1 isLocationServiceAuthorized];

  return v2;
}

void sub_100E8CBD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8CBE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = +[CTLocationManager sharedManager];
  [v4 startLocationMonitoringVisitsWithReason:a2];
}

void sub_100E8CC44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8CC54()
{
  uint64_t v1 = +[CTLocationManager sharedManager];
  [v1 stopLocationMonitoringVisits];
}

void sub_100E8CCA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8CCB8()
{
}

void sub_100E8CD2C(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101020664();
}

void sub_100E8CDA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E8CDBC(MMIFactoryInterface *this)
{
  *(void *)this = off_101A65CF8;
  id v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  MMIFactoryInterface::~MMIFactoryInterface(this);
}

void sub_100E8CE18(MMIFactoryInterface *this)
{
  *(void *)this = off_101A65CF8;
  id v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  MMIFactoryInterface::~MMIFactoryInterface(this);

  operator delete();
}

void stewie::TargetInstantAtLocationCacheFactory::createFactory(void *a1@<X0>, void *a2@<X1>, os_log_t *a3@<X2>, void *a4@<X8>)
{
  if (!*a1)
  {
    uint64_t v5 = *a3;
    if (!os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    __int16 v9 = 0;
    uint64_t v6 = "targets required";
    long long v7 = (uint8_t *)&v9;
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
    goto LABEL_7;
  }
  if (*a2) {
    operator new();
  }
  uint64_t v5 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    __int16 v8 = 0;
    uint64_t v6 = "targetFactory required";
    long long v7 = (uint8_t *)&v8;
    goto LABEL_9;
  }
LABEL_7:
  *a4 = 0;
  a4[1] = 0;
}

void sub_100E8D004(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100E8D058(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 16);
  long long v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  stewie::TargetInstantAtLocationCache::create(&v6, &v4, (os_log_t *)(a1 + 8), a2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100E8D0DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E8D100(void *a1)
{
  *a1 = off_101A65D38;
  id v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_100E8D160(void *a1)
{
  *a1 = off_101A65D38;
  id v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_100E8D1E4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100E8D21C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100E8D24C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100E8D2E4(id a1)
{
  uint64_t v1 = objc_alloc_init(CTLocationManager);
  id v2 = (void *)qword_101B12E58;
  qword_101B12E58 = (uint64_t)v1;
}

void sub_100E8D4EC()
{
}

void sub_100E8D564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  long long v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)CTLocationManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_100E8D770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8D99C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8DBD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8DD24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8DE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E8E284(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100E8E324);
}

void sub_100E8E2EC()
{
}

void sub_100E8E2F4(_Unwind_Exception *a1)
{
  sub_100E8E95C(&v4);
  sub_100E8EB24(&v6);
  sub_10000A740(&v5);

  _Unwind_Resume(a1);
}

id sub_100E8E3C8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = objc_alloc((Class)CLLocationManager);
  uint64_t v3 = +[NSBundle bundleWithIdentifier:@"com.apple.CoreTelephony"];
  id v4 = [v2 initWithEffectiveBundle:v3 delegate:*v1 onQueue:*(void *)(*v1 + 40)];
  uint64_t v5 = *(void **)(*v1 + 8);
  *(void *)(*v1 + 8) = v4;

  [*(id *)(*v1 + 8) setDistanceFilter:kCLDistanceFilterNone];
  uint64_t v6 = *(void **)(*v1 + 8);

  return [v6 setDesiredAccuracy:kCLLocationAccuracyHundredMeters];
}

void sub_100E8E480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id **sub_100E8E490(id *a1)
{
  id v2 = a1;
  [*a1 fetchLocationServiceEnabled];
  return sub_100E8ACF8(&v2);
}

void sub_100E8E4C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100E8ACF8((id **)va);
  _Unwind_Resume(a1);
}

void sub_100E8E4DC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  if (!*(unsigned char *)(*v1 + 49)) {
    __assert_rtn("operator()", "CTLocationManager.mm", 134, "fLocationServiceEnabled.has_value()");
  }
  id v4 = **(NSObject ***)(v2 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v2 + 48)) {
      uint64_t v5 = "True";
    }
    else {
      uint64_t v5 = "False";
    }
    int v6 = 136315138;
    long long v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I using cached locationServicesEnabled: %s", (uint8_t *)&v6, 0xCu);
    uint64_t v2 = *v1;
  }
  **(unsigned char **)(a1 + 32) = *(unsigned char *)(v2 + 48);
}

void sub_100E8E5E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100E8E91C(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100663138((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        __int16 v8 = *(_DWORD **)sub_100663AC8((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_100663AC8(v5) + 8))
        {
          __int16 v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_100663AC8(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100663138((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100663138((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100E8E91C(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100E8E8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E8E91C(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100E8E95C(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_1006630F4(v2);
    if (sub_100663F2C(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_1006630F4(v2);
      __int16 v9 = *(uint64_t **)(sub_100663F2C(v7) + 8);
      sub_10066323C(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100E8EAC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E8EB24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100E8EBF8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100E8EC18()
{
}

uint64_t sub_100E8EC40@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::supportsBIPController(a1);
  *a2 = 0;
  a2[1] = 0;
  if (result) {
    operator new();
  }
  return result;
}

void sub_100E8EFB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100E8F144(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100E8F244(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
  if (*(_DWORD *)(a1 + 120) != result)
  {
    *(_DWORD *)(a1 + 120) = result;
    uint64_t result = *(void *)(a1 + 112);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 48);
      return v3();
    }
  }
  return result;
}

void *sub_100E8F2E4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100E8F36C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E8F3A4(uint64_t a1)
{
}

uint64_t sub_100E8F3C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100E8F404(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_100E8F2E4(result + 11);
    uint64_t v2 = (std::__shared_weak_count *)v1[10];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[8];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[6];
    if (v4) {
      sub_10004D2C8(v4);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_100E8F488(ServiceManager::Service *this)
{
  *(void *)this = off_101A65EA0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E8F4E4(ServiceManager::Service *this)
{
  *(void *)this = off_101A65EA0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E8F554@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PowerSourceHandler");
}

unsigned char *sub_100E8F564@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E8F5A4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100E8F144(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100E8F144(v4, 0);
}

uint64_t sub_100E8F628()
{
  return 0;
}

uint64_t sub_100E8F630()
{
  return 1;
}

uint64_t sub_100E8F638()
{
  return 0;
}

void sub_100E8F644(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E8F724(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100E8F838(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v2 + 56) + 24))(*(void *)(v2 + 56));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100E8F8E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100E8F900(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v11, *(Registry **)(v2 + 40));
  ctu::RestModule::connect();
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v4 = (uint8_t *)(v2 + 88);
  *(void *)long long buf = off_101A65F20;
  uint64_t v14 = v2 + 72;
  uint64_t v15 = buf;
  if (buf != (uint8_t *)(v2 + 88))
  {
    long long v5 = *(uint8_t **)(v2 + 112);
    if (v5 == v4)
    {
      v16[1] = v2 + 72;
      unint64_t v16[2] = 0;
      uint64_t v15 = 0;
      v16[0] = off_101A65F20;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 24))(v2 + 88, buf);
      (*(void (**)(void))(**(void **)(v2 + 112) + 32))(*(void *)(v2 + 112));
      *(void *)(v2 + 112) = 0;
      uint64_t v15 = buf;
      (*(void (**)(void *, uint64_t))(v16[0] + 24))(v16, v2 + 88);
      (*(void (**)(void *))(v16[0] + 32))(v16);
    }
    else
    {
      *(void *)(v2 + 88) = off_101A65F20;
      *(void *)(v2 + 96) = v2 + 72;
      uint64_t v15 = v5;
    }
    *(void *)(v2 + 112) = v4;
  }
  sub_100E8F2E4(buf);
  uint64_t v6 = *(void *)(v2 + 112);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v2 + 120);
  }
  uint64_t v7 = *(void *)(v2 + 56);
  *(void *)long long buf = off_101A65FB0;
  uint64_t v14 = v2;
  uint64_t v15 = buf;
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v7 + 16))(v7, buf);
  sub_10003B34C(buf);
  sub_100088C88(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100E8FBA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E8FBFC()
{
}

void *sub_100E8FC10(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A65F20;
  result[1] = v3;
  return result;
}

uint64_t sub_100E8FC58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A65F20;
  a2[1] = v2;
  return result;
}

void sub_100E8FC84(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/power_source");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100E8FD38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E8FD7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8FDBC()
{
}

void sub_100E8FDCC()
{
}

void *sub_100E8FDE0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A65FB0;
  result[1] = v3;
  return result;
}

uint64_t sub_100E8FE28(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A65FB0;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E8FE54(uint64_t a1)
{
  return sub_100E8F244(*(void *)(a1 + 8));
}

uint64_t sub_100E8FE5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E8FE9C()
{
}

void sub_100E8FEA8(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  sub_100E8F244(v1);
  operator delete();
}

void sub_100E8FF44()
{
}

void *sub_100E8FF70(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_100E924EC((void *)a1);
}

void *sub_100E8FFB0(uint64_t a1)
{
  sub_100313534(a1 + 32, *(void **)(a1 + 40));

  return sub_100E92570((void *)a1);
}

void *sub_100E8FFF0(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_100E925F4((void *)a1);
}

void *sub_100E90030(uint64_t a1)
{
  sub_1007035FC(a1 + 32, *(void **)(a1 + 40));

  return sub_100E92678((void *)a1);
}

void *sub_100E90070(void *a1)
{
  *a1 = off_101A66030;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  uint64_t v3 = (std::__shared_weak_count *)a1[124];
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100057D78((const void **)a1 + 121);
  std::mutex::~mutex((std::mutex *)(a1 + 113));
  uint64_t v4 = (std::__shared_weak_count *)a1[112];
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = (std::__shared_weak_count *)a1[110];
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*((char *)a1 + 871) < 0) {
    operator delete((void *)a1[106]);
  }
  if (*((char *)a1 + 847) < 0) {
    operator delete((void *)a1[103]);
  }
  if (*((char *)a1 + 823) < 0) {
    operator delete((void *)a1[100]);
  }
  sub_1001FEC70((void *)a1[98]);
  std::mutex::~mutex((std::mutex *)(a1 + 89));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 68));
  sub_1003C8134((unsigned char *)a1 + 424);
  sub_10005CD2C((uint64_t)(a1 + 50), (char *)a1[51]);
  sub_100E924EC(a1 + 46);
  sub_100313534((uint64_t)(a1 + 43), (void *)a1[44]);
  sub_100E92570(a1 + 39);
  sub_10005CD2C((uint64_t)(a1 + 36), (char *)a1[37]);
  sub_100E924EC(a1 + 32);
  sub_10005CD2C((uint64_t)(a1 + 29), (char *)a1[30]);
  sub_100E924EC(a1 + 25);
  sub_10005CD2C((uint64_t)(a1 + 22), (char *)a1[23]);
  sub_100E925F4(a1 + 18);
  sub_1007035FC((uint64_t)(a1 + 15), (void *)a1[16]);
  sub_100E92678(a1 + 11);
  uint64_t v6 = (std::__shared_weak_count *)a1[10];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[8];
  if (v7) {
    sub_10004D2C8(v7);
  }
  char v8 = a1[6];
  if (v8) {
    dispatch_release(v8);
  }
  PhoneServices::~PhoneServices((PhoneServices *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100E90218(void *a1)
{
  sub_100E90070(a1);

  operator delete();
}

void *sub_100E90250(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[2];
  if (v4) {
    dispatch_release(v4);
  }
  long long v5 = (std::__shared_weak_count *)a1[1];
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_100E902A4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E903CC()
{
  v0[0] = 0;
  v0[1] = 0;
  *(void *)long long buf = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100076564(v0);
}

void sub_100E908F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v29 = a14;
  a14 = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 32))(v29);
  }
  uint64_t v30 = a19;
  a19 = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 32))(v30);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  sub_1000570E8(&a10);
  uint64_t v31 = a12;
  a12 = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 32))(v31);
  }
  _Unwind_Resume(a1);
}

void sub_100E90A40(uint64_t a1, xpc_object_t object)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3))
    {
      xpc_null_create();
      operator new();
    }
  }
  sub_100088B9C();
}

void PSManager::create()
{
}

void sub_100E91040(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

void sub_100E910D4(_Unwind_Exception *a1)
{
}

void sub_100E910E4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t object, dispatch_object_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v31 = *(std::__shared_weak_count **)(v29 + 992);
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_100057D78((const void **)(v29 + 968));
  std::mutex::~mutex((std::mutex *)(v29 + 904));
  unint64_t v32 = *(std::__shared_weak_count **)(v29 + 896);
  if (v32) {
    sub_10004D2C8(v32);
  }
  CFStringRef v33 = *(std::__shared_weak_count **)(v29 + 880);
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (*(char *)(v29 + 871) < 0) {
    operator delete(*(void **)(v29 + 848));
  }
  if (*(char *)(v29 + 847) < 0) {
    operator delete(*(void **)(v29 + 824));
  }
  if (*(char *)(v29 + 823) < 0) {
    operator delete(*(void **)(v29 + 800));
  }
  sub_1001FEC70(*v30);
  std::mutex::~mutex(v28);
  PersonalitiesTracker::~PersonalitiesTracker(v27);
  sub_1003C8134((unsigned char *)(v24 + 184));
  sub_100E8FF70(v24 + 128);
  sub_100E8FFB0(v24 + 72);
  sub_100E8FF70(v24 + 16);
  sub_100E8FF70(v24 - 40);
  sub_100E8FFF0(v24 - 96);
  sub_100E90030(v24 - 152);
  uint64_t v34 = *(std::__shared_weak_count **)(v29 + 80);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v35 = *(std::__shared_weak_count **)(v29 + 64);
  if (v35) {
    sub_10004D2C8(v35);
  }
  uint64_t v36 = *(NSObject **)(v29 + 48);
  if (v36) {
    dispatch_release(v36);
  }
  PhoneServices::~PhoneServices((PhoneServices *)v29);
  ctu::OsLogLogger::~OsLogLogger(v26);
  sub_100087E88(v25);
  operator delete();
}

double sub_100E912CC@<D0>(void (***a1)(long long *__return_ptr)@<X0>, _OWORD *a2@<X8>)
{
  (**a1)(&v4);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

double sub_100E91324@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  (*(void (**)(long long *__return_ptr))(*(void *)a1 + 8))(&v4);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_100E9137C(uint64_t a1)
{
  memset(&v47, 0, sizeof(v47));
  uint64_t v2 = *(uint64_t ***)(a1 + 696);
  uint64_t v3 = *v2;
  long long v4 = v2[1];
  if (*v2 == v4)
  {
    unsigned int v5 = 0;
  }
  else
  {
    unsigned int v5 = 0;
    do
    {
      uint64_t v6 = *v3;
      if (!*(unsigned char *)(*v3 + 49))
      {
        if (*(unsigned char *)(v6 + 48))
        {
          ++v5;
          if (*(_DWORD *)(v6 + 52) == *(_DWORD *)(a1 + 536)) {
            std::string::operator=(&v47, (const std::string *)(v6 + 24));
          }
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = asStringBool(v5 > 1);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v49 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sMulti-SIM: %s", buf, 0x20u);
  }
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  int v44 = &v45;
  xpc_object_t v9 = (std::mutex *)(a1 + 712);
  std::mutex::lock((std::mutex *)(a1 + 712));
  if (&v44 != (uint64_t ***)(a1 + 776))
  {
    uint64_t v10 = *(void **)(a1 + 776);
    uint64_t v11 = (void *)(a1 + 784);
    if (v46)
    {
      uint64_t v12 = v44;
      int v44 = &v45;
      v45[2] = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      if (v12[1]) {
        uint64_t v13 = (uint64_t)v12[1];
      }
      else {
        uint64_t v13 = (uint64_t)v12;
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = v13;
      *(void *)&uint8_t buf[16] = v13;
      if (!v13 || (*(void *)&uint8_t buf[8] = sub_1000EA590(v13), v10 == v11))
      {
        long long v22 = v10;
      }
      else
      {
        do
        {
          std::string::operator=((std::string *)(v13 + 32), (const std::string *)(v10 + 4));
          uint64_t v15 = v10[7];
          uint64_t v14 = v10[8];
          if (v14) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v16 = *(std::__shared_weak_count **)(v13 + 64);
          *(void *)(v13 + 56) = v15;
          *(void *)(v13 + 64) = v14;
          if (v16) {
            sub_10004D2C8(v16);
          }
          uint64_t v17 = *(uint64_t **)&buf[16];
          uint64_t v18 = v45;
          long long v19 = &v45;
          long long v20 = &v45;
          if (v45)
          {
            do
            {
              while (1)
              {
                long long v19 = (uint64_t **)v18;
                if ((sub_100046FE8(v17 + 4, (void **)v18 + 4) & 0x80) == 0) {
                  break;
                }
                uint64_t v18 = *v19;
                long long v20 = v19;
                if (!*v19) {
                  goto LABEL_28;
                }
              }
              uint64_t v18 = v19[1];
            }
            while (v18);
            long long v20 = v19 + 1;
          }
LABEL_28:
          uint64_t *v17 = 0;
          v17[1] = 0;
          v17[2] = (uint64_t)v19;
          *long long v20 = v17;
          if (*v44)
          {
            int v44 = (uint64_t **)*v44;
            uint64_t v17 = *v20;
          }
          sub_100046C90(v45, v17);
          ++v46;
          uint64_t v13 = *(void *)&buf[8];
          *(void *)&uint8_t buf[16] = *(void *)&buf[8];
          if (*(void *)&buf[8]) {
            *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
          }
          long long v21 = (void *)v10[1];
          if (v21)
          {
            do
            {
              long long v22 = v21;
              long long v21 = (void *)*v21;
            }
            while (v21);
          }
          else
          {
            do
            {
              long long v22 = (void *)v10[2];
              BOOL v23 = *v22 == (void)v10;
              uint64_t v10 = v22;
            }
            while (!v23);
          }
          if (!v13) {
            break;
          }
          uint64_t v10 = v22;
        }
        while (v22 != v11);
      }
      sub_100E9774C((uint64_t)buf);
      uint64_t v10 = v22;
    }
    if (v10 != v11)
    {
      do
      {
        *(void *)&uint8_t buf[16] = 0;
        uint64_t v24 = (uint64_t *)operator new(0x48uLL);
        long long v25 = v24;
        *(void *)long long buf = v24;
        *(void *)&uint8_t buf[8] = &v45;
        long long v26 = v24 + 4;
        if (*((char *)v10 + 55) < 0)
        {
          sub_10004FC84((unsigned char *)v24 + 32, (void *)v10[4], v10[5]);
        }
        else
        {
          long long v27 = *((_OWORD *)v10 + 2);
          v24[6] = v10[6];
          *(_OWORD *)long long v26 = v27;
        }
        v25[7] = v10[7];
        uint64_t v28 = v10[8];
        v25[8] = v28;
        if (v28) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
        }
        uint8_t buf[16] = 1;
        uint64_t v29 = v45;
        uint64_t v30 = &v45;
        uint64_t v31 = &v45;
        if (v45)
        {
          do
          {
            while (1)
            {
              uint64_t v30 = (uint64_t **)v29;
              if ((sub_100046FE8(v26, (void **)v29 + 4) & 0x80) == 0) {
                break;
              }
              uint64_t v29 = *v30;
              uint64_t v31 = v30;
              if (!*v30) {
                goto LABEL_53;
              }
            }
            uint64_t v29 = v30[1];
          }
          while (v29);
          uint64_t v31 = v30 + 1;
        }
LABEL_53:
        uint64_t *v25 = 0;
        v25[1] = 0;
        v25[2] = (uint64_t)v30;
        std::__shared_weak_count *v31 = v25;
        if (*v44)
        {
          int v44 = (uint64_t **)*v44;
          long long v25 = *v31;
        }
        sub_100046C90(v45, v25);
        ++v46;
        *(void *)long long buf = 0;
        sub_1001FEBC4((uint64_t)buf);
        unint64_t v32 = (void *)v10[1];
        if (v32)
        {
          do
          {
            CFStringRef v33 = v32;
            unint64_t v32 = (void *)*v32;
          }
          while (v32);
        }
        else
        {
          do
          {
            CFStringRef v33 = (void *)v10[2];
            BOOL v23 = *v33 == (void)v10;
            uint64_t v10 = v33;
          }
          while (!v23);
        }
        uint64_t v10 = v33;
      }
      while (v33 != v11);
    }
  }
  std::mutex::unlock(v9);
  uint64_t v34 = v44;
  if (v44 != &v45)
  {
    unsigned int v35 = 0;
    do
    {
      int v36 = (*(uint64_t (**)(uint64_t *))(*v34[7] + 288))(v34[7]);
      uint64_t v37 = v34[1];
      if (v37)
      {
        do
        {
          long long v38 = (uint64_t **)v37;
          uint64_t v37 = (uint64_t *)*v37;
        }
        while (v37);
      }
      else
      {
        do
        {
          long long v38 = (uint64_t **)v34[2];
          BOOL v23 = *v38 == (uint64_t *)v34;
          uint64_t v34 = v38;
        }
        while (!v23);
      }
      v35 += v36;
      uint64_t v34 = v38;
    }
    while (v38 != &v45);
    uint64_t v39 = v44;
    if (v44 != &v45)
    {
      do
      {
        __int16 v40 = v39[7];
        if (v5 < 2) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = (v35 > 1) & ~sub_10001D294((unsigned __int8 *)&v47, (unsigned __int8 *)v39 + 32);
        }
        (*(void (**)(uint64_t *, uint64_t))(*v40 + 240))(v40, v41);
        CFNumberRef v42 = v39[1];
        if (v42)
        {
          do
          {
            uint64_t v43 = (uint64_t **)v42;
            CFNumberRef v42 = (uint64_t *)*v42;
          }
          while (v42);
        }
        else
        {
          do
          {
            uint64_t v43 = (uint64_t **)v39[2];
            BOOL v23 = *v43 == (uint64_t *)v39;
            uint64_t v39 = v43;
          }
          while (!v23);
        }
        uint64_t v39 = v43;
      }
      while (v43 != &v45);
    }
  }
  sub_1001FEC70(v45);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
}

void sub_100E918C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E91928(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a2 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E91A08(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E91AE8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E91BC8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = (std::mutex *)(a1 + 904);
  std::mutex::lock((std::mutex *)(a1 + 904));
  CFMutableDictionaryRef theDict = 0;
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 968);
  if (v5) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v5);
    CFMutableDictionaryRef v8 = theDict;
    CFMutableDictionaryRef theDict = MutableCopy;
    CFMutableDictionaryRef v9 = v8;
    sub_10005717C((const void **)&v9);
    CFDictionaryRemoveValue(theDict, kPSAccountList);
    LOBYTE(v6) = 1;
    LOBYTE(v9) = 1;
    CFMutableDictionaryRef v10 = theDict;
    if (theDict)
    {
      CFRetain(theDict);
      LOBYTE(v6) = 1;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
    CFMutableDictionaryRef v10 = 0;
  }
  *(unsigned char *)a2 = (_BYTE)v6;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&v10);
  sub_10005717C((const void **)&v10);
  sub_10005717C((const void **)&theDict);
  std::mutex::unlock(v4);
}

void sub_100E91CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  std::mutex::unlock(v4);
  _Unwind_Resume(a1);
}

void sub_100E91CF4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = (std::mutex *)(a1 + 904);
  std::mutex::lock((std::mutex *)(a1 + 904));
  CFMutableDictionaryRef theDict = 0;
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 968);
  if (v5) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v5);
    CFMutableDictionaryRef v8 = theDict;
    CFMutableDictionaryRef theDict = MutableCopy;
    CFMutableDictionaryRef v9 = v8;
    sub_10005717C((const void **)&v9);
    CFDictionaryRemoveValue(theDict, kPSDeviceList);
    LOBYTE(v6) = 1;
    LOBYTE(v9) = 1;
    CFMutableDictionaryRef v10 = theDict;
    if (theDict)
    {
      CFRetain(theDict);
      LOBYTE(v6) = 1;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
    CFMutableDictionaryRef v10 = 0;
  }
  *(unsigned char *)a2 = (_BYTE)v6;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&v10);
  sub_10005717C((const void **)&v10);
  sub_10005717C((const void **)&theDict);
  std::mutex::unlock(v4);
}

void sub_100E91DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  std::mutex::unlock(v4);
  _Unwind_Resume(a1);
}

void sub_100E91E20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100E9A03C((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E91F54(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100E91F64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100E9A03C((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E92098(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100E920A8(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 776);
  uint64_t v3 = (unsigned __int8 *)(a1 + 784);
  if (v2 != (unsigned __int8 *)(a1 + 784))
  {
    do
    {
      uint64_t v4 = *(void *)(a1 + 696);
      uint64_t v5 = *(void **)v4;
      uint64_t v6 = *(void **)(v4 + 8);
      if (*(void **)v4 == v6) {
        goto LABEL_18;
      }
      while (!sub_10001D294((unsigned __int8 *)(*v5 + 24), v2 + 32))
      {
        v5 += 2;
        if (v5 == v6)
        {
          uint64_t v5 = v6;
          break;
        }
      }
      if (v5 == *(void **)(v4 + 8))
      {
LABEL_18:
        uint64_t v7 = 0;
      }
      else
      {
        uint64_t v8 = *v5;
        uint64_t v7 = (std::__shared_weak_count *)v5[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8)
        {
          CFMutableDictionaryRef v9 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = *(const char **)(v8 + 24);
            uint64_t v11 = v8 + 24;
            CFMutableDictionaryRef v10 = v12;
            int v13 = *(_DWORD *)(v11 + 32);
            uint64_t v14 = *(unsigned __int8 *)(v11 + 23);
            int v15 = (char)v14;
            if ((v14 & 0x80u) != 0) {
              uint64_t v14 = *(void *)(v11 + 8);
            }
            if (v15 >= 0) {
              CFMutableDictionaryRef v10 = (const char *)v11;
            }
            if (!v14) {
              CFMutableDictionaryRef v10 = "<invalid>";
            }
            int buf = 136315906;
            *(void *)buf_4 = "";
            *(_WORD *)&uint8_t buf_4[8] = 2080;
            *(void *)&buf_4[10] = "";
            __int16 v38 = 1024;
            *(_DWORD *)uint64_t v39 = v13;
            *(_WORD *)&_OWORD v39[4] = 2080;
            *(void *)&v39[6] = v10;
            uint64_t v16 = v9;
            uint64_t v17 = "#I %s%s| ---- %d: %s";
            uint32_t v18 = 38;
LABEL_28:
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&buf, v18);
            goto LABEL_29;
          }
          goto LABEL_29;
        }
      }
      long long v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = v2[55];
        BOOL v21 = (v20 & 0x80u) != 0;
        if ((v20 & 0x80u) != 0) {
          uint64_t v20 = *((void *)v2 + 5);
        }
        if (v21) {
          long long v22 = (const char *)*((void *)v2 + 4);
        }
        else {
          long long v22 = (const char *)(v2 + 32);
        }
        BOOL v23 = v20 == 0;
        uint64_t v24 = "<invalid>";
        if (!v23) {
          uint64_t v24 = v22;
        }
        int buf = 136315650;
        *(void *)buf_4 = "";
        *(_WORD *)&uint8_t buf_4[8] = 2080;
        *(void *)&buf_4[10] = "";
        __int16 v38 = 2080;
        *(void *)uint64_t v39 = v24;
        uint64_t v16 = v19;
        uint64_t v17 = "#I %s%s| ---- -: %s (personality is gone)";
        uint32_t v18 = 32;
        goto LABEL_28;
      }
LABEL_29:
      (*(void (**)(void))(**((void **)v2 + 7) + 464))(*((void *)v2 + 7));
      if (v7) {
        sub_10004D2C8(v7);
      }
      long long v25 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v25)
      {
        do
        {
          long long v26 = v25;
          long long v25 = *(unsigned __int8 **)v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          long long v26 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v23 = *(void *)v26 == (void)v2;
          uint64_t v2 = v26;
        }
        while (!v23);
      }
      uint64_t v2 = v26;
    }
    while (v26 != v3);
  }
  long long v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    int buf = 136315394;
    *(void *)buf_4 = "";
    *(_WORD *)&uint8_t buf_4[8] = 2080;
    *(void *)&buf_4[10] = "";
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%s| ----", (uint8_t *)&buf, 0x16u);
    long long v27 = *(NSObject **)(a1 + 40);
  }
  int v28 = *(unsigned __int8 *)(a1 + 424);
  BOOL v29 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
  if (v28)
  {
    if (!v29) {
      goto LABEL_47;
    }
    uint64_t v30 = (void *)(a1 + 432);
    if (*(char *)(a1 + 455) < 0) {
      uint64_t v30 = (void *)*v30;
    }
    uint64_t v31 = cellplan::asString();
    int buf = 136315906;
    *(void *)buf_4 = "";
    *(_WORD *)&uint8_t buf_4[8] = 2080;
    *(void *)&buf_4[10] = "";
    __int16 v38 = 2080;
    *(void *)uint64_t v39 = v30;
    *(_WORD *)&v39[8] = 2080;
    *(void *)&v39[10] = v31;
    unint64_t v32 = "#I %s%s| Vinyl Sim info: [%s: %s]";
    CFStringRef v33 = v27;
    uint32_t v34 = 42;
  }
  else
  {
    if (!v29) {
      goto LABEL_47;
    }
    int buf = 136315394;
    *(void *)buf_4 = "";
    *(_WORD *)&uint8_t buf_4[8] = 2080;
    *(void *)&buf_4[10] = "";
    unint64_t v32 = "#I %s%s| Vinyl Sim info: unavailable";
    CFStringRef v33 = v27;
    uint32_t v34 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&buf, v34);
LABEL_47:
  uint64_t v35 = *(void *)(a1 + 888);
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 64))(v35);
  }
  sub_1003A9CA0(&buf);
  sub_1003A9D84();
  if (*(void *)&buf_4[4]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
  }
}

void sub_100E924AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E924DC(uint64_t a1)
{
  double result = *(void **)(a1 + 888);
  if (result) {
    return (void *)sub_100805B8C(result);
  }
  return result;
}

void *sub_100E924EC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E92570(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E925F4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100E92678(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100E926FC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v55 = a1;
  uint64_t v56 = v1;
  std::string::size_type v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sBootstrap", (uint8_t *)&buf, 0x16u);
  }
  LOBYTE(v57[0]) = 0;
  uint64_t v4 = sub_100365D74();
  sub_100058DB0(&buf, "VoWiFiLocationEvaluated");
  sub_1002260B0(v4, (void **)&buf.__r_.__value_.__l.__data_, (BOOL *)v57);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (LOBYTE(v57[0]))
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_47;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    uint64_t v6 = "#I %s%sWiFiLocation already evaluated before. Nothing to do";
    goto LABEL_46;
  }
  uint64_t v7 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&buf, "VoWiFiLocationEvaluated");
  LOBYTE(__p) = 1;
  sub_1002264FC(v7, &buf, (unsigned __int8 *)&__p);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  uint64_t v8 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sEvaluating WiFiLocation once", (uint8_t *)&buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(v2 + 56));
  uint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      std::string::size_type v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_18;
      }
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
  if (!v18)
  {
LABEL_18:
    uint64_t v20 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%sNo PersonalityShop. Consider this a fresh install", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_42;
  }
LABEL_22:
  std::string __p = 0;
  char v59 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(&__p, v18, 1);
  BOOL v21 = __p;
  long long v22 = *(NSObject **)(v2 + 40);
  BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (v21)
  {
    if (v23)
    {
      long long v26 = (const char *)v21[3];
      long long v25 = (char *)(v21 + 3);
      uint64_t v24 = v26;
      uint64_t v27 = v25[23];
      BOOL v28 = (v27 & 0x80u) != 0;
      if ((v27 & 0x80u) != 0) {
        uint64_t v27 = *((void *)v25 + 1);
      }
      if (!v28) {
        uint64_t v24 = v25;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      if (!v27) {
        uint64_t v24 = "<invalid>";
      }
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      p_std::string buf = (std::string *)v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sFound Personality ID: '%s'", (uint8_t *)&buf, 0x20u);
    }
    int v29 = isReal();
    if (v59) {
      sub_10004D2C8(v59);
    }
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
    if (v29)
    {
      uint64_t v5 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_47;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      uint64_t v6 = "#I %s%sDevice being migrated. Keep current WiFiLocation status";
      goto LABEL_46;
    }
    goto LABEL_44;
  }
  if (v23)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sNo PersonalityInfo. Consider this a fresh install", (uint8_t *)&buf, 0x16u);
  }
  if (v59) {
    sub_10004D2C8(v59);
  }
LABEL_42:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
LABEL_44:
  *(unsigned char *)(v2 + 976) = 1;
  uint64_t v5 = *(NSObject **)(v2 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_47;
  }
  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
  uint64_t v6 = "#I %s%sFresh install. Need to disable WiFiLocation status";
LABEL_46:
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&buf, 0x16u);
LABEL_47:
  std::string::size_type v30 = v2 + 88;
  std::string::size_type v31 = v2 + 72;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A66188;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  if (&buf != (std::string *)(v2 + 88))
  {
    unint64_t v32 = *(std::string **)(v2 + 112);
    if (v32 == (std::string *)v30)
    {
      char v59 = (std::__shared_weak_count *)(v2 + 72);
      uint64_t v60 = 0;
      std::string __p = off_101A66188;
      p_std::string buf = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v30 + 24))(v2 + 88, &buf);
      (*(void (**)(void))(**(void **)(v2 + 112) + 32))(*(void *)(v2 + 112));
      *(void *)(v2 + 112) = 0;
      p_std::string buf = &buf;
      (*((void (**)(void **, std::string::size_type))__p + 3))(&__p, v2 + 88);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 88) = off_101A66188;
      *(void *)(v2 + 96) = v31;
      p_std::string buf = v32;
    }
    *(void *)(v2 + 112) = v30;
  }
  sub_100E92678(&buf);
  uint64_t v33 = *(void *)(v2 + 112);
  if (v33) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v33 + 48))(v33, v2 + 120);
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A66218;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  sub_100E938D4(&buf, (void *)(v2 + 200));
  sub_100E924EC(&buf);
  uint64_t v34 = *(void *)(v2 + 224);
  if (v34) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v34 + 48))(v34, v2 + 232);
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A662A8;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  sub_100E938D4(&buf, (void *)(v2 + 256));
  sub_100E924EC(&buf);
  uint64_t v35 = *(void *)(v2 + 280);
  if (v35) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v35 + 48))(v35, v2 + 288);
  }
  std::string::size_type v36 = v2 + 144;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A66328;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  if (&buf != (std::string *)(v2 + 144))
  {
    uint64_t v37 = *(std::string **)(v2 + 168);
    if (v37 == (std::string *)v36)
    {
      char v59 = (std::__shared_weak_count *)(v2 + 72);
      uint64_t v60 = 0;
      std::string __p = off_101A66328;
      p_std::string buf = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v36 + 24))(v2 + 144, &buf);
      (*(void (**)(void))(**(void **)(v2 + 168) + 32))(*(void *)(v2 + 168));
      *(void *)(v2 + 168) = 0;
      p_std::string buf = &buf;
      (*((void (**)(void **, std::string::size_type))__p + 3))(&__p, v2 + 144);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 144) = off_101A66328;
      *(void *)(v2 + 152) = v31;
      p_std::string buf = v37;
    }
    *(void *)(v2 + 168) = v36;
  }
  sub_100E925F4(&buf);
  uint64_t v38 = *(void *)(v2 + 168);
  if (v38) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v38 + 48))(v38, v2 + 176);
  }
  std::string::size_type v39 = v2 + 312;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A663B8;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  if (&buf != (std::string *)(v2 + 312))
  {
    __int16 v40 = *(std::string **)(v2 + 336);
    if (v40 == (std::string *)v39)
    {
      char v59 = (std::__shared_weak_count *)(v2 + 72);
      uint64_t v60 = 0;
      std::string __p = off_101A663B8;
      p_std::string buf = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v39 + 24))(v2 + 312, &buf);
      (*(void (**)(void))(**(void **)(v2 + 336) + 32))(*(void *)(v2 + 336));
      *(void *)(v2 + 336) = 0;
      p_std::string buf = &buf;
      (*((void (**)(void **, std::string::size_type))__p + 3))(&__p, v2 + 312);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 312) = off_101A663B8;
      *(void *)(v2 + 320) = v31;
      p_std::string buf = v40;
    }
    *(void *)(v2 + 336) = v39;
  }
  sub_100E92570(&buf);
  uint64_t v41 = *(void *)(v2 + 336);
  if (v41) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v41 + 48))(v41, v2 + 344);
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A66448;
  buf.__r_.__value_.__l.__size_ = v2 + 72;
  p_std::string buf = &buf;
  sub_100E938D4(&buf, (void *)(v2 + 368));
  sub_100E924EC(&buf);
  uint64_t v42 = *(void *)(v2 + 392);
  if (v42) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v42 + 48))(v42, v2 + 400);
  }
  uint64_t v43 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v43 || (std::string::size_type v44 = *(void *)(v2 + 8), (v45 = std::__shared_weak_count::lock(v43)) == 0)) {
    sub_100088B9C();
  }
  std::string::size_type v46 = (std::string::size_type)v45;
  atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v45);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A664C8;
  buf.__r_.__value_.__l.__size_ = v44;
  buf.__r_.__value_.__r.__words[2] = v46;
  p_std::string buf = &buf;
  uint64_t v61 = 0;
  std::string v47 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v47 || (uint64_t v48 = *(void *)(v2 + 8), (v49 = std::__shared_weak_count::lock(v47)) == 0)) {
    sub_100088B9C();
  }
  long long v50 = v49;
  atomic_fetch_add_explicit(&v49->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v49);
  v57[0] = off_101A66548;
  v57[1] = v48;
  v57[2] = v50;
  v57[3] = v57;
  PersonalitiesTracker::bind();
  sub_100100490(v57);
  sub_10010040C(&__p);
  sub_100100388(&buf);
  sub_100058DB0(&__p, "/cc/props/cellular_plan_remotesubscription_info");
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A665C8;
  buf.__r_.__value_.__l.__size_ = v2 + 424;
  buf.__r_.__value_.__r.__words[2] = v2;
  p_std::string buf = &buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v60) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  long long v51 = (std::string *)operator new(0x20uLL);
  v51->__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A66648;
  v51->__r_.__value_.__l.__size_ = v2;
  v51->__r_.__value_.__r.__words[2] = (std::string::size_type)sub_100E920A8;
  v51[1].__r_.__value_.__r.__words[0] = 0;
  p_std::string buf = v51;
  ctu::RestModule::observeEvent();
  sub_10003F600(&buf);
  if (SHIBYTE(v60) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/user_preferred_data_slot");
  uint64_t v52 = (std::string *)operator new(0x28uLL);
  v52->__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A666C8;
  v52->__r_.__value_.__l.__size_ = v2 + 536;
  v52->__r_.__value_.__r.__words[2] = v2;
  v52[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_100E9137C;
  v52[1].__r_.__value_.__l.__size_ = 0;
  p_std::string buf = v52;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v60) < 0) {
    operator delete(__p);
  }
  uint64_t v53 = *(void *)(v2 + 888);
  if (v53) {
    (*(void (**)(uint64_t))(*(void *)v53 + 48))(v53);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&buf, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (buf.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  sub_100088C88(&v56);
  return sub_100046B58((uint64_t *)&v55);
}

void sub_100E93448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100E93530()
{
}

void *sub_100E93544(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A66188;
  result[1] = v3;
  return result;
}

uint64_t sub_100E9358C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66188;
  a2[1] = v2;
  return result;
}

void sub_100E935B8(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A58F1C(a2, "PersonalityID", "State", &v5);
  sub_100058DB0(&__p, "/cc/props/vowifi_provisioning_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E93670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E936B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E936F4()
{
}

void sub_100E93704()
{
}

void *sub_100E93718(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A66218;
  result[1] = v3;
  return result;
}

uint64_t sub_100E93760(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66218;
  a2[1] = v2;
  return result;
}

void sub_100E9378C(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A596C4(a2, (uint64_t)"PersonalityID", (uint64_t)"State", &v5);
  sub_100058DB0(&__p, "/cc/props/volte_feature_support");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E93844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E93888(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E938C8()
{
}

void *sub_100E938D4(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100E93B3C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100E93B4C()
{
}

void *sub_100E93B60(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A662A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E93BA8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A662A8;
  a2[1] = v2;
  return result;
}

void sub_100E93BD4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A596C4(a2, (uint64_t)"PersonalityID", (uint64_t)"State", &v5);
  sub_100058DB0(&__p, "/cc/props/volte_network_support");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E93C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E93CD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E93D10()
{
}

void sub_100E93D20()
{
}

void *sub_100E93D34(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A66328;
  result[1] = v3;
  return result;
}

uint64_t sub_100E93D7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66328;
  a2[1] = v2;
  return result;
}

void sub_100E93DA8(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A584EC(a2, "PersonalityID", "IMSProvisioningState", &v5);
  sub_100058DB0(&__p, "/cc/props/ims_prov_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E93E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E93EA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E93EE4()
{
}

void sub_100E93EF4()
{
}

void *sub_100E93F08(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A663B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E93F50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A663B8;
  a2[1] = v2;
  return result;
}

void sub_100E93F7C(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A5A5CC(a2, "PersonalityID", "State", &v5);
  sub_100058DB0(&__p, "/cc/props/network_slicing_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E94034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E94078(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E940B8()
{
}

void sub_100E940C8()
{
}

void *sub_100E940DC(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = off_101A66448;
  result[1] = v3;
  return result;
}

uint64_t sub_100E94124(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66448;
  a2[1] = v2;
  return result;
}

void sub_100E94150(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A596C4(a2, (uint64_t)"PersonalityID", (uint64_t)"State", &v5);
  sub_100058DB0(&__p, "/cc/props/satellite_support");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100E94208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100E9424C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E9428C()
{
}

void *sub_100E94298(void *a1)
{
  *a1 = off_101A664C8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E942E4(void *a1)
{
  *a1 = off_101A664C8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100E94350(uint64_t a1)
{
  double result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *double result = off_101A664C8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E943AC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A664C8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E943E4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E943F4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E94434(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v4);
  if (!v6) {
    return;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    CFMutableDictionaryRef v9 = *(const std::string ****)(v8 + 696);
    CFMutableDictionaryRef v10 = *v9;
    uint64_t v11 = v9[1];
    std::string::size_type v12 = v10;
    if (v10 != v11)
    {
      std::string::size_type v12 = v10;
      while ((*v12)[2].__r_.__value_.__s.__data_[1] || HIDWORD((*v12)[2].__r_.__value_.__r.__words[0]) != 1)
      {
        v12 += 2;
        if (v12 == v11) {
          goto LABEL_14;
        }
      }
    }
    if (v12 == v11)
    {
LABEL_14:
      int v13 = 0;
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = *v12;
      int v13 = (std::__shared_weak_count *)v12[1];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        unsigned int v15 = *(const std::string ****)(v8 + 696);
        CFMutableDictionaryRef v10 = *v15;
        uint64_t v11 = v15[1];
      }
    }
    uint64_t v61 = v13;
    if (v10 == v11)
    {
      uint64_t v17 = 0;
      uint64_t v60 = 0;
    }
    else
    {
      uint64_t v16 = v10;
      while (1)
      {
        uint64_t v17 = *v16;
        if (!(*v16)[2].__r_.__value_.__s.__data_[1] && HIDWORD(v17[2].__r_.__value_.__r.__words[0]) == 2) {
          break;
        }
        v16 += 2;
        if (v16 == v11) {
          goto LABEL_20;
        }
      }
      if (v16 == v11)
      {
LABEL_20:
        uint64_t v18 = 0;
        uint64_t v17 = 0;
        goto LABEL_21;
      }
      uint64_t v18 = (std::__shared_weak_count *)v16[1];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::string::size_type v44 = *(const std::string ****)(v8 + 696);
        CFMutableDictionaryRef v10 = *v44;
        uint64_t v11 = v44[1];
      }
LABEL_21:
      uint64_t v60 = v18;
      if (v10 != v11)
      {
        while ((*v10)[2].__r_.__value_.__s.__data_[1] != 1)
        {
          v10 += 2;
          if (v10 == v11) {
            goto LABEL_27;
          }
        }
        uint64_t v11 = v10;
      }
    }
LABEL_27:
    std::mutex::lock((std::mutex *)(v8 + 712));
    char v19 = (std::string *)(v8 + 800);
    if (v14)
    {
      std::string::operator=(v19, v14 + 1);
    }
    else
    {
      memset(&__str, 0, sizeof(__str));
      std::string::operator=(v19, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v20 = (std::string *)(v8 + 824);
    if (v17)
    {
      std::string::operator=(v20, v17 + 1);
    }
    else
    {
      memset(&__str, 0, sizeof(__str));
      std::string::operator=(v20, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    if (v11 == *(const std::string ***)(*(void *)(v8 + 696) + 8))
    {
      memset(&__str, 0, sizeof(__str));
      std::string::operator=((std::string *)(v8 + 848), &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      std::string::operator=((std::string *)(v8 + 848), *v11 + 1);
    }
    std::mutex::unlock((std::mutex *)(v8 + 712));
    uint64_t v62 = 0;
    unsigned int v63 = 0;
    uint64_t v21 = *(void *)(v8 + 696);
    long long v22 = *(void **)v21;
    BOOL v23 = *(void **)(v21 + 8);
    if (*(void **)v21 == v23) {
      goto LABEL_53;
    }
    while (!sub_10001D294((unsigned __int8 *)(*v22 + 24), (unsigned __int8 *)a3))
    {
      v22 += 2;
      if (v22 == v23)
      {
        long long v22 = v23;
        break;
      }
    }
    if (v22 == *(void **)(v21 + 8))
    {
LABEL_53:
      uint64_t v62 = 0;
      unsigned int v63 = 0;
      if ((*(unsigned char *)(a3 + 24) & 0xFE) != 6) {
        goto LABEL_70;
      }
    }
    else
    {
      uint64_t v25 = *v22;
      uint64_t v24 = (std::__shared_weak_count *)v22[1];
      uint64_t v62 = *v22;
      unsigned int v63 = v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(unsigned char *)(a3 + 24) & 0xFE) != 6)
      {
        if (v25)
        {
          std::mutex::lock((std::mutex *)(v8 + 712));
          long long v26 = sub_100046F68(v8 + 776, (void **)a3);
          if ((void **)(v8 + 784) == v26)
          {
            std::mutex::unlock((std::mutex *)(v8 + 712));
            uint64_t v27 = 0;
          }
          else
          {
            BOOL v28 = v26[7];
            uint64_t v27 = (std::__shared_weak_count *)v26[8];
            if (v27) {
              atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            std::mutex::unlock((std::mutex *)(v8 + 712));
            if (v28)
            {
              sub_100E9137C(v8);
              uint64_t v58 = 1;
              switch(*(unsigned char *)(a3 + 24))
              {
                case 1:
                case 3:
                  goto LABEL_127;
                case 2:
                  uint64_t v58 = 0;
LABEL_127:
                  (*(void (**)(void *, uint64_t, uint64_t *))(*(void *)v28 + 248))(v28, v58, &v62);
                  goto LABEL_131;
                case 4:
                  char v59 = (void (**)(void *, uint64_t *))(*(void *)v28 + 256);
                  goto LABEL_130;
                case 5:
                  char v59 = (void (**)(void *, uint64_t *))(*(void *)v28 + 264);
LABEL_130:
                  (*v59)(v28, &v62);
                  break;
                default:
                  goto LABEL_131;
              }
              goto LABEL_131;
            }
          }
          uint64_t v45 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v46 = *(unsigned __int8 *)(a3 + 23);
            BOOL v47 = (v46 & 0x80u) != 0;
            uint64_t v48 = *(const char **)a3;
            if ((v46 & 0x80u) != 0) {
              uint64_t v46 = *(void *)(a3 + 8);
            }
            if (!v47) {
              uint64_t v48 = (const char *)a3;
            }
            if (v46) {
              uint64_t v49 = v48;
            }
            else {
              uint64_t v49 = "<invalid>";
            }
            LODWORD(__str.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            HIWORD(__str.__r_.__value_.__r.__words[2]) = 2080;
            int v65 = v49;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s%sCreating controller for %s", (uint8_t *)&__str, 0x20u);
          }
          if (*(unsigned char *)(v25 + 49) == 1)
          {
            std::string::size_type v54 = *(void *)(v8 + 64);
            __str.__r_.__value_.__r.__words[0] = *(void *)(v8 + 56);
            __str.__r_.__value_.__l.__size_ = v54;
            if (v54) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v54 + 8), 1uLL, memory_order_relaxed);
            }
            long long v55 = *(NSObject **)(v8 + 24);
            __str.__r_.__value_.__r.__words[2] = (std::string::size_type)v55;
            if (v55) {
              dispatch_retain(v55);
            }
            uint64_t v56 = *(void *)(v8 + 992);
            int v65 = *(const char **)(v8 + 984);
            uint64_t v66 = v56;
            if (v56) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v56 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v57 = *(void *)(v8 + 896);
            uint64_t v67 = *(void *)(v8 + 888);
            uint64_t v68 = v57;
            if (v57) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v57 + 8), 1uLL, memory_order_relaxed);
            }
            sub_1004DF4B4();
          }
          if (!*(unsigned char *)(v25 + 49))
          {
            std::string::size_type v50 = *(void *)(v8 + 64);
            __str.__r_.__value_.__r.__words[0] = *(void *)(v8 + 56);
            __str.__r_.__value_.__l.__size_ = v50;
            if (v50) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
            }
            long long v51 = *(NSObject **)(v8 + 24);
            __str.__r_.__value_.__r.__words[2] = (std::string::size_type)v51;
            if (v51) {
              dispatch_retain(v51);
            }
            uint64_t v52 = *(void *)(v8 + 992);
            int v65 = *(const char **)(v8 + 984);
            uint64_t v66 = v52;
            if (v52) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v53 = *(void *)(v8 + 896);
            uint64_t v67 = *(void *)(v8 + 888);
            uint64_t v68 = v53;
            if (v53) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
            }
            PSControlSIM::create();
          }
LABEL_131:
          if (v27) {
            sub_10004D2C8(v27);
          }
LABEL_86:
          if (v63) {
            sub_10004D2C8(v63);
          }
          if (v60) {
            sub_10004D2C8(v60);
          }
          if (v61) {
            sub_10004D2C8(v61);
          }
          goto LABEL_92;
        }
LABEL_70:
        uint64_t v38 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = *(unsigned __int8 *)(a3 + 23);
          BOOL v40 = (v39 & 0x80u) != 0;
          if ((v39 & 0x80u) != 0) {
            uint64_t v39 = *(void *)(a3 + 8);
          }
          if (v40) {
            uint64_t v41 = *(const char **)a3;
          }
          else {
            uint64_t v41 = (const char *)a3;
          }
          if (v39) {
            uint64_t v42 = v41;
          }
          else {
            uint64_t v42 = "<invalid>";
          }
          LODWORD(__str.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          HIWORD(__str.__r_.__value_.__r.__words[2]) = 2080;
          int v65 = v42;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s%s--- UNEXPECTED, Personality %s does not exist", (uint8_t *)&__str, 0x20u);
        }
        goto LABEL_86;
      }
    }
    std::mutex::lock((std::mutex *)(v8 + 712));
    int v29 = sub_100046F68(v8 + 776, (void **)a3);
    if ((void **)(v8 + 784) != v29)
    {
      char v30 = v29;
      std::string::size_type v31 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = *(unsigned __int8 *)(a3 + 23);
        BOOL v33 = (v32 & 0x80u) != 0;
        if ((v32 & 0x80u) != 0) {
          uint64_t v32 = *(void *)(a3 + 8);
        }
        if (v33) {
          uint64_t v34 = *(const char **)a3;
        }
        else {
          uint64_t v34 = (const char *)a3;
        }
        if (v32) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = "<invalid>";
        }
        LODWORD(__str.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(__str.__r_.__value_.__r.__words[2]) = 2080;
        int v65 = v35;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%sRemoving controller for %s", (uint8_t *)&__str, 0x20u);
      }
      std::string::size_type v36 = (atomic_ullong *)v30[8];
      if (v36) {
        atomic_fetch_add_explicit(v36 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v37 = *(std::__shared_weak_count **)(v8 + 16);
      if (v37 && std::__shared_weak_count::lock(v37)) {
        operator new();
      }
      sub_100088B9C();
    }
    uint64_t v43 = *(void *)(v8 + 888);
    memset(&__str, 0, sizeof(__str));
    (*(void (**)(uint64_t, std::string *))(*(void *)v43 + 72))(v43, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::mutex::unlock((std::mutex *)(v8 + 712));
    goto LABEL_86;
  }
LABEL_92:

  sub_10004D2C8(v7);
}

void sub_100E94F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, std::__shared_weak_count *a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_1001FEBC4((uint64_t)&a16);
  sub_1002B1A40((uint64_t)&__p);
  std::mutex::unlock(a11);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_100E9505C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E9509C()
{
}

void *sub_100E950A8(void *a1)
{
  *a1 = off_101A66548;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E950F4(void *a1)
{
  *a1 = off_101A66548;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100E95160(uint64_t a1)
{
  double result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *double result = off_101A66548;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E951BC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A66548;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E951F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E95204(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E95244(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(void *)(a1 + 8)) {
        sub_100E903CC();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100E952A4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E952B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E952F8()
{
}

void sub_100E95308()
{
}

__n128 sub_100E9531C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A665C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E95368(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A665C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E95398(uint64_t a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  sub_1003C8A7C(*(unsigned char **)(a1 + 8), a2);
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = *(unsigned __int8 *)(v3 + 424);
  xpc_object_t v5 = *(NSObject **)(v3 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6) {
      goto LABEL_8;
    }
    char isSimReadyToUse = cellplan::RemoteSimSubscriptionInfo::isSimReadyToUse((cellplan::RemoteSimSubscriptionInfo *)(v3 + 432));
    uint64_t v8 = asStringBool(isSimReadyToUse);
    if (!*(unsigned char *)(v3 + 424)) {
      __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
    }
    int v12 = 136315906;
    int v13 = "";
    __int16 v14 = 2080;
    unsigned int v15 = "";
    __int16 v16 = 2080;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = cellplan::asString();
    CFMutableDictionaryRef v9 = "#I %s%sVinylSimInfo: readyToUse: %s, status: %s";
    CFMutableDictionaryRef v10 = v5;
    uint32_t v11 = 42;
  }
  else
  {
    if (!v6) {
      goto LABEL_8;
    }
    int v12 = 136315394;
    int v13 = "";
    __int16 v14 = 2080;
    unsigned int v15 = "";
    CFMutableDictionaryRef v9 = "#I %s%sVinylSimInfo not available";
    CFMutableDictionaryRef v10 = v5;
    uint32_t v11 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, v11);
LABEL_8:
  sub_100E91A08(v3);
}

uint64_t sub_100E95508(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E95548()
{
}

void sub_100E95558()
{
}

__n128 sub_100E9556C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A66648;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100E955C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A66648;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E955F8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100E95640(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E95680()
{
}

void sub_100E95690()
{
}

__n128 sub_100E956A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A666C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100E956F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A666C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100E95730(void *a1, xpc_object_t *a2)
{
  int v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    *int v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *int v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  CFMutableDictionaryRef v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint32_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    CFMutableDictionaryRef v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100E95820(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E95860()
{
}

void sub_100E9586C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 136315394;
    *(void *)&buf[1] = "";
    __int16 v3 = 2080;
    int v4 = "";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s%sStarting", (uint8_t *)buf, 0x16u);
  }
  sub_100E903CC();
}

void sub_100E962A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, char a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,dispatch_object_t object,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  operator delete();
}

void sub_100E963EC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        uint64_t v5 = a1[6];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        BOOL v6 = *(std::__shared_weak_count **)(v3 + 16);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100E96540(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E9655C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E9656C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        BOOL v6 = (unsigned __int8 *)v3[97];
        if (v6 != (unsigned __int8 *)(v3 + 98))
        {
          do
          {
            if (isReal())
            {
              uint64_t v7 = v3[87];
              uint64_t v8 = *(void **)v7;
              CFMutableDictionaryRef v9 = *(void **)(v7 + 8);
              if (*(void **)v7 != v9)
              {
                while (!sub_10001D294((unsigned __int8 *)(*v8 + 24), v6 + 32))
                {
                  v8 += 2;
                  if (v8 == v9)
                  {
                    uint64_t v8 = v9;
                    break;
                  }
                }
                if (v8 != *(void **)(v7 + 8))
                {
                  uint64_t v10 = *v8;
                  uint32_t v11 = (std::__shared_weak_count *)v8[1];
                  if (v11) {
                    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (v10 && *(unsigned char *)(v10 + 48)) {
                    (*(void (**)(void))(**((void **)v6 + 7) + 24))(*((void *)v6 + 7));
                  }
                  if (v11) {
                    sub_10004D2C8(v11);
                  }
                }
              }
            }
            int v12 = (unsigned __int8 *)*((void *)v6 + 1);
            if (v12)
            {
              do
              {
                int v13 = v12;
                int v12 = *(unsigned __int8 **)v12;
              }
              while (v12);
            }
            else
            {
              do
              {
                int v13 = (unsigned __int8 *)*((void *)v6 + 2);
                BOOL v14 = *(void *)v13 == (void)v6;
                BOOL v6 = v13;
              }
              while (!v14);
            }
            BOOL v6 = v13;
          }
          while (v13 != (unsigned __int8 *)(v3 + 98));
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100E966E8(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E96710(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        BOOL v6 = *(void **)(v3 + 776);
        uint64_t v7 = (void *)(v3 + 784);
        if (v6 != v7)
        {
          do
          {
            uint64_t v8 = (void **)v6[7];
            if (*(_DWORD *)(*v8[10] + 52) == *(_DWORD *)(v1 + 28)) {
              ((void (*)(void **, void))(*v8)[2])(v8, *(unsigned int *)(v1 + 24));
            }
            CFMutableDictionaryRef v9 = (void *)v6[1];
            if (v9)
            {
              do
              {
                uint64_t v10 = v9;
                CFMutableDictionaryRef v9 = (void *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                uint64_t v10 = (void *)v6[2];
                BOOL v11 = *v10 == (void)v6;
                BOOL v6 = v10;
              }
              while (!v11);
            }
            BOOL v6 = v10;
          }
          while (v10 != v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100E9682C(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100E96808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100E9682C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E9682C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100E96880(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100E968F8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100E9690C(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100E96958(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_100E969AC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_100E96A10(uint64_t a1)
{
  uint64_t v15 = a1;
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(NSObject **)(*(void *)a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sMigration", buf, 0x16u);
  }
  uint64_t v4 = a1 + 8;
  *(void *)std::string buf = a1 + 8;
  *(void *)&uint8_t buf[8] = "kIsRestore";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  *(void *)std::string buf = v4;
  *(void *)&uint8_t buf[8] = "kIsDifferentDevice";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  VoLteControl::sHandleMigrationForAll((Registry **)(v2 + 56), v6, v8);
  CFMutableDictionaryRef v9 = *(void **)(v2 + 776);
  uint64_t v10 = (void *)(v2 + 784);
  if (v9 != v10)
  {
    do
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)v9[7] + 320))(v9[7], v6, v8);
      BOOL v11 = (void *)v9[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v9[2];
          BOOL v13 = *v12 == (void)v9;
          CFMutableDictionaryRef v9 = v12;
        }
        while (!v13);
      }
      CFMutableDictionaryRef v9 = v12;
    }
    while (v12 != v10);
  }
  return sub_100E969AC(&v15);
}

void sub_100E96BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100E96C20(void **a1)
{
  uint64_t v1 = *a1;
  int v12 = a1;
  BOOL v13 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void **)(*v1 + 776);
  uint64_t v4 = *v1 + 784;
  if (v3 != (void *)v4)
  {
    do
    {
      uint64_t v5 = v3[7];
      uint64_t v6 = v1[1];
      dispatch_group_t group = v6;
      if (v6)
      {
        dispatch_retain(v6);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v5 + 224))(v5, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      (*(void (**)(void))(*(void *)v3[7] + 232))(v3[7]);
      BOOL v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != (void *)v4);
  }
  uint64_t v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    __int16 v16 = "";
    __int16 v17 = 2080;
    __int16 v18 = "";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sShutting down", buf, 0x16u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  sub_100088C88((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100E96DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
}

void sub_100E96E18(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100E96E50(uint64_t a1)
{
}

uint64_t sub_100E96E6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100E96EB0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

void sub_100E96EDC(capabilities::ct *a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v8 = a1;
  BOOL v9 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = (capabilities::ct *)capabilities::ct::supportsThumperSourcing(a1);
  if (v3) {
    sub_100C6A024();
  }
  if (capabilities::ct::supportsThumperService(v3)) {
    sub_100467858();
  }
  uint64_t v4 = v2[8];
  uint64_t v10 = v2[7];
  uint64_t v11 = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = v2[3];
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  uint64_t v6 = v2[124];
  uint64_t v13 = v2[123];
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = v2[112];
  uint64_t v15 = v2[111];
  uint64_t v16 = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1003ED57C();
}

void sub_100E97030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void sub_100E9705C(ServiceManager::Service *this)
{
  *(void *)this = off_101A668D0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E970B8(ServiceManager::Service *this)
{
  *(void *)this = off_101A668D0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100E97128@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PhoneServices");
}

unsigned char *sub_100E97138@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100E97174(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100E902A4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100E902A4(v4, 0);
}

uint64_t sub_100E971F8()
{
  return 1;
}

uint64_t sub_100E97200()
{
  return 1;
}

uint64_t sub_100E97208()
{
  return 2;
}

void sub_100E97210(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v6 = *a3;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_100E90A40(v4, v5);
  }
  sub_100E90A40(v4, v5);
}

void sub_100E972AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E9738C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100E974A0(ServiceManager::Service *this)
{
  *(void *)this = off_101A668D0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100E974FC(ServiceManager::Service *this)
{
  *(void *)this = off_101A668D0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100E9756C()
{
  return 0;
}

uint64_t sub_100E97574()
{
  return 0;
}

uint64_t *sub_100E97580(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = **(void **)(v1 + 8);
  if (*(unsigned char *)v1 == 6) {
    uint64_t v3 = (void (**)(void))(v2 + 272);
  }
  else {
    uint64_t v3 = (void (**)(void))(v2 + 280);
  }
  (*v3)();
  uint64_t v4 = dispatch_group_create();
  xpc_object_t v5 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v5);
    dispatch_release(v5);
    uint64_t v6 = *(void *)(v1 + 8);
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  else
  {
    uint64_t v6 = *(void *)(v1 + 8);
  }
  dispatch_group_t group = v5;
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 224))(v6, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v5)
  {
    dispatch_group_leave(v5);
    dispatch_release(v5);
  }
  sub_100E976F8(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100E976A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v12)
  {
    dispatch_group_leave(v12);
    dispatch_release(v12);
  }
  sub_100E976F8(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E976F8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100E9774C(uint64_t a1)
{
  sub_1001FEC70(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1001FEC70(v2);
  }
  return a1;
}

void sub_100E9779C(uint64_t **a1)
{
  uint64_t v7 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(void **)(v1 + 776);
  uint64_t v3 = (void *)(v1 + 784);
  if (v2 != (void *)(v1 + 784))
  {
    do
    {
      sub_100A2E378(v2[7], 1);
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          xpc_object_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          xpc_object_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  operator delete();
}

void sub_100E97848()
{
}

void sub_100E97874(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%srecalculateCapabilities", buf, 0x16u);
  }
  v196[0] = 0;
  v196[1] = 0;
  v194[1] = 0;
  os_log_t v195 = (uint64_t *)v196;
  BOOL v193 = v194;
  v194[0] = 0;
  v192[0] = 0;
  v192[1] = 0;
  int v191 = v192;
  int v189 = 0;
  uint64_t v190 = 0;
  uint64_t v187 = 0;
  CFDictionaryRef v188 = &v189;
  uint64_t v185 = (uint64_t *)&v186;
  CFStringRef v186 = 0;
  v184[0] = 0;
  v184[1] = 0;
  uint64_t v183 = v184;
  uint64_t v3 = (unsigned __int8 *)(v1 + 784);
  uint64_t v4 = *(unsigned __int8 **)(v1 + 776);
  if (v4 == (unsigned __int8 *)(v1 + 784))
  {
    LOBYTE(v5) = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(v1 + 696);
      uint64_t v7 = *(void **)v6;
      uint64_t v8 = *(void **)(v6 + 8);
      if (*(void **)v6 != v8)
      {
        do
        {
          if (sub_10001D294((unsigned __int8 *)(*v7 + 24), v4 + 32)) {
            goto LABEL_9;
          }
          v7 += 2;
        }
        while (v7 != v8);
        uint64_t v7 = v8;
LABEL_9:
        if (v7 != *(void **)(v6 + 8))
        {
          uint64_t v9 = *v7;
          uint64_t v10 = (std::__shared_weak_count *)v7[1];
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v9)
          {
            if (*(unsigned char *)(v9 + 49))
            {
              BOOL v11 = 0;
            }
            else
            {
              sub_100A32090(*((void *)v4 + 7), (uint64_t)buf);
              BOOL v11 = *(_DWORD *)buf != 0;
              if (LOBYTE(v199[0]) && SHIBYTE(v198) < 0) {
                operator delete(*(void **)&buf[8]);
              }
            }
            *(void *)std::string buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            sub_100A3210C(*((void *)v4 + 7), 2, buf);
            v5 |= v11;
            if (**(unsigned char **)buf && *(_DWORD *)(*(void *)buf + 16) == 2) {
              v5 |= capabilities::ct::supportsVoiceCall(v12);
            }
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          if (v10) {
            sub_10004D2C8(v10);
          }
        }
      }
      uint64_t v13 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = *(unsigned __int8 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v31 = *(void *)v14 == (void)v4;
          uint64_t v4 = v14;
        }
        while (!v31);
      }
      uint64_t v4 = v14;
    }
    while (v14 != v3);
    uint64_t v4 = *(unsigned __int8 **)(v1 + 776);
  }
  if (v4 != v3)
  {
    char v173 = v5;
    do
    {
      uint64_t v15 = *(void *)(v1 + 696);
      uint64_t v16 = *(void **)v15;
      __int16 v17 = *(void **)(v15 + 8);
      if (*(void **)v15 != v17)
      {
        __int16 v18 = v4 + 32;
        do
        {
          if (sub_10001D294((unsigned __int8 *)(*v16 + 24), v4 + 32)) {
            goto LABEL_40;
          }
          v16 += 2;
        }
        while (v16 != v17);
        uint64_t v16 = v17;
LABEL_40:
        if (v16 != *(void **)(v15 + 8))
        {
          uint64_t v19 = *v16;
          uint64_t v20 = (std::__shared_weak_count *)v16[1];
          if (v20) {
            atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v19)
          {
            uint64_t v182 = 0;
            *(_OWORD *)std::string __p = 0u;
            long long v181 = 0u;
            sub_100A32090(*((void *)v4 + 7), (uint64_t)__p);
            if (((*(unsigned char *)(v19 + 49) == 1) & v5) == 1) {
              LODWORD(__p[0]) = 0;
            }
            if ((char)v4[55] < 0)
            {
              sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
            }
            else
            {
              *(_OWORD *)std::string buf = *v18;
              *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
            }
            LODWORD(v198) = __p[0];
            BYTE4(v198) = BYTE4(__p[0]);
            sub_1000593FC((uint64_t)v199, (long long *)&__p[1]);
            sub_100A5ADA8(&v195, (void **)buf, (long long *)buf);
            if (v201 && v200 < 0) {
              operator delete(v199[0]);
            }
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            int v21 = (int)__p[0];
            int v178 = 0;
            uint64_t v179 = 0;
            sub_100A3210C(*((void *)v4 + 7), 2, &v178);
            long long v22 = v178;
            BOOL v23 = v178[4] == 2;
            if ((char)v4[55] < 0)
            {
              sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
            }
            else
            {
              *(_OWORD *)std::string buf = *v18;
              *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
            }
            LOBYTE(v198) = v23;
            sub_10025675C((uint64_t **)&v193, (void **)buf, (uint64_t)buf);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            if ((char)v4[55] < 0)
            {
              sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
            }
            else
            {
              *(_OWORD *)std::string buf = *v18;
              *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
            }
            LOBYTE(v198) = *((unsigned char *)v22 + 12);
            sub_10025675C((uint64_t **)&v191, (void **)buf, (uint64_t)buf);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            unsigned int v24 = v22[4];
            CFTypeRef cf2 = 0;
            uint64_t v177 = 0;
            sub_100A3210C(*((void *)v4 + 7), 3, &cf2);
            unsigned int v25 = *((_DWORD *)cf2 + 4);
            if ((char)v4[55] < 0)
            {
              sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
            }
            else
            {
              *(_OWORD *)std::string buf = *v18;
              *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
            }
            long long v198 = (const char *)__PAIR64__(v25, v24);
            LODWORD(v199[0]) = v21;
            sub_100A5AC14((uint64_t **)&v188, (void **)buf, (uint64_t)buf);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            sub_100A3210C(*((void *)v4 + 7), 4, buf);
            uint64_t v26 = *(void *)buf;
            uint64_t v27 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)buf)
            {
              v175[0] = 0;
              v175[1] = 0;
              CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v175;
              BOOL v28 = *(void **)(*(void *)buf + 24);
              uint64_t v29 = *(void *)buf + 32;
              if (v28 != (void *)(*(void *)buf + 32))
              {
                do
                {
                  uint64_t v30 = *(unsigned int *)(v26 + 16);
                  if (v30)
                  {
                    if (*((unsigned char *)v28 + 44)) {
                      BOOL v31 = v30 == 2;
                    }
                    else {
                      BOOL v31 = 0;
                    }
                    if (v31) {
                      uint64_t v30 = 2;
                    }
                    else {
                      uint64_t v30 = 1;
                    }
                  }
                  *(void *)std::string buf = v28[4];
                  *(void *)&uint8_t buf[8] = (v30 == 2) | (unint64_t)(v30 << 32);
                  sub_100A5AFA8((uint64_t **)&theDict, (unint64_t *)buf, buf);
                  uint64_t v32 = (void *)v28[1];
                  if (v32)
                  {
                    do
                    {
                      BOOL v33 = v32;
                      uint64_t v32 = (void *)*v32;
                    }
                    while (v32);
                  }
                  else
                  {
                    do
                    {
                      BOOL v33 = (void *)v28[2];
                      BOOL v31 = *v33 == (void)v28;
                      BOOL v28 = v33;
                    }
                    while (!v31);
                  }
                  BOOL v28 = v33;
                }
                while (v33 != (void *)v29);
              }
              if ((char)v4[55] < 0)
              {
                sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
              }
              else
              {
                *(_OWORD *)std::string buf = *v18;
                *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
              }
              sub_100A5B240((uint64_t *)&v198, (uint64_t)&theDict);
              sub_100A5B0A4(&v185, (void **)buf, (long long *)buf);
              sub_1000346F8((uint64_t)&v198, v199[0]);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              sub_1000346F8((uint64_t)&theDict, v175[0]);
            }
            CFMutableDictionaryRef theDict = 0;
            v175[0] = 0;
            sub_100A3210C(*((void *)v4 + 7), 5, &theDict);
            if (theDict)
            {
              BOOL v34 = *((_DWORD *)theDict + 4) == 2;
              if ((char)v4[55] < 0)
              {
                sub_10004FC84(buf, *((void **)v4 + 4), *((void *)v4 + 5));
              }
              else
              {
                *(_OWORD *)std::string buf = *v18;
                *(void *)&uint8_t buf[16] = *((void *)v4 + 6);
              }
              LOBYTE(v198) = v34;
              sub_10025675C((uint64_t **)&v183, (void **)buf, (uint64_t)buf);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
            if (v175[0]) {
              sub_10004D2C8((std::__shared_weak_count *)v175[0]);
            }
            if (v27) {
              sub_10004D2C8(v27);
            }
            if (v177) {
              sub_10004D2C8(v177);
            }
            LOBYTE(v5) = v173;
            if (v179) {
              sub_10004D2C8(v179);
            }
            if ((_BYTE)v182 && SHIBYTE(v181) < 0) {
              operator delete(__p[1]);
            }
          }
          if (v20) {
            sub_10004D2C8(v20);
          }
        }
      }
      uint64_t v35 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v35)
      {
        do
        {
          std::string::size_type v36 = v35;
          uint64_t v35 = *(unsigned __int8 **)v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          std::string::size_type v36 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v31 = *(void *)v36 == (void)v4;
          uint64_t v4 = v36;
        }
        while (!v31);
      }
      uint64_t v4 = v36;
    }
    while (v36 != v3);
  }
  if ((sub_100E996C4((void *)(v1 + 120), (uint64_t)&v195) & 1) == 0)
  {
    if ((uint64_t **)(v1 + 120) != &v195)
    {
      uint64_t v37 = v195;
      if (*(void *)(v1 + 136))
      {
        uint64_t v38 = *(void *)(v1 + 128);
        uint64_t v39 = *(void *)(v1 + 120);
        *(void *)(v1 + 120) = v1 + 128;
        *(void *)(v38 + 16) = 0;
        *(void *)(v1 + 128) = 0;
        *(void *)(v1 + 136) = 0;
        if (*(void *)(v39 + 8)) {
          uint64_t v40 = *(void *)(v39 + 8);
        }
        else {
          uint64_t v40 = v39;
        }
        *(void *)std::string buf = v1 + 120;
        *(void *)&uint8_t buf[8] = v40;
        *(void *)&uint8_t buf[16] = v40;
        if (v40)
        {
          *(void *)&uint8_t buf[8] = sub_1000EA590(v40);
          if (v37 == (uint64_t *)v196)
          {
            uint64_t v45 = (uint64_t *)v196;
          }
          else
          {
            do
            {
              std::string::operator=((std::string *)(v40 + 32), (const std::string *)(v37 + 4));
              int v41 = *((_DWORD *)v37 + 14);
              *(unsigned char *)(v40 + 60) = *((unsigned char *)v37 + 60);
              *(_DWORD *)(v40 + 56) = v41;
              sub_100179AF8((std::string *)(v40 + 64), (const std::string *)(v37 + 8));
              uint64_t v42 = *(uint64_t **)&buf[16];
              __p[0] = 0;
              uint64_t v43 = (uint64_t **)sub_1000EA518(v1 + 120, __p, (void *)(*(void *)&buf[16] + 32));
              sub_100046C38((uint64_t **)(v1 + 120), (uint64_t)__p[0], v43, v42);
              uint64_t v40 = *(void *)&buf[8];
              *(void *)&uint8_t buf[16] = *(void *)&buf[8];
              if (*(void *)&buf[8]) {
                *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
              }
              std::string::size_type v44 = (uint64_t *)v37[1];
              if (v44)
              {
                do
                {
                  uint64_t v45 = v44;
                  std::string::size_type v44 = (uint64_t *)*v44;
                }
                while (v44);
              }
              else
              {
                do
                {
                  uint64_t v45 = (uint64_t *)v37[2];
                  BOOL v31 = *v45 == (void)v37;
                  uint64_t v37 = v45;
                }
                while (!v31);
              }
              if (!v40) {
                break;
              }
              uint64_t v37 = v45;
            }
            while (v45 != (uint64_t *)v196);
          }
        }
        else
        {
          uint64_t v45 = v37;
        }
        sub_100E99798((uint64_t)buf);
        uint64_t v37 = v45;
      }
      if (v37 != (uint64_t *)v196)
      {
        do
        {
          *(void *)&uint8_t buf[16] = 0;
          uint64_t v46 = operator new(0x60uLL);
          BOOL v47 = v46;
          *(void *)std::string buf = v46;
          *(void *)&uint8_t buf[8] = v1 + 128;
          if (*((char *)v37 + 55) < 0)
          {
            sub_10004FC84(v46 + 32, (void *)v37[4], v37[5]);
          }
          else
          {
            long long v48 = *((_OWORD *)v37 + 2);
            *((void *)v46 + 6) = v37[6];
            *((_OWORD *)v46 + 2) = v48;
          }
          int v49 = *((_DWORD *)v37 + 14);
          v47[60] = *((unsigned char *)v37 + 60);
          *((_DWORD *)v47 + 14) = v49;
          sub_1000593FC((uint64_t)(v47 + 64), (long long *)v37 + 4);
          uint8_t buf[16] = 1;
          __p[0] = 0;
          std::string::size_type v50 = (uint64_t **)sub_1000EA518(v1 + 120, __p, (void *)(*(void *)buf + 32));
          sub_100046C38((uint64_t **)(v1 + 120), (uint64_t)__p[0], v50, *(uint64_t **)buf);
          *(void *)std::string buf = 0;
          sub_100A5AF50((uint64_t)buf, 0);
          long long v51 = (uint64_t *)v37[1];
          if (v51)
          {
            do
            {
              uint64_t v52 = v51;
              long long v51 = (uint64_t *)*v51;
            }
            while (v51);
          }
          else
          {
            do
            {
              uint64_t v52 = (uint64_t *)v37[2];
              BOOL v31 = *v52 == (void)v37;
              uint64_t v37 = v52;
            }
            while (!v31);
          }
          uint64_t v37 = v52;
        }
        while (v52 != (uint64_t *)v196);
      }
    }
    uint64_t v53 = *(void *)(v1 + 112);
    if (v53) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v53 + 48))(v53, v1 + 120);
    }
    std::string::size_type v54 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s%sUpdated VoWiFi provisioning states pushed:", buf, 0x16u);
    }
    long long v55 = v195;
    if (v195 != (uint64_t *)v196)
    {
      do
      {
        uint64_t v56 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v57 = v55[4];
          uint64_t v58 = *((unsigned __int8 *)v55 + 55);
          uint64_t v59 = v55[5];
          asString();
          if ((v58 & 0x80u) == 0) {
            uint64_t v60 = v58;
          }
          else {
            uint64_t v60 = v59;
          }
          if ((v58 & 0x80u) == 0) {
            uint64_t v61 = (const char *)(v55 + 4);
          }
          else {
            uint64_t v61 = (const char *)v57;
          }
          BOOL v31 = v60 == 0;
          *(_DWORD *)std::string buf = 136315906;
          uint64_t v62 = "<invalid>";
          if (!v31) {
            uint64_t v62 = v61;
          }
          *(void *)&uint8_t buf[4] = "";
          unsigned int v63 = __p;
          if (SBYTE7(v181) < 0) {
            unsigned int v63 = (void **)__p[0];
          }
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v198 = v62;
          LOWORD(v199[0]) = 2080;
          *(void **)((char *)v199 + 2) = v63;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s: %s", buf, 0x2Au);
          if (SBYTE7(v181) < 0) {
            operator delete(__p[0]);
          }
        }
        __int16 v64 = (uint64_t *)v55[1];
        if (v64)
        {
          do
          {
            int v65 = v64;
            __int16 v64 = (uint64_t *)*v64;
          }
          while (v64);
        }
        else
        {
          do
          {
            int v65 = (uint64_t *)v55[2];
            BOOL v31 = *v65 == (void)v55;
            long long v55 = v65;
          }
          while (!v31);
        }
        long long v55 = v65;
      }
      while (v65 != (uint64_t *)v196);
    }
  }
  if ((sub_1004F6074((void *)(v1 + 288), (uint64_t)&v191) & 1) == 0)
  {
    if ((char ***)(v1 + 288) != &v191) {
      sub_100E997F0((uint64_t *)(v1 + 288), v191, v192);
    }
    uint64_t v66 = *(void *)(v1 + 280);
    if (v66) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v66 + 48))(v66, v1 + 288);
    }
    uint64_t v67 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s%sUpdated VoLTE network support pushed:", buf, 0x16u);
    }
    uint64_t v68 = (uint64_t *)v191;
    if (v191 != v192)
    {
      do
      {
        uint64_t v69 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v70 = v68[4];
          uint64_t v71 = *((unsigned __int8 *)v68 + 55);
          uint64_t v72 = v68[5];
          CFUUIDRef v73 = (void *)asStringBool(*((unsigned char *)v68 + 56));
          *(_DWORD *)std::string buf = 136315906;
          if ((v71 & 0x80u) == 0) {
            uint64_t v74 = v71;
          }
          else {
            uint64_t v74 = v72;
          }
          *(void *)&uint8_t buf[4] = "";
          if ((v71 & 0x80u) == 0) {
            uint64_t v75 = (const char *)(v68 + 4);
          }
          else {
            uint64_t v75 = (const char *)v70;
          }
          BOOL v31 = v74 == 0;
          *(_WORD *)&unsigned char buf[12] = 2080;
          int v76 = "<invalid>";
          if (!v31) {
            int v76 = v75;
          }
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v198 = v76;
          LOWORD(v199[0]) = 2080;
          *(void **)((char *)v199 + 2) = v73;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s: %s", buf, 0x2Au);
        }
        uint64_t v77 = (char *)v68[1];
        if (v77)
        {
          do
          {
            uint64_t v78 = (char **)v77;
            uint64_t v77 = *(char **)v77;
          }
          while (v77);
        }
        else
        {
          do
          {
            uint64_t v78 = (char **)v68[2];
            BOOL v31 = *v78 == (char *)v68;
            uint64_t v68 = (uint64_t *)v78;
          }
          while (!v31);
        }
        uint64_t v68 = (uint64_t *)v78;
      }
      while (v78 != v192);
    }
  }
  if ((sub_1004F6074((void *)(v1 + 232), (uint64_t)&v193) & 1) == 0)
  {
    if ((char ***)(v1 + 232) != &v193) {
      sub_100E997F0((uint64_t *)(v1 + 232), v193, v194);
    }
    uint64_t v79 = *(void *)(v1 + 224);
    if (v79) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v79 + 48))(v79, v1 + 232);
    }
    xpc_object_t v80 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I %s%sUpdated VoLTE feature support pushed:", buf, 0x16u);
    }
    int v81 = (uint64_t *)v193;
    if (v193 != v194)
    {
      do
      {
        int v82 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v83 = v81[4];
          uint64_t v84 = *((unsigned __int8 *)v81 + 55);
          uint64_t v85 = v81[5];
          int v86 = (void *)asStringBool(*((unsigned char *)v81 + 56));
          *(_DWORD *)std::string buf = 136315906;
          if ((v84 & 0x80u) == 0) {
            uint64_t v87 = v84;
          }
          else {
            uint64_t v87 = v85;
          }
          *(void *)&uint8_t buf[4] = "";
          if ((v84 & 0x80u) == 0) {
            int v88 = (const char *)(v81 + 4);
          }
          else {
            int v88 = (const char *)v83;
          }
          BOOL v31 = v87 == 0;
          *(_WORD *)&unsigned char buf[12] = 2080;
          uint64_t v89 = "<invalid>";
          if (!v31) {
            uint64_t v89 = v88;
          }
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v198 = v89;
          LOWORD(v199[0]) = 2080;
          *(void **)((char *)v199 + 2) = v86;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s: %s", buf, 0x2Au);
        }
        BOOL v90 = (char *)v81[1];
        if (v90)
        {
          do
          {
            uint64_t v91 = (char **)v90;
            BOOL v90 = *(char **)v90;
          }
          while (v90);
        }
        else
        {
          do
          {
            uint64_t v91 = (char **)v81[2];
            BOOL v31 = *v91 == (char *)v81;
            int v81 = (uint64_t *)v91;
          }
          while (!v31);
        }
        int v81 = (uint64_t *)v91;
      }
      while (v91 != v194);
    }
  }
  if (*(void *)(v1 + 192) == v190)
  {
    CFDictionaryRef v92 = *(void ***)(v1 + 176);
    if (v92 == (void **)(v1 + 184)) {
      goto LABEL_263;
    }
    while (1)
    {
      BOOL v93 = sub_100046F68((uint64_t)&v188, v92 + 4);
      if (&v189 == (char **)v93
        || *((_DWORD *)v93 + 14) != *((_DWORD *)v92 + 14)
        || *((_DWORD *)v93 + 15) != *((_DWORD *)v92 + 15)
        || *((_DWORD *)v93 + 16) != *((_DWORD *)v92 + 16))
      {
        break;
      }
      int v94 = (void **)v92[1];
      if (v94)
      {
        do
        {
          long long v95 = v94;
          int v94 = (void **)*v94;
        }
        while (v94);
      }
      else
      {
        do
        {
          long long v95 = (void **)v92[2];
          BOOL v31 = *v95 == v92;
          CFDictionaryRef v92 = v95;
        }
        while (!v31);
      }
      CFDictionaryRef v92 = v95;
      if (v95 == (void **)(v1 + 184)) {
        goto LABEL_263;
      }
    }
  }
  if ((char ***)(v1 + 176) != &v188)
  {
    long long v96 = (uint64_t *)v188;
    if (*(void *)(v1 + 192))
    {
      uint64_t v97 = *(void *)(v1 + 184);
      uint64_t v98 = *(void *)(v1 + 176);
      *(void *)(v1 + 176) = v1 + 184;
      *(void *)(v97 + 16) = 0;
      *(void *)(v1 + 184) = 0;
      *(void *)(v1 + 192) = 0;
      if (*(void *)(v98 + 8)) {
        uint64_t v99 = *(void *)(v98 + 8);
      }
      else {
        uint64_t v99 = v98;
      }
      *(void *)std::string buf = v1 + 176;
      *(void *)&uint8_t buf[8] = v99;
      *(void *)&uint8_t buf[16] = v99;
      if (v99)
      {
        *(void *)&uint8_t buf[8] = sub_1000EA590(v99);
        if (v96 == (uint64_t *)&v189)
        {
          long long v104 = &v189;
        }
        else
        {
          do
          {
            std::string::operator=((std::string *)(v99 + 32), (const std::string *)(v96 + 4));
            uint64_t v100 = v96[7];
            *(_DWORD *)(v99 + 64) = *((_DWORD *)v96 + 16);
            *(void *)(v99 + 56) = v100;
            char v101 = *(uint64_t **)&buf[16];
            __p[0] = 0;
            int v102 = (uint64_t **)sub_1000EA518(v1 + 176, __p, (void *)(*(void *)&buf[16] + 32));
            sub_100046C38((uint64_t **)(v1 + 176), (uint64_t)__p[0], v102, v101);
            uint64_t v99 = *(void *)&buf[8];
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            if (*(void *)&buf[8]) {
              *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
            }
            long long v103 = (char *)v96[1];
            if (v103)
            {
              do
              {
                long long v104 = (char **)v103;
                long long v103 = *(char **)v103;
              }
              while (v103);
            }
            else
            {
              do
              {
                long long v104 = (char **)v96[2];
                BOOL v31 = *v104 == (char *)v96;
                long long v96 = (uint64_t *)v104;
              }
              while (!v31);
            }
            if (!v99) {
              break;
            }
            long long v96 = (uint64_t *)v104;
          }
          while (v104 != &v189);
        }
      }
      else
      {
        long long v104 = (char **)v96;
      }
      sub_1000EA5E4((uint64_t)buf);
      long long v96 = (uint64_t *)v104;
    }
    if (v96 != (uint64_t *)&v189)
    {
      do
      {
        *(void *)&uint8_t buf[16] = 0;
        long long v105 = (char *)operator new(0x48uLL);
        uint64_t v106 = v105;
        *(void *)&uint8_t buf[8] = v1 + 184;
        unsigned int v107 = v105 + 32;
        if (*((char *)v96 + 55) < 0)
        {
          sub_10004FC84(v105 + 32, (void *)v96[4], v96[5]);
        }
        else
        {
          long long v108 = *((_OWORD *)v96 + 2);
          *((void *)v105 + 6) = v96[6];
          *(_OWORD *)unsigned int v107 = v108;
        }
        uint64_t v109 = v96[7];
        *((_DWORD *)v106 + 16) = *((_DWORD *)v96 + 16);
        *((void *)v106 + 7) = v109;
        __p[0] = 0;
        uint64_t v110 = (uint64_t **)sub_1000EA518(v1 + 176, __p, v107);
        sub_100046C38((uint64_t **)(v1 + 176), (uint64_t)__p[0], v110, (uint64_t *)v106);
        uint64_t v111 = (char *)v96[1];
        if (v111)
        {
          do
          {
            uint64_t v112 = (char **)v111;
            uint64_t v111 = *(char **)v111;
          }
          while (v111);
        }
        else
        {
          do
          {
            uint64_t v112 = (char **)v96[2];
            BOOL v31 = *v112 == (char *)v96;
            long long v96 = (uint64_t *)v112;
          }
          while (!v31);
        }
        long long v96 = (uint64_t *)v112;
      }
      while (v112 != &v189);
    }
  }
  uint64_t v113 = *(void *)(v1 + 168);
  if (v113) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v113 + 48))(v113, v1 + 176);
  }
LABEL_263:
  if (*(void *)(v1 + 360) == v187)
  {
    int v114 = *(void ***)(v1 + 344);
    if (v114 == (void **)(v1 + 352)) {
      goto LABEL_331;
    }
    while (1)
    {
      std::string::size_type v115 = sub_100046F68((uint64_t)&v185, v114 + 4);
      if (&v186 == (void **)v115 || !sub_100B0ABB4(v115 + 7, (uint64_t)(v114 + 7))) {
        break;
      }
      CFNumberRef v116 = (void **)v114[1];
      if (v116)
      {
        do
        {
          CFNumberRef v117 = v116;
          CFNumberRef v116 = (void **)*v116;
        }
        while (v116);
      }
      else
      {
        do
        {
          CFNumberRef v117 = (void **)v114[2];
          BOOL v31 = *v117 == v114;
          int v114 = v117;
        }
        while (!v31);
      }
      int v114 = v117;
      if (v117 == (void **)(v1 + 352)) {
        goto LABEL_331;
      }
    }
  }
  if ((uint64_t **)(v1 + 344) != &v185)
  {
    uint64_t v118 = v185;
    if (*(void *)(v1 + 360))
    {
      uint64_t v119 = *(void *)(v1 + 344);
      uint64_t v120 = *(void *)(v1 + 352);
      *(void *)(v1 + 344) = v1 + 352;
      *(void *)(v120 + 16) = 0;
      *(void *)(v1 + 352) = 0;
      *(void *)(v1 + 360) = 0;
      if (*(void *)(v119 + 8)) {
        uint64_t v121 = *(void *)(v119 + 8);
      }
      else {
        uint64_t v121 = v119;
      }
      *(void *)std::string buf = v1 + 344;
      *(void *)&uint8_t buf[8] = v121;
      *(void *)&uint8_t buf[16] = v121;
      if (v121)
      {
        *(void *)&uint8_t buf[8] = sub_1000EA590(v121);
        if (v118 == (uint64_t *)&v186)
        {
          uint64_t v125 = (uint64_t *)&v186;
        }
        else
        {
          do
          {
            std::string::operator=((std::string *)(v121 + 32), (const std::string *)(v118 + 4));
            if ((uint64_t *)v121 != v118) {
              sub_100B0AC80((uint64_t **)(v121 + 56), (void *)v118[7], v118 + 8);
            }
            CFIndex v122 = *(uint64_t **)&buf[16];
            __p[0] = 0;
            uint64_t v123 = (uint64_t **)sub_1000EA518(v1 + 344, __p, (void *)(*(void *)&buf[16] + 32));
            sub_100046C38((uint64_t **)(v1 + 344), (uint64_t)__p[0], v123, v122);
            uint64_t v121 = *(void *)&buf[8];
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            if (*(void *)&buf[8]) {
              *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
            }
            CFDictionaryRef v124 = (uint64_t *)v118[1];
            if (v124)
            {
              do
              {
                uint64_t v125 = v124;
                CFDictionaryRef v124 = (uint64_t *)*v124;
              }
              while (v124);
            }
            else
            {
              do
              {
                uint64_t v125 = (uint64_t *)v118[2];
                BOOL v31 = *v125 == (void)v118;
                uint64_t v118 = v125;
              }
              while (!v31);
            }
            if (!v121) {
              break;
            }
            uint64_t v118 = v125;
          }
          while (v125 != (uint64_t *)&v186);
        }
      }
      else
      {
        uint64_t v125 = v118;
      }
      sub_100429774((uint64_t)buf);
      uint64_t v118 = v125;
    }
    if (v118 != (uint64_t *)&v186)
    {
      do
      {
        *(void *)&uint8_t buf[16] = 0;
        uint64_t v126 = (uint64_t *)operator new(0x50uLL);
        int v127 = v126;
        *(void *)std::string buf = v126;
        *(void *)&uint8_t buf[8] = v1 + 352;
        if (*((char *)v118 + 55) < 0)
        {
          sub_10004FC84((unsigned char *)v126 + 32, (void *)v118[4], v118[5]);
        }
        else
        {
          long long v128 = *((_OWORD *)v118 + 2);
          v126[6] = v118[6];
          *((_OWORD *)v126 + 2) = v128;
        }
        sub_100A5B240(v127 + 7, (uint64_t)(v118 + 7));
        uint8_t buf[16] = 1;
        __p[0] = 0;
        uint64_t v129 = (uint64_t **)sub_1000EA518(v1 + 344, __p, (void *)(*(void *)buf + 32));
        sub_100046C38((uint64_t **)(v1 + 344), (uint64_t)__p[0], v129, *(uint64_t **)buf);
        *(void *)std::string buf = 0;
        sub_10031E5B4((uint64_t)buf, 0);
        uint64_t v130 = (uint64_t *)v118[1];
        if (v130)
        {
          do
          {
            CFTypeID v131 = v130;
            uint64_t v130 = (uint64_t *)*v130;
          }
          while (v130);
        }
        else
        {
          do
          {
            CFTypeID v131 = (uint64_t *)v118[2];
            BOOL v31 = *v131 == (void)v118;
            uint64_t v118 = v131;
          }
          while (!v31);
        }
        uint64_t v118 = v131;
      }
      while (v131 != (uint64_t *)&v186);
    }
  }
  uint64_t v132 = *(void *)(v1 + 336);
  if (v132) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v132 + 48))(v132, v1 + 344);
  }
  int v133 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "#I %s%sUpdated Network Slicing support pushed:", buf, 0x16u);
  }
  CFTypeID v134 = v185;
  if (v185 != (uint64_t *)&v186)
  {
    do
    {
      uint64_t v135 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v136 = v134[4];
        uint64_t v137 = *((unsigned __int8 *)v134 + 55);
        uint64_t v138 = v134[5];
        asString(v134 + 7, __p);
        if ((v137 & 0x80u) == 0) {
          uint64_t v139 = v137;
        }
        else {
          uint64_t v139 = v138;
        }
        if ((v137 & 0x80u) == 0) {
          unsigned int v140 = (const char *)(v134 + 4);
        }
        else {
          unsigned int v140 = (const char *)v136;
        }
        BOOL v31 = v139 == 0;
        *(_DWORD *)std::string buf = 136315906;
        BOOL v141 = "<invalid>";
        if (!v31) {
          BOOL v141 = v140;
        }
        *(void *)&uint8_t buf[4] = "";
        int v142 = __p;
        if (SBYTE7(v181) < 0) {
          int v142 = (void **)__p[0];
        }
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        *(_WORD *)&unsigned char buf[22] = 2080;
        long long v198 = v141;
        LOWORD(v199[0]) = 2080;
        *(void **)((char *)v199 + 2) = v142;
        _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s: %s", buf, 0x2Au);
        if (SBYTE7(v181) < 0) {
          operator delete(__p[0]);
        }
      }
      CFStringRef v143 = (uint64_t *)v134[1];
      if (v143)
      {
        do
        {
          char v144 = v143;
          CFStringRef v143 = (uint64_t *)*v143;
        }
        while (v143);
      }
      else
      {
        do
        {
          char v144 = (uint64_t *)v134[2];
          BOOL v31 = *v144 == (void)v134;
          CFTypeID v134 = v144;
        }
        while (!v31);
      }
      CFTypeID v134 = v144;
    }
    while (v144 != (uint64_t *)&v186);
  }
LABEL_331:
  if ((sub_1004F6074((void *)(v1 + 400), (uint64_t)&v183) & 1) == 0)
  {
    if ((char ***)(v1 + 400) != &v183) {
      sub_100E997F0((uint64_t *)(v1 + 400), v183, v184);
    }
    uint64_t v145 = *(void *)(v1 + 392);
    if (v145) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v145 + 48))(v145, v1 + 400);
    }
    uint64_t v146 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I %s%sUpdated satellite support pushed:", buf, 0x16u);
    }
    CFArrayRef v147 = (uint64_t *)v183;
    if (v183 != v184)
    {
      do
      {
        uint64_t v148 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v149 = v147[4];
          uint64_t v150 = *((unsigned __int8 *)v147 + 55);
          uint64_t v151 = v147[5];
          uint64_t v152 = (void *)asStringBool(*((unsigned char *)v147 + 56));
          *(_DWORD *)std::string buf = 136315906;
          if ((v150 & 0x80u) == 0) {
            uint64_t v153 = v150;
          }
          else {
            uint64_t v153 = v151;
          }
          *(void *)&uint8_t buf[4] = "";
          if ((v150 & 0x80u) == 0) {
            dispatch_group_t v154 = (const char *)(v147 + 4);
          }
          else {
            dispatch_group_t v154 = (const char *)v149;
          }
          BOOL v31 = v153 == 0;
          *(_WORD *)&unsigned char buf[12] = 2080;
          char v155 = "<invalid>";
          if (!v31) {
            char v155 = v154;
          }
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v198 = v155;
          LOWORD(v199[0]) = 2080;
          *(void **)((char *)v199 + 2) = v152;
          _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s: %s", buf, 0x2Au);
        }
        uint64_t v156 = (char *)v147[1];
        if (v156)
        {
          do
          {
            BOOL v157 = (char **)v156;
            uint64_t v156 = *(char **)v156;
          }
          while (v156);
        }
        else
        {
          do
          {
            BOOL v157 = (char **)v147[2];
            BOOL v31 = *v157 == (char *)v147;
            CFArrayRef v147 = (uint64_t *)v157;
          }
          while (!v31);
        }
        CFArrayRef v147 = (uint64_t *)v157;
      }
      while (v157 != v184);
    }
  }
  uint64_t v158 = *(void *)(v1 + 888);
  if (v158)
  {
    CFTypeRef cf2 = 0;
    sub_100058198(&cf2, (const void **)(v158 + 200));
    std::mutex::lock((std::mutex *)(v1 + 904));
    dispatch_object_t v159 = *(const void **)(v1 + 968);
    if (v159) {
      CFTypeID v160 = sub_100080778;
    }
    else {
      CFTypeID v160 = 0;
    }
    if (v160 && (cf2 ? (char v161 = sub_100080778) : (char v161 = 0), v161 && CFEqual(v159, cf2)))
    {
      int v162 = 1;
    }
    else
    {
      sub_100058140((const void **)(v1 + 968), &cf2);
      int v162 = 0;
    }
    std::mutex::unlock((std::mutex *)(v1 + 904));
    if (((v162 | capabilities::ct::supportsThumperService(v163) ^ 1) & 1) == 0)
    {
      CFTypeRef v164 = cf2;
      __p[0] = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v166 = __p[0];
        __p[0] = Mutable;
        *(void *)std::string buf = v166;
        sub_10005717C((const void **)buf);
      }
      CFDictionarySetValue((CFMutableDictionaryRef)__p[0], kCTCapabilityCanSet, kCFBooleanFalse);
      CFDictionarySetValue((CFMutableDictionaryRef)__p[0], kCTCapabilityStatus, kCFBooleanFalse);
      if (v164) {
        CFDictionaryAddValue((CFMutableDictionaryRef)__p[0], kPSAccountDetails, v164);
      }
      CFMutableDictionaryRef theDict = 0;
      v167 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v167)
      {
        CFMutableDictionaryRef v168 = theDict;
        CFMutableDictionaryRef theDict = v167;
        *(void *)std::string buf = v168;
        sub_10005717C((const void **)buf);
      }
      CFDictionarySetValue(theDict, kCTCapabilityPhoneServices, __p[0]);
      int v169 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "#I %s%sfiring notification:", buf, 0x16u);
      }
      *(void *)std::string buf = off_101A66938;
      *(void *)&uint8_t buf[8] = v1;
      long long v198 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      ctu::cf_to_xpc((uint64_t *)buf, theDict, v170);
      int v171 = xpc_null_create();
      int v178 = v171;
      sub_1000452AC(82, (xpc_object_t *)buf, (xpc_object_t *)&v178);
      xpc_release(v171);
      xpc_release(*(xpc_object_t *)buf);
      sub_10005717C((const void **)&theDict);
      sub_10005717C((const void **)__p);
      if (v164)
      {
        __p[0] = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v164);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)__p[0], kPSDeviceList);
        BOOL v172 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "#I %s%supdating delegates:", buf, 0x16u);
        }
        *(void *)std::string buf = off_101A669B8;
        *(void *)&uint8_t buf[8] = v1;
        long long v198 = buf;
        logger::CFTypeRefLogger();
        sub_10012C330(buf);
        (*(void (**)(void, void *))(**(void **)(v1 + 984) + 24))(*(void *)(v1 + 984), __p[0]);
        sub_10005717C((const void **)__p);
      }
    }
    sub_100057D78(&cf2);
  }
  sub_10005CD2C((uint64_t)&v183, v184[0]);
  sub_100313534((uint64_t)&v185, v186);
  sub_10005CD2C((uint64_t)&v188, v189);
  sub_10005CD2C((uint64_t)&v191, v192[0]);
  sub_10005CD2C((uint64_t)&v193, v194[0]);
  sub_1007035FC((uint64_t)&v195, v196[0]);
  operator delete();
}

void sub_100E9936C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,const void *a32,uint64_t a33,uint64_t a34,uint64_t a35,const void *a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,char a45,char *a46,uint64_t a47,char a48,void *a49,uint64_t a50,char a51,char *a52)
{
  sub_10012C330((void *)(v52 - 176));
  sub_10005717C(&a36);
  sub_100057D78(&a32);
  sub_10005CD2C((uint64_t)&a45, a46);
  sub_100313534((uint64_t)&a48, a49);
  sub_10005CD2C((uint64_t)&a51, a52);
  sub_10005CD2C(v52 - 248, *(char **)(v52 - 240));
  sub_10005CD2C(v52 - 224, *(char **)(v52 - 216));
  sub_1007035FC(v52 - 200, *(void **)(v52 - 192));
  operator delete();
}

uint64_t sub_100E996C4(void *a1, uint64_t a2)
{
  if (a1[2] == *(void *)(a2 + 16))
  {
    uint64_t v2 = a1 + 1;
    uint64_t v3 = (void *)*a1;
    if ((void *)*a1 == a1 + 1) {
      return 1;
    }
    int v5 = (void **)(a2 + 8);
    while (1)
    {
      uint64_t v6 = sub_100046F68(a2, (void **)v3 + 4);
      if (v5 == v6
        || *((_DWORD *)v6 + 14) != *((_DWORD *)v3 + 14)
        || *((unsigned __int8 *)v6 + 60) != *((unsigned __int8 *)v3 + 60))
      {
        break;
      }
      uint64_t result = sub_1005A0BB8((unsigned __int8 *)v6 + 64, (unsigned __int8 *)v3 + 64);
      if (!result) {
        return result;
      }
      uint64_t v8 = (void *)v3[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v3[2];
          BOOL v10 = *v9 == (void)v3;
          uint64_t v3 = v9;
        }
        while (!v10);
      }
      uint64_t v3 = v9;
      if (v9 == v2) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_100E99798(uint64_t a1)
{
  sub_1007035FC(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1007035FC(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *sub_100E997F0(uint64_t *result, void *a2, void *a3)
{
  int v5 = (uint64_t **)result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *uint64_t result = (uint64_t)(result + 1);
    *(void *)(v7 + 16) = 0;
    result[1] = 0;
    result[2] = 0;
    if (*(void *)(v6 + 8)) {
      uint64_t v8 = *(void **)(v6 + 8);
    }
    else {
      uint64_t v8 = (void *)v6;
    }
    __int16 v18 = result;
    uint64_t v19 = v8;
    uint64_t v20 = v8;
    if (v8)
    {
      uint64_t v19 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          std::string::operator=((std::string *)(v8 + 4), (const std::string *)(v9 + 4));
          *((unsigned char *)v8 + 56) = *((unsigned char *)v9 + 56);
          BOOL v10 = v20;
          uint64_t v17 = 0;
          BOOL v11 = (uint64_t **)sub_1000EA518((uint64_t)v5, &v17, v20 + 4);
          sub_100046C38(v5, v17, v11, v10);
          uint64_t v8 = v19;
          uint64_t v20 = v19;
          if (v19) {
            uint64_t v19 = sub_1000EA590((uint64_t)v19);
          }
          int v12 = (void *)v9[1];
          if (v12)
          {
            do
            {
              a2 = v12;
              int v12 = (void *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v13 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v13);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    uint64_t result = (uint64_t *)sub_1000EA5E4((uint64_t)&v18);
  }
  if (a2 != a3)
  {
    do
    {
      __int16 v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      sub_100CE72A4((uint64_t)v5, (uint64_t)(a2 + 4), &v18);
      uint64_t v17 = 0;
      uint64_t v14 = (uint64_t **)sub_1000EA518((uint64_t)v5, &v17, v18 + 4);
      uint64_t result = sub_100046C38(v5, v17, v14, v18);
      uint64_t v15 = (void *)a2[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)a2[2];
          BOOL v13 = *v16 == (void)a2;
          a2 = v16;
        }
        while (!v13);
      }
      a2 = v16;
    }
    while (v16 != a3);
  }
  return result;
}

void sub_100E999A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EA5E4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100E999B4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v1 + 56));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    int v12 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      __int16 v24 = 2080;
      unsigned int v25 = "";
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "#E %s%srecalculateWiFiLocationRequirement: No CountryDeterminationInterface. Skipping...", buf, 0x16u);
    }
    goto LABEL_24;
  }
LABEL_11:
  BOOL v13 = *(void **)(v1 + 776);
  if (v13 == (void *)(v1 + 784))
  {
    char v15 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    char v15 = 0;
    do
    {
      unsigned int v16 = (*(uint64_t (**)(void))(*(void *)v13[7] + 480))(v13[7]);
      uint64_t v17 = (void *)v13[1];
      if (v17)
      {
        do
        {
          __int16 v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          __int16 v18 = (void *)v13[2];
          BOOL v19 = *v18 == (void)v13;
          BOOL v13 = v18;
        }
        while (!v19);
      }
      v15 |= v16;
      v14 += v16;
      BOOL v13 = v18;
    }
    while (v18 != (void *)(v1 + 784));
  }
  uint64_t v20 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = asStringBool(v15 & 1);
    uint64_t v22 = *(void *)(v1 + 792);
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = "";
    __int16 v24 = 2080;
    unsigned int v25 = "";
    __int16 v26 = 2080;
    uint64_t v27 = v21;
    __int16 v28 = 2048;
    uint64_t v29 = v14;
    __int16 v30 = 2048;
    uint64_t v31 = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%srecalculateWiFiLocationRequirement: WiFiLocation required: %s (required by %zu / %zu controllers)", buf, 0x34u);
  }
  (*(void (**)(uint64_t, void))(*(void *)v10 + 80))(v10, v15 & 1);
LABEL_24:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  operator delete();
}

void sub_100E99C9C()
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_100E99CF8()
{
}

void *sub_100E99D0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A66938;
  result[1] = v3;
  return result;
}

uint64_t sub_100E99D54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66938;
  a2[1] = v2;
  return result;
}

void sub_100E99D80(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100E99E4C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E99E8C()
{
}

void sub_100E99E9C()
{
}

void *sub_100E99EB0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A669B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100E99EF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A669B8;
  a2[1] = v2;
  return result;
}

void sub_100E99F24(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100E99FF0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E9A030()
{
}

uint64_t sub_100E9A03C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100E9A0BC(void **a1)
{
  char v1 = *a1;
  uint64_t v4 = a1;
  int v5 = v1;
  uint64_t v2 = *v1;
  uint64_t v6 = 0;
  __int16 v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 48))(&v6);
  sub_100E9A1C8(v1[4], v6);
  sub_100057D78(&v7);
  sub_100E9A178((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100E9A148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  char v11 = v10;
  sub_100057D78(v11);
  sub_100E9A178(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100E9A178(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1002BD56C((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100E9A1C8(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_100E9A218(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  int v5 = v1;
  uint64_t v2 = *v1;
  uint64_t v6 = 0;
  __int16 v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 56))(&v6);
  sub_100E9A1C8(v1[4], v6);
  sub_100057D78(&v7);
  sub_100E9A178((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100E9A2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  char v11 = v10;
  sub_100057D78(v11);
  sub_100E9A178(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100E9A338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100E9AA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,uint64_t a22,void *a23,void *a24,void *a25,void *a26)
{
  sub_100127DDC((const void **)(v31 - 128));
  sub_100044D00((const void **)(v31 - 120));

  _Unwind_Resume(a1);
}

void sub_100E9ACC0(_Unwind_Exception *a1)
{
  uint64_t v8 = v7;

  _Unwind_Resume(a1);
}

void sub_100E9AD14(uint64_t a1@<X0>, void *a2@<X8>)
{
  std::string __p = 0;
  long long v26 = 0uLL;
  LODWORD(v22[0]) = 0;
  sub_10016AA28((std::random_device *)v22);
  bzero(&v27, 0x9C0uLL);
  std::random_device::result_type v4 = std::random_device::operator()((std::random_device *)v22);
  LODWORD(v27) = v4;
  for (uint64_t i = 1; i != 624; ++i)
  {
    std::random_device::result_type v4 = i + 1812433253 * (v4 ^ (v4 >> 30));
    *((_DWORD *)&v28[-1] + i) = v4;
  }
  uint64_t v42 = 0;
  v43[0] = (void *)0x630000000ALL;
  int v6 = sub_10016AA9C((uint64_t)v43, (uint64_t)&v27, v43);
  std::to_string(&v45, v6);
  __int16 v7 = std::string::insert(&v45, 0, "boundary", 8uLL);
  uint64_t v8 = (void *)v7->__r_.__value_.__r.__words[0];
  *(void *)uint64_t v46 = v7->__r_.__value_.__l.__size_;
  *(void *)&v46[7] = *(std::string::size_type *)((char *)&v7->__r_.__value_.__r.__words[1] + 7);
  char v9 = HIBYTE(v7->__r_.__value_.__r.__words[2]);
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  std::random_device::~random_device((std::random_device *)v22);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
  std::string __p = v8;
  *(void *)&long long v26 = *(void *)v46;
  *(void *)((char *)&v26 + 7) = *(void *)&v46[7];
  HIBYTE(v26) = v9;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  *(_OWORD *)uint64_t v29 = 0u;
  long long v30 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v27 = 0u;
  sub_10004BD84((uint64_t)&v27);
  v24[0] = (uint64_t)&v27;
  v24[1] = (uint64_t)&__p;
  sub_100E9B260(v24, a1);
  sub_10004B96C(v28, (uint64_t)"\r\n", 2);
  sub_100E9B260(v24, a1 + 104);
  uint64_t v10 = (std::string *)sub_100058DB0(v46, "--");
  if (v26 >= 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if (v26 >= 0) {
    std::string::size_type v12 = HIBYTE(v26);
  }
  else {
    std::string::size_type v12 = v26;
  }
  BOOL v13 = std::string::append(v10, p_p, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  sub_100058DB0(v43, "--");
  if ((v44 & 0x80u) == 0) {
    char v15 = (const std::string::value_type *)v43;
  }
  else {
    char v15 = (const std::string::value_type *)v43[0];
  }
  if ((v44 & 0x80u) == 0) {
    std::string::size_type v16 = v44;
  }
  else {
    std::string::size_type v16 = (std::string::size_type)v43[1];
  }
  uint64_t v17 = std::string::append(&v45, v15, v16);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  int64_t v23 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v22 = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if ((char)v44 < 0) {
    operator delete(v43[0]);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (v47 < 0) {
    operator delete(*(void **)v46);
  }
  if (v23 >= 0) {
    BOOL v19 = v22;
  }
  else {
    BOOL v19 = (void **)v22[0];
  }
  if (v23 >= 0) {
    uint64_t v20 = HIBYTE(v23);
  }
  else {
    uint64_t v20 = (uint64_t)v22[1];
  }
  sub_10004B96C(v28, (uint64_t)v19, v20);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
  sub_10004BC98((uint64_t)v28 + 8, &v45);
  sub_100CC8650(a2, (uint64_t)&v45);
  std::operator+<char>();
  sub_100CC8934(a2 + 5, (uint64_t)v46);
  if (v47 < 0) {
    operator delete(*(void **)v46);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  *(void *)((char *)&v28[-1]
  *(void *)&v28[0] = v21;
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
}

void sub_100E9B154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (*(char *)(v24 - 57) < 0) {
    operator delete(*(void **)(v24 - 80));
  }
  if (*(char *)(v23 + 23) < 0) {
    operator delete(*(void **)v23);
  }
  if (*(char *)(v24 - 89) < 0) {
    operator delete(*(void **)(v24 - 112));
  }
  sub_10008248C((uint64_t)&a23);
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100E9B260(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  sub_100058DB0(&v15, "--");
  int v6 = *(char *)(v5 + 23);
  if (v6 >= 0) {
    __int16 v7 = (const std::string::value_type *)v5;
  }
  else {
    __int16 v7 = *(const std::string::value_type **)v5;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(v5 + 8);
  }
  char v9 = std::string::append(&v15, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  std::string::size_type v14 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  sub_1010E716C(v4, (uint64_t)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_1000BE9C4(*a1, "Content-Type", (const std::string *)(a2 + 40));
  uint64_t v11 = *a1;
  sub_1010E72C4((void *)(a2 + 80), (uint64_t)&v15);
  sub_1010E716C(v11, (uint64_t)&v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  return sub_1010E716C(*a1, a2);
}

void sub_100E9B358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E9B38C(void *a1)
{
  *a1 = off_101A66BC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
    char v3 = (std::__shared_weak_count *)a1[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  return a1;
}

uint64_t sub_100E9B3E8()
{
  return 0;
}

uint64_t sub_100E9B3F0(uint64_t result)
{
  uint64_t v1 = *(unsigned char **)(result + 8);
  if (v1[25] && !v1[26] && !v1[27]) {
    operator new();
  }
  return result;
}

void sub_100E9B6AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E9B6E8()
{
  return 1;
}

void sub_100E9B6F0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (v3 > 4) {
      uint64_t v4 = "???";
    }
    else {
      uint64_t v4 = off_101A66CE8[v3];
    }
    int v5 = 136315138;
    int v6 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Encountered failure in state:  %s", (uint8_t *)&v5, 0xCu);
  }
  sub_100E9C6F8();
}

void sub_100E9B814(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  if (a2)
  {
    std::string::size_type v12 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)std::string v15 = "[Mode:kDisablingGPS]";
      *(_WORD *)&unsigned char v15[8] = 2048;
      *(void *)&v15[10] = 60;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%s Failed to disable GPS within %lld seconds", buf, 0x16u);
      uint64_t v3 = a1[1];
    }
    sub_100E9B6F0(v3);
  }
  if (!*(unsigned char *)(v3 + 25))
  {
    uint64_t v11 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)std::string v15 = "[Mode:kDisablingGPS]";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s Stewie is no longer required", buf, 0xCu);
    }
    sub_100E9BB0C();
  }
  if (!*(void *)(v3 + 32))
  {
    uint64_t v4 = operator new(0x20uLL);
    v4[1] = 0;
    void v4[2] = 0;
    *uint64_t v4 = off_1019B3378;
    *((unsigned char *)v4 + 24) = 0;
    int v5 = (char *)(v4 + 3);
    int v6 = (std::__shared_weak_count *)a1[5];
    a1[4] = v4 + 3;
    a1[5] = v4;
    if (!v6 || (sub_10004D2C8(v6), v5 = (char *)a1[4], (uint64_t v4 = (void *)a1[5]) != 0)) {
      atomic_fetch_add_explicit(v4 + 2, 1uLL, memory_order_relaxed);
    }
    __int16 v7 = (id *)(***(uint64_t (****)(void))(a1[1] + 16))(*(void *)(a1[1] + 16));
    std::string::size_type v8 = operator new(0x20uLL);
    void *v8 = off_101A66BF8;
    v8[1] = a1;
    void v8[2] = v5;
    v8[3] = v4;
    std::string::size_type v16 = v8;
    sub_1005825D4(v7, (uint64_t)buf, &v13);
    uint64_t v9 = a1[1];
    long long v10 = *(std::__shared_weak_count **)(v9 + 40);
    *(_OWORD *)(v9 + 32) = v13;
    if (v10) {
      sub_10004D2C8(v10);
    }
    sub_100060644(buf);
    (***(void (****)(void))(a1[1] + 16))(*(void *)(a1[1] + 16));
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1[1] + 16) + 8))(buf);
    sub_100E9BB70((uint64_t)a1);
    if (*(void *)&v15[4]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v15[4]);
    }
  }
}

void sub_100E9BAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E9BB0C()
{
}

void sub_100E9BB70(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    sub_100058DB0(&__p, "ReEvaluationTimer");
    v7[0] = off_101A66C78;
    v7[1] = a1;
    v7[3] = v7;
    AutoStartTimer::create();
    long long v2 = v6;
    long long v6 = 0uLL;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
    *(_OWORD *)(a1 + 16) = v2;
    if (v3)
    {
      sub_10004D2C8(v3);
      if (*((void *)&v6 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
      }
    }
    sub_10003B34C(v7);
    if (v5 < 0) {
      operator delete(__p);
    }
  }
}

void sub_100E9BC6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E9BC98()
{
  return 2;
}

void sub_100E9BCA0(capabilities::ct *a1, int a2)
{
  uint64_t v3 = *((void *)a1 + 1);
  if (a2)
  {
    __int16 v7 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v9 = "[Mode:kEntering]";
      __int16 v10 = 2048;
      uint64_t v11 = 60;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%s Failed to Enter Stewie mode within %lld seconds", buf, 0x16u);
      uint64_t v3 = *((void *)a1 + 1);
    }
    sub_100E9B6F0(v3);
  }
  if (!*(unsigned char *)(v3 + 25))
  {
    long long v6 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v9 = "[Mode:kEntering]";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s Stewie is no longer required", buf, 0xCu);
    }
    sub_100E9BB0C();
  }
  if (*(unsigned char *)(v3 + 24) && *(unsigned char *)(v3 + 29) && *(unsigned char *)(v3 + 28)) {
    operator new();
  }
  int v4 = capabilities::ct::requiresSeparateOperatingModeForStewie(a1);
  uint64_t v5 = *((void *)a1 + 1);
  if (!v4 || !*(unsigned char *)(v5 + 24))
  {
    sub_10078D45C(v5);
  }
}

void sub_100E9C08C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E9C0D0()
{
  return 3;
}

uint64_t sub_100E9C0D8(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 8);
  if (!*(unsigned char *)(v2 + 24))
  {
    uint64_t v3 = *(NSObject **)(v2 + 8);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    int v5 = 136315138;
    long long v6 = "[Mode:kActive]";
    int v4 = "%s Operating mode is no longer Stewie";
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, v4, (uint8_t *)&v5, 0xCu);
    uint64_t v2 = *(void *)(v1 + 8);
LABEL_11:
    sub_100E9B6F0(v2);
  }
  if (!*(unsigned char *)(v2 + 29) || !*(unsigned char *)(v2 + 28))
  {
    uint64_t v3 = *(NSObject **)(v2 + 8);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    int v5 = 136315138;
    long long v6 = "[Mode:kActive]";
    int v4 = "%s Stewie assertion was revoked";
    goto LABEL_14;
  }
  if (!*(unsigned char *)(v2 + 25))
  {
    sub_100E9BB0C();
  }
  return result;
}

uint64_t sub_100E9C238()
{
  return 4;
}

uint64_t sub_100E9C240(uint64_t a1)
{
  sub_10078D6D0(*(void *)(a1 + 8));
  uint64_t v2 = *(capabilities::ct **)(a1 + 8);
  if (!*((unsigned char *)v2 + 24))
  {
LABEL_4:
    sub_10078D7D8((uint64_t)v2);
    operator new();
  }
  uint64_t result = capabilities::ct::requiresSeparateOperatingModeForStewie(v2);
  if ((result & 1) == 0)
  {
    uint64_t v2 = *(capabilities::ct **)(a1 + 8);
    goto LABEL_4;
  }
  return result;
}

void sub_100E9C4F8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100E9C538(void *a1)
{
  sub_100E9B38C(a1);

  operator delete();
}

void *sub_100E9C570(void *a1)
{
  *a1 = off_101A66A68;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100E9B38C(a1);
}

void sub_100E9C5CC(void *a1)
{
  *a1 = off_101A66A68;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100E9B38C(a1);

  operator delete();
}

void sub_100E9C640(void *a1)
{
  sub_100E9B38C(a1);

  operator delete();
}

void sub_100E9C67C(void *a1)
{
  sub_100E9B38C(a1);

  operator delete();
}

void sub_100E9C6B8(void *a1)
{
  sub_100E9B38C(a1);

  operator delete();
}

void sub_100E9C6F8()
{
}

void sub_100E9C920(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *sub_100E9C95C(void *a1)
{
  *a1 = off_101A66BF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100E9C9A8(void *a1)
{
  *a1 = off_101A66BF8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100E9CA14(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A66BF8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100E9CA78(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A66BF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100E9CAB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100E9CAC8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100E9CB08(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    long long v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[2])
      {
        uint64_t v7 = *(void *)(v5 + 8);
        std::string::size_type v8 = *(NSObject **)(v7 + 8);
        if (v4)
        {
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = 136315138;
            __int16 v10 = "[Mode:kDisablingGPS]";
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s Successfully disabled GPS", (uint8_t *)&v9, 0xCu);
          }
          operator new();
        }
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          int v9 = 136315138;
          __int16 v10 = "[Mode:kDisablingGPS]";
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%s Failed to disable GPS - assertion rejected", (uint8_t *)&v9, 0xCu);
          uint64_t v7 = *(void *)(v5 + 8);
        }
        sub_100E9B6F0(v7);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100E9CF44(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E9CFCC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100E9D00C()
{
}

void sub_100E9D01C()
{
}

void *sub_100E9D030(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A66C78;
  result[1] = v3;
  return result;
}

uint64_t sub_100E9D078(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A66C78;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E9D0A4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)v1[3];
  v1[2] = 0;
  v1[3] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v1 + 24);

  return v3(v1, 1);
}

uint64_t sub_100E9D10C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100E9D14C()
{
}

uint64_t sms::Controller::handleWea(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v10 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  v159[0] = 0;
  v159[1] = 0;
  uint64_t v160 = 0;
  sub_100E9E884((uint64_t *)v159, a3);
  uint64_t v156 = 0;
  uint64_t v157 = 0;
  uint64_t v158 = 0;
  sub_100E9E884((uint64_t *)&v156, a4);
  uint64_t v11 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = sms::asString();
    long long v13 = v159;
    if (v160 < 0) {
      long long v13 = (void **)v159[0];
    }
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I WEA format: [%{public}s] pdu: [%{public}s]", buf, 0x16u);
  }
  uint64_t v14 = HIBYTE(v158);
  int v15 = SHIBYTE(v158);
  if (v158 < 0) {
    uint64_t v14 = v157;
  }
  if (v14)
  {
    std::string::size_type v16 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = v156;
      if (v15 >= 0) {
        uint64_t v17 = &v156;
      }
      *(_DWORD *)std::string buf = 136642819;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I WAC pdu: [%{sensitive}s]", buf, 0xCu);
    }
  }
  if (a5 == 3) {
    int v18 = 4;
  }
  else {
    int v18 = a5;
  }
  if (v18 == 2)
  {
    __p[0] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)4, *(Registry **)(a1 + 80));
    uint64_t v20 = ServiceMap;
    if (v21 < 0)
    {
      uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v21;
    unsigned int v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
    if (v25)
    {
      uint64_t v27 = v25[3];
      long long v26 = (std::__shared_weak_count *)v25[4];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        char v28 = 0;
LABEL_56:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v27 + 80))(__p, v27, a2, 1, @"SMSSettings", 0, 0);
        if ((v28 & 1) == 0) {
          sub_10004D2C8(v26);
        }
        uint64_t v53 = (std::__shared_weak_count *)operator new(0x438uLL);
        v53->__shared_owners_ = 0;
        v53->__shared_weak_owners_ = 0;
        v53->__vftable = (std::__shared_weak_count_vtbl *)off_101A66D20;
        C2KSmsPduDecoder::C2KSmsPduDecoder((C2KSmsPduDecoder *)&v53[1]);
        sub_10004EFE4(&v155, (CFTypeRef *)__p);
        C2KSmsPduDecoder::setSmsSettings();
        sub_100057D78(&v155);
        char v54 = C2KSmsPduDecoder::decodeDeliver((C2KSmsPduDecoder *)&v53[1], *(const unsigned __int8 **)a3, *(void *)(a3 + 8) - *(void *)a3);
        long long v55 = *v10;
        if (v54)
        {
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Processing as non-geofenced alert...", buf, 2u);
          }
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          operator new();
        }
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "WEA Parsing failed...", buf, 2u);
        }
        (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
        uint64_t v52 = 2;
        sub_10004D2C8(v53);
        sub_1000577C4((const void **)__p);
        goto LABEL_170;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    std::mutex::unlock(v20);
    long long v26 = 0;
    char v28 = 1;
    goto LABEL_56;
  }
  if ((v18 & 0xFFFFFFFE) == 4)
  {
    uint64_t v30 = *(void *)(a1 + 80);
    uint64_t v29 = *(std::__shared_weak_count **)(a1 + 88);
    long long v31 = operator new(0xC8uLL);
    long long v32 = v31;
    v31[1] = 0;
    long long v33 = v31 + 1;
    _OWORD v31[2] = 0;
    void *v31 = off_101A66D70;
    uint64_t v34 = (uint64_t)(v31 + 3);
    *(void *)std::string buf = v30;
    *(void *)&uint8_t buf[8] = v29;
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1010DA71C((uint64_t)(v31 + 3), a2, buf);
    if (v29) {
      sub_10004D2C8(v29);
    }
    if (v160 >= 0) {
      long long v35 = (char *)v159;
    }
    else {
      long long v35 = (char *)v159[0];
    }
    if (v158 >= 0) {
      long long v36 = (char *)&v156;
    }
    else {
      long long v36 = (char *)v156;
    }
    if ((sub_1010DA8AC(v34, v35, v36, v18) & 1) == 0)
    {
      uint64_t v56 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v52 = 2;
        _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "WEA Parsing failed...", buf, 2u);
      }
      else
      {
        uint64_t v52 = 2;
      }
LABEL_169:
      sub_10004D2C8((std::__shared_weak_count *)v32);
      goto LABEL_170;
    }
    uint64_t v38 = *(void *)(a1 + 272);
    if (v38)
    {
      uint64_t v37 = a1 + 272;
      do
      {
        int v39 = *(_DWORD *)(v38 + 28);
        BOOL v40 = v39 < (int)a2;
        if (v39 >= (int)a2) {
          uint64_t v41 = (uint64_t *)v38;
        }
        else {
          uint64_t v41 = (uint64_t *)(v38 + 8);
        }
        if (!v40) {
          uint64_t v37 = v38;
        }
        uint64_t v38 = *v41;
      }
      while (*v41);
      if (v37 != a1 + 272 && *(_DWORD *)(v37 + 28) <= (int)a2)
      {
        uint64_t v37 = *(unsigned int *)(v37 + 32);
        *((_DWORD *)v32 + 9) = v37;
      }
    }
    uint64_t v42 = (std::mutex *)Registry::getServiceMap((uint64_t *)v37, *(Registry **)(a1 + 80));
    uint64_t v43 = v42;
    if (v44 < 0)
    {
      std::string v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v46 = 5381;
      do
      {
        uint64_t v44 = v46;
        unsigned int v47 = *v45++;
        uint64_t v46 = (33 * v46) ^ v47;
      }
      while (v47);
    }
    std::mutex::lock(v42);
    *(void *)std::string buf = v44;
    long long v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)buf);
    if (v48)
    {
      int v49 = (std::__shared_weak_count *)v48[4];
      uint64_t v142 = v48[3];
      if (v49)
      {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v43);
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v49);
        char v50 = 0;
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v142 = 0;
    }
    std::mutex::unlock(v43);
    int v49 = 0;
    char v50 = 1;
LABEL_69:
    uint64_t v58 = v32[23];
    uint64_t v57 = (std::__shared_weak_count *)v32[24];
    if (v57)
    {
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v57);
    }
    if (v58)
    {
      uint64_t v59 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I WHAM detected...", buf, 2u);
      }
      if (v142)
      {
        uint64_t v153 = v34;
        dispatch_group_t v154 = (std::__shared_weak_count *)v32;
        atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v142 + 48))(v142, &v153);
        if (v154) {
          sub_10004D2C8(v154);
        }
        uint64_t v52 = 9;
      }
      else
      {
        uint64_t v69 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Failed to get WeaGeofenceManager...", buf, 2u);
        }
        uint64_t v52 = 0;
      }
LABEL_167:
      if ((v50 & 1) == 0) {
        sub_10004D2C8(v49);
      }
      goto LABEL_169;
    }
    BOOL v141 = v49;
    char v140 = v50;
    uint64_t v60 = (std::mutex *)Registry::getServiceMap((uint64_t *)atomic_fetch_add_explicit(v33, 1uLL, memory_order_relaxed), *(Registry **)(a1 + 80));
    uint64_t v61 = v60;
    if (v62 < 0)
    {
      unsigned int v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v64 = 5381;
      do
      {
        uint64_t v62 = v64;
        unsigned int v65 = *v63++;
        uint64_t v64 = (33 * v64) ^ v65;
      }
      while (v65);
    }
    std::mutex::lock(v60);
    *(void *)std::string buf = v62;
    uint64_t v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
    if (v66)
    {
      uint64_t v68 = v66[3];
      uint64_t v67 = (std::__shared_weak_count *)v66[4];
      if (v67)
      {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v61);
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v67);
        char v139 = 0;
        goto LABEL_88;
      }
    }
    else
    {
      uint64_t v68 = 0;
    }
    std::mutex::unlock(v61);
    uint64_t v67 = 0;
    char v139 = 1;
LABEL_88:
    unsigned int v163 = *((_DWORD *)v32 + 45);
    uint64_t v70 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v71 = v70;
    if (!v68)
    {
      uint64_t v83 = *v70;
      if (os_log_type_enabled(*v70, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "Failed to get CellMonitorInterface...", buf, 2u);
      }
      int v84 = 0;
      int v49 = v141;
      goto LABEL_116;
    }
    uint64_t v138 = v67;
    uint64_t v72 = (*(uint64_t (**)(uint64_t, void))(*(void *)v68 + 80))(v68, v163);
    char v74 = v73;
    *(void *)std::string buf = &v163;
    uint64_t v75 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
    v75[57] = v72;
    *((unsigned char *)v75 + 464) = v74;
    uint64_t v76 = (*(uint64_t (**)(uint64_t, void))(*(void *)v68 + 72))(v68, v163);
    char v78 = v77;
    *(void *)std::string buf = &v163;
    uint64_t v79 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
    v79[59] = v76;
    *((unsigned char *)v79 + 480) = v78;
    xpc_object_t v80 = *v71;
    uint64_t v67 = v138;
    if (!os_log_type_enabled(*v71, OS_LOG_TYPE_DEFAULT))
    {
LABEL_103:
      *(void *)std::string buf = &v163;
      int v49 = v141;
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
           + 464))
      {
        *(void *)std::string buf = &v163;
        int v49 = v141;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 480))
        {
          uint64_t v161 = v34;
          int v162 = (std::__shared_weak_count *)v32;
          atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
          *(void *)std::string buf = &v163;
          int v88 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
          MCC::MCC((MCC *)buf, (const MCC *)(v88 + 49));
          MCC::MCC((MCC *)v173, (const MCC *)(v88 + 53));
          v175[0] = *(_OWORD *)(v88 + 57);
          *(_OWORD *)((char *)v175 + 9) = *(_OWORD *)((char *)v88 + 465);
          unsigned int v137 = sub_100144E50((uint64_t)&v161, (uint64_t)buf);
          if (v174 < 0) {
            operator delete(v173[1]);
          }
          if (v172 < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (v162) {
            sub_10004D2C8(v162);
          }
          HIDWORD(v134) = *((_DWORD *)v32 + 42);
          unsigned int v135 = *((_DWORD *)v32 + 43);
          LODWORD(v134) = *((_DWORD *)v32 + 24);
          int v89 = *((_DWORD *)v32 + 26);
          int v136 = *((_DWORD *)v32 + 25);
          BOOL v90 = *v71;
          if (os_log_type_enabled(*v71, OS_LOG_TYPE_DEFAULT))
          {
            if (*((char *)v32 + 135) < 0)
            {
              sub_10004FC84(__p, (void *)v32[14], v32[15]);
            }
            else
            {
              *(_OWORD *)std::string __p = *((_OWORD *)v32 + 7);
              *(void *)v165 = v32[16];
            }
            CFDictionaryRef v92 = __p;
            if (v165[7] < 0) {
              CFDictionaryRef v92 = (void **)__p[0];
            }
            *(_DWORD *)int v169 = 136642819;
            int v170 = v92;
            _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I WEA body (as hex str): %{sensitive}s", v169, 0xCu);
            if ((v165[7] & 0x80000000) != 0) {
              operator delete(__p[0]);
            }
            BOOL v90 = *v71;
          }
          int v93 = v89 >> 4;
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(__p[0]) = 67110400;
            HIDWORD(__p[0]) = v134;
            LOWORD(__p[1]) = 1024;
            *(_DWORD *)((char *)&__p[1] + 2) = HIDWORD(v134);
            HIWORD(__p[1]) = 1024;
            *(_DWORD *)v165 = v137;
            *(_WORD *)&v165[4] = 1024;
            *(_DWORD *)&v165[6] = v135;
            *(_WORD *)&v165[10] = 1024;
            int v166 = v89 >> 4;
            __int16 v167 = 1024;
            int v168 = v136;
            _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I New CellBroadcast Info: Channel:%d, Message Code:%d, Location:%d, Version:%d, Parts:%d DCS:%d", (uint8_t *)__p, 0x26u);
          }
          long long v95 = (std::mutex *)Registry::getServiceMap(v94, *(Registry **)(a1 + 80));
          long long v96 = v95;
          if (v97 < 0)
          {
            uint64_t v98 = (unsigned __int8 *)(v97 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v99 = 5381;
            do
            {
              uint64_t v97 = v99;
              unsigned int v100 = *v98++;
              uint64_t v99 = (33 * v99) ^ v100;
            }
            while (v100);
          }
          std::mutex::lock(v95);
          __p[0] = (void *)v97;
          char v101 = sub_10004D37C(&v96[1].__m_.__sig, (unint64_t *)__p);
          int v133 = v93;
          if (v101)
          {
            uint64_t v102 = v101[3];
            long long v103 = (std::__shared_weak_count *)v101[4];
            if (v103)
            {
              atomic_fetch_add_explicit(&v103->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v96);
              atomic_fetch_add_explicit(&v103->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v103);
              char v104 = 0;
LABEL_133:
              uint64_t v105 = (*(uint64_t (**)(uint64_t))(*(void *)v102 + 88))(v102);
              if ((v104 & 1) == 0) {
                sub_10004D2C8(v103);
              }
              uint64_t v106 = *(void *)(a1 + 2568);
              uint64_t v107 = v163;
              __p[0] = &v163;
              long long v108 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5]
                   + 70;
              __p[0] = v134;
              __p[1] = (void *)__PAIR64__(v135, v137);
              *(_DWORD *)v165 = v133;
              *(_DWORD *)&v165[4] = v105;
              *(_DWORD *)&v165[8] = v136;
              int v84 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, void **, uint64_t))(*(void *)v106 + 184))(v106, v107, v108, __p, v105) ^ 1;
              int v49 = v141;
              char v50 = v140;
              uint64_t v67 = v138;
LABEL_136:
              if ((v139 & 1) == 0) {
                sub_10004D2C8(v67);
              }
              sub_10004D2C8((std::__shared_weak_count *)v32);
              uint64_t v109 = *v10;
              BOOL v110 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
              if (v84)
              {
                if (v110)
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "#I Received WEA is a duplicate", buf, 2u);
                }
                uint64_t v52 = 3;
                goto LABEL_167;
              }
              if (v110)
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "#I WEA is not a duplicate", buf, 2u);
              }
              uint64_t v112 = v32[5];
              uint64_t v111 = (std::__shared_weak_count *)v32[6];
              if (v111)
              {
                atomic_fetch_add_explicit(&v111->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v111);
              }
              if (v112)
              {
                uint64_t v114 = v32[5];
                uint64_t v113 = (std::__shared_weak_count *)v32[6];
                if (v113)
                {
                  atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed);
                  int v115 = *(unsigned __int8 *)(v114 + 81);
                  sub_10004D2C8(v113);
                  if (v115) {
                    goto LABEL_149;
                  }
                }
                else if (*(unsigned char *)(v114 + 81))
                {
LABEL_149:
                  CFNumberRef v116 = *v10;
                  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)std::string buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "#I Processing as geofenced alert...", buf, 2u);
                  }
                  *(void *)std::string buf = 0;
                  *(void *)&uint8_t buf[8] = 0;
                  sub_1004AB97C(*(Registry **)(a1 + 80), buf);
                  if (!*(void *)buf)
                  {
                    uint64_t v123 = *v10;
                    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__p[0]) = 0;
                      _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I Safety alert manager not available", (uint8_t *)__p, 2u);
                    }
                    goto LABEL_181;
                  }
                  if ((***(unsigned int (****)(void))buf)(*(void *)buf))
                  {
                    uint64_t v117 = *(void *)buf;
                    uint64_t v151 = v34;
                    uint64_t v152 = (std::__shared_weak_count *)v32;
                    atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
                    int v118 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v117 + 104))(v117, &v151);
                    if (v152) {
                      sub_10004D2C8(v152);
                    }
                    uint64_t v119 = *v10;
                    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v120 = "false";
                      if (v118) {
                        uint64_t v120 = "true";
                      }
                      LODWORD(__p[0]) = 136315138;
                      *(void **)((char *)__p + 4) = (void *)v120;
                      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#I Early geofence results: %s", (uint8_t *)__p, 0xCu);
                    }
                    if (v118)
                    {
                      uint64_t v149 = v34;
                      uint64_t v150 = v32;
                      atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
                      sub_100E9E928();
                    }
                    uint64_t v128 = *(void *)buf;
                    uint64_t v147 = v34;
                    uint64_t v148 = (std::__shared_weak_count *)v32;
                    atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
                    (*(void (**)(uint64_t, uint64_t *))(*(void *)v128 + 112))(v128, &v147);
                    uint64_t v126 = v148;
                    if (!v148) {
                      goto LABEL_181;
                    }
                  }
                  else
                  {
                    CFDictionaryRef v124 = *v10;
                    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p[0]) = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "Safety alert geofencing not allowed", (uint8_t *)__p, 2u);
                    }
                    uint64_t v125 = *(void *)buf;
                    uint64_t v145 = v34;
                    uint64_t v146 = (std::__shared_weak_count *)v32;
                    atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
                    (*(void (**)(uint64_t, uint64_t *))(*(void *)v125 + 112))(v125, &v145);
                    uint64_t v126 = v146;
                    if (!v146) {
                      goto LABEL_181;
                    }
                  }
                  sub_10004D2C8(v126);
LABEL_181:
                  if (v142)
                  {
                    uint64_t v143 = v34;
                    char v144 = (std::__shared_weak_count *)v32;
                    atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
                    (*(void (**)(uint64_t, uint64_t *))(*(void *)v142 + 48))(v142, &v143);
                    if (v144) {
                      sub_10004D2C8(v144);
                    }
                    uint64_t v52 = 9;
                  }
                  else
                  {
                    int v127 = *v10;
                    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p[0]) = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "Failed to get WeaGeofenceManager...", (uint8_t *)__p, 2u);
                    }
                    uint64_t v52 = 0;
                  }
                  if (*(void *)&buf[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                  }
                  goto LABEL_167;
                }
              }
              uint64_t v121 = *v10;
              if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "#I Processing as non-geofenced alert...", buf, 2u);
              }
              atomic_fetch_add_explicit(v32 + 1, 1uLL, memory_order_relaxed);
              sub_100E9E928();
            }
          }
          else
          {
            uint64_t v102 = 0;
          }
          std::mutex::unlock(v96);
          long long v103 = 0;
          char v104 = 1;
          goto LABEL_133;
        }
      }
      uint64_t v91 = *v71;
      if (!os_log_type_enabled(*v71, OS_LOG_TYPE_ERROR)) {
        goto LABEL_115;
      }
      __p[0] = &v163;
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5]
           + 464))
      {
        __p[0] = &v163;
        uint64_t v130 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5];
        if (!*((unsigned char *)v130 + 464)) {
          goto LABEL_202;
        }
        uint64_t v129 = v130[57];
      }
      else
      {
        uint64_t v129 = -1;
      }
      __p[0] = &v163;
      if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5]
            + 480))
      {
        uint64_t v131 = -1;
LABEL_200:
        *(_DWORD *)std::string buf = 134545921;
        *(void *)&uint8_t buf[4] = v129;
        *(_WORD *)&unsigned char buf[12] = 2053;
        *(void *)&buf[14] = v131;
        _os_log_error_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "Invalid Cell ID / Area Code [%{sensitive}lld] [%{sensitive}lld]", buf, 0x16u);
LABEL_115:
        int v84 = 0;
LABEL_116:
        char v50 = v140;
        goto LABEL_136;
      }
      __p[0] = &v163;
      uint64_t v132 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5];
      if (*((unsigned char *)v132 + 480))
      {
        uint64_t v131 = v132[59];
        goto LABEL_200;
      }
LABEL_202:
      sub_10016C840();
    }
    __p[0] = &v163;
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5]
         + 464))
    {
      __p[0] = &v163;
      int v81 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5];
      if (!*((unsigned char *)v81 + 464)) {
        goto LABEL_201;
      }
      uint64_t v82 = v81[57];
    }
    else
    {
      uint64_t v82 = -1;
    }
    __p[0] = &v163;
    if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5]
          + 480))
    {
      uint64_t v87 = -1;
      goto LABEL_102;
    }
    __p[0] = &v163;
    int v86 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v163, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5];
    if (*((unsigned char *)v86 + 480))
    {
      uint64_t v87 = v86[59];
LABEL_102:
      *(_DWORD *)std::string buf = 134545921;
      *(void *)&uint8_t buf[4] = v82;
      *(_WORD *)&unsigned char buf[12] = 2053;
      *(void *)&buf[14] = v87;
      _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I Device Location Info: Cell ID: %{sensitive}lld Area Code: %{sensitive}lld", buf, 0x16u);
      goto LABEL_103;
    }
LABEL_201:
    sub_10016C840();
  }
  long long v51 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v85 = sms::asString();
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v85;
    _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Invalid WEA format %{public}s", buf, 0xCu);
  }
  uint64_t v52 = 2;
LABEL_170:
  if (SHIBYTE(v158) < 0) {
    operator delete(v156);
  }
  if (SHIBYTE(v160) < 0) {
    operator delete(v159[0]);
  }
  return v52;
}

void sub_100E9E608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  uint64_t v56 = *(std::__shared_weak_count **)(v54 - 200);
  if (v56) {
    sub_10004D2C8(v56);
  }
  if ((v53 & 1) == 0) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v52);
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  _Unwind_Resume(a1);
}

void sub_100E9E884(uint64_t *a1, uint64_t a2)
{
  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  else
  {
    v4[0] = 0;
    v4[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v4);
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::setSource((ctu::TextConverter *)v4, *(const char **)a2, *(void *)(a2 + 8) - *(void *)a2);
    ctu::TextConverter::readChars(a1, (ctu::TextConverter *)v4, 0x7FFFFFFFuLL);
    ctu::TextConverter::~TextConverter((ctu::TextConverter *)v4);
  }
}

void sub_100E9E914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100E9E928()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  operator new();
}

void sub_100E9EC48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21)
{
  sub_100160BF8(&a21);
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_7:
      sub_10004D2C8(v22);
      if (!v21) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else if ((v23 & 1) == 0)
  {
    goto LABEL_7;
  }
  if (!v21)
  {
LABEL_9:
    if (a20) {
      sub_10004D2C8(a20);
    }
    _Unwind_Resume(a1);
  }
LABEL_8:
  sub_10004D2C8(v21);
  goto LABEL_9;
}

void sms::Controller::dispatchWea(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_100E9EE20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sms::Controller::copyCellBroadcastAlertTypes(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  unsigned int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      (*(void (**)(void, void))(**(void **)(a1 + 2568) + 16))(*(void *)(a1 + 2568), v8);
      return;
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_100EA2990;
  v9[3] = &unk_101A66E30;
  v9[4] = a1 + 8;
  void v9[5] = v7;
  __int16 v10 = v9;
  long long v6 = *(NSObject **)(a1 + 24);
  *a3 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    uint64_t v12 = sub_100EA29C4;
    long long v13 = &unk_101A66E50;
    uint64_t v14 = a3;
    int v15 = &v10;
    dispatch_sync(v6, block);
  }
  else
  {
    uint64_t v12 = sub_100EA2A3C;
    long long v13 = &unk_101A66E70;
    uint64_t v14 = a3;
    int v15 = &v10;
    dispatch_async_and_wait(v6, block);
  }
}

uint64_t sms::Controller::getCellBroadcastSettingForAlertType(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v11 = a2;
  v9[3] = a4;
  uint64_t v10 = a3;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v10;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 2568) + 40))(*(void *)(a1 + 2568), v11, v10, a4);
    }
    BOOL v7 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  CFTypeRef v12[2] = sub_100EA2AB4;
  v12[3] = &unk_101A66E90;
  v12[4] = a1 + 8;
  v12[5] = v9;
  long long v13 = v12;
  unsigned int v8 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v7)
  {
    int v15 = sub_10005A5D4;
    std::string::size_type v16 = &unk_101A66EB0;
    uint64_t v17 = &v19;
    int v18 = &v13;
    dispatch_sync(v8, block);
  }
  else
  {
    int v15 = sub_10005B338;
    std::string::size_type v16 = &unk_101A66ED0;
    uint64_t v17 = &v19;
    int v18 = &v13;
    dispatch_async_and_wait(v8, block);
  }
  return v19 != 0;
}

uint64_t sms::Controller::setCellBroadcastSettingForAlertType(capabilities::ct *a1, unsigned int a2, uint64_t a3, char a4)
{
  unsigned int v11 = a2;
  uint64_t v10 = a3;
  char v9 = a4;
  v8[0] = a1;
  v8[1] = &v11;
  void v8[2] = &v10;
  v8[3] = &v9;
  if (*((void *)a1 + 4))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100E9F434(a1, v11, v10, v9);
    }
    BOOL v6 = *((void *)a1 + 4) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  CFTypeRef v12[2] = sub_100EA2AF0;
  v12[3] = &unk_101A66EF0;
  v12[4] = (char *)a1 + 8;
  v12[5] = v8;
  long long v13 = v12;
  BOOL v7 = *((void *)a1 + 3);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    int v15 = sub_10005A5D4;
    std::string::size_type v16 = &unk_101A66EB0;
    uint64_t v17 = &v19;
    int v18 = &v13;
    dispatch_sync(v7, block);
  }
  else
  {
    int v15 = sub_10005B338;
    std::string::size_type v16 = &unk_101A66ED0;
    uint64_t v17 = &v19;
    int v18 = &v13;
    dispatch_async_and_wait(v7, block);
  }
  return v19 != 0;
}

uint64_t sub_100E9F434(capabilities::ct *a1, uint64_t a2, uint64_t a3, char a4)
{
  if (!capabilities::ct::supportsGemini(a1))
  {
    uint64_t v14 = *(uint64_t (**)(void))(**((void **)a1 + 321) + 48);
LABEL_20:
    char v9 = v14();
    int v15 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 6) + 16))(*((void **)a1 + 6), a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Cell broadcast setting has been changed, pushing the configuration to baseband again", (uint8_t *)&v17, 2u);
    }
    sms::Controller::setupBasebandForCellBroadcast_sync((uint64_t)a1, a2);
    return v9 & 1;
  }
  if ((a4 & 1) == 0)
  {
    uint64_t v14 = *(uint64_t (**)(void))(**((void **)a1 + 321) + 48);
    goto LABEL_20;
  }
  subscriber::makeSimSlotRange();
  unsigned int v8 = v17;
  if (v17 == v18) {
    goto LABEL_24;
  }
  while ((v19(*v8) & 1) == 0)
  {
    if (++v8 == v18)
    {
      unsigned int v8 = v18;
      break;
    }
  }
  if (v8 == v18)
  {
LABEL_24:
    char v9 = 0;
  }
  else
  {
    char v9 = 0;
    do
    {
      uint64_t v10 = *v8;
      char v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(**((void **)a1 + 321) + 48))(*((void **)a1 + 321), v10, a3, 1);
      uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 6) + 16))(*((void **)a1 + 6), v10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Cell broadcast setting has been changed, pushing the configuration to baseband again", buf, 2u);
      }
      sms::Controller::setupBasebandForCellBroadcast_sync((uint64_t)a1, v10);
      long long v13 = v8 + 1;
      unsigned int v8 = v18;
      if (v13 != v18)
      {
        unsigned int v8 = v13;
        while ((v19(*v8) & 1) == 0)
        {
          if (++v8 == v18)
          {
            unsigned int v8 = v18;
            break;
          }
        }
      }
      v9 |= v11;
    }
    while (v8 != v18);
  }
  return v9 & 1;
}

uint64_t sms::Controller::storeMMIAlertPreference(sms::Controller *this, char a2)
{
  char v7 = a2;
  v6[0] = this;
  v6[1] = &v7;
  if (*((void *)this + 4))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100E9F834((uint64_t)this);
    }
    BOOL v4 = *((void *)this + 4) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100EA2B0C;
  v8[3] = &unk_101A66F10;
  void v8[4] = (char *)this + 8;
  void v8[5] = v6;
  char v9 = v8;
  BOOL v5 = *((void *)this + 3);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    char v11 = sub_10005A5D4;
    uint64_t v12 = &unk_101A66EB0;
    long long v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    char v11 = sub_10005B338;
    uint64_t v12 = &unk_101A66ED0;
    long long v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

uint64_t sub_100E9F834(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 2568) + 200))(*(void *)(a1 + 2568));
  if (v2)
  {
    subscriber::makeSimSlotRange();
    uint64_t v3 = v6;
    if (v6 != v7)
    {
      while ((v8(*v3) & 1) == 0)
      {
        if (++v3 == v7)
        {
          uint64_t v3 = v7;
          break;
        }
      }
LABEL_6:
      while (v3 != v7)
      {
        BOOL v4 = v3 + 1;
        sms::Controller::setupBasebandForCellBroadcast_sync(a1, *v3);
        uint64_t v3 = v7;
        if (v4 != v7)
        {
          uint64_t v3 = v4;
          while ((v8(*v3) & 1) == 0)
          {
            if (++v3 == v7)
            {
              uint64_t v3 = v7;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  return v2;
}

void sms::Controller::setupBasebandForCellBroadcast_sync(uint64_t a1, int a2)
{
  unsigned int v22 = a2;
  if (subscriber::isValidSimSlot())
  {
    char v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sms::Controller::getDynamicMessageModes_sync(a1, a2, (uint64_t *)&v19);
    BOOL v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v22);
    BOOL v5 = v4;
    BOOL v6 = v19;
    if (v19 != v20)
    {
      while (*v6 != 4)
      {
        if (++v6 == v20)
        {
          BOOL v6 = v20;
          break;
        }
      }
    }
    if (v6 == v20)
    {
      uint64_t v12 = *v4;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      *(_WORD *)std::string::size_type v16 = 0;
      long long v13 = "#I Device inherently does not support cell broadcast, not pushing any configuration";
    }
    else
    {
      if ((capabilities::ct::supportsGemini((capabilities::ct *)v4) & 1) != 0
        || (*(void *)std::string::size_type v16 = &v22,
            *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)v16)[5]
            + 261)))
      {
        *(void *)std::string::size_type v16 = 0;
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        memset(__p, 0, sizeof(__p));
        if (sub_100EA03D4(a1, v22, v16, __p))
        {
          uint64_t v7 = *(void *)(a1 + 112);
          if (v7)
          {
            (*(void (**)(uint64_t, void))(*(void *)v7 + 120))(v7, v22);
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112), v22);
          }
          uint64_t v8 = v22;
          unsigned __int8 v23 = 0;
          char v9 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v22);
          if ((*(unsigned int (**)(void, uint64_t, unsigned __int8 *))(**(void **)(a1 + 2568) + 24))(*(void *)(a1 + 2568), v8, &v23))
          {
            uint64_t v10 = *v9;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              if (v23) {
                char v11 = "true";
              }
              else {
                char v11 = "false";
              }
              *(_DWORD *)std::string buf = 136315138;
              unsigned int v25 = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Alerts enabled: %s", buf, 0xCu);
            }
          }
          sub_100E9FEB8(a1, v8, v23);
        }
        else
        {
          uint64_t v14 = *v5;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Deactivating the CMAS as could not read the config from operator bundle", buf, 2u);
          }
          sub_100E9FEB8(a1, v22, 0);
        }
        if (__p[0]) {
          operator delete(__p[0]);
        }
        if (*(void *)v16) {
          operator delete(*(void **)v16);
        }
        goto LABEL_31;
      }
      uint64_t v12 = *v5;
      if (!os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
LABEL_31:
        if (v19)
        {
          uint64_t v20 = v19;
          operator delete(v19);
        }
        return;
      }
      *(_WORD *)std::string::size_type v16 = 0;
      long long v13 = "#I SMS not ready. Baseband not being setup for CMAS";
    }
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, v16, 2u);
    goto LABEL_31;
  }
}

void sub_100E9FC98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
}

BOOL sms::Controller::injectCellBroadcastMessage(uint64_t a1, long long *a2, long long *a3)
{
  uint64_t v8 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v12 = *((void *)a3 + 2);
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = sub_100EA2B1C;
  v13[3] = &unk_101A66F30;
  v13[4] = a1 + 8;
  v13[5] = &v8;
  uint64_t v14 = v13;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int8 v21 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v16 = 0x40000000;
    uint64_t v17 = sub_10005B338;
    uint64_t v18 = &unk_101A66ED0;
    char v19 = &v21;
    uint64_t v20 = &v14;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    unsigned __int8 v21 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v16 = 0x40000000;
    uint64_t v17 = sub_10005A5D4;
    uint64_t v18 = &unk_101A66EB0;
    char v19 = &v21;
    uint64_t v20 = &v14;
    dispatch_sync(v5, &block);
  }
  int v6 = v21;
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  return v6 != 0;
}

void sub_100E9FE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E9FEB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v21 = a2;
  if (subscriber::isValidSimSlot())
  {
    int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    *(void *)std::string buf = &v21;
    uint64_t v7 = (uint64_t **)(sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                    + 29);
    int v20 = 1;
    if (*((unsigned char *)sub_100877FD0(v7, 1, &v20) + 32))
    {
      *(void *)std::string buf = &v21;
      uint64_t v8 = (uint64_t **)(sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                      + 29);
      int v19 = 0;
      if (*((unsigned char *)sub_100877FD0(v8, 0, &v19) + 32))
      {
        *(void *)std::string buf = &v21;
        if (*((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
             + 64) == a3)
        {
          os_log_t v9 = *v6;
          if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a3;
          uint64_t v10 = "#I Activation (%d) has been done before";
          char v11 = v9;
          uint32_t v12 = 8;
          goto LABEL_15;
        }
      }
    }
    long long v13 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = "kBroadcastSMSDeactivate";
      if (a3) {
        uint64_t v14 = "kBroadcastSMSActivate";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Going ahead and issuing activation (%s) request to baseband", buf, 0xCu);
    }
    *(void *)std::string buf = &v21;
    *((_DWORD *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 64) = a3;
    *(void *)std::string buf = &v21;
    char v15 = (uint64_t **)(sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                     + 29);
    *(_DWORD *)std::string buf = 1;
    *((unsigned char *)sub_100877FD0(v15, 1, buf) + 32) = 0;
    *(void *)std::string buf = &v21;
    uint64_t v16 = (uint64_t **)(sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v21, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                     + 29);
    *(_DWORD *)std::string buf = 0;
    *((unsigned char *)sub_100877FD0(v16, 0, buf) + 32) = 0;
    uint64_t v17 = *(void *)(a1 + 112);
    if (v17)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v17 + 96))(v17, 1, a3, v21);
      (*(void (**)(void, void, uint64_t, void))(**(void **)(a1 + 112) + 96))(*(void *)(a1 + 112), 0, a3, v21);
      return;
    }
    os_log_t v18 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "#I WMS Driver is not yet available";
      char v11 = v18;
      uint32_t v12 = 2;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    }
  }
}

uint64_t sms::Controller::handleCBActivation(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v13 = a4;
  int v14 = a3;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    os_log_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = "false";
      if (a2) {
        uint64_t v10 = "true";
      }
      if (a3 == 255)
      {
        char v11 = "kBroadcastConfigModeUnknown";
      }
      else if (a3 == 1)
      {
        char v11 = "kBroadcastConfigModeGSM";
      }
      else if (a3)
      {
        char v11 = "???";
      }
      else
      {
        char v11 = "kBroadcastConfigModeCDMA";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v16 = 2080;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I SMS Broadcast activation result %s for mode %s", buf, 0x16u);
    }
    *(void *)std::string buf = &v13;
    uint32_t v12 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v13, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    if (a2) {
      LOBYTE(a2) = 1;
    }
    uint64_t result = (uint64_t)sub_100877FD0((uint64_t **)v12[5] + 29, a3, &v14);
    *(unsigned char *)(result + 32) = a2;
  }
  return result;
}

uint64_t sub_100EA03D4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  CFArrayRef theArray = (CFArrayRef)(*(uint64_t (**)(void, uint64_t, const __CFString *))(**(void **)(a1 + 2568)
                                                                                        + 104))(*(void *)(a1 + 2568), a2, @"MessageIDParameters3GPP");
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  os_log_t v9 = v8;
  CFArrayRef v10 = theArray;
  if (theArray) {
    char v11 = sub_100083F10;
  }
  else {
    char v11 = 0;
  }
  uint64_t v85 = a4;
  if (!v11) {
    goto LABEL_48;
  }
  int v84 = v8;
  uint32_t v12 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I The CMAS Configuration for 3GPP has been be retrieved", buf, 2u);
    CFArrayRef v10 = theArray;
  }
  CFIndex Count = CFArrayGetCount(v10);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
      CFDictionaryRef v16 = ValueAtIndex;
      if (ValueAtIndex && (CFTypeID v17 = CFGetTypeID(ValueAtIndex), v17 == CFDictionaryGetTypeID()))
      {
        *(_WORD *)&uint8_t buf[4] = 0;
        *(_DWORD *)std::string buf = 0;
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v16, @"FromServiceID");
        CFNumberRef v19 = Value;
        if (Value
          && (CFTypeID v20 = CFGetTypeID(Value), v20 == CFNumberGetTypeID())
          && CFNumberGetValue(v19, kCFNumberSInt16Type, buf))
        {
          CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(v16, @"ToServiceID");
          CFNumberRef v22 = v21;
          if (v21)
          {
            CFTypeID v23 = CFGetTypeID(v21);
            if (v23 == CFNumberGetTypeID())
            {
              if (CFNumberGetValue(v22, kCFNumberSInt16Type, &buf[2]))
              {
                uint8_t buf[4] = 1;
                unsigned int v25 = (unsigned char *)a3[1];
                unint64_t v24 = a3[2];
                if ((unint64_t)v25 >= v24)
                {
                  uint64_t v34 = (unsigned char *)*a3;
                  unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v25[-*a3] >> 1);
                  unint64_t v36 = v35 + 1;
                  if (v35 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                    sub_10006A748();
                  }
                  unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v34) >> 1);
                  if (2 * v37 > v36) {
                    unint64_t v36 = 2 * v37;
                  }
                  if (v37 >= 0x1555555555555555) {
                    unint64_t v38 = 0x2AAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v38 = v36;
                  }
                  if (v38)
                  {
                    if (v38 > 0x2AAAAAAAAAAAAAAALL) {
                      sub_10006A7CC();
                    }
                    unint64_t v39 = v38;
                    BOOL v40 = (char *)operator new(6 * v38);
                    unint64_t v38 = v39;
                  }
                  else
                  {
                    BOOL v40 = 0;
                  }
                  uint64_t v41 = &v40[6 * v35];
                  *(_DWORD *)uint64_t v41 = *(_DWORD *)buf;
                  *((_WORD *)v41 + 2) = *(_WORD *)&buf[4];
                  uint64_t v42 = v41;
                  if (v25 != v34)
                  {
                    do
                    {
                      int v43 = *(_DWORD *)(v25 - 6);
                      v25 -= 6;
                      char v44 = v25[4];
                      *(_DWORD *)(v42 - 6) = v43;
                      v42 -= 6;
                      v42[4] = v44;
                    }
                    while (v25 != v34);
                    unsigned int v25 = (unsigned char *)*a3;
                  }
                  uint64_t v27 = v41 + 6;
                  *a3 = v42;
                  a3[1] = v41 + 6;
                  a3[2] = &v40[6 * v38];
                  if (v25) {
                    operator delete(v25);
                  }
                }
                else
                {
                  int v26 = *(_DWORD *)buf;
                  *((_WORD *)v25 + 2) = *(_WORD *)&buf[4];
                  *(_DWORD *)unsigned int v25 = v26;
                  uint64_t v27 = v25 + 6;
                }
                a3[1] = v27;
                continue;
              }
            }
          }
          long long v33 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v87 = 0;
            uint64_t v29 = v87;
            uint64_t v30 = v33;
            long long v31 = "Failed to retrieve ToServiceID in MessageID dictionary";
            goto LABEL_27;
          }
        }
        else
        {
          long long v32 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v87 = 0;
            uint64_t v29 = v87;
            uint64_t v30 = v32;
            long long v31 = "Failed to retrieve FromServiceID in MessageID dictionary";
            goto LABEL_27;
          }
        }
      }
      else
      {
        char v28 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          uint64_t v29 = buf;
          uint64_t v30 = v28;
          long long v31 = "Failed to retrieve MessageID dictionary";
LABEL_27:
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v31, v29, 2u);
        }
      }
    }
  }
  if (*a3 != a3[1])
  {
    uint64_t v45 = 1;
    os_log_t v9 = v84;
    goto LABEL_49;
  }
  uint64_t v46 = *(NSObject **)(a1 + 40);
  uint64_t v45 = 0;
  os_log_t v9 = v84;
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#N 3GPP does not have any configuration", buf, 2u);
LABEL_48:
    uint64_t v45 = 0;
  }
LABEL_49:
  CFArrayRef v47 = (const __CFArray *)(*(uint64_t (**)(void, uint64_t, const __CFString *))(**(void **)(a1 + 2568)
                                                                                          + 104))(*(void *)(a1 + 2568), a2, @"MessageIDParameters3GPP2");
  *(void *)std::string buf = v47;
  if (v47) {
    long long v48 = sub_100083F10;
  }
  else {
    long long v48 = 0;
  }
  if (v48)
  {
    int v49 = *v9;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v87 = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I The CMAS Configuration for 3GPP2 has been be retrieved", v87, 2u);
      CFArrayRef v47 = *(const __CFArray **)buf;
    }
    CFIndex v50 = CFArrayGetCount(v47);
    if (v50 >= 1)
    {
      for (CFIndex j = 0; j != v50; ++j)
      {
        CFDictionaryRef v52 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)buf, j);
        CFDictionaryRef v53 = v52;
        if (v52 && (CFTypeID v54 = CFGetTypeID(v52), v54 == CFDictionaryGetTypeID()))
        {
          __int16 v88 = 0;
          *(_DWORD *)uint64_t v87 = 0;
          CFNumberRef v55 = (const __CFNumber *)CFDictionaryGetValue(v53, @"Category");
          CFNumberRef v56 = v55;
          if (v55
            && (CFTypeID v57 = CFGetTypeID(v55), v57 == CFNumberGetTypeID())
            && CFNumberGetValue(v56, kCFNumberSInt16Type, v87))
          {
            CFNumberRef v58 = (const __CFNumber *)CFDictionaryGetValue(v53, @"Language");
            CFNumberRef v59 = v58;
            if (v58)
            {
              CFTypeID v60 = CFGetTypeID(v58);
              if (v60 == CFNumberGetTypeID())
              {
                if (CFNumberGetValue(v59, kCFNumberSInt16Type, &v87[2]))
                {
                  LOBYTE(v88) = 1;
                  uint64_t v62 = (char *)v85[1];
                  unint64_t v61 = v85[2];
                  if ((unint64_t)v62 >= v61)
                  {
                    uint64_t v71 = (char *)*v85;
                    unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v62[-*v85] >> 1);
                    unint64_t v73 = v72 + 1;
                    if (v72 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                      sub_10006A748();
                    }
                    unint64_t v74 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v61 - (void)v71) >> 1);
                    if (2 * v74 > v73) {
                      unint64_t v73 = 2 * v74;
                    }
                    if (v74 >= 0x1555555555555555) {
                      unint64_t v75 = 0x2AAAAAAAAAAAAAAALL;
                    }
                    else {
                      unint64_t v75 = v73;
                    }
                    if (v75)
                    {
                      if (v75 > 0x2AAAAAAAAAAAAAAALL) {
                        sub_10006A7CC();
                      }
                      uint64_t v76 = (char *)operator new(6 * v75);
                    }
                    else
                    {
                      uint64_t v76 = 0;
                    }
                    char v77 = &v76[6 * v72];
                    *(_DWORD *)char v77 = *(_DWORD *)v87;
                    *((_WORD *)v77 + 2) = v88;
                    char v78 = v77;
                    if (v62 == v71)
                    {
                      int v81 = (char **)v85;
                    }
                    else
                    {
                      do
                      {
                        int v79 = *(_DWORD *)(v62 - 6);
                        v62 -= 6;
                        char v80 = v62[4];
                        *(_DWORD *)(v78 - 6) = v79;
                        v78 -= 6;
                        v78[4] = v80;
                      }
                      while (v62 != v71);
                      int v81 = (char **)v85;
                      uint64_t v62 = (char *)*v85;
                    }
                    uint64_t v64 = v77 + 6;
                    uint64_t *v81 = v78;
                    v81[1] = v77 + 6;
                    v81[2] = &v76[6 * v75];
                    if (v62) {
                      operator delete(v62);
                    }
                  }
                  else
                  {
                    int v63 = *(_DWORD *)v87;
                    *((_WORD *)v62 + 2) = v88;
                    *(_DWORD *)uint64_t v62 = v63;
                    uint64_t v64 = v62 + 6;
                  }
                  v85[1] = v64;
                  continue;
                }
              }
            }
            uint64_t v70 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int v86 = 0;
              uint64_t v66 = v86;
              uint64_t v67 = v70;
              uint64_t v68 = "Failed to retrieve Language in MessageID dictionary";
              goto LABEL_75;
            }
          }
          else
          {
            uint64_t v69 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)int v86 = 0;
              uint64_t v66 = v86;
              uint64_t v67 = v69;
              uint64_t v68 = "Failed to retrieve Category in MessageID dictionary";
              goto LABEL_75;
            }
          }
        }
        else
        {
          unsigned int v65 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v87 = 0;
            uint64_t v66 = v87;
            uint64_t v67 = v65;
            uint64_t v68 = "Failed to retrieve MessageID dictionary";
LABEL_75:
            _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, v68, v66, 2u);
          }
        }
      }
    }
    if (*v85 == v85[1])
    {
      uint64_t v82 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v87 = 0;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#N 3GPP2 does not have any configuration", v87, 2u);
      }
    }
    else
    {
      uint64_t v45 = 1;
    }
  }
  sub_100044D00((const void **)buf);
  sub_100044D00((const void **)&theArray);
  return v45;
}

void sub_100EA0C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  CFArrayRef v10 = va_arg(va1, const void *);
  sub_100044D00((const void **)va);
  sub_100044D00((const void **)va1);
  _Unwind_Resume(a1);
}

void sms::Controller::handleCBSetConfigResult(uint64_t a1, char a2, int a3, uint64_t a4)
{
  if (subscriber::isValidSimSlot())
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
    if (a2)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        os_log_t v9 = "kBroadcastConfigModeGSM";
        CFArrayRef v10 = "???";
        if (!a3) {
          CFArrayRef v10 = "kBroadcastConfigModeCDMA";
        }
        if (a3 != 1) {
          os_log_t v9 = v10;
        }
        if (a3 == 255) {
          os_log_t v9 = "kBroadcastConfigModeUnknown";
        }
        int v13 = 136315138;
        int v14 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Set Broadcast Config succeeded for mode %s", (uint8_t *)&v13, 0xCu);
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      char v11 = "kBroadcastConfigModeGSM";
      uint32_t v12 = "???";
      if (!a3) {
        uint32_t v12 = "kBroadcastConfigModeCDMA";
      }
      if (a3 != 1) {
        char v11 = v12;
      }
      if (a3 == 255) {
        char v11 = "kBroadcastConfigModeUnknown";
      }
      int v13 = 136315138;
      int v14 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Set Broadcast Config failed for mode %s", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sms::Controller::handleCBGetConfig3GPP(uint64_t a1, int a2, unsigned __int16 ***a3, uint64_t a4)
{
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  int v49 = 0;
  CFIndex v50 = 0;
  uint64_t v51 = 0;
  memset(v48, 0, sizeof(v48));
  sub_100EA03D4(a1, a4, &v49, v48);
  char v44 = a3;
  uint64_t v45 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
  uint64_t v8 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      if (a2 == 255)
      {
        os_log_t v9 = "kBroadcastSMSActivationUnknown";
      }
      else if (a2 == 1)
      {
        os_log_t v9 = "kBroadcastSMSActivate";
      }
      else
      {
        os_log_t v9 = "???";
      }
    }
    else
    {
      os_log_t v9 = "kBroadcastSMSDeactivate";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Get Broadcast Config for 3GPP, activated: %s", buf, 0xCu);
    uint64_t v8 = *v45;
  }
  CFArrayRef v10 = *a3;
  unsigned int v43 = a4;
  if (*a3)
  {
    char v11 = *v10;
    uint32_t v12 = v10[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Broadcast config 3GPP:", buf, 2u);
    }
    uint64_t v71 = 0;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    *(_OWORD *)CFNumberRef v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10004BD84((uint64_t)buf);
    for (; v11 != v12; v11 += 3)
    {
      sub_10004B96C(&v55, (uint64_t)"[", 1);
      int v13 = (void *)std::ostream::operator<<();
      sub_10004B96C(v13, (uint64_t)"-", 1);
      int v14 = (void *)std::ostream::operator<<();
      char v15 = sub_10004B96C(v14, (uint64_t)":", 1);
      if (*((unsigned char *)v11 + 4)) {
        CFDictionaryRef v16 = "true";
      }
      else {
        CFDictionaryRef v16 = "false";
      }
      if (*((unsigned char *)v11 + 4)) {
        uint64_t v17 = 4;
      }
      else {
        uint64_t v17 = 5;
      }
      os_log_t v18 = sub_10004B96C(v15, (uint64_t)v16, v17);
      sub_10004B96C(v18, (uint64_t)"] ", 2);
    }
    CFNumberRef v19 = *v45;
    if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004BC98((uint64_t)&v55 + 8, __p);
      CFTypeID v20 = v47 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)CFDictionaryRef v52 = 136446210;
      CFDictionaryRef v53 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v52, 0xCu);
      if (v47 < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)&long long v55 = v21;
    if (SHIBYTE(v60) < 0) {
      operator delete(v59[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    uint64_t v8 = *v45;
  }
  CFNumberRef v22 = (char *)v49;
  CFTypeID v23 = v50;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Current Broadcast config 3GPP:", buf, 2u);
  }
  uint64_t v71 = 0;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  *(_OWORD *)CFNumberRef v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_10004BD84((uint64_t)buf);
  for (; v22 != v23; v22 += 6)
  {
    sub_10004B96C(&v55, (uint64_t)"[", 1);
    unint64_t v24 = (void *)std::ostream::operator<<();
    sub_10004B96C(v24, (uint64_t)"-", 1);
    unsigned int v25 = (void *)std::ostream::operator<<();
    int v26 = sub_10004B96C(v25, (uint64_t)":", 1);
    if (v22[4]) {
      uint64_t v27 = "true";
    }
    else {
      uint64_t v27 = "false";
    }
    if (v22[4]) {
      uint64_t v28 = 4;
    }
    else {
      uint64_t v28 = 5;
    }
    uint64_t v29 = sub_10004B96C(v26, (uint64_t)v27, v28);
    sub_10004B96C(v29, (uint64_t)"] ", 2);
  }
  uint64_t v30 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&v55 + 8, __p);
    long long v31 = v47 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)CFDictionaryRef v52 = 136446210;
    CFDictionaryRef v53 = v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v52, 0xCu);
    if (v47 < 0) {
      operator delete(__p[0]);
    }
  }
  if (!*v44)
  {
    unint64_t v39 = *v45;
    if (!os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_66;
    }
    LOWORD(__p[0]) = 0;
    BOOL v40 = "#I Sending the 3GPP CMAS config to Baseband";
LABEL_65:
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)__p, 2u);
LABEL_66:
    uint64_t v41 = *(void *)(a1 + 112);
    if (v41) {
      (*(void (**)(uint64_t, void **, void))(*(void *)v41 + 104))(v41, &v49, v43);
    }
    goto LABEL_68;
  }
  long long v32 = v50;
  long long v33 = **v44;
  if (v50 - (unsigned char *)v49 != (char *)(*v44)[1] - (char *)v33)
  {
LABEL_61:
    unint64_t v39 = *v45;
    if (!os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_66;
    }
    LOWORD(__p[0]) = 0;
    BOOL v40 = "#I 3GPPs are not equal";
    goto LABEL_65;
  }
  if (v49 != v50)
  {
    uint64_t v34 = 0;
    while (1)
    {
      unint64_t v35 = &v33[v34];
      unint64_t v36 = (char *)v49 + v34 * 2;
      if (*(unsigned __int16 *)((char *)v49 + v34 * 2) != v33[v34]
        || *((unsigned __int16 *)v36 + 1) != v35[1]
        || v36[4] != *((unsigned char *)v35 + 4))
      {
        break;
      }
      v34 += 3;
      if (v36 + 6 == v50) {
        goto LABEL_55;
      }
    }
    do
    {
      unint64_t v38 = v32 - 6;
      if (*((unsigned __int16 *)v32 - 3) != *v33
        || *((unsigned __int16 *)v32 - 2) != v33[1]
        || *(v32 - 2) != *((unsigned char *)v33 + 4))
      {
        goto LABEL_61;
      }
      v33 += 3;
      v32 -= 6;
    }
    while (v38 != v49);
  }
LABEL_55:
  unint64_t v37 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I 3GPPs are equal", (uint8_t *)__p, 2u);
  }
LABEL_68:
  *(void *)&long long v55 = v42;
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (v48[0]) {
    operator delete(v48[0]);
  }
  if (v49)
  {
    CFIndex v50 = (char *)v49;
    operator delete(v49);
  }
}

void sub_100EA16A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  _Unwind_Resume(a1);
}

void sms::Controller::handleCBGetConfig3GPP2(uint64_t a1, int a2, unsigned __int16 ***a3, uint64_t a4)
{
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  memset(v51, 0, sizeof(v51));
  long long v48 = 0;
  int v49 = 0;
  uint64_t v50 = 0;
  sub_100EA03D4(a1, a4, v51, &v48);
  char v44 = a3;
  uint64_t v45 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
  uint64_t v8 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      if (a2 == 255)
      {
        os_log_t v9 = "kBroadcastSMSActivationUnknown";
      }
      else if (a2 == 1)
      {
        os_log_t v9 = "kBroadcastSMSActivate";
      }
      else
      {
        os_log_t v9 = "???";
      }
    }
    else
    {
      os_log_t v9 = "kBroadcastSMSDeactivate";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Get Broadcast Config for 3GPP2, activated: %s", buf, 0xCu);
    uint64_t v8 = *v45;
  }
  CFArrayRef v10 = *a3;
  unsigned int v43 = a4;
  if (*a3)
  {
    char v11 = *v10;
    uint32_t v12 = v10[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Broadcast config 3GPP2:", buf, 2u);
    }
    uint64_t v71 = 0;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    *(_OWORD *)CFNumberRef v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10004BD84((uint64_t)buf);
    for (; v11 != v12; v11 += 3)
    {
      sub_10004B96C(&v55, (uint64_t)"[", 1);
      int v13 = (void *)std::ostream::operator<<();
      sub_10004B96C(v13, (uint64_t)"-", 1);
      int v14 = (void *)std::ostream::operator<<();
      char v15 = sub_10004B96C(v14, (uint64_t)":", 1);
      if (*((unsigned char *)v11 + 4)) {
        CFDictionaryRef v16 = "true";
      }
      else {
        CFDictionaryRef v16 = "false";
      }
      if (*((unsigned char *)v11 + 4)) {
        uint64_t v17 = 4;
      }
      else {
        uint64_t v17 = 5;
      }
      os_log_t v18 = sub_10004B96C(v15, (uint64_t)v16, v17);
      sub_10004B96C(v18, (uint64_t)"] ", 2);
    }
    CFNumberRef v19 = *v45;
    if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004BC98((uint64_t)&v55 + 8, __p);
      CFTypeID v20 = v47 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)CFDictionaryRef v52 = 136446210;
      CFDictionaryRef v53 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v52, 0xCu);
      if (v47 < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)&long long v55 = v21;
    if (SHIBYTE(v60) < 0) {
      operator delete(v59[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    uint64_t v8 = *v45;
  }
  CFNumberRef v22 = (char *)v48;
  CFTypeID v23 = v49;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Current Broadcast config 3GPP2:", buf, 2u);
  }
  uint64_t v71 = 0;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  *(_OWORD *)CFNumberRef v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_10004BD84((uint64_t)buf);
  for (; v22 != v23; v22 += 6)
  {
    sub_10004B96C(&v55, (uint64_t)"[", 1);
    unint64_t v24 = (void *)std::ostream::operator<<();
    sub_10004B96C(v24, (uint64_t)"-", 1);
    unsigned int v25 = (void *)std::ostream::operator<<();
    int v26 = sub_10004B96C(v25, (uint64_t)":", 1);
    if (v22[4]) {
      uint64_t v27 = "true";
    }
    else {
      uint64_t v27 = "false";
    }
    if (v22[4]) {
      uint64_t v28 = 4;
    }
    else {
      uint64_t v28 = 5;
    }
    uint64_t v29 = sub_10004B96C(v26, (uint64_t)v27, v28);
    sub_10004B96C(v29, (uint64_t)"] ", 2);
  }
  uint64_t v30 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&v55 + 8, __p);
    long long v31 = v47 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)CFDictionaryRef v52 = 136446210;
    CFDictionaryRef v53 = v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v52, 0xCu);
    if (v47 < 0) {
      operator delete(__p[0]);
    }
  }
  if (!*v44)
  {
    unint64_t v39 = *v45;
    if (!os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_66;
    }
    LOWORD(__p[0]) = 0;
    BOOL v40 = "#I Sending the 3GPP2 CMAS config to Baseband";
LABEL_65:
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)__p, 2u);
LABEL_66:
    uint64_t v41 = *(void *)(a1 + 112);
    if (v41) {
      (*(void (**)(uint64_t, void **, void))(*(void *)v41 + 112))(v41, &v48, v43);
    }
    goto LABEL_68;
  }
  long long v32 = v49;
  long long v33 = **v44;
  if (v49 - (unsigned char *)v48 != (char *)(*v44)[1] - (char *)v33)
  {
LABEL_61:
    unint64_t v39 = *v45;
    if (!os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_66;
    }
    LOWORD(__p[0]) = 0;
    BOOL v40 = "#I 3GPP2s are not equal";
    goto LABEL_65;
  }
  if (v48 != v49)
  {
    uint64_t v34 = 0;
    while (1)
    {
      unint64_t v35 = &v33[v34];
      unint64_t v36 = (char *)v48 + v34 * 2;
      if (*(unsigned __int16 *)((char *)v48 + v34 * 2) != v33[v34]
        || *((unsigned __int16 *)v36 + 1) != v35[1]
        || v36[4] != *((unsigned char *)v35 + 4))
      {
        break;
      }
      v34 += 3;
      if (v36 + 6 == v49) {
        goto LABEL_55;
      }
    }
    do
    {
      unint64_t v38 = v32 - 6;
      if (*((unsigned __int16 *)v32 - 3) != *v33
        || *((unsigned __int16 *)v32 - 2) != v33[1]
        || *(v32 - 2) != *((unsigned char *)v33 + 4))
      {
        goto LABEL_61;
      }
      v33 += 3;
      v32 -= 6;
    }
    while (v38 != v48);
  }
LABEL_55:
  unint64_t v37 = *v45;
  if (os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I 3GPP2s are equal", (uint8_t *)__p, 2u);
  }
LABEL_68:
  *(void *)&long long v55 = v42;
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (v48)
  {
    int v49 = (char *)v48;
    operator delete(v48);
  }
  if (v51[0]) {
    operator delete(v51[0]);
  }
}

void sub_100EA1FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  _Unwind_Resume(a1);
}

void sms::Controller::handleCellBroadcast_sync(uint64_t a1, uint64_t a2)
{
  int v21 = *(_DWORD *)(*(void *)a2 + 8);
  int v4 = v21;
  if (subscriber::isValidSimSlot())
  {
    os_log_t v18 = 0;
    CFNumberRef v19 = 0;
    uint64_t v20 = 0;
    sms::Controller::getDynamicMessageModes_sync(a1, v21, (uint64_t *)&v18);
    BOOL v5 = v18;
    if (v18 != v19)
    {
      while (*v5 != 4)
      {
        if (++v5 == v19)
        {
          BOOL v5 = v19;
          break;
        }
      }
    }
    if (v5 != v19)
    {
      (*(void (**)(void **__return_ptr))(**(void **)a2 + 192))(&__p);
      if ((v17 & 0x80u) == 0) {
        __int16 v6 = v17;
      }
      else {
        __int16 v6 = v16;
      }
      CFNumberRef v22 = &v21;
      uint64_t v7 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v21, (uint64_t)&unk_10144E20E, &v22)[5];
      uint64_t v9 = v7[34];
      uint64_t v8 = v7[35];
      int TransportType = sms::Model::getTransportType(*(sms::Model **)a2);
      sms::Controller::submitSMSReceivedMetric(a1, v4, v6, (v8 - v9) >> 4, 7u, TransportType, 0);
      if ((char)v17 < 0) {
        operator delete(__p);
      }
      uint64_t v11 = *(void *)(a1 + 2568);
      uint32_t v12 = *(std::__shared_weak_count **)(a2 + 8);
      int v13 = *(sms::Model **)a2;
      int v14 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, sms::Model **))(*(void *)v11 + 112))(v11, &v13);
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
    if (v18)
    {
      CFNumberRef v19 = v18;
      operator delete(v18);
    }
  }
}

void sub_100EA219C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EA21E4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A66D20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EA2204(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A66D20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EA2258(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100EA2280(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A66D70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EA22A0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A66D70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EA22F4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)(a1 + 72));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
}

void sub_100EA2378(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  int v4 = v1;
  uint64_t v2 = v1[1];
  uint64_t v5 = *v1;
  uint64_t v6 = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100E9E928();
}

void sub_100EA23E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100EA240C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EA240C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100EA2460(void *a1)
{
  *a1 = off_101A66DC0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100EA24AC(void *a1)
{
  *a1 = off_101A66DC0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100EA2518(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A66DC0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100EA257C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A66DC0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EA25BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EA25CC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100EA260C(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = a1[1];
  uint64_t v6 = a1[3];
  v7[0] = a1[2];
  v7[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    sub_100E9EE20(v5, (uint64_t)v7, v3, v4);
  }
  sub_100E9EE20(v5, (uint64_t)v7, v3, 0);
}

uint64_t sub_100EA26D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA2714()
{
}

uint64_t *sub_100EA2720(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint32_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v4 = *(void *)(v1 + 24);
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(v1 + 8);
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 16);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    int v7 = *(unsigned __int8 *)(v1 + 40);
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    int v7 = *(unsigned __int8 *)(v1 + 40);
  }
  *(void *)(v2 + 2584) = v5;
  uint64_t v8 = *(std::__shared_weak_count **)(v2 + 2592);
  *(void *)(v2 + 2592) = v6;
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v4 + 8));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    CFArrayRef v10 = "true";
    if (!v7) {
      CFArrayRef v10 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    unsigned __int8 v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Power assertion for CMAS operation created: %s", buf, 0xCu);
  }
  uint64_t v14 = v4;
  char v15 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 24))(v2, &v14);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100EA2930(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100EA28D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    sub_10004D2C8(a12);
    if (!v13)
    {
LABEL_3:
      if (!v12) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v13);
  if (!v12)
  {
LABEL_5:
    sub_100EA2930(&a10);
    sub_100046B58(&a9);
    _Unwind_Resume(a1);
  }
LABEL_4:
  sub_10004D2C8(v12);
  goto LABEL_5;
}

uint64_t *sub_100EA2930(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100EA2990(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(**(void **)(a1 + 40) + 2568) + 16))(*(void *)(**(void **)(a1 + 40) + 2568), **(unsigned int **)(*(void *)(a1 + 40) + 8));
}

const void **sub_100EA29C4(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    uint64_t v6 = v3;
    std::__shared_weak_count *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_100EA2A3C(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    std::__shared_weak_count *v2 = 0;
    uint64_t v6 = v3;
    std::__shared_weak_count *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

uint64_t sub_100EA2AB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)v1 + 2568) + 40))(*(void *)(*(void *)v1 + 2568), **(unsigned int **)(v1 + 8), **(void **)(v1 + 16), *(void *)(v1 + 24));
}

uint64_t sub_100EA2AF0(uint64_t a1)
{
  return sub_100E9F434(**(capabilities::ct ***)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), **(void **)(*(void *)(a1 + 40) + 16), **(unsigned char **)(*(void *)(a1 + 40) + 24));
}

uint64_t sub_100EA2B0C(uint64_t a1)
{
  return sub_100E9F834(**(void **)(a1 + 40));
}

uint64_t sub_100EA2B1C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  if (((*(uint64_t (**)(void))(**(void **)(*v1 + 2568) + 32))(*(void *)(*v1 + 2568)) & 1) == 0)
  {
    uint64_t v14 = *(NSObject **)(v2 + 40);
    uint64_t v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return v15;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Inject Cell Broadcast: Device does not support CMAS", (uint8_t *)&buf, 2u);
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v2 + 80));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      std::string::size_type v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v6;
  CFArrayRef v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_12:
  char v16 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if ((v16 & 1) == 0)
  {
    unsigned __int8 v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Injecting Cell Broadcast not supported", (uint8_t *)&buf, 2u);
    }
    return 0;
  }
  if (*((char *)v1 + 55) < 0)
  {
    sub_10004FC84(__p, (void *)v1[4], v1[5]);
  }
  else
  {
    *(_OWORD *)long long __p = *((_OWORD *)v1 + 2);
    uint64_t v49 = v1[6];
  }
  memset(&buf, 0, sizeof(buf));
  if (*((char *)v1 + 31) < 0)
  {
    sub_10004FC84(&buf, (void *)v1[1], v1[2]);
  }
  else
  {
    long long v18 = *(_OWORD *)(v1 + 1);
    buf.__r_.__value_.__r.__words[2] = v1[3];
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v18;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(buf.__r_.__value_.__r.__words[2]) < 8u)
    {
      CFNumberRef v19 = *(NSObject **)(v2 + 40);
      uint64_t v15 = 0;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        p_std::string buf = &buf;
LABEL_31:
        LODWORD(v62.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v62.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Invalid message while injecting WEA: [%s]", (uint8_t *)&v62, 0xCu);
LABEL_57:
        uint64_t v15 = 0;
        goto LABEL_58;
      }
      goto LABEL_58;
    }
    int v21 = &buf;
LABEL_34:
    if (v21->__r_.__value_.__s.__data_[0] == 50) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = 1;
    }
    if ((subscriber::isValidSimSlot() & 1) == 0)
    {
      long long v33 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        uint64_t v47 = subscriber::asString();
        LODWORD(v62.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v62.__r_.__value_.__r.__words + 4) = v47;
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid slot while injecting WEA: [%s]", (uint8_t *)&v62, 0xCu);
      }
      goto LABEL_57;
    }
    CFTypeID v23 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v22);
    memset(&v62, 0, sizeof(v62));
    std::string::basic_string(&v62, &buf, 2uLL, 5uLL, (std::allocator<char> *)&v60);
    std::string::size_type size = HIBYTE(v62.__r_.__value_.__r.__words[2]);
    int v25 = SHIBYTE(v62.__r_.__value_.__r.__words[2]);
    if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v62.__r_.__value_.__l.__size_;
    }
    if (size != 5) {
      goto LABEL_51;
    }
    int v26 = (std::string *)v62.__r_.__value_.__r.__words[0];
    if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v26 = &v62;
    }
    if (LODWORD(v26->__r_.__value_.__l.__data_) == 544043879 && v26->__r_.__value_.__s.__data_[4] == 58)
    {
      uint64_t v35 = 4;
    }
    else
    {
      int data = (int)v26->__r_.__value_.__l.__data_;
      int v29 = v26->__r_.__value_.__s.__data_[4];
      if (data != 1937010037 || v29 != 58)
      {
LABEL_51:
        long long v31 = *v23;
        uint64_t v15 = 0;
        if (os_log_type_enabled(*v23, OS_LOG_TYPE_DEFAULT))
        {
          long long v32 = (std::string *)v62.__r_.__value_.__r.__words[0];
          if (v25 >= 0) {
            long long v32 = &v62;
          }
          LODWORD(v60) = 136315138;
          *(void *)((char *)&v60 + 4) = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Unknown PDU type: %s", (uint8_t *)&v60, 0xCu);
          uint64_t v15 = 0;
        }
LABEL_106:
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v62.__r_.__value_.__l.__data_);
        }
        goto LABEL_58;
      }
      uint64_t v35 = 5;
    }
    std::string::erase(&buf, 0, 7uLL);
    v56[0] = 0;
    v56[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v56);
    ctu::TextConverter::pushConversion();
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v36 = &buf;
    }
    else {
      unint64_t v36 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v37 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v37 = buf.__r_.__value_.__l.__size_;
    }
    ctu::TextConverter::setSource((ctu::TextConverter *)v56, (const char *)v36, v37);
    long long v60 = 0uLL;
    uint64_t v61 = 0;
    ctu::TextConverter::readChars((uint64_t *)&v60, (ctu::TextConverter *)v56, 0x7FFFFFFFuLL);
    v54[0] = 0;
    v54[1] = 0;
    uint64_t v55 = 0;
    unint64_t v38 = (void *)HIBYTE(v49);
    if (v49 < 0) {
      unint64_t v38 = __p[1];
    }
    if (v38)
    {
      v53[0] = 0;
      v53[1] = 0;
      ctu::TextConverter::TextConverter((ctu::TextConverter *)v53);
      ctu::TextConverter::pushConversion();
      if (v49 >= 0) {
        unint64_t v39 = __p;
      }
      else {
        unint64_t v39 = (void **)__p[0];
      }
      if (v49 >= 0) {
        unint64_t v40 = HIBYTE(v49);
      }
      else {
        unint64_t v40 = (unint64_t)__p[1];
      }
      ctu::TextConverter::setSource((ctu::TextConverter *)v53, (const char *)v39, v40);
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      uint64_t v52 = 0;
      ctu::TextConverter::readChars((uint64_t *)&v50, (ctu::TextConverter *)v53, 0x7FFFFFFFuLL);
      if (v52 >= 0) {
        uint64_t v41 = (char *)&v50;
      }
      else {
        uint64_t v41 = (char *)v50;
      }
      if (v52 >= 0) {
        size_t v42 = HIBYTE(v52);
      }
      else {
        size_t v42 = (size_t)v51;
      }
      uint64_t v59 = 0;
      memset(v58, 0, sizeof(v58));
      sub_1007DC9C0((char *)v58, v41, &v41[v42], v42);
      if (v54[0])
      {
        v54[1] = v54[0];
        operator delete(v54[0]);
      }
      *(_OWORD *)CFTypeID v54 = *(_OWORD *)v58;
      uint64_t v55 = v59;
      if (SHIBYTE(v52) < 0) {
        operator delete(v50);
      }
      ctu::TextConverter::~TextConverter((ctu::TextConverter *)v53);
    }
    if (v61 >= 0) {
      unsigned int v43 = (char *)&v60;
    }
    else {
      unsigned int v43 = (char *)v60;
    }
    if (v61 >= 0) {
      size_t v44 = HIBYTE(v61);
    }
    else {
      size_t v44 = *((void *)&v60 + 1);
    }
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v50 = 0;
    sub_1007DC9C0((char *)&v50, v43, &v43[v44], v44);
    (*(void (**)(uint64_t, uint64_t, void **, void **, uint64_t))(*(void *)v2 + 384))(v2, v22, &v50, v54, v35);
    uint64_t v45 = *v23;
    if (os_log_type_enabled(*v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v46 = sms::asString();
      *(_DWORD *)long long v58 = 136315138;
      *(void *)&v58[4] = v46;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I WEA processing status: %s", v58, 0xCu);
    }
    if (v50)
    {
      uint64_t v51 = v50;
      operator delete(v50);
    }
    if (v54[0])
    {
      v54[1] = v54[0];
      operator delete(v54[0]);
    }
    if (SHIBYTE(v61) < 0) {
      operator delete((void *)v60);
    }
    ctu::TextConverter::~TextConverter((ctu::TextConverter *)v56);
    uint64_t v15 = 1;
    goto LABEL_106;
  }
  if (buf.__r_.__value_.__l.__size_ >= 8)
  {
    int v21 = (std::string *)buf.__r_.__value_.__r.__words[0];
    goto LABEL_34;
  }
  CFNumberRef v19 = *(NSObject **)(v2 + 40);
  uint64_t v15 = 0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    goto LABEL_31;
  }
LABEL_58:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete(__p[0]);
  }
  return v15;
}

void sub_100EA325C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23) {
    operator delete(a23);
  }
  if (*(char *)(v34 - 121) < 0) {
    operator delete(*(void **)(v34 - 144));
  }
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)&a27);
  if (*(char *)(v34 - 89) < 0) {
    operator delete(*(void **)(v34 - 112));
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t ImsSmsCommandDriver::ImsSmsCommandDriver(uint64_t a1)
{
  uint64_t v2 = (capabilities::ct *)CSISMSCommandDriver::CSISMSCommandDriver();
  v21[0] = off_101999E18;
  v21[1] = sub_100EA38D0;
  v21[3] = v21;
  *((void *)v2 + 11) = 0;
  if ((capabilities::ct::supportsGemini(v2) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 88)) {
    operator new();
  }
  sub_10008863C(v21);
  *(void *)a1 = off_101A66F60;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = a1 + 128;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 160) = 0;
  sub_100058DB0(&__p, "ImsSmsDriver");
  uint64_t v3 = *(NSObject **)(a1 + 24);
  dispatch_object_t v17 = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 184) = a1 + 192;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = a1 + 216;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  subscriber::makeSimSlotRange();
  std::string::size_type v6 = v22;
  uint64_t v5 = v23;
  if (v22 != v23)
  {
    int v7 = v24;
    while ((v7(*v6) & 1) == 0)
    {
      if (++v6 == v5)
      {
        std::string::size_type v6 = v5;
        break;
      }
    }
    uint64_t v8 = v23;
    while (v6 != v8)
    {
      int v15 = 0;
      int v15 = *v6;
      uint64_t v20 = &v15;
      *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 120), &v15, (uint64_t)&unk_10144E20E, &v20) + 32) = 0;
      unsigned int v9 = sub_100256E84((uint64_t **)(a1 + 144), v15, &v15);
      CFArrayRef v10 = (std::__shared_weak_count *)v9[6];
      void v9[5] = 0;
      void v9[6] = 0;
      if (v10) {
        sub_10004D2C8(v10);
      }
      uint64_t v11 = sub_100256E84((uint64_t **)(a1 + 96), v15, &v15);
      uint64_t v12 = (std::__shared_weak_count *)v11[6];
      void v11[5] = 0;
      v11[6] = 0;
      if (v12) {
        sub_10004D2C8(v12);
      }
      char v13 = v6 + 1;
      std::string::size_type v6 = v5;
      if (v13 != v5)
      {
        std::string::size_type v6 = v13;
        while ((v7(*v6) & 1) == 0)
        {
          if (++v6 == v5)
          {
            std::string::size_type v6 = v5;
            break;
          }
        }
      }
    }
  }
  return a1;
}

void sub_100EA3724(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

const char *sub_100EA38D0(int a1)
{
  uint64_t v1 = "msg.sms.ims?";
  if (a1 == 2) {
    uint64_t v1 = "msg.sms.ims.2";
  }
  if (a1 == 1) {
    return "msg.sms.ims.1";
  }
  else {
    return v1;
  }
}

void sub_100EA38FC(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/props/ims_registration_state");
  v7[0] = off_101A670D0;
  v7[1] = a1 + 208;
  void v7[2] = a1;
  uint64_t v8 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/ims_client_state");
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A67150;
  v2[1] = a1 + 184;
  void v2[2] = a1;
  v2[3] = sub_100EA3AA0;
  v2[4] = 0;
  uint64_t v8 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection(&v3, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100EA3A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EA3AA0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 184);
  uint64_t v3 = (void *)(a1 + 192);
  if (v2 != (void *)(a1 + 192))
  {
    char v6 = (void **)(a2 + 8);
    uint64_t v7 = a1 + 120;
    while (1)
    {
      unsigned int v27 = 0;
      unsigned int v27 = SlotIdFromPersonalityIdEx();
      if (!v27)
      {
        long long v18 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = *((unsigned __int8 *)v2 + 55);
          BOOL v20 = (v19 & 0x80u) != 0;
          if ((v19 & 0x80u) != 0) {
            uint64_t v19 = v2[5];
          }
          if (v20) {
            int v21 = (const char *)v2[4];
          }
          else {
            int v21 = (const char *)(v2 + 4);
          }
          BOOL v22 = v19 == 0;
          CFTypeID v23 = "<invalid>";
          if (!v22) {
            CFTypeID v23 = v21;
          }
          *(_DWORD *)std::string buf = 136315138;
          int v29 = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Unknown PersonalityID : %s !", buf, 0xCu);
        }
        goto LABEL_35;
      }
      uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
      unsigned int v9 = sub_100046F68(a2, (void **)v2 + 4);
      int v10 = *((unsigned __int8 *)v2 + 56);
      if (v6 != v9 && *((unsigned __int8 *)v9 + 56) == v10)
      {
        uint64_t v11 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = "ready";
          if (!v10) {
            uint64_t v12 = "not ready";
          }
          *(_DWORD *)std::string buf = 136315138;
          int v29 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I IMS client has not changed state from %s", buf, 0xCu);
        }
        goto LABEL_35;
      }
      char v13 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = "ready";
        if (!v10) {
          uint64_t v14 = "not ready";
        }
        *(_DWORD *)std::string buf = 136315138;
        int v29 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I IMS client is now %s", buf, 0xCu);
        int v10 = *((unsigned __int8 *)v2 + 56);
      }
      if (!v10) {
        goto LABEL_35;
      }
      if (*(unsigned char *)sub_10012EF5C(v7, (int *)&v27)) {
        break;
      }
LABEL_34:
      sub_100EA4D14(a1, v27);
LABEL_35:
      int v25 = (void *)v2[1];
      if (v25)
      {
        do
        {
          int v26 = v25;
          int v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          int v26 = (void *)v2[2];
          BOOL v22 = *v26 == (void)v2;
          uint64_t v2 = v26;
        }
        while (!v22);
      }
      uint64_t v2 = v26;
      if (v26 == v3) {
        return;
      }
    }
    *(unsigned char *)sub_10012EF5C(v7, (int *)&v27) = 0;
    int v15 = *(std::__shared_weak_count **)(a1 + 80);
    if (v15)
    {
      char v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = *(void *)(a1 + 72);
        if (v17)
        {
          (*(void (**)(uint64_t, void, void, uint64_t, void))(*(void *)v17 + 72))(v17, v27, 0, 1, 0);
LABEL_33:
          sub_10004D2C8(v16);
          goto LABEL_34;
        }
      }
    }
    else
    {
      char v16 = 0;
    }
    unint64_t v24 = *v8;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", buf, 2u);
    }
    if (!v16) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
}

void sub_100EA3DF4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EA3E10(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 168));
}

void sub_100EA3E1C(uint64_t a1)
{
  *(void *)a1 = off_101A66F60;
  uint64_t v2 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_10005CD2C(a1 + 208, *(char **)(a1 + 216));
  sub_10005CD2C(a1 + 184, *(char **)(a1 + 192));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 176);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100119D90(*(void **)(a1 + 152));
  sub_1000346F8(a1 + 120, *(void **)(a1 + 128));
  sub_100119D90(*(void **)(a1 + 104));
  uint64_t v5 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }

  CSISMSCommandDriver::~CSISMSCommandDriver((CSISMSCommandDriver *)a1);
}

void sub_100EA3F40(uint64_t a1)
{
  sub_100EA3E1C(a1);

  operator delete();
}

void ImsSmsCommandDriver::create()
{
}

void sub_100EA4010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  if (v10) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100EA4044(uint64_t a1, int a2)
{
  int v8 = a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v4 = sub_100EA40DC((uint64_t)&v6, a2);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return v4 && *(unsigned char *)sub_10012EF5C(a1 + 120, &v8) != 0;
}

void sub_100EA40C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EA40DC(uint64_t a1, int a2)
{
  subscriber::makeSimSlotRange();
  uint64_t v3 = v8;
  if (v8 == v9) {
    goto LABEL_14;
  }
  while ((v10(*v3) & 1) == 0)
  {
    if (++v3 == v9)
    {
      uint64_t v3 = v9;
      break;
    }
  }
  if (v3 == v9)
  {
LABEL_14:
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = v3 + 1;
      BOOL v6 = *v3 == a2;
      uint64_t v3 = v9;
      if (v5 != v9)
      {
        uint64_t v3 = v5;
        while ((v10(*v3) & 1) == 0)
        {
          if (++v3 == v9)
          {
            uint64_t v3 = v9;
            break;
          }
        }
      }
      v4 |= v6;
    }
    while (v3 != v9);
  }
  return v4 & 1;
}

void sub_100EA41BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sms Timer (TR1M) expired", (uint8_t *)&buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 232);
  *(void *)(v2 + 232) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  size_t v44 = 0;
  uint64_t v45 = 0;
  long long buf = 0uLL;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5 {
    && (BOOL v6 = std::__shared_weak_count::lock(v5), (*((void *)&buf + 1) = v6) != 0)
  }
    && (v7 = v6, (int v8 = *(const void **)(a1 + 40)) != 0)
  {
    size_t v44 = v9;
    uint64_t v45 = v7;
    p_long long buf = (void **)&buf;
  }
  else
  {
    p_long long buf = (void **)&v44;
  }
  *p_long long buf = 0;
  p_buf[1] = 0;
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  uint64_t v11 = (uint64_t)v44;
  if (!v44) {
    goto LABEL_55;
  }
  unsigned int v47 = *(_DWORD *)(a1 + 56);
  uint64_t v12 = v47;
  long long v46 = xmmword_101586790;
  char v13 = (os_log_t *)(*(uint64_t (**)(void *, void))(*v44[11] + 16))(v44[11], v47);
  if (!sub_100256E84((uint64_t **)(v11 + 144), v12, &v47)[5])
  {
    unsigned int v27 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I No pending actions", (uint8_t *)&buf, 2u);
    }
    goto LABEL_55;
  }
  uint64_t v14 = sub_100256E84((uint64_t **)(v11 + 144), v12, &v47);
  if (*((unsigned char *)v14[5] + 44))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*((unsigned __int8 *)v14[5] + 44), *(Registry **)(v11 + 56));
    char v16 = ServiceMap;
    if (v17 < 0)
    {
      long long v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v17;
    int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      BOOL v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        if (!v23)
        {
LABEL_22:
          int v25 = *(NSObject **)(v11 + 40);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to get CarrierSettingsInterface", (uint8_t *)&buf, 2u);
          }
          BOOL v26 = 1;
LABEL_44:
          if ((v24 & 1) == 0) {
            sub_10004D2C8(v22);
          }
          BYTE8(v46) = v26;
          int v29 = *v13;
          if (!os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR)) {
            goto LABEL_47;
          }
          unsigned int v43 = "false";
          if (v26) {
            unsigned int v43 = "true";
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v43;
          long long v31 = "SMS was sent. TR1M expiry error [Fatal: %s]";
          goto LABEL_63;
        }
LABEL_33:
        long long v32 = operator new(0x20uLL);
        *((void *)&buf + 1) = v32 + 2;
        uint64_t v52 = v32 + 2;
        *long long v32 = *(_OWORD *)off_1019C4410;
        v32[1] = *(_OWORD *)off_1019C4420;
        *(void *)&long long buf = v32;
        long long v48 = 0;
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, long long *, void, void))(*(void *)v23 + 104))(v49, v23, v12, 1, &buf, 0, 0);
        sub_1000057AC(&v48, (CFTypeRef *)v49);
        sub_1000577C4((const void **)v49);
        if (v48) {
          long long v33 = sub_100084B4C;
        }
        else {
          long long v33 = 0;
        }
        if (v33)
        {
          uint64_t v34 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 88) + 16))(*(void *)(v11 + 88), v12);
          v49[0] = 1;
          ctu::cf::assign((ctu::cf *)v49, v48, v35);
          int v36 = v49[0];
          BOOL v26 = v49[0] != 0;
          std::string::size_type v37 = *v34;
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v38 = "false";
            if (v36) {
              unint64_t v38 = "true";
            }
            *(_DWORD *)uint64_t v49 = 136315138;
            uint64_t v50 = v38;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Carrier preference: shouldConsiderAcceptedSmsAsFatal: %s", v49, 0xCu);
          }
        }
        else
        {
          BOOL v26 = 1;
        }
        sub_100062778((const void **)&v48);
        if ((void)buf)
        {
          *((void *)&buf + 1) = buf;
          operator delete((void *)buf);
        }
        goto LABEL_44;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    BOOL v22 = 0;
    char v24 = 1;
    if (!v23) {
      goto LABEL_22;
    }
    goto LABEL_33;
  }
  BOOL v28 = sub_100EA49E8(v11, v12);
  BYTE8(v46) = v28;
  int v29 = *v13;
  if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v30 = "false";
    if (v28) {
      uint64_t v30 = "true";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v30;
    long long v31 = "SMS was not sent. TR1M expiry error [Fatal: %s]";
LABEL_63:
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v31, (uint8_t *)&buf, 0xCu);
  }
LABEL_47:
  unint64_t v39 = *(std::__shared_weak_count **)(v11 + 80);
  if (v39)
  {
    unint64_t v40 = std::__shared_weak_count::lock(v39);
    if (v40)
    {
      uint64_t v41 = *(void *)(v11 + 72);
      if (v41)
      {
        (*(void (**)(uint64_t, void, long long *))(*(void *)v41 + 48))(v41, v47, &v46);
        goto LABEL_54;
      }
    }
  }
  else
  {
    unint64_t v40 = 0;
  }
  size_t v42 = *v13;
  if (!os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
  {
    if (!v40) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }
  LOWORD(buf) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to get SMS controller interface during TR1M expiry handling", (uint8_t *)&buf, 2u);
  if (v40) {
LABEL_54:
  }
    sub_10004D2C8(v40);
LABEL_55:
  if (v45) {
    sub_10004D2C8(v45);
  }
}

void sub_100EA47BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21)
{
  sub_10004D2C8(v21);
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EA483C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EA4858(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100EA4868(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 232);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    uint64_t v3 = *(void *)(a1 + 232);
    *(void *)(a1 + 232) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sms Timer (TR1M) destroyed", v5, 2u);
    }
  }
}

void sub_100EA4928(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    uint64_t v3 = *(void *)(a1 + 240);
    *(void *)(a1 + 240) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sms Timer (SmsRetransmission) destroyed", v5, 2u);
    }
  }
}

BOOL sub_100EA49E8(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  long long __p = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12)
  {
LABEL_7:
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get CarrierSettingsInterface", (uint8_t *)&__p, 2u);
    }
    BOOL v15 = 0;
    goto LABEL_23;
  }
LABEL_12:
  char v16 = operator new(0x20uLL);
  BOOL v26 = v16 + 2;
  unsigned int v27 = v16 + 2;
  *char v16 = *(_OWORD *)off_1019C43F0;
  v16[1] = *(_OWORD *)off_1019C4400;
  char v24 = 0;
  long long __p = v16;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v12 + 104))(buf, v12, a2, 1, &__p, 0, 0);
  sub_1000057AC(&v24, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v24) {
    uint64_t v17 = sub_100084B4C;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17)
  {
    long long v18 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, v24, v19);
    int v20 = buf[0];
    BOOL v15 = buf[0] != 0;
    int v21 = *v18;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v22 = "false";
      if (v20) {
        BOOL v22 = "true";
      }
      *(_DWORD *)long long buf = 136315138;
      int v29 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Carrier preference: shouldConsiderNonAcceptedSmsAsFatal: %s", buf, 0xCu);
    }
  }
  else
  {
    BOOL v15 = 0;
  }
  sub_100062778((const void **)&v24);
  if (__p)
  {
    BOOL v26 = __p;
    operator delete(__p);
  }
LABEL_23:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return v15;
}

void sub_100EA4CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15)
{
  sub_1000577C4(&a15);
  if (__p) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

void sub_100EA4D14(uint64_t a1, uint64_t a2)
{
  int v31 = a2;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v29 = *(void *)(a1 + 56);
  uint64_t v30 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v5 = sub_100EA40DC((uint64_t)&v29, a2);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (v5)
  {
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v28 = 0;
    PersonalityIdFromSlotId();
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v7 || (v8 = *(std::__shared_weak_count_vtbl **)(a1 + 8), (unsigned int v9 = std::__shared_weak_count::lock(v7)) == 0)) {
      sub_100088B9C();
    }
    int v10 = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a2);
    uint64_t v13 = *(void *)(a1 + 56);
    uint64_t v12 = *(std::__shared_weak_count **)(a1 + 64);
    uint64_t v14 = (std::__shared_weak_count *)operator new(0x60uLL);
    BOOL v15 = v14;
    v14->__shared_owners_ = 0;
    v14->__shared_weak_owners_ = 0;
    v14->__vftable = (std::__shared_weak_count_vtbl *)off_101A67230;
    char v16 = (uint64_t *)&v14[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    p_uint64_t shared_weak_owners = &v10->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v14[1].__shared_owners_ = 0;
    v14[1].__shared_weak_owners_ = 0;
    v14[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A43870;
    LODWORD(v14[2].__vftable) = a2;
    v14[2].__shared_owners_ = v13;
    v14[2].__shared_weak_owners_ = (uint64_t)v12;
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v14[3].__vftable = v8;
      v14[3].__shared_owners_ = (uint64_t)v10;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      v14[3].__shared_weak_owners_ = v11;
      std::__shared_weak_count::__release_weak(v10);
      sub_10004D2C8(v12);
    }
    else
    {
      v14[3].__vftable = v8;
      v14[3].__shared_owners_ = (uint64_t)v10;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      v14[3].__shared_weak_owners_ = v11;
      std::__shared_weak_count::__release_weak(v10);
    }
    uint64_t shared_weak_owners = (std::__shared_weak_count *)v15[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_20:
        int v20 = (uint64_t **)(a1 + 96);
        int v21 = sub_100256E84(v20, a2, &v31);
        BOOL v22 = (std::__shared_weak_count *)v21[6];
        v21[5] = v16;
        v21[6] = (uint64_t *)v15;
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (sub_100256E84(v20, a2, &v31)[5])
        {
          uint64_t v23 = sub_100256E84(v20, a2, &v31);
          ImsSmsCommandDriverDelegate::setMessageDelegate((ImsSmsCommandDriverDelegate *)v23[5]);
          char v24 = *v6;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            int v25 = sub_100256E84(v20, a2, &v31)[5];
            *(_DWORD *)long long buf = 134217984;
            long long v33 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Sms IMS client created : %p ", buf, 0xCu);
          }
        }
        else
        {
          BOOL v26 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Unable to create SMS command driver delegate", buf, 2u);
          }
        }
        std::__shared_weak_count::__release_weak(v10);
        if (SHIBYTE(v28) < 0) {
          operator delete(__p[0]);
        }
        return;
      }
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v15[1].__shared_owners_ = (uint64_t)v16;
      v15[1].__shared_weak_owners_ = (uint64_t)v15;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
    }
    else
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v15[1].__shared_owners_ = (uint64_t)v16;
      v15[1].__shared_weak_owners_ = (uint64_t)v15;
    }
    sub_10004D2C8(v15);
    goto LABEL_20;
  }
  long long v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid slot for create IMS client", (uint8_t *)__p, 2u);
  }
}

void sub_100EA50D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  std::__shared_weak_count::__release_weak(v16);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100EA5138(uint64_t a1, uint64_t a2)
{
  void (***v14)(uint64_t *__return_ptr, void, uint64_t);
  std::__shared_weak_count *v15;
  char v16;
  int v17;
  std::__shared_weak_count *v18;
  char v19;
  os_log_t *v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v24;
  os_log_t v25;
  NSObject *v26;
  const char *v27;
  uint32_t v28;
  os_log_t v29;
  const char *v30;
  const char *v31;
  int v32;
  os_log_t v33;
  const char *v34;
  const char *v35;
  int v36;
  NSObject *v37;
  const char *v38;
  const char *v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  NSObject *v45;
  uint64_t *v46;
  BOOL v47;
  void **v48;
  uint64_t v50;
  std::__shared_weak_count *v51;
  unsigned int v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  unsigned char buf[12];
  __int16 v56;
  const char *v57;

  uint64_t v2 = *(uint64_t **)(a1 + 208);
  uint64_t v3 = (uint64_t *)(a1 + 216);
  if (v2 != (uint64_t *)(a1 + 216))
  {
    long long v48 = (void **)(a2 + 8);
    uint64_t v5 = a1 + 120;
    uint64_t v6 = (uint64_t *)&byte_10144BF80[128];
    do
    {
      CFDictionaryRef v53 = 0;
      CFTypeID v54 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 56));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v9;
      uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
      if (v13)
      {
        uint64_t v14 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v13[3];
        BOOL v15 = (std::__shared_weak_count *)v13[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v16 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      std::mutex::unlock(v8);
      BOOL v15 = 0;
      char v16 = 1;
LABEL_11:
      (**v14)(&v53, v14, (uint64_t)(v2 + 4));
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      if (!v53) {
        goto LABEL_75;
      }
      if (*(unsigned char *)(v53 + 49)) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = *(_DWORD *)(v53 + 52);
      }
      uint64_t v52 = v17;
      long long v18 = *(std::__shared_weak_count **)(a1 + 64);
      uint64_t v50 = *(void *)(a1 + 56);
      uint64_t v51 = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      CFBooleanRef v19 = sub_100EA40DC((uint64_t)&v50, v17);
      if (v51) {
        sub_10004D2C8(v51);
      }
      if ((v19 & 1) == 0) {
        goto LABEL_75;
      }
      int v20 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), v52);
      if (v48 == sub_100046F68(a2, (void **)v2 + 4))
      {
        int v25 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          BOOL v26 = v25;
          unsigned int v27 = "#I IMS registration status changed: New info added";
          uint64_t v28 = 2;
          goto LABEL_52;
        }
LABEL_53:
        if (*((_DWORD *)v2 + 14) == 1) {
          int v36 = (*((unsigned __int8 *)v2 + 60) >> 1) & 1;
        }
        else {
          LOBYTE(v36) = 0;
        }
        *(unsigned char *)sub_10012EF5C(v5, (int *)&v52) = v36;
        std::string::size_type v37 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
        {
          if (*(unsigned char *)sub_10012EF5C(v5, (int *)&v52)) {
            unint64_t v38 = "true";
          }
          else {
            unint64_t v38 = "false";
          }
          if (*((unsigned char *)v2 + 64)) {
            unint64_t v39 = "true";
          }
          else {
            unint64_t v39 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v38;
          long long v56 = 2080;
          long long v57 = v39;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I IMS registered : %s , Over Wifi : %s", buf, 0x16u);
        }
        if (*(unsigned char *)sub_10012EF5C(v5, (int *)&v52)) {
          sub_100EA4D14(a1, v52);
        }
        unint64_t v40 = *(std::__shared_weak_count **)(a1 + 80);
        if (v40)
        {
          uint64_t v41 = std::__shared_weak_count::lock(v40);
          if (v41)
          {
            size_t v42 = *(void *)(a1 + 72);
            if (v42)
            {
              unsigned int v43 = v52;
              size_t v44 = sub_10012EF5C(v5, (int *)&v52);
              (*(void (**)(uint64_t, uint64_t, void, uint64_t, void))(*(void *)v42 + 72))(v42, v43, *(unsigned __int8 *)v44, 1, *((unsigned __int8 *)v2 + 64));
LABEL_74:
              sub_10004D2C8(v41);
              goto LABEL_75;
            }
          }
        }
        else
        {
          uint64_t v41 = 0;
        }
        uint64_t v45 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", buf, 2u);
        }
        if (!v41) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }
      *(void *)long long buf = 0;
      int v21 = *sub_100046ED4(a2, buf, (void **)v2 + 4);
      if (!v21) {
        sub_1000C14F0("map::at:  key not found");
      }
      BOOL v22 = *(unsigned __int8 *)(v21 + 64);
      if (*(_DWORD *)(v21 + 56) == 1)
      {
        uint64_t v23 = *(_DWORD *)(v21 + 60);
        char v24 = *((_DWORD *)v2 + 14);
        if (v24 == 1)
        {
          if (((v23 >> 1) & 1) != (*((unsigned char *)v2 + 60) & 2) >> 1) {
            goto LABEL_35;
          }
        }
        else if ((v23 & 2) != 0)
        {
LABEL_35:
          uint64_t v29 = *v20;
          if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_53;
          }
          uint64_t v30 = "true";
          if ((v23 & 2) == 0) {
            uint64_t v30 = "false";
          }
          int v31 = "false";
          if (v24 == 1)
          {
LABEL_39:
            int v31 = "true";
            if ((*((_DWORD *)v2 + 15) & 2) == 0) {
              int v31 = "false";
            }
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v30;
          long long v56 = 2080;
          long long v57 = v31;
          BOOL v26 = v29;
          unsigned int v27 = "#I IMS registration status changed: From %s to %s";
LABEL_51:
          uint64_t v28 = 22;
LABEL_52:
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, v28);
          goto LABEL_53;
        }
      }
      else if (*((_DWORD *)v2 + 14) == 1 && (*((unsigned char *)v2 + 60) & 2) != 0)
      {
        uint64_t v29 = *v20;
        if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_53;
        }
        uint64_t v30 = "false";
        goto LABEL_39;
      }
      long long v32 = *((unsigned __int8 *)v2 + 64);
      if (v32 != v22)
      {
        long long v33 = *v20;
        if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_53;
        }
        if (v22) {
          uint64_t v34 = "WLAN";
        }
        else {
          uint64_t v34 = "Baseband";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v34;
        if (v32) {
          CFBooleanRef v35 = "WLAN";
        }
        else {
          CFBooleanRef v35 = "Baseband";
        }
        long long v56 = 2080;
        long long v57 = v35;
        BOOL v26 = v33;
        unsigned int v27 = "#I IMS transport changed: From %s to %s";
        goto LABEL_51;
      }
LABEL_75:
      if (v54) {
        sub_10004D2C8(v54);
      }
      long long v46 = (uint64_t *)v2[1];
      if (v46)
      {
        do
        {
          uint64_t v6 = v46;
          long long v46 = (uint64_t *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          uint64_t v6 = (uint64_t *)v2[2];
          unsigned int v47 = *v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v47);
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
  }
}

void sub_100EA56F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  sub_10004D2C8(v18);
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

void ImsSmsCommandDriver::handleMessageSendFailure(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v6, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a3 + 8);
    void v6[2] = *(void **)(a3 + 24);
  }
  __int16 v7 = *(_WORD *)(a3 + 32);
  if (*(char *)(a3 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(a3 + 40), *(void *)(a3 + 48));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a3 + 40);
    __p[2] = *(void **)(a3 + 56);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EA5980(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 47) < 0) {
    operator delete(*v18);
  }
  sub_10006A6AC(a1);
}

void ImsSmsCommandDriver::handleMessageSendSuccess(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EA5AB4(uint64_t a1, int a2)
{
  int v6 = a2;
  sub_100EA4868(a1);
  sub_100EA4928(a1);
  uint64_t v4 = sub_100256E84((uint64_t **)(a1 + 144), a2, &v6);
  uint64_t v5 = (std::__shared_weak_count *)v4[6];
  void v4[5] = 0;
  v4[6] = 0;
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_100EA5B30(uint64_t a1, uint64_t **a2)
{
  unsigned int v52 = *((_DWORD *)*a2 + 2);
  uint64_t v4 = v52;
  uint64_t v5 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), v52);
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  (*(void (**)(void **__return_ptr))(**a2 + 168))(&v49);
  int v6 = *a2;
  int v7 = *((_DWORD *)*a2 + 12);
  if (v7 == 2)
  {
    int v9 = *((_DWORD *)v6 + 2);
    if (*((char *)v6 + 135) < 0)
    {
      sub_10004FC84(buf, (void *)v6[14], v6[15]);
      int v6 = *a2;
    }
    else
    {
      *(_OWORD *)long long buf = *((_OWORD *)v6 + 7);
      CFTypeID v54 = (void (*)(uint64_t))v6[16];
    }
    long long __p = 0;
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    int v26 = sub_100EA6404(a1, v9, 2, (uint64_t)&v49, (uint64_t)buf, (uint64_t)&__p, *((unsigned __int8 *)v6 + 149));
    if (SHIBYTE(v64) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v54) < 0)
    {
      operator delete(*(void **)buf);
      if (!v26) {
        goto LABEL_30;
      }
    }
    else if (!v26)
    {
      goto LABEL_30;
    }
LABEL_12:
    uint64_t v11 = sub_100256E84((uint64_t **)(a1 + 144), v4, &v52);
    uint64_t v13 = *a2;
    unsigned int v12 = a2[1];
    if (v12) {
      atomic_fetch_add_explicit(v12 + 1, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = (std::__shared_weak_count *)v11[6];
    void v11[5] = v13;
    v11[6] = v12;
    if (v14) {
      sub_10004D2C8(v14);
    }
    BOOL v15 = *v5;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Sms segment sent", buf, 2u);
    }
    uint64_t v67 = 0;
    long long v68 = 0;
    Registry::getTimerService(&v67, *(Registry **)(a1 + 56));
    if (!v67)
    {
      long long v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Failed to get timer interface.", buf, 2u);
      }
LABEL_79:
      long long v32 = v68;
      if (!v68) {
        goto LABEL_81;
      }
      goto LABEL_80;
    }
    int valuePtr = 130;
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x82, *(Registry **)(a1 + 56));
    uint64_t v17 = ServiceMap;
    if (v18 < 0)
    {
      CFBooleanRef v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v18;
    BOOL v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
    if (v22)
    {
      uint64_t v24 = v22[3];
      uint64_t v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v25 = 0;
LABEL_49:
        CFNumberRef v65 = 0;
        uint64_t v34 = operator new(0x20uLL);
        *(void *)&uint8_t buf[8] = v34 + 2;
        CFTypeID v54 = (void (*)(uint64_t))(v34 + 2);
        _OWORD *v34 = *(_OWORD *)off_1019C43D0;
        v34[1] = *(_OWORD *)off_1019C43E0;
        *(void *)long long buf = v34;
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, uint8_t *, void, void))(*(void *)v24 + 104))(&__p, v24, v4, 1, buf, 0, 0);
        sub_1000842D0(&v65, (CFTypeRef *)&__p);
        sub_1000577C4((const void **)&__p);
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        if (v65) {
          CFBooleanRef v35 = sub_100081E58;
        }
        else {
          CFBooleanRef v35 = 0;
        }
        if (v35) {
          CFNumberGetValue(v65, kCFNumberIntType, &valuePtr);
        }
        uint64_t v36 = *(void *)(a1 + 232);
        if (v36 && ((*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36) & 1) == 0)
        {
          long long v48 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Sms Timer (TR1M) active.", buf, 2u);
          }
        }
        else
        {
          std::string::size_type v37 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v37 || (uint64_t v38 = *(void *)(a1 + 8), (v39 = std::__shared_weak_count::lock(v37)) == 0)) {
            sub_100088B9C();
          }
          unint64_t v40 = v39;
          atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v39);
          uint64_t v41 = v67;
          sub_100058DB0(&__p, "TR1M timer");
          unsigned int v42 = valuePtr;
          unsigned int v43 = *(NSObject **)(a1 + 24);
          dispatch_object_t object = v43;
          if (v43) {
            dispatch_retain(v43);
          }
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          CFTypeID v54 = sub_100EA41BC;
          uint64_t v55 = &unk_101A67008;
          uint64_t v56 = a1;
          uint64_t v57 = v38;
          long long v58 = v40;
          atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          int v59 = v4;
          aBlock = _Block_copy(buf);
          sub_100118A44(v41, (uint64_t)&__p, 2, 1000000 * v42, &object, &aBlock);
          uint64_t v44 = *(void *)v69;
          *(void *)long long v69 = 0;
          uint64_t v45 = *(void *)(a1 + 232);
          *(void *)(a1 + 232) = v44;
          if (v45)
          {
            (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
            uint64_t v46 = *(void *)v69;
            *(void *)long long v69 = 0;
            if (v46) {
              (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
            }
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (object) {
            dispatch_release(object);
          }
          if (SHIBYTE(v64) < 0) {
            operator delete(__p);
          }
          if (*(void *)(a1 + 232))
          {
            unsigned int v47 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long v69 = 67109120;
              *(_DWORD *)&v69[4] = valuePtr;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Sms Timer (TR1M) started: %u sec", v69, 8u);
            }
          }
          if (v58) {
            std::__shared_weak_count::__release_weak(v58);
          }
          std::__shared_weak_count::__release_weak(v40);
        }
        sub_1000570E8((const void **)&v65);
        if ((v25 & 1) == 0) {
          sub_10004D2C8(v23);
        }
        goto LABEL_79;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    uint64_t v23 = 0;
    char v25 = 1;
    goto LABEL_49;
  }
  if (v7 != 1) {
    goto LABEL_30;
  }
  int v8 = *((_DWORD *)v6 + 2);
  if (*((char *)v6 + 135) < 0)
  {
    sub_10004FC84(buf, (void *)v6[14], v6[15]);
    int v6 = *a2;
  }
  else
  {
    *(_OWORD *)long long buf = *((_OWORD *)v6 + 7);
    CFTypeID v54 = (void (*)(uint64_t))v6[16];
  }
  long long __p = 0;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  char v10 = sub_100EA6404(a1, v8, 1, (uint64_t)&v49, (uint64_t)buf, (uint64_t)&__p, *((unsigned __int8 *)v6 + 149));
  if (SHIBYTE(v64) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v54) < 0)
  {
    operator delete(*(void **)buf);
    if ((v10 & 1) == 0) {
      goto LABEL_30;
    }
    goto LABEL_12;
  }
  if (v10) {
    goto LABEL_12;
  }
LABEL_30:
  unsigned int v27 = *v5;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Sms segment not sent", buf, 2u);
  }
  *(_OWORD *)long long buf = xmmword_1015867A0;
  uint64_t v28 = *(std::__shared_weak_count **)(a1 + 80);
  if (v28)
  {
    uint64_t v29 = std::__shared_weak_count::lock(v28);
    if (v29)
    {
      uint64_t v30 = *(void *)(a1 + 72);
      if (v30)
      {
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v30 + 48))(v30, v4, buf);
LABEL_40:
        long long v32 = v29;
LABEL_80:
        sub_10004D2C8(v32);
        goto LABEL_81;
      }
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  int v31 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", (uint8_t *)&__p, 2u);
  }
  if (v29) {
    goto LABEL_40;
  }
LABEL_81:
  if (v49)
  {
    uint64_t v50 = v49;
    operator delete(v49);
  }
}

void sub_100EA62D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,void *aBlock,dispatch_object_t object,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EA6404(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v35 = a2;
  memset(&__p, 0, sizeof(__p));
  uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  BOOL v15 = v14;
  if (a3 == 1)
  {
    char v16 = "application/vnd.3gpp.sms";
    size_t v17 = 24;
  }
  else
  {
    if (a3 != 2)
    {
      os_log_t v28 = *v14;
      if (!os_log_type_enabled(*v14, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v37) = a3;
      uint64_t v29 = "Failed to send SMS - Unknown content type: %d ";
      uint64_t v30 = v28;
      uint32_t v31 = 8;
LABEL_29:
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      goto LABEL_24;
    }
    char v16 = "application/vnd.3gpp2.sms";
    size_t v17 = 25;
  }
  sub_10003ECB8(&__p, v16, v17);
  if (*(char *)(a5 + 23) >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    uint64_t v18 = *(void *)(a5 + 8);
  }
  CFBooleanRef v19 = *v15;
  BOOL v20 = os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT);
  if (!v18)
  {
    if (v20)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Failed to send SMS - Destination not set", buf, 2u);
    }
    goto LABEL_24;
  }
  if (v20)
  {
    uint64_t v21 = sms::asString();
    if (*(char *)(a5 + 23) >= 0) {
      uint64_t v22 = a5;
    }
    else {
      uint64_t v22 = *(void *)a5;
    }
    if (*(char *)(a6 + 23) >= 0) {
      uint64_t v23 = a6;
    }
    else {
      uint64_t v23 = *(void *)a6;
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v37 = v21;
    __int16 v38 = 2080;
    uint64_t v39 = v22;
    __int16 v40 = 2080;
    uint64_t v41 = v23;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Sending SMS start - content type: %s, destination: %s, inReplyTo: %s", buf, 0x20u);
  }
  uint64_t v24 = (uint64_t **)(a1 + 96);
  if (sub_100256E84(v24, a2, &v35)[5])
  {
    char v25 = sub_100256E84(v24, a2, &v35);
    ImsSmsCommandDriverDelegate::sendSms((uint64_t)v25[5], a5, a6, a4, (uint64_t)&__p, a7, v26);
    uint64_t v27 = 1;
    goto LABEL_25;
  }
  os_log_t v32 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v29 = "Invalid delegate while sending SMS";
    uint64_t v30 = v32;
    uint32_t v31 = 2;
    goto LABEL_29;
  }
LABEL_24:
  uint64_t v27 = 0;
LABEL_25:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v27;
}

void sub_100EA66B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ImsSmsCommandDriver::handleMessageReceived(uint64_t a1, uint64_t a2, long long *a3)
{
  sub_100BAD4EC((char *)&v5, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100EA6854(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  CFStringRef v19 = CFStringCreateWithCString(kCFAllocatorDefault, "IMSConfig", 0x8000100u);
  CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, "SMS", 0x8000100u);
  if (*(char *)(a4 + 23) >= 0) {
    int v9 = (const char *)a4;
  }
  else {
    int v9 = *(const char **)a4;
  }
  CFStringRef v10 = CFStringCreateWithCString(kCFAllocatorDefault, v9, 0x8000100u);
  CFStringRef v17 = v10;
  CFStringRef v11 = v18;
  unsigned int v12 = operator new(0x18uLL);
  BOOL v15 = v12 + 3;
  char v16 = v12 + 3;
  *unsigned int v12 = v19;
  v12[1] = v11;
  CFTypeRef v12[2] = v10;
  std::string __p = v12;
  (*(void (**)(void, uint64_t, uint64_t, void **, void, uint64_t))(*(void *)*a3 + 104))(*a3, a2, 1, &__p, *a5, 1);
  if (__p)
  {
    BOOL v15 = __p;
    operator delete(__p);
  }
  sub_1000558F4((const void **)&v17);
  sub_1000558F4((const void **)&v18);
  return sub_1000558F4((const void **)&v19);
}

void sub_100EA6998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, const void *a12, const void *a13, const void *a14)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1000558F4(&a12);
  sub_1000558F4(&a13);
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_100EA69E4(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_100EA6A50()
{
  return 0;
}

uint64_t sub_100EA6A58()
{
  return 0;
}

uint64_t sub_100EA6A60()
{
  return 0;
}

uint64_t sub_100EA6A68(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100EA6AC0()
{
}

uint64_t sub_100EA6AD4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100EA6AE4()
{
}

__n128 sub_100EA6AF8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A670D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EA6B44(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A670D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EA6B74(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v22 = (char **)*v3;
  uint64_t v23 = (char *)v5;
  uint64_t v24 = (char *)v3[2];
  if (v24)
  {
    *(void *)(v5 + 16) = &v23;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v22 = &v23;
  }
  sub_1002430C8((uint64_t)v3, a2);
  int v6 = v22;
  BOOL v20 = v22;
  v21[0] = v23;
  v21[1] = v24;
  if (v24)
  {
    *((void *)v23 + 2) = v21;
    uint64_t v22 = &v23;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v7 = *(void *)(a1 + 16);
    int v26 = 0;
    uint64_t v27 = 0;
    char v25 = &v26;
    if (v6 != v21)
    {
      do
      {
        uint32_t v31 = 0;
        int v8 = v26;
        if (v25 == &v26)
        {
          CFStringRef v10 = &v26;
          if (!v26) {
            goto LABEL_18;
          }
        }
        else
        {
          int v9 = &v26;
          if (v26)
          {
            do
            {
              CFStringRef v10 = (uint64_t **)v8;
              int v8 = (uint64_t *)v8[1];
            }
            while (v8);
          }
          else
          {
            do
            {
              CFStringRef v10 = (uint64_t **)v9[2];
              BOOL v11 = *v10 == (uint64_t *)v9;
              int v9 = v10;
            }
            while (v11);
          }
          if ((sub_100046FE8(v10 + 4, (void **)v6 + 4) & 0x80) == 0)
          {
            unsigned int v12 = (uint64_t **)sub_100046ED4((uint64_t)&v25, &v31, (void **)v6 + 4);
            goto LABEL_15;
          }
          if (!v26)
          {
LABEL_18:
            uint32_t v31 = &v26;
            unsigned int v12 = &v26;
LABEL_19:
            uint64_t v30 = 0;
            uint64_t v13 = (char *)operator new(0x50uLL);
            os_log_t v28 = v13;
            uint64_t v29 = &v26;
            uint64_t v14 = v13 + 32;
            if (*((char *)v6 + 55) < 0)
            {
              sub_10004FC84(v14, v6[4], (unint64_t)v6[5]);
            }
            else
            {
              long long v15 = *((_OWORD *)v6 + 2);
              *((void *)v13 + 6) = v6[6];
              *(_OWORD *)uint64_t v14 = v15;
            }
            long long v16 = *(_OWORD *)(v6 + 7);
            *((_DWORD *)v13 + 18) = *((_DWORD *)v6 + 18);
            *(_OWORD *)(v13 + 56) = v16;
            CFStringRef v17 = v31;
            *(void *)uint64_t v13 = 0;
            *((void *)v13 + 1) = 0;
            *((void *)v13 + 2) = v17;
            *unsigned int v12 = (uint64_t *)v13;
            if (*v25)
            {
              char v25 = (uint64_t **)*v25;
              uint64_t v13 = (char *)*v12;
            }
            sub_100046C90(v26, (uint64_t *)v13);
            ++v27;
            goto LABEL_25;
          }
        }
        uint32_t v31 = v10;
        unsigned int v12 = v10 + 1;
LABEL_15:
        if (!*v12) {
          goto LABEL_19;
        }
LABEL_25:
        CFStringRef v18 = v6[1];
        if (v18)
        {
          do
          {
            CFStringRef v19 = (char **)v18;
            CFStringRef v18 = *(char **)v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            CFStringRef v19 = (char **)v6[2];
            BOOL v11 = *v19 == (char *)v6;
            int v6 = v19;
          }
          while (!v11);
        }
        int v6 = v19;
      }
      while (v19 != v21);
    }
  }
  else
  {
    BOOL v20 = v21;
    uint64_t v7 = *(void *)(a1 + 16);
    int v26 = 0;
    uint64_t v27 = 0;
    char v25 = &v26;
  }
  sub_100EA5138(v7, (uint64_t)&v25);
  sub_10005CD2C((uint64_t)&v25, (char *)v26);
  sub_10005CD2C((uint64_t)&v20, v21[0]);
  sub_10005CD2C((uint64_t)&v22, v23);
}

void sub_100EA6DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11, uint64_t a12, char a13, char *a14, uint64_t a15, char a16, char *a17)
{
}

uint64_t sub_100EA6E34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA6E74()
{
}

void sub_100EA6E84()
{
}

__n128 sub_100EA6E98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A67150;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100EA6EEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A67150;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EA6F24(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  int v9 = (char **)*v3;
  CFStringRef v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_100256368((uint64_t)v3, a2);
  int v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100EA6FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100EA6FFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA703C()
{
}

void sub_100EA7048(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EA7114(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100EA71EC);
  __cxa_rethrow();
}

void sub_100EA713C(_Unwind_Exception *a1)
{
}

void sub_100EA7154(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EA718C(uint64_t a1)
{
}

uint64_t sub_100EA71A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EA71EC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_100EA7218(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A67230;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EA7238(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A67230;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EA728C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t *sub_100EA72B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = (unsigned int *)(v1 + 8);
  uint64_t v3 = *(void *)v1;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 88) + 16))(*(void *)(*(void *)v1 + 88), *(unsigned int *)(v1 + 8));
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(v1 + 16);
    if (*(unsigned char *)(v1 + 21)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    *(_DWORD *)long long buf = 67109378;
    int v19 = v6;
    *(_WORD *)BOOL v20 = 2080;
    *(void *)&v20[2] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I SMS Send failure [SIP error: %u, fatal: %s]", buf, 0x12u);
  }
  int v8 = *(std::__shared_weak_count **)(v3 + 80);
  if (v8)
  {
    int v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      CFStringRef v10 = v9;
      uint64_t v11 = *(void *)(v3 + 72);
      if (v11)
      {
        unsigned __int8 v12 = *(unsigned char *)(v1 + 21);
        *(_DWORD *)long long buf = *(_DWORD *)(v1 + 16);
        int v19 = 0;
        *(_DWORD *)&v20[4] = 4;
        *(_DWORD *)BOOL v20 = v12;
        if (sub_100256E84((uint64_t **)(v3 + 144), *(_DWORD *)(v1 + 8), (_DWORD *)(v1 + 8))[5])
        {
          if (sub_100EA49E8(v3, *v2)) {
            v20[0] = 1;
          }
          (*(void (**)(uint64_t, void, uint8_t *))(*(void *)v11 + 48))(v11, *v2, buf);
        }
        else
        {
          uint64_t v13 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)CFStringRef v17 = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No pending actions for send failure", v17, 2u);
          }
        }
      }
      sub_10004D2C8(v10);
    }
  }
  sub_100EA74E0(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100EA74B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100EA74E0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EA74E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_100EA7548(uint64_t **a1)
{
  uint64_t v1 = (int *)(*a1 + 1);
  uint64_t v2 = **a1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 88) + 16))(*(void *)(v2 + 88), *v1);
  uint64_t v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SMS Send success", buf, 2u);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 80);
  if (!v5 || (int v6 = std::__shared_weak_count::lock(v5)) == 0) {
LABEL_15:
  }
    operator delete();
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(v2 + 72);
  if (v8)
  {
    int v9 = (uint64_t **)(v2 + 144);
    if (sub_100256E84((uint64_t **)(v2 + 144), *v1, v1)[5])
    {
      if (*((_DWORD *)sub_100256E84((uint64_t **)(v2 + 144), *v1, v1)[5] + 12) == 2)
      {
        sub_100EA4928(v2);
        sub_100EA4868(v2);
        (*(void (**)(uint64_t, void))(*(void *)v8 + 40))(v8, *v1);
        goto LABEL_14;
      }
      if (*((_DWORD *)sub_100256E84((uint64_t **)(v2 + 144), *v1, v1)[5] + 12) == 1)
      {
        sub_100EA4928(v2);
        *((unsigned char *)sub_100256E84((uint64_t **)(v2 + 144), *v1, v1)[5] + 44) = 1;
        goto LABEL_14;
      }
      os_log_t v14 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      sub_100256E84(v9, *v1, v1);
      uint64_t v15 = sms::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v17 = v15;
      uint64_t v11 = "Unknown sms type in sms send success: %s";
      unsigned __int8 v12 = v14;
      uint32_t v13 = 12;
    }
    else
    {
      os_log_t v10 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "Failed to get pending messages";
      unsigned __int8 v12 = v10;
      uint32_t v13 = 2;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
  }
LABEL_14:
  sub_10004D2C8(v7);
  goto LABEL_15;
}

void sub_100EA77D8()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t *sub_100EA7818(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v48 = a1;
  uint64_t v49 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 88) + 16))(*(void *)(*(void *)v1 + 88), *(unsigned int *)(v1 + 8));
  if (subscriber::isValidSimSlot())
  {
    if (MessageCenterModel::isMessagesInstalled((Registry **)(v2 + 56)))
    {
      uint64_t v4 = *(const void **)(v1 + 136);
      uint64_t v5 = *(void *)(v1 + 144);
      unsigned int v52 = 0;
      CFDictionaryRef v53 = 0;
      uint64_t v54 = 0;
      sub_10005C928(&v52, v4, v5, v5 - (void)v4);
      int v6 = (void *)(v1 + 88);
      if (std::string::compare((const std::string *)(v1 + 88), "application/vnd.3gpp.sms"))
      {
        if (std::string::compare((const std::string *)(v1 + 88), "application/vnd.3gpp2.sms"))
        {
          uint64_t v7 = *v3;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(v1 + 111) < 0) {
              int v6 = (void *)*v6;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v6;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SMS message with unrecognized content type: '%s'! Ignoring message.", buf, 0xCu);
          }
          goto LABEL_95;
        }
        os_log_t v10 = *(std::__shared_weak_count **)(v2 + 80);
        if (v10)
        {
          uint64_t v11 = *(unsigned int *)(v1 + 8);
          unsigned __int8 v12 = std::__shared_weak_count::lock(v10);
          if (v12)
          {
            uint64_t v13 = *(void *)(v2 + 72);
            if (v13)
            {
              *(_OWORD *)uint64_t v56 = 0u;
              memset(buf, 0, sizeof(buf));
              sms::MTSmsDetails::MTSmsDetails();
              *(void *)std::string v62 = off_101A67360;
              *(void *)&v62[8] = v2;
              *(void *)&v62[16] = v11;
              *(void *)&v62[24] = v62;
              (*(void (**)(uint64_t, uint8_t *, uint8_t *))(*(void *)v13 + 32))(v13, buf, v62);
              sub_1009F04EC(v62);
              sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)buf);
LABEL_34:
              sub_10004D2C8(v12);
LABEL_95:
              if (v52)
              {
                CFDictionaryRef v53 = v52;
                operator delete(v52);
              }
              goto LABEL_97;
            }
          }
        }
        else
        {
          unsigned __int8 v12 = 0;
        }
        uint64_t v24 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", buf, 2u);
        }
        if (!v12) {
          goto LABEL_95;
        }
        goto LABEL_34;
      }
      if (*(char *)(v1 + 39) < 0)
      {
        sub_10004FC84(__dst, *(void **)(v1 + 16), *(void *)(v1 + 24));
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)(v1 + 16);
        uint64_t v51 = *(void *)(v1 + 32);
      }
      uint64_t v14 = *(unsigned int *)(v1 + 8);
      uint64_t v15 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 88) + 16))(*(void *)(v2 + 88), v14);
      uint64_t v16 = v15;
      if (*(void *)(v1 + 136) == *(void *)(v1 + 144))
      {
        uint64_t v23 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Empty PDU while parsing 3GPP message", buf, 2u);
        }
        goto LABEL_93;
      }
      uint64_t v17 = (char *)operator new(0x378uLL);
      *((void *)v17 + 1) = 0;
      *((void *)v17 + 2) = 0;
      *(void *)uint64_t v17 = off_101A67280;
      uint64_t v18 = (uint64_t)(v17 + 24);
      ImsSmsPduDecoder::ImsSmsPduDecoder((ImsSmsPduDecoder *)(v17 + 24));
      BOOL v19 = ImsSmsPduDecoder::decodeRpMessage((uint64_t)(v17 + 24), v1 + 136);
      BOOL v20 = *v16;
      if (!v19)
      {
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
        {
          (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v18 + 16))(buf, v18);
          unsigned int v43 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)std::string v62 = 136315138;
          *(void *)&v62[4] = v43;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to parse incoming sms using: %s decoder ", v62, 0xCu);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v18 + 16))(buf, v18);
        ImsSmsPduDecoder::logPdu(v18, v1 + 136, (uint64_t *)buf);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_92;
      }
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v21 = *((_DWORD *)v17 + 184) - 2;
        uint64_t v22 = v21 > 4 ? "RP-DATA" : off_101A67450[v21];
        if (*(void *)(v1 + 136) == *(void *)(v1 + 144))
        {
          memset(buf, 0, 24);
          char v25 = buf;
        }
        else
        {
          v60[0] = 0;
          v60[1] = 0;
          ctu::TextConverter::TextConverter((ctu::TextConverter *)v60);
          ctu::TextConverter::pushConversion();
          ctu::TextConverter::setSource((ctu::TextConverter *)v60, *(const char **)(v1 + 136), *(void *)(v1 + 144) - *(void *)(v1 + 136));
          ctu::TextConverter::readChars((uint64_t *)buf, (ctu::TextConverter *)v60, 0x7FFFFFFFuLL);
          ctu::TextConverter::~TextConverter((ctu::TextConverter *)v60);
          char v25 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
        }
        *(_DWORD *)std::string v62 = 136315395;
        *(void *)&v62[4] = v22;
        *(_WORD *)&v62[12] = 2085;
        *(void *)&v62[14] = v25;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Received %s (as hex): %{sensitive}s", v62, 0x16u);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
      int v26 = *((_DWORD *)v17 + 184);
      if (v26 != 4)
      {
        if (v26 == 2)
        {
          uint64_t v37 = *v16;
          if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I RP-ACK received", buf, 2u);
          }
          sub_100EA4868(v2);
          sub_100EA4928(v2);
          __int16 v38 = *(std::__shared_weak_count **)(v2 + 80);
          if (!v38) {
            goto LABEL_92;
          }
          uint64_t v39 = std::__shared_weak_count::lock(v38);
          if (!v39) {
            goto LABEL_92;
          }
          os_log_t v28 = v39;
          uint64_t v40 = *(void *)(v2 + 72);
          if (v40) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v40 + 40))(v40, v14);
          }
          goto LABEL_91;
        }
        if (v26)
        {
          uint64_t v41 = *v16;
          if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Invalid RP-Message of type: %d", buf, 8u);
          }
          goto LABEL_92;
        }
        uint64_t v27 = *(std::__shared_weak_count **)(v2 + 80);
        if (v27)
        {
          os_log_t v28 = std::__shared_weak_count::lock(v27);
          if (v28)
          {
            uint64_t v29 = *(void *)(v2 + 72);
            if (v29)
            {
              long long v63 = 0u;
              memset(v62, 0, sizeof(v62));
              memset(buf, 0, 24);
              sub_10005C928(buf, *((const void **)v17 + 89), *((void *)v17 + 90), *((void *)v17 + 90) - *((void *)v17 + 89));
              sms::MTSmsDetails::MTSmsDetails();
              if (*(void *)buf)
              {
                *(void *)&uint8_t buf[8] = *(void *)buf;
                operator delete(*(void **)buf);
              }
              *(void *)long long buf = v2;
              *(_DWORD *)&uint8_t buf[8] = v14;
              *(void *)&uint8_t buf[16] = v17 + 24;
              *(void *)&unsigned char buf[24] = v17;
              atomic_fetch_add_explicit((atomic_ullong *volatile)v17 + 1, 1uLL, memory_order_relaxed);
              if (*(char *)(v1 + 135) < 0)
              {
                sub_10004FC84(v56, *(void **)(v1 + 112), *(void *)(v1 + 120));
              }
              else
              {
                *(_OWORD *)uint64_t v56 = *(_OWORD *)(v1 + 112);
                uint64_t v57 = *(void *)(v1 + 128);
              }
              if (SHIBYTE(v51) < 0)
              {
                sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
              }
              else
              {
                long long __p = *(_OWORD *)__dst;
                uint64_t v59 = v51;
              }
              uint64_t v61 = 0;
              uint64_t v44 = (char *)operator new(0x58uLL);
              uint64_t v45 = *(void *)buf;
              *(void *)uint64_t v44 = off_101A672D0;
              *((void *)v44 + 1) = v45;
              *((_DWORD *)v44 + 4) = *(_DWORD *)&buf[8];
              *(_OWORD *)(v44 + 24) = *(_OWORD *)&buf[16];
              *(_OWORD *)&uint8_t buf[16] = 0uLL;
              uint64_t v46 = v44 + 40;
              if (SHIBYTE(v57) < 0)
              {
                sub_10004FC84(v46, v56[0], (unint64_t)v56[1]);
              }
              else
              {
                *(_OWORD *)uint64_t v46 = *(_OWORD *)v56;
                *((void *)v44 + 7) = v57;
              }
              *((_OWORD *)v44 + 4) = __p;
              *((void *)v44 + 10) = v59;
              uint64_t v59 = 0;
              long long __p = 0uLL;
              uint64_t v61 = v44;
              (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v29 + 32))(v29, v62, v60);
              sub_1009F04EC(v60);
              if (SHIBYTE(v59) < 0) {
                operator delete((void *)__p);
              }
              if (SHIBYTE(v57) < 0) {
                operator delete(v56[0]);
              }
              if (*(void *)&buf[24]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[24]);
              }
              sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)v62);
LABEL_91:
              sub_10004D2C8(v28);
LABEL_92:
              sub_10004D2C8((std::__shared_weak_count *)v17);
LABEL_93:
              if (SHIBYTE(v51) < 0) {
                operator delete(__dst[0]);
              }
              goto LABEL_95;
            }
          }
        }
        else
        {
          os_log_t v28 = 0;
        }
        unsigned int v42 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to get SMS controller", buf, 2u);
        }
        if (!v28) {
          goto LABEL_92;
        }
        goto LABEL_91;
      }
      uint64_t v30 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = v17[880];
        uint64_t v32 = sms::asString();
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v31;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I RP-Error received: [%d: %s]", buf, 0x12u);
      }
      unint64_t v33 = v17[880];
      *(_DWORD *)long long buf = v17[880];
      *(_DWORD *)&uint8_t buf[4] = 1;
      *(_DWORD *)&uint8_t buf[8] = (v33 > 0x2F) | (0x79BFFFFFFFFFuLL >> v33) & 1;
      *(_DWORD *)&unsigned char buf[12] = 3;
      uint64_t v34 = *(std::__shared_weak_count **)(v2 + 80);
      if (!v34) {
        goto LABEL_92;
      }
      int v35 = std::__shared_weak_count::lock(v34);
      if (!v35) {
        goto LABEL_92;
      }
      os_log_t v28 = v35;
      uint64_t v36 = *(void *)(v2 + 72);
      if (v36)
      {
        sub_100EA4928(v2);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v36 + 48))(v36, v14, buf);
      }
      goto LABEL_91;
    }
    int v9 = *v3;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed, dropping incoming message.", buf, 2u);
    }
  }
  else
  {
    uint64_t v8 = *v3;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to handle Incoming SMS for invalid slot", buf, 2u);
    }
  }
LABEL_97:
  sub_100EA83D0(&v49);
  return sub_100046B58((uint64_t *)&v48);
}

void sub_100EA8260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v41 = (std::__shared_weak_count *)v38[4];
  if (v41) {
    sub_10004D2C8(v41);
  }
  operator delete(v38);
  sub_100EA69E4((uint64_t)&a20);
  sms::MTSmsDetails::~MTSmsDetails((sms::MTSmsDetails *)(v39 - 160));
  sub_10004D2C8(v37);
  sub_10004D2C8(v36);
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  sub_100EA83D0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EA83D0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 136);
    if (v2)
    {
      *(void *)(v1 + 144) = v2;
      operator delete(v2);
    }
    if (*(char *)(v1 + 135) < 0) {
      operator delete(*(void **)(v1 + 112));
    }
    if (*(char *)(v1 + 111) < 0) {
      operator delete(*(void **)(v1 + 88));
    }
    if (*(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_100EA8478(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A67280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EA8498(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A67280;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EA84EC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100EA8514(uint64_t a1)
{
  *(void *)a1 = off_101A672D0;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100EA8580(uint64_t a1)
{
  *(void *)a1 = off_101A672D0;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100EA860C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = off_101A672D0;
  sub_100EA967C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100EA8660(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EA8674(uint64_t a1, void *a2)
{
  *a2 = off_101A672D0;
  return sub_100EA967C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100EA86A0(uint64_t a1)
{
}

void sub_100EA86A8(void *a1)
{
  sub_100EA9760((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100EA86E4(uint64_t a1, int *a2, uint64_t *a3)
{
  int v4 = *a2;
  uint64_t v6 = *a3;
  uint64_t v5 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v7 + 88) + 16))(*(void *)(v7 + 88), *(unsigned int *)(a1 + 16));
  int v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = sms::asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Message pdu processing status: %s", buf, 0xCu);
  }
  if (v4 != 5)
  {
    uint64_t v120 = 0;
    long long v118 = 0u;
    long long v119 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    memset(buf, 0, sizeof(buf));
    SmsPduEncoder::SmsPduEncoder((SmsPduEncoder *)buf, 0);
    *(void *)long long buf = &off_101A90CB0;
    BYTE8(v119) = 0;
    if (v4 == 1)
    {
      uint64_t v11 = *v8;
      unint64_t v12 = (unint64_t)&_mh_execute_header;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_134:
        uint64_t v74 = sms::asString();
        *(_DWORD *)uint64_t v121 = 136315138;
        *(void *)&v121[4] = v74;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Rejecting MT SMS with RP-ERROR: %s", v121, 0xCu);
      }
LABEL_135:
      sub_101118AD8((uint64_t)buf, *(unsigned __int8 *)(*(void *)(a1 + 24) + 716), v12);
      memset(v121, 0, sizeof(v121));
      *(void *)&long long v122 = 0;
      sub_101118CC4((uint64_t)buf, v121);
      sub_100EA6404(v7, *(_DWORD *)(a1 + 16), 1, (uint64_t)v121, a1 + 64, a1 + 40, 0);
      unint64_t v75 = *(void **)v121;
      if (!*(void *)v121)
      {
LABEL_154:
        SmsPduEncoder::~SmsPduEncoder((SmsPduEncoder *)buf);
        goto LABEL_155;
      }
      *(void *)&uint8_t v121[8] = *(void *)v121;
LABEL_137:
      operator delete(v75);
      goto LABEL_154;
    }
    uint64_t v13 = *(unsigned int *)(a1 + 16);
    uint64_t v14 = operator new(0x10uLL);
    *(void *)&uint8_t v121[8] = v14 + 2;
    *(void *)&long long v122 = v14 + 2;
    void *v14 = @"SMSSettings";
    v14[1] = @"RejectUserSmsWithErrorCode";
    *(void *)uint64_t v121 = v14;
    cf[0] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v14 + 2, *(Registry **)(v7 + 56));
    uint64_t v16 = ServiceMap;
    if (v17 < 0)
    {
      uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v99 = v17;
    unsigned int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&v99);
    if (v21)
    {
      uint64_t v23 = v21[3];
      uint64_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        goto LABEL_120;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    uint64_t v22 = 0;
    char v24 = 1;
LABEL_120:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, uint8_t *, void, void))(*(void *)v23 + 104))(v94, v23, v13, 1, v121, 0, 0);
    sub_1000842D0(cf, v94);
    sub_1000577C4(v94);
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    LODWORD(v99) = -1;
    ctu::cf::assign((ctu::cf *)&v99, (int *)cf[0], v61);
    int v62 = v99;
    sub_1000570E8(cf);
    if (*(void *)v121)
    {
      *(void *)&uint8_t v121[8] = *(void *)v121;
      operator delete(*(void **)v121);
    }
    unint64_t v12 = (v62 & ~(v62 >> 31) | ((((unint64_t)(v62 & 0x80000000) >> 31) & 1) << 32)) ^ (unint64_t)&_mh_execute_header;
    uint64_t v11 = *v8;
    BOOL v63 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (!HIDWORD(v12))
    {
      if (v63)
      {
        *(_WORD *)uint64_t v121 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending RP-ACK", v121, 2u);
      }
      *(_OWORD *)uint64_t v121 = 0u;
      long long v122 = 0u;
      v121[0] = *(unsigned char *)(*(void *)(a1 + 24) + 716);
      uint64_t v64 = *(unsigned int *)(a1 + 16);
      CFNumberRef v65 = (std::mutex *)Registry::getServiceMap((uint64_t *)v121[0], *(Registry **)(v7 + 56));
      long long v66 = v65;
      if (v67 < 0)
      {
        long long v68 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v69 = 5381;
        do
        {
          uint64_t v67 = v69;
          unsigned int v70 = *v68++;
          uint64_t v69 = (33 * v69) ^ v70;
        }
        while (v70);
      }
      std::mutex::lock(v65);
      *(void *)&long long v99 = v67;
      uint64_t v71 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)&v99);
      if (v71)
      {
        unint64_t v73 = (const void *)v71[3];
        unint64_t v72 = (std::__shared_weak_count *)v71[4];
        if (v72) {
          atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        unint64_t v73 = 0;
        unint64_t v72 = 0;
      }
      std::mutex::unlock(v66);
      cf[0] = v73;
      cf[1] = v72;
      if (v72)
      {
        atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v72);
      }
      sub_100058DB0(&v99, "EnableExtraRPAckFields");
      v92[0] = kCFBooleanFalse;
      if (kCFBooleanFalse) {
        CFRetain(kCFBooleanFalse);
      }
      sub_100EA6854((uint64_t)v94, v64, cf, (uint64_t)&v99, v92);
      uint64_t v76 = (BOOL *)v94[0];
      LOBYTE(v90[0]) = 0;
      if (v94[0])
      {
        CFTypeID v77 = CFGetTypeID(v94[0]);
        if (v77 == CFBooleanGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)v90, v76, v78);
          LODWORD(v76) = LOBYTE(v90[0]);
        }
        else
        {
          LODWORD(v76) = 0;
        }
      }
      sub_1000577C4(v94);
      sub_1000577C4((const void **)v92);
      if (SHIBYTE(v100) < 0) {
        operator delete((void *)v99);
      }
      if (v72) {
        sub_10004D2C8(v72);
      }
      sub_101118658((uint64_t)buf, v121, v76 != 0);
      long long v99 = 0uLL;
      uint64_t v100 = 0;
      sub_101118CC4((uint64_t)buf, &v99);
      sub_100EA6404(v7, *(_DWORD *)(a1 + 16), 1, (uint64_t)&v99, a1 + 64, a1 + 40, 0);
      if ((void)v99)
      {
        *((void *)&v99 + 1) = v99;
        operator delete((void *)v99);
      }
      if ((SHIBYTE(v122) & 0x80000000) == 0) {
        goto LABEL_154;
      }
      unint64_t v75 = *(void **)&v121[8];
      goto LABEL_137;
    }
    if (v63) {
      goto LABEL_134;
    }
    goto LABEL_135;
  }
  v90[0] = 0;
  v90[1] = 0;
  uint64_t v91 = 0;
  sub_10009DB3C((uint64_t)buf, *(void *)(a1 + 24) + 720);
  CSIPhoneNumber::getFullNumber((uint64_t *)v90, (CSIPhoneNumber *)buf);
  if (SHIBYTE(v103) < 0) {
    operator delete(*((void **)&v102 + 1));
  }
  if (SBYTE7(v102) < 0) {
    operator delete(*(void **)&buf[64]);
  }
  if ((buf[55] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[32]);
  }
  if ((buf[31] & 0x80000000) != 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v10 = *(unsigned char *)(*(void *)(a1 + 24) + 716);
  if (SHIBYTE(v91) < 0)
  {
    sub_10004FC84(__dst, v90[0], (unint64_t)v90[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v90;
    uint64_t v89 = v91;
  }
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(v86, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    *(_OWORD *)int v86 = *(_OWORD *)(a1 + 64);
    uint64_t v87 = *(void *)(a1 + 80);
  }
  uint64_t v25 = *(void *)(a1 + 24);
  int v84 = 0;
  uint64_t v85 = 0;
  uint64_t v83 = 0;
  sub_10005C928(&v83, *(const void **)(v25 + 688), *(void *)(v25 + 696), *(void *)(v25 + 696) - *(void *)(v25 + 688));
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(v81, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)int v81 = *(_OWORD *)(a1 + 40);
    int v26 = *(uint64_t **)(a1 + 56);
    uint64_t v82 = v26;
  }
  uint64_t v27 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(v7 + 56));
  os_log_t v28 = v27;
  if (v29 < 0)
  {
    uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  *(void *)long long buf = v29;
  unint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
  if (v33)
  {
    uint64_t v35 = v33[3];
    uint64_t v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v28);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      if (!v35) {
        goto LABEL_104;
      }
LABEL_41:
      char v80 = v36;
      long long v99 = 0uLL;
      uint64_t v100 = 0;
      int v79 = v34;
      sub_10012CD04(&v99, (char *)v83, v84, v84 - (unsigned char *)v83);
      uint64_t v37 = *(unsigned int *)(v6 + 8);
      uint64_t v38 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 88) + 16))(*(void *)(v7 + 88), v37);
      uint64_t v40 = (std::mutex *)Registry::getServiceMap(v39, *(Registry **)(v7 + 56));
      uint64_t v41 = v40;
      if (v42 < 0)
      {
        unsigned int v43 = (unsigned __int8 *)(v42 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v44 = 5381;
        do
        {
          uint64_t v42 = v44;
          unsigned int v45 = *v43++;
          uint64_t v44 = (33 * v44) ^ v45;
        }
        while (v45);
      }
      std::mutex::lock(v40);
      *(void *)long long buf = v42;
      uint64_t v46 = sub_10004D37C(&v41[1].__m_.__sig, (unint64_t *)buf);
      char v47 = v10;
      if (v46)
      {
        uint64_t v49 = v46[3];
        long long v48 = (std::__shared_weak_count *)v46[4];
        if (v48) {
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v49 = 0;
        long long v48 = 0;
      }
      std::mutex::unlock(v41);
      *(void *)uint64_t v121 = v49;
      *(void *)&uint8_t v121[8] = v48;
      if (v48)
      {
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v48);
      }
      sub_100058DB0(buf, "UseRpOriginatingAddressAsSender");
      CFBooleanRef v98 = kCFBooleanTrue;
      if (kCFBooleanTrue) {
        CFRetain(kCFBooleanTrue);
      }
      sub_100EA6854((uint64_t)cf, v37, v121, (uint64_t)buf, &v98);
      uint64_t v50 = (BOOL *)cf[0];
      LOBYTE(v94[0]) = 0;
      if (cf[0])
      {
        CFTypeID v51 = CFGetTypeID(cf[0]);
        if (v51 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)v94, v50, v52);
        }
      }
      int v53 = LOBYTE(v94[0]);
      sub_1000577C4(cf);
      sub_1000577C4((const void **)&v98);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (v48) {
        sub_10004D2C8(v48);
      }
      cf[0] = 0;
      cf[1] = 0;
      uint64_t v97 = 0;
      if (v53) {
        uint64_t v54 = __dst;
      }
      else {
        uint64_t v54 = v86;
      }
      uint64_t v55 = (char *)&v87 + 7;
      if (v53) {
        uint64_t v55 = (char *)&v89 + 7;
      }
      if (*v55 < 0)
      {
        uint64_t v56 = &__dst[1];
        if (!v53) {
          uint64_t v56 = &v86[1];
        }
        sub_10004FC84(cf, *v54, (unint64_t)*v56);
      }
      else
      {
        *(_OWORD *)CFTypeRef cf = *(_OWORD *)v54;
        uint64_t v97 = v54[2];
      }
      uint64_t v57 = *(unsigned int *)(v6 + 8);
      if (SHIBYTE(v97) < 0)
      {
        sub_10004FC84(v94, (void *)cf[0], (unint64_t)cf[1]);
      }
      else
      {
        *(_OWORD *)int v94 = *(_OWORD *)cf;
        long long v95 = v97;
      }
      if (SHIBYTE(v100) < 0)
      {
        sub_10004FC84(v92, (void *)v99, *((unint64_t *)&v99 + 1));
      }
      else
      {
        *(_OWORD *)CFDictionaryRef v92 = v99;
        uint64_t v93 = v100;
      }
      *(void *)long long buf = v7;
      *(void *)&uint8_t buf[8] = v6;
      *(void *)&uint8_t buf[16] = v5;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned char buf[24] = v47;
      if (SHIBYTE(v87) < 0)
      {
        sub_10004FC84(&buf[32], v86[0], (unint64_t)v86[1]);
      }
      else
      {
        *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)v86;
        *(void *)&buf[48] = v87;
      }
      if (SHIBYTE(v82) < 0)
      {
        sub_10004FC84(&buf[56], v81[0], (unint64_t)v81[1]);
      }
      else
      {
        *(_OWORD *)&buf[56] = *(_OWORD *)v81;
        *(void *)&buf[72] = v82;
      }
      *(void *)&long long v102 = v38;
      DWORD2(v102) = v37;
      *((void *)&v122 + 1) = 0;
      long long v58 = (char *)operator new(0x68uLL);
      uint64_t v59 = v58;
      *(void *)long long v58 = off_101A673E0;
      *(_OWORD *)(v58 + 8) = *(_OWORD *)buf;
      *((void *)v58 + 3) = *(void *)&buf[16];
      *(_OWORD *)&uint8_t buf[8] = 0uLL;
      v58[32] = buf[24];
      if ((buf[55] & 0x80000000) != 0)
      {
        sub_10004FC84(v58 + 40, *(void **)&buf[32], *(unint64_t *)&buf[40]);
      }
      else
      {
        *(_OWORD *)(v58 + 40) = *(_OWORD *)&buf[32];
        *((void *)v58 + 7) = *(void *)&buf[48];
      }
      long long v60 = v59 + 64;
      if ((buf[79] & 0x80000000) != 0)
      {
        uint64_t v34 = v79;
        sub_10004FC84(v60, *(void **)&buf[56], *(unint64_t *)&buf[64]);
      }
      else
      {
        *(_OWORD *)long long v60 = *(_OWORD *)&buf[56];
        *((void *)v59 + 10) = *(void *)&buf[72];
        uint64_t v34 = v79;
      }
      *((void *)v59 + 11) = v102;
      *((_DWORD *)v59 + 24) = DWORD2(v102);
      *((void *)&v122 + 1) = v59;
      (*(void (**)(uint64_t, uint64_t, CFTypeRef *, void **, void, uint8_t *))(*(void *)v35 + 160))(v35, v57, v94, v92, 0, v121);
      sub_1000DBADC(v121);
      if ((buf[79] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[56]);
      }
      if ((buf[55] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[32]);
      }
      if (*(void *)&buf[16]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[16]);
      }
      if (SHIBYTE(v93) < 0) {
        operator delete(v92[0]);
      }
      if (SHIBYTE(v95) < 0) {
        operator delete((void *)v94[0]);
      }
      if (SHIBYTE(v97) < 0) {
        operator delete((void *)cf[0]);
      }
      if (SHIBYTE(v100) < 0) {
        operator delete((void *)v99);
      }
      char v36 = v80;
      goto LABEL_104;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v28);
  uint64_t v34 = 0;
  char v36 = 1;
  if (v35) {
    goto LABEL_41;
  }
LABEL_104:
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  if (SHIBYTE(v82) < 0) {
    operator delete(v81[0]);
  }
  if (v83)
  {
    int v84 = (char *)v83;
    operator delete(v83);
  }
  if (SHIBYTE(v87) < 0) {
    operator delete(v86[0]);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete(__dst[0]);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (SHIBYTE(v91) < 0) {
    operator delete(v90[0]);
  }
LABEL_155:
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100EA9314(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EA9630(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA9670()
{
}

uint64_t sub_100EA967C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  uint64_t v5 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), (void *)a2[4], a2[5]);
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 2);
    *(void *)(a1 + 48) = a2[6];
    *(_OWORD *)(a1 + 32) = v6;
  }
  uint64_t v7 = (unsigned char *)(a1 + 56);
  if (*((char *)a2 + 79) < 0)
  {
    sub_10004FC84(v7, (void *)a2[7], a2[8]);
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 7);
    *(void *)(a1 + 72) = a2[9];
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_100EA9730(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EA9760(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100EA97C8()
{
}

__n128 sub_100EA97DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A67360;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EA9828(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A67360;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EA9858(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 88) + 16))(*(void *)(*(void *)(a1 + 8) + 88), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = sms::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SMS message processing status: %s", (uint8_t *)&v5, 0xCu);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100EA9948(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EA9960(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA99A0()
{
}

uint64_t sub_100EA99AC(uint64_t a1)
{
  *(void *)a1 = off_101A673E0;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100EA9A18(uint64_t a1)
{
  *(void *)a1 = off_101A673E0;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100EA9AA4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  void *v2 = off_101A673E0;
  sub_100EA9E80((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100EA9AF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EA9B0C(uint64_t a1, void *a2)
{
  *a2 = off_101A673E0;
  return sub_100EA9E80((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100EA9B38(uint64_t a1)
{
}

void sub_100EA9B40(void *a1)
{
  sub_100EA9F74((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100EA9B7C(uint64_t a1, unsigned __int8 *a2, std::string *a3)
{
  int v4 = *a2;
  std::string v9 = *a3;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v15 = 0;
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  SmsPduEncoder::SmsPduEncoder((SmsPduEncoder *)v13, 0);
  *(void *)&v13[0] = &off_101A90CB0;
  BYTE8(v14) = 0;
  if (v4)
  {
    *(_OWORD *)long long __p = 0u;
    long long v12 = 0u;
    std::string::operator=((std::string *)&__p[1], &v9);
    LOBYTE(__p[0]) = *(unsigned char *)(a1 + 32);
    BYTE2(__p[0]) = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 432))(*(void *)(a1 + 16));
    BYTE1(__p[0]) = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 344))(*(void *)(a1 + 16));
    uint64_t v6 = **(NSObject ***)(a1 + 88);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I SMS PP-Data succeeded. Sending RP-ACK", buf, 2u);
    }
    sub_101118658((uint64_t)v13, (unsigned __int8 *)__p, 1);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[1]);
    }
  }
  else
  {
    uint64_t v7 = **(NSObject ***)(a1 + 88);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "SMS PP-Data failed. Sending RP-ERROR", (uint8_t *)__p, 2u);
    }
    sub_101118AD8((uint64_t)v13, *(unsigned __int8 *)(a1 + 32), 111);
  }
  int v8 = *(_DWORD *)(a1 + 96);
  sub_101118CC4((uint64_t)v13, __p);
  sub_100EA6404(v5, v8, 1, (uint64_t)__p, a1 + 40, a1 + 64, 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  SmsPduEncoder::~SmsPduEncoder((SmsPduEncoder *)v13);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_100EA9DD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EA9E34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EA9E74()
{
}

uint64_t sub_100EA9E80(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v6 = v7;
  }
  uint64_t v8 = *(void *)(a2 + 80);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(void *)(a1 + 80) = v8;
  return a1;
}

void sub_100EA9F44(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EA9F74(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100EA9FD8()
{
}

void sub_100EAA0A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, dispatch_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v12) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EAA0E0(uint64_t a1, Registry **a2, NSObject **a3, uint64_t a4, uint64_t a5)
{
  char v10 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "dtmf.handler");
  sub_100EAA210(v10, a3, &v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *(void *)a1 = off_101A67488;
  Registry::getTimerService((uint64_t *)(a1 + 48), *a2);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)a4;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a1 + 80) = a5;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(unsigned char *)(a1 + 152) = 1;
  return a1;
}

void sub_100EAA1D4(_Unwind_Exception *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 40));
  sub_100087E88(v2);
  DtmfHandlerInterface::~DtmfHandlerInterface((DtmfHandlerInterface *)v1);
  _Unwind_Resume(a1);
}

void *sub_100EAA210(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  long long v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100EAA278(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_100EAA29C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAA38C(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    uint64_t v2 = *(void *)(a1 + 136);
    if ((!v2 || (*(unsigned int (**)(uint64_t))(*(void *)v2 + 24))(v2)) && *(unsigned char *)(a1 + 152))
    {
      char v3 = *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + ((*(void *)(a1 + 120) >> 9) & 0x7FFFFFFFFFFFF8))
                    + (*(void *)(a1 + 120) & 0xFFFLL));
      (*(void (**)(void, void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), v3);
      uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v4 || (v5 = *(void *)(a1 + 8), (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
        sub_100088B9C();
      }
      long long v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      uint64_t v8 = *(void *)(a1 + 48);
      sub_100058DB0(__p, "DtmfHandler");
      char v9 = v3;
      uint64_t v10 = *(void *)(a1 + 80);
      uint64_t v11 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v11;
      if (v11) {
        dispatch_retain(v11);
      }
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 1174405120;
      void v14[2] = sub_100EAA688;
      v14[3] = &unk_101A674C0;
      void v14[4] = a1;
      v14[5] = v5;
      uint64_t v15 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      char v16 = v9;
      aBlock = _Block_copy(v14);
      sub_100118A44(v8, (uint64_t)__p, 1, 1000 * v10, &object, &aBlock);
      sub_1004DC2E0((void *)(a1 + 136), &v21);
      uint64_t v12 = v21;
      uint64_t v21 = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v20 < 0) {
        operator delete(__p[0]);
      }
      if (v15) {
        std::__shared_weak_count::__release_weak(v15);
      }
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No digit enqueued!", (uint8_t *)v14, 2u);
    }
  }
}

void sub_100EAA5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v27 = *(void *)(v25 - 72);
  *(void *)(v25 - 72) = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

void sub_100EAA688(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        (*(void (**)(void))(**(void **)(v3 + 64) + 24))(*(void *)(v3 + 64));
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 144);
        *(void *)(v3 + 136) = 0;
        *(void *)(v3 + 144) = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
        uint64_t v7 = *(void *)(v3 + 128);
        if (v7)
        {
          ++*(void *)(v3 + 120);
          *(void *)(v3 + 128) = v7 - 1;
          sub_100B2539C(v3 + 88, 1);
          if (*(unsigned char *)(v3 + 152)) {
            sub_100EAA38C(v3);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100EAA760(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EAA774(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EAA790(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100EAA7A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAA880(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAA96C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAAA4C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAAB2C(void *a1)
{
  *a1 = off_101A67488;
  uint64_t v2 = (std::__shared_weak_count *)a1[18];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100B24550(a1 + 11);
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  DtmfHandlerInterface::~DtmfHandlerInterface((DtmfHandlerInterface *)a1);
}

void sub_100EAABBC(void *a1)
{
  *a1 = off_101A67488;
  uint64_t v2 = (std::__shared_weak_count *)a1[18];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100B24550(a1 + 11);
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  DtmfHandlerInterface::~DtmfHandlerInterface((DtmfHandlerInterface *)a1);

  operator delete();
}

void sub_100EAAC60(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EAAD2C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100EAAE04);
  __cxa_rethrow();
}

void sub_100EAAD54(_Unwind_Exception *a1)
{
}

void sub_100EAAD6C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EAADA4(uint64_t a1)
{
}

uint64_t sub_100EAADC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EAAE04(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100EAAE30(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  char v3 = *((unsigned char *)*a1 + 8);
  sub_100B22AE8((void *)(v1 + 88), &v3);
  sub_100EAA38C(v1);
  operator delete();
}

void sub_100EAAE9C()
{
}

void sub_100EAAEC8(uint64_t **a1)
{
  uint64_t v5 = a1;
  uint64_t v1 = **a1;
  *(unsigned char *)(v1 + 152) = 1;
  uint64_t v2 = *(void *)(v1 + 128);
  char v3 = *(NSObject **)(v1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Previous STOP has been sent. Sending the next Start Dtmf.", buf, 2u);
    }
    sub_100EAA38C(v1);
  }
  else if (v4)
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E The last stop DTMF has been sent. But there were no digits enqueued!", v7, 2u);
  }
  operator delete();
}

void sub_100EAAFA4()
{
}

void sub_100EAAFD0(uint64_t a1)
{
  uint64_t v1 = a1;
  *(void *)(**(void **)a1 + 80) = *(void *)(*(void *)a1 + 8);
  operator delete();
}

void sub_100EAB018(uint64_t **a1)
{
  char v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Need to wait for BB to confirm STOP has been sent.", buf, 2u);
  }
  *(unsigned char *)(v1 + 152) = 0;
  operator delete();
}

void sub_100EAB0B0(uint64_t **a1)
{
  uint64_t v10 = a1;
  uint64_t v1 = **a1;
  *(unsigned char *)(v1 + 152) = 1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 144);
  *(void *)(v1 + 136) = 0;
  *(void *)(v1 + 144) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(v1 + 128);
  if (v3)
  {
    BOOL v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Clearing unsent DTMF digits...%lu", buf, 0xCu);
    }
    uint64_t v5 = *(void ***)(v1 + 96);
    uint64_t v6 = *(void *)(v1 + 104);
    *(void *)(v1 + 128) = 0;
    unint64_t v7 = v6 - (void)v5;
    if (v7 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v8 = *(void *)(v1 + 104);
        uint64_t v5 = (void **)(*(void *)(v1 + 96) + 8);
        *(void *)(v1 + 96) = v5;
        unint64_t v7 = v8 - (void)v5;
      }
      while (v7 > 0x10);
    }
    if (v7 >> 3 == 1)
    {
      uint64_t v9 = 2048;
    }
    else
    {
      if (v7 >> 3 != 2) {
        goto LABEL_13;
      }
      uint64_t v9 = 4096;
    }
    *(void *)(v1 + 120) = v9;
  }
LABEL_13:
  sub_100EAB1FC((void **)(v1 + 88));
  operator delete();
}

void sub_100EAB1FC(void **a1)
{
  if (a1[5])
  {
    sub_100B2539C((uint64_t)a1, 0);
    sub_100B24F7C(a1, 0);
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v2 = (uint64_t)a1[2];
  }
  else
  {
    uint64_t v3 = (uint64_t)a1[2];
    if ((void *)v3 != a1[1])
    {
      do
      {
        operator delete(*(void **)(v3 - 8));
        BOOL v4 = a1[1];
        uint64_t v3 = (uint64_t)a1[2] - 8;
        a1[2] = (void *)v3;
      }
      while ((void *)v3 != v4);
    }
    a1[4] = 0;
    uint64_t v2 = v3;
  }
  unint64_t v5 = (v2 - v3) >> 3;
  if (v5 < ((unsigned char *)a1[3] - (unsigned char *)*a1) >> 3)
  {
    if (v2 == v3)
    {
      uint64_t v9 = 0;
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v5);
      unint64_t v7 = (char *)a1[1];
      uint64_t v2 = (uint64_t)a1[2];
      uint64_t v9 = &v6[8 * v8];
      uint64_t v10 = v2 - (void)v7;
      if ((char *)v2 != v7)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 8 * (v10 >> 3);
        do
        {
          *(void *)&v6[v11] = *(void *)&v7[v11];
          v11 += 8;
        }
        while (v12 != v11);
        uint64_t v2 = (uint64_t)a1[1];
        uint64_t v13 = a1[2];
LABEL_14:
        uint64_t v14 = (uint64_t)v13 - v2;
        uint64_t v15 = *a1;
        *a1 = v6;
        a1[1] = v6;
        a1[2] = &v6[v14];
        a1[3] = v9;
        if (v15)
        {
          operator delete(v15);
        }
        return;
      }
    }
    uint64_t v13 = (void *)v2;
    goto LABEL_14;
  }
}

uint64_t sub_100EAB32C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (capabilities::ct *)capabilities::ct::supportsSIMProvisioningAsSignupSource(a1);
  if ((v3 & 1) != 0
    || (uint64_t result = capabilities::ct::supportsSIMProvisioningAsSignupDestination(v3), result))
  {
    *a2 = 0;
    a2[1] = 0;
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_100EAB428(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EAB47C(uint64_t a1, uint64_t a2, uint64_t a3, dispatch_object_t *a4)
{
  unint64_t v7 = (void *)(a1 + 8);
  uint64_t v8 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "lasd.ids");
  if (v8) {
    dispatch_retain(v8);
  }
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v10 = dispatch_queue_create_with_target_V2("LASDDatabaseIDSUtility", initially_inactive, v8);
  dispatch_set_qos_class_floor(v10, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v10);
  void *v7 = 0;
  v7[1] = 0;
  *(void *)(a1 + 24) = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  if (v10) {
    dispatch_release(v10);
  }
  if (v8) {
    dispatch_release(v8);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  if (v8) {
    dispatch_release(v8);
  }
  *(void *)a1 = off_101A67608;
  *(void *)(a1 + 48) = *(void *)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 64), *(Registry **)a2);
  *(void *)(a1 + 104) = 0;
  (*(void (**)(void))(**(void **)a3 + 16))();
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 221) = 0;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_WORD *)(a1 + 192) = 0;
  return a1;
}

void sub_100EAB654(_Unwind_Exception *a1)
{
  sub_100D77C9C((void *)v1 + 10);
  unint64_t v5 = (std::__shared_weak_count *)*((void *)v1 + 9);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v1 + 7);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger(v3);
  sub_100087E88(v2);
  LASDDatabaseIDSInterface::~LASDDatabaseIDSInterface(v1);
  _Unwind_Resume(a1);
}

void sub_100EAB6DC(uint64_t a1, uint64_t a2)
{
  sub_100A0BD40(v4, a2);
  v4[3] = a1;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAB7E0(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  unint64_t v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAB904(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EAB9E4(uint64_t a1)
{
  uint64_t v4 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      (*(void (**)(void))(**(void **)(a1 + 112) + 56))(*(void *)(a1 + 112));
      sub_100EABC70(a1);
      return;
    }
    BOOL v2 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v2 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_100EACF58;
  block[3] = &unk_101A677F0;
  void block[4] = a1 + 8;
  block[5] = &v4;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_sync(v3, block);
  }
  else {
    dispatch_async_and_wait(v3, block);
  }
}

void sub_100EABAD4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1003C5AEC((uint64_t)&v8, a2);
        unint64_t v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100EABC2C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EABC44(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EABC60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100EABC70(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 167);
  if (v2 < 0)
  {
    if (!*(void *)(a1 + 152)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 167))
  {
    return;
  }
  uint64_t v3 = (void *)(a1 + 144);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a1 + 144);
    if (v2 < 0) {
      uint64_t v5 = (void *)*v3;
    }
    int v10 = 136315138;
    uint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Clearing out the directory %s where databases were previously received", (uint8_t *)&v10, 0xCu);
  }
  uint64_t v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), a1 + 144);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 167) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      uint64_t v9 = strerror(v7);
      int v10 = 136315394;
      uint64_t v11 = v3;
      __int16 v12 = 2080;
      OsLogContext v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Could not remove %s directory: %s", (uint8_t *)&v10, 0x16u);
    }
  }
  else if (*(char *)(a1 + 167) < 0)
  {
    **(unsigned char **)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 144) = 0;
    *(unsigned char *)(a1 + 167) = 0;
  }
}

void sub_100EABE08(uint64_t a1)
{
  sub_100EABE40(a1);

  operator delete();
}

void sub_100EABE40(uint64_t a1)
{
  *(void *)a1 = off_101A67608;
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  char v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100D77C9C((void *)(a1 + 80));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  LASDDatabaseIDSInterface::~LASDDatabaseIDSInterface((LASDDatabaseIDSInterface *)a1);
}

void sub_100EABF0C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EABFD8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100EAC0B0);
  __cxa_rethrow();
}

void sub_100EAC000(_Unwind_Exception *a1)
{
}

void sub_100EAC018(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EAC050(uint64_t a1)
{
}

uint64_t sub_100EAC06C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EAC0B0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t *sub_100EAC0DC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(v1 + 24);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Database version updated", buf, 2u);
  }
  sub_100EABC70(v2);
  (***(void (****)(void, uint64_t))(v2 + 112))(*(void *)(v2 + 112), v1);
  sub_100EAC1B0(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100EAC194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EAC1B0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A0AF80(v1, *(char **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EAC204(void **a1)
{
  uint64_t v1 = *a1;
  __int16 v12 = a1;
  OsLogContext v13 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstapping", buf, 2u);
  }
  uint64_t v4 = v2[14];
  uint64_t v5 = v1[1];
  dispatch_group_t group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)v1[3];
  uint64_t v14 = v1[2];
  uint64_t v15 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v7 = (std::__shared_weak_count *)v2[2];
  if (!v7 || (v8 = v2[1], (uint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  int v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  *(void *)long long buf = off_101A67820;
  uint64_t v18 = v8;
  uint64_t v19 = v10;
  char v20 = buf;
  (*(void (**)(uint64_t, dispatch_group_t *, uint64_t *, uint8_t *))(*(void *)v4 + 40))(v4, &group, &v14, buf);
  sub_100A0AEFC(buf);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100EAC3F4((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100EAC3A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_group_t group, uint64_t a15)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100EAC3F4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAC3F4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(NSObject **)(v1 + 8);
    if (v3)
    {
      dispatch_group_leave(v3);
      uint64_t v4 = *(NSObject **)(v1 + 8);
      if (v4) {
        dispatch_release(v4);
      }
    }
    operator delete();
  }
  return result;
}

void sub_100EAC460(unint64_t **a1)
{
  unint64_t v1 = **a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v1 + 48));
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "38CellularPlanIDSServiceManagerInterface";
  if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  v24[0] = (unint64_t)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, v24);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
LABEL_9:
      (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v10 + 16))(v28, v10);
      long long v12 = *(_OWORD *)v28;
      memset(v28, 0, sizeof(v28));
      OsLogContext v13 = *(std::__shared_weak_count **)(v1 + 136);
      *(_OWORD *)(v1 + 128) = v12;
      if (v13)
      {
        sub_10004D2C8(v13);
        if (*(void *)&v28[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v28[8]);
        }
      }
      if ((v11 & 1) == 0) {
        sub_10004D2C8(v9);
      }
      if (*(void *)(v1 + 128))
      {
        (*(void (**)(void))(**(void **)(v1 + 112) + 48))(*(void *)(v1 + 112));
        uint64_t v14 = *(std::__shared_weak_count **)(v1 + 16);
        if (!v14 || (unint64_t v15 = *(void *)(v1 + 8), (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v17 = v16;
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v20 = *(void *)(v1 + 128);
        *(void *)os_log_t v28 = 0xF000E000D000CLL;
        do
        {
          unint64_t v21 = *(unsigned __int16 *)&v28[v18];
          if (v21 >= 0x10) {
            sub_1000C14F0("bitset set argument out of range");
          }
          v19 |= 1 << v21;
          v18 += 2;
        }
        while (v18 != 8);
        v26[4] = v1;
        *(void *)long long buf = v19;
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 0x40000000;
        v26[2] = sub_100EAC8D8;
        v26[3] = &unk_101A67770;
        *(void *)os_log_t v28 = _NSConcreteStackBlock;
        *(void *)&v28[8] = 1174405120;
        uint64_t v29 = sub_100EACABC;
        uint64_t v30 = &unk_101A67790;
        unint64_t v31 = v1;
        unint64_t v32 = v15;
        unint64_t v33 = v17;
        atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v24[0] = (unint64_t)_NSConcreteStackBlock;
        v24[1] = 1174405120;
        uint64_t v24[2] = (unint64_t)sub_100EACC54;
        v24[3] = (unint64_t)&unk_101A677C0;
        v24[4] = v1;
        void v24[5] = v15;
        uint64_t v25 = v17;
        atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        if (((*(uint64_t (**)(uint64_t, const char *, uint8_t *, void *, uint8_t *, unint64_t *))(*(void *)v20 + 24))(v20, "LASDDatabaseIDSUtility", buf, v26, v28, v24) & 1) == 0)
        {
          uint64_t v22 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#E Failed to register IDS callbacks", buf, 2u);
          }
        }
        if (v25) {
          std::__shared_weak_count::__release_weak(v25);
        }
        if (v33) {
          std::__shared_weak_count::__release_weak(v33);
        }
        std::__shared_weak_count::__release_weak(v17);
      }
      else
      {
        uint64_t v23 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)os_log_t v28 = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E Can't start because IDS service not found", v28, 2u);
        }
      }
      operator delete();
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  goto LABEL_9;
}

void sub_100EAC854(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a31) {
    std::__shared_weak_count::__release_weak(a31);
  }
  std::__shared_weak_count::__release_weak(v31);
  operator delete();
}

uint64_t sub_100EAC8D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a2 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(v3 + 48));
  uint64_t v6 = ServiceMap;
  unint64_t v8 = v7;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v29 = v8;
  long long v12 = sub_10004D37C(&v6[1].__m_.__sig, &v29);
  if (v12)
  {
    uint64_t v14 = (GestaltUtilityInterface *)v12[3];
    OsLogContext v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v6);
  OsLogContext v13 = 0;
  char v15 = 1;
LABEL_9:
  int isIPhone = GestaltUtilityInterface::isIPhone(v14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (isIPhone) {
    return (v4 & 0xFFF80000) != 0;
  }
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v3 + 48));
  uint64_t v20 = v19;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unint64_t v21 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      unint64_t v7 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v19);
  unint64_t v29 = v7;
  char v24 = sub_10004D37C(&v20[1].__m_.__sig, &v29);
  if (!v24)
  {
    int v26 = 0;
    goto LABEL_20;
  }
  int v26 = (GestaltUtilityInterface *)v24[3];
  uint64_t v25 = (std::__shared_weak_count *)v24[4];
  if (!v25)
  {
LABEL_20:
    std::mutex::unlock(v20);
    uint64_t v25 = 0;
    char v27 = 1;
    goto LABEL_21;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v20);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
LABEL_21:
  unsigned int isWatch = GestaltUtilityInterface::isWatch(v26);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (HIWORD(v4) > 0xEu) {
    return isWatch;
  }
  else {
    return 0;
  }
}

void sub_100EACA90(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EACABC(void *a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        uint64_t v7 = *a2;
        uint64_t v8 = a2[1];
        memset(v10, 0, sizeof(v10));
        sub_1003C1BB8(v10, v7, v8, (v8 - v7) >> 6);
        uint64_t v9 = *(std::__shared_weak_count **)(v5 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100EACC3C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EACC54(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
          void v8[2] = *(void **)(a2 + 16);
        }
        if (*(char *)(a2 + 47) < 0)
        {
          sub_10004FC84(__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(a2 + 24);
          __p[2] = *(void **)(a2 + 40);
        }
        __int16 v10 = *(_WORD *)(a2 + 48);
        sub_10002FD9C(&v11, (const void **)(a2 + 56));
        sub_100119B5C(&v12, (const void **)(a2 + 64));
        *(void *)&void v13[6] = *(void *)(a2 + 78);
        *(void *)OsLogContext v13 = *(void *)(a2 + 72);
        uint64_t v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100EACF04(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 31) < 0) {
    operator delete(*v18);
  }
  sub_10006A6AC(a1);
}

void sub_100EACF58(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  (*(void (**)(void))(**(void **)(v1 + 112) + 56))(*(void *)(v1 + 112));

  sub_100EABC70(v1);
}

uint64_t *sub_100EACFB8(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  int v26 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v2 != v4)
  {
    while (!*(unsigned char *)(v2 + 24))
    {
      v2 += 64;
      if (v2 == v4) {
        goto LABEL_20;
      }
    }
  }
  if (v2 == v4)
  {
LABEL_20:
    int v17 = *(unsigned __int8 *)(v3 + 192);
    uint64_t v18 = *(NSObject **)(v3 + 40);
    BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v17)
    {
      uint64_t v20 = (void **)(v3 + 168);
      if (v19)
      {
        unint64_t v21 = (void *)(v3 + 168);
        if (*(char *)(v3 + 191) < 0) {
          unint64_t v21 = *v20;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Device with ID %s is in no longer in proximity", (uint8_t *)buf, 0xCu);
      }
      if (*(char *)(v3 + 191) < 0) {
        operator delete(*v20);
      }
      uint64_t v22 = (void **)(v3 + 200);
      *uint64_t v20 = 0;
      *(void *)(v3 + 176) = 0;
      *(_WORD *)(v3 + 192) = 0;
      *(void *)(v3 + 184) = 0;
      if (*(char *)(v3 + 223) < 0) {
        operator delete(*v22);
      }
      *uint64_t v22 = 0;
      *(void *)(v3 + 208) = 0;
      *(void *)(v3 + 221) = 0;
      *(void *)(v3 + 216) = 0;
      goto LABEL_53;
    }
    if (!v19) {
      goto LABEL_53;
    }
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    unsigned int v23 = "#N No device in proximity";
    goto LABEL_34;
  }
  std::string::operator=((std::string *)(v3 + 168), (const std::string *)v2);
  *(_WORD *)(v3 + 192) = *(_WORD *)(v2 + 24);
  std::string::operator=((std::string *)(v3 + 200), (const std::string *)(v2 + 32));
  int v5 = *(_DWORD *)(v2 + 56);
  *(unsigned char *)(v3 + 228) = *(unsigned char *)(v2 + 60);
  *(_DWORD *)(v3 + 224) = v5;
  uint64_t v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v7 = v3 + 168;
    if (*(char *)(v3 + 191) < 0) {
      std::string::size_type v7 = *(void *)(v3 + 168);
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device with ID %s is in proximity", (uint8_t *)buf, 0xCu);
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(v3 + 112) + 24))(*(void *)(v3 + 112), v2))
  {
    if (*(unsigned char *)(v3 + 192))
    {
      long long v36 = 0u;
      *(_OWORD *)uint64_t v37 = 0u;
      *(_DWORD *)&v37[20] = 0;
      memset(buf, 0, sizeof(buf));
      v37[8] = 2;
      *(void *)&v37[12] = 0x50000003CLL;
      std::string::operator=(buf, (const std::string *)(v3 + 168));
      *(_DWORD *)&v37[12] = 30;
      v37[8] = 2;
      int v8 = *(unsigned __int8 *)(v3 + 228);
      (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 112) + 8))(&__dst);
      sub_10110D34C((uint64_t)buf, v8, (const void **)&__dst.__r_.__value_.__l.__data_);
      sub_1000886C0((uint64_t)&__dst, (char *)__dst.__r_.__value_.__l.__size_);
      uint64_t v9 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v10 = sub_1005050C0((unsigned __int16)v36);
        unsigned int v11 = buf;
        if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v11 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
        WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sending the request message %s to device %s", (uint8_t *)&__dst, 0x16u);
      }
      long long v12 = *(std::__shared_weak_count **)(v3 + 16);
      if (!v12 || (uint64_t v13 = *(void *)(v3 + 8), (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      char v15 = v14;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      uint64_t v16 = *(void *)(v3 + 128);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = buf[0];
      }
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__p, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = buf[1];
      }
      __int16 v31 = v36;
      unint64_t v32 = (const void *)*((void *)&v36 + 1);
      if (*((void *)&v36 + 1)) {
        CFRetain(*((CFTypeRef *)&v36 + 1));
      }
      unint64_t v33 = *(const void **)v37;
      if (*(void *)v37) {
        CFRetain(*(CFTypeRef *)v37);
      }
      v34[0] = *(void *)&v37[8];
      *(void *)((char *)v34 + 6) = *(void *)&v37[14];
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 1174405120;
      v27[2] = sub_100EABAD4;
      v27[3] = &unk_101A67638;
      v27[4] = v3;
      v27[5] = v13;
      os_log_t v28 = v15;
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, std::string *, void *))(*(void *)v16 + 32))(v16, &__dst, v27);
      sub_1000FE824(&v33);
      sub_100030068(&v32);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (v28) {
        std::__shared_weak_count::__release_weak(v28);
      }
      std::__shared_weak_count::__release_weak(v15);
      sub_1000FE824((const void **)v37);
      sub_100030068((const void **)&v36 + 1);
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[1].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }
      goto LABEL_53;
    }
    uint64_t v18 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    unsigned int v23 = "#I Can't exchange version info as there is no device in proximity";
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)buf, 2u);
  }
LABEL_53:
  sub_1003C2D34((uint64_t *)&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100EAD508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v24);
  sub_1003C1D74(v25 - 160);
  sub_1003C2D34(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAD5A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v62 = a1;
  uint64_t v63 = v1;
  uint64_t v2 = v1 + 8;
  uint64_t v3 = *(void *)v1;
  int v4 = 2;
  switch(sub_10110E2B8(v1 + 8))
  {
    case 0u:
      uint64_t v50 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"kUnknown";
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#E Unhandled or Unknown message type %s", (uint8_t *)buf, 0xCu);
      }
      goto LABEL_149;
    case 1u:
      goto LABEL_113;
    case 2u:
      int v4 = 1;
LABEL_113:
      CFTypeID v51 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v52 = v1 + 32;
        if (*(char *)(v1 + 31) >= 0) {
          std::string::size_type v53 = v1 + 8;
        }
        else {
          std::string::size_type v53 = *(void *)(v1 + 8);
        }
        if (*(char *)(v1 + 55) < 0) {
          std::string::size_type v52 = *(void *)(v1 + 32);
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v53;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v52;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Received version info request from device %s, tx-id %s", (uint8_t *)buf, 0x16u);
      }
      memset(&__dst, 0, sizeof(__dst));
      sub_10110D73C(v1 + 8, &__dst);
      if (__dst.__r_.__value_.__r.__words[2])
      {
        (*(void (**)(void, uint64_t, std::string *))(**(void **)(v3 + 112) + 16))(*(void *)(v3 + 112), v1 + 8, &__dst);
        long long v77 = 0u;
        *(_OWORD *)CFBooleanRef v78 = 0u;
        *(_DWORD *)&v78[20] = 0;
        memset(buf, 0, sizeof(buf));
        v78[8] = 2;
        *(void *)&v78[12] = 0x50000003CLL;
        std::string::operator=(buf, (const std::string *)(v1 + 8));
        std::string::operator=(&buf[1], (const std::string *)(v1 + 32));
        *(_DWORD *)&v78[12] = 30;
        v78[8] = 2;
        (*(void (**)(std::string *__return_ptr))(**(void **)(v3 + 112) + 8))(&__p);
        sub_10110D34C((uint64_t)buf, v4, (const void **)&__p.__r_.__value_.__l.__data_);
        sub_1000886C0((uint64_t)&__p, (char *)__p.__r_.__value_.__l.__size_);
        uint64_t v54 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v55 = sub_1005050C0((unsigned __int16)v77);
          uint64_t v56 = buf;
          if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v56 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
          }
          if (*(char *)(v1 + 55) >= 0) {
            std::string::size_type v57 = v1 + 32;
          }
          else {
            std::string::size_type v57 = *(void *)(v1 + 32);
          }
          LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v55;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v56;
          HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
          v71.__r_.__value_.__r.__words[0] = v57;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Sending the response message %s to device %s, tx-id %s", (uint8_t *)&__p, 0x20u);
        }
        uint64_t v58 = *(void *)(v3 + 128);
        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = buf[0];
        }
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v71, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
        }
        else {
          std::string v71 = buf[1];
        }
        __int16 v72 = v77;
        unint64_t v73 = (const void *)*((void *)&v77 + 1);
        if (*((void *)&v77 + 1)) {
          CFRetain(*((CFTypeRef *)&v77 + 1));
        }
        uint64_t v74 = *(const void **)v78;
        if (*(void *)v78) {
          CFRetain(*(CFTypeRef *)v78);
        }
        v75[0] = *(void *)&v78[8];
        *(void *)((char *)v75 + 6) = *(void *)&v78[14];
        (*(void (**)(uint64_t, std::string *, void))(*(void *)v58 + 32))(v58, &__p, 0);
        sub_1000FE824(&v74);
        sub_100030068(&v73);
        if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v71.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        sub_1000FE824((const void **)v78);
        sub_100030068((const void **)&v77 + 1);
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[1].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[0].__r_.__value_.__l.__data_);
        }
      }
      else
      {
        uint64_t v59 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#E Received invalid version info dictionary", (uint8_t *)buf, 2u);
        }
      }
      sub_1000886C0((uint64_t)&__dst, (char *)__dst.__r_.__value_.__l.__size_);
      goto LABEL_149;
    case 3u:
    case 4u:
      int v5 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = sub_1005050C0(*(unsigned __int16 *)(v1 + 56));
        std::string::size_type v9 = *(void *)(v1 + 32);
        std::string::size_type v8 = v1 + 32;
        std::string::size_type v7 = v9;
        if (*(char *)(v8 - 1) >= 0) {
          std::string::size_type v10 = v2;
        }
        else {
          std::string::size_type v10 = *(void *)(v8 - 24);
        }
        if (*(char *)(v8 + 23) >= 0) {
          std::string::size_type v7 = v8;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v10;
        HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
        buf[1].__r_.__value_.__r.__words[0] = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received database file message %s from device %s, tx-id %s", (uint8_t *)buf, 0x20u);
      }
      uint64_t v67 = 0;
      v68[0] = 0;
      v68[1] = 0;
      sub_10110DE1C(v2, &v67);
      CFNumberRef v65 = 0;
      uint64_t v66 = 0;
      uint64_t v64 = &v65;
      unsigned int v11 = v67;
      if (v67 == v68) {
        goto LABEL_109;
      }
      long long v12 = &buf[1];
      uint64_t v13 = (std::string::size_type *)(v3 + 144);
      break;
    default:
      goto LABEL_149;
  }
  do
  {
    if (*((char *)v11 + 87) < 0) {
      uint64_t v14 = v11[9];
    }
    else {
      uint64_t v14 = (void *)*((unsigned __int8 *)v11 + 87);
    }
    char v15 = (int *)(v11 + 4);
    if (v14)
    {
      memset(&__p, 0, sizeof(__p));
      int v16 = *(char *)(v3 + 167);
      if (v16 < 0)
      {
        if (*(void *)(v3 + 152))
        {
LABEL_17:
          int v17 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v18 = v3 + 144;
            if (v16 < 0) {
              std::string::size_type v18 = *v13;
            }
            LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Already have a directory created at %s", (uint8_t *)buf, 0xCu);
            LOBYTE(v16) = *(unsigned char *)(v3 + 167);
          }
          if ((v16 & 0x80) != 0)
          {
LABEL_22:
            sub_10004FC84(&__dst, *(void **)(v3 + 144), *(void *)(v3 + 152));
            goto LABEL_31;
          }
LABEL_30:
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)v13;
          __dst.__r_.__value_.__r.__words[2] = *(void *)(v3 + 160);
LABEL_31:
          int v23 = *v15;
          char v24 = std::string::append(&__dst, "/", 1uLL);
          uint64_t v25 = std::string::append(v24, "lasd", 4uLL);
          int v26 = "gsm";
          switch(v23)
          {
            case 1:
              int v26 = "umts";
              break;
            case 2:
              int v26 = "cdma";
              break;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_36;
            case 4:
              int v26 = "lte";
              break;
            case 8:
              break;
            default:
              if (v23 == 16)
              {
                int v26 = "scdma";
              }
              else if (v23 == 32)
              {
                int v26 = "nr";
              }
              else
              {
LABEL_36:
                int v26 = "unknown";
              }
              break;
          }
          size_t v27 = strlen(v26);
          os_log_t v28 = std::string::append(v25, v26, v27);
          unint64_t v29 = std::string::append(v28, ".db", 3uLL);
          if (SHIBYTE(v29->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(&__p, v29->__r_.__value_.__l.__data_, v29->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          __int16 v31 = v11 + 8;
          unint64_t v32 = v11 + 8;
          if (*((char *)v11 + 87) < 0) {
            unint64_t v32 = (void *)*v31;
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          int v34 = (*(uint64_t (**)(void, void *, std::string *))(**(void **)(v3 + 64) + 16))(*(void *)(v3 + 64), v32, p_p);
          if (v34)
          {
            uint64_t v35 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              int v43 = *v15;
              int v44 = *v15 - 1;
              unsigned int v45 = "gsm";
              switch(v44)
              {
                case 0:
                  unsigned int v45 = "umts";
                  break;
                case 1:
                  unsigned int v45 = "cdma";
                  break;
                case 2:
                case 4:
                case 5:
                case 6:
                  goto LABEL_85;
                case 3:
                  unsigned int v45 = "lte";
                  break;
                case 7:
                  break;
                default:
                  if (v43 == 16)
                  {
                    unsigned int v45 = "scdma";
                  }
                  else if (v43 == 32)
                  {
                    unsigned int v45 = "nr";
                  }
                  else
                  {
LABEL_85:
                    unsigned int v45 = "unknown";
                  }
                  break;
              }
              CFNumberRef v61 = v12;
              if (*((char *)v11 + 87) < 0) {
                __int16 v31 = (void *)*v31;
              }
              int v46 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
              std::string::size_type v47 = __p.__r_.__value_.__r.__words[0];
              long long v48 = strerror(v34);
              LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315906;
              uint64_t v49 = &__p;
              if (v46 < 0) {
                uint64_t v49 = (std::string *)v47;
              }
              *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
              WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v31;
              HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
              buf[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
              LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v48;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Moving %s database file from %s to %s failed with err: (%s)", (uint8_t *)buf, 0x2Au);
              long long v12 = v61;
            }
LABEL_53:
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            goto LABEL_55;
          }
          uint64_t v39 = (void **)(v11 + 5);
          if (*((char *)v11 + 63) < 0)
          {
            unint64_t v40 = (unint64_t)v11[6];
            if (v40)
            {
              memset(buf, 0, sizeof(buf));
              sub_10004FC84(buf, *v39, v40);
              goto LABEL_67;
            }
          }
          else if (*((unsigned char *)v11 + 63))
          {
            v12->__r_.__value_.__l.__size_ = 0;
            v12->__r_.__value_.__r.__words[2] = 0;
            v12->__r_.__value_.__r.__words[0] = 0;
            buf[0].__r_.__value_.__r.__words[2] = (std::string::size_type)v11[7];
            *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = *(_OWORD *)v39;
LABEL_67:
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(v12, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            }
            else {
              *long long v12 = __p;
            }
            sub_100A0B5C4((uint64_t)&v64, (int *)v11 + 8, (_DWORD *)v11 + 8, (long long *)buf);
            if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf[1].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf[0].__r_.__value_.__l.__data_);
            }
            goto LABEL_53;
          }
          uint64_t v41 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            uint64_t v42 = "gsm";
            switch(*v15)
            {
              case 1:
                uint64_t v42 = "umts";
                break;
              case 2:
                uint64_t v42 = "cdma";
                break;
              case 3:
              case 5:
              case 6:
              case 7:
                goto LABEL_102;
              case 4:
                uint64_t v42 = "lte";
                break;
              case 8:
                break;
              default:
                if ("gsm" == 16)
                {
                  uint64_t v42 = "scdma";
                }
                else if ("gsm" == 32)
                {
                  uint64_t v42 = "nr";
                }
                else
                {
LABEL_102:
                  uint64_t v42 = "unknown";
                }
                break;
            }
            LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Incoming %s database has version info missing so it can't be used for updating", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_53;
        }
      }
      else if (*(unsigned char *)(v3 + 167))
      {
        goto LABEL_17;
      }
      strcpy((char *)buf, "/tmp/LASDTemp.XXXXXX");
      unint64_t v21 = mkdtemp((char *)buf);
      sub_10003ED78((std::string *)(v3 + 144), v21);
      std::string::size_type v22 = v3 + 144;
      if (*(char *)(v3 + 167) < 0) {
        std::string::size_type v22 = *v13;
      }
      (*(void (**)(void, std::string::size_type, uint64_t, uint64_t))(**(void **)(v3 + 64) + 56))(*(void *)(v3 + 64), v22, 511, 1);
      if (*(char *)(v3 + 167) < 0) {
        goto LABEL_22;
      }
      goto LABEL_30;
    }
    BOOL v19 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = "gsm";
      switch(*v15)
      {
        case 1:
          uint64_t v20 = "umts";
          break;
        case 2:
          uint64_t v20 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_86;
        case 4:
          uint64_t v20 = "lte";
          break;
        case 8:
          break;
        default:
          if ("gsm" == 16)
          {
            uint64_t v20 = "scdma";
          }
          else if ("gsm" == 32)
          {
            uint64_t v20 = "nr";
          }
          else
          {
LABEL_86:
            uint64_t v20 = "unknown";
          }
          break;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Incoming %s database has file resource missing", (uint8_t *)buf, 0xCu);
    }
LABEL_55:
    long long v36 = v11[1];
    if (v36)
    {
      do
      {
        uint64_t v37 = (void **)v36;
        long long v36 = (void *)*v36;
      }
      while (v36);
    }
    else
    {
      do
      {
        uint64_t v37 = (void **)v11[2];
        BOOL v38 = *v37 == v11;
        unsigned int v11 = v37;
      }
      while (!v38);
    }
    unsigned int v11 = v37;
  }
  while (v37 != v68);
  if (v66) {
    (*(void (**)(void, void ***))(**(void **)(v3 + 112) + 32))(*(void *)(v3 + 112), &v64);
  }
LABEL_109:
  sub_10019D5B8((uint64_t)&v64, v65);
  sub_10019D5B8((uint64_t)&v67, v68[0]);
LABEL_149:
  sub_1003C32EC(&v63);
  return sub_100046B58((uint64_t *)&v62);
}

void sub_100EAE1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char *a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74(v37 - 192);
  sub_1000886C0((uint64_t)&a25, a26);
  sub_1003C32EC(&a16);
  sub_100046B58(&a15);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAE380(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  if (v3 == 2)
  {
    int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = sub_1005050E8(*(unsigned __int8 *)(v1 + 16));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Received an IDS error : %s while exchanging version info", buf, 0xCu);
    }
  }
  else
  {
    long long v19 = 0u;
    memset(v20, 0, 24);
    memset(__p, 0, sizeof(__p));
    *(_OWORD *)long long buf = 0u;
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    if (*(char *)(v1 + 39) < 0)
    {
      sub_10004FC84(buf, *(void **)(v1 + 16), *(void *)(v1 + 24));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(v1 + 16);
      __p[0] = *(void **)(v1 + 32);
    }
    if (*(char *)(v1 + 63) < 0)
    {
      sub_10004FC84(&__p[1], *(void **)(v1 + 40), *(void *)(v1 + 48));
    }
    else
    {
      *(_OWORD *)&__p[1] = *(_OWORD *)(v1 + 40);
      __p[3] = *(void **)(v1 + 56);
    }
    LOWORD(v19) = *(_WORD *)(v1 + 64);
    sub_10002FD9C((const void **)&v19 + 1, (const void **)(v1 + 72));
    sub_100119B5C((const void **)v20, (const void **)(v1 + 80));
    *((void *)&v20[0] + 1) = *(void *)(v1 + 88);
    *(void *)((char *)v20 + 14) = *(void *)(v1 + 94);
    uint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v7 = sub_1005050C0((unsigned __int16)v19);
      if (SHIBYTE(__p[0]) >= 0) {
        std::string::size_type v8 = buf;
      }
      else {
        std::string::size_type v8 = *(uint8_t **)buf;
      }
      if (SHIBYTE(__p[3]) >= 0) {
        std::string::size_type v9 = &__p[1];
      }
      else {
        std::string::size_type v9 = (void **)__p[1];
      }
      *(_DWORD *)std::string __dst = 136315650;
      *(void *)&__dst[4] = v7;
      *(_WORD *)&__dst[12] = 2080;
      *(void *)&__dst[14] = v8;
      *(_WORD *)&__dst[22] = 2080;
      std::string::size_type v22 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received version info response %s from device %s, tx-id %s", __dst, 0x20u);
    }
    memset(__dst, 0, sizeof(__dst));
    sub_10110D73C((uint64_t)buf, __dst);
    if (*(void *)&__dst[16])
    {
      (*(void (**)(void, uint8_t *, uint8_t *))(**(void **)(v2 + 112) + 16))(*(void *)(v2 + 112), buf, __dst);
    }
    else
    {
      std::string::size_type v10 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E Version info is invalid", v16, 2u);
      }
    }
    sub_1000886C0((uint64_t)__dst, *(char **)&__dst[8]);
    uint64_t v11 = *(void *)(v2 + 128);
    if (SHIBYTE(__p[3]) < 0)
    {
      sub_10004FC84(__dst, __p[1], (unint64_t)__p[2]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)&__p[1];
      *(void **)&__dst[16] = __p[3];
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 40))(v11, __dst);
    if ((char)__dst[23] < 0) {
      operator delete(*(void **)__dst);
    }
    sub_1000FE824((const void **)v20);
    sub_100030068((const void **)&v19 + 1);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1003C5A9C(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100EAE708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1003C5A9C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAE7A0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string::size_type v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(const std::string **)v1;
  if (*(unsigned char *)(*(void *)v1 + 192))
  {
    *(_OWORD *)CFTypeRef cf = 0u;
    *(_OWORD *)int v16 = 0u;
    *(_DWORD *)&v16[20] = 0;
    memset(v14, 0, sizeof(v14));
    uint8_t v16[8] = 2;
    *(void *)&v16[12] = 0x50000003CLL;
    std::string::operator=(v14, v2 + 7);
    *(_DWORD *)&v16[12] = 300;
    uint8_t v16[8] = 2;
    int v3 = v2[9].__r_.__value_.__s.__data_[12];
    if (*(char *)(v1 + 55) < 0)
    {
      sub_10004FC84(__p, *(void **)(v1 + 32), *(void *)(v1 + 40));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v1 + 32);
      uint64_t v13 = *(void *)(v1 + 48);
    }
    sub_10110DBC0((uint64_t)v14, v3, (const void **)(v1 + 8), (const char *)__p);
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
    int v5 = v2[1].__r_.__value_.__r.__words[2];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = sub_1005050C0(LOWORD(cf[0]));
      std::string::size_type v7 = v14;
      if ((v14[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v7 = (std::string *)v14[0].__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sending the message %s to device %s", (uint8_t *)&buf, 0x16u);
    }
    std::string::size_type size = v2[5].__r_.__value_.__l.__size_;
    if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, v14[0].__r_.__value_.__l.__data_, v14[0].__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v14[0];
    }
    if (SHIBYTE(v14[1].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v18, v14[1].__r_.__value_.__l.__data_, v14[1].__r_.__value_.__l.__size_);
    }
    else {
      std::string v18 = v14[1];
    }
    __int16 v19 = (__int16)cf[0];
    CFTypeRef v20 = cf[1];
    if (cf[1]) {
      CFRetain(cf[1]);
    }
    unint64_t v21 = *(const void **)v16;
    if (*(void *)v16) {
      CFRetain(*(CFTypeRef *)v16);
    }
    v22[0] = *(void *)&v16[8];
    *(void *)((char *)v22 + 6) = *(void *)&v16[14];
    (*(void (**)(std::string::size_type, std::string *, void))(*(void *)size + 32))(size, &buf, 0);
    sub_1000FE824(&v21);
    sub_100030068(&v20);
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    sub_1000FE824((const void **)v16);
    sub_100030068(&cf[1]);
    if (SHIBYTE(v14[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14[1].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v14[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14[0].__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int v4 = v2[1].__r_.__value_.__r.__words[2];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Can't send database as there is no device in proximity", (uint8_t *)v14, 2u);
    }
  }
  sub_100EAEB20(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100EAEAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74((uint64_t)&a18);
  sub_100EAEB20(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAEB20(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    sub_1000886C0(v1 + 8, *(char **)(v1 + 16));
    operator delete();
  }
  return result;
}

void *sub_100EAEB84(void *a1)
{
  *a1 = off_101A67820;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100EAEBD0(void *a1)
{
  *a1 = off_101A67820;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100EAEC3C(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A67820;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100EAEC98(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A67820;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EAECD0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100EAECE0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100EAED20(uint64_t a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)a2[1];
  std::string::size_type v9 = (void **)*a2;
  std::string::size_type v10 = v4;
  if (a2[2])
  {
    void v4[2] = &v10;
    *a2 = v3;
    void *v3 = 0;
    a2[2] = 0;
  }
  else
  {
    std::string::size_type v9 = &v10;
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v12 = *(void *)(a1 + 8);
        uint64_t v13 = v6;
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100A0B7BC(&v14, (uint64_t)&v9);
        std::string::size_type v8 = *(std::__shared_weak_count **)(v7 + 16);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
  sub_10019D5B8((uint64_t)&v9, v10);
}

void sub_100EAEEF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v13);
  sub_10019D5B8((uint64_t)&a9, a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100EAEF28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EAEF68()
{
}

uint64_t *sub_100EAEF74(void **a1)
{
  uint64_t v1 = *a1;
  int v17 = a1;
  std::string v18 = v1;
  uint64_t v2 = (void *)v1[2];
  uint64_t v3 = v1 + 3;
  if (v2 != v1 + 3)
  {
    uint64_t v4 = *v1;
    do
    {
      if (*((char *)v2 + 87) < 0)
      {
        if (v2[9])
        {
LABEL_5:
          int v5 = *((char *)v2 + 63);
          if (v5 < 0) {
            uint64_t v6 = v2[6];
          }
          else {
            uint64_t v6 = *((unsigned __int8 *)v2 + 63);
          }
          uint64_t v7 = *(NSObject **)(v4 + 40);
          if (v6)
          {
            std::string::size_type v8 = v2 + 5;
            if (os_log_type_enabled(*(os_log_t *)(v4 + 40), OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v9 = "gsm";
              switch(*((_DWORD *)v2 + 8))
              {
                case 1:
                  std::string::size_type v9 = "umts";
                  goto LABEL_24;
                case 2:
                  std::string::size_type v9 = "cdma";
                  goto LABEL_24;
                case 3:
                case 5:
                case 6:
                case 7:
                  goto LABEL_20;
                case 4:
                  std::string::size_type v9 = "lte";
                  goto LABEL_24;
                case 8:
                  goto LABEL_24;
                default:
                  if ("gsm" == 16)
                  {
                    std::string::size_type v9 = "scdma";
                  }
                  else if ("gsm" == 32)
                  {
                    std::string::size_type v9 = "nr";
                  }
                  else
                  {
LABEL_20:
                    std::string::size_type v9 = "unknown";
                  }
LABEL_24:
                  uint64_t v11 = v2 + 5;
                  if (v5 < 0) {
                    uint64_t v11 = (void *)*v8;
                  }
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v9;
                  __int16 v24 = 2080;
                  uint64_t v25 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Attempting to send %s database version %s", buf, 0x16u);
                  LOBYTE(v5) = *((unsigned char *)v2 + 63);
                  break;
              }
            }
            int v21 = *((_DWORD *)v2 + 8);
            if ((v5 & 0x80) != 0)
            {
              sub_10004FC84(v22, (void *)v2[5], v2[6]);
            }
            else
            {
              *(_OWORD *)std::string::size_type v22 = *(_OWORD *)v8;
              void v22[2] = *((void **)v2 + 7);
            }
            v20[0] = 0;
            v20[1] = 0;
            __int16 v19 = v20;
            sub_100A0BB4C(&v19, v20, &v21, (uint64_t)&v21);
            *(void *)std::string buf = v4;
            sub_100A0BA68((uint64_t *)&buf[8], (uint64_t)&v19);
            if (*((char *)v2 + 87) < 0)
            {
              sub_10004FC84(__p, (void *)v2[8], v2[9]);
            }
            else
            {
              *(_OWORD *)std::string __p = *((_OWORD *)v2 + 4);
              __p[2] = *((void **)v2 + 10);
            }
            uint64_t v12 = *(std::__shared_weak_count **)(v4 + 16);
            if (v12)
            {
              if (std::__shared_weak_count::lock(v12)) {
                operator new();
              }
            }
            sub_100088B9C();
          }
          goto LABEL_14;
        }
      }
      else if (*((unsigned char *)v2 + 87))
      {
        goto LABEL_5;
      }
      uint64_t v7 = *(NSObject **)(v4 + 40);
LABEL_14:
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        std::string::size_type v10 = "gsm";
        switch(*((_DWORD *)v2 + 8))
        {
          case 1:
            std::string::size_type v10 = "umts";
            break;
          case 2:
            std::string::size_type v10 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_46;
          case 4:
            std::string::size_type v10 = "lte";
            break;
          case 8:
            break;
          default:
            if ("gsm" == 16)
            {
              std::string::size_type v10 = "scdma";
            }
            else if ("gsm" == 32)
            {
              std::string::size_type v10 = "nr";
            }
            else
            {
LABEL_46:
              std::string::size_type v10 = "unknown";
            }
            break;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Not sending %s database because there is no associated file/version", buf, 0xCu);
      }
      uint64_t v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          uint64_t v2 = v14;
        }
        while (!v15);
      }
      uint64_t v2 = v14;
    }
    while (v14 != v3);
  }
  sub_100EAF4EC((uint64_t *)&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_100EAF420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int16 a16, char a17, char a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,char *a32)
{
  sub_1000886C0(v32, a32);
  sub_1000886C0((uint64_t)&a16, a19);
  if (a29 < 0) {
    operator delete(__p);
  }
  sub_100EAF4EC(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EAF4EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10019D5B8(v1 + 16, *(void **)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100EAF54C(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = sub_100E7F0A4(a1, a2);
  *(void *)uint64_t v3 = off_101A678B0;
  *(_OWORD *)(v3 + 272) = 0u;
  *(_OWORD *)(v3 + 288) = 0u;
  *(_OWORD *)(v3 + 304) = 0u;
  *(_DWORD *)(v3 + 328) = 2;
  sub_100E7F3F8(v3);
  *(_OWORD *)(a1 + 254) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  *(void *)(a1 + 304) = *(void *)(a1 + 296);
  *(_DWORD *)(a1 + 320) = 0;
  *(unsigned char *)(a1 + 324) = 0;
  uint64_t v4 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    int v7 = 136315394;
    uint64_t v8 = v6;
    __int16 v9 = 2080;
    std::string::size_type v10 = ", ";
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%screated AkaDigestAuthScheme", (uint8_t *)&v7, 0x16u);
  }
  return a1;
}

void sub_100EAF69C(_Unwind_Exception *a1)
{
  uint64_t v4 = (void *)v1[37];
  if (v4)
  {
    v1[38] = v4;
    operator delete(v4);
  }
  int v5 = *v2;
  if (*v2)
  {
    v1[35] = v5;
    operator delete(v5);
  }
  sub_100EAF6D0((uint64_t)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EAF6D0(uint64_t a1)
{
  *(void *)a1 = off_101A650A8;
  uint64_t v3 = (void **)(a1 + 168);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  uint64_t v3 = (void **)(a1 + 88);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  *(void *)a1 = off_101A2EB80;
  sub_100343DF4(a1 + 16);
  return a1;
}

double sub_100EAF78C(uint64_t a1)
{
  sub_100E7F3F8(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 254) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  *(void *)(a1 + 304) = *(void *)(a1 + 296);
  *(_DWORD *)(a1 + 320) = 0;
  *(unsigned char *)(a1 + 324) = 0;
  return result;
}

uint64_t sub_100EAF7D8(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 304) = *(void *)(a1 + 296);
  *(unsigned char *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  ctu::base64::decode();
  uint64_t v4 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    if (*((char *)a2 + 23) >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = ", ";
    __int16 v12 = 2080;
    uint64_t v13 = v7;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "#E %s%sBase64 decode failed for nonce: %s", buf, 0x20u);
  }
  return 0;
}

void sub_100EAFA28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100EAFA54(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 320);
  if (*(unsigned char *)(a1 + 320))
  {
    __int16 v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10011FDF0((unint64_t *)&v12, *(void *)(a1 + 304) - *(void *)(a1 + 296) + 32);
    *__int16 v12 = *(_OWORD *)(a1 + 192);
    int v5 = v12;
    v12[1] = *(_OWORD *)(a1 + 208);
    uint64_t v6 = *(unsigned char **)(a1 + 296);
    int v7 = *(unsigned char **)(a1 + 304);
    if (v7 != v6) {
      memmove(v5 + 2, v6, v7 - v6);
    }
    ctu::base64::encode();
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    *(_OWORD *)a2 = v10;
    uint64_t v8 = v12;
    *(void *)(a2 + 16) = v11;
    if (v8)
    {
      uint64_t v13 = v8;
      operator delete(v8);
    }
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  return v3 != 0;
}

void sub_100EAFB3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EAFB5C(uint64_t a1, uint64_t a2, int a3)
{
  sub_100E7F538(a1, a2, a3);
  if (a3 && *(unsigned char *)(a1 + 321))
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v14 = 0;
    sub_1001E7940(__p, (const void *)(a1 + 224), a1 + 238, 0xEuLL);
    ctu::base64::encode();
    long long v30 = v33;
    uint64_t v31 = v34;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)int v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v14 = 0u;
    sub_10004DE24((uint64_t)__p);
    LOBYTE(v33) = 34;
    uint64_t v6 = sub_10004B96C(__p, (uint64_t)&v33, 1);
    if (v31 >= 0) {
      int v7 = &v30;
    }
    else {
      int v7 = (long long *)v30;
    }
    if (v31 >= 0) {
      uint64_t v8 = HIBYTE(v31);
    }
    else {
      uint64_t v8 = *((void *)&v30 + 1);
    }
    uint64_t v9 = sub_10004B96C(v6, (uint64_t)v7, v8);
    LOBYTE(v33) = 34;
    sub_10004B96C(v9, (uint64_t)&v33, 1);
    sub_10004BC98((uint64_t)&__p[1], &v33);
    uint64_t v32 = "auts";
    long long v10 = sub_100A3C118(a2, "auts", (uint64_t)&unk_10144E20E, (long long **)&v32);
    uint64_t v11 = v10 + 40;
    if ((char)v10[63] < 0) {
      operator delete(*(void **)v11);
    }
    *(_OWORD *)uint64_t v11 = v33;
    *((void *)v11 + 2) = v34;
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)v30);
    }
  }
  return 1;
}

void sub_100EAFDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(char *)(v9 - 33) < 0) {
    operator delete(*(void **)(v9 - 56));
  }
  sub_1000C937C((uint64_t)&a9);
  if (*(char *)(v9 - 73) < 0) {
    operator delete(*(void **)(v9 - 96));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EAFE14(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 320);
}

uint64_t sub_100EAFE1C(uint64_t a1, std::string *this)
{
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  if (size)
  {
    if (std::string::compare(this, 0, 3uLL, "AKA")) {
      return 0;
    }
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      if (this->__r_.__value_.__l.__size_ < 7) {
        return 0;
      }
      uint64_t v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      uint64_t v6 = this;
      if (HIBYTE(this->__r_.__value_.__r.__words[2]) < 7u) {
        return 0;
      }
    }
    *(_DWORD *)(a1 + 328) = v6->__r_.__value_.__s.__data_[4] - 48;
    std::string::basic_string(&v8, this, 6uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v9);
    int v7 = (void **)(a1 + 136);
    if (*(char *)(a1 + 159) < 0) {
      operator delete(*v7);
    }
    *(_OWORD *)int v7 = *(_OWORD *)&v8.__r_.__value_.__l.__data_;
    *(void *)(a1 + 152) = *((void *)&v8.__r_.__value_.__l + 2);
  }
  else
  {
    *(_DWORD *)(a1 + 328) = 2;
    if (*(char *)(a1 + 159) < 0)
    {
      **(unsigned char **)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 136) = 0;
      *(unsigned char *)(a1 + 159) = 0;
    }
  }
  return 1;
}

uint64_t sub_100EAFF28(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(char *)(result + 159) < 0)
  {
    if (*(void *)(result + 144)) {
      goto LABEL_3;
    }
LABEL_15:
    if (*(char *)(a2 + 23) < 0)
    {
      **(unsigned char **)a2 = 0;
      *(void *)(a2 + 8) = 0;
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 23) = 0;
    }
    return result;
  }
  if (!*(unsigned char *)(result + 159)) {
    goto LABEL_15;
  }
LABEL_3:
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v11, 0, sizeof(v11));
  sub_10004DE24((uint64_t)v11);
  sub_10004B96C(v11, (uint64_t)"AKAv", 4);
  uint64_t v4 = (void *)std::ostream::operator<<();
  LOBYTE(v9) = 45;
  int v5 = sub_10004B96C(v4, (uint64_t)&v9, 1);
  int v6 = *(char *)(v3 + 159);
  if (v6 >= 0) {
    uint64_t v7 = v3 + 136;
  }
  else {
    uint64_t v7 = *(void *)(v3 + 136);
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(v3 + 159);
  }
  else {
    uint64_t v8 = *(void *)(v3 + 144);
  }
  sub_10004B96C(v5, v7, v8);
  sub_10004BC98((uint64_t)v11 + 8, &v9);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v9;
  *(void *)(a2 + 16) = v10;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100EB0130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

char **sub_100EB0148(char **result, char **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if ((unint64_t)(v4 - v3 - 17) >= 0xFFFFFFFFFFFFFFF3)
  {
    int v6 = result;
    result += 34;
    if (result != a2) {
      double result = (char **)sub_10006E4A8(result, v3, v4, v4 - v3);
    }
    *(_WORD *)((char *)v6 + 321) = 256;
  }
  return result;
}

uint64_t sub_100EB019C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v12 = a3;
    }
    else {
      uint64_t v12 = *(void *)a3;
    }
    if (*(char *)(a4 + 23) >= 0) {
      uint64_t v13 = a4;
    }
    else {
      uint64_t v13 = *(void *)a4;
    }
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = ", ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v11;
    *(_WORD *)long long v17 = 2080;
    *(void *)&v17[2] = v12;
    *(_WORD *)&v17[10] = 2080;
    *(void *)&v17[12] = v13;
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#D %s%scomputeResponse, '%s', '%s', '%s'", buf, 0x34u);
  }
  if (*(unsigned char *)(a1 + 321))
  {
    buf[0] = 0;
    sub_100E8024C(a1, (uint64_t *)a2, (uint64_t *)a3, (uint64_t *)a4, (ctu *)buf, 0);
  }
  if (*(unsigned char *)(a1 + 322))
  {
    if (*(_DWORD *)(a1 + 328) == 1) {
      sub_100E8024C(a1, (uint64_t *)a2, (uint64_t *)a3, (uint64_t *)a4, *(ctu **)(a1 + 272), (const void *)(*(void *)(a1 + 280) - *(void *)(a1 + 272)));
    }
    if (*(unsigned char *)(a1 + 324) && *(unsigned char *)(a1 + 323))
    {
      memset(&__dst, 0, sizeof(__dst));
      if (*(char *)(a1 + 159) < 0) {
        sub_10004FC84(&__dst, *(void **)(a1 + 136), *(void *)(a1 + 144));
      }
      else {
        std::string __dst = *(std::string *)(a1 + 136);
      }
      std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      if (!size) {
        std::string::operator=(&__dst, (const std::string *)"MD5");
      }
      *(_OWORD *)long long v17 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_1004DD20C((uint64_t)buf, *(void *)(a1 + 8));
    }
  }
  return 0;
}

void sub_100EB068C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  sub_1004DD2CC(v28 - 112);
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(a1);
}

void *sub_100EB0718(unsigned char *a1, void *a2)
{
  sub_100A3AC40((uint64_t)a1, a2);
  if (a1[322])
  {
    uint64_t v4 = sub_10004B96C(a2, (uint64_t)"  RES: ", 7);
    ctu::hex();
    int v5 = (v30 & 0x80u) == 0 ? &__p : (void **)__p;
    uint64_t v6 = (v30 & 0x80u) == 0 ? v30 : v29;
    uint64_t v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
    uint64_t v8 = std::locale::use_facet(&v31, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v31);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v30 < 0) {
      operator delete(__p);
    }
  }
  if (a1[323])
  {
    long long v9 = sub_10004B96C(a2, (uint64_t)"  CK: ", 6);
    ctu::hex((uint64_t *)&__p, (ctu *)(a1 + 238), (const void *)0x10, v10);
    uint64_t v11 = (v30 & 0x80u) == 0 ? &__p : (void **)__p;
    uint64_t v12 = (v30 & 0x80u) == 0 ? v30 : v29;
    uint64_t v13 = sub_10004B96C(v9, (uint64_t)v11, v12);
    std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
    long long v14 = std::locale::use_facet(&v31, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(&v31);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v30 < 0) {
      operator delete(__p);
    }
  }
  if (a1[324])
  {
    long long v15 = sub_10004B96C(a2, (uint64_t)"  IK: ", 6);
    ctu::hex((uint64_t *)&__p, (ctu *)(a1 + 254), (const void *)0x10, v16);
    long long v17 = (v30 & 0x80u) == 0 ? &__p : (void **)__p;
    uint64_t v18 = (v30 & 0x80u) == 0 ? v30 : v29;
    long long v19 = sub_10004B96C(v15, (uint64_t)v17, v18);
    std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
    long long v20 = std::locale::use_facet(&v31, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
    std::locale::~locale(&v31);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v30 < 0) {
      operator delete(__p);
    }
  }
  if (a1[321])
  {
    long long v21 = sub_10004B96C(a2, (uint64_t)"  AUTS: ", 8);
    ctu::hex((uint64_t *)&__p, (ctu *)(a1 + 224), (const void *)0xE, v22);
    if ((v30 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v30 & 0x80u) == 0) {
      uint64_t v24 = v30;
    }
    else {
      uint64_t v24 = v29;
    }
    long long v25 = sub_10004B96C(v21, (uint64_t)p_p, v24);
    std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
    long long v26 = std::locale::use_facet(&v31, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
    std::locale::~locale(&v31);
    std::ostream::put();
    std::ostream::flush();
    if ((char)v30 < 0) {
      operator delete(__p);
    }
  }
  return a2;
}

void sub_100EB0AD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100EB0B18(uint64_t a1)
{
  sub_1007DCA34(a1);

  operator delete();
}

const char *sub_100EB0B50()
{
  return "AkaDigestAuthScheme";
}

void sub_100EB0B5C()
{
}

void sub_100EB0D04()
{
  uint64_t v3 = *v2;
  if (*v2)
  {
    *(void *)(v0 + 304) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *v1;
  if (*v1)
  {
    *(void *)(v0 + 280) = v4;
    operator delete(v4);
  }
  sub_100EAF6D0(v0);
  operator delete();
}

void *sub_100EB0D5C(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  long long v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    double result = sub_10005C9F8(v7, v11);
    long long v9 = (char *)v7[1];
    goto LABEL_17;
  }
  uint64_t v12 = (unsigned char *)result[1];
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v15 = a3 - __src;
    if (v15) {
      double result = memmove(v9, __src, v15);
    }
    long long v14 = &v9[v15];
    goto LABEL_20;
  }
  uint64_t v13 = &__src[v12 - v9];
  if (v12 != v9)
  {
    double result = memmove((void *)*result, __src, v12 - v9);
    long long v9 = (char *)v7[1];
  }
  if (a3 != v13) {
    double result = memmove(v9, v13, a3 - v13);
  }
  long long v14 = &v9[a3 - v13];
LABEL_20:
  v7[1] = v14;
  return result;
}

uint64_t sub_100EB0E70()
{
  sub_100058DB0(&qword_101B12E68, "http-digest-akav2-password");

  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B12E68, (void *)&_mh_execute_header);
}

BOOL DataServiceController::isSimSlotConfigured_sync(DataServiceController *this)
{
  uint64_t v2 = (capabilities::ct *)capabilities::ct::supportsGemini(this);
  if (!v2 || (capabilities::ct::supportsDataSubscriptionController(v2) & 1) != 0) {
    return 1;
  }
  unsigned int v4 = atomic_load((unsigned int *)this + 1048);
  unsigned int v5 = *((_DWORD *)this + 1051);
  if (v4 <= 1) {
    unsigned int v4 = 1;
  }
  if (v5 <= 1) {
    unsigned int v5 = 1;
  }
  int v6 = *((_DWORD *)this + 1046);
  if (v6) {
    return v6 == v4 && v6 == v5;
  }
  else {
    return v4 == v5;
  }
}

BOOL non-virtual thunk to'DataServiceController::isSimSlotConfigured_sync(DataServiceController *this)
{
  return DataServiceController::isSimSlotConfigured_sync((DataServiceController *)((char *)this - 72));
}

void DataServiceController::synchronizePreferredDataSIM_sync(DataServiceController *this, const char *a2)
{
  if (*((unsigned char *)this + 288)) {
    return;
  }
  unsigned int v4 = (capabilities::ct *)capabilities::ct::supportsGemini(this);
  if (!v4 || (unsigned int v4 = (capabilities::ct *)capabilities::ct::supportsDataSubscriptionController(v4), v4))
  {
    if (!capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v4)) {
      return;
    }
  }
  unsigned int v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MSIM: synchronizePreferredDataSIM: reason: '%s'", buf, 0xCu);
  }
  uint64_t v6 = *((unsigned int *)this + 1047);
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**((void **)this + 6) + 16))(*((void *)this + 6), *((unsigned int *)this + 1046));
  unint64_t v8 = v7;
  int v9 = *((_DWORD *)this + 1046);
  if (v9)
  {
    if (!v6)
    {
      uint64_t v10 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N MSIM: synchronizePreferredDataSIM: unknown dual SIM mode from UI. Before we get info from UI, we assume that BB has the right information.", buf, 2u);
        int v9 = *((_DWORD *)this + 1046);
      }
      uint64_t v6 = *((unsigned int *)this + 1052);
    }
    size_t v11 = (capabilities::ct *)sub_100AF2240(*((void *)this + 18), v9);
    if ((v11 & 1) == 0)
    {
      size_t v11 = (capabilities::ct *)capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v11);
      if ((v11 & 1) == 0)
      {
        os_log_t v19 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v20;
          size_t v15 = "#E MSIM: synchronizePreferredDataSIM: wrong SIM from UI: %s";
          long long v21 = v19;
          uint32_t v22 = 12;
LABEL_40:
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v15, buf, v22);
          return;
        }
        return;
      }
    }
    int v12 = capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v11);
    uint64_t v13 = *((void *)this + 18);
    if (v12)
    {
      if (!sub_100AF2240(v13, 1))
      {
        os_log_t v14 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          size_t v15 = "#E MSIM: synchronizePreferredDataSIM: fDataModels empty (0)";
          goto LABEL_39;
        }
        return;
      }
      if (!*(void *)(sub_100AEFE40(*((void *)this + 18), 1) + 24))
      {
        os_log_t v14 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          size_t v15 = "#E MSIM: synchronizePreferredDataSIM: BB driver empty (1)";
LABEL_39:
          long long v21 = v14;
          uint32_t v22 = 2;
          goto LABEL_40;
        }
        return;
      }
    }
    else
    {
      if (!sub_100AF2240(v13, *((_DWORD *)this + 1046)))
      {
        os_log_t v14 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          size_t v15 = "#E MSIM: synchronizePreferredDataSIM: invalid SIM (2)";
          goto LABEL_39;
        }
        return;
      }
      if (!*(void *)(sub_100AEFE40(*((void *)this + 18), *((_DWORD *)this + 1046)) + 24))
      {
        os_log_t v14 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          size_t v15 = "#E MSIM: synchronizePreferredDataSIM: BB driver empty (3)";
          goto LABEL_39;
        }
        return;
      }
    }
    int v16 = *((_DWORD *)this + 1046);
    if (v16 == *((_DWORD *)this + 1051))
    {
      unsigned int v17 = atomic_load((unsigned int *)this + 1048);
      if (v16 == v17)
      {
        if (v6 == *((_DWORD *)this + 1052))
        {
          unsigned int v18 = atomic_load((unsigned int *)this + 1049);
          if (v6 == v18)
          {
            os_log_t v14 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              size_t v15 = "#N MSIM: synchronizePreferredDataSIM: nothing to do";
              goto LABEL_39;
            }
            return;
          }
          long long v23 = "UI and CT have different understanding which dual SIM mode we are in, UI has priority";
        }
        else
        {
          long long v23 = "UI and BB have different understanding which dual SIM mode we are in, UI has priority";
        }
      }
      else
      {
        long long v23 = "UI and CT have different understanding which SIM is the preferred Data SIM, UI has priority";
      }
    }
    else
    {
      long long v23 = "UI and BB have different understanding which SIM is the preferred Data SIM, UI has priority";
    }
    uint64_t v24 = *v8;
    BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
    uint64_t v26 = *((unsigned int *)this + 1046);
    if (v25)
    {
      uint64_t v27 = subscriber::asString();
      uint64_t v28 = subscriber::asString();
      atomic_load((unsigned int *)this + 1048);
      uint64_t v29 = subscriber::asString();
      uint64_t v30 = subscriber::asString();
      uint64_t v31 = subscriber::asString();
      atomic_load((unsigned int *)this + 1049);
      uint64_t v32 = subscriber::asString();
      *(_DWORD *)std::string buf = 136316418;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v28;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v68 = v29;
      *(_WORD *)uint64_t v69 = 2080;
      *(void *)&v69[2] = v30;
      *(_WORD *)&v69[10] = 2080;
      *(void *)&v69[12] = v31;
      __int16 v70 = 2080;
      *(void *)std::string v71 = v32;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I MSIM: synchronizePreferredDataSIM: have to run update process: SIM from UI: %s, SIM from BB: %s, currently preferred SIM: %s, dual SIM from UI: %s, dual SIM from BB: %s, current dual SIM: %s", buf, 0x3Eu);
      uint64_t v26 = *((unsigned int *)this + 1046);
    }
    sub_10003E168(buf, (void *)this + 1);
    uint64_t v33 = *(void *)buf;
    uint64_t v34 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
    }
    sub_10003E168(buf, (void *)this + 1);
    uint64_t v35 = *(std::__shared_weak_count **)&buf[8];
    uint64_t v61 = *(void *)buf;
    int v62 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v35);
    }
    int v63 = v26;
    uint64_t v64 = v33;
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)CFNumberRef v65 = this;
    *(void *)&char v65[8] = v26;
    *(void *)&v65[16] = v23;
    *(_DWORD *)&v65[24] = v6;
    uint64_t v66 = v23;
    if (*((_DWORD *)this + 1051) == v26 && *((_DWORD *)this + 1052) == v6)
    {
      (*(void (**)(DataServiceController *, uint64_t, uint64_t, uint64_t, const char *))(*(void *)this + 2080))(this, v26, v6, 1, "already have SIM set");
      long long v36 = v34;
LABEL_84:
      if (v36) {
        std::__shared_weak_count::__release_weak(v36);
      }
      if (v35) {
        std::__shared_weak_count::__release_weak(v35);
      }
      if (v34) {
        std::__shared_weak_count::__release_weak(v34);
      }
      return;
    }
    sub_100EB3C00((uint64_t)this + 4272);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v37, *((Registry **)this + 13));
    uint64_t v39 = ServiceMap;
    if (v40 < 0)
    {
      uint64_t v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v42 = 5381;
      do
      {
        uint64_t v40 = v42;
        unsigned int v43 = *v41++;
        uint64_t v42 = (33 * v42) ^ v43;
      }
      while (v43);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v40;
    int v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)buf);
    unsigned int v57 = v26;
    uint64_t v58 = v23;
    if (v44)
    {
      uint64_t v46 = v44[3];
      unsigned int v45 = (std::__shared_weak_count *)v44[4];
      if (v45)
      {
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v39);
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v45);
        char v47 = 0;
        goto LABEL_63;
      }
    }
    else
    {
      uint64_t v46 = 0;
    }
    std::mutex::unlock(v39);
    unsigned int v45 = 0;
    char v47 = 1;
LABEL_63:
    if (v46)
    {
      (*(void (**)(unsigned char *__return_ptr, uint64_t, const char *, void))(*(void *)v46 + 8))(buf, v46, "MSIM reconfiguration", 0);
      long long v48 = *(_OWORD *)buf;
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v49 = (std::__shared_weak_count *)*((void *)this + 537);
      *((_OWORD *)this + 268) = v48;
      if (v49)
      {
        sub_10004D2C8(v49);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      uint64_t v50 = *((void *)this + 5);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v51 = asStringBool(*((void *)this + 536) != 0);
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v51;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I MSIM update: PowerAssertion set: %s", buf, 0xCu);
        if (v47) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }
    }
    else
    {
      std::string::size_type v52 = *((void *)this + 5);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "MSIM update: Missing PowerAssertionInterface!", buf, 2u);
        if (v47) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }
    }
    if (v47)
    {
LABEL_73:
      sub_100058DB0(buf, "/cc/assertions/airplane_mode");
      ctu::rest::AssertionHandle::create();
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      std::string::size_type v53 = (std::__shared_weak_count *)*((void *)this + 535);
      *((_OWORD *)this + 267) = v59;
      if (v53) {
        sub_10004D2C8(v53);
      }
      sub_10003E168(buf, (void *)this + 1);
      uint64_t v54 = *(std::__shared_weak_count **)&buf[8];
      uint64_t v56 = *(void *)buf;
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
      }
      uint64_t v35 = v62;
      if (v62) {
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      long long v36 = v34;
      if (v34) {
        atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v60 = v58;
      *((void *)&v60 + 1) = __PAIR64__(v6, v57);
      *(void *)std::string buf = this;
      *(void *)&uint8_t buf[8] = v56;
      *(void *)&uint8_t buf[16] = v54;
      uint64_t v68 = v61;
      *(void *)uint64_t v69 = v62;
      *(void *)&uint8_t v69[8] = this;
      *(_DWORD *)&v69[16] = v63;
      *(void *)&v71[2] = v64;
      __int16 v72 = v34;
      *(_OWORD *)((char *)v73 + 12) = *(_OWORD *)&v65[12];
      v73[0] = *(_OWORD *)v65;
      int v75 = v6;
      uint64_t v74 = v66;
      long long v76 = v60;
      CFBooleanRef v78 = 0;
      uint64_t v55 = (char *)operator new(0x90uLL);
      *(void *)uint64_t v55 = off_101A67AE0;
      *((void *)v55 + 1) = this;
      *((void *)v55 + 2) = v56;
      *((void *)v55 + 3) = v54;
      *(void *)&uint8_t buf[8] = 0;
      *(void *)&uint8_t buf[16] = 0;
      *((void *)v55 + 4) = v61;
      *((void *)v55 + 5) = v62;
      uint64_t v68 = 0;
      *(void *)uint64_t v69 = 0;
      *((void *)v55 + 6) = this;
      *((_DWORD *)v55 + 14) = v63;
      *((void *)v55 + 8) = v64;
      *((void *)v55 + 9) = v34;
      *(void *)&v71[2] = 0;
      __int16 v72 = 0;
      *(_OWORD *)(v55 + 92) = *(_OWORD *)&v65[12];
      *((_OWORD *)v55 + 5) = *(_OWORD *)v65;
      *((_DWORD *)v55 + 30) = v6;
      *((void *)v55 + 14) = v66;
      *((_OWORD *)v55 + 8) = v60;
      CFBooleanRef v78 = v55;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(v77);
      goto LABEL_84;
    }
LABEL_72:
    sub_10004D2C8(v45);
    goto LABEL_73;
  }
  os_log_t v14 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    size_t v15 = "#N MSIM: synchronizePreferredDataSIM: unknown SIM from UI. Before we get info from UI, we do not reconfigure anything.";
    goto LABEL_39;
  }
}

void sub_100EB1900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if ((v51 & 1) == 0) {
    sub_10004D2C8(v50);
  }
  sub_100EB3CC0((uint64_t)&a33);
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t DataServiceController::handleRadioState_sync(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 836);
  if (v3 == a2) {
    goto LABEL_75;
  }
  unsigned int v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    uint64_t v7 = radioStateAsString();
    uint64_t v8 = radioStateAsString();
    uint64_t v9 = asStringBool(*(void *)(a1 + 4272) != 0);
    if (*(void *)(a1 + 4328)) {
      BOOL v10 = *(void *)(a1 + 4272) != 0;
    }
    else {
      BOOL v10 = 0;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v8;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v9;
    __int16 v82 = 2080;
    uint64_t v83 = asStringBool(v10);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I radio state (change states) %s->%s, airplane assertion %s, airplane assertion waiting %s", buf, 0x2Au);
  }
  if (capabilities::ct::supportsIPCInterfaceConfig((capabilities::ct *)v6))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 104));
    uint64_t v13 = ServiceMap;
    if (v3 < 3)
    {
      if (v14 < 0)
      {
        size_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          uint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v14;
      unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
      if (v18)
      {
        uint64_t v20 = v18[3];
        os_log_t v19 = (std::__shared_weak_count *)v18[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          char v21 = 0;
          if (!v20) {
            goto LABEL_33;
          }
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v20 = 0;
      }
      std::mutex::unlock(v13);
      os_log_t v19 = 0;
      char v21 = 1;
      if (!v20) {
        goto LABEL_33;
      }
LABEL_25:
      sub_100058DB0(&v80, "Baseband state change: ");
      uint64_t v27 = (const char *)radioStateAsString();
      size_t v28 = strlen(v27);
      uint64_t v29 = std::string::append(&v80, v27, v28);
      long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      *(void *)&uint8_t buf[16] = *((void *)&v29->__r_.__value_.__l + 2);
      *(_OWORD *)std::string buf = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v20 + 40))(v20, buf);
LABEL_29:
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v80.__r_.__value_.__l.__data_);
      }
      goto LABEL_33;
    }
    if (v14 < 0)
    {
      uint32_t v22 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v14 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v14;
    BOOL v25 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
    if (v25)
    {
      uint64_t v26 = v25[3];
      os_log_t v19 = (std::__shared_weak_count *)v25[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        if (!v26)
        {
LABEL_33:
          if ((v21 & 1) == 0) {
            sub_10004D2C8(v19);
          }
          goto LABEL_35;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v13);
    os_log_t v19 = 0;
    char v21 = 1;
    if (!v26) {
      goto LABEL_33;
    }
LABEL_28:
    sub_100058DB0(&v80, "Baseband state change: ");
    uint64_t v31 = (const char *)radioStateAsString();
    size_t v32 = strlen(v31);
    uint64_t v33 = std::string::append(&v80, v31, v32);
    long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    *(void *)&uint8_t buf[16] = *((void *)&v33->__r_.__value_.__l + 2);
    *(_OWORD *)std::string buf = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v26 + 48))(v26, buf);
    goto LABEL_29;
  }
LABEL_35:
  if (a2 <= 1)
  {
    if (v3 > 5 || ((1 << v3) & 0x2C) == 0) {
      goto LABEL_54;
    }
    uint64_t v35 = *(void *)(a1 + 144);
    long long v36 = *(void **)(v35 + 8);
    for (CFIndex i = *(void **)(v35 + 16); v36 != i; v36 += 54)
    {
      uint64_t v38 = v36[3];
      if (v38)
      {
        (*(void (**)(uint64_t))(*(void *)v38 + 336))(v38);
        uint64_t v40 = v36[52];
        uint64_t v39 = (std::__shared_weak_count *)v36[53];
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v41 = *(unsigned int *)(v40 + 52);
          sub_10004D2C8(v39);
        }
        else
        {
          uint64_t v41 = *(unsigned int *)(v40 + 52);
        }
        DataServiceController::tetheringAuthStateReset_sync(a1, v41, 0);
      }
    }
  }
  switch(v3)
  {
    case 5u:
LABEL_59:
      int v43 = 1;
      goto LABEL_60;
    case 3u:
      if (*(void *)(a1 + 4272))
      {
        int v44 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I MSIM update: baseband got reset while reconfiguring", buf, 2u);
        }
        sub_100EB2354(a1, *(unsigned int *)(a1 + 4344), *(_DWORD *)(a1 + 4348), 1, 0);
      }
      goto LABEL_59;
    case 2u:
      if (*(void *)(a1 + 4328) && *(void *)(a1 + 4272))
      {
        uint64_t v42 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I MSIM update: got real airplane mode", buf, 2u);
        }
        memset(buf, 0, sizeof(buf));
        sub_1000DA470((uint64_t)buf, a1 + 4304);
        sub_1003355AC((void *)(a1 + 4304));
        if (!*(void *)&buf[24]) {
          sub_10007B600();
        }
        (*(void (**)(void))(**(void **)&buf[24] + 48))(*(void *)&buf[24]);
        sub_10003B34C(buf);
      }
      goto LABEL_59;
  }
LABEL_54:
  int v43 = 0;
LABEL_60:
  if (a2 <= 5 && ((1 << a2) & 0x2C) != 0)
  {
    if (v43) {
      goto LABEL_74;
    }
  }
  else if (!v43)
  {
    goto LABEL_74;
  }
  if (v3 - 2 > 3) {
    unsigned int v45 = "Radio On";
  }
  else {
    unsigned int v45 = off_101A67E08[v3 - 2];
  }
  sub_100058DB0(__p, v45);
  *(_DWORD *)std::string buf = 3;
  uint8_t buf[4] = 0;
  if (SHIBYTE(v79) < 0)
  {
    sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
    *(void *)&unsigned char buf[24] = v79;
  }
  sub_10011AE40();
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (SHIBYTE(v79) < 0)
  {
    operator delete(__p[0]);
    if (v3) {
      goto LABEL_75;
    }
    goto LABEL_82;
  }
LABEL_74:
  if (v3) {
    goto LABEL_75;
  }
LABEL_82:
  uint64_t v52 = *(void *)(a1 + 144);
  std::string::size_type v53 = *(uint64_t ***)(v52 + 8);
  for (CFIndex j = *(uint64_t ***)(v52 + 16); v53 != j; v53 += 54)
  {
    uint64_t v55 = *v53;
    uint64_t v56 = v53[1];
    while (v55 != v56)
    {
      uint64_t v57 = *v55;
      uint64_t v58 = (std::__shared_weak_count *)v55[1];
      if (v58) {
        atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v57) {
        (*(void (**)(uint64_t))(*(void *)v57 + 40))(v57);
      }
      if (v58) {
        sub_10004D2C8(v58);
      }
      v55 += 2;
    }
  }
  sub_100EB2834(a1, 5);
  long long v60 = (std::mutex *)Registry::getServiceMap(v59, *(Registry **)(a1 + 104));
  uint64_t v61 = v60;
  if (v62 < 0)
  {
    int v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v64 = 5381;
    do
    {
      uint64_t v62 = v64;
      unsigned int v65 = *v63++;
      uint64_t v64 = (33 * v64) ^ v65;
    }
    while (v65);
  }
  std::mutex::lock(v60);
  *(void *)std::string buf = v62;
  uint64_t v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
  if (v66)
  {
    uint64_t v68 = (uint64_t (***)(void))v66[3];
    uint64_t v67 = (std::__shared_weak_count *)v66[4];
    if (v67)
    {
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v61);
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v67);
      char v69 = 0;
      if (!v68) {
        goto LABEL_103;
      }
      goto LABEL_102;
    }
  }
  else
  {
    uint64_t v68 = 0;
  }
  std::mutex::unlock(v61);
  uint64_t v67 = 0;
  char v69 = 1;
  if (v68)
  {
LABEL_102:
    uint64_t v70 = (**v68)(v68);
    sub_100EB2AFC((capabilities::ct *)a1, v70);
  }
LABEL_103:
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v67);
  }
  uint64_t v71 = *(void *)(a1 + 144);
  uint64_t v72 = *(void *)(v71 + 8);
  uint64_t v73 = *(void *)(v71 + 16);
  while (v72 != v73)
  {
    uint64_t v74 = *(void *)(v72 + 24);
    if (v74)
    {
      uint64_t v75 = *(void *)(a1 + 152);
      long long v76 = (os_unfair_lock_s *)(v75 + 24);
      os_unfair_lock_lock((os_unfair_lock_t)(v75 + 24));
      uint64_t v77 = *(unsigned __int8 *)(v75 + 84);
      os_unfair_lock_unlock(v76);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v74 + 888))(v74, v77);
    }
    v72 += 432;
  }
LABEL_75:
  int v46 = *(unsigned __int8 *)(a1 + 4377);
  unsigned int v47 = (v3 < 6) & (0x2Cu >> v3);
  *(unsigned char *)(a1 + 4377) = v47;
  if (v46 != v47)
  {
    long long v48 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v49 = asStringBool(v46 != 0);
      uint64_t v50 = asStringBool(*(unsigned char *)(a1 + 4377));
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "handleRadioState_sync";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v49;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v50;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s: radio off %s->%s", buf, 0x20u);
    }
  }
  uint64_t result = *(void *)(a1 + 4384);
  *(void *)(a1 + 4384) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_100EB2284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,void *a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB2354(uint64_t a1, uint64_t a2, int a3, BOOL a4, BOOL a5)
{
  if (!*(unsigned char *)(a1 + 288))
  {
    uint64_t v8 = a2;
    BOOL v10 = sub_100AF2240(*(void *)(a1 + 144), a2);
    if (v10 || capabilities::ct::supportsDualSIMSingleStackWithCrossMapping((capabilities::ct *)v10))
    {
      if (*(void *)(a1 + 4272))
      {
        if (!*(void *)(a1 + 4328))
        {
          uint64_t v11 = *(unsigned int *)(a1 + 4344);
          if (v11)
          {
            if (a4)
            {
              if (a5)
              {
                if (v11 == v8
                  && ((uint64_t v12 = *(unsigned int *)(a1 + 4348), v12 == a3) || !v12))
                {
                  int v17 = *(_DWORD *)(a1 + 4340);
                  unsigned int v18 = *(NSObject **)(a1 + 40);
                  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
                  if (v17 == 1)
                  {
                    if (v19)
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I MSIM update: config done, waiting for remap completion", buf, 2u);
                    }
                    *(unsigned char *)(a1 + 4352) = 1;
                  }
                  else
                  {
                    if (v19)
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I MSIM update: BB part done (1)", buf, 2u);
                      uint64_t v8 = *(unsigned int *)(a1 + 4344);
                      uint64_t v12 = *(unsigned int *)(a1 + 4348);
                    }
                    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, const char *))(*(void *)a1 + 2080))(a1, v8, v12, 1, "BB part done");
                  }
                }
                else
                {
                  uint64_t v13 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)std::string buf = 136315906;
                    uint64_t v23 = subscriber::asString();
                    __int16 v24 = 2080;
                    uint64_t v25 = subscriber::asString();
                    __int16 v26 = 2080;
                    uint64_t v27 = subscriber::asString();
                    __int16 v28 = 2080;
                    uint64_t v29 = subscriber::asString();
                    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I MSIM update: failed configration: wrong SIM result: %s/%s (must be %s/%s)", buf, 0x2Au);
                    uint64_t v11 = *(unsigned int *)(a1 + 4344);
                  }
                  (*(void (**)(uint64_t, uint64_t, void, void, const char *))(*(void *)a1 + 2080))(a1, v11, *(unsigned int *)(a1 + 4348), 0, "failed configration: wrong SIM result");
                }
              }
              else
              {
                uint64_t v16 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I MSIM update: failed configration", buf, 2u);
                  uint64_t v11 = *(unsigned int *)(a1 + 4344);
                }
                (*(void (**)(uint64_t, uint64_t, void, void, const char *))(*(void *)a1 + 2080))(a1, v11, *(unsigned int *)(a1 + 4348), 0, "failed configration");
              }
            }
          }
          else
          {
            size_t v15 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I MSIM update: stray BB information, ignore it", buf, 2u);
            }
          }
        }
      }
      else if (*(_DWORD *)(a1 + 4204) != v8 || *(_DWORD *)(a1 + 4208) != a3)
      {
        uint64_t v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136316418;
          uint64_t v23 = subscriber::asString();
          __int16 v24 = 2080;
          uint64_t v25 = subscriber::asString();
          __int16 v26 = 2080;
          uint64_t v27 = subscriber::asString();
          __int16 v28 = 2080;
          uint64_t v29 = subscriber::asString();
          __int16 v30 = 2080;
          uint64_t v31 = asStringBool(a4);
          __int16 v32 = 2080;
          uint64_t v33 = asStringBool(a5);
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MSIM: (change states) fPreferredDataSIMFromBB %s ==>> %s mode %s ==> %s (bb reported configCompleted = %s success = %s)", buf, 0x3Eu);
        }
        *(_DWORD *)(a1 + 4204) = v8;
        *(_DWORD *)(a1 + 4208) = a3;
        (*(void (**)(uint64_t, const char *))(*(void *)a1 + 2096))(a1, "getter or unsolicited notification");
        sub_100058DB0(__p, "preferredDataSIM updated (2)");
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 1320))(a1, 3, __p);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
}

void sub_100EB2810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB2834(uint64_t a1, uint64_t a2)
{
  if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
    return;
  }
  uint64_t v4 = atomic_load((unsigned int *)(a1 + 4200));
  uint64_t v5 = *(void *)(a1 + 112);
  *(void *)&long long v13 = *(void *)(a1 + 104);
  *((void *)&v13 + 1) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (*((void *)&v13 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
  }
  if ((isValidSimSlot & 1) == 0)
  {
    BOOL v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LODWORD(v13) = 136315138;
    *(void *)((char *)&v13 + 4) = asString();
    uint64_t v11 = "#N MSIM switch: invalid sim slot for BB SIM update (%s)";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v13, 0xCu);
    return;
  }
  if (!sub_100AF2240(*(void *)(a1 + 144), v4))
  {
    BOOL v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LODWORD(v13) = 136315138;
    *(void *)((char *)&v13 + 4) = asString();
    uint64_t v11 = "#E MSIM switch: no data model for BB SIM update (%s)";
    goto LABEL_16;
  }
  uint64_t v7 = sub_100AEFE40(*(void *)(a1 + 144), v4);
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v9 = *(std::__shared_weak_count **)(v7 + 32);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v8)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 816))(v8, a2);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v13) = 136315138;
      *(void *)((char *)&v13 + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E MSIM switch: data driver is empty for BB SIM update (%s)", (uint8_t *)&v13, 0xCu);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100EB2AC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB2AFC(capabilities::ct *a1, uint64_t a2)
{
  if (capabilities::ct::supports5G(a1))
  {
    uint64_t v4 = *((void *)a1 + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 67109120;
      v10[1] = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I notifyCellularDataSwitchingAllowed %d", (uint8_t *)v10, 8u);
    }
    uint64_t v5 = *((void *)a1 + 18);
    int v6 = (*(uint64_t (**)(capabilities::ct *))(*(void *)a1 + 1072))(a1);
    uint64_t v7 = sub_10003B004(v5, v6);
    if (*(void *)(*((void *)a1 + 18) + 16) == v7)
    {
      uint64_t v9 = *((void *)a1 + 5);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I PreferredDataSIM not ready yet", (uint8_t *)v10, 2u);
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v7 + 24);
      if (v8) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 736))(v8, a2);
      }
    }
  }
}

void sub_100EB2C74(uint64_t a1, uint64_t a2, int a3, int a4, int a5, char a6, uint64_t a7)
{
  if (*(void *)(a1 + 4360)) {
    BOOL v12 = a5 == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if (!v12)
  {
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = a7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MSIM update: backoff reason <%s>: setting timer (mode %s)", buf, 0x16u);
    }
    uint64_t v15 = *(void *)(a1 + 4360);
    *(void *)(a1 + 4360) = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v35 = 0;
    long long v36 = 0;
    Registry::getTimerService(&v35, *(Registry **)(a1 + 104));
    if (v35)
    {
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v17 = *(void *)buf;
      uint64_t v16 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
      }
      uint64_t v18 = v35;
      sub_100058DB0(__p, "MsimBackoff timer");
      BOOL v19 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v19;
      if (v19) {
        dispatch_retain(v19);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_100EB30A8;
      aBlock[3] = &unk_101A67A40;
      aBlock[4] = a1;
      aBlock[5] = v17;
      uint64_t v29 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      char v30 = a6;
      uint64_t v31 = _Block_copy(aBlock);
      sub_100118A44(v18, (uint64_t)__p, 0, 5000000, &object, &v31);
      uint64_t v20 = *(void *)buf;
      *(void *)std::string buf = 0;
      uint64_t v21 = *(void *)(a1 + 4360);
      *(void *)(a1 + 4360) = v20;
      if (v21)
      {
        (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
        uint64_t v22 = *(void *)buf;
        *(void *)std::string buf = 0;
        if (v22) {
          (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
        }
      }
      if (v31) {
        _Block_release(v31);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v34 < 0) {
        operator delete(__p[0]);
      }
      if (v29) {
        std::__shared_weak_count::__release_weak(v29);
      }
      if (v16) {
        std::__shared_weak_count::__release_weak(v16);
      }
    }
    if (v36) {
      sub_10004D2C8(v36);
    }
  }
  uint64_t v23 = *(unsigned int *)(a1 + 4368);
  if (v23) {
    BOOL v24 = a4 == 0;
  }
  else {
    BOOL v24 = 0;
  }
  if (!v24)
  {
    *(_DWORD *)(a1 + 4368) = a2;
    uint64_t v23 = a2;
  }
  if (*(_DWORD *)(a1 + 4372)) {
    BOOL v25 = a4 == 0;
  }
  else {
    BOOL v25 = 0;
  }
  if (!v25) {
    *(_DWORD *)(a1 + 4372) = a3;
  }
  __int16 v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v23);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a7;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I set MsimBackoff timer for mode %s (reason <%s>)", buf, 0x16u);
  }
}

void sub_100EB3020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB30A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(void *)(v3 + 4360);
        *(void *)(v3 + 4360) = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        int v7 = *(_DWORD *)(v3 + 836);
        uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 4368));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136315394;
          uint64_t v12 = subscriber::asString();
          __int16 v13 = 2080;
          uint64_t v14 = radioStateAsString();
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fired MsimBackoff timer for mode %s, radio state %s", (uint8_t *)&v11, 0x16u);
        }
        uint64_t v9 = *(unsigned int *)(v3 + 4368);
        if (*(unsigned char *)(a1 + 56) && v7)
        {
          sub_100EB2C74(v3, v9, *(unsigned int *)(v3 + 4372), 0, 0, 1, "baseband not online");
        }
        else if (v9)
        {
          uint64_t v10 = *(unsigned int *)(v3 + 4372);
          *(void *)(v3 + 4368) = 0;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 2104))(v3, v9, v10);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100EB3270(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EB3290(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EB32AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void DataServiceController::onFullCompleteMSIM_sync(uint64_t a1, uint64_t a2, unsigned int a3, BOOL a4, uint64_t a5)
{
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = a5;
    __int16 v59 = 2080;
    uint64_t v60 = asStringBool(a4);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MSIM update: mode: %s, onFullCompleteMSIM: reason: '%s', success: %s", buf, 0x20u);
  }
  int v11 = *(unsigned __int8 *)(a1 + 4336);
  sub_100EB3C00(a1 + 4272);
  if (!a4)
  {
    uint64_t v38 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#E MSIM update: Cannot update preferredData SIM, will try again", buf, 2u);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_10003E168(buf, (void *)(a1 + 8));
    operator new();
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    atomic_load((unsigned int *)(a1 + 4192));
    uint64_t v13 = subscriber::asString();
    uint64_t v14 = subscriber::asString();
    uint64_t v15 = subscriber::asString();
    uint64_t v16 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    __int16 v59 = 2080;
    uint64_t v60 = v15;
    __int16 v61 = 2080;
    uint64_t v62 = v16;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MSIM update: (change states) fPreferredDataSIM %s ==>> %s, fPreferredDataSIMFromBB %s ==>> %s", buf, 0x2Au);
    uint64_t v12 = *(NSObject **)(a1 + 40);
  }
  BOOL v17 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    atomic_load((unsigned int *)(a1 + 4196));
    uint64_t v18 = subscriber::asString();
    uint64_t v19 = subscriber::asString();
    uint64_t v20 = subscriber::asString();
    uint64_t v21 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v18;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v19;
    __int16 v59 = 2080;
    uint64_t v60 = v20;
    __int16 v61 = 2080;
    uint64_t v62 = v21;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MSIM update: (change states) fMSimConfigMode %s ==>> %s, fMSimConfigModeFromBB %s ==>> %s", buf, 0x2Au);
  }
  unsigned int v22 = atomic_load((unsigned int *)(a1 + 4192));
  atomic_store(a2, (unsigned int *)(a1 + 4192));
  atomic_store(a3, (unsigned int *)(a1 + 4196));
  *(_DWORD *)(a1 + 4204) = a2;
  *(_DWORD *)(a1 + 4208) = a3;
  uint64_t v23 = capabilities::ct::supportsGemini((capabilities::ct *)v17);
  if (v23)
  {
    uint64_t v23 = capabilities::ct::supportsDataSubscriptionController((capabilities::ct *)v23);
    if ((v23 & 1) == 0 && *(_DWORD *)(a1 + 3440) != a2)
    {
      *(_DWORD *)(a1 + 3440) = a2;
      uint64_t v23 = *(void *)(a1 + 3432);
      if (v23) {
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v23 + 48))(v23, a1 + 3440);
      }
    }
  }
  BOOL v24 = (capabilities::ct *)capabilities::ct::supportsGemini((capabilities::ct *)v23);
  if (v24
    && (BOOL v24 = (capabilities::ct *)capabilities::ct::supportsDataSubscriptionController(v24), !v24)
    || (BOOL v24 = (capabilities::ct *)capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v24), v24))
  {
    if (*(_DWORD *)(a1 + 3560) != a3)
    {
      *(_DWORD *)(a1 + 3560) = a3;
      BOOL v24 = *(capabilities::ct **)(a1 + 3552);
      if (v24) {
        BOOL v24 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v24 + 48))(v24, a1 + 3560);
      }
    }
    if (*(_DWORD *)(a1 + 3480) != a2)
    {
      *(_DWORD *)(a1 + 3480) = a2;
      BOOL v24 = *(capabilities::ct **)(a1 + 3472);
      if (v24) {
        BOOL v24 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v24 + 48))(v24, a1 + 3480);
      }
    }
  }
  BOOL v25 = (capabilities::ct *)capabilities::ct::supportsGemini(v24);
  if (v25 && (capabilities::ct::supportsDataSubscriptionController(v25) & 1) == 0)
  {
    unsigned int v39 = atomic_load((unsigned int *)(a1 + 4200));
    unsigned int v40 = atomic_load((unsigned int *)(a1 + 4200));
    atomic_store(a2, (unsigned int *)(a1 + 4200));
    __int16 v26 = (uint64_t *)*(unsigned int *)(a1 + 3520);
    if (v26 != a2)
    {
      *(_DWORD *)(a1 + 3520) = a2;
      uint64_t v41 = *(void *)(a1 + 3512);
      if (v41) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v41 + 48))(v41, a1 + 3520);
      }
    }
    if (v39 != a2)
    {
      if (v40) {
        uint64_t v42 = 2;
      }
      else {
        uint64_t v42 = 1;
      }
      sub_100EB2834(a1, v42);
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 4240) + 56))(*(void *)(a1 + 4240), a2);
      int v43 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        atomic_load((unsigned int *)(a1 + 4200));
        uint64_t v44 = subscriber::asString();
        uint64_t v45 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v44;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v45;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I MSIM update: (change states) fCurrentDataSIM %s ==>> %s", buf, 0x16u);
      }
      DataServiceController::initAgentPolicies_sync((DataServiceController *)a1);
    }
  }
  else
  {
    __int16 v26 = (uint64_t *)(a1 + 4200);
    atomic_store(1u, (unsigned int *)(a1 + 4200));
  }
  if (v22 != a2)
  {
    DataServiceController::updateIpcConfiguration_sync((Registry **)a1, v26);
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 4240) + 48))(*(void *)(a1 + 4240), a2);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(a1 + 104));
    uint64_t v29 = ServiceMap;
    if (v30 < 0)
    {
      uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v30;
    char v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
    if (v34)
    {
      long long v36 = (uint64_t (***)(void))v34[3];
      uint64_t v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
        if (!v36)
        {
LABEL_49:
          if ((v37 & 1) == 0) {
            sub_10004D2C8(v35);
          }
          goto LABEL_51;
        }
LABEL_48:
        uint64_t v46 = (**v36)(v36);
        sub_100EB2AFC((capabilities::ct *)a1, v46);
        goto LABEL_49;
      }
    }
    else
    {
      long long v36 = 0;
    }
    std::mutex::unlock(v29);
    uint64_t v35 = 0;
    char v37 = 1;
    if (!v36) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
LABEL_51:
  sub_100EB2C74(a1, 0, 0, 0, 1, v11 == 0, (uint64_t)"onFullCompleteMSIM_sync success");
  uint64_t v47 = *(void *)(a1 + 144);
  long long v48 = *(void **)(v47 + 8);
  for (CFIndex i = *(void **)(v47 + 16); v48 != i; v48 += 54)
  {
    uint64_t v51 = v48[52];
    uint64_t v50 = (std::__shared_weak_count *)v48[53];
    if (v50)
    {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
      int v52 = *(_DWORD *)(v51 + 52);
      sub_10004D2C8(v50);
    }
    else
    {
      int v52 = *(_DWORD *)(v51 + 52);
    }
    if (v52 != (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1072))(a1))
    {
      std::string::size_type v53 = (void *)v48[7];
      uint64_t v54 = (void *)v48[8];
      while (v53 != v54)
      {
        if ((*(uint64_t (**)(void, void, uint64_t, void))(*(void *)*v53 + 216))(*v53, 0, 1, 0))(*(void (**)(void, const char *, void, void))(*(void *)*v53 + 1128))(*v53, "MSIM reconfig", 0, 0); {
        v53 += 2;
        }
      }
    }
  }
  sub_100058DB0(__p, "preferredDataSIM updated (1)");
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 1320))(a1, 3, __p);
  if (v57 < 0) {
    operator delete(__p[0]);
  }
  for (uint64_t j = 0; j != 2; ++j)
    DataServiceController::updateTetheringStatus_sync(a1, dword_10155B0D0[j]);
  sub_100058DB0(buf, "MSIM config complete");
  (*(void (**)(uint64_t, uint64_t, unsigned char *, void))(*(void *)a1 + 2328))(a1, 3, buf, 0);
  if (SHIBYTE(v59) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100EB3B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB3C00(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  *(unsigned char *)(a1 + 64) = 0;
  sub_1003355AC((void *)(a1 + 32));
  *(_DWORD *)(a1 + 68) = 3;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void *sub_100EB3C78(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t sub_100EB3CC0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void DataServiceController::handleMSimConfigCallbackFromBB(uint64_t a1, int a2, int a3, char a4, char a5)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100EB3E18;
  void v7[3] = &unk_101A67A70;
  void v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  char v10 = a4;
  char v11 = a5;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_100EB86C4;
  block[3] = &unk_101A67C58;
  block[5] = v14;
  uint64_t v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v7;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100EB3E18(uint64_t a1)
{
}

void non-virtual thunk to'DataServiceController::handleMSimConfigCallbackFromBB(uint64_t a1, int a2, int a3, char a4, char a5)
{
}

void DataServiceController::handleMSimRemapStatusCallbackFromBB(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100EB3F4C;
  v4[3] = &unk_101A67A90;
  uint64_t v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_100EB86C4;
  block[3] = &unk_101A67C58;
  block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100EB3F4C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 40);
  if (!*(void *)(v1 + 4272))
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v7 = 136315138;
    uint64_t v8 = asString();
    uint64_t v4 = "#I MSIMRemapStatus: unexpected controller state - we are not reconfiguring: status = %s";
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v7, 0xCu);
    return;
  }
  if (*(void *)(v1 + 4328))
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v7 = 136315138;
    uint64_t v8 = asString();
    uint64_t v4 = "#I MSIMRemapStatus: unexpected controller state - we are waiting for the airplane mode to kick in: status = %s";
    goto LABEL_9;
  }
  if (*(_DWORD *)(v1 + 4340) != v2)
  {
    int v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      uint64_t v8 = asString();
      __int16 v9 = 2080;
      uint64_t v10 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MSIMRemapStatus: (change states): %s ==> %s (bb reported)", (uint8_t *)&v7, 0x16u);
    }
    *(_DWORD *)(v1 + 4340) = v2;
  }
  if (v2 == 2 && *(unsigned char *)(v1 + 4352))
  {
    uint64_t v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MSIM update: BB part done", (uint8_t *)&v7, 2u);
    }
    (*(void (**)(uint64_t, void, void, uint64_t, const char *))(*(void *)v1 + 2080))(v1, *(unsigned int *)(v1 + 4344), *(unsigned int *)(v1 + 4348), 1, "remap BB part done");
  }
}

void non-virtual thunk to'DataServiceController::handleMSimRemapStatusCallbackFromBB(uint64_t a1, int a2)
{
}

uint64_t DataServiceController::setActiveUserDataSlot(void **a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setActiveUserDataSlot", v6, 2u);
  }
  return ((uint64_t (*)(void **, uint64_t, void))(*a1)[263])(a1, a2, 0);
}

uint64_t non-virtual thunk to'DataServiceController::setActiveUserDataSlot(uint64_t a1, uint64_t a2)
{
  return DataServiceController::setActiveUserDataSlot((void **)(a1 - 56), a2);
}

uint64_t DataServiceController::setMSimConfig(void **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void *))(*a1[6] + 16))(a1[6]);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setMSimConfig", v8, 2u);
  }
  return ((uint64_t (*)(void **, uint64_t, uint64_t))(*a1)[263])(a1, a2, a3);
}

uint64_t non-virtual thunk to'DataServiceController::setMSimConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DataServiceController::setMSimConfig((void **)(a1 - 56), a2, a3);
}

void DataServiceController::setDataSlot(uint64_t a1, int a2, int a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100EB4438;
  v5[3] = &unk_101A67AB0;
  v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  uint64_t v10 = 0;
  char v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_100EB86C4;
  block[3] = &unk_101A67C58;
  block[5] = v10;
  __int16 v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100EB4438(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 288)) {
    return;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  int v3 = *(_DWORD *)(a1 + 44);
  if (!v3)
  {
    uint64_t v4 = (capabilities::ct *)capabilities::ct::supportsGemini((capabilities::ct *)a1);
    if (v4 && (capabilities::ct::supportsDataSubscriptionController(v4) & 1) == 0)
    {
      int v3 = *(_DWORD *)(v1 + 4372);
      if (v3)
      {
        int v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_8;
        }
        int v31 = 136315138;
        uint64_t v32 = subscriber::asString();
        int v6 = "#I MSIM update: msimMode adjusted to %s (1)";
      }
      else
      {
        int v3 = *(_DWORD *)(v1 + 4348);
        if (!v3) {
          goto LABEL_8;
        }
        int v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_8;
        }
        int v31 = 136315138;
        uint64_t v32 = subscriber::asString();
        int v6 = "#I MSIM update: msimMode adjusted to %s (2)";
      }
      goto LABEL_7;
    }
    int v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    int v3 = 1;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = 136315138;
      uint64_t v32 = subscriber::asString();
      int v6 = "#I MSIM update: msimMode adjusted to %s (5)";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v31, 0xCu);
    }
  }
LABEL_8:
  if (*(void *)(v1 + 4360))
  {
    int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = subscriber::asString();
      int v31 = 136315138;
      uint64_t v32 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MSIM update: backoff: we are already in backoff period, postponing change for mode %s", (uint8_t *)&v31, 0xCu);
    }
    char v9 = *(unsigned char *)(v1 + 4336) == 0;
    uint64_t v10 = "we are already in backoff period";
LABEL_16:
    sub_100EB2C74(v1, v2, v3, 1, 0, v9, (uint64_t)v10);
    return;
  }
  if (*(void *)(v1 + 4272))
  {
    char v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = subscriber::asString();
      int v31 = 136315138;
      uint64_t v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setDataSlot: we are already in the middle of another update, postponing change for mode %s", (uint8_t *)&v31, 0xCu);
    }
    char v9 = *(unsigned char *)(v1 + 4336) == 0;
    uint64_t v10 = "we are already in the middle of another update";
    goto LABEL_16;
  }
  if (*(_DWORD *)(v1 + 4184) == v2
    && (unsigned int v13 = atomic_load((unsigned int *)(v1 + 4192)), v13 == v2)
    && *(_DWORD *)(v1 + 4204) == v2
    && v3 == *(_DWORD *)(v1 + 4188)
    && (unsigned int v14 = atomic_load((unsigned int *)(v1 + 4196)), v3 == v14)
    && v3 == *(_DWORD *)(v1 + 4208))
  {
    uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = subscriber::asString();
      int v31 = 136315138;
      uint64_t v32 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setDataSlot: slot already set for mode %s", (uint8_t *)&v31, 0xCu);
    }
  }
  else
  {
    BOOL v17 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = subscriber::asString();
      uint64_t v19 = subscriber::asString();
      atomic_load((unsigned int *)(v1 + 4192));
      uint64_t v20 = subscriber::asString();
      uint64_t v21 = subscriber::asString();
      uint64_t v22 = subscriber::asString();
      uint64_t v23 = subscriber::asString();
      atomic_load((unsigned int *)(v1 + 4200));
      uint64_t v24 = subscriber::asString();
      int v31 = 136316674;
      uint64_t v32 = v18;
      __int16 v33 = 2080;
      uint64_t v34 = v19;
      __int16 v35 = 2080;
      uint64_t v36 = v20;
      __int16 v37 = 2080;
      uint64_t v38 = v21;
      __int16 v39 = 2080;
      uint64_t v40 = v22;
      __int16 v41 = 2080;
      uint64_t v42 = v23;
      __int16 v43 = 2080;
      uint64_t v44 = v24;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setDataSlot: (change states attempt) active user data slot %s -> %s, preferred Data SIM %s -> %s, BB SIM %s -> %s, current Data SIM %s", (uint8_t *)&v31, 0x48u);
      BOOL v17 = *(NSObject **)(v1 + 40);
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = subscriber::asString();
      uint64_t v26 = subscriber::asString();
      atomic_load((unsigned int *)(v1 + 4196));
      uint64_t v27 = subscriber::asString();
      uint64_t v28 = subscriber::asString();
      uint64_t v29 = subscriber::asString();
      uint64_t v30 = subscriber::asString();
      int v31 = 136316418;
      uint64_t v32 = v25;
      __int16 v33 = 2080;
      uint64_t v34 = v26;
      __int16 v35 = 2080;
      uint64_t v36 = v27;
      __int16 v37 = 2080;
      uint64_t v38 = v28;
      __int16 v39 = 2080;
      uint64_t v40 = v29;
      __int16 v41 = 2080;
      uint64_t v42 = v30;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I MSIM update: setActiveUserDualSIMMode: (change states attempt) active user %s -> %s, CT %s -> %s, BB %s -> %s", (uint8_t *)&v31, 0x3Eu);
    }
    *(_DWORD *)(v1 + 4184) = v2;
    *(_DWORD *)(v1 + 4188) = v3;
    (*(void (**)(uint64_t, const char *))(*(void *)v1 + 2096))(v1, "setDataSlot");
  }
}

uint64_t DataServiceController::preferredDataSIM(DataServiceController *this)
{
  if (capabilities::ct::supportsGemini(this) && (unsigned int v2 = atomic_load((unsigned int *)this + 1048), v2 == 2)) {
    return 2;
  }
  else {
    return 1;
  }
}

BOOL DataServiceController::preferredDataSIMKnown(DataServiceController *this)
{
  BOOL result = 1;
  if (capabilities::ct::supportsGemini(this))
  {
    if (!atomic_load((unsigned int *)this + 1048)) {
      return 0;
    }
  }
  return result;
}

uint64_t DataServiceController::msimConfigMode(DataServiceController *this)
{
  unsigned int v2 = (capabilities::ct *)capabilities::ct::supportsGemini(this);
  if (!v2) {
    return 1;
  }
  if (capabilities::ct::supportsDataSubscriptionController(v2)) {
    return 1;
  }
  unsigned int v3 = atomic_load((unsigned int *)this + 1049);
  if (v3 == 1) {
    return 1;
  }
  else {
    return 2;
  }
}

uint64_t non-virtual thunk to'DataServiceController::msimConfigMode(DataServiceController *this)
{
  return DataServiceController::msimConfigMode((DataServiceController *)((char *)this - 56));
}

void DataServiceController::handleRecommendedDataSIMChange_sync(void *a1, uint64_t a2)
{
  char v4 = (*(uint64_t (**)(void *))(*a1 + 1080))(a1);
  int v5 = a1[5];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if ((v4 & 1) == 0)
  {
    if (!v6) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v10 = "#I MSIM switch: recommendation: while Data SIM not configured yet, ignore recommendation";
    char v11 = v5;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
    return;
  }
  if (v6)
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MSIM switch: recommendation: %s", buf, 0xCu);
    int v5 = a1[5];
  }
  int v7 = (capabilities::ct *)os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    uint64_t v8 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MSIM switch: oosReason %s", buf, 0xCu);
  }
  uint64_t v9 = 3;
  switch(HIDWORD(a2))
  {
    case 0:
      uint64_t v9 = 5;
      break;
    case 1:
      break;
    case 2:
      uint64_t v9 = 4;
      break;
    case 3:
      int v7 = (capabilities::ct *)(*(uint64_t (**)(void *))(*a1 + 1072))(a1);
      if (v7 == a2) {
        uint64_t v9 = 5;
      }
      else {
        uint64_t v9 = 4;
      }
      break;
    default:
      uint64_t v9 = 0;
      break;
  }
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0)
  {
    uint64_t v23 = a1[5];
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v10 = "#E MSIM switch: called on a non-Gemini device";
    char v11 = v23;
    goto LABEL_27;
  }
  if (sub_100AF2240(a1[18], a2)
    && (*(unsigned int (**)(void *))(*a1 + 1088))(a1) != a2
    && (*(unsigned int (**)(void *, uint64_t, const char *))(*a1 + 2136))(a1, a2, "sim switch call"))
  {
    CFTypeRef cf = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, (Registry *)a1[13]);
    unsigned int v14 = ServiceMap;
    if (v15 < 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      uint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
LABEL_31:
    uint64_t v24 = (*(uint64_t (**)(void *))(*a1 + 1072))(a1);
    TypeID = (capabilities::ct *)(*(void *(**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v21 + 96))(&cf, v21, v24, 1, @"InformBBOfTempDataSubSwitch", kCFBooleanTrue, 0);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    uint64_t v26 = (BOOL *)cf;
    buf[0] = 1;
    if (cf)
    {
      CFTypeID v27 = CFGetTypeID(cf);
      TypeID = (capabilities::ct *)CFBooleanGetTypeID();
      if ((capabilities::ct *)v27 == TypeID) {
        TypeID = (capabilities::ct *)ctu::cf::assign((ctu::cf *)buf, v26, v28);
      }
      if (!buf[0]) {
        goto LABEL_68;
      }
    }
    if ((capabilities::ct::supportsDataQMIExtensions(TypeID) & 1) == 0) {
      goto LABEL_68;
    }
    uint64_t v29 = a1[5];
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I InformBBOfTempDataSubSwitch", buf, 2u);
      uint64_t v29 = a1[5];
    }
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = asString();
      uint64_t v31 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v30;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchint State = %s, cause = %s", buf, 0x16u);
    }
    int v32 = (*(uint64_t (**)(void *))(*a1 + 1072))(a1);
    __int16 v33 = (uint64_t *)*((unsigned int *)a1 + 1130);
    if (v32 == a2)
    {
      if (v33)
      {
        if (v33 != 2)
        {
          if (v33 == 1)
          {
            uint64_t v34 = a1[5];
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I toDDS received before tempSwitchComplete. set fPendingOnSwitchBackToPreferredDataSIM", buf, 2u);
            }
            *((unsigned char *)a1 + 4524) = 1;
          }
          goto LABEL_69;
        }
        uint64_t v47 = (std::mutex *)Registry::getServiceMap(v33, (Registry *)a1[13]);
        long long v48 = v47;
        if (v49 < 0)
        {
          uint64_t v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v51 = 5381;
          do
          {
            uint64_t v49 = v51;
            unsigned int v52 = *v50++;
            uint64_t v51 = (33 * v51) ^ v52;
          }
          while (v52);
        }
        std::mutex::lock(v47);
        *(void *)std::string buf = v49;
        std::string::size_type v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
        if (v53)
        {
          uint64_t v55 = v53[3];
          uint64_t v54 = (std::__shared_weak_count *)v53[4];
          if (v54)
          {
            atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v48);
            atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v54);
            char v56 = 0;
            goto LABEL_72;
          }
        }
        else
        {
          uint64_t v55 = 0;
        }
        std::mutex::unlock(v48);
        uint64_t v54 = 0;
        char v56 = 1;
LABEL_72:
        if (v55)
        {
          *(void *)std::string buf = off_101A67D98;
          *(void *)&uint8_t buf[8] = a1;
          *(void *)&uint8_t buf[16] = a2 | ((unint64_t)v9 << 32);
          int v63 = buf;
          (*(void (**)(uint64_t, void, uint64_t, unsigned char *))(*(void *)v55 + 56))(v55, 0, 1, buf);
          sub_100060644(buf);
          *((_DWORD *)a1 + 1130) = 3;
          char v57 = a1[5];
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v60 = 0;
            _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState back to DDS tempSwitchBackRequested", v60, 2u);
          }
        }
        if (v56) {
          goto LABEL_69;
        }
        uint64_t v58 = v54;
        goto LABEL_84;
      }
      uint64_t v45 = a1[5];
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v46 = "#I fTempDataSubSwitchState non-voice call back to DDS";
      goto LABEL_67;
    }
    if (v33)
    {
LABEL_69:
      sub_1000577C4(&cf);
      return;
    }
    if (v9 != 3)
    {
      uint64_t v45 = a1[5];
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
LABEL_68:
        sub_100EB570C((uint64_t)a1, a2, v9);
        goto LABEL_69;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v46 = "#I fTempDataSubSwitchState non-voice call to nDDS";
LABEL_67:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v46, buf, 2u);
      goto LABEL_68;
    }
    __int16 v35 = (std::mutex *)Registry::getServiceMap(v33, (Registry *)a1[13]);
    uint64_t v36 = v35;
    if (v37 < 0)
    {
      uint64_t v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v39 = 5381;
      do
      {
        uint64_t v37 = v39;
        unsigned int v40 = *v38++;
        uint64_t v39 = (33 * v39) ^ v40;
      }
      while (v40);
    }
    std::mutex::lock(v35);
    *(void *)std::string buf = v37;
    __int16 v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)buf);
    if (v41)
    {
      uint64_t v43 = v41[3];
      uint64_t v42 = (std::__shared_weak_count *)v41[4];
      if (v42)
      {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v36);
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v42);
        char v44 = 0;
        goto LABEL_79;
      }
    }
    else
    {
      uint64_t v43 = 0;
    }
    std::mutex::unlock(v36);
    uint64_t v42 = 0;
    char v44 = 1;
LABEL_79:
    if (v43)
    {
      *(void *)std::string buf = off_101A67D18;
      *(void *)&uint8_t buf[8] = a2 | 0x300000000;
      *(void *)&uint8_t buf[16] = a1;
      int v63 = buf;
      (*(void (**)(uint64_t, unint64_t, uint64_t, unsigned char *))(*(void *)v43 + 56))(v43, (unint64_t)&_mh_execute_header & 0xFFFFFFFF00000000 | a2, 2, buf);
      sub_100060644(buf);
      *((_DWORD *)a1 + 1130) = 1;
      __int16 v59 = a1[5];
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v60 = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState to nDDS kTempSwitchToNddsRequested", v60, 2u);
      }
    }
    if (v44) {
      goto LABEL_69;
    }
    uint64_t v58 = v42;
LABEL_84:
    sub_10004D2C8(v58);
    goto LABEL_69;
  }
}

void sub_100EB54E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v5 = va_arg(va1, const void *);
  sub_100060644((uint64_t *)va1);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t DataServiceController::checkIfSIMSwitchOK_sync(void **a1, uint64_t a2, uint64_t a3)
{
  if (((unsigned int (*)(void **))(*a1)[134])(a1) == a2
    || (((uint64_t (*)(void **, uint64_t))(*a1)[130])(a1, a2) & 1) != 0
    || (((uint64_t (*)(void **, uint64_t))(*a1)[132])(a1, a2) & 1) != 0)
  {
    return 1;
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v8)
  {
    int v9 = 136315138;
    uint64_t v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MSIM switch: cannot switch to non-preferred data SIM in roaming (%s)", (uint8_t *)&v9, 0xCu);
    return 0;
  }
  return result;
}

void sub_100EB570C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
  sub_100EB5D88((DataServiceController *)a1, "MSIM: switching SIM");
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = asString();
    atomic_load((unsigned int *)(a1 + 4200));
    uint64_t v9 = subscriber::asString();
    uint64_t v10 = subscriber::asString();
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1072))(a1);
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = "sim switch call";
    uint64_t v12 = "no data";
    *(void *)&buf[14] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    if (v11 == a2) {
      uint64_t v12 = "data";
    }
    __int16 v46 = 2080;
    uint64_t v47 = v9;
    __int16 v48 = 2080;
    uint64_t v49 = v10;
    __int16 v50 = 2080;
    uint64_t v51 = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MSIM switch: <%s: %s> (change states) fCurrentDataSIM %s ==>> %s (%s)", buf, 0x34u);
  }
  atomic_store(a2, (unsigned int *)(a1 + 4200));
  sub_100EB2834(a1, a3);
  if (*(_DWORD *)(a1 + 3520) != a2)
  {
    *(_DWORD *)(a1 + 3520) = a2;
    uint64_t v13 = *(void *)(a1 + 3512);
    if (v13) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 48))(v13, a1 + 3520);
    }
  }
  char v14 = 0;
  uint64_t v15 = 0;
  *(_DWORD *)std::string buf = v6;
  *(_DWORD *)&uint8_t buf[4] = a2;
  do
  {
    char v16 = v14;
    uint64_t v17 = sub_100AEFE40(*(void *)(a1 + 144), *(_DWORD *)&buf[4 * v15]);
    unsigned int v18 = *(void **)(v17 + 56);
    uint64_t v19 = *(void **)(v17 + 64);
    while (v18 != v19)
    {
      if ((*(uint64_t (**)(void, void, uint64_t, void))(*(void *)*v18 + 216))(*v18, 0, 1, 0))
      {
        (*(void (**)(void))(*(void *)*v18 + 1064))(*v18);
        break;
      }
      v18 += 2;
    }
    char v14 = 1;
    uint64_t v15 = 1;
  }
  while ((v16 & 1) == 0);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 4240) + 56))(*(void *)(a1 + 4240), a2);
  DataServiceController::initAgentPolicies_sync((DataServiceController *)a1);
  sub_100058DB0(__p, "currentDataSIM updated");
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 1320))(a1, 3, __p);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  DataServiceController::enableContextStateChangeNotificationRepost(a1, a2, 0, (uint64_t)"current data SIM changed", 2);
  DataServiceController::enableContextStateChangeNotificationRepost(a1, v6, 0, (uint64_t)"current data SIM changed", 2);
  if (capabilities::ct::supportsGemini(v20))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)(a1 + 104));
    uint64_t v23 = ServiceMap;
    if (v24 < 0)
    {
      uint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v24;
    CFBooleanRef v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)buf);
    if (v28)
    {
      uint64_t v30 = v28[3];
      uint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
        if (!v30) {
          goto LABEL_24;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    uint64_t v29 = 0;
    char v31 = 1;
    if (!v30)
    {
LABEL_24:
      int v32 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "MSIM switch: personality shop empty !", buf, 2u);
      }
LABEL_36:
      if ((v31 & 1) == 0) {
        sub_10004D2C8(v29);
      }
      goto LABEL_38;
    }
LABEL_28:
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v30 + 8))(buf, v30, a2);
    __int16 v33 = *(uint64_t **)(a1 + 4136);
    for (CFIndex i = *(uint64_t **)(a1 + 4144); v33 != i; v33 += 2)
    {
      uint64_t v35 = *v33;
      uint64_t v41 = *(void *)buf;
      uint64_t v42 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v35 + 352))(v35, &v41);
      if (v42) {
        sub_10004D2C8(v42);
      }
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_36;
  }
LABEL_38:
  DataServiceController::reactivateAsserted_sync(a1, a2, 33, 0);
  sub_100058DB0(v39, "new TM recommendation");
  DataServiceController::setConnectionActive_sync((uint64_t *)a1, a2, 0, 1, (const std::string::value_type *)v39, 0, 1);
  if (v40 < 0) {
    operator delete(v39[0]);
  }
  for (uint64_t j = 0; j != 2; ++j)
    DataServiceController::updateTetheringStatus_sync(a1, dword_10155B0D0[j]);
  sub_100058DB0(buf, "switch current Data SIM");
  if (a2) {
    BOOL v37 = v6 == a2;
  }
  else {
    BOOL v37 = 1;
  }
  uint64_t v38 = !v37;
  (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 2328))(a1, 3, buf, v38);
  if (SHIBYTE(v46) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100EB5CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB5D88(DataServiceController *a1, char *a2)
{
  DataServiceController::setInternetActive_sync(a1, 0, a2);
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  sub_100058DB0(v16, "shutdownAllInternetConnections_sync: forced shutdown");
  uint64_t v3 = *((void *)a1 + 14);
  v12[0] = *((void *)a1 + 13);
  v12[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v12[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v12[1]);
  }
  int v5 = v13;
  char v4 = v14;
  if (v13 != v14)
  {
    int v6 = v15;
    while ((v15(*v5) & 1) == 0)
    {
      if (++v5 == v14)
      {
        int v5 = v14;
        break;
      }
    }
    int v7 = v14;
    while (v5 != v7)
    {
      unsigned int v8 = *v5;
      memset(&v12[1], 0, 32);
      v12[0] = a1;
      LODWORD(v12[1]) = v8;
      if (SHIBYTE(v17) < 0)
      {
        sub_10004FC84(&v12[2], v16[0], (unint64_t)v16[1]);
      }
      else
      {
        *(_OWORD *)&CFTypeRef v12[2] = *(_OWORD *)v16;
        v12[4] = v17;
      }
      for (int i = 28; i != 36; ++i)
        sub_100EB5F94((uint64_t)v12, i);
      for (uint64_t j = 0; j != 2; ++j)
        sub_100EB5F94((uint64_t)v12, dword_101587968[j]);
      if (SHIBYTE(v12[4]) < 0) {
        operator delete((void *)v12[2]);
      }
      int v11 = v5 + 1;
      int v5 = v4;
      if (v11 != v4)
      {
        int v5 = v11;
        while ((v6(*v5) & 1) == 0)
        {
          if (++v5 == v4)
          {
            int v5 = v4;
            break;
          }
        }
      }
    }
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
}

void sub_100EB5F40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB5F94(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  DataServiceController::getConnection_sync(v4, *(_DWORD *)(a1 + 8), a2, &v9);
  uint64_t v5 = v9;
  if (v9 && (*(unsigned int (**)(uint64_t))(*(void *)v9 + 168))(v9))
  {
    int v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v12 = "operator()";
      __int16 v13 = 2080;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating %s...", buf, 0x16u);
    }
    unsigned int v8 = (void *)(a1 + 16);
    if (*(char *)(a1 + 39) < 0) {
      unsigned int v8 = (void *)*v8;
    }
    DataServiceController::enableContextStateChangeNotificationRepost(v4, *(_DWORD *)(a1 + 8), a2, (uint64_t)v8, 1);
    (*(void (**)(uint64_t, const char *, const char *))(*(void *)v5 + 96))(v5, "shutdownAllInternetConnections_sync", "CommCenter");
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100EB6118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::handleCriticalActivityOnSim_sync(DataServiceController *this)
{
  uint64_t v2 = *((void *)this + 18);
  uint64_t v4 = *(void *)(v2 + 8);
  uint64_t v3 = *(void *)(v2 + 16);
  if (v4 != v3)
  {
    int v6 = (char *)this + 808;
    uint64_t v7 = (void **)((char *)this + 816);
    while (1)
    {
      uint64_t v9 = *(void *)(v4 + 416);
      unsigned int v8 = *(std::__shared_weak_count **)(v4 + 424);
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v10 = *(unsigned int *)(v9 + 52);
        sub_10004D2C8(v8);
      }
      else
      {
        uint64_t v10 = *(unsigned int *)(v9 + 52);
      }
      int v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 6) + 16))(*((void *)this + 6), v10);
      if (!*(void *)(v4 + 24)) {
        goto LABEL_25;
      }
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(v4 + 416);
      uint64_t v14 = *(std::__shared_weak_count **)(v4 + 424);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (*(unsigned char *)(v13 + 49)) {
        break;
      }
      if (*(char *)(v13 + 47) < 0)
      {
        sub_10004FC84(__p, *(void **)(v13 + 24), *(void *)(v13 + 32));
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(v13 + 24);
        uint64_t v27 = *(void *)(v13 + 40);
      }
      uint64_t v19 = sub_100046F68((uint64_t)v6, __p);
      if (v7 != v19) {
        LODWORD(v1) = *((unsigned char *)v19 + 56) != 0;
      }
      BOOL v20 = v7 != v19;
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      BOOL v1 = v20 & v1;
      int v21 = *(unsigned __int8 *)(v4 + 392);
      char v22 = *v12;
      BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
      if (v21 != v1)
      {
        if (v23)
        {
          uint64_t v25 = asStringBool(v1);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v29 = v25;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I handle critical activity: setting to %s", buf, 0xCu);
        }
        (*(void (**)(void, BOOL))(**(void **)(v4 + 24) + 824))(*(void *)(v4 + 24), v1);
        *(unsigned char *)(v4 + 392) = v1;
        if (!v14) {
          goto LABEL_25;
        }
LABEL_24:
        sub_10004D2C8(v14);
        goto LABEL_25;
      }
      if (v23)
      {
        uint64_t v24 = asStringBool(v1);
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v29 = v24;
        char v16 = v22;
        uint64_t v17 = "#I handle critical activity: already handled: %s";
        uint32_t v18 = 12;
LABEL_22:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, buf, v18);
      }
LABEL_23:
      if (v14) {
        goto LABEL_24;
      }
LABEL_25:
      v4 += 432;
      if (v4 == v3) {
        return;
      }
    }
    os_log_t v15 = *v11;
    if (!os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    *(_WORD *)std::string buf = 0;
    char v16 = v15;
    uint64_t v17 = "#N handle critical activity: wrong personality type";
    uint32_t v18 = 2;
    goto LABEL_22;
  }
}

void sub_100EB63D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::handleBasebandDataSlotUpdated_sync(DataServiceController *this)
{
  unsigned int v2 = atomic_load((unsigned int *)this + 1048);
  unsigned int v3 = atomic_load((unsigned int *)this + 1050);
  uint64_t v4 = *((unsigned int *)this + 268);
  if (v2 != v4)
  {
    *((_DWORD *)this + 1130) = 0;
    sub_100EB5D88(this, "MSIM: changing preferred SIM");
    DataServiceController::updateIpcConfiguration_sync((Registry **)this, v5);
  }
  atomic_store(v4, (unsigned int *)this + 1048);
  atomic_store(v4, (unsigned int *)this + 1050);
  if (*((_DWORD *)this + 880) != v4)
  {
    *((_DWORD *)this + 880) = v4;
    uint64_t v6 = *((void *)this + 439);
    if (v6) {
      (*(void (**)(uint64_t, char *))(*(void *)v6 + 48))(v6, (char *)this + 3520);
    }
  }
  uint64_t v7 = *((void *)this + 5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    __int16 v35 = 2080;
    uint64_t v36 = subscriber::asString();
    __int16 v37 = 2080;
    uint64_t v38 = subscriber::asString();
    __int16 v39 = 2080;
    uint64_t v40 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MSIM update: (change states) fPreferredDataSIM %s ==>> %s, fCurrentDataSIM %s ==>> %s", buf, 0x2Au);
  }
  if (v3) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 1;
  }
  sub_100EB2834((uint64_t)this, v8);
  (*(void (**)(void, uint64_t))(**((void **)this + 530) + 56))(*((void *)this + 530), v4);
  (*(void (**)(void, uint64_t))(**((void **)this + 530) + 48))(*((void *)this + 530), v4);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *((Registry **)this + 13));
  int v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (!v16)
  {
    uint32_t v18 = 0;
LABEL_19:
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  uint32_t v18 = (uint64_t (***)(void))v16[3];
  uint64_t v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (v18)
  {
LABEL_20:
    uint64_t v20 = (**v18)(v18);
    sub_100EB2AFC(this, v20);
  }
LABEL_21:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  uint64_t v21 = *((void *)this + 18);
  char v22 = *(void **)(v21 + 8);
  for (int i = *(void **)(v21 + 16); v22 != i; v22 += 54)
  {
    uint64_t v25 = v22[52];
    uint64_t v24 = (std::__shared_weak_count *)v22[53];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      int v26 = *(_DWORD *)(v25 + 52);
      sub_10004D2C8(v24);
    }
    else
    {
      int v26 = *(_DWORD *)(v25 + 52);
    }
    if (v26 != v4)
    {
      uint64_t v27 = (void *)v22[7];
      CFBooleanRef v28 = (void *)v22[8];
      while (v27 != v28)
      {
        if ((*(uint64_t (**)(void, void, uint64_t, void))(*(void *)*v27 + 216))(*v27, 0, 1, 0))(*(void (**)(void, const char *, void, void))(*(void *)*v27 + 1128))(*v27, "MSIM reconfig", 0, 0); {
        v27 += 2;
        }
      }
    }
  }
  DataServiceController::initAgentPolicies_sync(this);
  sub_100058DB0(__p, "preferredDataSIM updated");
  (*(void (**)(DataServiceController *, uint64_t, void **))(*(void *)this + 1320))(this, 3, __p);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  for (uint64_t j = 0; j != 2; ++j)
    DataServiceController::updateTetheringStatus_sync((uint64_t)this, dword_10155B0D0[j]);
  sub_100058DB0(buf, "changed preferred Data SIM");
  BOOL v31 = v2 != v4 && v4 != 0;
  (*(void (**)(DataServiceController *, uint64_t, unsigned char *, BOOL))(*(void *)this + 2328))(this, 3, buf, v31);
  if (SHIBYTE(v37) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100EB68CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::notifyCellularDataSwitchingAllowed(DataServiceController *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void non-virtual thunk to'DataServiceController::notifyCellularDataSwitchingAllowed(DataServiceController *this)
{
}

void DataServiceController::processCongestionInd(os_log_t *a1, int a2)
{
  int v8 = a2;
  unsigned int v2 = a1[5];
  if (a2)
  {
    if (os_log_type_enabled(a1[5], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I processCongestionInd simSlot %s", buf, 0xCu);
    }
    int v7 = ((uint64_t (*)(os_log_t *))(*a1)[134].isa)(a1);
    *(void *)std::string buf = 1;
    long long v11 = 0u;
    uint64_t v12 = 0;
    *(void *)&uint8_t buf[8] = a1 + 412;
    sub_10005DF14((uint64_t *)&v11, (uint64_t)(a1 + 416));
    uint64_t v5 = a1[5];
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v7 == a2)
    {
      if (v6)
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I preferredDataSIM has congestion", v9, 2u);
      }
      *(void *)uint64_t v9 = &v8;
      *((unsigned char *)sub_10005CE78((uint64_t **)&v11, &v8, (uint64_t)&unk_10144E20E, (_DWORD **)v9) + 32) = 1;
    }
    else
    {
      if (v6)
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I congestion relieved or timeout", v9, 2u);
      }
      *(void *)uint64_t v9 = &v7;
      *((unsigned char *)sub_10005CE78((uint64_t **)&v11, &v7, (uint64_t)&unk_10144E20E, (_DWORD **)v9) + 32) = 0;
    }
    sub_100EB91E0((uint64_t)buf);
  }
  else if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "invalid simSlot from baseband's CongestionInd", buf, 2u);
  }
}

void sub_100EB6C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100EB91E0((uint64_t)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'DataServiceController::processCongestionInd(uint64_t a1, int a2)
{
}

void DataServiceController::dumpMsimData_sync(DataServiceController *this)
{
  unsigned int v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========================== MSIM ==========================", buf, 2u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = subscriber::asString();
    atomic_load((unsigned int *)this + 1048);
    uint64_t v4 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v39 = v3;
    __int16 v40 = 2080;
    uint64_t v41 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: PreferredDataSIM = %s / %s", buf, 0x16u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = subscriber::asString();
    atomic_load((unsigned int *)this + 1050);
    uint64_t v6 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v39 = v5;
    __int16 v40 = 2080;
    uint64_t v41 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: CurrentDataSIM = %s / %s", buf, 0x16u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = subscriber::asString();
    uint64_t v8 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v39 = v7;
    __int16 v40 = 2080;
    uint64_t v41 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: BasebandDataSIM = %s / %s", buf, 0x16u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v39 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: UIDataSIM = %s", buf, 0xCu);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = subscriber::asString();
    atomic_load((unsigned int *)this + 1049);
    uint64_t v11 = subscriber::asString();
    uint64_t v12 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v39 = v10;
    __int16 v40 = 2080;
    uint64_t v41 = v11;
    __int16 v42 = 2080;
    uint64_t v43 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: config mode = %s / %s, target = %s", buf, 0x20u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = asStringBool(*((void *)this + 545) != 0);
    uint64_t v14 = subscriber::asString();
    uint64_t v15 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v39 = v13;
    __int16 v40 = 2080;
    uint64_t v41 = v14;
    __int16 v42 = 2080;
    uint64_t v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: backoff timer: %s, sim %s, mode %s", buf, 0x20u);
    unsigned int v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(*((void *)this + 534) != 0);
    uint64_t v17 = asStringBool(*((unsigned char *)this + 4336));
    uint64_t v18 = asStringBool(*((void *)this + 536) != 0);
    uint64_t v19 = asString();
    uint64_t v20 = subscriber::asString();
    uint64_t v21 = subscriber::asString();
    uint64_t v22 = asStringBool(*((unsigned char *)this + 4352));
    *(_DWORD *)std::string buf = 136316674;
    uint64_t v39 = v16;
    __int16 v40 = 2080;
    uint64_t v41 = v17;
    __int16 v42 = 2080;
    uint64_t v43 = v18;
    __int16 v44 = 2080;
    uint64_t v45 = v19;
    __int16 v46 = 2080;
    uint64_t v47 = v20;
    __int16 v48 = 2080;
    uint64_t v49 = v21;
    __int16 v50 = 2080;
    uint64_t v51 = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: waiting: fMSIMAirplaneAssertion = %s, fAlreadyInAirplaneMode = %s, fMSIMPowerAssertion = %s, fRemapStatus = %s, fSimSlot = %s, fMSimConfigMode = %s, fConfigResult = %s", buf, 0x48u);
  }
  uint64_t v23 = *((void *)this + 18);
  uint64_t v25 = *(void *)(v23 + 8);
  for (uint64_t i = *(void *)(v23 + 16); v25 != i; v25 += 432)
  {
    int v26 = *((void *)this + 5);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *(std::__shared_weak_count **)(v25 + 424);
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
      }
      uint64_t v28 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v39 = v28;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: for %s:", buf, 0xCu);
    }
    uint64_t v30 = *(void *)(v25 + 416);
    uint64_t v29 = *(std::__shared_weak_count **)(v25 + 424);
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      if (v30)
      {
        uint64_t v30 = *(void *)(v25 + 416);
        BOOL v31 = *(std::__shared_weak_count **)(v25 + 424);
        if (!v31) {
          goto LABEL_28;
        }
        char v32 = 0;
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        goto LABEL_29;
      }
    }
    else if (v30)
    {
      BOOL v31 = 0;
LABEL_28:
      char v32 = 1;
LABEL_29:
      char v33 = (BOOL *)sub_100046F68((uint64_t)this + 808, (void **)(v30 + 24));
      if ((v32 & 1) == 0) {
        sub_10004D2C8(v31);
      }
      if ((BOOL *)((char *)this + 816) != v33)
      {
        uint64_t v34 = *((void *)this + 5);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = asStringBool(v33[56]);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v39 = v35;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: CriticalActivityOnSimPersonality = %s", buf, 0xCu);
        }
      }
    }
    uint64_t v36 = *((void *)this + 5);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = asStringBool(*(unsigned char *)(v25 + 392));
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v39 = v37;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I DATA:: MSIM:: simCriticalActivity = %s", buf, 0xCu);
    }
  }
}

void sub_100EB722C(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EB724C(uint64_t **a1)
{
  char v1 = a1;
  sub_100EB2C74(**a1, *((unsigned int *)*a1 + 2), *((_DWORD *)*a1 + 3), 0, 0, *((unsigned char *)*a1 + 16), (uint64_t)"onFullCompleteMSIM_sync failure");
  operator delete();
}

void sub_100EB72B8()
{
}

void *sub_100EB72E4(void *a1)
{
  *a1 = off_101A67AE0;
  unsigned int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100EB7348(void *a1)
{
  *a1 = off_101A67AE0;
  unsigned int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_100EB73CC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unsigned int v2 = operator new(0x90uLL);
  void *v2 = off_101A67AE0;
  sub_100EB76E0((uint64_t)(v2 + 1), v1);
  return v2;
}

double sub_100EB7420(uint64_t a1, void *a2)
{
  *a2 = off_101A67AE0;
  *(void *)&double result = sub_100EB76E0((uint64_t)(a2 + 1), a1 + 8).n128_u64[0];
  return result;
}

void sub_100EB744C(uint64_t a1)
{
}

void sub_100EB7454(void *a1)
{
  sub_100EB776C(a1 + 1);

  operator delete(a1);
}

void sub_100EB7490(uint64_t a1)
{
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 16))
      {
        uint64_t v5 = *(void *)(a1 + 40);
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(void *)(a1 + 72);
        if (v6) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
        }
        *(void *)&v7[9] = *(void *)(a1 + 112);
        v7[11] = *(_DWORD *)(a1 + 120);
        *(void *)uint64_t v7 = 0;
        *(void *)&void v7[2] = 0;
        sub_10003E168(v7, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100EB7684(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EB7694(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB76D4()
{
}

__n128 sub_100EB76E0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v2 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 40);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(void *)(a1 + 40) = v4;
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 84) = *(_OWORD *)(a2 + 84);
  *(_OWORD *)(a1 + 72) = v6;
  uint64_t v7 = *(void *)(a2 + 104);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(void *)(a1 + 104) = v7;
  __n128 result = *(__n128 *)(a2 + 120);
  *(__n128 *)(a1 + 120) = result;
  return result;
}

void sub_100EB776C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t *sub_100EB77C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 4272);
  if (v3)
  {
    int v4 = *(_DWORD *)(v3 + 68);
    if (v4 != 2)
    {
      if (v4)
      {
        uint64_t v5 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = *(void *)(v1 + 112);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v30 = v12;
          uint64_t v7 = "MSIM update: Could not acquire airplane mode assertion: trying to setup MSIM anyway... (reason '%s')";
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v5 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          uint64_t v6 = *(void *)(v1 + 112);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v30 = v6;
          uint64_t v7 = "MSIM update: Could not acquire airplane mode assertion: revoked: trying to setup MSIM anyway... (reason '%s')";
LABEL_17:
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
        }
      }
LABEL_18:
      sub_100EB7BC4(v1 + 16);
      goto LABEL_19;
    }
    if (!*(unsigned char *)(v1 + 8))
    {
      uint64_t v5 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(v1 + 112);
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = v13;
        uint64_t v7 = "MSIM update: Could not acquire airplane mode assertion: not granted: trying to setup MSIM anyway... (reason '%s')";
        goto LABEL_17;
      }
      goto LABEL_18;
    }
    if (*(_DWORD *)(v2 + 836) == 2)
    {
      *(unsigned char *)(v2 + 4336) = 1;
      uint64_t v10 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(v1 + 112);
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MSIM update: Acquired airplane mode assertion - already in airplane mode (reason '%s')", buf, 0xCu);
      }
      goto LABEL_18;
    }
    uint64_t v15 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(v1 + 112);
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v30 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I MSIM update: Acquired airplane mode assertion - postpone execution till actual airplane mode (reason '%s')", buf, 0xCu);
    }
    uint64_t v18 = *(void *)(v1 + 16);
    uint64_t v17 = *(void *)(v1 + 24);
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v27 = *(void *)(v1 + 32);
    int v28 = *(_DWORD *)(v1 + 40);
    uint64_t v20 = *(void *)(v1 + 48);
    uint64_t v19 = *(void *)(v1 + 56);
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = (char *)operator new(0x68uLL);
    *(void *)uint64_t v21 = off_101A67B50;
    *((void *)v21 + 1) = v18;
    uint64_t v22 = v27;
    *((void *)v21 + 2) = v17;
    *((void *)v21 + 3) = v22;
    *((_DWORD *)v21 + 8) = v28;
    *((void *)v21 + 5) = v20;
    *((void *)v21 + 6) = v19;
    long long v23 = *(_OWORD *)(v1 + 64);
    *(_OWORD *)(v21 + 68) = *(_OWORD *)(v1 + 76);
    *(_OWORD *)(v21 + 56) = v23;
    LODWORD(v22) = *(_DWORD *)(v1 + 104);
    *((void *)v21 + 11) = *(void *)(v1 + 96);
    *((_DWORD *)v21 + 24) = v22;
    BOOL v31 = v21;
    sub_100335220(buf, (void *)(v2 + 4304));
    sub_10003B34C(buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = *(void *)(v1 + 112);
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v30 = v24;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "MSIM update: airplane mode assertion gone somehow ?! (reason '%s')", buf, 0xCu);
    }
    char v9 = *(unsigned char *)(v2 + 4336) == 0;
    sub_100EB3C00(v2 + 4272);
    sub_100EB2C74(v2, *(unsigned int *)(v1 + 120), *(_DWORD *)(v1 + 124), 0, 0, v9, (uint64_t)"lost airplane assertion");
  }
LABEL_19:
  sub_100EB7B64(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100EB7B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  sub_100EB7B64(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EB7B64(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 56);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

void sub_100EB7BC4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)a1)
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
        if (v7)
        {
          uint64_t v8 = *(void *)(a1 + 80);
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v28 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MSIM update: onAirplaneMode (reason '%s')", buf, 0xCu);
        }
        *(_DWORD *)(v3 + 4344) = *(_DWORD *)(a1 + 24);
        uint64_t v9 = *(unsigned int *)(a1 + 88);
        if (!v9) {
          uint64_t v9 = atomic_load((unsigned int *)(v3 + 4196));
        }
        *(_DWORD *)(v3 + 4348) = v9;
        int v10 = capabilities::ct::supportsDualSIMSingleStackWithCrossMapping((capabilities::ct *)v7);
        uint64_t v11 = *(void *)(v3 + 144);
        if (v10)
        {
          if (!sub_100AF2240(v11, 1) || !*(void *)(sub_100AEFE40(*(void *)(v3 + 144), 1) + 24)) {
            goto LABEL_20;
          }
          uint64_t v12 = *(void *)(sub_100AEFE40(*(void *)(v3 + 144), 1) + 24);
          uint64_t v13 = *(unsigned int *)(a1 + 24);
          uint64_t v15 = *(void *)(a1 + 32);
          uint64_t v14 = *(void *)(a1 + 40);
          if (v14) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
          }
          uint64_t v26 = 0;
          uint64_t v16 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v16 = off_101A67BD0;
          *((void *)v16 + 1) = v15;
          *((void *)v16 + 2) = v14;
          *(_OWORD *)(v16 + 24) = *(_OWORD *)(a1 + 48);
          *(_OWORD *)(v16 + 36) = *(_OWORD *)(a1 + 60);
          uint64_t v26 = v16;
          uint64_t v17 = v25;
          (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)v12 + 808))(v12, v13, v25, v9);
        }
        else
        {
          if (!sub_100AF2240(v11, *(_DWORD *)(a1 + 24))
            || !*(void *)(sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(a1 + 24)) + 24))
          {
            goto LABEL_20;
          }
          uint64_t v18 = *(void *)(sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(a1 + 24)) + 24);
          uint64_t v19 = *(unsigned int *)(a1 + 24);
          uint64_t v21 = *(void *)(a1 + 32);
          uint64_t v20 = *(void *)(a1 + 40);
          if (v20) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 16), 1uLL, memory_order_relaxed);
          }
          uint64_t v24 = 0;
          uint64_t v22 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v22 = off_101A67BD0;
          *((void *)v22 + 1) = v21;
          *((void *)v22 + 2) = v20;
          *(_OWORD *)(v22 + 24) = *(_OWORD *)(a1 + 48);
          *(_OWORD *)(v22 + 36) = *(_OWORD *)(a1 + 60);
          uint64_t v24 = v22;
          uint64_t v17 = v23;
          (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)v18 + 808))(v18, v19, v23, v9);
        }
        sub_100060644(v17);
      }
LABEL_20:
      sub_10004D2C8(v5);
    }
  }
}

void sub_100EB7E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100060644(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void *sub_100EB7ED0(void *a1)
{
  *a1 = off_101A67B50;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100EB7F28(void *a1)
{
  *a1 = off_101A67B50;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

__n128 sub_100EB7FA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x68uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)uint64_t v2 = off_101A67B50;
  *((void *)v2 + 1) = v4;
  *((void *)v2 + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  *((void *)v2 + 6) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  __n128 result = *(__n128 *)(a1 + 68);
  *(__n128 *)(v2 + 68) = result;
  *((void *)v2 + 11) = *(void *)(a1 + 88);
  *((_DWORD *)v2 + 24) = *(_DWORD *)(a1 + 96);
  return result;
}

__n128 sub_100EB8044(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)a2 = off_101A67B50;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  *(void *)(a2 + 24) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(void *)(a2 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a2 + 68) = *(_OWORD *)(a1 + 68);
  *(__n128 *)(a2 + 56) = result;
  uint64_t v7 = *(void *)(a1 + 88);
  *(_DWORD *)(a2 + 96) = *(_DWORD *)(a1 + 96);
  *(void *)(a2 + 88) = v7;
  return result;
}

void sub_100EB80C4(uint64_t a1)
{
}

void sub_100EB80CC(void *a1)
{
  sub_100EB815C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100EB8108(uint64_t a1)
{
}

uint64_t sub_100EB8110(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB8150()
{
}

void sub_100EB815C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_100EB81AC(void *a1)
{
  *a1 = off_101A67BD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100EB81F8(void *a1)
{
  *a1 = off_101A67BD0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

__n128 sub_100EB8264(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)uint64_t v2 = off_101A67BD0;
  *((void *)v2 + 1) = v4;
  *((void *)v2 + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 36);
  *(__n128 *)(v2 + 36) = result;
  return result;
}

__n128 sub_100EB82D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)a2 = off_101A67BD0;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 24);
  *(_OWORD *)(a2 + 36) = *(_OWORD *)(a1 + 36);
  *(__n128 *)(a2 + 24) = result;
  return result;
}

void sub_100EB8318(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100EB8328(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100EB8368(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(v3 != 0);
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    __int16 v13 = 2080;
    uint64_t v14 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MSIM update: configuration completed with result %s (reason '%s' msimMode %s)", buf, 0x20u);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      if (!v3 && *(void *)(a1 + 8))
      {
        sub_100EB3C00(v4 + 4272);
        int v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), *(unsigned int *)(a1 + 32));
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *(void *)(a1 + 40);
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E MSIM update: Cannot update preferredData SIM, will try again (reason '%s')", buf, 0xCu);
        }
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        sub_10003E168(buf, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100EB85B4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100EB85E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB8620()
{
}

void sub_100EB862C(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100EB2C74(**a1, *((unsigned int *)*a1 + 2), *((_DWORD *)*a1 + 3), 0, 0, *((unsigned char *)*a1 + 16), (uint64_t)"updatePreferredDataSIM_sync failure");
  operator delete();
}

void sub_100EB8698()
{
}

uint64_t sub_100EB86C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EB86D4(uint64_t **a1)
{
  uint64_t v19 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *((unsigned __int8 *)v1 + 16);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I temporaryDataSubSwitchRequestComplete success = %d", buf, 8u);
  }
  uint64_t v5 = (uint64_t *)(v2 + 4524);
  if (!*(unsigned char *)(v2 + 4524))
  {
    *(_DWORD *)(v2 + 4520) = 2;
    uint64_t v16 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState to nDDS kTempSwitchToNddsCompleted", buf, 2u);
    }
    sub_100EB570C(v2, *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
LABEL_20:
    operator delete();
  }
  *(unsigned char *)uint64_t v5 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(v2 + 104));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    __int16 v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14)
      {
LABEL_18:
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_20;
      }
LABEL_16:
      uint64_t v17 = v1[1];
      v20[0] = off_101A67C98;
      v20[1] = v2;
      uint64_t v20[2] = v17;
      unint64_t v20[3] = v20;
      (*(void (**)(uint64_t, void, uint64_t, void *))(*(void *)v14 + 56))(v14, 0, 1, v20);
      sub_100060644(v20);
      *(_DWORD *)(v2 + 4520) = 3;
      uint64_t v18 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState back to DDS kTempSwitchBackRequested due to pending", buf, 2u);
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  __int16 v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_18;
  }
  goto LABEL_16;
}