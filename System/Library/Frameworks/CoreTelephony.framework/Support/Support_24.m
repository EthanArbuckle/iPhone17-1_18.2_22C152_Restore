void sub_100CFED90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v25;
  uint64_t v26;

  sub_100057D78(&a9);
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1003DD210(&a25);
  sub_100D156EC(v26);
  sub_100D1541C(v25);
  _Unwind_Resume(a1);
}

void sub_100CFEE08(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v39[0] = a2;
  v39[1] = a3;
  if (a4)
  {
    v5 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v5();
    return;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v30 = 0;
  v31 = 0;
  sub_100324590(&v30);
  memset(__p, 0, sizeof(__p));
  ctu::cf::assign();
  *(_OWORD *)v28 = *(_OWORD *)__p;
  v29 = __p[2];
  ctu::hex((uint64_t *)__p, (ctu *)v39, (const void *)0x10, v7);
  uint64_t v26 = v30;
  v27 = v31;
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v8 = sub_100CD0B54((uint64_t)__p, (char *)v28, &v26);
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    if ((v8 & 1) == 0) {
      goto LABEL_16;
    }
  }
  else if ((v8 & 1) == 0)
  {
    goto LABEL_16;
  }
  if (!*(unsigned char *)(v30 + 120)) {
    goto LABEL_22;
  }
  if (*(char *)(v30 + 95) < 0)
  {
    if (*(void *)(v30 + 80)) {
      goto LABEL_22;
    }
  }
  else if (*(unsigned char *)(v30 + 95))
  {
    goto LABEL_22;
  }
  if (*(void *)(a1 + 56)) {
    v10 = sub_1000810B8;
  }
  else {
    v10 = 0;
  }
  if (!v10)
  {
LABEL_16:
    v9 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    goto LABEL_45;
  }
LABEL_22:
  (*(void (**)(long long *__return_ptr))(**(void **)(v6 + 128) + 640))(&v38);
  (*(void (**)(void **__return_ptr))(*(void *)v38 + 32))(__p);
  uint64_t v11 = v30;
  sub_10005CBB4((uint64_t *)(v30 + 96));
  *(_OWORD *)(v11 + 96) = *(_OWORD *)__p;
  *(void **)(v11 + 112) = __p[2];
  memset(__p, 0, sizeof(__p));
  v32 = __p;
  sub_100047F64(&v32);
  if (*((void *)&v38 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v38 + 1));
  }
  if (*(void *)(a1 + 56)) {
    v12 = sub_1000810B8;
  }
  else {
    v12 = 0;
  }
  if (v12)
  {
    memset(__p, 0, sizeof(__p));
    ctu::cf::assign();
    v13 = __p[0];
    *(void **)&long long v38 = __p[1];
    *(void **)((char *)&v38 + 7) = *(void **)((char *)&__p[1] + 7);
    char v14 = HIBYTE(__p[2]);
    uint64_t v15 = v30;
    if (*(char *)(v30 + 95) < 0) {
      operator delete(*(void **)(v30 + 72));
    }
    uint64_t v16 = v38;
    *(void *)(v15 + 72) = v13;
    *(void *)(v15 + 80) = v16;
    *(void *)(v15 + 87) = *(void *)((char *)&v38 + 7);
    *(unsigned char *)(v15 + 95) = v14;
  }
  int v17 = sub_100CFDC54(v6, *(unsigned __int8 *)(a1 + 68), (uint64_t)v39);
  v9 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  if (v17)
  {
    v9();
    *(_DWORD *)(v6 + 1040) = *(_DWORD *)(a1 + 64);
    uint64_t v18 = *(void *)(v6 + 160);
    int v19 = *(_DWORD *)(a1 + 64);
    uint64_t v25 = 0;
    long long v24 = 0uLL;
    v33[0] = 0;
    char v34 = 0;
    sub_1003DB514((uint64_t)__p, v19, &v24, (uint64_t)v33, 0);
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v18 + 96))(v18, 1, __p);
    if (v37[216]) {
      sub_1000C584C((uint64_t)v37);
    }
    if (v36 < 0) {
      operator delete(__p[1]);
    }
    if (v34) {
      sub_1000C584C((uint64_t)v33);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)v24);
    }
    (*(void (**)(void))(**(void **)(v6 + 96) + 16))(*(void *)(v6 + 96));
    uint64_t v20 = *(void *)(v6 + 256);
    uint64_t v22 = v30;
    v23 = v31;
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v21[0] = 0;
    v21[176] = 0;
    (*(void (**)(uint64_t, void *, uint64_t *, void, unsigned char *))(*(void *)v20 + 32))(v20, v39, &v22, 0, v21);
    sub_10030AEBC((uint64_t)v21);
    if (v23) {
      sub_10004D2C8(v23);
    }
    (*(void (**)(void, void))(**(void **)(v6 + 208) + 96))(*(void *)(v6 + 208), *(unsigned __int8 *)(a1 + 69));
    goto LABEL_46;
  }
LABEL_45:
  v9();
LABEL_46:
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
}

void sub_100CFF2B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46)
{
  if (a33) {
    sub_10004D2C8((std::__shared_weak_count *)a33);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a46) {
    sub_10004D2C8((std::__shared_weak_count *)a46);
  }
  _Unwind_Resume(a1);
}

const void **sub_100CFF394(void *a1, int a2, char a3, const void **a4, const void **a5, const void **a6, const void **a7, char a8, uint64_t a9)
{
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 1174405120;
  v21[2] = sub_100CFF548;
  v21[3] = &unk_101A50788;
  int v26 = a2;
  v21[4] = a9;
  v21[5] = a1;
  sub_100083DA4(&v22, a4);
  sub_100083DA4(&v23, a5);
  sub_100083DA4(&v24, a6);
  sub_100083DA4(&v25, a7);
  char v27 = a8;
  char v28 = a3;
  uint64_t v15 = (std::__shared_weak_count *)a1[2];
  if (!v15 || (uint64_t v16 = a1[1], (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v18 = v17;
  int v19 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v16;
  uint64_t v30 = v18;
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v21;
  dispatch_async(v19, block);
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_10004D2C8(v18);
  sub_1000558F4(&v25);
  sub_1000558F4(&v24);
  sub_1000558F4(&v23);
  return sub_1000558F4(&v22);
}

void sub_100CFF548(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 80));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I handleUserEnteredRemoteDataPlanFlowTriggered", buf, 2u);
  }
  *(_OWORD *)buf = 0u;
  long long v15 = 0u;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 128) + 640))(&v12);
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v12 + 24))(buf);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if ((buf[0] & 2) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 80);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 1174405120;
    v5[2] = sub_100CFF7C8;
    v5[3] = &unk_101A50750;
    v5[4] = *(void *)(a1 + 32);
    v5[5] = v2;
    sub_100083DA4(&v6, (const void **)(a1 + 48));
    sub_100083DA4(&v7, (const void **)(a1 + 56));
    sub_100083DA4(&v8, (const void **)(a1 + 64));
    sub_100083DA4(&v9, (const void **)(a1 + 72));
    int v10 = *(_DWORD *)(a1 + 80);
    __int16 v11 = *(_WORD *)(a1 + 84);
    sub_100CFE56C(v2, v4, (uint64_t)v5);
    sub_1000558F4(&v9);
    sub_1000558F4(&v8);
    sub_1000558F4(&v7);
    sub_1000558F4(&v6);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_100CFF770(_Unwind_Exception *a1)
{
  sub_1000558F4(v4);
  sub_1000558F4(v3);
  sub_1000558F4(v2);
  sub_1000558F4(v1);
  if (*(char *)(v5 - 65) < 0) {
    operator delete(*(void **)(v5 - 88));
  }
  _Unwind_Resume(a1);
}

void sub_100CFF7C8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v45[0] = a2;
  v45[1] = a3;
  if (a4)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v5();
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v36 = 0;
    v37 = 0;
    sub_100324590(&v36);
    memset(v41, 0, sizeof(v41));
    ctu::cf::assign();
    uint64_t v7 = *(void *)v41;
    *(void *)&long long v44 = *(void *)&v41[8];
    *(void *)((char *)&v44 + 7) = *(void *)&v41[15];
    char v8 = v41[23];
    uint64_t v9 = v36;
    if (*(char *)(v36 + 23) < 0) {
      operator delete(*(void **)v36);
    }
    *(void *)uint64_t v9 = v7;
    *(void *)(v9 + 8) = v44;
    *(void *)(v9 + 15) = *(void *)((char *)&v44 + 7);
    *(unsigned char *)(v9 + 23) = v8;
    if (*(void *)(a1 + 56)) {
      int v10 = sub_1000810B8;
    }
    else {
      int v10 = 0;
    }
    if (v10)
    {
      memset(v41, 0, sizeof(v41));
      ctu::cf::assign();
      uint64_t v11 = *(void *)v41;
      *(void *)&long long v44 = *(void *)&v41[8];
      *(void *)((char *)&v44 + 7) = *(void *)&v41[15];
      char v12 = v41[23];
      uint64_t v13 = v36;
      if (*(char *)(v36 + 71) < 0) {
        operator delete(*(void **)(v36 + 48));
      }
      uint64_t v14 = v44;
      *(void *)(v13 + 48) = v11;
      *(void *)(v13 + 56) = v14;
      *(void *)(v13 + 63) = *(void *)((char *)&v44 + 7);
      *(unsigned char *)(v13 + 71) = v12;
    }
    if (*(void *)(a1 + 64)) {
      long long v15 = sub_1000810B8;
    }
    else {
      long long v15 = 0;
    }
    if (v15)
    {
      memset(v41, 0, sizeof(v41));
      ctu::cf::assign();
      uint64_t v16 = *(void *)v41;
      *(void *)&long long v44 = *(void *)&v41[8];
      *(void *)((char *)&v44 + 7) = *(void *)&v41[15];
      char v17 = v41[23];
      uint64_t v18 = v36;
      if (*(char *)(v36 + 47) < 0) {
        operator delete(*(void **)(v36 + 24));
      }
      uint64_t v19 = v44;
      *(void *)(v18 + 24) = v16;
      *(void *)(v18 + 32) = v19;
      *(void *)(v18 + 39) = *(void *)((char *)&v44 + 7);
      *(unsigned char *)(v18 + 47) = v17;
    }
    if (*(void *)(a1 + 72)) {
      uint64_t v20 = sub_1000810B8;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v20)
    {
      memset(v41, 0, sizeof(v41));
      ctu::cf::assign();
      uint64_t v21 = *(void *)v41;
      *(void *)&long long v44 = *(void *)&v41[8];
      *(void *)((char *)&v44 + 7) = *(void *)&v41[15];
      char v22 = v41[23];
      uint64_t v23 = v36;
      if (*(char *)(v36 + 95) < 0) {
        operator delete(*(void **)(v36 + 72));
      }
      uint64_t v24 = v44;
      *(void *)(v23 + 72) = v21;
      *(void *)(v23 + 80) = v24;
      *(void *)(v23 + 87) = *(void *)((char *)&v44 + 7);
      *(unsigned char *)(v23 + 95) = v22;
    }
    (*(void (**)(long long *__return_ptr))(**(void **)(v6 + 128) + 640))(&v44);
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v44 + 32))(v41);
    uint64_t v25 = v36;
    sub_10005CBB4((uint64_t *)(v36 + 96));
    *(_OWORD *)(v25 + 96) = *(_OWORD *)v41;
    *(void *)(v25 + 112) = *(void *)&v41[16];
    memset(v41, 0, sizeof(v41));
    long long v38 = (void **)v41;
    sub_100047F64(&v38);
    if (*((void *)&v44 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v44 + 1));
    }
    int v26 = sub_100CFDC54(v6, *(unsigned __int8 *)(a1 + 84), (uint64_t)v45);
    char v27 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    if (v26)
    {
      v27();
      *(_DWORD *)(v6 + 1040) = *(_DWORD *)(a1 + 80);
      uint64_t v28 = *(void *)(v6 + 160);
      int v29 = *(_DWORD *)(a1 + 80);
      uint64_t v35 = 0;
      long long v34 = 0uLL;
      v39[0] = 0;
      char v40 = 0;
      sub_1003DB514((uint64_t)v41, v29, &v34, (uint64_t)v39, 0);
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v28 + 96))(v28, 1, v41);
      if (v43[216]) {
        sub_1000C584C((uint64_t)v43);
      }
      if (v42 < 0) {
        operator delete(*(void **)&v41[8]);
      }
      if (v40) {
        sub_1000C584C((uint64_t)v39);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete((void *)v34);
      }
      (*(void (**)(void))(**(void **)(v6 + 96) + 16))(*(void *)(v6 + 96));
      uint64_t v30 = *(void *)(v6 + 256);
      uint64_t v32 = v36;
      v33 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v31[0] = 0;
      v31[176] = 0;
      (*(void (**)(uint64_t, void *, uint64_t *, void, unsigned char *))(*(void *)v30 + 32))(v30, v45, &v32, 0, v31);
      sub_10030AEBC((uint64_t)v31);
      if (v33) {
        sub_10004D2C8(v33);
      }
      (*(void (**)(void, void))(**(void **)(v6 + 208) + 96))(*(void *)(v6 + 208), *(unsigned __int8 *)(a1 + 85));
    }
    else
    {
      v27();
    }
    if (v37) {
      sub_10004D2C8(v37);
    }
  }
}

void sub_100CFFC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  if (a34) {
    sub_10004D2C8((std::__shared_weak_count *)a34);
  }
  if (a39) {
    sub_10004D2C8((std::__shared_weak_count *)a39);
  }
  _Unwind_Resume(a1);
}

const void **sub_100CFFD3C(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 6, a2 + 6);
  sub_100083DA4(a1 + 7, a2 + 7);
  sub_100083DA4(a1 + 8, a2 + 8);

  return sub_100083DA4(a1 + 9, a2 + 9);
}

const void **sub_100CFFD9C(const void **a1)
{
  v1 = a1 + 6;
  uint64_t v2 = a1 + 7;
  v3 = a1 + 8;
  sub_1000558F4(a1 + 9);
  sub_1000558F4(v3);
  sub_1000558F4(v2);

  return sub_1000558F4(v1);
}

void sub_100CFFDF8(void *a1, int a2, char a3, uint64_t a4)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100CFFF18;
  v10[3] = &unk_101A507E8;
  int v11 = a2;
  v10[4] = a4;
  v10[5] = a1;
  char v12 = a3;
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  char v8 = v7;
  uint64_t v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v6;
  uint64_t v14 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v8);
}

uint64_t sub_100CFFF18(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 48));
  uint64_t v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleAddNewRemotePlanTapped", buf, 2u);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 48);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100D00024;
  v7[3] = &unk_101A507C0;
  v7[4] = *(void *)(a1 + 32);
  v7[5] = v2;
  int v8 = v5;
  v7[6] = v3;
  char v9 = *(unsigned char *)(a1 + 52);
  return sub_100CFE56C(v2, v5, (uint64_t)v7);
}

void sub_100D00024(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v98 = a2;
  uint64_t v99 = a3;
  uint64_t v5 = *(void *)(a1 + 40);
  switch(a4)
  {
    case 0:
      if (!sub_100CFDC54(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 60), (uint64_t)&v98))
      {
        uint64_t v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
        goto LABEL_32;
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 128) + 648))(v87);
      if ((***(unsigned int (****)(void, void))v87)(*(void *)v87, *(unsigned int *)(a1 + 56)))
      {
        sub_1008EB218((uint64_t *)(v5 + 896), (uint64_t)buf);
        BOOL v9 = buf[0] == 1;
        if (v84 < 0) {
          operator delete(__p);
        }
        if (v82 < 0) {
          operator delete(v81);
        }
        if (v80 < 0) {
          operator delete(v79);
        }
        if (v78 < 0) {
          operator delete(v77);
        }
        if (v76 < 0) {
          operator delete(v75);
        }
        if (v74 < 0) {
          operator delete(v73);
        }
        if (SHIBYTE(v72) < 0) {
          operator delete(*(void **)&buf[8]);
        }
      }
      else
      {
        BOOL v9 = 0;
      }
      if (*(void *)&v87[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v87[8]);
      }
      if (v9)
      {
        int v11 = **(NSObject ***)(a1 + 48);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I carrier needs VoLTE setting to default", buf, 2u);
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 128) + 648))(buf);
        (*(void (**)(void))(**(void **)buf + 16))(*(void *)buf);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 128) + 648))(buf);
        (*(void (**)(void))(**(void **)buf + 8))(*(void *)buf);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      char v12 = *(void **)(a1 + 32);
      if (v12) {
        char v12 = _Block_copy(v12);
      }
      uint64_t v13 = *(const void **)(v5 + 1216);
      *(void *)(v5 + 1216) = v12;
      if (v13) {
        _Block_release(v13);
      }
      uint64_t v14 = **(NSObject ***)(a1 + 48);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I launch entitlements flow", buf, 2u);
      }
      *(_DWORD *)(v5 + 1040) = *(_DWORD *)(a1 + 56);
      long long v97 = 0u;
      long long v96 = 0u;
      long long v95 = 0u;
      long long v94 = 0u;
      long long v93 = 0u;
      long long v92 = 0u;
      long long v91 = 0u;
      *(_OWORD *)__src = 0u;
      long long v89 = 0u;
      *(_OWORD *)v87 = 0u;
      long long v88 = 0u;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 160) + 256))(v87);
      if (v87[0])
      {
        RemoteVinylInfo::findProfile();
        if (!v85)
        {
          v66 = 0;
          v67 = 0;
          sub_100324590(&v66);
          if (!v87[0]) {
            __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
          }
          v33 = v66;
          if (SBYTE7(v91) < 0)
          {
            sub_10004FC84(v62, __src[0], (unint64_t)__src[1]);
          }
          else
          {
            *(_OWORD *)v62 = *(_OWORD *)__src;
            uint64_t v63 = v91;
          }
          sub_100D00EE0((uint64_t)&v64, (uint64_t *)v62);
          std::string::size_type v34 = v33[4].__r_.__value_.__r.__words[2];
          std::string::size_type size = v33[4].__r_.__value_.__l.__size_;
          if (size >= v34)
          {
            std::string::pointer data = v33[4].__r_.__value_.__l.__data_;
            unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(size - (void)data) >> 3);
            unint64_t v39 = v38 + 1;
            if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v34 - (void)data) >> 3);
            if (2 * v40 > v39) {
              unint64_t v39 = 2 * v40;
            }
            if (v40 >= 0x555555555555555) {
              unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v41 = v39;
            }
            v73 = &v33[4].__r_.__value_.__r.__words[2];
            if (v41) {
              char v42 = (char *)sub_10004812C((uint64_t)&v33[4].__r_.__value_.__r.__words[2], v41);
            }
            else {
              char v42 = 0;
            }
            v43 = &v42[24 * v38];
            *(void *)buf = v42;
            *(void *)&buf[8] = v43;
            v72 = &v42[24 * v41];
            *(_OWORD *)v43 = v64;
            *((void *)v43 + 2) = v65;
            std::string::size_type v71 = (std::string::size_type)(v43 + 24);
            sub_100048204((uint64_t *)&v33[4], buf);
            std::string::size_type v36 = v33[4].__r_.__value_.__l.__size_;
            sub_100048174((uint64_t)buf);
          }
          else
          {
            *(_OWORD *)std::string::size_type size = v64;
            *(void *)(size + 16) = v65;
            std::string::size_type v36 = size + 24;
            v33[4].__r_.__value_.__l.__size_ = size + 24;
          }
          v33[4].__r_.__value_.__l.__size_ = v36;
          if (SHIBYTE(v63) < 0) {
            operator delete(v62[0]);
          }
          if (!v87[0]) {
            __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
          }
          uint64_t v44 = HIBYTE(v94);
          if (v94 < 0) {
            uint64_t v44 = v94;
          }
          if (v44)
          {
            std::string::operator=(v66, (const std::string *)((char *)&v93 + 8));
          }
          else
          {
            (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 128) + 640))(&v64);
            (*(void (**)(uint8_t *__return_ptr))(*(void *)v64 + 48))(buf);
            v45 = v66;
            if (SHIBYTE(v66->__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v66->__r_.__value_.__l.__data_);
            }
            long long v46 = *(_OWORD *)buf;
            v45->__r_.__value_.__r.__words[2] = v71;
            *(_OWORD *)&v45->__r_.__value_.__l.__data_ = v46;
            HIBYTE(v71) = 0;
            buf[0] = 0;
            if (*((void *)&v64 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v64 + 1));
            }
          }
          uint64_t v47 = *(void *)(v5 + 160);
          int v48 = *(_DWORD *)(a1 + 56);
          uint64_t v61 = 0;
          long long v60 = 0uLL;
          v68[0] = 0;
          char v69 = 0;
          sub_1003DB514((uint64_t)buf, v48, &v60, (uint64_t)v68, 0);
          (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v47 + 96))(v47, 1, buf);
          if (v86) {
            sub_1000C584C((uint64_t)&v73);
          }
          if (SHIBYTE(v72) < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (v69) {
            sub_1000C584C((uint64_t)v68);
          }
          if (SHIBYTE(v61) < 0) {
            operator delete((void *)v60);
          }
          (*(void (**)(void))(**(void **)(v5 + 96) + 16))(*(void *)(v5 + 96));
          uint64_t v49 = *(void *)(v5 + 256);
          v58 = v66;
          v59 = v67;
          if (v67) {
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 128) + 640))(buf);
          v57 = 0;
          uint64_t v50 = (*(uint64_t (**)(void, const void **, void))(**(void **)buf + 16))(*(void *)buf, &v57, *(unsigned int *)(a1 + 56));
          v56[0] = 0;
          v56[176] = 0;
          (*(void (**)(uint64_t, uint64_t *, std::string **, uint64_t, unsigned char *))(*(void *)v49 + 32))(v49, &v98, &v58, v50, v56);
          sub_10030AEBC((uint64_t)v56);
          sub_100057D78(&v57);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v59) {
            sub_10004D2C8(v59);
          }
          if (v67) {
            sub_10004D2C8(v67);
          }
          goto LABEL_55;
        }
        sub_1000C584C((uint64_t)buf);
      }
      long long v15 = *(void (****)(void, uint64_t *, uint64_t, unsigned char *))(v5 + 256);
      uint64_t v16 = *(unsigned int *)(v5 + 1040);
      v55[0] = 0;
      v55[176] = 0;
      (**v15)(v15, &v98, v16, v55);
      sub_10030AEBC((uint64_t)v55);
LABEL_55:
      *(_DWORD *)((char *)&v66 + 3) = 0;
      LODWORD(v66) = 0;
      *(void *)&long long v64 = 0;
      (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 128) + 128))(&v64);
      if ((void)v64) {
        char v17 = sub_1000810B8;
      }
      else {
        char v17 = 0;
      }
      if (v17)
      {
        memset(buf, 0, sizeof(buf));
        std::string::size_type v71 = 0;
        ctu::cf::assign();
        uint64_t v18 = *(void **)buf;
        uint64_t v19 = *(void **)&buf[8];
        LODWORD(v66) = v71;
        *(_DWORD *)((char *)&v66 + 3) = *(_DWORD *)((char *)&v71 + 3);
        char v20 = HIBYTE(v71);
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        char v20 = 0;
      }
      sub_1000558F4((const void **)&v64);
      v22.n128_f64[0] = sub_1008EB218((uint64_t *)(v5 + 896), (uint64_t)buf);
      int v23 = buf[0];
      if (v84 < 0) {
        operator delete(__p);
      }
      if (v82 < 0) {
        operator delete(v81);
      }
      if (v80 < 0) {
        operator delete(v79);
      }
      if (v78 < 0) {
        operator delete(v77);
      }
      if (v76 < 0) {
        operator delete(v75);
      }
      if (v74 < 0) {
        operator delete(v73);
      }
      if (SHIBYTE(v72) < 0) {
        operator delete(*(void **)&buf[8]);
      }
      if (v23 == 2) {
        unsigned __int8 v24 = 2;
      }
      else {
        unsigned __int8 v24 = 1;
      }
      uint64_t v25 = *(void *)(v5 + 896);
      uint64_t v26 = *(void *)(v5 + 904);
      if (v25 == v26)
      {
        BOOL v29 = 0;
      }
      else
      {
        uint64_t v27 = v25 + 184;
        do
        {
          int v28 = *(unsigned __int8 *)(v27 - 7);
          BOOL v29 = v28 == 1;
          BOOL v30 = v28 == 1 || v27 == v26;
          v27 += 184;
        }
        while (!v30);
      }
      uint64_t v31 = *(void *)(v5 + 208);
      if (v20 < 0)
      {
        sub_10004FC84(__dst, v18, (unint64_t)v19);
      }
      else
      {
        __dst[0] = v18;
        __dst[1] = v19;
        *(_DWORD *)v53 = v66;
        *(_DWORD *)&v53[3] = *(_DWORD *)((char *)&v66 + 3);
        char v54 = v20;
      }
      (*(void (**)(uint8_t *__return_ptr, __n128))(**(void **)(v5 + 128) + 640))(buf, v22);
      v51 = 0;
      uint64_t v32 = (*(uint64_t (**)(void, const void **, void))(**(void **)buf + 136))(*(void *)buf, &v51, *(unsigned int *)(v5 + 1040));
      (*(void (**)(uint64_t, void **, void, void, BOOL, uint64_t))(*(void *)v31 + 88))(v31, __dst, 0, v24, v29, v32);
      sub_100057D78(&v51);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v54 < 0) {
        operator delete(__dst[0]);
      }
      if (v20 < 0) {
        operator delete(v18);
      }
      sub_1003DD394(v87);
      return;
    case 13:
      memset(buf, 0, sizeof(buf));
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 96) + 64))(buf);
      if (*(_DWORD *)(a1 + 56) == *(_DWORD *)(v5 + 1040))
      {
        *(void *)v87 = (*(uint64_t (**)(void))(**(void **)(v5 + 256) + 104))(*(void *)(v5 + 256));
        *(void *)&v87[8] = v7;
        BOOL v8 = *(void *)v87 == v98 && v7 == v99;
        if (v8 && *(void *)buf && (*(unsigned int (**)(void))(**(void **)buf + 192))(*(void *)buf))
        {
          uint64_t v21 = **(NSObject ***)(a1 + 48);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v87 = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I resume previous websheet flow", v87, 2u);
          }
          (*(void (**)(void))(**(void **)buf + 184))(*(void *)buf);
        }
      }
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      break;
    case 15:
      uint64_t v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_32:
      v6();
      return;
    default:
      int v10 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
      v10();
      break;
  }
}

void sub_100D00D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a69) {
    sub_10004D2C8(a69);
  }
  if (a72) {
    sub_10004D2C8(a72);
  }
  sub_1003DD394(&STACK[0x3F0]);
  _Unwind_Resume(a1);
}

__n128 sub_100D00EE0(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v5 = (unsigned char *)*a2;
    uint64_t v4 = (unsigned char *)(*a2 + a2[1]);
  }
  else
  {
    uint64_t v4 = (char *)a2 + *((unsigned __int8 *)a2 + 23);
    uint64_t v5 = a2;
  }
  if (v5 == v4)
  {
    unsigned int v6 = *((unsigned __int8 *)a2 + 23);
    if ((v6 & 0x80) == 0) {
      goto LABEL_7;
    }
  }
  else
  {
    do
    {
      *uint64_t v5 = __tolower((char)*v5);
      ++v5;
    }
    while (v5 != v4);
    unsigned int v6 = *((unsigned __int8 *)a2 + 23);
    if ((v6 & 0x80) == 0)
    {
LABEL_7:
      if (v6 && *((unsigned char *)a2 + v6 - 1) == 102)
      {
        uint64_t v7 = v6 - 1;
        *((unsigned char *)a2 + 23) = v7;
        BOOL v8 = a2;
LABEL_14:
        *((unsigned char *)v8 + v7) = 0;
        goto LABEL_15;
      }
      goto LABEL_15;
    }
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    BOOL v8 = (uint64_t *)*a2;
    if (*(unsigned char *)(*a2 + v9 - 1) == 102)
    {
      uint64_t v7 = v9 - 1;
      a2[1] = v7;
      goto LABEL_14;
    }
  }
LABEL_15:
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = a2[2];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return result;
}

void sub_100D00FC0(void *a1, long long *a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  v8[2] = sub_100D01114;
  v8[3] = &unk_101A50808;
  v8[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v4;
  char v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v6);
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100D01114(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(unsigned char *)(a1 + 63);
  if (v2 < 0) {
    uint64_t v3 = *(void *)(a1 + 48);
  }
  else {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 63);
  }
  uint64_t v4 = *(NSObject **)(v1 + 40);
  if (!v3)
  {
    if (!os_log_type_enabled(*(os_log_t *)(v1 + 40), OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v16 = "No plan iccid in manage remote plan request";
    char v17 = v4;
    goto LABEL_22;
  }
  uint64_t v5 = (void *)(a1 + 40);
  if (os_log_type_enabled(*(os_log_t *)(v1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = v5;
    if (v2 < 0) {
      unsigned int v6 = (void *)*v5;
    }
    *(_DWORD *)buf = 136315138;
    unint64_t v41 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I user wants to manage remote plan (%s)", buf, 0xCu);
  }
  long long v46 = 0uLL;
  if (*(unsigned char *)(v1 + 1224)) {
    uint64_t v7 = v1 + 1368;
  }
  else {
    uint64_t v7 = v1 + 328;
  }
  uint64_t v9 = v7 + 32;
  uint64_t v8 = *(void *)(v7 + 32);
  if (*(void *)(v9 + 8) == v8)
  {
    uint64_t v18 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v16 = "csn not available";
    char v17 = v18;
LABEL_22:
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, 2u);
    return;
  }
  long long v46 = *(_OWORD *)(v8 + 16);
  bzero(buf, 0x318uLL);
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 160) + 224))(buf);
  if (buf[0])
  {
    int v11 = v45;
    if (v45)
    {
      unint64_t v12 = sub_100CCD974(v42, (uint64_t *)(v1 + 304));
      if ((v12 & 0xFF00000000) != 0)
      {
        unsigned __int8 v13 = v12;
        uint64_t v14 = v1 + 256;
        if (*(void *)(v1 + 256))
        {
          int v15 = v12 & 0xFFFFFF00;
          goto LABEL_26;
        }
        *(_DWORD *)(v1 + 1040) = v12;
        goto LABEL_42;
      }
    }
    if (*(unsigned char *)(v1 + 1224))
    {
      uint64_t v14 = v1 + 256;
      if (*(void *)(v1 + 256))
      {
        int v15 = 0;
        unsigned __int8 v13 = 0;
LABEL_26:
        memset(v35, 0, sizeof(v35));
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 96) + 64))(v35);
        if ((v13 | v15) == *(_DWORD *)(v1 + 1040)
          && ((*(void *)v37 = (*(uint64_t (**)(void))(**(void **)v14 + 104))(),
               uint64_t v38 = v19,
               *(void *)v37 == (void)v46)
            ? (BOOL v20 = v19 == *((void *)&v46 + 1))
            : (BOOL v20 = 0),
              v20
           && *(void *)v35
           && (*(unsigned int (**)(void))(**(void **)v35 + 192))(*(void *)v35)))
        {
          uint64_t v26 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v37 = 0;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I resume previous websheet flow", v37, 2u);
          }
          (*(void (**)(void))(**(void **)v35 + 184))(*(void *)v35);
        }
        else
        {
          uint64_t v21 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v37 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "unable to resume manage account websheet", v37, 2u);
          }
        }
        if (*(void *)&v35[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v35[8]);
        }
        goto LABEL_66;
      }
      *(_DWORD *)(v1 + 1040) = 0;
      if (!v11)
      {
LABEL_59:
        uint64_t v27 = *(NSObject **)(v1 + 24);
        dispatch_object_t v34 = v27;
        if (v27) {
          dispatch_retain(v27);
        }
        int v28 = *(std::__shared_weak_count **)(v1 + 16);
        if (v28)
        {
          uint64_t v29 = *(void *)(v1 + 8);
          BOOL v30 = std::__shared_weak_count::lock(v28);
          if (v30)
          {
            uint64_t v31 = v29 + 64;
            if (!v29) {
              uint64_t v31 = 0;
            }
            v33[0] = v31;
            v33[1] = v30;
            (*(void (**)(uint64_t *__return_ptr))(**(void **)(v1 + 128) + 640))(&v32);
            sub_1008218D0(&v34, (uint64_t)v33, (uint64_t)&v32);
          }
        }
        sub_100088B9C();
      }
LABEL_42:
      ctu::hex((uint64_t *)v37, (ctu *)&v46, (const void *)0x10, v10);
      sub_1008EB2C8((uint64_t *)(v1 + 896), (uint64_t)v37, v35);
      p_p = (char *)&__p;
      if (SHIBYTE(v44) < 0) {
        operator delete((void *)__p);
      }
      long long __p = *(_OWORD *)v35;
      uint64_t v44 = v36;
      HIBYTE(v36) = 0;
      v35[0] = 0;
      if (v39 < 0) {
        operator delete(*(void **)v37);
      }
      uint64_t v25 = HIBYTE(v44);
      if (v44 < 0) {
        uint64_t v25 = *((void *)&__p + 1);
      }
      if (!v25)
      {
        if (SHIBYTE(v44) < 0)
        {
          *((void *)&__p + 1) = 11;
          p_p = (char *)__p;
        }
        else
        {
          HIBYTE(v44) = 11;
        }
        strcpy(p_p, "Apple Watch");
      }
      sub_100D0180C(v1, *(unsigned int *)(v1 + 1040), 0, (uint64_t)v5, (uint64_t)v42);
      goto LABEL_59;
    }
    __n128 v22 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v35 = 0;
      int v23 = "Failed to find slot matching ManageAccount iccid";
      goto LABEL_39;
    }
  }
  else
  {
    __n128 v22 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v35 = 0;
      int v23 = "Websheet launch info not found";
LABEL_39:
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v23, v35, 2u);
    }
  }
LABEL_66:
  sub_10082783C(buf);
}

void sub_100D0177C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10082783C(&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_100D0180C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v58 = 0uLL;
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v40 = 0u;
  uint64_t v11 = 1368;
  if (*(unsigned char *)(a1 + 1224))
  {
    uint64_t v12 = a1 + 1368;
  }
  else
  {
    uint64_t v11 = 328;
    uint64_t v12 = a1 + 328;
  }
  if (*(char *)(v12 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + v11), *(void *)(v12 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v12;
    *(void *)&long long v40 = *(void *)(v12 + 16);
  }
  uint64_t v13 = *(void *)(v12 + 32);
  *((void *)&v40 + 1) = *(void *)(v12 + 24);
  long long v41 = 0uLL;
  *(void *)&long long v42 = 0;
  sub_100311ED8(&v41, v13, *(void *)(v12 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v12 + 40) - v13) >> 3));
  *((void *)&v42 + 1) = *(void *)(v12 + 56);
  LODWORD(v43) = *(_DWORD *)(v12 + 64);
  long long v56 = 0u;
  memset(v57, 0, 24);
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  if (*(unsigned char *)(a1 + 1224)) {
    uint64_t v14 = (long long *)(a1 + 1232);
  }
  else {
    uint64_t v14 = (long long *)(a1 + 408);
  }
  long long __dst = 0uLL;
  long long v51 = 0uLL;
  sub_100313228((char *)&__dst, v14);
  if (*((void *)&v41 + 1) == (void)v41 || a3 && !BYTE8(v40))
  {
LABEL_33:
    uint64_t v23 = 0;
    goto LABEL_34;
  }
  long long v58 = *(_OWORD *)(v41 + 16);
  ctu::hex((uint64_t *)buf, (ctu *)&v58, (const void *)0x10, v15);
  uint64_t v16 = (void **)(a5 + 24);
  if (*(char *)(a5 + 47) < 0) {
    operator delete(*v16);
  }
  *(_OWORD *)uint64_t v16 = *(_OWORD *)buf;
  *(void *)(a5 + 40) = v45;
  uint64_t v17 = BYTE7(v51);
  if ((SBYTE7(v51) & 0x80u) == 0) {
    uint64_t v18 = (void *)BYTE7(v51);
  }
  else {
    uint64_t v18 = (void *)*((void *)&__dst + 1);
  }
  uint64_t v19 = (void *)BYTE7(v40);
  if (SBYTE7(v40) < 0) {
    uint64_t v19 = __p[1];
  }
  if (v18 != v19) {
    goto LABEL_31;
  }
  if ((SBYTE7(v40) & 0x80u) == 0) {
    BOOL v20 = __p;
  }
  else {
    BOOL v20 = (void **)__p[0];
  }
  if ((BYTE7(v51) & 0x80) != 0)
  {
    if (!memcmp((const void *)__dst, v20, *((size_t *)&__dst + 1))) {
      goto LABEL_49;
    }
LABEL_31:
    __n128 v22 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Device Id mismatch! Fail sign up", buf, 2u);
    }
    goto LABEL_33;
  }
  if (BYTE7(v51))
  {
    p_dst = (unsigned __int8 *)&__dst;
    while (*p_dst == *(unsigned __int8 *)v20)
    {
      ++p_dst;
      BOOL v20 = (void **)((char *)v20 + 1);
      if (!--v17) {
        goto LABEL_49;
      }
    }
    goto LABEL_31;
  }
LABEL_49:
  uint64_t v25 = *(unsigned __int8 *)(a4 + 23);
  if ((v25 & 0x80u) != 0) {
    uint64_t v25 = *(void *)(a4 + 8);
  }
  if (!v25)
  {
    memset(v49, 0, sizeof(v49));
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    *(_OWORD *)buf = 0u;
    sub_100CCD910(a2, (_DWORD **)(a1 + 304), (char *)buf);
    if (buf[0]) {
      std::string::operator=((std::string *)a5, v49);
    }
    sub_1003DD210(buf);
  }
  sub_1003DC1E4(a5 + 72, (uint64_t)&v51 + 8);
  sub_1003DC1E4(a5 + 104, (uint64_t)&v53 + 8);
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
  int v26 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 112))(*(void *)buf, a2);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v26) {
    *(int8x16_t *)(a5 + 208) = vextq_s8(*(int8x16_t *)((char *)v57 + 8), *(int8x16_t *)((char *)v57 + 8), 8uLL);
  }
  uint64_t v27 = *(unsigned __int8 *)(a4 + 23);
  if ((v27 & 0x80u) != 0) {
    uint64_t v27 = *(void *)(a4 + 8);
  }
  if (v27)
  {
    int v28 = (uint64_t *)(a5 + 48);
    unint64_t v29 = *(void *)(a5 + 56);
    if (v29 >= *(void *)(a5 + 64))
    {
      uint64_t v30 = sub_10030E9EC(v28, (long long *)a4);
    }
    else
    {
      sub_1000D87F8(v28, (long long *)a4);
      uint64_t v30 = v29 + 24;
    }
    *(void *)(a5 + 56) = v30;
  }
  else
  {
    memset(v38, 0, sizeof(v38));
    sub_100311ED8(v38, v41, *((uint64_t *)&v41 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v41 + 1) - v41) >> 3));
    sub_100CF9E88(a1, a2, v38, (uint64_t *)(a5 + 48));
    *(void *)buf = v38;
    sub_1000C56F4((void ***)buf);
  }
  sub_100D1CC7C(a5 + 136, "Watch");
  if (*(unsigned char *)(a1 + 1224))
  {
    *(_DWORD *)(a5 + 172) = 2;
    *(unsigned char *)(a5 + 168) = 1;
    uint64_t v31 = &cellplan::kServiceTypeStandaloneWatch;
  }
  else
  {
    (***(void (****)(long long *__return_ptr))(a1 + 128))(&v36);
    long long v37 = v36;
    long long v36 = 0uLL;
    PersonalityIdFromSlotId();
    uint64_t v32 = sub_100046F68(a1 + 848, (void **)buf);
    if ((void **)(a1 + 856) == v32)
    {
      int v33 = 0;
      int v34 = 0;
    }
    else
    {
      int v33 = (*((_DWORD *)v32 + 14) >> 11) & 1;
      int v34 = 1;
    }
    if (SBYTE7(v45) < 0) {
      operator delete(*(void **)buf);
    }
    if (*((void *)&v37 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v37 + 1));
    }
    int v35 = v33 | (v34 << 8);
    if (*((void *)&v36 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v36 + 1));
    }
    if (v35 != 257) {
      goto LABEL_81;
    }
    uint64_t v31 = cellplan::kServiceTypeMultiSim;
  }
  sub_100D1CC7C(a5 + 176, *v31);
LABEL_81:
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 128) + 312))(*(void *)(a1 + 128), a2)
    && (void)v41 != *((void *)&v41 + 1)
    && VinylInfo::isVinylPairingSupported((VinylInfo *)v41))
  {
    *(_WORD *)(a5 + 224) = 257;
  }
  uint64_t v23 = 1;
LABEL_34:
  if (v57[0].i8[7] < 0) {
    operator delete((void *)v56);
  }
  if (BYTE8(v53))
  {
    if (SBYTE7(v55) < 0) {
      operator delete((void *)v54);
    }
    BYTE8(v53) = 0;
  }
  if (BYTE8(v51))
  {
    if (SBYTE7(v53) < 0) {
      operator delete((void *)v52);
    }
    BYTE8(v51) = 0;
  }
  if (SBYTE7(v51) < 0) {
    operator delete((void *)__dst);
  }
  *(void *)buf = &v41;
  sub_1000C56F4((void ***)buf);
  if (SBYTE7(v40) < 0) {
    operator delete(__p[0]);
  }
  return v23;
}

void sub_100D01E14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1003DD210(&__p);
  sub_100309AC4(v32 - 256);
  sub_1003CC6D4((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void sub_100D01EBC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100D01EB4);
}

void sub_100D01ED4(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  ctu::cf::assign();
  if (a4) {
    _Block_copy(a4);
  }
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D02090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  operator delete(v14);
  _Unwind_Resume(a1);
}

void sub_100D020C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  sub_100328018((uint64_t)&v8, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D02270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void sub_100D022AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100D189C8((uint64_t)&v6, a3);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D02460(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    sub_100544BC4(v2);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D024A8(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  sub_100D189C8((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D025F8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

const void **sub_100D02610(void *a1, const void **a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100D0273C;
  v10[3] = &unk_101A50840;
  v10[4] = a3;
  v10[5] = a1;
  sub_100083DA4(&v11, a2);
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  char v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  uint64_t v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v8, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
  return sub_1000558F4(&v11);
}

uint64_t sub_100D0273C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I setActiveRemoteProfile", buf, 2u);
  }
  if (*(unsigned char *)(v2 + 1224)) {
    uint64_t v4 = v2 + 1368;
  }
  else {
    uint64_t v4 = v2 + 328;
  }
  if (*(void *)(v4 + 40) == *(void *)(v4 + 32) || !*(unsigned char *)(v4 + 24))
  {
    int v7 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No Watch in proximity", buf, 2u);
    }
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    uint64_t v5 = *(void *)(v2 + 160);
    memset(buf, 0, sizeof(buf));
    uint64_t v12 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v10 = v12;
    (*(void (**)(uint64_t, void, void **))(*(void *)v5 + 88))(v5, 0, __p);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  return v6();
}

void sub_100D028C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D028F0(uint64_t a1, void *a2, const void **a3, uint64_t a4, char a5)
{
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 264);
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 280);
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(void *)(a1 + 160);
  int v13 = *(_DWORD *)(a1 + 1040);
  uint64_t v17 = 0;
  long long v16 = 0uLL;
  v18[0] = 0;
  char v19 = 0;
  sub_1003DB514((uint64_t)v20, v13, &v16, (uint64_t)v18, 0);
  (*(void (**)(uint64_t, void, unsigned char *))(*(void *)v12 + 96))(v12, 0, v20);
  if (v36) {
    sub_1000C584C((uint64_t)&v23);
  }
  if (v22 < 0) {
    operator delete(__p);
  }
  if (v19) {
    sub_1000C584C((uint64_t)v18);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  (*(void (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
  if ((a5 & 1) == 0)
  {
    sub_100D02B8C(a1, a2);
    v14.n128_f64[0] = sub_1008EB218((uint64_t *)(a1 + 896), (uint64_t)v20);
    int v15 = v35;
    (*(void (**)(void, const void **, uint64_t, uint64_t, BOOL, __n128))(**(void **)(a1 + 208) + 176))(*(void *)(a1 + 208), a3, 1, a4, v35 == 1, v14);
    sub_100D0ACA8(a1, a3, a4, v15 == 1);
    if (v34 < 0) {
      operator delete(v33);
    }
    if (v32 < 0) {
      operator delete(v31);
    }
    if (v30 < 0) {
      operator delete(v29);
    }
    if (v28 < 0) {
      operator delete(v27);
    }
    if (v26 < 0) {
      operator delete(v25);
    }
    if (v24 < 0) {
      operator delete(v23);
    }
    if (v22 < 0) {
      operator delete(__p);
    }
  }
}

void sub_100D02B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,int a44,__int16 a45,char a46,char a47)
{
}

void sub_100D02B8C(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  int v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 64))(&v6);
  if (v6)
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v6 + 80))(v6, *a2, a2[1]);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No alert helper", v5, 2u);
    }
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100D02C68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D02C80(void *a1, const void **a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100D02DAC;
  v10[3] = &unk_101A508B0;
  v10[4] = a3;
  v10[5] = a1;
  sub_100083DA4(&v11, a2);
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  char v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  int v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v8, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
  return sub_1000558F4(&v11);
}

void sub_100D02DAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I deleteRemotePlan", buf, 2u);
  }
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)buf = 0u;
  long long v22 = 0u;
  uint64_t v4 = 1368;
  if (*(unsigned char *)(v2 + 1224))
  {
    uint64_t v5 = v2 + 1368;
  }
  else
  {
    uint64_t v4 = 328;
    uint64_t v5 = v2 + 328;
  }
  if (*(char *)(v5 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)(v2 + v4), *(void *)(v5 + 8));
  }
  else
  {
    *(_OWORD *)buf = *(_OWORD *)v5;
    *(void *)&long long v22 = *(void *)(v5 + 16);
  }
  uint64_t v7 = *(void *)(v5 + 24);
  uint64_t v6 = *(void *)(v5 + 32);
  *(void *)&long long v24 = 0;
  *((void *)&v22 + 1) = v7;
  long long v23 = 0uLL;
  sub_100311ED8(&v23, v6, *(void *)(v5 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v5 + 40) - v6) >> 3));
  *((void *)&v24 + 1) = *(void *)(v5 + 56);
  LODWORD(v25) = *(_DWORD *)(v5 + 64);
  if (*((void *)&v23 + 1) == (void)v23 || !BYTE8(v22))
  {
    char v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v37 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No vinyl info", v37, 2u);
    }
    goto LABEL_15;
  }
  if (*(void *)(v2 + 256))
  {
LABEL_15:
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    goto LABEL_16;
  }
  uint64_t v9 = *(void *)(v23 + 16);
  uint64_t v10 = *(void *)(v23 + 24);
  long long v38 = 0u;
  long long v39 = 0u;
  *(_OWORD *)long long v37 = 0u;
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  ctu::cf::assign();
  uint64_t v11 = (void *)v26;
  v20[0] = v27;
  *(_DWORD *)((char *)v20 + 3) = *(_DWORD *)((char *)&v27 + 3);
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(&v38, (void *)v26, *((unint64_t *)&v26 + 1));
    BYTE8(v39) = 1;
    operator delete(v11);
    uint64_t v12 = *(void *)(v2 + 144);
    long long v33 = *(_OWORD *)v37;
    if (SBYTE7(v39) < 0)
    {
      sub_10004FC84(&v34, (void *)v38, *((unint64_t *)&v38 + 1));
      goto LABEL_23;
    }
  }
  else
  {
    long long v38 = v26;
    LODWORD(v39) = v20[0];
    *(_DWORD *)((char *)&v39 + 3) = *(_DWORD *)((char *)v20 + 3);
    BYTE7(v39) = HIBYTE(v27);
    BYTE8(v39) = 1;
    uint64_t v12 = *(void *)(v2 + 144);
    long long v33 = *(_OWORD *)v37;
  }
  long long v34 = v38;
  uint64_t v35 = v39;
LABEL_23:
  char v36 = BYTE8(v39);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_100D03360;
  v14[3] = &unk_101A50878;
  v14[4] = *(void *)(a1 + 32);
  v14[5] = v2;
  if (SBYTE7(v22) < 0)
  {
    sub_10004FC84(&v15, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    long long v15 = *(_OWORD *)buf;
    uint64_t v16 = v22;
  }
  uint64_t v17 = *((void *)&v22 + 1);
  memset(v18, 0, 24);
  sub_100311ED8(v18, v23, *((uint64_t *)&v23 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v23 + 1) - v23) >> 3));
  v18[3] = *((void *)&v24 + 1);
  int v19 = v25;
  (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, void *))(*(void *)v12 + 72))(v12, v9, v10, &v33, v14);
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)v34);
  }
  uint64_t v13 = *(void *)(v2 + 160);
  v28[0] = 0;
  long long v29 = *(_OWORD *)v37;
  if (SBYTE7(v39) < 0)
  {
    sub_10004FC84(&__p, (void *)v38, *((unint64_t *)&v38 + 1));
  }
  else
  {
    long long __p = v38;
    uint64_t v31 = v39;
  }
  char v32 = BYTE8(v39);
  v28[0] = 1;
  (*(void (**)(uint64_t, char *))(*(void *)v13 + 80))(v13, v28);
  if (v28[0])
  {
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)__p);
    }
    v28[0] = 0;
  }
  (*(void (**)(void))(**(void **)(v2 + 96) + 16))(*(void *)(v2 + 96));
  *(void *)&long long v26 = v18;
  sub_1000C56F4((void ***)&v26);
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (SBYTE7(v39) < 0) {
    operator delete((void *)v38);
  }
LABEL_16:
  *(void *)long long v37 = &v23;
  sub_1000C56F4((void ***)v37);
  if (SBYTE7(v22) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100D03280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (*(char *)(v55 - 121) < 0) {
    operator delete(*(void **)(v55 - 144));
  }
  sub_1003CC6D4((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_100D03360(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(v4 + 160);
  v27[0] = 0;
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v5 + 80))(v5, v27);
  if (v27[0])
  {
    if (v29 < 0) {
      operator delete(__p);
    }
    v27[0] = 0;
  }
  int v6 = *a2;
  if (v6 == 2)
  {
    uint64_t v11 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      *(_DWORD *)buf = 136315138;
      *(void *)long long v33 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I deleteRemotePlan error: %s", buf, 0xCu);
    }
    goto LABEL_19;
  }
  if (v6 != 1 || !a2[1])
  {
LABEL_19:
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    return;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  sub_10005D144(*(void **)(v4 + 936));
  *(void *)(v4 + 928) = v4 + 936;
  *(void *)(v4 + 944) = 0;
  *(void *)(v4 + 936) = 0;
  if (*(unsigned char *)(a1 + 109) && *(unsigned char *)(a1 + 108) == 1)
  {
    uint64_t v7 = v4 + 1368;
    if (!*(unsigned char *)(v4 + 1224)) {
      uint64_t v7 = v4 + 328;
    }
    uint64_t v8 = *(void *)(v7 + 32);
    if (*(void *)(v7 + 40) == v8 || !*(unsigned char *)(v7 + 24))
    {
      uint64_t v9 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        uint64_t v10 = "No vinyl info";
        goto LABEL_23;
      }
    }
    else
    {
      long long v36 = *(_OWORD *)(v8 + 16);
      if (*(void *)(v4 + 256))
      {
        uint64_t v9 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          uint64_t v10 = "another provisioning operation is present, skip";
LABEL_23:
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
        }
      }
      else if (sub_100CFDC54(v4, 0, (uint64_t)&v36))
      {
        uint64_t v13 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I re-attempt pending install due to out of memory", buf, 2u);
        }
        uint64_t v25 = 0;
        long long v26 = 0;
        sub_100324590(&v25);
        *(unsigned char *)(v25 + 121) = 1;
        uint64_t v14 = *(void *)(v4 + 160);
        int v15 = *(_DWORD *)(v4 + 1040);
        uint64_t v24 = 0;
        long long v23 = 0uLL;
        v30[0] = 0;
        char v31 = 0;
        sub_1003DB514((uint64_t)buf, v15, &v23, (uint64_t)v30, 0);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v14 + 96))(v14, 1, buf);
        if (v35[216]) {
          sub_1000C584C((uint64_t)v35);
        }
        if (v34 < 0) {
          operator delete(*(void **)&v33[4]);
        }
        if (v31) {
          sub_1000C584C((uint64_t)v30);
        }
        if (SHIBYTE(v24) < 0) {
          operator delete((void *)v23);
        }
        (*(void (**)(void))(**(void **)(v4 + 96) + 16))(*(void *)(v4 + 96));
        uint64_t v16 = *(void *)(v4 + 256);
        uint64_t v21 = v25;
        long long v22 = v26;
        if (v26) {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(v4 + 128) + 640))(&v19);
        uint64_t v18 = 0;
        uint64_t v17 = (*(uint64_t (**)(uint64_t, const void **, void))(*(void *)v19 + 16))(v19, &v18, *(unsigned int *)(v4 + 1040));
        buf[0] = 0;
        v35[144] = 0;
        (*(void (**)(uint64_t, long long *, uint64_t *, uint64_t, uint8_t *))(*(void *)v16 + 32))(v16, &v36, &v21, v17, buf);
        sub_10030AEBC((uint64_t)buf);
        sub_100057D78(&v18);
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v26) {
          sub_10004D2C8(v26);
        }
      }
    }
  }
}

void sub_100D037B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,__int16 a55)
{
  if (a12) {
    sub_10004D2C8((std::__shared_weak_count *)a12);
  }
  if (a14) {
    sub_10004D2C8((std::__shared_weak_count *)a14);
  }
  if (a19) {
    sub_10004D2C8((std::__shared_weak_count *)a19);
  }
  _Unwind_Resume(a1);
}

void *sub_100D03870(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
  }
  uint64_t v5 = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 72) = v5;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  __n128 result = sub_100311ED8((void *)(a1 + 80), *(void *)(a2 + 80), *(void *)(a2 + 88), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3));
  uint64_t v7 = *(void *)(a2 + 104);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(void *)(a1 + 104) = v7;
  return result;
}

void sub_100D03914(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D03930(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 80);
  sub_1000C56F4(&v2);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

void sub_100D03978(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100D03A90;
  v8[3] = &unk_101A50910;
  v8[4] = a2;
  void v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_100D03A90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I deleteAllRemotePlans", buf, 2u);
  }
  uint64_t v4 = v2 + 1368;
  if (!*(unsigned char *)(v2 + 1224)) {
    uint64_t v4 = v2 + 328;
  }
  uint64_t v5 = *(void *)(v4 + 32);
  if (*(void *)(v4 + 40) == v5 || !*(unsigned char *)(v4 + 24))
  {
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No vinyl info", buf, 2u);
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v6 = *(void *)(v5 + 16);
    uint64_t v7 = *(void *)(v5 + 24);
    uint64_t v8 = *(void *)(v2 + 144);
    sub_1002EF958((uint64_t)v22);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_100D03D68;
    v12[3] = &unk_101A508E8;
    v12[4] = *(void *)(a1 + 32);
    v12[5] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void *))(*(void *)v8 + 72))(v8, v6, v7, v22, v12);
    if (v24 < 0) {
      operator delete(v23);
    }
    uint64_t v9 = *(void *)(v2 + 160);
    sub_1002EF958((uint64_t)buf);
    long long v18 = *(_OWORD *)buf;
    *(_OWORD *)long long __p = *(_OWORD *)v14;
    uint64_t v20 = v15;
    v14[0] = 0;
    v14[1] = 0;
    uint64_t v15 = 0;
    char v21 = v16;
    v17[0] = 1;
    (*(void (**)(uint64_t, char *))(*(void *)v9 + 80))(v9, v17);
    if (v17[0])
    {
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      v17[0] = 0;
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[0]);
    }
    return (*(uint64_t (**)(void))(**(void **)(v2 + 96) + 16))(*(void *)(v2 + 96));
  }
}

void sub_100D03D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a24 && a32 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D03D68(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(v4 + 160);
  v10[0] = 0;
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v5 + 80))(v5, v10);
  if (v10[0])
  {
    if (v12 < 0) {
      operator delete(__p);
    }
    v10[0] = 0;
  }
  int v6 = *a2;
  if (v6 == 2)
  {
    uint64_t v7 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      uint64_t v9 = asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I deleteRemotePlan error: %s", (uint8_t *)&v8, 0xCu);
    }
  }
  else if (v6 == 1 && a2[1])
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    sub_10005D144(*(void **)(v4 + 936));
    *(void *)(v4 + 928) = v4 + 936;
    *(void *)(v4 + 944) = 0;
    *(void *)(v4 + 936) = 0;
    return;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100D03ED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a11)
  {
    if (a19 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100D03EFC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100D03FDC(void *a1, const void **a2, const void **a3, const void **a4, const void **a5, const void **a6)
{
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 1174405120;
  v17[2] = sub_100D04188;
  v17[3] = &unk_101A50930;
  v17[4] = a1;
  sub_100083DA4(&v18, a2);
  sub_100083DA4(&v19, a3);
  sub_100083DA4(&v20, a4);
  sub_100083DA4(&v21, a5);
  sub_100083DA4(&v22, a6);
  uint64_t v11 = (std::__shared_weak_count *)a1[2];
  if (!v11 || (uint64_t v12 = a1[1], (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v14 = v13;
  uint64_t v15 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v12;
  char v24 = v14;
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v17;
  dispatch_async(v15, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v14);
  sub_1000558F4(&v22);
  sub_1000558F4(&v21);
  sub_1000558F4(&v20);
  sub_1000558F4(&v19);
  return sub_1000558F4(&v18);
}

const void **sub_100D04188(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100083DA4(&v90, (const void **)(a1 + 40));
  sub_100083DA4(&v89, (const void **)(a1 + 48));
  sub_100083DA4(&v88, (const void **)(a1 + 56));
  sub_100083DA4(&cf, (const void **)(a1 + 64));
  sub_100083DA4(&v86, (const void **)(a1 + 72));
  if (v90) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3 && !(v89 ? sub_1000810B8 : 0) && !(v88 ? sub_1000810B8 : 0)) {
    goto LABEL_29;
  }
  CFTypeRef v99 = cf;
  if (cf) {
    CFRetain(cf);
  }
  int v6 = sub_100CCD35C();
  sub_1000558F4(&v99);
  if (!v6)
  {
LABEL_29:
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "did purchase remote plan invalid iccid or missing eid/imei/meid", buf, 2u);
    }
    goto LABEL_239;
  }
  long long v129 = 0uLL;
  memset(&__str, 0, sizeof(__str));
  memset(buf, 0, 24);
  ctu::cf::assign();
  std::string __str = *(std::string *)buf;
  if (v90) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    memset(__dst, 0, 24);
    memset(buf, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)long long __dst = *(_OWORD *)buf;
    *(void *)&__dst[16] = *(void *)&buf[16];
    int v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = __dst;
      if (__dst[23] < 0) {
        uint64_t v9 = *(unsigned char **)__dst;
      }
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = p_str;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I did purchase remote plan eid:%s, iccid:%s", buf, 0x16u);
    }
    memset(buf, 0, 24);
    ctu::parse_hex();
    uint64_t v11 = *(void **)buf;
    uint64_t v12 = *(void *)&buf[8] - *(void *)buf;
    if (*(void *)&buf[8] - *(void *)buf == 16)
    {
      if (*(void *)&buf[8] != *(void *)buf)
      {
        long long v129 = **(_OWORD **)buf;
LABEL_69:
        *(void *)&buf[8] = v11;
        operator delete(v11);
LABEL_70:
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        if (v12 != 16) {
          goto LABEL_237;
        }
        goto LABEL_73;
      }
      uint64_t v11 = *(void **)&buf[8];
    }
    else
    {
      char v31 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v100 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "EID not valid", v100, 2u);
        uint64_t v11 = *(void **)buf;
      }
    }
    if (!v11) {
      goto LABEL_70;
    }
    goto LABEL_69;
  }
  uint64_t v110 = 0;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  memset(buf, 0, sizeof(buf));
  if (*(unsigned char *)(v2 + 1224)) {
    uint64_t v14 = (long long *)(v2 + 1232);
  }
  else {
    uint64_t v14 = (long long *)(v2 + 408);
  }
  sub_100313228(buf, v14);
  if (v89) {
    uint64_t v15 = sub_1000810B8;
  }
  else {
    uint64_t v15 = 0;
  }
  if (!v15 || !buf[24])
  {
    BOOL v30 = 0;
    goto LABEL_170;
  }
  memset(v100, 0, sizeof(v100));
  uint64_t v101 = 0;
  memset(__dst, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)v100 = *(_OWORD *)__dst;
  uint64_t v101 = *(void *)&__dst[16];
  char v16 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = v100;
    if (v101 < 0) {
      uint64_t v17 = *(uint8_t **)v100;
    }
    long long v18 = &__str;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v18 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long __dst = 136315394;
    *(void *)&__dst[4] = v17;
    *(_WORD *)&__dst[12] = 2080;
    *(void *)&__dst[14] = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I did purchase remote plan imei:%s, iccid:%s", __dst, 0x16u);
  }
  if (!buf[24]) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  if (v101 >= 0) {
    uint64_t v19 = HIBYTE(v101);
  }
  else {
    uint64_t v19 = *(void *)&v100[8];
  }
  uint64_t v20 = BYTE7(v105);
  if (SBYTE7(v105) < 0) {
    uint64_t v20 = *((void *)&v104 + 1);
  }
  if (v19 != v20)
  {
    BOOL v30 = 0;
LABEL_100:
    if ((v101 & 0x8000000000000000) == 0) {
      goto LABEL_170;
    }
    uint64_t v43 = *(void **)v100;
    goto LABEL_141;
  }
  if ((SBYTE7(v105) & 0x80u) == 0) {
    char v21 = &v104;
  }
  else {
    char v21 = (long long *)v104;
  }
  if (v101 < 0)
  {
    uint64_t v43 = *(void **)v100;
    BOOL v30 = memcmp(*(const void **)v100, v21, *(size_t *)&v100[8]) == 0;
LABEL_141:
    operator delete(v43);
    goto LABEL_170;
  }
  if (HIBYTE(v101))
  {
    uint64_t v22 = HIBYTE(v101) - 1;
    long long v23 = v100;
    do
    {
      int v25 = *v23++;
      int v24 = v25;
      int v27 = *(unsigned __int8 *)v21;
      char v21 = (long long *)((char *)v21 + 1);
      int v26 = v27;
      BOOL v29 = v22-- != 0;
      BOOL v30 = v24 == v26;
    }
    while (v24 == v26 && v29);
    goto LABEL_100;
  }
  BOOL v30 = 1;
LABEL_170:
  if (v88) {
    v62 = sub_1000810B8;
  }
  else {
    v62 = 0;
  }
  if (v62 && BYTE8(v105))
  {
    memset(v100, 0, sizeof(v100));
    uint64_t v101 = 0;
    memset(__dst, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)v100 = *(_OWORD *)__dst;
    uint64_t v101 = *(void *)&__dst[16];
    uint64_t v63 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      long long v64 = v100;
      if (v101 < 0) {
        long long v64 = *(uint8_t **)v100;
      }
      uint64_t v65 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v65 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long __dst = 136315394;
      *(void *)&__dst[4] = v64;
      *(_WORD *)&__dst[12] = 2080;
      *(void *)&__dst[14] = v65;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I did purchase remote plan meid:%s, iccid:%s", __dst, 0x16u);
    }
    if (!BYTE8(v105)) {
      __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
    }
    if (v101 >= 0) {
      uint64_t v66 = HIBYTE(v101);
    }
    else {
      uint64_t v66 = *(void *)&v100[8];
    }
    uint64_t v67 = BYTE7(v107);
    if (SBYTE7(v107) < 0) {
      uint64_t v67 = *((void *)&v106 + 1);
    }
    if (v66 == v67)
    {
      if ((SBYTE7(v107) & 0x80u) == 0) {
        v68 = &v106;
      }
      else {
        v68 = (long long *)v106;
      }
      if (v101 < 0)
      {
        v75 = *(void **)v100;
        if (!memcmp(*(const void **)v100, v68, *(size_t *)&v100[8])) {
          LOBYTE(v30) = 1;
        }
        char v74 = v75;
        goto LABEL_221;
      }
      if (!HIBYTE(v101)) {
        goto LABEL_198;
      }
      uint64_t v69 = 0;
      while (v100[v69] == *((unsigned __int8 *)v68 + v69))
      {
        if (HIBYTE(v101) == ++v69) {
          goto LABEL_198;
        }
      }
    }
    if ((v101 & 0x8000000000000000) == 0) {
      goto LABEL_222;
    }
    char v74 = *(void **)v100;
LABEL_221:
    operator delete(v74);
LABEL_222:
    if (!v30) {
      goto LABEL_223;
    }
    goto LABEL_198;
  }
  if (!v30)
  {
LABEL_223:
    v72 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
      goto LABEL_224;
    }
    *(_WORD *)long long __dst = 0;
    v73 = "imei/meid does not match!";
    goto LABEL_279;
  }
LABEL_198:
  uint64_t v70 = v2 + 1368;
  if (!*(unsigned char *)(v2 + 1224)) {
    uint64_t v70 = v2 + 328;
  }
  uint64_t v71 = *(void *)(v70 + 32);
  if (*(void *)(v70 + 40) == v71 || !*(unsigned char *)(v70 + 24))
  {
    v72 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
LABEL_224:
      if (SBYTE7(v109) < 0) {
        operator delete((void *)v108);
      }
      if (BYTE8(v105))
      {
        if (SBYTE7(v107) < 0) {
          operator delete((void *)v106);
        }
        BYTE8(v105) = 0;
      }
      if (buf[24])
      {
        if (SBYTE7(v105) < 0) {
          operator delete((void *)v104);
        }
        buf[24] = 0;
      }
      if ((buf[23] & 0x80000000) == 0) {
        goto LABEL_237;
      }
      long long v46 = *(void **)buf;
      goto LABEL_236;
    }
    *(_WORD *)long long __dst = 0;
    v73 = "eid unavailable";
LABEL_279:
    _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, v73, __dst, 2u);
    goto LABEL_224;
  }
  long long v129 = *(_OWORD *)(v71 + 16);
  if (SBYTE7(v109) < 0) {
    operator delete((void *)v108);
  }
  if (BYTE8(v105))
  {
    if (SBYTE7(v107) < 0) {
      operator delete((void *)v106);
    }
    BYTE8(v105) = 0;
  }
  if (buf[24])
  {
    if (SBYTE7(v105) < 0) {
      operator delete((void *)v104);
    }
    buf[24] = 0;
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
LABEL_73:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = __str;
  }
  sub_100D00EE0((uint64_t)buf, (uint64_t *)&__p);
  char v32 = (void **)(v2 + 976);
  if (*(char *)(v2 + 999) < 0) {
    operator delete(*v32);
  }
  *(_OWORD *)char v32 = *(_OWORD *)buf;
  *(void *)(v2 + 992) = *(void *)&buf[16];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  (*(void (**)(void, uint64_t))(**(void **)(v2 + 160) + 288))(*(void *)(v2 + 160), v2 + 976);
  long long v33 = 0uLL;
  memset(v128, 0, sizeof(v128));
  if (v86) {
    char v34 = sub_1000810B8;
  }
  else {
    char v34 = 0;
  }
  if (v34)
  {
    memset(buf, 0, 24);
    ctu::cf::assign();
    uint64_t v35 = *(void **)buf;
    *(void *)long long __dst = *(void *)&buf[8];
    *(void *)&__dst[7] = *(void *)&buf[15];
    int v36 = buf[23];
    if (LOBYTE(v128[0]))
    {
      if (SHIBYTE(v128[3]) < 0) {
        operator delete((void *)v128[1]);
      }
      v128[1] = v35;
      v128[2] = *(const void **)__dst;
      *(const void **)((char *)&v128[2] + 7) = *(const void **)&__dst[7];
      HIBYTE(v128[3]) = v36;
    }
    else
    {
      v128[1] = *(const void **)buf;
      v128[2] = *(const void **)__dst;
      *(const void **)((char *)&v128[2] + 7) = *(const void **)&__dst[7];
      HIBYTE(v128[3]) = buf[23];
      LOBYTE(v128[0]) = 1;
    }
    long long v37 = *(NSObject **)(v2 + 40);
    BOOL v38 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
    long long v33 = 0uLL;
    if (v38)
    {
      if (!LOBYTE(v128[0])) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      long long v39 = &v128[1];
      if (v36 < 0) {
        long long v39 = (const void **)v35;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v39;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I alternate smdp: %s", buf, 0xCu);
      long long v33 = 0uLL;
    }
  }
  long long v126 = v33;
  long long v127 = v33;
  long long v124 = v33;
  long long v125 = v33;
  long long v122 = v33;
  long long v123 = v33;
  long long v120 = v33;
  long long v121 = v33;
  long long v118 = v33;
  long long v119 = v33;
  long long v116 = v33;
  long long v117 = v33;
  *(_OWORD *)long long __dst = v33;
  *(_OWORD *)&__dst[16] = v33;
  RemoteVinylInfo::findProfile();
  if (!BYTE8(v127))
  {
    uint64_t v114 = 0;
    memset(v113, 0, sizeof(v113));
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    long long v112 = 0uLL;
    if (size)
    {
      std::string::operator=(v113, &__str);
      uint64_t v41 = *(void *)(v2 + 160);
      int v42 = *(_DWORD *)(v2 + 1040);
      uint64_t v96 = 0;
      long long v95 = 0uLL;
      sub_1000C5AB4((uint64_t)v100, (uint64_t)&v112);
      char v102 = 1;
      sub_1003DB514((uint64_t)buf, v42, &v95, (uint64_t)v100, 0);
    }
    else
    {
      uint64_t v41 = *(void *)(v2 + 160);
      int v44 = *(_DWORD *)(v2 + 1040);
      uint64_t v96 = 0;
      long long v95 = 0uLL;
      v100[0] = 0;
      char v102 = 0;
      sub_1003DB514((uint64_t)buf, v44, &v95, (uint64_t)v100, 0);
    }
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v41 + 96))(v41, 1, buf);
    if (v111) {
      sub_1000C584C((uint64_t)&v104);
    }
    if ((buf[31] & 0x80000000) != 0) {
      operator delete(*(void **)&buf[8]);
    }
    if (v102) {
      sub_1000C584C((uint64_t)v100);
    }
    if (SHIBYTE(v96) < 0) {
      operator delete((void *)v95);
    }
    (*(void (**)(void))(**(void **)(v2 + 96) + 16))(*(void *)(v2 + 96));
    sub_1000C584C((uint64_t)&v112);
  }
  uint64_t v45 = *(void *)(v2 + 256);
  if (v45)
  {
    buf[0] = 0;
    if (LOBYTE(v128[0]))
    {
      if (SHIBYTE(v128[3]) < 0)
      {
        sub_10004FC84(&buf[8], (void *)v128[1], (unint64_t)v128[2]);
      }
      else
      {
        *(_OWORD *)&buf[8] = *(_OWORD *)&v128[1];
        *(const void **)&buf[24] = v128[3];
      }
      buf[0] = 1;
    }
    (*(void (**)(uint64_t, long long *, uint64_t, unsigned char *))(*(void *)v45 + 128))(v45, &v129, v2 + 976, buf);
    if (buf[0])
    {
      if ((buf[31] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[8]);
      }
      buf[0] = 0;
    }
    if (BYTE8(v127)) {
      sub_1000C584C((uint64_t)__dst);
    }
    if (LOBYTE(v128[0]) && SHIBYTE(v128[3]) < 0) {
      operator delete((void *)v128[1]);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      long long v47 = (void *)__str.__r_.__value_.__r.__words[0];
LABEL_246:
      operator delete(v47);
      goto LABEL_247;
    }
    goto LABEL_247;
  }
  if (BYTE8(v127))
  {
    sub_1000C584C((uint64_t)__dst);
    if (!LOBYTE(v128[0]) || (SHIBYTE(v128[3]) & 0x80000000) == 0)
    {
LABEL_237:
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      goto LABEL_239;
    }
    long long v46 = (void *)v128[1];
LABEL_236:
    operator delete(v46);
    goto LABEL_237;
  }
  long long v48 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I did purchase without provisioning operation", buf, 2u);
  }
  long long v112 = 0uLL;
  sub_100324590(&v112);
  uint64_t v49 = v112;
  uint64_t v50 = (uint64_t *)(v112 + 96);
  unint64_t v51 = *(void *)(v112 + 104);
  if (v51 >= *(void *)(v112 + 112))
  {
    uint64_t v52 = sub_1000D8CE8(v50, (long long *)(v2 + 976));
  }
  else
  {
    sub_10030BFC4(v50, (long long *)(v2 + 976));
    uint64_t v52 = v51 + 24;
  }
  *(void *)(v49 + 104) = v52;
  if (LOBYTE(v128[0]))
  {
    std::string::operator=((std::string *)v112, (const std::string *)&v128[1]);
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 128) + 640))(&v93);
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v93 + 48))(buf);
    uint64_t v53 = v112;
    if (*(char *)(v112 + 23) < 0) {
      operator delete(*(void **)v112);
    }
    long long v54 = *(_OWORD *)buf;
    *(void *)(v53 + 16) = *(void *)&buf[16];
    *(_OWORD *)uint64_t v53 = v54;
    buf[23] = 0;
    buf[0] = 0;
    if (v94) {
      sub_10004D2C8(v94);
    }
  }
  if (*(char *)(v112 + 23) < 0) {
    uint64_t v55 = *(void *)(v112 + 8);
  }
  else {
    uint64_t v55 = *(unsigned __int8 *)(v112 + 23);
  }
  if (v55)
  {
    long long v56 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "No provisioning object present but have install url - should fetch", buf, 2u);
    }
    v57 = *(NSObject **)(v2 + 24);
    dispatch_object_t v92 = v57;
    if (v57) {
      dispatch_retain(v57);
    }
    long long v58 = *(std::__shared_weak_count **)(v2 + 16);
    if (v58)
    {
      uint64_t v59 = *(void *)(v2 + 8);
      long long v60 = std::__shared_weak_count::lock(v58);
      if (v60)
      {
        uint64_t v61 = v59 + 64;
        if (!v59) {
          uint64_t v61 = 0;
        }
        uint64_t v93 = v61;
        long long v94 = v60;
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 128) + 640))(&v91);
        sub_1008218D0(&v92, (uint64_t)&v93, (uint64_t)&v91);
      }
    }
    sub_100088B9C();
  }
  if (*((void *)&v112 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v112 + 1));
  }
  if (BYTE8(v127)) {
    sub_1000C584C((uint64_t)__dst);
  }
  if (LOBYTE(v128[0]) && SHIBYTE(v128[3]) < 0) {
    operator delete((void *)v128[1]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_239:
  uint64_t v76 = *(void *)(v2 + 256);
  if (v76)
  {
    v128[0] = 0;
    v128[1] = 0;
    memset(__dst, 0, 24);
    LOBYTE(v112) = 0;
    (*(void (**)(uint64_t, const void **, unsigned char *, long long *))(*(void *)v76 + 128))(v76, v128, __dst, &v112);
    if ((_BYTE)v112)
    {
      if (v113[0].__r_.__value_.__s.__data_[15] < 0) {
        operator delete(*((void **)&v112 + 1));
      }
      LOBYTE(v112) = 0;
    }
    if ((__dst[23] & 0x80000000) != 0)
    {
      long long v47 = *(void **)__dst;
      goto LABEL_246;
    }
  }
LABEL_247:
  *(_DWORD *)((char *)__str.__r_.__value_.__r.__words + 3) = 0;
  LODWORD(__str.__r_.__value_.__l.__data_) = 0;
  v128[0] = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(v2 + 128) + 128))(v128);
  if (v128[0]) {
    v77 = sub_1000810B8;
  }
  else {
    v77 = 0;
  }
  if (v77)
  {
    memset(__dst, 0, 24);
    ctu::cf::assign();
    char v78 = *(void **)__dst;
    unint64_t v79 = *(void *)&__dst[8];
    LODWORD(__str.__r_.__value_.__l.__data_) = *(_DWORD *)&__dst[16];
    *(_DWORD *)((char *)__str.__r_.__value_.__r.__words + 3) = *(_DWORD *)&__dst[19];
    char v80 = __dst[23];
  }
  else
  {
    char v78 = 0;
    unint64_t v79 = 0;
    char v80 = 0;
  }
  sub_1000558F4(v128);
  v81.n128_f64[0] = sub_1008EB218((uint64_t *)(v2 + 896), (uint64_t)__dst);
  int v82 = __dst[0];
  if (SHIBYTE(v124) < 0) {
    operator delete(*((void **)&v123 + 1));
  }
  if (SBYTE7(v123) < 0) {
    operator delete((void *)v122);
  }
  if (SHIBYTE(v121) < 0) {
    operator delete(*((void **)&v120 + 1));
  }
  if (SBYTE7(v120) < 0) {
    operator delete((void *)v119);
  }
  if (SHIBYTE(v118) < 0) {
    operator delete(*((void **)&v117 + 1));
  }
  if (SBYTE7(v117) < 0) {
    operator delete((void *)v116);
  }
  if ((__dst[31] & 0x80000000) != 0) {
    operator delete(*(void **)&__dst[8]);
  }
  if (v82 == 2) {
    unsigned __int8 v83 = 2;
  }
  else {
    unsigned __int8 v83 = 1;
  }
  uint64_t v84 = *(void *)(v2 + 208);
  if (v80 < 0)
  {
    sub_10004FC84(__dst, v78, v79);
  }
  else
  {
    *(void *)long long __dst = v78;
    *(void *)&__dst[8] = v79;
    *(_DWORD *)&__dst[16] = __str.__r_.__value_.__l.__data_;
    *(_DWORD *)&__dst[19] = *(_DWORD *)((char *)__str.__r_.__value_.__r.__words + 3);
    __dst[23] = v80;
  }
  (*(void (**)(uint64_t, unsigned char *, void, void, __n128))(*(void *)v84 + 144))(v84, __dst, 0, v83, v81);
  if ((__dst[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__dst);
    if ((v80 & 0x80) == 0) {
      goto LABEL_275;
    }
LABEL_277:
    operator delete(v78);
    goto LABEL_275;
  }
  if (v80 < 0) {
    goto LABEL_277;
  }
LABEL_275:
  sub_1000558F4(&v86);
  sub_1000558F4(&cf);
  sub_1000558F4(&v88);
  sub_1000558F4(&v89);
  return sub_1000558F4(&v90);
}

void sub_100D053A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a21) {
    sub_10004D2C8((std::__shared_weak_count *)a21);
  }
  if (STACK[0x2B8]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x2B8]);
  }
  if (LOBYTE(STACK[0x468])) {
    sub_1000C584C((uint64_t)&STACK[0x390]);
  }
  if (*(unsigned char *)(v34 - 144) && *(char *)(v34 - 113) < 0) {
    operator delete(*(void **)(v34 - 136));
  }
  if (a34 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  sub_1000558F4(&a13);
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_100D05674(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 5, a2 + 5);
  sub_100083DA4(a1 + 6, a2 + 6);
  sub_100083DA4(a1 + 7, a2 + 7);
  sub_100083DA4(a1 + 8, a2 + 8);

  return sub_100083DA4(a1 + 9, a2 + 9);
}

const void **sub_100D056E0(const void **a1)
{
  uint64_t v1 = a1 + 5;
  uint64_t v2 = a1 + 6;
  uint64_t v3 = a1 + 7;
  uint64_t v4 = a1 + 8;
  sub_1000558F4(a1 + 9);
  sub_1000558F4(v4);
  sub_1000558F4(v3);
  sub_1000558F4(v2);

  return sub_1000558F4(v1);
}

void sub_100D05748(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100D05860;
  v7[3] = &unk_101A50960;
  v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  int v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_100D05860(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received cancel plan, check subscription", v3, 2u);
  }
  sub_100CF7954(v1, 1);
}

void sub_100D058D0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100D059E8;
  v7[3] = &unk_101A50980;
  v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  int v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_100D059E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received plan pending release", v4, 2u);
  }
  uint64_t result = *(void *)(v1 + 256);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
  }
  return result;
}

const void **sub_100D05A78(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I will fetch for slot %s before get plans", buf, 0xCu);
    }
    *(_DWORD *)(a1 + 1040) = a2;
    int v8 = *(NSObject **)(a1 + 24);
    dispatch_object_t v23 = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = std::__shared_weak_count::lock(v9);
      if (v11)
      {
        uint64_t v12 = v10 + 64;
        if (!v10) {
          uint64_t v12 = 0;
        }
        v22[0] = v12;
        v22[1] = v11;
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v21);
        sub_1008218D0(&v23, (uint64_t)v22, (uint64_t)&v21);
      }
    }
    sub_100088B9C();
  }
  sub_100CF7954(a1, 0);
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 160) + 104))(&cf);
  if (*(unsigned char *)(a1 + 1072))
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = asString();
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I install error: %s", buf, 0xCu);
      if (!*(unsigned char *)(a1 + 1072)) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
    }
    switch(*(_DWORD *)(a1 + 1076))
    {
      case 2:
      case 4:
      case 5:
      case 6:
        char v15 = 0;
        uint64_t v16 = 18;
        break;
      case 3:
        char v15 = 0;
        uint64_t v16 = 13;
        break;
      case 7:
        char v15 = 0;
        uint64_t v16 = 25;
        break;
      case 8:
        char v15 = 0;
        uint64_t v16 = 26;
        break;
      case 9:
        char v15 = 0;
        uint64_t v16 = 34;
        break;
      case 0xA:
        char v15 = 0;
        uint64_t v16 = 35;
        break;
      case 0xB:
        uint64_t v16 = 58;
        char v15 = 1;
        break;
      case 0xC:
        char v15 = 0;
        uint64_t v16 = 45;
        break;
      default:
        char v15 = 0;
        uint64_t v16 = 0;
        break;
    }
    if (*(unsigned char *)(a1 + 1045))
    {
      char v17 = v15 ^ 1;
      if (!*(unsigned char *)(a1 + 1044)) {
        char v17 = 1;
      }
      if ((v17 & 1) == 0) {
        uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 848))(*(void *)(a1 + 128));
      }
    }
    *(unsigned char *)(a1 + 1072) = 0;
  }
  else
  {
    uint64_t v16 = 0;
  }
  uint64_t v18 = *a4;
  *(void *)buf = cf;
  if (cf) {
    CFRetain(cf);
  }
  (*(void (**)(uint64_t, uint8_t *, uint64_t))(v18 + 16))(v18, buf, v16);
  sub_100044D00((const void **)buf);
  return sub_100044D00(&cf);
}

void sub_100D05E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *aBlock, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_100D05F14(uint64_t a1, uint64_t a2, void *aBlock)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
    if (aBlock) {
      goto LABEL_3;
    }
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
    if (aBlock)
    {
LABEL_3:
      uint64_t v5 = _Block_copy(aBlock);
      goto LABEL_6;
    }
  }
  uint64_t v5 = 0;
LABEL_6:
  __p[3] = v5;
  int v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D06098(void *a1, char a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100D061B4;
  v9[3] = &unk_101A509A8;
  char v10 = a2;
  v9[4] = a3;
  v9[5] = a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (int v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  int v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  uint64_t v12 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v7);
}

void sub_100D061B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I getRemoteCellularPlanItems, shouldFetch:%d", buf, 8u);
  }
  uint64_t v42 = 0;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)buf = 0u;
  long long v39 = 0u;
  if (*(unsigned char *)(v2 + 1224)) {
    uint64_t v5 = v2 + 1368;
  }
  else {
    uint64_t v5 = v2 + 328;
  }
  if (*(char *)(v5 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)v5, *(void *)(v5 + 8));
  }
  else
  {
    *(_OWORD *)buf = *(_OWORD *)v5;
    *(void *)&long long v39 = *(void *)(v5 + 16);
  }
  uint64_t v7 = *(void *)(v5 + 24);
  uint64_t v6 = *(void *)(v5 + 32);
  *(void *)&long long v41 = 0;
  *((void *)&v39 + 1) = v7;
  long long v40 = 0uLL;
  sub_100311ED8(&v40, v6, *(void *)(v5 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v5 + 40) - v6) >> 3));
  *((void *)&v41 + 1) = *(void *)(v5 + 56);
  LODWORD(v42) = *(_DWORD *)(v5 + 64);
  if (*(unsigned char *)(a1 + 48))
  {
    int v8 = (*(uint64_t (**)(void))(**(void **)(v2 + 160) + 160))(*(void *)(v2 + 160));
    int v9 = HIDWORD(v39) == 1 ? 1 : v8;
    if (v9 != 1)
    {
      long long v12 = 0uLL;
      if (*((void *)&v40 + 1) != (void)v40 && BYTE8(v39)) {
        long long v12 = *(_OWORD *)(v40 + 16);
      }
      long long v32 = v12;
      uint64_t v13 = *(std::__shared_weak_count **)(v2 + 16);
      if (!v13 || (uint64_t v14 = *(void *)(v2 + 8), (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v16 = v15;
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = *(const void **)(a1 + 32);
      if (v17) {
        uint64_t v18 = _Block_copy(v17);
      }
      else {
        uint64_t v18 = 0;
      }
      uint64_t v19 = operator new(0x28uLL);
      *uint64_t v19 = off_101A519B0;
      v19[1] = v2;
      v19[2] = v14;
      v19[3] = v16;
      v19[4] = v18;
      long long v37 = v19;
      long long v50 = v32;
      if (!*(unsigned char *)(v2 + 1224))
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        sub_100D146D8((uint64_t)v19, 0);
        v48[0] = (void **)&v43;
        uint64_t v20 = v48;
        goto LABEL_32;
      }
      (*(void (**)(void *__return_ptr))(**(void **)(v2 + 160) + 272))(v34);
      if (v34[0] != v34[1])
      {
        sub_100D146D8((uint64_t)v37, 1);
LABEL_30:
        uint64_t v35 = v34;
        uint64_t v20 = (void ***)&v35;
LABEL_32:
        sub_1000C63B8(v20);
        sub_100D1C19C(v36);
        goto LABEL_33;
      }
      if (*(unsigned char *)(v2 + 1224)) {
        uint64_t v21 = v2 + 1368;
      }
      else {
        uint64_t v21 = v2 + 328;
      }
      uint64_t v22 = *(VinylInfo **)(v21 + 32);
      if (v22 == *(VinylInfo **)(v21 + 40))
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        sub_100D146D8((uint64_t)v37, 0);
        v48[0] = (void **)&v43;
        sub_1000C63B8(v48);
        goto LABEL_30;
      }
      VinylInfo::getActiveUserProfile((uint64_t *)&v43, v22);
      if (SHIBYTE(v45) < 0)
      {
        uint64_t v24 = v44;
        operator delete(v43);
        if (v24) {
          goto LABEL_42;
        }
      }
      else if (HIBYTE(v45))
      {
LABEL_42:
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        sub_100D146D8((uint64_t)v37, 1);
        v48[0] = (void **)&v43;
        sub_1000C63B8(v48);
        uint64_t v23 = *(void *)(v2 + 144);
        uint64_t v43 = off_101A51D38;
        uint64_t v44 = v2;
        long long v46 = (void ***)&v43;
        (*(void (**)(uint64_t, void, void, uint64_t (***)()))(*(void *)v23 + 168))(v23, v50, *((void *)&v50 + 1), &v43);
        sub_10037E8D0(&v43);
        goto LABEL_30;
      }
      uint64_t v25 = *(void *)(v2 + 144);
      long long v26 = v50;
      uint64_t v43 = (uint64_t (**)())v2;
      sub_100D1F584((uint64_t)&v44, (uint64_t)v36);
      uint64_t v49 = 0;
      int v27 = operator new(0x30uLL);
      char v28 = v27;
      BOOL v29 = (void **)v43;
      BOOL v30 = v47;
      void *v27 = off_101A51DC8;
      v27[1] = v29;
      if (v30)
      {
        if (v30 == &v44)
        {
          v27[5] = v27 + 2;
          (*(void (**)(uint64_t *))(v44 + 24))(&v44);
          goto LABEL_51;
        }
        char v31 = &v47;
        v27[5] = v30;
      }
      else
      {
        char v31 = (uint64_t **)(v27 + 5);
      }
      NSObject *v31 = 0;
LABEL_51:
      uint64_t v49 = v28;
      (*(void (**)(uint64_t, void, void, void ***))(*(void *)v25 + 168))(v25, v26, *((void *)&v26 + 1), v48);
      sub_10037E8D0(v48);
      sub_100D1C19C(&v44);
      goto LABEL_30;
    }
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  char v10 = *(const void **)(a1 + 32);
  if (v10) {
    uint64_t v11 = _Block_copy(v10);
  }
  else {
    uint64_t v11 = 0;
  }
  long long v33 = v11;
  sub_100D05A78(v2, 0, (uint64_t)&v43, (uint64_t *)&v33);
  if (v11) {
    _Block_release(v11);
  }
LABEL_33:
  uint64_t v43 = (uint64_t (**)())&v40;
  sub_1000C56F4((void ***)&v43);
  if (SBYTE7(v39) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100D066EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D067DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100D067C4);
}

uint64_t sub_100D067F4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D06834(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D06924(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D06A5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (***(void (****)(void **__return_ptr))(a1 + 128))(__p);
  *(_OWORD *)&v12[1] = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = SlotIdFromPersonalityId();
  if (v12[2]) {
    sub_10004D2C8((std::__shared_weak_count *)v12[2]);
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  uint64_t v6 = *(void *)(a1 + 1000);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
    uint64_t v7 = *(void *)(a1 + 1000);
    *(void *)(a1 + 1000) = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  int v8 = _Block_copy(&stru_101A509E8);
  v12[0] = v8;
  sub_100CF79E4(a1, v5, 0, 1, v12);
  if (v8) {
    _Block_release(v8);
  }
  memset(__p, 0, sizeof(__p));
  char v10 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 128) + 128))(&v10);
  if (v10) {
    int v9 = sub_1000810B8;
  }
  else {
    int v9 = 0;
  }
  if (v9)
  {
    memset(&v12[1], 0, 24);
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)&v12[1];
    *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v12[2] + 7);
    HIBYTE(__p[2]) = HIBYTE(v12[3]);
  }
  (*(void (**)(void, void **, uint64_t, uint64_t))(**(void **)(a1 + 208) + 200))(*(void *)(a1 + 208), __p, a3, 1);
  sub_1000558F4(&v10);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D06C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

void sub_100D06CE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (***(void (****)(void **__return_ptr))(a1 + 128))(__p);
  *(_OWORD *)&v10[1] = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = SlotIdFromPersonalityId();
  if (v10[2]) {
    sub_10004D2C8((std::__shared_weak_count *)v10[2]);
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  uint64_t v6 = _Block_copy(&stru_101A50A28);
  v10[0] = v6;
  sub_100CF79E4(a1, v5, 0, 1, v10);
  if (v6) {
    _Block_release(v6);
  }
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 128) + 128))(&v8);
  if (v8) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    memset(&v10[1], 0, 24);
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)&v10[1];
    *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v10[2] + 7);
    HIBYTE(__p[2]) = HIBYTE(v10[3]);
  }
  (*(void (**)(void, void **, uint64_t, uint64_t))(**(void **)(a1 + 208) + 200))(*(void *)(a1 + 208), __p, a3, 2);
  sub_1000558F4(&v8);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D06E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

void sub_100D06F08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (***(void (****)(void **__return_ptr))(a1 + 128))(__p);
  v10[0] = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  SlotIdFromPersonalityId();
  if (*((void *)&v10[0] + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10[0] + 1));
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  uint64_t v8 = 0;
  int v9 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 64))(&v8);
  if (v8) {
    (*(void (**)(uint64_t, void, void))(*(void *)v8 + 80))(v8, 0, 0);
  }
  memset(__p, 0, 24);
  uint64_t v6 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 128) + 128))(&v6);
  if (v6) {
    uint64_t v5 = sub_1000810B8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    memset(v10, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v10[0];
    *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v10 + 15);
    HIBYTE(__p[2]) = BYTE7(v10[1]);
  }
  (*(void (**)(void, void **, uint64_t, uint64_t))(**(void **)(a1 + 208) + 200))(*(void *)(a1 + 208), __p, a3, 3);
  sub_1000558F4(&v6);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100D070E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

void sub_100D07134(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (!a12) {
    JUMPOUT(0x100D0712CLL);
  }
  JUMPOUT(0x100D07128);
}

void sub_100D07150(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100D07268;
  v7[3] = &unk_101A50A48;
  v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v3;
  int v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_100D07268(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 256);
  if (v2)
  {
    aBlock = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 176))(v2, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "no provisioning operation", v4, 2u);
    }
  }
}

void sub_100D07318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D07334(void *a1, uint64_t a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100D0744C;
  v9[3] = &unk_101A50A98;
  v9[4] = a3;
  v9[5] = a1;
  int v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  uint64_t v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
}

void sub_100D0744C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 256);
  if (v2)
  {
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_100D07574;
    aBlock[3] = &unk_101A50A70;
    aBlock[4] = *(void *)(a1 + 32);
    aBlock[5] = v1;
    uint64_t v6 = _Block_copy(aBlock);
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 176))(v2, &v6);
    if (v6) {
      _Block_release(v6);
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "no provisioning operation", v4, 2u);
    }
  }
}

void sub_100D07554(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(const void **)(v1 - 24);
  if (v3) {
    _Block_release(v3);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D07574(uint64_t a1, int a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (!a2 || !*(unsigned char *)a3) {
    goto LABEL_42;
  }
  char v8 = *(unsigned char *)(a3 + 31);
  if (v8 < 0)
  {
    if (*(void *)(a3 + 16)) {
      goto LABEL_7;
    }
LABEL_42:
    uint64_t v20 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I URL launch not successful", (uint8_t *)&buf, 2u);
    }
    uint64_t v21 = *(void *)(a1 + 32);
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    (*(void (**)(void))(v21 + 16))();
    sub_100057D78(&v23);
    return sub_1000558F4(&v24);
  }
  if (!*(unsigned char *)(a3 + 31)) {
    goto LABEL_42;
  }
LABEL_7:
  int v9 = (uint64_t *)(a3 + 8);
  char v10 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = a3 + 8;
    if (v8 < 0) {
      uint64_t v11 = *v9;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I successful URL launch: %s", (uint8_t *)&buf, 0xCu);
  }
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
LABEL_41:
    sub_10005717C(&cf);
    goto LABEL_42;
  }
  CFTypeRef v13 = cf;
  CFTypeRef cf = Mutable;
  *(void *)&long long buf = v13;
  sub_10005717C((const void **)&buf);
  if (*a4)
  {
    if (a4[344])
    {
      CFTypeRef v31 = cf;
      CFRetain(cf);
      if (!*a4) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      if (!a4[344]) {
        sub_10016C840();
      }
      uint64_t v14 = (long long *)(a4 + 8);
      char v15 = &v31;
      sub_100DDB308((CFMutableDictionaryRef *)&v31, v14);
LABEL_17:
      sub_10005717C(v15);
      goto LABEL_18;
    }
    if (!a4[696])
    {
      if (!a4[728]) {
        goto LABEL_18;
      }
      sub_100057240(&v29, &cf);
      if (!*a4) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      if (!a4[728]) {
        sub_10016C840();
      }
      uint64_t v22 = (uint64_t)(a4 + 704);
      char v15 = &v29;
      sub_100DDD340((CFMutableDictionaryRef *)&v29, v22);
      goto LABEL_17;
    }
    sub_100057240(&v30, &cf);
    if (!*a4) {
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    if (!a4[696]) {
      sub_10016C840();
    }
    BOOL v19 = sub_100DDCEB8((CFMutableDictionaryRef *)&v30, (uint64_t)(a4 + 352));
    sub_10005717C(&v30);
    if (v19) {
      goto LABEL_18;
    }
    goto LABEL_41;
  }
LABEL_18:
  if (!*(unsigned char *)a3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  uint64_t v16 = *(void *)(a1 + 32);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v9;
    uint64_t v27 = *(void *)(a3 + 24);
  }
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v35 = v27;
  }
  long long v33 = 0;
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(&buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long buf = *(_OWORD *)__p;
    uint64_t v39 = v35;
  }
  int v36 = 0;
  if (ctu::cf::convert_copy())
  {
    char v17 = v33;
    long long v33 = v36;
    long long v37 = v17;
    sub_1000558F4(&v37);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)buf);
  }
  char v28 = v33;
  long long v33 = 0;
  sub_1000558F4(&v33);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p[0]);
  }
  sub_10004EFE4(&v25, &cf);
  (*(void (**)(uint64_t, const void **, const void **, void))(v16 + 16))(v16, &v28, &v25, 0);
  sub_100057D78(&v25);
  sub_1000558F4(&v28);
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  return sub_10005717C(&cf);
}

void sub_100D079E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D07AB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100D07B98(void *a1, const void **a2, char a3, const void **a4, uint64_t a5)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_100D07CF0;
  v14[3] = &unk_101A50AC0;
  v14[4] = a5;
  v14[5] = a1;
  sub_100083DA4(&v15, a2);
  char v17 = a3;
  sub_100083DA4(&v16, a4);
  char v8 = (std::__shared_weak_count *)a1[2];
  if (!v8 || (v9 = a1[1], (char v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v11 = v10;
  long long v12 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v9;
  BOOL v19 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v14;
  dispatch_async(v12, block);
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_10004D2C8(v11);
  sub_1000558F4(&v16);
  return sub_1000558F4(&v15);
}

void sub_100D07CF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 256))
  {
    if (*(void *)(a1 + 48)) {
      uint64_t v3 = sub_1000810B8;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      memset(v27, 0, sizeof(v27));
      memset(buf, 0, sizeof(buf));
      uint64_t v13 = 0;
      ctu::cf::assign();
      memset(v27, 0, sizeof(v27));
      if ((*(unsigned int (**)(void, void **))(**(void **)(v2 + 160) + 144))(*(void *)(v2 + 160), v27))
      {
        uint64_t v4 = *(unsigned __int8 *)(a1 + 64);
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        uint64_t v4 = 2;
      }
      if (SHIBYTE(v27[2]) < 0) {
        operator delete(v27[0]);
      }
    }
    else
    {
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      uint64_t v4 = 2;
    }
    memset(v27, 0, sizeof(v27));
    if (*(void *)(a1 + 56)) {
      uint64_t v6 = sub_1000810B8;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v13 = 0;
      ctu::cf::assign();
      v28[0] = 0;
      *(void *)((char *)v28 + 7) = 0;
      if (SHIBYTE(v27[2]) < 0) {
        operator delete(v27[0]);
      }
      v27[0] = 0;
      v27[1] = (void *)v28[0];
      *(void **)((char *)&v27[1] + 7) = *(void **)((char *)v28 + 7);
      HIBYTE(v27[2]) = 0;
    }
    (*(void (**)(void, uint64_t, void **))(**(void **)(v2 + 256) + 88))(*(void *)(v2 + 256), v4, v27);
    if (*(unsigned char *)(a1 + 64))
    {
      v7.n128_f64[0] = sub_1008EB218((uint64_t *)(v2 + 896), (uint64_t)buf);
      int v8 = buf[0];
      if (v26 < 0) {
        operator delete(__p);
      }
      if (v24 < 0) {
        operator delete(v23);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(v19);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
      if (v16 < 0) {
        operator delete(v15);
      }
      if (v14 < 0) {
        operator delete(*(void **)&buf[8]);
      }
      if (v8 == 2)
      {
        uint64_t v9 = *(void *)(v2 + 208);
        (*(void (**)(void **__return_ptr, __n128))(**(void **)(v2 + 160) + 152))(v10, v7);
        (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(void *)v9 + 144))(v9, v10, 3, 2);
        if (v11 < 0) {
          operator delete(v10[0]);
        }
      }
    }
    if (SHIBYTE(v27[2]) < 0) {
      operator delete(v27[0]);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "no provisioning operation present to consent to", buf, 2u);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_100D08060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v21 - 89) < 0) {
    operator delete(*(void **)(v21 - 112));
  }
  _Unwind_Resume(exception_object);
}

void sub_100D080CC(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100D081E4;
  v8[3] = &unk_101A50B18;
  v8[4] = a2;
  void v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  __n128 v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v4;
  char v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_100D081E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = v2 + 1368;
  if (!*(unsigned char *)(v2 + 1224)) {
    uint64_t v3 = v2 + 328;
  }
  uint64_t v4 = *(void *)(v3 + 32);
  if (*(void *)(v3 + 40) == v4 || !*(unsigned char *)(v3 + 24))
  {
    uint64_t v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No vinyl info", buf, 2u);
    }
    int v8 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = *(void *)(v4 + 24);
    uint64_t v7 = *(void *)(v2 + 144);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_100D0831C;
    v11[3] = &unk_101A50AF0;
    v11[4] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 136))(v7, v5, v6, 2, v11);
    int v8 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  return v8();
}

void sub_100D0831C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (v3 == 2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315138;
      uint64_t v8 = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Start Session result: %s", (uint8_t *)&v7, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    int v5 = a2[1];
    int v7 = 67109120;
    LODWORD(v8) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Start Session result: %d", (uint8_t *)&v7, 8u);
  }
}

void sub_100D08458(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D0846C(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100D08584;
  v8[3] = &unk_101A50B60;
  v8[4] = a2;
  void v8[5] = a1;
  int v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  int v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v4;
  char v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_100D08584(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = v2 + 1368;
  if (!*(unsigned char *)(v2 + 1224)) {
    uint64_t v3 = v2 + 328;
  }
  uint64_t v4 = *(void *)(v3 + 32);
  if (*(void *)(v3 + 40) == v4 || !*(unsigned char *)(v3 + 24))
  {
    char v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No vinyl info", buf, 2u);
    }
    char v10 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = *(void *)(v4 + 24);
    uint64_t v7 = *(void *)(v2 + 144);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100D08734;
    v13[3] = &unk_101A50B38;
    v13[4] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 144))(v7, v5, v6, 2, v13);
    uint64_t v8 = *(void *)(v2 + 256);
    if (v8)
    {
      uint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I User left cellular pane", buf, 2u);
        uint64_t v8 = *(void *)(v2 + 256);
      }
      (*(void (**)(uint64_t))(*(void *)v8 + 160))(v8);
    }
    char v10 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  }
  return v10();
}

void sub_100D08734(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (v3 == 2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315138;
      uint64_t v8 = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "End Session result: %s", (uint8_t *)&v7, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (v3 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    int v5 = a2[1];
    int v7 = 67109120;
    LODWORD(v8) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I End Session result: %d", (uint8_t *)&v7, 8u);
  }
}

void sub_100D08870(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D08884(uint64_t a1)
{
  (*(void (**)(unsigned int (****__return_ptr)(void)))(**(void **)(a1 + 128) + 648))(&v5);
  if (!(**v5)())
  {
    if (v6) {
      sub_10004D2C8(v6);
    }
    return 0;
  }
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 200))(*(void *)(a1 + 160));
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (!v2) {
    return 0;
  }
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CB discourages disabling LTE and active plan", (uint8_t *)&v5, 2u);
  }
  return 1;
}

void sub_100D089B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D089CC(uint64_t a1)
{
  (*(void (**)(unsigned int (****__return_ptr)(void)))(**(void **)(a1 + 128) + 648))(&v20);
  if ((**v20)())
  {
    sub_1008EB218((uint64_t *)(a1 + 896), (uint64_t)v5);
    BOOL v2 = v5[0] == 1;
    if (v19 < 0) {
      operator delete(__p);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if (v15 < 0) {
      operator delete(v14);
    }
    if (v13 < 0) {
      operator delete(v12);
    }
    if (v11 < 0) {
      operator delete(v10);
    }
    if (v9 < 0) {
      operator delete(v8);
    }
    if (v7 < 0) {
      operator delete(v6);
    }
  }
  else
  {
    BOOL v2 = 0;
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v2)
  {
    int v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CB discourages disabling LTE", v5, 2u);
    }
  }
  return v2;
}

void sub_100D08B4C(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 - 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D08B68(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 1368;
  if (!*(unsigned char *)(a1 + 1224)) {
    uint64_t v4 = a1 + 328;
  }
  uint64_t v5 = *(void *)(v4 + 32);
  if (*(void *)(v4 + 40) == v5 || !*(unsigned char *)(v4 + 24))
  {
    char v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No vinyl info", buf, 2u);
    }
    (*(void (**)(void))(*(void *)a2 + 16))();
  }
  else
  {
    uint64_t v6 = *(void *)(v5 + 16);
    uint64_t v7 = *(void *)(v5 + 24);
    uint64_t v8 = *(void *)(a1 + 144);
    sub_1002EF958((uint64_t)v14);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 1174405120;
    v11[2] = sub_100D08D54;
    v11[3] = &unk_101A50B80;
    v11[4] = a1;
    char v9 = *(void **)a2;
    if (*(void *)a2) {
      char v9 = _Block_copy(v9);
    }
    aBlock = v9;
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void *))(*(void *)v8 + 72))(v8, v6, v7, v14, v11);
    if (v16 < 0) {
      operator delete(__p);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
  }
}

void sub_100D08D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D08D54(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *a2;
  if (v4 == 1)
  {
    if (a2[1])
    {
      uint64_t v7 = 1;
    }
    else
    {
      char v11 = *(NSObject **)(v3 + 40);
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      uint64_t v7 = 0;
      if (v12)
      {
        LOWORD(v15) = 0;
        uint64_t v8 = "#I deleteAllRemotePlans callback failure";
        char v9 = v11;
        uint32_t v10 = 2;
        goto LABEL_9;
      }
    }
  }
  else
  {
    if (v4 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    uint64_t v5 = *(NSObject **)(v3 + 40);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t v7 = 0;
    if (v6)
    {
      int v15 = 136315138;
      uint64_t v16 = asString();
      uint64_t v8 = "#I deleteAllRemotePlans failure: %s";
      char v9 = v5;
      uint32_t v10 = 12;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v15, v10);
      uint64_t v7 = 0;
    }
  }
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v7);
}

void sub_100D08EB4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_100D08ED0(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 40);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100D08F04(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100D08F28(uint64_t a1, uint64_t a2)
{
}

void sub_100D08F30(uint64_t a1, char a2, const void **a3)
{
  uint64_t v5 = *(unsigned int *)(a1 + 1040);
  if (*a3) {
    BOOL v6 = _Block_copy(*a3);
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v7 = v6;
  sub_100CF79E4(a1, v5, 1u, a2, &v7);
  if (v6) {
    _Block_release(v6);
  }
}

void sub_100D08FB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    _Block_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D08FCC(uint64_t a1, char a2, const void **a3)
{
}

void *sub_100D08FD4(void *result, void *a2)
{
  result[5] = a2[5];
  BOOL v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  int v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    *BOOL v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void sub_100D09010(uint64_t a1)
{
}

unsigned char *sub_100D09020(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v5 = (int *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 48);
  *((_DWORD *)sub_100D1CB8C((uint64_t **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), *(_DWORD *)(a1 + 64), (_DWORD *)(a1 + 64))+ 10) = a2;
  uint64_t v7 = sub_100D1CB8C((uint64_t **)(*(void *)(*((void *)v5 - 4) + 8) + 40), *v5, v5);
  sub_1003DC1E4((uint64_t)(v7 + 6), (uint64_t)a3);
  sub_1003DC1E4((uint64_t)(v7 + 10), (uint64_t)(a3 + 4));
  if (v7 + 6 != (uint64_t **)a3)
  {
    sub_1003DAD3C((uint64_t)(v7 + 14), a3[8], a3[9], 0x8E38E38E38E38E39 * ((a3[9] - a3[8]) >> 4));
    sub_1003DAFDC((uint64_t)(v7 + 17), a3[11], a3[12], 0xCF3CF3CF3CF3CF3DLL * ((a3[12] - a3[11]) >> 3));
  }
  memset(v14, 0, sizeof(v14));
  sub_100CCD910(*v5, (_DWORD **)(v6 + 304), (char *)v14);
  if (LOBYTE(v14[0]))
  {
    uint64_t v8 = *(void *)(v6 + 160);
    char v9 = sub_100D1CB8C((uint64_t **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), *(_DWORD *)(a1 + 64), v5);
    (*(void (**)(uint64_t, char *, uint64_t **))(*(void *)v8 + 16))(v8, (char *)v14 + 8, v9 + 5);
  }
  if (++*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == *(unsigned char *)(a1 + 68))
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8) + 40;
    uint64_t v11 = *(void *)(a1 + 56);
    sub_100344308(v13, v10);
    (*(void (**)(uint64_t, uint64_t *))(v11 + 16))(v11, v13);
    sub_10034422C((uint64_t)v13, (void *)v13[1]);
  }
  return sub_1003DD210(v14);
}

void sub_100D0923C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void *);
  uint64_t v6 = va_arg(va1, void);
  sub_10034422C((uint64_t)va, v5);
  sub_1003DD210(va1);
  _Unwind_Resume(a1);
}

void *sub_100D0926C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 56);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 56) = result;
  return result;
}

void sub_100D092A0(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 56);
  if (v1) {
    _Block_release(v1);
  }
}

uint64_t sub_100D092C4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(result + 40) = v2;
  return result;
}

uint64_t sub_100D092D4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100D0930C(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I GetSIMStatusRspTimeout fired!", buf, 2u);
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  long long v7 = 0u;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)long long buf = 0u;
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  uint64_t v5 = (void **)&v10[1] + 1;
  sub_10023F96C(&v5);
  uint64_t v5 = (void **)v10;
  sub_10023FA88(&v5);
  if (LOBYTE(__p[0]))
  {
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[1]);
    }
    LOBYTE(__p[0]) = 0;
  }
  if (buf[0])
  {
    if (SHIBYTE(v7) < 0) {
      operator delete(*(void **)&buf[8]);
    }
  }
}

void sub_100D0945C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1003DA218((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100D09470(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 48);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 48) = result;
  return result;
}

void sub_100D094A4(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 48);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100D094C8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4)
  {
    uint64_t v6 = *(void ***)(a1 + 40);
    long long v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      if (!*(void *)(a1 + 48))
      {
LABEL_18:
        sub_10004D2C8(v8);
        return;
      }
      uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
      if (*(unsigned char *)(a1 + 108))
      {
        if (!v9) {
          goto LABEL_18;
        }
      }
      else if (!v9)
      {
LABEL_10:
        if (!a3)
        {
          if (!*(unsigned char *)(a1 + 64)) {
            __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
          }
          uint64_t v16 = (_DWORD *)(a1 + 104);
          BOOL v12 = sub_10008CC40(v6 + 131, (int *)(a1 + 104), (uint64_t)&unk_10144E20E, &v16);
          std::string::operator=((std::string *)(v12 + 5), (const std::string *)(a1 + 72));
        }
        (*(void (**)(uint64_t *__return_ptr))(*v6[16] + 640))(&v14);
        (*(void (**)(_DWORD **__return_ptr))(*(void *)v14 + 152))(&v16);
        char v13 = (uint64_t *)(**(uint64_t (***)(_DWORD *))v16)(v16);
        sub_1002C74D0(v6 + 116, *(_DWORD *)(a1 + 104), (_DWORD *)(a1 + 104))[5] = v13;
        if (v17) {
          sub_10004D2C8(v17);
        }
        if (v15) {
          sub_10004D2C8(v15);
        }
        (*(void (**)(void))(*(void *)(a1 + 96) + 16))();
        goto LABEL_18;
      }
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v11 = *(void *)(v10 + 40);
      *(void *)(v10 + 40) = 0;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      }
      goto LABEL_10;
    }
  }
}

void sub_100D096D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void *sub_100D09718(void *a1, void *a2)
{
  uint64_t v4 = a2[7];
  a1[6] = a2[6];
  a1[7] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100311E70((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
  uint64_t result = (void *)a2[12];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[12] = result;
  return result;
}

void sub_100D09774(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 56);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D0978C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2) {
    _Block_release(v2);
  }
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    *(unsigned char *)(a1 + 64) = 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_100D097FC(uint64_t a1)
{
  sub_100D15774(a1 + 104);
  uint64_t v3 = (void **)(a1 + 80);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 24))
  {
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100D0987C(uint64_t a1, long long *a2, long long **a3, const void **a4)
{
  sub_1003268E0((char *)__dst, *a3);
  if (*a4) {
    long long v7 = _Block_copy(*a4);
  }
  else {
    long long v7 = 0;
  }
  sub_100CFA334(a1, a2, __dst, v7);
  if (v7) {
    _Block_release(v7);
  }
  return sub_10030A89C((uint64_t)__dst);
}

void sub_100D09908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10) {
    _Block_release(v10);
  }
  sub_10030A89C((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100D0992C(uint64_t a1, long long *a2, long long **a3, const void **a4)
{
  return sub_100D0987C(a1 - 64, a2, a3, a4);
}

char *sub_100D09934@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char v3 = result[24];
  if (v3)
  {
    *(unsigned char *)a2 = 0;
    if (result[23] < 0)
    {
      uint64_t result = (char *)sub_10004FC84((unsigned char *)(a2 + 8), *(void **)result, *((void *)result + 1));
    }
    else
    {
      *(_OWORD *)(a2 + 8) = *(_OWORD *)result;
      *(void *)(a2 + 24) = *((void *)result + 2);
    }
    char v3 = 1;
  }
  *(unsigned char *)a2 = v3;
  return result;
}

void *sub_100D09994(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  sub_100345B34((uint64_t)v4, a2);
  sub_100D09A28(a1, (uint64_t)v5, (uint64_t)v4);
  return sub_100345BCC(v4);
}

void sub_100D09A0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100345BCC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100D09A28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v99 = 0;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  uint64_t v6 = *(unsigned int *)(a1 + 1040);
  char v74 = 0;
  v73 = 0;
  uint64_t v75 = 0;
  char v7 = sub_100D0180C(a1, v6, 1, (uint64_t)&v73, (uint64_t)&v85);
  char v8 = v7;
  if (SHIBYTE(v75) < 0)
  {
    operator delete(v73);
    if (v8)
    {
LABEL_3:
      uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v9 || (v10 = *(void *)(a1 + 8), (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
        sub_100088B9C();
      }
      BOOL v12 = v11;
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      v73 = 0;
      char v74 = &v73;
      uint64_t v75 = 0x3002000000;
      uint64_t v76 = sub_100D092C4;
      v77 = sub_100D092D4;
      uint64_t v78 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v26);
      (*(void (**)(void ***__return_ptr))(*(void *)v26 + 152))(&v28);
      char v13 = v28;
      sub_100058DB0(__p, "SignUpForSIMServiceRspTimeout");
      uint64_t v14 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v14;
      if (v14) {
        dispatch_retain(v14);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_100D0A6E4;
      aBlock[3] = &unk_101A50C60;
      aBlock[5] = a1;
      aBlock[4] = &v73;
      sub_100345B34((uint64_t)v72, a3);
      char v22 = _Block_copy(aBlock);
      sub_100118A44((uint64_t)v13, (uint64_t)__p, 1, 30000000, &object, &v22);
      int v15 = v30;
      BOOL v30 = 0;
      uint64_t v16 = v74[5];
      v74[5] = v15;
      if (v16)
      {
        (*(void (**)(void *))(*(void *)v16 + 8))(v16);
        char v17 = v30;
        BOOL v30 = 0;
        if (v17) {
          (*(void (**)(void *))(*(void *)v17 + 8))(v17);
        }
      }
      if (v22) {
        _Block_release(v22);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      if (v29) {
        sub_10004D2C8(v29);
      }
      if (v27) {
        sub_10004D2C8(v27);
      }
      uint64_t v18 = *(void *)(a1 + 240);
      uint64_t v19 = *(unsigned int *)(a1 + 1040);
      sub_10034696C((char *)__dst, &v85);
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 1174405120;
      v31[2] = sub_100D0A858;
      v31[3] = &unk_101A50C98;
      v31[5] = a1;
      v31[6] = v10;
      long long v32 = v12;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v31[4] = &v73;
      sub_100345B34((uint64_t)v33, a3);
      sub_10034696C((char *)&v34, &v85);
      sub_100311E70((uint64_t)v51, a2);
      uint64_t v21 = _Block_copy(v31);
      (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v18 + 8))(v18, v19, __dst, &v21);
      if (v21) {
        _Block_release(v21);
      }
      if (v68)
      {
        if (v70 < 0) {
          operator delete(v69);
        }
        char v68 = 0;
      }
      if (v65)
      {
        if (v67 < 0) {
          operator delete(v66);
        }
        char v65 = 0;
      }
      if (v62)
      {
        if (v64 < 0) {
          operator delete(v63);
        }
        char v62 = 0;
      }
      if (v59)
      {
        if (v61 < 0) {
          operator delete(v60);
        }
        char v59 = 0;
      }
      char v28 = (void **)&v58;
      sub_100047F64(&v28);
      if (v57 < 0) {
        operator delete(v56);
      }
      if (v55 < 0) {
        operator delete(__dst[0]);
      }
      if (v51[0])
      {
        if (v53 < 0) {
          operator delete(v52);
        }
        v51[0] = 0;
      }
      if (v48)
      {
        if (v50 < 0) {
          operator delete(v49);
        }
        char v48 = 0;
      }
      if (v45)
      {
        if (v47 < 0) {
          operator delete(v46);
        }
        char v45 = 0;
      }
      if (v42)
      {
        if (v44 < 0) {
          operator delete(v43);
        }
        char v42 = 0;
      }
      if (v39)
      {
        if (v41 < 0) {
          operator delete(v40);
        }
        char v39 = 0;
      }
      char v28 = (void **)&v38;
      sub_100047F64(&v28);
      if (v37 < 0) {
        operator delete(v36);
      }
      if (v35 < 0) {
        operator delete(v34);
      }
      sub_100345BCC(v33);
      if (v32) {
        std::__shared_weak_count::__release_weak(v32);
      }
      sub_100345BCC(v72);
      _Block_object_dispose(&v73, 8);
      uint64_t v20 = v78;
      uint64_t v78 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
      std::__shared_weak_count::__release_weak(v12);
      goto LABEL_81;
    }
  }
  else if (v7)
  {
    goto LABEL_3;
  }
  bzero(&v73, 0x310uLL);
  sub_100305208(a3, 0);
  if (v84 && v83 < 0) {
    operator delete(v82);
  }
  if (v81[344]) {
    sub_100310520((uint64_t)v81);
  }
  sub_1003107E0((uint64_t)&v80);
  if (v79 < 0) {
    operator delete(v77);
  }
  if (SHIBYTE(v75) < 0) {
    operator delete(v73);
  }
LABEL_81:
  if ((_BYTE)v96)
  {
    if (SHIBYTE(v97) < 0) {
      operator delete(*((void **)&v96 + 1));
    }
    LOBYTE(v96) = 0;
  }
  if (BYTE8(v93))
  {
    if (SBYTE7(v95) < 0) {
      operator delete((void *)v94);
    }
    BYTE8(v93) = 0;
  }
  if (BYTE8(v91))
  {
    if (SBYTE7(v93) < 0) {
      operator delete((void *)v92);
    }
    BYTE8(v91) = 0;
  }
  if (BYTE8(v89))
  {
    if (SBYTE7(v91) < 0) {
      operator delete((void *)v90);
    }
    BYTE8(v89) = 0;
  }
  v73 = &v88;
  sub_100047F64((void ***)&v73);
  if (SHIBYTE(v87) < 0) {
    operator delete(*((void **)&v86 + 1));
  }
  if (SBYTE7(v86) < 0) {
    operator delete((void *)v85);
  }
}

void sub_100D0A118(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100D0A278()
{
}

void sub_100D0A288()
{
}

void sub_100D0A290()
{
  if (SLOBYTE(STACK[0x317]) < 0) {
    operator delete((void *)STACK[0x300]);
  }
  JUMPOUT(0x100D0A268);
}

void *sub_100D0A2A8(uint64_t a1, uint64_t a2)
{
  return sub_100D09994(a1 - 64, a2);
}

void sub_100D0A2B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5)
  {
    if (*(unsigned char *)(a1 + 1224)) {
      uint64_t v6 = a1 + 1368;
    }
    else {
      uint64_t v6 = a1 + 328;
    }
    uint64_t v8 = v6 + 32;
    uint64_t v7 = *(void *)(v6 + 32);
    if (*(void *)(v8 + 8) != v7)
    {
      long long v24 = *(_OWORD *)(v7 + 16);
      uint64_t v10 = (std::__shared_weak_count *)operator new(0x328uLL);
      v10->__shared_owners_ = 0;
      v10->__shared_weak_owners_ = 0;
      v10->__vftable = (std::__shared_weak_count_vtbl *)off_101A51B18;
      sub_100827714(&v10[1].__vftable, (long long *)a2);
      uint64_t v11 = *(void *)(a1 + 144);
      *(void *)&long long v18 = a1;
      BOOL v12 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v12 || (v13 = *(void *)(a1 + 8), (uint64_t v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      *((void *)&v18 + 1) = v13;
      uint64_t v19 = v14;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      sub_100345B34((uint64_t)v20, a3);
      *(void *)&long long v21 = v10 + 1;
      *((void *)&v21 + 1) = v10;
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v23 = 0;
      int v15 = (char *)operator new(0x50uLL);
      *(void *)int v15 = off_101A51B68;
      *(_OWORD *)(v15 + 8) = v18;
      *((void *)v15 + 3) = v19;
      sub_10034618C((uint64_t)(v15 + 32), (uint64_t)v20);
      *((_OWORD *)v15 + 4) = v21;
      long long v21 = 0uLL;
      uint64_t v23 = v15;
      (*(void (**)(uint64_t, long long *, uint64_t, void *))(*(void *)v11 + 160))(v11, &v24, a2, v22);
      sub_10037DCD8(v22);
      if (*((void *)&v21 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v21 + 1));
      }
      sub_100345BCC(v20);
      sub_10004D2C8(v10);
      return;
    }
    char v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "csn not available", buf, 2u);
    }
  }
  else
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Unknown remote plan iccid", buf, 2u);
    }
  }
  v31[336] = 0;
  v32[0] = 0;
  char v33 = 0;
  LOBYTE(__p) = 0;
  char v36 = 0;
  *(void *)long long buf = 0;
  uint64_t v26 = 0;
  v27[0] = 0;
  *(_DWORD *)((char *)v27 + 7) = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  v31[0] = 0;
  sub_100305208(a3, 0);
  if (v36 && v35 < 0) {
    operator delete(__p);
  }
  if (v33) {
    sub_100310520((uint64_t)v32);
  }
  sub_1003107E0((uint64_t)v31);
  if (SHIBYTE(v30) < 0) {
    operator delete(v28);
  }
  if (SHIBYTE(v27[0]) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100D0A628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
}

void *sub_100D0A698(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100345BCC(a1 + 3);
  char v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D0A6DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100D0A6E4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 40) + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SignUpForSIMServiceRspTimeout fired!", (uint8_t *)v5, 2u);
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  bzero(v5, 0x310uLL);
  sub_100305208(a1 + 48, 0);
  if (v13 && v12 < 0) {
    operator delete(__p);
  }
  if (v10[344]) {
    sub_100310520((uint64_t)v10);
  }
  sub_1003107E0((uint64_t)&v9);
  if (v8 < 0) {
    operator delete(v7);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_100D0A830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100D0A844(uint64_t a1, uint64_t a2)
{
  return sub_100345B34(a1 + 48, a2 + 48);
}

void *sub_100D0A850(uint64_t a1)
{
  return sub_100345BCC((void *)(a1 + 48));
}

void sub_100D0A858(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    char v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (!*(void *)(a1 + 48))
      {
LABEL_37:
        sub_10004D2C8(v9);
        return;
      }
      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
      if (!v10)
      {
        uint64_t v16 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v17[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I signed timed out, completion already invoked", (uint8_t *)v17, 2u);
        }
        goto LABEL_37;
      }
      (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v12 = *(void *)(v11 + 40);
      *(void *)(v11 + 40) = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
      if ((a3 & 1) == 0)
      {
        bzero(v17, 0x310uLL);
        sub_100305208(a1 + 64, 0);
        if (v28 && v27 < 0) {
          operator delete(__p);
        }
        if (v25[344]) {
          sub_100310520((uint64_t)v25);
        }
        sub_1003107E0((uint64_t)v20 + 8);
        if (SBYTE7(v20[0]) < 0) {
          operator delete(v19[0]);
        }
        if (SBYTE7(v18) < 0) {
          operator delete(v17[0]);
        }
        goto LABEL_37;
      }
      if (!*(unsigned char *)(a2 + 392))
      {
        uint64_t v21 = 0;
        long long v23 = 0u;
        memset(v20, 0, sizeof(v20));
        long long v18 = 0u;
        *(_OWORD *)uint64_t v19 = 0u;
        *(_OWORD *)char v17 = 0u;
        char v22 = &v23;
        char v24 = 1;
        sub_10034620C(a2 + 56, (uint64_t)v17);
        sub_1003107E0((uint64_t)v17);
      }
      sub_1008EB2C8((uint64_t *)(v7 + 896), a1 + 120, v17);
      char v13 = (void **)(a2 + 312);
      if (*(char *)(a2 + 335) < 0) {
        operator delete(*v13);
      }
      *(_OWORD *)char v13 = *(_OWORD *)v17;
      *(void *)(a2 + 328) = v18;
      uint64_t v14 = *(unsigned __int8 *)(a2 + 335);
      int v15 = (char)v14;
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(a2 + 320);
      }
      if (!v14)
      {
        if (v15 < 0)
        {
          *(void *)(a2 + 320) = 11;
          char v13 = *(void ***)(a2 + 312);
        }
        else
        {
          *(unsigned char *)(a2 + 335) = 11;
        }
        strcpy((char *)v13, "Apple Watch");
      }
      if (*(unsigned char *)(a1 + 328))
      {
        if ((*(char *)(a1 + 359) & 0x80000000) == 0)
        {
          if (!*(unsigned char *)(a1 + 359)) {
            goto LABEL_36;
          }
          goto LABEL_35;
        }
        if (*(void *)(a1 + 344)) {
LABEL_35:
        }
          sub_10032AFC0((unsigned char *)(a2 + 336), (const std::string *)(a1 + 336));
      }
LABEL_36:
      sub_100305208(a1 + 64, 1);
      goto LABEL_37;
    }
  }
}

void sub_100D0AB40(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D0AB7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100345B34(a1 + 64, a2 + 64);
  sub_10034696C((char *)(a1 + 96), (long long *)(a2 + 96));
  return sub_100311E70(a1 + 328, a2 + 328);
}

void sub_100D0ABEC(_Unwind_Exception *a1)
{
  sub_10031085C(v3);
  sub_100345BCC(v2);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 56);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void sub_100D0AC24(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 64);
  uint64_t v3 = a1 + 96;
  if (*(unsigned char *)(a1 + 328))
  {
    if (*(char *)(a1 + 359) < 0) {
      operator delete(*(void **)(a1 + 336));
    }
    *(unsigned char *)(a1 + 328) = 0;
  }
  sub_10031085C(v3);
  sub_100345BCC(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100D0ACA8(uint64_t a1, const void **a2, uint64_t a3, int a4)
{
  long long v50 = 0u;
  uint64_t v52 = 0xA00000000000000;
  long long v51 = 0u;
  *(_OWORD *)&v53[8] = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  memset(__p, 0, sizeof(__p));
  uint64_t v55 = 23;
  HIBYTE(v50) = 8;
  uint64_t v49 = (void *)0x72616C756C6C6543;
  WORD4(v51) = 26723;
  *(void *)&long long v51 = *(void *)"eSIM Watch";
  v53[23] = 16;
  *(_OWORD *)char v53 = *(_OWORD *)"Transfer failure";
  if (*((char *)a2 + 23) >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = (size_t)a2[1];
  }
  memset(&v45, 0, sizeof(v45));
  char v8 = &v45;
  sub_1000C140C((uint64_t)&v45, v7 + 21);
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    char v8 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  if (v7)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *a2;
    }
    memmove(v8, v9, v7);
  }
  strcpy((char *)v8 + v7, " Watch Transfer Fail ");
  uint64_t v10 = std::string::append(&v45, ", PlanType:", 0xBuLL);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = (const char *)asString();
  size_t v13 = strlen(v12);
  uint64_t v14 = std::string::append(&v46, v12, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  uint64_t v16 = std::string::append(&v47, ", IsPairing:", 0xCuLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (a4) {
    long long v18 = "true";
  }
  else {
    long long v18 = "false";
  }
  if (a4) {
    std::string::size_type v19 = 4;
  }
  else {
    std::string::size_type v19 = 5;
  }
  uint64_t v20 = std::string::append(&v48, v18, v19);
  uint64_t v21 = (void *)v20->__r_.__value_.__r.__words[0];
  v59[0] = v20->__r_.__value_.__l.__size_;
  *(void *)((char *)v59 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
  char v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = v21;
  __p[1] = (void *)v59[0];
  *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v59 + 7);
  HIBYTE(__p[2]) = v22;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  v55 |= 0x13uLL;
  long long v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v48.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Reporting eSIM transfer failure on Watch", (uint8_t *)&v48, 2u);
  }
  (***(void (****)(std::string *__return_ptr))(a1 + 128))(&v48);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24, (Registry *)v48.__r_.__value_.__l.__data_);
  uint64_t v26 = ServiceMap;
  if ((v27 & 0x8000000000000000) != 0)
  {
    char v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v29 = 5381;
    do
    {
      std::string::size_type v27 = v29;
      unsigned int v30 = *v28++;
      uint64_t v29 = (33 * v29) ^ v30;
    }
    while (v30);
  }
  std::mutex::lock(ServiceMap);
  v47.__r_.__value_.__r.__words[0] = v27;
  CFTypeRef v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)&v47);
  if (v31)
  {
    uint64_t v33 = v31[3];
    long long v32 = (std::__shared_weak_count *)v31[4];
    if (v32)
    {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v26);
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v32);
      char v34 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v33 = 0;
  }
  std::mutex::unlock(v26);
  long long v32 = 0;
  char v34 = 1;
LABEL_37:
  sub_1000DB86C((char *)v35, (long long *)&v49);
  v58[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v33 + 16))(v33, v35, v58);
  sub_1000DBADC(v58);
  if (v44 < 0) {
    operator delete(v43);
  }
  if (v42 < 0) {
    operator delete(v41);
  }
  if (v40 < 0) {
    operator delete(v39);
  }
  if (v38 < 0) {
    operator delete(v37);
  }
  if ((v36 & 0x80000000) == 0)
  {
    if (v34) {
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  operator delete(v35[0]);
  if ((v34 & 1) == 0) {
LABEL_47:
  }
    sub_10004D2C8(v32);
LABEL_48:
  if (v48.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v48.__r_.__value_.__l.__size_);
  }
  if (SBYTE7(v57) < 0) {
    operator delete((void *)v56);
  }
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if ((v53[23] & 0x80000000) != 0) {
    operator delete(*(void **)v53);
  }
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)v51);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(v49);
  }
}

void sub_100D0B174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,void *__p,std::__shared_weak_count *a47,int a48,__int16 a49,char a50,char a51,char a52)
{
  sub_1000DBADC((void *)(v54 - 120));
  sub_1001278A0((uint64_t)&a9);
  if ((v53 & 1) == 0) {
    sub_10004D2C8(v52);
  }
  if (a47) {
    sub_10004D2C8(a47);
  }
  sub_1001278A0((uint64_t)&a52);
  _Unwind_Resume(a1);
}

void sub_100D0B23C(uint64_t a1, char a2, unsigned __int8 **a3, uint64_t a4)
{
  char v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handleTransferRemotePlanTapped", buf, 2u);
  }
  uint64_t v89 = 0;
  *(_OWORD *)long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  *(_OWORD *)long long v86 = 0u;
  *(_OWORD *)char v83 = 0u;
  *(_OWORD *)char v84 = 0u;
  *(_OWORD *)__n128 v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  *(_OWORD *)uint64_t v80 = 0u;
  *(_OWORD *)uint64_t v78 = 0u;
  sub_1008EB218((uint64_t *)(a1 + 896), (uint64_t)v78);
  uint64_t v9 = BYTE1(v89);
  BOOL v10 = BYTE1(v89) == 1;
  if (LOBYTE(v78[0]) == 2) {
    unsigned __int8 v11 = 2;
  }
  else {
    unsigned __int8 v11 = 1;
  }
  if ((sub_100CF965C(a1) & 1) == 0)
  {
    uint64_t v76 = 0;
    v77 = 0;
    sub_1002E8348(a4, (uint64_t)&v77, (uint64_t)&v76, 261);
    sub_100057D78(&v76);
    sub_1000558F4(&v77);
    goto LABEL_128;
  }
  if ((*((char *)a3 + 23) & 0x80000000) == 0)
  {
    if (*((unsigned char *)a3 + 23)) {
      goto LABEL_9;
    }
LABEL_113:
    uint64_t v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "empty ICCID", buf, 2u);
    }
    char v74 = 0;
    uint64_t v75 = 0;
    sub_1002E8348(a4, (uint64_t)&v75, (uint64_t)&v74, 262);
    sub_100057D78(&v74);
    sub_1000558F4(&v75);
    sub_100058DB0(buf, "");
    (*(void (**)(void, uint8_t *, uint64_t, void, BOOL))(**(void **)(a1 + 208) + 176))(*(void *)(a1 + 208), buf, 1, v11, v9 == 1);
    sub_100D0ACA8(a1, (const void **)buf, v11, v9 == 1);
    goto LABEL_125;
  }
  if (!a3[1]) {
    goto LABEL_113;
  }
LABEL_9:
  (***(void (****)(uint8_t *__return_ptr))(a1 + 128))(v107);
  *(_OWORD *)long long buf = *(_OWORD *)v107;
  *(void *)&v107[8] = 0;
  *(void *)long long v107 = 0;
  subscriber::makeSimSlotRange();
  uint64_t v68 = a4;
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  BOOL v64 = v10;
  char v65 = a2;
  int v66 = v9;
  unsigned __int8 v67 = v11;
  if (*(void *)&v107[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v107[8]);
  }
  uint64_t v12 = v90;
  size_t v13 = v91;
  if (v90 == v91) {
    goto LABEL_122;
  }
  uint64_t v14 = v92;
  while ((v14(*v12) & 1) == 0)
  {
    if (++v12 == v13)
    {
      uint64_t v12 = v13;
      break;
    }
  }
  uint64_t v69 = v91;
  if (v12 == v91) {
    goto LABEL_122;
  }
  while (1)
  {
    uint64_t v15 = *v12;
    long long v129 = 0u;
    long long v130 = 0u;
    long long v127 = 0u;
    long long v128 = 0u;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v118 = 0u;
    memset(buf, 0, sizeof(buf));
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 160) + 184))(buf);
    if (BYTE8(v130))
    {
      if (*(unsigned char *)(a1 + 1224))
      {
        uint64_t v16 = *((void *)&v129 + 1);
        for (uint64_t i = v129; ; i += 168)
        {
          if (i == v16)
          {
            uint64_t v9 = 0;
            goto LABEL_61;
          }
          uint64_t v116 = 0;
          long long v114 = 0u;
          *(_OWORD *)std::string __p = 0u;
          *(_OWORD *)long long v112 = 0u;
          *(_OWORD *)v113 = 0u;
          *(_OWORD *)uint64_t v110 = 0u;
          *(_OWORD *)char v111 = 0u;
          *(_OWORD *)__s1 = 0u;
          *(_OWORD *)__n = 0u;
          memset(v107, 0, sizeof(v107));
          sub_1003449E4((uint64_t)v107, i);
          uint64_t v18 = HIBYTE(__n[1]);
          if ((__n[1] & 0x8000000000000000) == 0) {
            size_t v19 = HIBYTE(__n[1]);
          }
          else {
            size_t v19 = __n[0];
          }
          uint64_t v20 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
          int v21 = (char)v20;
          if ((char)v20 < 0) {
            uint64_t v20 = a3[1];
          }
          if ((unsigned __int8 *)v19 != v20) {
            goto LABEL_39;
          }
          if (v21 >= 0) {
            char v22 = (unsigned __int8 *)a3;
          }
          else {
            char v22 = *a3;
          }
          if ((__n[1] & 0x8000000000000000) != 0)
          {
            if (memcmp(__s1[1], v22, __n[0])) {
              goto LABEL_39;
            }
          }
          else if (HIBYTE(__n[1]))
          {
            long long v23 = v22;
            char v24 = &__s1[1];
            while (*(unsigned __int8 *)v24 == *v23)
            {
              char v24 = (void **)((char *)v24 + 1);
              ++v23;
              if (!--v18) {
                goto LABEL_40;
              }
            }
LABEL_39:
            char v25 = 0;
            goto LABEL_43;
          }
LABEL_40:
          uint64_t v26 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = subscriber::asString();
            *(_DWORD *)v103 = 136315394;
            long long v104 = v22;
            __int16 v105 = 2080;
            uint64_t v106 = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I matching slot for remote profile iccid %s = %s", v103, 0x16u);
          }
          char v25 = 1;
          uint64_t v9 = v15;
LABEL_43:
          if (SHIBYTE(v116) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v114) < 0) {
            operator delete(v113[1]);
          }
          if (SHIBYTE(v113[0]) < 0) {
            operator delete(v112[0]);
          }
          if (SHIBYTE(v111[1]) < 0) {
            operator delete(v110[1]);
          }
          if (SHIBYTE(__n[1]) < 0) {
            operator delete(__s1[1]);
          }
          if (SHIBYTE(__s1[0]) < 0) {
            operator delete(*(void **)&v107[16]);
          }
          if (v25) {
            goto LABEL_61;
          }
        }
      }
      uint64_t v30 = *((void *)&v127 + 1);
      uint64_t v31 = v128;
      while (1)
      {
        if (v30 == v31)
        {
          int v29 = 0;
          goto LABEL_100;
        }
        *(_OWORD *)v113 = 0u;
        long long v114 = 0u;
        *(_OWORD *)char v111 = 0u;
        *(_OWORD *)long long v112 = 0u;
        *(_OWORD *)__n = 0u;
        *(_OWORD *)uint64_t v110 = 0u;
        *(_OWORD *)__s1 = 0u;
        memset(v107, 0, sizeof(v107));
        sub_1003447D4((uint64_t)v107, v30);
        uint64_t v32 = HIBYTE(v112[0]);
        if (SHIBYTE(v112[0]) >= 0) {
          size_t v33 = HIBYTE(v112[0]);
        }
        else {
          size_t v33 = v111[1];
        }
        char v34 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
        int v35 = (char)v34;
        if ((char)v34 < 0) {
          char v34 = a3[1];
        }
        if ((unsigned __int8 *)v33 != v34) {
          goto LABEL_80;
        }
        if (v35 >= 0) {
          char v36 = (unsigned __int8 *)a3;
        }
        else {
          char v36 = *a3;
        }
        if ((HIBYTE(v112[0]) & 0x80) != 0)
        {
          if (memcmp((const void *)v111[0], v36, v111[1])) {
            goto LABEL_80;
          }
        }
        else if (HIBYTE(v112[0]))
        {
          char v37 = v36;
          char v38 = v111;
          while (*(unsigned __int8 *)v38 == *v37)
          {
            char v38 = (size_t *)((char *)v38 + 1);
            ++v37;
            if (!--v32) {
              goto LABEL_81;
            }
          }
LABEL_80:
          char v39 = 0;
          goto LABEL_84;
        }
LABEL_81:
        char v40 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = subscriber::asString();
          *(_DWORD *)v103 = 136315394;
          long long v104 = v36;
          __int16 v105 = 2080;
          uint64_t v106 = v41;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I matching slot for remote profile iccid %s = %s", v103, 0x16u);
        }
        char v39 = 1;
        uint64_t v9 = v15;
LABEL_84:
        if (LOBYTE(v113[0]))
        {
          if (SHIBYTE(v114) < 0) {
            operator delete(v113[1]);
          }
          LOBYTE(v113[0]) = 0;
        }
        if (SHIBYTE(v112[0]) < 0) {
          operator delete((void *)v111[0]);
        }
        if (LOBYTE(__n[0]))
        {
          if (SHIBYTE(v110[1]) < 0) {
            operator delete((void *)__n[1]);
          }
          LOBYTE(__n[0]) = 0;
        }
        if (v107[16] && SHIBYTE(__s1[1]) < 0) {
          operator delete(*(void **)&v107[24]);
        }
        if (v39)
        {
LABEL_61:
          int v29 = 1;
          goto LABEL_100;
        }
        v30 += 144;
      }
    }
    char v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v15);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v107 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "failed to find current phone sim info", v107, 2u);
    }
    int v29 = 3;
LABEL_100:
    if (BYTE8(v130)) {
      sub_10023F898((uint64_t)buf);
    }
    if (v29 != 3 && v29) {
      break;
    }
    char v42 = v12 + 1;
    uint64_t v12 = v13;
    if (v42 != v13)
    {
      uint64_t v12 = v42;
      while ((v14(*v12) & 1) == 0)
      {
        if (++v12 == v13)
        {
          uint64_t v12 = v13;
          break;
        }
      }
    }
    if (v12 == v69) {
      goto LABEL_122;
    }
  }
  if (v9)
  {
    memset(v107, 0, 24);
    long long v90 = 0;
    (*(void (**)(unsigned int **__return_ptr))(**(void **)(a1 + 128) + 128))(&v90);
    if (v90) {
      char v44 = sub_1000810B8;
    }
    else {
      char v44 = 0;
    }
    if (v44)
    {
      memset(buf, 0, 24);
      ctu::cf::assign();
      std::string v45 = *(void **)buf;
      *(void *)&v107[8] = *(void *)&buf[8];
      *(void *)&v107[15] = *(void *)&buf[15];
      uint8_t v46 = buf[23];
      *(void *)long long v107 = *(void *)buf;
      v107[23] = buf[23];
    }
    else
    {
      std::string v45 = 0;
      uint8_t v46 = 0;
    }
    if (*(unsigned char *)(a1 + 1224)) {
      int v49 = 14;
    }
    else {
      int v49 = 12;
    }
    uint64_t v50 = *(void *)(a1 + 1096);
    if (!v50) {
      goto LABEL_170;
    }
    uint64_t v51 = a1 + 1096;
    do
    {
      int v52 = *(_DWORD *)(v50 + 32);
      BOOL v53 = v52 < v49;
      if (v52 >= v49) {
        uint64_t v54 = (uint64_t *)v50;
      }
      else {
        uint64_t v54 = (uint64_t *)(v50 + 8);
      }
      if (!v53) {
        uint64_t v51 = v50;
      }
      uint64_t v50 = *v54;
    }
    while (*v54);
    if (v51 == a1 + 1096) {
      goto LABEL_170;
    }
    if (v49 < *(_DWORD *)(v51 + 32)) {
      goto LABEL_170;
    }
    uint64_t v57 = *(void *)(v51 + 48);
    uint64_t v55 = v51 + 48;
    uint64_t v56 = v57;
    if (!v57) {
      goto LABEL_170;
    }
    uint64_t v58 = v55;
    do
    {
      int v59 = *(_DWORD *)(v56 + 28);
      BOOL v60 = v59 < (int)v9;
      if (v59 >= (int)v9) {
        char v61 = (uint64_t *)v56;
      }
      else {
        char v61 = (uint64_t *)(v56 + 8);
      }
      if (!v60) {
        uint64_t v58 = v56;
      }
      uint64_t v56 = *v61;
    }
    while (*v61);
    if (v58 != v55 && (int)v9 >= *(_DWORD *)(v58 + 28) && *(_DWORD *)(v58 + 32) == 2)
    {
      v93[0] = _NSConcreteStackBlock;
      v93[1] = 1174405120;
      v93[2] = sub_100D0BFDC;
      v93[3] = &unk_101A50D58;
      v93[4] = a1;
      int v99 = v9;
      sub_100328018((uint64_t)v94, v68);
      if ((v46 & 0x80) != 0)
      {
        sub_10004FC84(&v95, v45, *(unint64_t *)&v107[8]);
      }
      else
      {
        long long v95 = *(_OWORD *)v107;
        uint64_t v96 = *(void *)&v107[16];
      }
      unsigned __int8 v100 = v67;
      BOOL v101 = v64;
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(&v97, *a3, (unint64_t)a3[1]);
      }
      else
      {
        long long v97 = *(_OWORD *)a3;
        long long v98 = a3[2];
      }
      char v102 = v65;
      sub_100CFE56C(a1, v9, (uint64_t)v93);
      if (SHIBYTE(v98) < 0) {
        operator delete((void *)v97);
      }
      if (SHIBYTE(v96) < 0) {
        operator delete((void *)v95);
      }
      sub_10030C800(v94);
    }
    else
    {
LABEL_170:
      char v62 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v9);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        uint64_t v63 = sub_100059954(v49);
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v63;
        _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "transfer (%s) not allowed by carrier", buf, 0xCu);
      }
      char v70 = 0;
      uint64_t v71 = 0;
      sub_1002E8348(v68, (uint64_t)&v71, (uint64_t)&v70, 278);
      sub_100057D78(&v70);
      sub_1000558F4(&v71);
      (*(void (**)(void, uint8_t *, uint64_t, void, BOOL))(**(void **)(a1 + 208) + 176))(*(void *)(a1 + 208), v107, 1, v67, v66 == 1);
      sub_100D0ACA8(a1, (const void **)v107, v67, v66 == 1);
    }
    sub_1000558F4((const void **)&v90);
    if ((char)v107[23] < 0)
    {
      std::string v48 = *(void **)v107;
LABEL_127:
      operator delete(v48);
    }
    goto LABEL_128;
  }
LABEL_122:
  std::string v47 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "Failed to determine local slot for transfer operation", buf, 2u);
  }
  v72 = 0;
  v73 = 0;
  sub_1002E8348(v68, (uint64_t)&v73, (uint64_t)&v72, 312);
  sub_100057D78(&v72);
  sub_1000558F4(&v73);
  sub_100058DB0(buf, "");
  (*(void (**)(void, uint8_t *, uint64_t, void, BOOL))(**(void **)(a1 + 208) + 176))(*(void *)(a1 + 208), buf, 1, v67, v66 == 1);
  sub_100D0ACA8(a1, (const void **)buf, v67, v66 == 1);
LABEL_125:
  if ((char)buf[23] < 0)
  {
    std::string v48 = *(void **)buf;
    goto LABEL_127;
  }
LABEL_128:
  if (SHIBYTE(v88) < 0) {
    operator delete(v87[1]);
  }
  if (SHIBYTE(v87[0]) < 0) {
    operator delete(v86[0]);
  }
  if (SHIBYTE(v85) < 0) {
    operator delete(v84[1]);
  }
  if (SHIBYTE(v84[0]) < 0) {
    operator delete(v83[0]);
  }
  if (SHIBYTE(v82) < 0) {
    operator delete(v81[1]);
  }
  if (SHIBYTE(v81[0]) < 0) {
    operator delete(v80[0]);
  }
  if (SHIBYTE(v79) < 0) {
    operator delete(v78[1]);
  }
}

void sub_100D0BE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,__int16 a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,const void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *__p,uint64_t a63)
{
  if (a67 < 0) {
    operator delete(__p);
  }
  sub_10030C800(v67);
  sub_1000558F4(&a50);
  if (SLOBYTE(STACK[0x217]) < 0) {
    operator delete((void *)STACK[0x200]);
  }
  sub_1001509E4((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_100D0BFDC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (a4)
  {
    __int16 v6 = a4;
    size_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 120));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v53) = 136315138;
      *(void *)((char *)&v53 + 4) = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "cannot start provisioning operation, error: %s", (uint8_t *)&v53, 0xCu);
    }
    uint64_t v32 = 0;
    size_t v33 = 0;
    sub_1002E8348(a1 + 40, (uint64_t)&v33, (uint64_t)&v32, v6 | 0x100);
    sub_100057D78(&v32);
    sub_1000558F4(&v33);
    char v8 = (const void **)(a1 + 72);
    uint64_t v9 = *(unsigned __int8 *)(a1 + 124);
    BOOL v10 = *(unsigned char *)(a1 + 125) != 0;
    (*(void (**)(void, const void **, uint64_t, uint64_t))(**(void **)(v5 + 208) + 176))(*(void *)(v5 + 208), v8, 1, v9);
    sub_100D0ACA8(v5, v8, v9, v10);
    return;
  }
  uint64_t v13 = *(void *)(v5 + 160);
  int v14 = *(_DWORD *)(a1 + 120);
  uint64_t v31 = 0;
  long long v30 = 0uLL;
  v51[0] = 0;
  char v52 = 0;
  sub_1003DB514((uint64_t)&v53, v14, &v30, (uint64_t)v51, 1);
  (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v13 + 96))(v13, 1, &v53);
  if (v59) {
    sub_1000C584C((uint64_t)&v56);
  }
  if (SHIBYTE(v55) < 0) {
    operator delete(*((void **)&v53 + 1));
  }
  if (v52) {
    sub_1000C584C((uint64_t)v51);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)v30);
  }
  (*(void (**)(void))(**(void **)(v5 + 96) + 16))(*(void *)(v5 + 96));
  uint64_t v15 = *(void *)(v5 + 208);
  uint64_t v16 = (_OWORD *)(a1 + 72);
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(v28, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)char v28 = *v16;
    uint64_t v29 = *(void *)(a1 + 88);
  }
  (*(void (**)(uint64_t, void **, uint64_t, void, void, void))(*(void *)v15 + 88))(v15, v28, 2, *(unsigned __int8 *)(a1 + 124), *(unsigned __int8 *)(a1 + 125), 0);
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  uint64_t v17 = *(unsigned int *)(a1 + 120);
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_100D0C73C;
  aBlock[3] = &unk_101A50D28;
  aBlock[4] = v5;
  int v44 = v17;
  uint64_t v45 = a2;
  uint64_t v46 = a3;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(&v39, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    long long v39 = *v16;
    uint64_t v40 = *(void *)(a1 + 88);
  }
  char v47 = *(unsigned char *)(a1 + 124);
  sub_100328018((uint64_t)v41, a1 + 40);
  if (*(char *)(a1 + 119) < 0)
  {
    sub_10004FC84(&v42, *(void **)(a1 + 96), *(void *)(a1 + 104));
  }
  else
  {
    long long v42 = *(_OWORD *)(a1 + 96);
    uint64_t v43 = *(void *)(a1 + 112);
  }
  char v48 = *(unsigned char *)(a1 + 126);
  char v49 = 0;
  char v50 = *(unsigned char *)(a1 + 125);
  uint64_t v18 = _Block_copy(aBlock);
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 128) + 640))(buf);
  char v19 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 96))(*(void *)buf, v17);
  if (v36) {
    sub_10004D2C8(v36);
  }
  if (v19)
  {
    buf[0] = 0;
    uint64_t v20 = *(std::__shared_weak_count **)(v5 + 16);
    if (!v20 || (v21 = *(void *)(v5 + 8), (char v22 = std::__shared_weak_count::lock(v20)) == 0)) {
      sub_100088B9C();
    }
    long long v23 = v22;
    p_shared_weak_owners = &v22->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
    uint64_t v25 = *(void *)(v5 + 240);
    *(void *)&long long v53 = _NSConcreteStackBlock;
    *((void *)&v53 + 1) = 1174405120;
    uint64_t v54 = sub_100D0EA4C;
    uint64_t v55 = &unk_101A50D88;
    uint64_t v56 = v21;
    uint64_t v57 = v23;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    if (v18) {
      uint64_t v26 = _Block_copy(v18);
    }
    else {
      uint64_t v26 = 0;
    }
    uint64_t v58 = v26;
    char v34 = _Block_copy(&v53);
    (*(void (**)(uint64_t, uint64_t, uint8_t *, void **))(*(void *)v25 + 16))(v25, v17, buf, &v34);
    if (v34) {
      _Block_release(v34);
    }
    if (v58) {
      _Block_release(v58);
    }
    if (v57) {
      std::__shared_weak_count::__release_weak(v57);
    }
    std::__shared_weak_count::__release_weak(v23);
    if (!v18) {
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v17);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I authenticateTrustFlag not supported by carrier", buf, 2u);
    }
    char v36 = 0;
    uint64_t v37 = 0;
    *(void *)long long buf = 0;
    (*((void (**)(void *, void, uint8_t *))v18 + 2))(v18, 0, buf);
    if (SHIBYTE(v37) < 0) {
      operator delete(*(void **)buf);
    }
  }
  _Block_release(v18);
LABEL_44:
  if (SHIBYTE(v43) < 0) {
    operator delete((void *)v42);
  }
  sub_10030C800(v41);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)v39);
  }
}

void sub_100D0C5F4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100D0C73C(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  size_t v7 = (char *)operator new(0x170uLL);
  char v8 = v7;
  *((void *)v7 + 1) = 0;
  uint64_t v9 = (atomic_ullong *)(v7 + 8);
  *((void *)v7 + 2) = 0;
  *(void *)size_t v7 = off_101A51BE8;
  *(_OWORD *)(v7 + 24) = 0u;
  BOOL v10 = v7 + 24;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 104) = 0u;
  *(_OWORD *)(v7 + 120) = 0u;
  *(_OWORD *)(v7 + 136) = 0u;
  *(_OWORD *)(v7 + 152) = 0u;
  *(_OWORD *)(v7 + 168) = 0u;
  *(_OWORD *)(v7 + 184) = 0u;
  *(_OWORD *)(v7 + 200) = 0u;
  *(_OWORD *)(v7 + 216) = 0u;
  *(_OWORD *)(v7 + 232) = 0u;
  *(_OWORD *)(v7 + 248) = 0u;
  *((void *)v7 + 45) = 0;
  *(_OWORD *)(v7 + 264) = 0u;
  *(_OWORD *)(v7 + 280) = 0u;
  *(_OWORD *)(v7 + 296) = 0u;
  *(_OWORD *)(v7 + 312) = 0u;
  *(_OWORD *)(v7 + 328) = 0u;
  *(_OWORD *)(v7 + 344) = 0u;
  if (a2)
  {
    uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a3 + 8);
    }
    if (v11) {
      sub_100093B44((std::string *)v7 + 1, (const std::string *)a3);
    }
  }
  uint64_t v12 = *(unsigned int *)(a1 + 120);
  atomic_fetch_add_explicit(v9, 1uLL, memory_order_relaxed);
  uint64_t v13 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), v12);
  int v14 = (unsigned __int8 *)(a1 + 96);
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v60, 0, sizeof(v60));
  std::string::operator=((std::string *)v60, (const std::string *)(a1 + 96));
  *(_OWORD *)uint64_t v89 = 0u;
  long long v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  *(_OWORD *)long long v82 = 0u;
  *(_OWORD *)long long v79 = 0u;
  *(_OWORD *)uint64_t v80 = 0u;
  long long v77 = 0u;
  *(_OWORD *)uint64_t v78 = 0u;
  *(_OWORD *)long long __dst = 0u;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v6 + 160) + 184))(__dst);
  if (BYTE8(v90))
  {
    if (*(unsigned char *)(v6 + 1224))
    {
      uint64_t v15 = v89[0];
      uint64_t v16 = v89[1];
      if (v89[0] == v89[1]) {
        goto LABEL_64;
      }
      char v17 = *(unsigned char *)(a1 + 119);
      if (v17 >= 0) {
        uint64_t v18 = *(unsigned __int8 *)(a1 + 119);
      }
      else {
        uint64_t v18 = *(void *)(a1 + 104);
      }
      if (v17 >= 0) {
        char v19 = (unsigned __int8 *)(a1 + 96);
      }
      else {
        char v19 = *(unsigned __int8 **)(a1 + 96);
      }
      while (1)
      {
        uint64_t v20 = *((unsigned __int8 *)v15 + 63);
        unint64_t v21 = *((void *)v15 + 6);
        if ((v20 & 0x80u) == 0) {
          uint64_t v22 = *((unsigned __int8 *)v15 + 63);
        }
        else {
          uint64_t v22 = *((void *)v15 + 6);
        }
        if (v22 == v18)
        {
          if ((v20 & 0x80) != 0)
          {
            if (!memcmp(*((const void **)v15 + 5), v19, v21))
            {
LABEL_49:
              ctu::hex((uint64_t *)buf, v15, (const void *)0x10, v21);
              sub_10008BE4C((uint64_t)(v8 + 80), (long long *)buf);
              if (SHIBYTE(v58) < 0) {
                operator delete(*(void **)buf);
              }
              if (*((char *)v15 + 39) < 0)
              {
                if (!*((void *)v15 + 3)) {
                  goto LABEL_64;
                }
              }
              else if (!*((unsigned char *)v15 + 39))
              {
                goto LABEL_64;
              }
              sub_100093B44((std::string *)&v60[24], (const std::string *)((char *)v15 + 16));
              goto LABEL_64;
            }
          }
          else
          {
            if (!*((unsigned char *)v15 + 63)) {
              goto LABEL_49;
            }
            uint64_t v23 = 0;
            while (*((unsigned __int8 *)v15 + v23 + 40) == v19[v23])
            {
              if (v20 == ++v23) {
                goto LABEL_49;
              }
            }
          }
        }
        uint64_t v15 = (ctu *)((char *)v15 + 168);
        if (v15 == v16) {
          goto LABEL_64;
        }
      }
    }
    uint64_t v25 = *((void *)&v87 + 1);
    uint64_t v26 = v88;
    if (*((void *)&v87 + 1) == (void)v88) {
      goto LABEL_64;
    }
    char v27 = *(unsigned char *)(a1 + 119);
    if (v27 >= 0) {
      uint64_t v28 = *(unsigned __int8 *)(a1 + 119);
    }
    else {
      uint64_t v28 = *(void *)(a1 + 104);
    }
    if (v27 < 0) {
      int v14 = *(unsigned __int8 **)(a1 + 96);
    }
    while (1)
    {
      uint64_t v29 = *(unsigned __int8 *)(v25 + 103);
      unint64_t v30 = *(void *)(v25 + 88);
      if ((v29 & 0x80u) == 0) {
        uint64_t v31 = *(unsigned __int8 *)(v25 + 103);
      }
      else {
        uint64_t v31 = *(void *)(v25 + 88);
      }
      if (v31 == v28)
      {
        if ((v29 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v25 + 80), v14, v30))
          {
LABEL_54:
            ctu::hex((uint64_t *)buf, (ctu *)v25, (const void *)0x10, v30);
            sub_10008BE4C((uint64_t)(v8 + 80), (long long *)buf);
            if (SHIBYTE(v58) < 0) {
              operator delete(*(void **)buf);
            }
            sub_100CFBAA0((char *)(v25 + 16), (uint64_t)buf);
            sub_100179CB0((uint64_t)&v60[24], (__n128 *)buf);
            if (v59 && SHIBYTE(v58) < 0) {
              operator delete(*(void **)buf);
            }
            sub_100CFBAA0((char *)(v25 + 48), (uint64_t)buf);
            sub_100179CB0((uint64_t)&__p[1], (__n128 *)buf);
            if (v59 && SHIBYTE(v58) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_64;
          }
        }
        else
        {
          if (!*(unsigned char *)(v25 + 103)) {
            goto LABEL_54;
          }
          uint64_t v32 = 0;
          while (*(unsigned __int8 *)(v25 + v32 + 80) == v14[v32])
          {
            if (v29 == ++v32) {
              goto LABEL_54;
            }
          }
        }
      }
      v25 += 144;
      if (v25 == v26) {
        goto LABEL_64;
      }
    }
  }
  char v24 = *v13;
  if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "failed to find current phone sim info", buf, 2u);
  }
LABEL_64:
  unint64_t v33 = *((void *)v8 + 8);
  if (v33 >= *((void *)v8 + 9))
  {
    uint64_t v35 = sub_100D15584((uint64_t *)v8 + 7, (long long *)v60);
  }
  else
  {
    sub_10019FFDC(*((void **)v8 + 8), (long long *)v60);
    uint64_t v35 = v33 + 96;
    *((void *)v8 + 8) = v33 + 96;
  }
  *((void *)v8 + 8) = v35;
  if (BYTE8(v90)) {
    sub_10023F898((uint64_t)__dst);
  }
  if ((_BYTE)v64 && SHIBYTE(v63) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && SHIBYTE(v61) < 0) {
    operator delete(*(void **)&v60[24]);
  }
  if ((v60[23] & 0x80000000) != 0) {
    operator delete(*(void **)v60);
  }
  long long v75 = 0uLL;
  uint64_t v36 = v6 + 1368;
  if (!*(unsigned char *)(v6 + 1224)) {
    uint64_t v36 = v6 + 328;
  }
  uint64_t v37 = *(void *)(v36 + 32);
  if (*(void *)(v36 + 40) == v37 || !*(unsigned char *)(v36 + 24))
  {
    uint64_t v41 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long __dst = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "failed to get target EID", __dst, 2u);
    }
    sub_10004D2C8((std::__shared_weak_count *)v8);
    long long v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), *(unsigned int *)(a1 + 120));
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long __dst = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "failed to fill TransferSIMRequest parameters", __dst, 2u);
    }
    sub_100D028F0(v6, (void *)(a1 + 124), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 140), 0);
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    sub_1002E8348(a1 + 64, (uint64_t)&v56, (uint64_t)&v55, 261);
    sub_100057D78(&v55);
    sub_1000558F4(&v56);
  }
  else
  {
    long long v75 = *(_OWORD *)(v37 + 16);
    ctu::hex((uint64_t *)__dst, (ctu *)&v75, (const void *)0x10, v34);
    char v38 = (void **)(v8 + 112);
    if (v8[135] < 0) {
      operator delete(*v38);
    }
    *(_OWORD *)char v38 = *(_OWORD *)__dst;
    *((void *)v8 + 16) = v77;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    *(_OWORD *)std::string __p = 0u;
    memset(v60, 0, sizeof(v60));
    *(void *)&long long v84 = 0;
    *(_OWORD *)long long v82 = 0u;
    long long v83 = 0u;
    *(_OWORD *)uint64_t v80 = 0u;
    long long v81 = 0u;
    *(_OWORD *)uint64_t v78 = 0u;
    *(_OWORD *)long long v79 = 0u;
    *(_OWORD *)long long __dst = 0u;
    long long v77 = 0u;
    if (*(unsigned char *)(v6 + 1224)) {
      long long v39 = (long long *)(v6 + 1232);
    }
    else {
      long long v39 = (long long *)(v6 + 408);
    }
    sub_100313228((char *)__dst, v39);
    char v40 = BYTE8(v77);
    if (BYTE8(v77))
    {
      if (SHIBYTE(v79[0]) < 0)
      {
        sub_10004FC84(buf, v78[0], (unint64_t)v78[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)v78;
        uint64_t v58 = v79[0];
      }
      char v40 = 1;
    }
    else
    {
      buf[0] = 0;
    }
    char v59 = v40;
    sub_100179CB0((uint64_t)&v60[24], (__n128 *)buf);
    if (v59 && SHIBYTE(v58) < 0) {
      operator delete(*(void **)buf);
    }
    char v43 = (char)v79[1];
    if (LOBYTE(v79[1]))
    {
      if (SBYTE7(v81) < 0)
      {
        sub_10004FC84(buf, v80[0], (unint64_t)v80[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)v80;
        uint64_t v58 = (void *)v81;
      }
      char v43 = 1;
    }
    else
    {
      buf[0] = 0;
    }
    char v59 = v43;
    sub_100179CB0((uint64_t)&__p[1], (__n128 *)buf);
    if (v59 && SHIBYTE(v58) < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v44 = *((void *)v8 + 18);
    if (v44 >= *((void *)v8 + 19))
    {
      uint64_t v45 = sub_100D15584((uint64_t *)v8 + 17, (long long *)v60);
    }
    else
    {
      sub_10019FFDC(*((void **)v8 + 18), (long long *)v60);
      uint64_t v45 = v44 + 96;
      *((void *)v8 + 18) = v44 + 96;
    }
    *((void *)v8 + 18) = v45;
    sub_1000791C0((std::string *)(v8 + 160), &off_101A50658);
    if (SBYTE7(v83) < 0) {
      operator delete(v82[0]);
    }
    if (LOBYTE(v79[1]))
    {
      if (SBYTE7(v81) < 0) {
        operator delete(v80[0]);
      }
      LOBYTE(v79[1]) = 0;
    }
    if (BYTE8(v77))
    {
      if (SHIBYTE(v79[0]) < 0) {
        operator delete(v78[0]);
      }
      BYTE8(v77) = 0;
    }
    if (SBYTE7(v77) < 0) {
      operator delete(*(void **)__dst);
    }
    if ((_BYTE)v64 && SHIBYTE(v63) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v61) < 0) {
      operator delete(*(void **)&v60[24]);
    }
    if ((v60[23] & 0x80000000) != 0) {
      operator delete(*(void **)v60);
    }
    sub_10004D2C8((std::__shared_weak_count *)v8);
    uint64_t v46 = *(unsigned int *)(a1 + 120);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100D0D2F4;
    aBlock[3] = &unk_101A50CF8;
    aBlock[4] = v6;
    int v70 = v46;
    long long v71 = *(_OWORD *)(a1 + 124);
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(&v66, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      long long v66 = *(_OWORD *)(a1 + 40);
      uint64_t v67 = *(void *)(a1 + 56);
    }
    char v72 = *(unsigned char *)(a1 + 140);
    sub_100328018((uint64_t)v68, a1 + 64);
    v68[4] = v10;
    uint64_t v69 = (std::__shared_weak_count *)v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    char v73 = *(unsigned char *)(a1 + 141);
    __int16 v74 = *(_WORD *)(a1 + 142);
    char v47 = _Block_copy(aBlock);
    char v48 = *(std::__shared_weak_count **)(v6 + 16);
    if (!v48 || (char v49 = *(std::__shared_weak_count **)(v6 + 8), (v50 = std::__shared_weak_count::lock(v48)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v51 = v50;
    p_shared_weak_owners = &v50->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v50);
    uint64_t v53 = *(void *)(v6 + 240);
    *(void *)long long __dst = _NSConcreteStackBlock;
    *(void *)&__dst[8] = 1174405120;
    *(void *)&long long v77 = sub_100D0EB88;
    *((void *)&v77 + 1) = &unk_101A50DB8;
    v78[0] = v49;
    v78[1] = v51;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    if (v47) {
      uint64_t v54 = _Block_copy(v47);
    }
    else {
      uint64_t v54 = 0;
    }
    v79[0] = v54;
    *(void *)BOOL v60 = _Block_copy(__dst);
    (*(void (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v53 + 24))(v53, v46, v10, v60);
    if (*(void *)v60) {
      _Block_release(*(const void **)v60);
    }
    if (v79[0]) {
      _Block_release(v79[0]);
    }
    if (v78[1]) {
      std::__shared_weak_count::__release_weak(v78[1]);
    }
    std::__shared_weak_count::__release_weak(v51);
    if (v47) {
      _Block_release(v47);
    }
    if (v69) {
      sub_10004D2C8(v69);
    }
    sub_10030C800(v68);
    if (SHIBYTE(v67) < 0) {
      operator delete((void *)v66);
    }
  }
  sub_10004D2C8((std::__shared_weak_count *)v8);
}

void sub_100D0D170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  sub_100309AC4((uint64_t)&a47);
  sub_10018F220((uint64_t)&aBlock);
  sub_10004D2C8(v47);
  sub_10004D2C8(v47);
  _Unwind_Resume(a1);
}

void sub_100D0D2F4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (a2 != 6000)
  {
    if (a2 != 6013)
    {
      char v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = sub_100FB56F4(a2);
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "transferSIMService failed, status %s", buf, 0xCu);
      }
      sub_100D028F0(v5, (void *)(a1 + 116), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 132), 0);
      long long v79 = 0;
      uint64_t v80 = 0;
      sub_1002E8348(a1 + 64, (uint64_t)&v80, (uint64_t)&v79, 312);
      sub_100057D78(&v79);
      uint64_t v20 = (const void **)&v80;
      goto LABEL_28;
    }
    if (*(unsigned char *)(a3 + 48))
    {
      uint64_t v117 = 0;
      memset(v116, 0, sizeof(v116));
      long long v115 = 0u;
      *(_OWORD *)long long v114 = 0u;
      memset(v113, 0, sizeof(v113));
      long long v112 = 0u;
      *(_OWORD *)char v111 = 0u;
      memset(v110, 0, sizeof(v110));
      *(_OWORD *)std::string __p = 0u;
      long long v108 = 0u;
      *(_OWORD *)long long v107 = 0u;
      int v7 = *(_DWORD *)(a1 + 112);
      uint64_t v8 = *(void *)(a1 + 96);
      sub_1000593FC((uint64_t)v76, (long long *)(a3 + 56));
      if (v7)
      {
        uint64_t v9 = *(void *)(v5 + 304);
        uint64_t v10 = *(void *)(v5 + 312);
        if (v9 != v10)
        {
          while (*(_DWORD *)v9 != v7)
          {
            v9 += 168;
            if (v9 == v10)
            {
              uint64_t v9 = *(void *)(v5 + 312);
              break;
            }
          }
        }
        memset(&__dst, 0, sizeof(__dst));
        if (*(char *)(v9 + 95) < 0) {
          sub_10004FC84(&__dst, *(void **)(v9 + 72), *(void *)(v9 + 80));
        }
        else {
          std::string __dst = *(std::string *)(v9 + 72);
        }
        if (v78)
        {
          if (SHIBYTE(v77) < 0)
          {
            sub_10004FC84(buf, v76[0], (unint64_t)v76[1]);
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)v76;
            std::string::size_type v93 = v77;
          }
        }
        else
        {
          memset(buf, 0, sizeof(buf));
          std::string::size_type v93 = 0;
        }
        if (SBYTE7(v110[0]) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        *(void *)&v110[0] = v93;
        sub_100D09934((char *)v8, (uint64_t)buf);
        sub_1003464A0((uint64_t)v107, (uint64_t)buf);
        if (buf[0] && v95 < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (*(unsigned char *)(v8 + 80)) {
          std::string::operator=((std::string *)((char *)v110 + 8), (const std::string *)(v8 + 56));
        }
        uint64_t v29 = *(void *)(v8 + 32);
        for (uint64_t i = *(void *)(v8 + 40); v29 != i; v29 += 96)
        {
          sub_100D09934((char *)(v29 + 24), (uint64_t)buf);
          sub_100D09934((char *)(v29 + 56), (uint64_t)&v118);
          uint64_t v31 = (char *)v111[1];
          if (v111[1] >= (void *)v112)
          {
            uint64_t v32 = (void *)sub_100D157C4((uint64_t *)v111, v29, (uint64_t)buf, (uint64_t)&v118);
          }
          else
          {
            sub_100D158FC((void *)v111[1], v29, (uint64_t)buf, (uint64_t)&v118);
            uint64_t v32 = v31 + 88;
          }
          v111[1] = v32;
          if ((_BYTE)v118 && v120 < 0) {
            operator delete(*((void **)&v118 + 1));
          }
          if (buf[0] && v95 < 0) {
            operator delete(*(void **)&buf[8]);
          }
        }
        if (SBYTE7(v113[1]) < 0)
        {
          *((void *)&v113[0] + 1) = 11;
          unint64_t v33 = *(char **)&v113[0];
        }
        else
        {
          unint64_t v33 = (char *)v113;
          BYTE7(v113[1]) = 11;
        }
        strcpy(v33, "Apple Watch");
        sub_100D1CC7C((uint64_t)&v113[1] + 8, "Watch");
        sub_10032AFC0((unsigned char *)&v113[3] + 8, &__dst);
        std::string::operator=((std::string *)((char *)&v113[5] + 8), (const std::string *)(v8 + 88));
        uint64_t v34 = *(void *)(v8 + 112);
        for (uint64_t j = *(void *)(v8 + 120); v34 != j; v34 += 96)
        {
          sub_100D09934((char *)(v34 + 24), (uint64_t)buf);
          sub_100D09934((char *)(v34 + 56), (uint64_t)&v118);
          uint64_t v36 = (char *)v114[1];
          if (v114[1] >= (void *)v115)
          {
            uint64_t v37 = (void *)sub_100D157C4((uint64_t *)v114, v34, (uint64_t)buf, (uint64_t)&v118);
          }
          else
          {
            sub_100D158FC((void *)v114[1], v34, (uint64_t)buf, (uint64_t)&v118);
            uint64_t v37 = v36 + 88;
          }
          v114[1] = v37;
          if ((_BYTE)v118 && v120 < 0) {
            operator delete(*((void **)&v118 + 1));
          }
          if (buf[0] && v95 < 0) {
            operator delete(*(void **)&buf[8]);
          }
        }
        if (SBYTE7(v116[1]) < 0)
        {
          *((void *)&v116[0] + 1) = 11;
          char v38 = *(char **)&v116[0];
        }
        else
        {
          char v38 = (char *)v116;
          BYTE7(v116[1]) = 11;
        }
        strcpy(v38, "Apple Watch");
        sub_100D1CC7C((uint64_t)&v116[1] + 8, "Watch");
        sub_10032AFC0((unsigned char *)&v116[3] + 8, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        uint64_t v23 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid slot", buf, 2u);
        }
      }
      long long v39 = (const std::string *)(a3 + 24);
      if (v78 && SHIBYTE(v77) < 0) {
        operator delete(v76[0]);
      }
      if (*(unsigned char *)(a1 + 133))
      {
        if ((sub_100CFDC54(v5, 0, a1 + 116) & 1) == 0)
        {
          char v48 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            uint64_t v54 = asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v54;
            _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Cannot create provisioning operation for transfer, error: %s", buf, 0xCu);
          }
          sub_100D028F0(v5, (void *)(a1 + 116), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 132), 0);
          __int16 v74 = 0;
          long long v75 = 0;
          sub_1002E8348(a1 + 64, (uint64_t)&v75, (uint64_t)&v74, 261);
          sub_100057D78(&v74);
          sub_1000558F4(&v75);
          goto LABEL_148;
        }
        *(_DWORD *)(v5 + 1040) = *(_DWORD *)(a1 + 112);
        bzero(buf, 0x310uLL);
        std::string::operator=(&v96, v39);
        char v94 = 0;
        if (v103)
        {
          sub_1003464A0((uint64_t)v98, (uint64_t)v107);
          if (SHIBYTE(v100) < 0) {
            operator delete((void *)v99);
          }
          long long v99 = *(_OWORD *)__p;
          uint64_t v100 = *(void *)&v110[0];
          BYTE7(v110[0]) = 0;
          LOBYTE(__p[0]) = 0;
          sub_100D15AA0((uint64_t)&v101, (long long *)((char *)v110 + 8));
          sub_100D15AA0((uint64_t)&v102, (long long *)((char *)&v113[5] + 8));
        }
        else
        {
          sub_1003DF3C0((uint64_t)v98, (uint64_t)v107);
          char v103 = 1;
        }
        uint64_t v50 = *(void *)(v5 + 256);
        uint64_t v51 = *(unsigned int *)(v5 + 1040);
        v90[0] = 0;
        sub_100827714(v91, (long long *)buf);
        v90[0] = 1;
        (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)v50 + 56))(v50, a1 + 116, v51, v90);
        sub_10082783C(v90);
        (*(void (**)(void, uint64_t, uint64_t, void, void))(**(void **)(v5 + 208) + 176))(*(void *)(v5 + 208), a1 + 40, 2, *(unsigned __int8 *)(a1 + 132), *(unsigned __int8 *)(a1 + 135));
        char v72 = 0;
        char v73 = 0;
        sub_1002E8348(a1 + 64, (uint64_t)&v73, (uint64_t)&v72, 0);
        sub_100057D78(&v72);
        sub_1000558F4(&v73);
        if (v106 && v105 < 0) {
          operator delete(v104);
        }
        if (v103) {
          sub_100310520((uint64_t)v98);
        }
        sub_1003107E0((uint64_t)&v97);
        if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v96.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v93) < 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        CFTypeRef cf = 0;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          CFTypeRef v41 = cf;
          CFTypeRef cf = Mutable;
          *(void *)long long buf = v41;
          sub_10005717C((const void **)buf);
        }
        CFTypeRef v70 = cf;
        if (cf) {
          CFRetain(cf);
        }
        BOOL v42 = sub_100DDCEB8((CFMutableDictionaryRef *)&v70, (uint64_t)v107);
        sub_10005717C(&v70);
        char v43 = (void *)(a1 + 116);
        unint64_t v44 = (const void **)(a1 + 40);
        uint64_t v45 = *(unsigned __int8 *)(a1 + 132);
        if (!v42)
        {
          sub_100D028F0(v5, v43, v44, v45, 0);
          uint64_t v68 = 0;
          uint64_t v69 = 0;
          sub_1002E8348(a1 + 64, (uint64_t)&v69, (uint64_t)&v68, 261);
          sub_100057D78(&v68);
          sub_1000558F4(&v69);
          sub_10005717C(&cf);
LABEL_148:
          sub_100310520((uint64_t)v107);
          return;
        }
        sub_100D028F0(v5, v43, v44, v45, 1);
        uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a3 + 47) >= 0) {
            uint64_t v47 = a3 + 24;
          }
          else {
            uint64_t v47 = *(void *)(a3 + 24);
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v47;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I initiate transfer websheet flow: %s", buf, 0xCu);
        }
        if (*(char *)(a3 + 47) < 0)
        {
          sub_10004FC84(v65, *(void **)(a3 + 24), *(void *)(a3 + 32));
        }
        else
        {
          *(_OWORD *)char v65 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
          std::string::size_type v66 = *(void *)(a3 + 40);
        }
        if (SHIBYTE(v66) < 0)
        {
          sub_10004FC84(&v118, v65[0], (unint64_t)v65[1]);
        }
        else
        {
          long long v118 = *(_OWORD *)v65;
          std::string::size_type v119 = v66;
        }
        long long v81 = 0;
        if (SHIBYTE(v119) < 0)
        {
          sub_10004FC84(buf, (void *)v118, *((unint64_t *)&v118 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v118;
          std::string::size_type v93 = v119;
        }
        long long v82 = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v52 = (std::string::size_type)v81;
          long long v81 = v82;
          __dst.__r_.__value_.__r.__words[0] = v52;
          sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v93) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v67 = v81;
        long long v81 = 0;
        sub_1000558F4(&v81);
        if (SHIBYTE(v119) < 0) {
          operator delete((void *)v118);
        }
        sub_10004EFE4(&v64, &cf);
        sub_1002E8348(a1 + 64, (uint64_t)&v67, (uint64_t)&v64, 0);
        sub_100057D78(&v64);
        sub_1000558F4(&v67);
        if (SHIBYTE(v66) < 0) {
          operator delete(v65[0]);
        }
        sub_10005717C(&cf);
      }
      (*(void (**)(void, uint64_t, uint64_t, void, void))(**(void **)(v5 + 208) + 176))(*(void *)(v5 + 208), a1 + 40, 2, *(unsigned __int8 *)(a1 + 132), *(unsigned __int8 *)(a1 + 135));
      goto LABEL_148;
    }
  }
  uint64_t v11 = *(const std::string **)a3;
  if (*(void *)a3 == *(void *)(a3 + 8))
  {
    unint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "transferSIMService response does not contain any ICCID", buf, 2u);
    }
    sub_100D028F0(v5, (void *)(a1 + 116), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 132), 0);
    char v62 = 0;
    uint64_t v63 = 0;
    sub_1002E8348(a1 + 64, (uint64_t)&v63, (uint64_t)&v62, 312);
    sub_100057D78(&v62);
    uint64_t v20 = (const void **)&v63;
    goto LABEL_28;
  }
  if (!v11[3].__r_.__value_.__s.__data_[17] || v11[3].__r_.__value_.__s.__data_[16])
  {
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I initiate transfer profile fetch", buf, 2u);
    }
    char v13 = sub_100CFDC54(v5, 0, a1 + 116);
    uint64_t v14 = *(unsigned int *)(a1 + 112);
    if (v13)
    {
      *(_DWORD *)(v5 + 1040) = v14;
      (*(void (**)(void, uint64_t, uint64_t, void, void))(**(void **)(v5 + 208) + 176))(*(void *)(v5 + 208), a1 + 40, 3, *(unsigned __int8 *)(a1 + 132), *(unsigned __int8 *)(a1 + 135));
      std::string::operator=((std::string *)(v5 + 976), v11);
      v107[1] = 0;
      v107[0] = 0;
      sub_100324590(v107);
      uint64_t v15 = v107[0];
      uint64_t v16 = v107[0] + 4;
      std::string::size_type size = v107[0][4].__r_.__value_.__l.__size_;
      if (size >= v107[0][4].__r_.__value_.__r.__words[2])
      {
        uint64_t v18 = sub_1000D8CE8((uint64_t *)v16, (long long *)(v5 + 976));
      }
      else
      {
        sub_10030BFC4(v16, (long long *)(v5 + 976));
        uint64_t v18 = size + 24;
      }
      v15[4].__r_.__value_.__l.__size_ = v18;
      if (*(unsigned char *)(a3 + 112))
      {
        std::string::operator=(v107[0], (const std::string *)(a3 + 88));
      }
      else
      {
        (*(void (**)(long long *__return_ptr))(**(void **)(v5 + 128) + 640))(&v118);
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v118 + 48))(buf);
        uint64_t v26 = v107[0];
        if (SHIBYTE(v107[0]->__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v107[0]->__r_.__value_.__l.__data_);
        }
        long long v27 = *(_OWORD *)buf;
        v26->__r_.__value_.__r.__words[2] = v93;
        *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v27;
        HIBYTE(v93) = 0;
        buf[0] = 0;
        if (*((void *)&v118 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v118 + 1));
        }
      }
      uint64_t v28 = *(void *)(v5 + 256);
      uint64_t v57 = v107[0];
      uint64_t v58 = (std::__shared_weak_count *)v107[1];
      if (v107[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v107[1]->__r_.__value_.__l.__size_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t, std::string **))(*(void *)v28 + 24))(v28, a1 + 116, &v57);
      if (v58) {
        sub_10004D2C8(v58);
      }
      uint64_t v55 = 0;
      uint64_t v56 = 0;
      sub_1002E8348(a1 + 64, (uint64_t)&v56, (uint64_t)&v55, 0);
      sub_100057D78(&v55);
      sub_1000558F4(&v56);
      if (v107[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v107[1]);
      }
      return;
    }
    uint64_t v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v14);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v53 = asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v53;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Cannot create provisioning operation for transfer, error: %s", buf, 0xCu);
    }
    sub_100D028F0(v5, (void *)(a1 + 116), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 132), 0);
    char v59 = 0;
    uint64_t v60 = 0;
    sub_1002E8348(a1 + 64, (uint64_t)&v60, (uint64_t)&v59, 261);
    sub_100057D78(&v59);
    uint64_t v20 = (const void **)&v60;
LABEL_28:
    sub_1000558F4(v20);
    return;
  }
  char v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 112));
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I transfer completed with profile pending release", buf, 2u);
  }
  uint64_t v25 = *(unsigned int *)(v5 + 1040);
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_100D0E5B8;
  aBlock[3] = &unk_101A50CC8;
  aBlock[4] = v5;
  long long v88 = *(_OWORD *)(a1 + 116);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(&v85, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long v85 = *(_OWORD *)(a1 + 40);
    uint64_t v86 = *(void *)(a1 + 56);
  }
  char v89 = *(unsigned char *)(a1 + 132);
  sub_100328018((uint64_t)v87, a1 + 64);
  char v49 = _Block_copy(aBlock);
  long long v61 = v49;
  sub_100CF79E4(v5, v25, 1u, 1, &v61);
  if (v49) {
    _Block_release(v49);
  }
  sub_10030C800(v87);
  if (SHIBYTE(v86) < 0) {
    operator delete((void *)v85);
  }
}

void sub_100D0E304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,const void *a40)
{
  sub_1000558F4(&a40);
  if (*(char *)(v40 - 105) < 0) {
    operator delete(*(void **)(v40 - 128));
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_10005717C(&a29);
  sub_100310520((uint64_t)&STACK[0x7B0]);
  _Unwind_Resume(a1);
}

const void **sub_100D0E5B8(uint64_t a1)
{
  sub_100D028F0(*(void *)(a1 + 32), (void *)(a1 + 96), (const void **)(a1 + 40), *(unsigned __int8 *)(a1 + 112), 1);
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_1002E8348(a1 + 64, (uint64_t)&v4, (uint64_t)&v3, 0);
  sub_100057D78(&v3);
  return sub_1000558F4(&v4);
}

void sub_100D0E620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_100D0E63C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  return sub_100328018(a1 + 64, a2 + 64);
}

void sub_100D0E6A4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D0E6C0(uint64_t a1)
{
  sub_10030C800((void *)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

uint64_t sub_100D0E710(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  uint64_t result = sub_100328018(a1 + 64, a2 + 64);
  uint64_t v6 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D0E790(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D0E7AC(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 64);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10030C800(v2);
  if (*(char *)(a1 + 63) < 0)
  {
    long long v4 = *(void **)(a1 + 40);
    operator delete(v4);
  }
}

unsigned char *sub_100D0E80C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  sub_100328018(a1 + 64, a2 + 64);
  uint64_t result = (unsigned char *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  long long v6 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)uint64_t result = v6;
  return result;
}

void sub_100D0E8A4(_Unwind_Exception *a1)
{
  sub_10030C800(v3);
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(a1);
}

void sub_100D0E8D0(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 64);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  sub_10030C800(v2);
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    operator delete(v3);
  }
}

unsigned char *sub_100D0E934(uint64_t a1, uint64_t a2)
{
  sub_100328018(a1 + 40, a2 + 40);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 72), *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v4;
  }
  uint64_t result = (unsigned char *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  long long v6 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)uint64_t result = v6;
  return result;
}

void sub_100D0E9CC(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 95) < 0) {
    operator delete(*v3);
  }
  sub_10030C800(v1);
  _Unwind_Resume(a1);
}

void *sub_100D0E9F8(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }

  return sub_10030C800((void *)(a1 + 40));
}

void sub_100D0EA4C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      if (a1[4]) {
        (*(void (**)(void))(a1[6] + 16))();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100D0EAD4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100D0EAE8(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100D0EB34(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D0EB88(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      if (a1[4]) {
        (*(void (**)(void))(a1[6] + 16))();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100D0EC10(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100D0EC24(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100D0EC70(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_100D0ECC4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[3];
  if (v3)
  {
    dispatch_group_leave(v3);
    long long v4 = a1[3];
    if (v4) {
      dispatch_release(v4);
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

void sub_100D0ED18(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 256);
  if (v3)
  {
    if (*(unsigned char *)(a2 + 784))
    {
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
      if (v5)
      {
        long long v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          uint64_t v7 = *(void *)(a1 + 112);
          if (v7)
          {
            CFTypeRef cf = 0;
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              CFTypeRef v9 = cf;
              CFTypeRef cf = Mutable;
              *(void *)long long buf = v9;
              sub_10005717C((const void **)buf);
            }
            CFTypeRef v21 = cf;
            if (cf) {
              CFRetain(cf);
            }
            if (!*(unsigned char *)(a2 + 744)) {
              sub_10016C840();
            }
            BOOL v10 = sub_100DDCEB8((CFMutableDictionaryRef *)&v21, a2 + 400);
            sub_10005717C(&v21);
            if (v10)
            {
              CFTypeRef v20 = 0;
              (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 128) + 128))(&v20);
              if (*(char *)(a2 + 55) < 0)
              {
                sub_10004FC84(__dst, *(void **)(a2 + 32), *(void *)(a2 + 40));
              }
              else
              {
                *(_OWORD *)std::string __dst = *(_OWORD *)(a2 + 32);
                uint64_t v18 = *(void *)(a2 + 48);
              }
              if (SHIBYTE(v18) < 0)
              {
                sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)__dst;
                uint64_t v25 = v18;
              }
              uint64_t v23 = 0;
              if (SHIBYTE(v25) < 0)
              {
                sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
              }
              else
              {
                *(_OWORD *)long long buf = *(_OWORD *)__p;
                uint64_t v27 = v25;
              }
              uint64_t v28 = 0;
              if (ctu::cf::convert_copy())
              {
                uint64_t v14 = v23;
                uint64_t v23 = v28;
                uint64_t v29 = v14;
                sub_1000558F4(&v29);
              }
              if (SHIBYTE(v27) < 0) {
                operator delete(*(void **)buf);
              }
              char v19 = v23;
              uint64_t v23 = 0;
              sub_1000558F4(&v23);
              if (SHIBYTE(v25) < 0) {
                operator delete(__p[0]);
              }
              sub_10004EFE4(&v16, &cf);
              CFTypeRef v15 = v20;
              if (v20) {
                CFRetain(v20);
              }
              (*(void (**)(uint64_t, const void **, const void **, CFTypeRef *))(*(void *)v7 + 72))(v7, &v19, &v16, &v15);
              sub_1000558F4(&v15);
              sub_100057D78(&v16);
              sub_1000558F4(&v19);
              if (SHIBYTE(v18) < 0) {
                operator delete(__dst[0]);
              }
              sub_1000558F4(&v20);
            }
            else
            {
              char v13 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to generate post data", buf, 2u);
              }
              (*(void (**)(void))(**(void **)(a1 + 256) + 168))(*(void *)(a1 + 256));
            }
            sub_10005717C(&cf);
LABEL_44:
            sub_10004D2C8(v6);
            return;
          }
        }
      }
      else
      {
        long long v6 = 0;
      }
      (*(void (**)(void))(**(void **)(a1 + 256) + 168))(*(void *)(a1 + 256));
      if (!v6) {
        return;
      }
      goto LABEL_44;
    }
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Missing websheet info, aborting", buf, 2u);
      uint64_t v3 = *(void *)(a1 + 256);
    }
    (*(void (**)(uint64_t))(*(void *)v3 + 168))(v3);
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No operation, nothing to do", buf, 2u);
    }
  }
}

void sub_100D0F100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, const void *a19, __int16 a20,char a21,char a22,int a23,const void *a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1000558F4(&a19);
  sub_10005717C(&a24);
  sub_10004D2C8(v31);
  _Unwind_Resume(a1);
}

void sub_100D0F1CC(uint64_t a1, uint64_t a2)
{
}

void sub_100D0F1D4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void sub_100D0F1EC(uint64_t a1, char a2, long long *a3, uint64_t a4)
{
  v8[0] = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v9, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    uint64_t v10 = *((void *)a3 + 2);
  }
  v8[0] = 1;
  v7[0] = 0;
  sub_100346768(v7, a4);
  (*(void (**)(uint64_t, BOOL, char *, unsigned char *))(a1 + 16))(a1, a2 != 0, v8, v7);
  sub_100347114(v7);
  if (v8[0])
  {
    if (SHIBYTE(v10) < 0) {
      operator delete((void *)v9);
    }
  }
}

void sub_100D0F2D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_100D0F314(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void sub_100D0F32C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "a pending websheet did launch callback is being failed", v5, 2u);
  }
  uint64_t v4 = *a2;
  char v6 = 0;
  v5[0] = 0;
  (*(void (**)(uint64_t))(v4 + 16))(v4);
  sub_100347114(v5);
  if (v6)
  {
    if (v8 < 0) {
      operator delete(v7);
    }
  }
}

void sub_100D0F40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_100347114(&a9);
  if (*(unsigned char *)(v9 - 72))
  {
    if (*(char *)(v9 - 41) < 0) {
      operator delete(*(void **)(v9 - 64));
    }
  }
  _Unwind_Resume(a1);
}

void sub_100D0F438(uint64_t a1, uint64_t *a2)
{
}

const void **sub_100D0F440(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I a pending get plan callback is present, get plans", buf, 2u);
  }
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 160) + 104))(&v6);
  sub_100D0F50C(*a2, &v6, 0);
  return sub_100044D00(&v6);
}

void sub_100D0F4F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100D0F50C(uint64_t a1, const void **a2, unsigned __int8 a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  (*(void (**)(uint64_t, const void **, void))(a1 + 16))(a1, &v4, a3);
  return sub_100044D00(&v4);
}

void sub_100D0F558(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100D0F56C(uint64_t a1, uint64_t *a2)
{
  return sub_100D0F440(a1 - 64, a2);
}

uint64_t sub_100D0F574(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)uint64_t v14 = cellplan::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I provisioning operation result: %s", buf, 0xCu);
  }
  uint64_t v3 = *(const void **)(a1 + 1080);
  *(void *)(a1 + 1080) = 0;
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 264);
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 280);
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 160);
  int v7 = *(_DWORD *)(a1 + 1040);
  uint64_t v10 = 0;
  long long v9 = 0uLL;
  v11[0] = 0;
  char v12 = 0;
  sub_1003DB514((uint64_t)buf, v7, &v9, (uint64_t)v11, 0);
  (*(void (**)(uint64_t, void, uint8_t *))(*(void *)v6 + 96))(v6, 0, buf);
  if (v16[216]) {
    sub_1000C584C((uint64_t)v16);
  }
  if (v15 < 0) {
    operator delete(*(void **)&v14[4]);
  }
  if (v12) {
    sub_1000C584C((uint64_t)v11);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
}

void sub_100D0F720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,int a44,__int16 a45,char a46,char a47)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D0F774(uint64_t a1)
{
  return sub_100D0F574(a1 - 64);
}

void sub_100D0F77C(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 1072))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315138;
      uint64_t v6 = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Overwriting plan provisioning error: %s", (uint8_t *)&v5, 0xCu);
    }
  }
  *(_DWORD *)(a1 + 1076) = a2;
  *(unsigned char *)(a1 + 1072) = 1;
}

void sub_100D0F844(uint64_t a1, int a2)
{
}

void sub_100D0F84C(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 1072))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Overwriting plan provisioning error: %s", buf, 0xCu);
    }
  }
  *(_DWORD *)(a1 + 1076) = a2;
  *(unsigned char *)(a1 + 1072) = 1;
  if (a2 == 5)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device not reachable - do not bother displaying notification", buf, 2u);
    }
  }
  else
  {
    *(_OWORD *)long long buf = 0uLL;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 64))(buf);
    if (*(void *)buf) {
      (*(void (**)(void))(**(void **)buf + 80))();
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
}

void sub_100D0FA08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D0FA28(uint64_t a1, int a2)
{
}

uint64_t sub_100D0FA30(uint64_t a1)
{
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v17 = 0u;
  uint64_t v2 = 1368;
  if (*(unsigned char *)(a1 + 1224))
  {
    uint64_t v3 = a1 + 1368;
  }
  else
  {
    uint64_t v2 = 328;
    uint64_t v3 = a1 + 328;
  }
  if (*(char *)(v3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + v2), *(void *)(v3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    *(void *)&long long v17 = *(void *)(v3 + 16);
  }
  uint64_t v4 = *(void *)(v3 + 32);
  *((void *)&v17 + 1) = *(void *)(v3 + 24);
  long long v18 = 0uLL;
  *(void *)&long long v19 = 0;
  sub_100311ED8(&v18, v4, *(void *)(v3 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v3 + 40) - v4) >> 3));
  *((void *)&v19 + 1) = *(void *)(v3 + 56);
  LODWORD(v20) = *(_DWORD *)(v3 + 64);
  if (*(char *)(a1 + 999) < 0)
  {
    if (!*(void *)(a1 + 984))
    {
LABEL_33:
      uint64_t v14 = 0;
      goto LABEL_34;
    }
  }
  else if (!*(unsigned char *)(a1 + 999))
  {
    goto LABEL_33;
  }
  if ((void)v18 == *((void *)&v18 + 1)) {
    goto LABEL_33;
  }
  if (!*(unsigned char *)(v18 + 80)) {
    goto LABEL_33;
  }
  uint64_t v5 = *(void *)(v18 + 56);
  uint64_t v6 = *(void *)(v18 + 64);
  if (v5 == v6) {
    goto LABEL_33;
  }
  while (1)
  {
    uint64_t v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    *(_OWORD *)__s1 = 0u;
    long long v23 = 0u;
    long long v21 = 0u;
    sub_1000C5AB4((uint64_t)&v21, v5);
    uint64_t v7 = BYTE7(v23);
    if ((SBYTE7(v23) & 0x80u) == 0) {
      char v8 = (void *)BYTE7(v23);
    }
    else {
      char v8 = __s1[1];
    }
    long long v9 = (void *)*(unsigned __int8 *)(a1 + 999);
    int v10 = (char)v9;
    if ((char)v9 < 0) {
      long long v9 = *(void **)(a1 + 984);
    }
    if (v8 != v9) {
      goto LABEL_29;
    }
    uint64_t v11 = v10 >= 0 ? (unsigned __int8 *)(a1 + 976) : *(unsigned __int8 **)(a1 + 976);
    if ((BYTE7(v23) & 0x80) == 0) {
      break;
    }
    int v13 = memcmp(__s1[0], v11, (size_t)__s1[1]);
    sub_1000C584C((uint64_t)&v21);
    if (!v13) {
      goto LABEL_38;
    }
LABEL_31:
    uint64_t v14 = 0;
    v5 += 216;
    if (v5 == v6) {
      goto LABEL_34;
    }
  }
  if (BYTE7(v23))
  {
    char v12 = __s1;
    while (*(unsigned __int8 *)v12 == *v11)
    {
      char v12 = (void **)((char *)v12 + 1);
      ++v11;
      if (!--v7) {
        goto LABEL_37;
      }
    }
LABEL_29:
    sub_1000C584C((uint64_t)&v21);
    goto LABEL_31;
  }
LABEL_37:
  sub_1000C584C((uint64_t)&v21);
LABEL_38:
  uint64_t v14 = 1;
LABEL_34:
  *(void *)&long long v21 = &v18;
  sub_1000C56F4((void ***)&v21);
  if (SBYTE7(v17) < 0) {
    operator delete(__p[0]);
  }
  return v14;
}

void sub_100D0FC94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100D0FCC8(uint64_t a1)
{
  return sub_100D0FA30(a1 - 64);
}

uint64_t sub_100D0FCD0(uint64_t a1)
{
  uint64_t v1 = a1 + 1368;
  if (!*(unsigned char *)(a1 + 1224)) {
    uint64_t v1 = a1 + 328;
  }
  uint64_t v2 = *(void *)(v1 + 32);
  if (*(void *)(v1 + 40) != v2)
  {
    if (*(unsigned char *)(v1 + 24))
    {
      long long v55 = *(_OWORD *)(v2 + 16);
      if (*(void *)(a1 + 256))
      {
        (***(void (****)(long long *__return_ptr))(a1 + 128))(&v40);
        long long v44 = v40;
        long long v40 = 0uLL;
        subscriber::makeSimSlotRange();
        if (*((void *)&v44 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v44 + 1));
        }
        if (*((void *)&v40 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v40 + 1));
        }
        uint64_t v5 = v37;
        uint64_t v4 = v38;
        if (v37 != v38)
        {
          uint64_t v6 = v39;
          while ((v39(*v5) & 1) == 0)
          {
            if (++v5 == v38)
            {
              uint64_t v5 = v38;
              break;
            }
          }
          uint64_t v7 = v38;
          if (v5 != v38)
          {
            char v8 = 1;
            while (1)
            {
              uint64_t v9 = *v5;
              uint64_t v35 = 0;
              uint64_t v36 = 0;
              sub_100324590(&v35);
              (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 128) + 640))(&v40);
              (*(void (**)(long long *__return_ptr))(*(void *)v40 + 48))(&v44);
              int v10 = v35;
              if (SHIBYTE(v35->__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v35->__r_.__value_.__l.__data_);
              }
              long long v11 = v44;
              v10->__r_.__value_.__r.__words[2] = v45;
              *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
              BYTE7(v45) = 0;
              LOBYTE(v44) = 0;
              if (*((void *)&v40 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v40 + 1));
              }
              long long v53 = 0u;
              long long v54 = 0u;
              long long v51 = 0u;
              long long v52 = 0u;
              long long v49 = 0u;
              long long v50 = 0u;
              long long v47 = 0u;
              long long v48 = 0u;
              long long v45 = 0u;
              long long v46 = 0u;
              long long v44 = 0u;
              (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 160) + 256))(&v44);
              if ((_BYTE)v44) {
                goto LABEL_22;
              }
              (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 128) + 640))(&v40);
              int v14 = (*(uint64_t (**)(void, uint64_t))(*(void *)v40 + 8))(v40, v9);
              if (*((void *)&v40 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v40 + 1));
              }
              if (!v14) {
                goto LABEL_54;
              }
              if ((_BYTE)v44)
              {
LABEL_22:
                uint64_t v12 = HIBYTE(v51);
                if (v51 < 0) {
                  uint64_t v12 = v51;
                }
                int v13 = v35;
                if (v12)
                {
                  std::string::operator=(v35, (const std::string *)((char *)&v50 + 8));
                  int v13 = v35;
                  if (!(_BYTE)v44) {
                    goto LABEL_49;
                  }
                }
                if (SBYTE7(v48) < 0)
                {
                  sub_10004FC84(&__p, (void *)v47, *((unint64_t *)&v47 + 1));
                }
                else
                {
                  long long __p = v47;
                  uint64_t v32 = v48;
                }
                sub_100D00EE0((uint64_t)&v33, (uint64_t *)&__p);
                std::string::size_type v15 = v13[4].__r_.__value_.__r.__words[2];
                std::string::size_type size = v13[4].__r_.__value_.__l.__size_;
                if (size >= v15)
                {
                  std::string::pointer data = v13[4].__r_.__value_.__l.__data_;
                  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(size - (void)data) >> 3);
                  unint64_t v20 = v19 + 1;
                  if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    sub_1000D8578();
                  }
                  unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)data) >> 3);
                  if (2 * v21 > v20) {
                    unint64_t v20 = 2 * v21;
                  }
                  if (v21 >= 0x555555555555555) {
                    unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v22 = v20;
                  }
                  char v43 = &v13[4].__r_.__value_.__s.__data_[16];
                  if (v22) {
                    long long v23 = (char *)sub_10004812C((uint64_t)&v13[4].__r_.__value_.__r.__words[2], v22);
                  }
                  else {
                    long long v23 = 0;
                  }
                  long long v24 = &v23[24 * v19];
                  *(void *)&long long v40 = v23;
                  *((void *)&v40 + 1) = v24;
                  BOOL v42 = &v23[24 * v22];
                  *(_OWORD *)long long v24 = v33;
                  *((void *)v24 + 2) = v34;
                  long long v33 = 0uLL;
                  uint64_t v34 = 0;
                  CFTypeRef v41 = v24 + 24;
                  sub_100048204((uint64_t *)&v13[4], &v40);
                  std::string::size_type v17 = v13[4].__r_.__value_.__l.__size_;
                  sub_100048174((uint64_t)&v40);
                }
                else
                {
                  *(_OWORD *)std::string::size_type size = v33;
                  *(void *)(size + 16) = v34;
                  std::string::size_type v17 = size + 24;
                  v13[4].__r_.__value_.__l.__size_ = size + 24;
                }
                v13[4].__r_.__value_.__l.__size_ = v17;
                if (SHIBYTE(v32) < 0) {
                  operator delete((void *)__p);
                }
              }
              int v13 = v35;
LABEL_49:
              uint64_t v25 = *(void *)(a1 + 256);
              long long v29 = v13;
              long long v30 = v36;
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v28[0] = 0;
              v28[176] = 0;
              (*(void (**)(uint64_t, std::string **, unsigned char *))(*(void *)v25 + 192))(v25, &v29, v28);
              sub_10030AEBC((uint64_t)v28);
              if (v30) {
                sub_10004D2C8(v30);
              }
              char v8 = 0;
LABEL_54:
              sub_1003DD394(&v44);
              if (v36) {
                sub_10004D2C8(v36);
              }
              long long v26 = v5 + 1;
              uint64_t v5 = v4;
              if (v26 != v4)
              {
                uint64_t v5 = v26;
                while ((v6(*v5) & 1) == 0)
                {
                  if (++v5 == v4)
                  {
                    uint64_t v5 = v4;
                    break;
                  }
                }
              }
              if (v5 == v7) {
                return v8 & 1;
              }
            }
          }
        }
      }
    }
  }
  char v8 = 1;
  return v8 & 1;
}

void sub_100D10200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,std::__shared_weak_count *a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,std::__shared_weak_count *a60)
{
  if (a60) {
    sub_10004D2C8(a60);
  }
  if (a54) {
    sub_10004D2C8(a54);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D102DC(uint64_t a1)
{
  return sub_100D0FCD0(a1 - 64);
}

uint64_t sub_100D102E4(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v5);
  uint64_t v4 = 0;
  uint64_t v2 = (*(uint64_t (**)(uint64_t, const void **, void))(*(void *)v5 + 16))(v5, &v4, *(unsigned int *)(a1 + 1040));
  sub_100057D78(&v4);
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v2;
}

void sub_100D10390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D103B0(uint64_t a1)
{
  return sub_100D102E4(a1 - 64);
}

uint64_t sub_100D103B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 208) + 136))();
}

uint64_t sub_100D103E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 136))();
}

void sub_100D10408(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23)) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 72) = 0;
      *(unsigned char *)(a3 + 80) = 0;
      *(unsigned char *)(a3 + 216) = 0;
      *(unsigned char *)(a3 + 224) = 1;
      return;
    }
    LOWORD(v30) = 0;
    uint64_t v6 = "No valid device Id, not fetching from dB";
LABEL_52:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v30, 2u);
    goto LABEL_13;
  }
  if (!*(void *)(a2 + 8)) {
    goto LABEL_10;
  }
LABEL_3:
  if (!*(void *)(a1 + 128))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    LOWORD(v30) = 0;
    uint64_t v6 = "fSettings is not initialized, not fetching from dB";
    goto LABEL_52;
  }
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  memset(v40, 0, sizeof(v40));
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 176) + 16))(&v30);
  if ((_BYTE)v44)
  {
    LODWORD(v43) = 2;
    if ((_BYTE)v30) {
      (*(void (**)(void, uint64_t, char *))(**(void **)(a1 + 160) + 88))(*(void *)(a1 + 160), 1, (char *)&v30 + 8);
    }
    if (SHIBYTE(v40[3]) < 0)
    {
      sub_10004FC84(buf, (void *)v40[1], v40[2]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)&v40[1];
      uint64_t v14 = v40[3];
    }
    uint64_t v15 = v41;
    long long v16 = 0uLL;
    uint64_t v17 = 0;
    sub_100311ED8(&v16, *((uint64_t *)&v41 + 1), v42, 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v42 - *((void *)&v41 + 1)) >> 3));
    uint64_t v18 = v43;
    int v19 = DWORD2(v43);
    sub_100313228((char *)v20, &v32);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    uint64_t v8 = v14;
    uint64_t v9 = v15;
    uint64_t v14 = 0;
    memset(buf, 0, sizeof(buf));
    *(void *)(a3 + 16) = v8;
    *(void *)(a3 + 24) = v9;
    *(_OWORD *)(a3 + 32) = v16;
    *(_DWORD *)(a3 + 64) = v19;
    uint64_t v10 = v17;
    uint64_t v17 = 0;
    long long v16 = 0uLL;
    uint64_t v11 = v18;
    *(void *)(a3 + 48) = v10;
    *(void *)(a3 + 56) = v11;
    *(unsigned char *)(a3 + 72) = 1;
    sub_100313228((char *)(a3 + 80), (long long *)v20);
    *(unsigned char *)(a3 + 216) = 1;
    *(unsigned char *)(a3 + 224) = 1;
    if (v29 < 0) {
      operator delete(__p);
    }
    if (v25)
    {
      if (v27 < 0) {
        operator delete(v26);
      }
      char v25 = 0;
    }
    if (v22)
    {
      if (v24 < 0) {
        operator delete(v23);
      }
      char v22 = 0;
    }
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    uint64_t v12 = (void **)&v16;
    sub_1000C56F4(&v12);
    if (SHIBYTE(v14) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No Record found in DB, not fetching from dB", buf, 2u);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 72) = 0;
    *(unsigned char *)(a3 + 80) = 0;
    *(unsigned char *)(a3 + 216) = 0;
    *(unsigned char *)(a3 + 224) = 1;
  }
  if ((_BYTE)v44)
  {
    *(void *)long long buf = (char *)&v41 + 8;
    sub_1000C56F4((void ***)buf);
    if (SHIBYTE(v40[3]) < 0) {
      operator delete((void *)v40[1]);
    }
    if (SBYTE7(v39) < 0) {
      operator delete((void *)v38);
    }
    if (BYTE8(v35))
    {
      if (SBYTE7(v37) < 0) {
        operator delete((void *)v36);
      }
      BYTE8(v35) = 0;
    }
    if (BYTE8(v33))
    {
      if (SBYTE7(v35) < 0) {
        operator delete((void *)v34);
      }
      BYTE8(v33) = 0;
    }
    if (SBYTE7(v33) < 0) {
      operator delete((void *)v32);
    }
    if ((_BYTE)v30)
    {
      if (SHIBYTE(v31) < 0) {
        operator delete(*((void **)&v30 + 1));
      }
    }
  }
}

void sub_100D1080C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a67) {
    sub_1000C5634((uint64_t)&a37);
  }
  _Unwind_Resume(a1);
}

void sub_100D10874(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_100D1087C(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  *(_OWORD *)long long __p = 0u;
  memset(v7, 0, sizeof(v7));
  long long v5 = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(&v7[1], *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7[1] = *(_OWORD *)a2;
    v7[3] = *(void **)(a2 + 16);
  }
  LOWORD(v7[4]) = 0;
  memset(&v7[5], 0, 48);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&v7[11], *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)&v7[11] = *(_OWORD *)(a2 + 24);
    v7[13] = *(void **)(a2 + 40);
  }
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(__p, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a2 + 48);
    uint64_t v9 = *(void *)(a2 + 64);
  }
  (*(void (**)(void, long long *))(**(void **)(a1 + 176) + 72))(*(void *)(a1 + 176), &v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7[13]) < 0) {
    operator delete(v7[11]);
  }
  if (SHIBYTE(v7[10]) < 0) {
    operator delete(v7[8]);
  }
  if (SHIBYTE(v7[7]) < 0) {
    operator delete(v7[5]);
  }
  if (SHIBYTE(v7[3]) < 0) {
    operator delete(v7[1]);
  }
  if (SHIBYTE(v7[0]) < 0) {
    operator delete(v6[0]);
  }
  return 1;
}

void sub_100D10A20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D10A9C(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_100D10ABC()
{
  return 0;
}

uint64_t sub_100D10AC4()
{
  return 0;
}

uint64_t sub_100D10ACC()
{
  return 0;
}

uint64_t sub_100D10AD4()
{
  return 0;
}

uint64_t sub_100D10ADC(uint64_t a1)
{
  return 1;
}

uint64_t sub_100D10B50(uint64_t a1)
{
  return 1;
}

uint64_t sub_100D10BC4(uint64_t a1, ctu *a2, const std::string **a3)
{
  (*(void (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160));
  if (*a3 == a3[1] || *(void *)(a1 + 256)) {
    return 1;
  }
  (***(void (****)(unsigned char *__return_ptr))(a1 + 128))(__str);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)__str);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v93.__r_.__value_.__r.__words[0] = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v93);
  if (v13)
  {
    uint64_t v14 = v13[3];
    uint64_t v15 = (std::__shared_weak_count *)v13[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v16 = 1;
LABEL_11:
  if (*(void *)&__str[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&__str[8]);
  }
  if (v14)
  {
    *(_OWORD *)long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    memset(__str, 0, sizeof(__str));
    if (SHIBYTE((*a3)[3].__r_.__value_.__r.__words[2]) < 0) {
      std::string::size_type size = (*a3)[3].__r_.__value_.__l.__size_;
    }
    else {
      std::string::size_type size = HIBYTE((*a3)[3].__r_.__value_.__r.__words[2]);
    }
    if (size) {
      uint64_t v18 = *a3 + 3;
    }
    else {
      uint64_t v18 = *a3;
    }
    long long v75 = v15;
    std::string::operator=((std::string *)__str, v18);
    if (SHIBYTE(v85) < 0)
    {
      *(void *)&long long v85 = 16;
      int v19 = *(char **)&__str[24];
    }
    else
    {
      int v19 = &__str[24];
      HIBYTE(v85) = 16;
    }
    strcpy(v19, "com.apple.Bridge");
    LOBYTE(v86) = 1;
    uint64_t v74 = kCBMessageLocalizationTable;
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v14 + 40))(&buf, v14);
    v93.__r_.__value_.__r.__words[0] = *((void *)&v86 + 1);
    *((void *)&v86 + 1) = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
    long long v83 = 0;
    uint64_t v20 = *(void *)(a1 + 896);
    uint64_t v21 = *(void *)(a1 + 904);
    ctu::hex((uint64_t *)&__p, a2, (const void *)0x10, v22);
    uint64_t v23 = v82;
    if (v20 != v21)
    {
      uint64_t v73 = v14;
      char v24 = v16;
      long long v26 = __p;
      size_t v25 = v81;
      if ((v82 & 0x80u) == 0) {
        size_t v27 = v82;
      }
      else {
        size_t v27 = v81;
      }
      do
      {
        uint64_t v28 = *(unsigned __int8 *)(v20 + 55);
        int v29 = (char)v28;
        if ((v28 & 0x80u) != 0) {
          uint64_t v28 = *(void *)(v20 + 40);
        }
        if (v27 == v28)
        {
          if (v29 >= 0) {
            long long v30 = (unsigned __int8 *)(v20 + 32);
          }
          else {
            long long v30 = *(unsigned __int8 **)(v20 + 32);
          }
          if ((v23 & 0x80) != 0)
          {
            if (!memcmp(v26, v30, v25))
            {
              char v16 = v24;
              uint64_t v14 = v73;
              goto LABEL_44;
            }
          }
          else
          {
            if (!v23)
            {
              char v16 = v24;
              uint64_t v14 = v73;
              goto LABEL_45;
            }
            p_p = &__p;
            uint64_t v32 = v23;
            while (*(unsigned __int8 *)p_p == *v30)
            {
              p_p = (void **)((char *)p_p + 1);
              ++v30;
              if (!--v32) {
                goto LABEL_42;
              }
            }
          }
        }
        v20 += 184;
      }
      while (v20 != v21);
      uint64_t v20 = v21;
LABEL_42:
      char v16 = v24;
      uint64_t v14 = v73;
    }
    if ((v23 & 0x80) != 0) {
LABEL_44:
    }
      operator delete(__p);
LABEL_45:
    if (v20 == *(void *)(a1 + 904))
    {
      long long v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex((uint64_t *)&v93, a2, (const void *)0x10, v34);
        long long v36 = (v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v93
            : (std::string *)v93.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Cannot find device for (%s)", (uint8_t *)&buf, 0xCu);
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v93.__r_.__value_.__l.__data_);
        }
      }
      long long v91 = 0;
      buf.__r_.__value_.__r.__words[0] = 0;
      CFAllocatorRef v37 = kCFAllocatorDefault;
      if (ctu::cf::convert_copy((ctu::cf *)&buf, (const __CFString **)"Apple Watch", (const char *)0x8000100, kCFAllocatorDefault, v35))
      {
        std::string::size_type v38 = (std::string::size_type)v91;
        long long v91 = (const void *)buf.__r_.__value_.__r.__words[0];
        v93.__r_.__value_.__r.__words[0] = v38;
        sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      }
      long long v90 = v91;
      long long v91 = 0;
      sub_1000558F4(&v91);
      v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
      long long v83 = v90;
      long long v90 = 0;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      sub_1000558F4(&v90);
    }
    else
    {
      if (*(char *)(v20 + 127) < 0) {
        sub_10004FC84(&__dst, *(void **)(v20 + 104), *(void *)(v20 + 112));
      }
      else {
        std::string __dst = *(std::string *)(v20 + 104);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = __dst;
      }
      char v89 = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v93, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string v93 = buf;
      }
      long long v90 = 0;
      CFAllocatorRef v37 = kCFAllocatorDefault;
      if (ctu::cf::convert_copy())
      {
        long long v39 = v89;
        char v89 = v90;
        long long v91 = v39;
        sub_1000558F4(&v91);
      }
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      long long v79 = v89;
      char v89 = 0;
      sub_1000558F4(&v89);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
      long long v83 = v79;
      long long v79 = 0;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      sub_1000558F4(&v79);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    if (v20 == *(void *)(a1 + 904))
    {
      long long v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex((uint64_t *)&v93, a2, (const void *)0x10, v41);
        long long v43 = (v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v93
            : (std::string *)v93.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v43;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Cannot find device for (%s)", (uint8_t *)&buf, 0xCu);
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v93.__r_.__value_.__l.__data_);
        }
      }
      long long v91 = 0;
      buf.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy((ctu::cf *)&buf, (const __CFString **)"Apple Watch", (const char *)0x8000100, v37, v42))
      {
        std::string::size_type v44 = (std::string::size_type)v91;
        long long v91 = (const void *)buf.__r_.__value_.__r.__words[0];
        v93.__r_.__value_.__r.__words[0] = v44;
        sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      }
      long long v90 = v91;
      long long v91 = 0;
      sub_1000558F4(&v91);
      v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
      long long v83 = v90;
      long long v90 = 0;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      sub_1000558F4(&v90);
    }
    else
    {
      if (*(char *)(v20 + 127) < 0) {
        sub_10004FC84(&v77, *(void **)(v20 + 104), *(void *)(v20 + 112));
      }
      else {
        std::string v77 = *(std::string *)(v20 + 104);
      }
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, v77.__r_.__value_.__l.__data_, v77.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = v77;
      }
      char v89 = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v93, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string v93 = buf;
      }
      long long v90 = 0;
      if (ctu::cf::convert_copy())
      {
        long long v45 = v89;
        char v89 = v90;
        long long v91 = v45;
        sub_1000558F4(&v91);
      }
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      long long v79 = v89;
      char v89 = 0;
      sub_1000558F4(&v89);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
      long long v83 = v79;
      long long v79 = 0;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      sub_1000558F4(&v79);
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v77.__r_.__value_.__l.__data_);
      }
    }
    p_std::string::pointer data = (void **)&(*a3)[2].__r_.__value_.__l.__data_;
    if (SHIBYTE((*a3)[2].__r_.__value_.__r.__words[2]) < 0)
    {
      unint64_t v47 = (*a3)[2].__r_.__value_.__l.__size_;
      if (v47)
      {
        long long v79 = 0;
        sub_10004FC84(&v76, *p_data, v47);
        goto LABEL_104;
      }
    }
    else if (*((unsigned char *)&(*a3)[2].__r_.__value_.__s + 23))
    {
      long long v79 = 0;
      std::string v76 = *(std::string *)p_data;
LABEL_104:
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, v76.__r_.__value_.__l.__data_, v76.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = v76;
      }
      char v89 = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v93, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string v93 = buf;
      }
      long long v90 = 0;
      if (ctu::cf::convert_copy())
      {
        long long v51 = v89;
        char v89 = v90;
        long long v91 = v51;
        sub_1000558F4(&v91);
      }
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      long long v79 = v89;
      char v89 = 0;
      sub_1000558F4(&v89);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      buf.__r_.__value_.__r.__words[0] = 0;
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&buf, v14, v74, @"CELLULAR_PLAN_PENDING_FOR_INSTALL_MESSAGE_PHONE_%@_%@", @"CELLULAR_PLAN_PENDING_FOR_INSTALL_MESSAGE_PHONE_%@_%@");
      CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(v37, 0, @"%@%@", (CFStringRef)buf.__r_.__value_.__l.__data_, 0, v79, v83);
      long long v53 = v87[0];
      v87[0] = (void *)StringWithValidatedFormat;
      v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v53;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
      p_std::string buf = (std::string *)&v79;
      goto LABEL_120;
    }
    buf.__r_.__value_.__r.__words[0] = 0;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v14 + 40))(&buf, v14, v74, @"CELLULAR_PLAN_PENDING_FOR_INSTALL_MESSAGE_PHONE_NO_CARRIER_%@", @"CELLULAR_PLAN_PENDING_FOR_INSTALL_MESSAGE_PHONE_NO_CARRIER_%@");
    CFStringRef v48 = CFStringCreateStringWithValidatedFormat(v37, 0, @"%@", (CFStringRef)buf.__r_.__value_.__l.__data_, 0, v83);
    long long v49 = v87[0];
    v87[0] = (void *)v48;
    v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
    sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
    p_std::string buf = &buf;
LABEL_120:
    sub_1000558F4((const void **)&p_buf->__r_.__value_.__l.__data_);
    ctu::hex((uint64_t *)&v93, a2, (const void *)0x10, v54);
    long long v55 = std::string::insert(&v93, 0, "bridge:root=CELLULAR_ID&csn=", 0x1CuLL);
    uint64_t v56 = (void *)v55->__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = v55->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v55->__r_.__value_.__r.__words[1] + 7);
    char v57 = HIBYTE(v55->__r_.__value_.__r.__words[2]);
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v88) < 0) {
      operator delete(v87[1]);
    }
    v87[1] = v56;
    *(void *)&long long v88 = buf.__r_.__value_.__r.__words[0];
    *(void *)((char *)&v88 + 7) = *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 7);
    HIBYTE(v88) = v57;
    if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v93.__r_.__value_.__l.__data_);
    }
    for (uint64_t i = *(void *)(a1 + 896); i != *(void *)(a1 + 904); i += 184)
    {
      if (*(unsigned char *)(i + 177) == 1)
      {
        CFTypeRef v70 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
        {
          long long v71 = __str;
          if (__str[23] < 0) {
            long long v71 = *(unsigned char **)__str;
          }
          LODWORD(v93.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v93.__r_.__value_.__r.__words + 4) = (std::string::size_type)v71;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Delaying notification (%s)", (uint8_t *)&v93, 0xCu);
        }
        sub_100D119E4((void *)(a1 + 1112), (std::string *)__str);
        goto LABEL_147;
      }
    }
    (***(void (****)(std::string *__return_ptr))(a1 + 128))(&v93);
    uint64_t v60 = (std::mutex *)Registry::getServiceMap(v59, (Registry *)v93.__r_.__value_.__l.__data_);
    long long v61 = v60;
    if ((v62 & 0x8000000000000000) != 0)
    {
      uint64_t v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v64 = 5381;
      do
      {
        std::string::size_type v62 = v64;
        unsigned int v65 = *v63++;
        uint64_t v64 = (33 * v64) ^ v65;
      }
      while (v65);
    }
    std::mutex::lock(v60);
    buf.__r_.__value_.__r.__words[0] = v62;
    std::string::size_type v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)&buf);
    if (v66)
    {
      uint64_t v68 = v66[3];
      uint64_t v67 = (std::__shared_weak_count *)v66[4];
      if (v67)
      {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v61);
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v67);
        char v69 = 0;
        goto LABEL_141;
      }
    }
    else
    {
      uint64_t v68 = 0;
    }
    std::mutex::unlock(v61);
    uint64_t v67 = 0;
    char v69 = 1;
LABEL_141:
    if (v93.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v93.__r_.__value_.__l.__size_);
    }
    if (v68) {
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v68 + 16))(v68, __str);
    }
    if ((v69 & 1) == 0) {
      sub_10004D2C8(v67);
    }
LABEL_147:
    sub_1000558F4(&v83);
    if (SHIBYTE(v88) < 0) {
      operator delete(v87[1]);
    }
    sub_1000558F4((const void **)v87);
    sub_1000558F4((const void **)&v86 + 1);
    uint64_t v15 = v75;
    if (SHIBYTE(v85) < 0) {
      operator delete(*(void **)&__str[24]);
    }
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  return 1;
}

void sub_100D11808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,const void *a39,__int16 a40,char a41,char a42)
{
  sub_1000558F4(&a39);
  sub_100D11A70((uint64_t)&a40);
  if ((v42 & 1) == 0) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_100D119A8()
{
  if (*(void *)(v0 - 120)) {
    JUMPOUT(0x100D119B4);
  }
  JUMPOUT(0x100D11984);
}

void sub_100D119CC()
{
}

void sub_100D119D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (!a32) {
    JUMPOUT(0x100D119A0);
  }
  JUMPOUT(0x100D1199CLL);
}

void *sub_100D119E4(void *__dst, std::string *__str)
{
  if (*((unsigned char *)__dst + 96))
  {
    std::string::operator=((std::string *)__dst, __str);
    std::string::operator=((std::string *)__dst + 1, __str + 1);
    *((unsigned char *)__dst + 48) = __str[2].__r_.__value_.__s.__data_[0];
    sub_100083EB8((const void **)__dst + 7, (const void **)&__str[2].__r_.__value_.__l.__size_);
    sub_100083EB8((const void **)__dst + 8, (const void **)&__str[2].__r_.__value_.__r.__words[2]);
    std::string::operator=((std::string *)__dst + 3, __str + 3);
  }
  else
  {
    sub_1004FDEC0((char *)__dst, (long long *)__str);
    *((unsigned char *)__dst + 96) = 1;
  }
  return __dst;
}

uint64_t sub_100D11A70(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_1000558F4((const void **)(a1 + 64));
  sub_1000558F4((const void **)(a1 + 56));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100D11AD4(uint64_t a1, ctu *a2, const std::string **a3)
{
  return 1;
}

uint64_t sub_100D11AF4(uint64_t a1, ctu *a2, uint64_t a3, int a4)
{
  (***(void (****)(unsigned char *__return_ptr))(a1 + 128))(__str);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)__str);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    char v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  char v16 = 0;
  char v19 = 1;
LABEL_9:
  if (*(void *)&__str[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&__str[8]);
  }
  if (!v17) {
    goto LABEL_104;
  }
  *(_OWORD *)char v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  memset(__str, 0, sizeof(__str));
  uint64_t v63 = 0;
  std::string::size_type v64 = 0;
  uint64_t v65 = 0;
  ctu::hex((uint64_t *)&v63, a2, (const void *)0x10, v18);
  if (SHIBYTE(v67) < 0)
  {
    *(void *)&long long v67 = 16;
    uint64_t v20 = *(char **)&__str[24];
  }
  else
  {
    uint64_t v20 = &__str[24];
    HIBYTE(v67) = 16;
  }
  strcpy(v20, "com.apple.Bridge");
  LOBYTE(v68) = 1;
  uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
  if ((v21 & 0x80u) != 0) {
    uint64_t v21 = *(void *)(a3 + 8);
  }
  if (v21) {
    unint64_t v22 = (const std::string *)a3;
  }
  else {
    unint64_t v22 = (const std::string *)&v63;
  }
  std::string::operator=((std::string *)__str, v22);
  CFStringRef v62 = 0;
  if (a4)
  {
    uint64_t v23 = kCBMessageLocalizationTable;
    (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v17 + 40))(&__dst, v17, kCBMessageLocalizationTable, @"CELLULAR_PLAN_SETUP_READY_FOR_USE_TITLE_PHONE_%@", 0);
    *(void *)std::string buf = v62;
    CFStringRef v62 = (const __CFString *)__dst;
    *(void *)&long long __dst = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&__dst);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v17 + 40))(&__dst, v17, v23, @"CELLULAR_PLAN_SETUP_READY_FOR_USE_MESSAGE_PHONE", 0);
  }
  else
  {
    uint64_t v24 = kCBMessageLocalizationTable;
    (*(void (**)(long long *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v17 + 40))(&__dst, v17, kCBMessageLocalizationTable, @"CELLULAR_PLAN_SETUP_FAILURE_TITLE_PHONE_%@", 0);
    *(void *)std::string buf = v62;
    CFStringRef v62 = (const __CFString *)__dst;
    *(void *)&long long __dst = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&__dst);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v17 + 40))(&__dst, v17, v24, @"CELLULAR_PLAN_SETUP_FAILURE_MESSAGE_PHONE", 0);
  }
  *(void **)std::string buf = v69[0];
  v69[0] = (void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&__dst);
  __src[0] = 0;
  __src[1] = 0;
  uint64_t v61 = 0;
  sub_1008EB2C8((uint64_t *)(a1 + 896), (uint64_t)&v63, __src);
  if (SHIBYTE(v61) < 0)
  {
    if (__src[1])
    {
      CFStringRef v27 = v62;
      sub_10004FC84(__p, __src[0], (unint64_t)__src[1]);
      CFAllocatorRef v26 = kCFAllocatorDefault;
      goto LABEL_28;
    }
LABEL_30:
    CFStringRef v28 = v62;
    *(void *)long long v75 = 0;
    *(void *)&long long __dst = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&__dst, (const __CFString **)"Apple Watch", (const char *)0x8000100, kCFAllocatorDefault, v25))
    {
      uint64_t v29 = *(void *)v75;
      *(void *)long long v75 = __dst;
      *(void *)std::string buf = v29;
      sub_1000558F4((const void **)buf);
    }
    uint64_t v74 = *(const void **)v75;
    *(void *)long long v75 = 0;
    sub_1000558F4((const void **)v75);
    CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", v28, 0, v74);
    uint64_t v31 = *((void *)&v68 + 1);
    *((void *)&v68 + 1) = StringWithValidatedFormat;
    *(void *)std::string buf = v31;
    sub_1000558F4((const void **)buf);
    sub_1000558F4(&v74);
    goto LABEL_45;
  }
  if (!HIBYTE(v61)) {
    goto LABEL_30;
  }
  CFAllocatorRef v26 = kCFAllocatorDefault;
  CFStringRef v27 = v62;
  *(_OWORD *)long long __p = *(_OWORD *)__src;
  uint64_t v58 = v61;
LABEL_28:
  if (SHIBYTE(v58) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v73 = v58;
  }
  long long v71 = 0;
  if (SHIBYTE(v73) < 0)
  {
    sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)std::string buf = __dst;
    uint64_t v77 = v73;
  }
  uint64_t v74 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v32 = v71;
    long long v71 = v74;
    *(void *)long long v75 = v32;
    sub_1000558F4((const void **)v75);
  }
  if (SHIBYTE(v77) < 0) {
    operator delete(*(void **)buf);
  }
  char v59 = v71;
  long long v71 = 0;
  sub_1000558F4(&v71);
  if (SHIBYTE(v73) < 0) {
    operator delete((void *)__dst);
  }
  CFStringRef v33 = CFStringCreateStringWithValidatedFormat(v26, 0, @"%@", v27, 0, v59);
  uint64_t v34 = *((void *)&v68 + 1);
  *((void *)&v68 + 1) = v33;
  *(void *)std::string buf = v34;
  sub_1000558F4((const void **)buf);
  sub_1000558F4(&v59);
  if (SHIBYTE(v58) < 0) {
    operator delete(__p[0]);
  }
LABEL_45:
  sub_10003ECB8((std::string *)&v69[1], "bridge:root=CELLULAR_ID&csn=", 0x1CuLL);
  if (v65 >= 0) {
    CFAllocatorRef v35 = (const std::string::value_type *)&v63;
  }
  else {
    CFAllocatorRef v35 = (const std::string::value_type *)v63;
  }
  if (v65 >= 0) {
    std::string::size_type v36 = HIBYTE(v65);
  }
  else {
    std::string::size_type v36 = v64;
  }
  std::string::append((std::string *)&v69[1], v35, v36);
  for (uint64_t i = *(void *)(a1 + 896); i != *(void *)(a1 + 904); i += 184)
  {
    if (*(unsigned char *)(i + 177) == 1)
    {
      long long v49 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        long long v50 = __str;
        if (__str[23] < 0) {
          long long v50 = *(unsigned char **)__str;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v50;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Delaying notification (%s)", buf, 0xCu);
      }
      sub_100D119E4((void *)(a1 + 1112), (std::string *)__str);
      goto LABEL_95;
    }
  }
  (***(void (****)(uint8_t *__return_ptr))(a1 + 128))(buf);
  long long v39 = (std::mutex *)Registry::getServiceMap(v38, *(Registry **)buf);
  long long v40 = v39;
  if (v41 < 0)
  {
    char v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v43 = 5381;
    do
    {
      uint64_t v41 = v43;
      unsigned int v44 = *v42++;
      uint64_t v43 = (33 * v43) ^ v44;
    }
    while (v44);
  }
  std::mutex::lock(v39);
  *(void *)&long long __dst = v41;
  long long v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)&__dst);
  if (!v45)
  {
    uint64_t v47 = 0;
    goto LABEL_67;
  }
  uint64_t v47 = v45[3];
  long long v46 = (std::__shared_weak_count *)v45[4];
  if (!v46)
  {
LABEL_67:
    std::mutex::unlock(v40);
    long long v46 = 0;
    char v48 = 1;
    goto LABEL_68;
  }
  atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v40);
  atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v46);
  char v48 = 0;
LABEL_68:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v47)
  {
    long long v51 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      long long v52 = __str;
      if (__str[23] < 0) {
        long long v52 = *(unsigned char **)__str;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v52;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Posting notification (%s)", buf, 0xCu);
      long long v51 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v77 = 0;
      ctu::cf::assign();
      long long __dst = *(_OWORD *)buf;
      uint64_t v73 = v77;
      p_dst = *(long long **)buf;
      if (v77 >= 0) {
        p_dst = &__dst;
      }
      *(_DWORD *)long long v75 = 136315138;
      *(void *)&v75[4] = p_dst;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s", v75, 0xCu);
      if (SHIBYTE(v73) < 0) {
        operator delete((void *)__dst);
      }
      long long v51 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v77 = 0;
      ctu::cf::assign();
      long long __dst = *(_OWORD *)buf;
      uint64_t v73 = v77;
      unint64_t v54 = *(long long **)buf;
      if (v77 >= 0) {
        unint64_t v54 = &__dst;
      }
      *(_DWORD *)long long v75 = 136315138;
      *(void *)&v75[4] = v54;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s", v75, 0xCu);
      if (SHIBYTE(v73) < 0) {
        operator delete((void *)__dst);
      }
      long long v51 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      if (v70 >= 0) {
        long long v55 = &v69[1];
      }
      else {
        long long v55 = (void **)v69[1];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Posting notification (%s)", buf, 0xCu);
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v47 + 16))(v47, __str);
  }
  if ((v48 & 1) == 0) {
    sub_10004D2C8(v46);
  }
LABEL_95:
  if (SHIBYTE(v61) < 0) {
    operator delete(__src[0]);
  }
  sub_1000558F4((const void **)&v62);
  if (SHIBYTE(v65) < 0) {
    operator delete(v63);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete(v69[1]);
  }
  sub_1000558F4((const void **)v69);
  sub_1000558F4((const void **)&v68 + 1);
  if (SHIBYTE(v67) < 0) {
    operator delete(*(void **)&__str[24]);
  }
  if ((__str[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__str);
    if (v19) {
      return 1;
    }
    goto LABEL_105;
  }
LABEL_104:
  if ((v19 & 1) == 0) {
LABEL_105:
  }
    sub_10004D2C8(v16);
  return 1;
}

void sub_100D124B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  if (*(char *)(v36 - 105) < 0) {
    operator delete(*(void **)(v36 - 128));
  }
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(a26);
  }
  sub_100D11A70((uint64_t)&a32);
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  _Unwind_Resume(a1);
}

void sub_100D12600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (!a24) {
    JUMPOUT(0x100D125F8);
  }
  JUMPOUT(0x100D125F4);
}

uint64_t sub_100D12610(uint64_t a1, ctu *a2, uint64_t a3, int a4)
{
  return 1;
}

void sub_100D12638(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ActivatingStateSubscriptionCheckTimer fired!", buf, 2u);
        }
        uint64_t v7 = *(void *)(v3 + 1000);
        *(void *)(v3 + 1000) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        uint64_t v8 = *(unsigned int *)(v3 + 1040);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 0x40000000;
        _OWORD v10[2] = sub_100D127A8;
        _OWORD v10[3] = &unk_101A50DE8;
        v10[4] = v3;
        std::string::size_type v9 = _Block_copy(v10);
        uint64_t v11 = v9;
        sub_100CF79E4(v3, v8, 0, 1, &v11);
        if (v9) {
          _Block_release(v9);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100D12780(_Unwind_Exception *a1)
{
  if (v2) {
    _Block_release(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D127A8(uint64_t a1)
{
  return sub_100D127B4(*(void *)(a1 + 32), 0);
}

void sub_100D127B4(uint64_t a1, int a2)
{
  if (*(char *)(a1 + 999) < 0)
  {
    if (!*(void *)(a1 + 984)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 999))
  {
    return;
  }
  if (a2)
  {
    *(void *)(a1 + 1032) = 0;
    *(void *)(a1 + 1016) = *(void *)(a1 + 1008);
    uint64_t v3 = *(void *)(a1 + 1000);
    *(void *)(a1 + 1000) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    theArray[0] = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
    (*(void (**)(CFArrayRef *__return_ptr))(**(void **)buf + 64))(theArray);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v4 = (void **)(a1 + 1008);
    if (theArray[0]) {
      long long v5 = sub_100083F10;
    }
    else {
      long long v5 = 0;
    }
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(theArray[0]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex(theArray[0], i);
          std::string::size_type v9 = ValueAtIndex;
          *(_DWORD *)std::string buf = 0;
          if (ValueAtIndex)
          {
            CFTypeID v10 = CFGetTypeID(ValueAtIndex);
            if (v10 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v9, v11);
            }
          }
          int v12 = *(_DWORD *)buf;
          uint64_t v13 = *(char **)(a1 + 1016);
          unint64_t v14 = *(void *)(a1 + 1024);
          if ((unint64_t)v13 >= v14)
          {
            char v16 = (char *)*v4;
            uint64_t v17 = (v13 - (unsigned char *)*v4) >> 2;
            unint64_t v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62) {
              sub_10006A748();
            }
            uint64_t v19 = v14 - (void)v16;
            if (v19 >> 1 > v18) {
              unint64_t v18 = v19 >> 1;
            }
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v20 = v18;
            }
            if (v20)
            {
              uint64_t v21 = (char *)sub_10005ECD8(a1 + 1024, v20);
              uint64_t v13 = *(char **)(a1 + 1016);
              char v16 = *(char **)(a1 + 1008);
            }
            else
            {
              uint64_t v21 = 0;
            }
            unint64_t v22 = &v21[4 * v17];
            *(_DWORD *)unint64_t v22 = v12;
            uint64_t v15 = v22 + 4;
            while (v13 != v16)
            {
              int v23 = *((_DWORD *)v13 - 1);
              v13 -= 4;
              *((_DWORD *)v22 - 1) = v23;
              v22 -= 4;
            }
            *(void *)(a1 + 1008) = v22;
            *(void *)(a1 + 1016) = v15;
            *(void *)(a1 + 1024) = &v21[4 * v20];
            if (v16) {
              operator delete(v16);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v13 = *(_DWORD *)buf;
            uint64_t v15 = v13 + 4;
          }
          *(void *)(a1 + 1016) = v15;
        }
      }
    }
    else
    {
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Subscription timer intervals not found in carrier bundle!", buf, 2u);
      }
      CFAllocatorRef v25 = *(char **)(a1 + 1016);
      CFAllocatorRef v26 = (char **)(a1 + 1024);
      CFStringRef v27 = *(char **)(a1 + 1024);
      if (v25 >= v27)
      {
        uint64_t v29 = (char *)*v4;
        uint64_t v30 = (v25 - (unsigned char *)*v4) >> 2;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v32 = v27 - v29;
        if (v32 >> 1 > v31) {
          unint64_t v31 = v32 >> 1;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          char v34 = (char *)sub_10005ECD8(a1 + 1024, v33);
          CFAllocatorRef v25 = *(char **)(a1 + 1016);
          uint64_t v29 = *(char **)(a1 + 1008);
        }
        else
        {
          char v34 = 0;
        }
        char v35 = &v34[4 * v30];
        CFStringRef v27 = &v34[4 * v33];
        *(_DWORD *)char v35 = 300;
        CFStringRef v28 = v35 + 4;
        while (v25 != v29)
        {
          int v36 = *((_DWORD *)v25 - 1);
          v25 -= 4;
          *((_DWORD *)v35 - 1) = v36;
          v35 -= 4;
        }
        *(void *)(a1 + 1008) = v35;
        *(void *)(a1 + 1016) = v28;
        *(void *)(a1 + 1024) = v27;
        if (v29)
        {
          operator delete(v29);
          CFStringRef v27 = *v26;
        }
      }
      else
      {
        *(_DWORD *)CFAllocatorRef v25 = 300;
        CFStringRef v28 = v25 + 4;
      }
      *(void *)(a1 + 1016) = v28;
      if (v28 >= v27)
      {
        std::string::size_type v38 = (char *)*v4;
        uint64_t v39 = (v28 - (unsigned char *)*v4) >> 2;
        unint64_t v40 = v39 + 1;
        if ((unint64_t)(v39 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v41 = v27 - v38;
        if (v41 >> 1 > v40) {
          unint64_t v40 = v41 >> 1;
        }
        if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v42 = v40;
        }
        if (v42)
        {
          uint64_t v43 = (char *)sub_10005ECD8(a1 + 1024, v42);
          CFStringRef v28 = *(char **)(a1 + 1016);
          std::string::size_type v38 = *(char **)(a1 + 1008);
        }
        else
        {
          uint64_t v43 = 0;
        }
        unsigned int v44 = &v43[4 * v39];
        CFStringRef v27 = &v43[4 * v42];
        *(_DWORD *)unsigned int v44 = 600;
        CFAllocatorRef v37 = v44 + 4;
        while (v28 != v38)
        {
          int v45 = *((_DWORD *)v28 - 1);
          v28 -= 4;
          *((_DWORD *)v44 - 1) = v45;
          v44 -= 4;
        }
        *(void *)(a1 + 1008) = v44;
        *(void *)(a1 + 1016) = v37;
        *(void *)(a1 + 1024) = v27;
        if (v38)
        {
          operator delete(v38);
          CFStringRef v27 = *v26;
        }
      }
      else
      {
        *(_DWORD *)CFStringRef v28 = 600;
        CFAllocatorRef v37 = v28 + 4;
      }
      *(void *)(a1 + 1016) = v37;
      if (v37 >= v27)
      {
        uint64_t v47 = (char *)*v4;
        uint64_t v48 = (v37 - (unsigned char *)*v4) >> 2;
        unint64_t v49 = v48 + 1;
        if ((unint64_t)(v48 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v50 = v27 - v47;
        if (v50 >> 1 > v49) {
          unint64_t v49 = v50 >> 1;
        }
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v51 = v49;
        }
        if (v51)
        {
          long long v52 = (char *)sub_10005ECD8(a1 + 1024, v51);
          CFAllocatorRef v37 = *(char **)(a1 + 1016);
          uint64_t v47 = *(char **)(a1 + 1008);
        }
        else
        {
          long long v52 = 0;
        }
        long long v53 = &v52[4 * v48];
        unint64_t v54 = &v52[4 * v51];
        *(_DWORD *)long long v53 = 1800;
        long long v46 = v53 + 4;
        while (v37 != v47)
        {
          int v55 = *((_DWORD *)v37 - 1);
          v37 -= 4;
          *((_DWORD *)v53 - 1) = v55;
          v53 -= 4;
        }
        *(void *)(a1 + 1008) = v53;
        *(void *)(a1 + 1016) = v46;
        *(void *)(a1 + 1024) = v54;
        if (v47) {
          operator delete(v47);
        }
      }
      else
      {
        *(_DWORD *)CFAllocatorRef v37 = 1800;
        long long v46 = v37 + 4;
      }
      *(void *)(a1 + 1016) = v46;
    }
    sub_100044D00((const void **)theArray);
  }
  if (*(void *)(a1 + 1032) < (unint64_t)((uint64_t)(*(void *)(a1 + 1016) - *(void *)(a1 + 1008)) >> 2)
    && ((*(uint64_t (**)(void, void, uint64_t))(**(void **)(a1 + 160) + 128))(*(void *)(a1 + 160), *(unsigned int *)(a1 + 1040), a1 + 976) & 1) == 0)
  {
    uint64_t v56 = *(NSObject **)(a1 + 40);
    if (*(void *)(a1 + 1000))
    {
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "A timer is still on-going!", buf, 2u);
      }
    }
    else
    {
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v57 = *(void *)(a1 + 1032);
        int v58 = *(_DWORD *)(*(void *)(a1 + 1008) + 4 * v57);
        *(_DWORD *)std::string buf = 134218240;
        *(void *)&uint8_t buf[4] = v57;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v58;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Starting a timer with index:%zu and time interval:%d", buf, 0x12u);
      }
      char v59 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v59 || (uint64_t v60 = *(void *)(a1 + 8), (v61 = std::__shared_weak_count::lock(v59)) == 0)) {
        sub_100088B9C();
      }
      CFStringRef v62 = v61;
      atomic_fetch_add_explicit(&v61->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v61);
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v73);
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v73 + 152))(&v75);
      uint64_t v63 = v75;
      sub_100058DB0(theArray, "ActivatingStateSubscriptionCheckTimer");
      unsigned int v64 = *(_DWORD *)(*(void *)(a1 + 1008) + 4 * *(void *)(a1 + 1032));
      uint64_t v65 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v65;
      if (v65) {
        dispatch_retain(v65);
      }
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_100D12638;
      long long v79 = &unk_101A50E08;
      uint64_t v80 = a1;
      uint64_t v81 = v60;
      unsigned __int8 v82 = v62;
      atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlock = _Block_copy(buf);
      sub_100118A44(v63, (uint64_t)theArray, 1, 1000000 * v64, &object, &aBlock);
      uint64_t v66 = v77;
      uint64_t v77 = 0;
      uint64_t v67 = *(void *)(a1 + 1000);
      *(void *)(a1 + 1000) = v66;
      if (v67)
      {
        (*(void (**)(uint64_t))(*(void *)v67 + 8))(v67);
        uint64_t v68 = v77;
        uint64_t v77 = 0;
        if (v68) {
          (*(void (**)(uint64_t))(*(void *)v68 + 8))(v68);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v72 < 0) {
        operator delete(theArray[0]);
      }
      if (v76) {
        sub_10004D2C8(v76);
      }
      if (v74) {
        sub_10004D2C8(v74);
      }
      ++*(void *)(a1 + 1032);
      if (v82) {
        std::__shared_weak_count::__release_weak(v82);
      }
      std::__shared_weak_count::__release_weak(v62);
    }
  }
}

void sub_100D12FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D130AC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D130C8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D130D8(uint64_t a1, int a2)
{
}

void sub_100D130E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D131C0(uint64_t a1)
{
}

void sub_100D131C8(uint64_t a1, uint64_t *a2, std::string *__str, uint64_t *a4, uint64_t a5)
{
  uint64_t v28 = 0;
  memset(v27, 0, sizeof(v27));
  *(_OWORD *)CFAllocatorRef v26 = 0u;
  memset(v25, 0, sizeof(v25));
  if (((uint64_t)__str[1].__r_.__value_.__l.__data_ & 0xFFFFFFFE) == 2) {
    goto LABEL_5;
  }
  (*(void (**)(uint64_t (****__return_ptr)(void **)))(**(void **)(a1 + 128) + 640))(&v23);
  int v10 = (*v23)[22]((void **)v23);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v10)
  {
LABEL_5:
    std::string::operator=((std::string *)v25, __str);
    *(_DWORD *)&v25[24] = __str[1].__r_.__value_.__l.__data_;
    std::string::operator=((std::string *)v26, (std::string *)((char *)__str + 32));
    std::string::operator=((std::string *)&v27[1], (std::string *)((char *)__str + 56));
    LODWORD(v28) = __str[3].__r_.__value_.__r.__words[1];
  }
  else
  {
    *(_DWORD *)&v25[24] = 1;
  }
  uint64_t v11 = *(void *)(a1 + 144);
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  if ((v25[23] & 0x80000000) != 0)
  {
    sub_10004FC84(__dst, *(void **)v25, *(unint64_t *)&v25[8]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v25;
    uint64_t v16 = *(void *)&v25[16];
  }
  int v17 = *(_DWORD *)&v25[24];
  if (SHIBYTE(v27[0]) < 0)
  {
    sub_10004FC84(&v18, v26[0], (unint64_t)v26[1]);
  }
  else
  {
    long long v18 = *(_OWORD *)v26;
    uint64_t v19 = v27[0];
  }
  if (SHIBYTE(v27[3]) < 0)
  {
    sub_10004FC84(&__p, v27[1], (unint64_t)v27[2]);
  }
  else
  {
    long long __p = *(_OWORD *)&v27[1];
    uint64_t v21 = v27[3];
  }
  int v22 = v28;
  v29[0] = 0;
  memset(v30, 0, sizeof(v30));
  sub_10037C544(v30, *a4, a4[1], 0x2E8BA2E8BA2E8BA3 * ((a4[1] - *a4) >> 3));
  v29[0] = 1;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_100D135B8;
  v14[3] = &unk_101A50E40;
  v14[4] = a5;
  v14[5] = a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void **, char *, void *))(*(void *)v11 + 80))(v11, v12, v13, __dst, v29, v14);
  if (v29[0])
  {
    int v23 = (uint64_t (***)(void **))v30;
    sub_10037AB58((void ***)&v23);
    v29[0] = 0;
  }
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  (*(void (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
  if (SHIBYTE(v27[3]) < 0) {
    operator delete(v27[1]);
  }
  if (SHIBYTE(v27[0]) < 0) {
    operator delete(v26[0]);
  }
  if ((v25[23] & 0x80000000) != 0) {
    operator delete(*(void **)v25);
  }
}

void sub_100D1352C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_1003785AC((uint64_t)&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_100D135B8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  uint64_t v6 = *(NSObject **)(v4 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5 == 2)
  {
    if (v7)
    {
      int v13 = 136315138;
      uint64_t v14 = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I updatePlan error: %s", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    if (v7)
    {
      if (v5 != 1)
      {
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      if (a2[1]) {
        uint64_t v8 = "succeeded";
      }
      else {
        uint64_t v8 = "failed";
      }
      int v13 = 136315138;
      uint64_t v14 = (uint64_t)v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I updatePlan result: %s", (uint8_t *)&v13, 0xCu);
      int v5 = *a2;
    }
    if (v5 != 1)
    {
      if (v5 == 2)
      {
        int v10 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v10);
      }
      uint64_t v11 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v11);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  return (*(uint64_t (**)(void))(**(void **)(v4 + 96) + 16))(*(void *)(v4 + 96));
}

void sub_100D137D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D137FC(uint64_t a1, uint64_t *a2, std::string *a3, uint64_t *a4, uint64_t a5)
{
}

uint64_t sub_100D13808(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 256);
  if (v1 && (uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 96))(v1), v2 <= 2))
  {
    uint64_t v3 = v2 << 32;
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
  }
  return v3 | v4;
}

uint64_t sub_100D13868(uint64_t a1)
{
  return sub_100D13808(a1 - 80);
}

uint64_t sub_100D13870(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v32 = 0u;
  *(_OWORD *)uint64_t v29 = 0u;
  long long v30 = 0u;
  *(_OWORD *)CFStringRef v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)CFAllocatorRef v25 = 0u;
  long long v26 = 0u;
  if (*(unsigned char *)(a1 + 1224)) {
    uint64_t v3 = (long long *)(a1 + 1232);
  }
  else {
    uint64_t v3 = (long long *)(a1 + 408);
  }
  sub_100313228((char *)v25, v3);
  uint64_t v4 = 0;
  if (*(unsigned char *)(a2 + 16) && BYTE8(v26))
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 47);
    if ((v5 & 0x80u) == 0) {
      uint64_t v6 = (void *)*(unsigned __int8 *)(a2 + 47);
    }
    else {
      uint64_t v6 = *(void **)(a2 + 32);
    }
    BOOL v7 = (void *)BYTE7(v28);
    if (SBYTE7(v28) < 0) {
      BOOL v7 = v27[1];
    }
    if (v6 == v7)
    {
      uint64_t v8 = (const void **)(a2 + 24);
      if ((SBYTE7(v28) & 0x80u) == 0) {
        std::string::size_type v9 = v27;
      }
      else {
        std::string::size_type v9 = (void **)v27[0];
      }
      if ((v5 & 0x80) != 0)
      {
        uint64_t v4 = memcmp(*v8, v9, *(void *)(a2 + 32)) == 0;
      }
      else if (*(unsigned char *)(a2 + 47))
      {
        uint64_t v10 = v5 - 1;
        do
        {
          int v12 = *(unsigned __int8 *)v8;
          uint64_t v8 = (const void **)((char *)v8 + 1);
          int v11 = v12;
          int v14 = *(unsigned __int8 *)v9;
          std::string::size_type v9 = (void **)((char *)v9 + 1);
          int v13 = v14;
          BOOL v16 = v10-- != 0;
          uint64_t v4 = v11 == v13;
        }
        while (v11 == v13 && v16);
      }
      else
      {
        uint64_t v4 = 1;
      }
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  int v17 = BYTE8(v28);
  if (*(unsigned char *)(a2 + 48)) {
    BOOL v18 = BYTE8(v28) == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v19 = *(unsigned __int8 *)(a2 + 79);
    if ((v19 & 0x80u) == 0) {
      unint64_t v20 = (void *)*(unsigned __int8 *)(a2 + 79);
    }
    else {
      unint64_t v20 = *(void **)(a2 + 64);
    }
    uint64_t v21 = (void *)BYTE7(v30);
    if (SBYTE7(v30) < 0) {
      uint64_t v21 = v29[1];
    }
    if (v20 == v21)
    {
      int v22 = (const void **)(a2 + 56);
      if ((SBYTE7(v30) & 0x80u) == 0) {
        int v23 = v29;
      }
      else {
        int v23 = (void **)v29[0];
      }
      if ((v19 & 0x80) != 0)
      {
        if (!memcmp(*v22, v23, *(void *)(a2 + 64))) {
          uint64_t v4 = 1;
        }
        else {
          uint64_t v4 = v4;
        }
      }
      else if (*(unsigned char *)(a2 + 79))
      {
        while (*(unsigned __int8 *)v22 == *(unsigned __int8 *)v23)
        {
          int v22 = (const void **)((char *)v22 + 1);
          int v23 = (void **)((char *)v23 + 1);
          if (!--v19) {
            goto LABEL_44;
          }
        }
      }
      else
      {
LABEL_44:
        uint64_t v4 = 1;
      }
    }
  }
  if (SBYTE7(v32) < 0)
  {
    operator delete(__p[0]);
    int v17 = BYTE8(v28);
  }
  if (v17)
  {
    if (SBYTE7(v30) < 0) {
      operator delete(v29[0]);
    }
    BYTE8(v28) = 0;
  }
  if (BYTE8(v26))
  {
    if (SBYTE7(v28) < 0) {
      operator delete(v27[0]);
    }
    BYTE8(v26) = 0;
  }
  if (SBYTE7(v26) < 0) {
    operator delete(v25[0]);
  }
  return v4;
}

uint64_t sub_100D13AA8(uint64_t a1, uint64_t a2)
{
  return sub_100D13870(a1 - 80, a2);
}

uint64_t sub_100D13AB0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 176) + 48))();
}

uint64_t sub_100D13AD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 48))();
}

uint64_t sub_100D13B00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 176) + 64))();
}

uint64_t sub_100D13B28(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 64))();
}

void sub_100D13B50(uint64_t a1, void *a2)
{
}

void sub_100D13B58(uint64_t a1, int a2, unsigned __int8 **a3, void *a4)
{
  if (!a4[2]) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 256);
  if (v8)
  {
    int v55 = 0;
    uint64_t v56 = 0;
    int v55 = (std::string *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 104))(v8);
    uint64_t v56 = v9;
    ctu::hex((uint64_t *)&__p, (ctu *)&v55, (const void *)0x10, v10);
    if ((v48 & 0x80u) == 0) {
      size_t v11 = v48;
    }
    else {
      size_t v11 = __n;
    }
    int v12 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    int v13 = (char)v12;
    if ((char)v12 < 0) {
      int v12 = a3[1];
    }
    if ((unsigned __int8 *)v11 == v12)
    {
      if (v13 >= 0) {
        int v14 = (unsigned __int8 *)a3;
      }
      else {
        int v14 = *a3;
      }
      if ((v48 & 0x80) != 0)
      {
        CFAllocatorRef v25 = __p;
        int v26 = memcmp(__p, v14, __n);
        operator delete(v25);
        if (v26) {
          return;
        }
      }
      else if (v48)
      {
        uint64_t v15 = 0;
        do
        {
          int v16 = *((unsigned __int8 *)&__p + v15);
          int v17 = v14[v15];
        }
        while (v16 == v17 && v48 - 1 != v15++);
        if (v16 != v17) {
          return;
        }
      }
      memset(v53, 0, sizeof(v53));
      long long v52 = 0u;
      CFStringRef v27 = (const std::string *)(*a4 + 32);
      uint64_t v54 = 0;
      std::string::operator=(v53, v27);
      uint64_t v28 = *(void *)(a1 + 160);
      uint64_t v38 = 0;
      long long v37 = 0uLL;
      sub_1000C5AB4((uint64_t)v44, (uint64_t)&v52);
      char v45 = 1;
      sub_1003DB514((uint64_t)&__p, a2, &v37, (uint64_t)v44, 0);
      (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v28 + 96))(v28, 1, &__p);
      if (v51) {
        sub_1000C584C((uint64_t)v50);
      }
      if (v49 < 0) {
        operator delete((void *)__n);
      }
      if (v45) {
        sub_1000C584C((uint64_t)v44);
      }
      if (SHIBYTE(v38) < 0) {
        operator delete((void *)v37);
      }
      uint64_t v29 = *(void *)(a1 + 256);
      uint64_t v30 = *a4;
      v41[0] = 0;
      if (*(char *)(v30 + 79) < 0)
      {
        sub_10004FC84(&v42, *(void **)(v30 + 56), *(void *)(v30 + 64));
      }
      else
      {
        long long v42 = *(_OWORD *)(v30 + 56);
        uint64_t v43 = *(void *)(v30 + 72);
      }
      v41[0] = 1;
      (*(void (**)(uint64_t, std::string **, uint64_t, char *))(*(void *)v29 + 128))(v29, &v55, v30 + 32, v41);
      if (v41[0])
      {
        if (SHIBYTE(v43) < 0) {
          operator delete((void *)v42);
        }
        v41[0] = 0;
      }
      (*(void (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
      sub_1000C584C((uint64_t)&v52);
    }
    else if ((v48 & 0x80) != 0)
    {
      operator delete(__p);
    }
  }
  else
  {
    long long v52 = 0uLL;
    sub_100CCD2E8();
    if (sub_100CFDC54(a1, 0, (uint64_t)&v52))
    {
      uint64_t v19 = *a4;
      if ((void *)*a4 != a4 + 1)
      {
        int v55 = 0;
        uint64_t v56 = 0;
        sub_100324590(&v55);
        unint64_t v20 = (long long *)(v19 + 32);
        uint64_t v21 = v55;
        int v22 = v55 + 4;
        std::string::size_type size = v55[4].__r_.__value_.__l.__size_;
        if (size >= v55[4].__r_.__value_.__r.__words[2])
        {
          uint64_t v24 = sub_10030E9EC((uint64_t *)v22, v20);
        }
        else
        {
          sub_1000D87F8(v22, v20);
          uint64_t v24 = size + 24;
        }
        v21[4].__r_.__value_.__l.__size_ = v24;
        std::string::operator=(v55, (const std::string *)(v19 + 56));
        uint64_t v31 = *(void *)(a1 + 160);
        uint64_t v36 = 0;
        long long v35 = 0uLL;
        v39[0] = 0;
        char v40 = 0;
        sub_1003DB514((uint64_t)&__p, a2, &v35, (uint64_t)v39, 0);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v31 + 96))(v31, 1, &__p);
        if (v51) {
          sub_1000C584C((uint64_t)v50);
        }
        if (v49 < 0) {
          operator delete((void *)__n);
        }
        if (v40) {
          sub_1000C584C((uint64_t)v39);
        }
        if (SHIBYTE(v36) < 0) {
          operator delete((void *)v35);
        }
        (*(void (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
        uint64_t v32 = *(void *)(a1 + 256);
        uint64_t v33 = v55;
        char v34 = v56;
        if (v56) {
          atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, long long *, std::string **))(*(void *)v32 + 24))(v32, &v52, &v33);
        if (v34) {
          sub_10004D2C8(v34);
        }
        if (v56) {
          sub_10004D2C8(v56);
        }
      }
    }
  }
}

void sub_100D14008(_Unwind_Exception *a1)
{
}

void sub_100D140F0(uint64_t a1, int a2, unsigned __int8 **a3, void *a4)
{
}

uint64_t sub_100D140F8(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 144) + 152))(*(void *)(a1 + 144));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 96) + 16);

  return v2();
}

uint64_t sub_100D14174(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 64) + 152))(*(void *)(a1 + 64));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 16);

  return v2();
}

uint64_t sub_100D141F0(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 144);
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __dst = *a3;
    uint64_t v19 = *((void *)a3 + 2);
  }
  sub_1000EA30C((uint64_t)v12, (void **)&__dst, 1);
  uint64_t v14 = a1;
  sub_1000DFC90((uint64_t)v15, a4);
  int v17 = 0;
  std::string::size_type v9 = operator new(0x30uLL);
  uint64_t v10 = v14;
  void *v9 = off_101A51CB8;
  v9[1] = v10;
  sub_100023950((uint64_t)(v9 + 2), (uint64_t)v15);
  int v17 = v9;
  (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void *))(*(void *)v6 + 64))(v6, v7, v8, v12, v16);
  sub_1000C6B58(v16);
  sub_100060644(v15);
  sub_10005CD2C((uint64_t)v12, v13);
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)__dst);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
}

void sub_100D1437C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, char *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_1000C6B58((uint64_t *)va1);
  sub_100060644(v3);
  sub_10005CD2C((uint64_t)va, v8);
  if (*(char *)(v4 - 57) < 0) {
    operator delete(*(void **)(v4 - 80));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D143D4(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4)
{
  return sub_100D141F0(a1 - 80, a2, a3, a4);
}

void sub_100D143DC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  if (!*(unsigned char *)(a1 + 1208)) {
    goto LABEL_17;
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 1135);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 1135);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 1120);
  }
  uint64_t v6 = a2[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 != v6) {
    goto LABEL_17;
  }
  if (v7 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*(const void **)(a1 + 1112), a2, *(void *)(a1 + 1120))) {
      goto LABEL_17;
    }
LABEL_32:
    sub_100D15518(a1 + 1112);
    return;
  }
  if (!*(unsigned char *)(a1 + 1135)) {
    goto LABEL_32;
  }
  uint64_t v8 = (unsigned __int8 *)(a1 + 1112);
  while (*v8 == *a2)
  {
    ++v8;
    ++a2;
    if (!--v4) {
      goto LABEL_32;
    }
  }
LABEL_17:
  (***(void (****)(Registry **__return_ptr))(a1 + 128))(&v20);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, v20);
  uint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v12;
  int v16 = sub_10004D37C(&v11[1].__m_.__sig, &v22);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_24;
  }
  uint64_t v18 = v16[3];
  int v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_24:
    std::mutex::unlock(v11);
    int v17 = 0;
    char v19 = 1;
    goto LABEL_25;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_25:
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v18) {
    (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v18 + 24))(v18, v2);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100D145D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D14600(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_100D14608(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 208) + 104))();
}

uint64_t sub_100D14630(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 104))();
}

void *sub_100D14658@<X0>(void *result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = result[110];
  if (!v3) {
    return sub_100058DB0(a3, "");
  }
  uint64_t v4 = result + 110;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = (void *)v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == result + 110 || *((_DWORD *)v4 + 8) > a2) {
    return sub_100058DB0(a3, "");
  }
  if (*((char *)v4 + 87) < 0) {
    return sub_10004FC84(a3, (void *)v4[8], v4[9]);
  }
  long long v8 = *((_OWORD *)v4 + 4);
  a3[2] = v4[10];
  *(_OWORD *)a3 = v8;
  return result;
}

void *sub_100D146D0@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  return sub_100D14658((void *)(a1 - 80), a2, a3);
}

uint64_t sub_100D146D8(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_100D14728(uint64_t a1, const void **a2)
{
  sub_100083DA4((const void **)&v4 + 1, a2);
  char v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D14834(uint64_t a1, const void **a2)
{
}

const void **sub_100D1483C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1368;
  if (!*(unsigned char *)(a1 + 1224)) {
    uint64_t v3 = a1 + 328;
  }
  uint64_t v4 = *(void *)(v3 + 32);
  if (*(void *)(v3 + 40) == v4 || !*(unsigned char *)(v3 + 24))
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No vinyl info", buf, 2u);
    }
    char v11 = 0;
    (*(void (**)(uint64_t, const void **, void))(a2 + 16))(a2, &v11, 0);
    return sub_100057D78(&v11);
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = *(void *)(v4 + 24);
    uint64_t v7 = *(void *)(a1 + 144);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    _OWORD v10[2] = sub_100D14980;
    _OWORD v10[3] = &unk_101A50EA8;
    v10[4] = a2;
    return (const void **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 128))(v7, v5, v6, v10);
  }
}

void sub_100D1496C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100D14980(uint64_t a1, unsigned __int8 *a2)
{
  xpc_object_t v29 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v29 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v29 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v29 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a2;
  if (v7 == 1)
  {
    if (a2[8])
    {
      uint64_t v35 = 0;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v30 = 0u;
      sub_1000C5DA8((uint64_t)&v30, (uint64_t)(a2 + 16));
      v28[0] = 0;
      v28[1] = 0;
      ctu::TextConverter::TextConverter((ctu::TextConverter *)v28);
      ctu::TextConverter::pushConversion();
      ctu::TextConverter::setSource((ctu::TextConverter *)v28, (const char *)&v31, 0x10uLL);
      ctu::TextConverter::readChars((uint64_t *)&__p, (ctu::TextConverter *)v28, 0x7FFFFFFFuLL);
      if (v25 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      xpc_object_t v26 = xpc_string_create(p_p);
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      v22[0] = (ctu *)&v29;
      v22[1] = (ctu *)"CSN";
      sub_100035E70((uint64_t)v22, &v26, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      if (v25 < 0) {
        operator delete(__p);
      }
      xpc_object_t v20 = xpc_int64_create(SHIDWORD(v30));
      if (!v20) {
        xpc_object_t v20 = xpc_null_create();
      }
      long long __p = &v29;
      uint64_t v24 = "Available";
      sub_100035E70((uint64_t)&__p, &v20, &v21);
      xpc_release(v21);
      xpc_object_t v21 = 0;
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_object_t v18 = xpc_int64_create(SDWORD1(v30));
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
      long long __p = &v29;
      uint64_t v24 = "SlotId";
      sub_100035E70((uint64_t)&__p, &v18, &v19);
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_release(v18);
      xpc_object_t v18 = 0;
      if ((_BYTE)v35)
      {
        xpc_object_t v16 = xpc_int64_create(0x84BDA12F684BDA13 * ((uint64_t)(v34 - *((void *)&v33 + 1)) >> 3));
        if (!v16) {
          xpc_object_t v16 = xpc_null_create();
        }
        long long __p = &v29;
        uint64_t v24 = "NumProfiles";
        sub_100035E70((uint64_t)&__p, &v16, &v17);
        xpc_release(v17);
        xpc_object_t v17 = 0;
        xpc_release(v16);
        xpc_object_t v16 = 0;
        v22[0] = 0;
        if (!(_BYTE)v35) {
          sub_10016C840();
        }
        sub_1003EEC34((void *)&v33 + 1, (NSMutableArray **)v22);
        ctu::cf_to_xpc((uint64_t *)&v14, v22[0], v10);
        long long __p = &v29;
        uint64_t v24 = "Profiles";
        sub_100035E70((uint64_t)&__p, &v14, &v15);
        xpc_release(v15);
        xpc_object_t v15 = 0;
        xpc_release(v14);
        xpc_object_t v14 = 0;
        sub_100044D00((const void **)v22);
      }
      ctu::TextConverter::~TextConverter((ctu::TextConverter *)v28);
      if ((_BYTE)v35)
      {
        long long __p = (char *)&v33 + 8;
        sub_1000C57C8((void ***)&__p);
      }
      if (SBYTE7(v33) < 0) {
        operator delete((void *)v32);
      }
    }
  }
  else if (v7 != 2)
  {
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
  }
  uint64_t v11 = *(void *)(a1 + 32);
  long long __p = v29;
  if (v29) {
    xpc_retain(v29);
  }
  else {
    long long __p = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v30, (xpc *)&__p, v12);
  sub_10004EFE4(&v13, (CFTypeRef *)&v30);
  (*(void (**)(uint64_t, const void **, void))(v11 + 16))(v11, &v13, 0);
  sub_100057D78(&v13);
  sub_1000577C4((const void **)&v30);
  xpc_release(__p);
  xpc_release(v29);
}

void sub_100D14DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,xpc_object_t object,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

const void **sub_100D14EB0(uint64_t a1, uint64_t a2)
{
  return sub_100D1483C(a1 - 56, a2);
}

void sub_100D14EB8(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v12);
  uint64_t v8 = v12;
  sub_100058198(&v11, a3);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100D15020;
  v9[3] = &unk_101A50ED0;
  v9[4] = a4;
  v9[5] = a1;
  aBlock = _Block_copy(v9);
  (*(void (**)(uint64_t, uint64_t, const void **, void **))(*(void *)v8 + 184))(v8, a2, &v11, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  sub_100057D78(&v11);
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100D14FEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, const void *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  sub_100057D78(&a16);
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

void sub_100D15020(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2 != 1)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    sub_100058DB0(v9, "");
    (*(void (**)(uint64_t, void *, void))(v7 + 16))(v7, v9, 0);
    if ((v10 & 0x80000000) == 0) {
      return;
    }
    uint64_t v8 = (void *)v9[0];
    goto LABEL_15;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v14 = 0;
  sub_10012CD04(v13, *(char **)(a2 + 8), *(char **)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
  xpc_object_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v5 = v13;
    if (v14 < 0) {
      xpc_object_t v5 = (void **)v13[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    xpc_object_t v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I received phone auth token: %s", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (SHIBYTE(v14) < 0)
  {
    sub_10004FC84(__p, v13[0], (unint64_t)v13[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v13;
    uint64_t v12 = v14;
  }
  (*(void (**)(uint64_t, void **, uint64_t))(v6 + 16))(v6, __p, 1);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    uint64_t v8 = v13[0];
LABEL_15:
    operator delete(v8);
  }
}

void sub_100D1519C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D151EC(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4)
{
}

void *sub_100D151FC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100D15280(uint64_t a1, char a2, long long *a3, long long *a4)
{
  *(unsigned char *)a1 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v7;
  }
  uint64_t v8 = *((void *)a3 + 3);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = v8;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  sub_100311ED8((void *)(a1 + 40), *((void *)a3 + 4), *((void *)a3 + 5), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)a3 + 5) - *((void *)a3 + 4)) >> 3));
  uint64_t v9 = *((void *)a3 + 7);
  *(_DWORD *)(a1 + 72) = *((_DWORD *)a3 + 16);
  *(void *)(a1 + 64) = v9;
  sub_100313228((char *)(a1 + 80), a4);
  return a1;
}

void sub_100D15338(_Unwind_Exception *a1)
{
  sub_1003CC6D4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D15364(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(unsigned char *)(a1 + 8) = 0;
  long long v3 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 32) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v5 = *(void *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 72);
  *(void *)(a1 + 72) = v5;
  *(unsigned char *)(a1 + 8) = 1;
  *(unsigned char *)(a1 + 88) = 0;
  sub_100313228((char *)(a1 + 96), (long long *)(a2 + 80));
  *(unsigned char *)(a1 + 88) = 1;
  return a1;
}

void sub_100D15408(_Unwind_Exception *a1)
{
  sub_100D1541C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1541C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    long long v3 = (void **)(a1 + 40);
    sub_1000C56F4(&v3);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

uint64_t sub_100D15474(uint64_t a1)
{
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 167) < 0) {
      operator delete(*(void **)(a1 + 144));
    }
    *(unsigned char *)(a1 + 136) = 0;
  }
  if (*(unsigned char *)(a1 + 104))
  {
    if (*(char *)(a1 + 135) < 0) {
      operator delete(*(void **)(a1 + 112));
    }
    *(unsigned char *)(a1 + 104) = 0;
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  long long v3 = (void **)(a1 + 40);
  sub_1000C56F4(&v3);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100D15518(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    sub_1000558F4((const void **)(a1 + 64));
    sub_1000558F4((const void **)(a1 + 56));
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 96) = 0;
  }
}

uint64_t sub_100D15584(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x155555555555555) {
    unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  xpc_object_t v17 = a1 + 2;
  if (v9) {
    char v10 = (char *)sub_100157260(v7, v9);
  }
  else {
    char v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[96 * v4];
  xpc_object_t v16 = &v10[96 * v9];
  sub_10019FFDC(v14, a2);
  xpc_object_t v15 = v14 + 96;
  sub_1008C329C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1008C33BC((uint64_t)&v13);
  return v11;
}

void sub_100D15678(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1008C33BC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1568C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    if (*(char *)(a1 + 87) < 0) {
      operator delete(*(void **)(a1 + 64));
    }
    if (*(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

uint64_t sub_100D156EC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(unsigned char *)(a1 + 64))
    {
      if (*(char *)(a1 + 95) < 0) {
        operator delete(*(void **)(a1 + 72));
      }
      *(unsigned char *)(a1 + 64) = 0;
    }
    if (*(unsigned char *)(a1 + 32))
    {
      if (*(char *)(a1 + 63) < 0) {
        operator delete(*(void **)(a1 + 40));
      }
      *(unsigned char *)(a1 + 32) = 0;
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

uint64_t sub_100D15774(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

uint64_t sub_100D157C4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  uint64_t v6 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_10006A748();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v5) >> 3);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x1745D1745D1745DLL) {
    unint64_t v13 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v13 = v7;
  }
  xpc_object_t v21 = a1 + 2;
  if (v13) {
    uint64_t v14 = (char *)sub_10010C8A4(v11, v13);
  }
  else {
    uint64_t v14 = 0;
  }
  xpc_object_t v17 = v14;
  xpc_object_t v18 = &v14[88 * v6];
  xpc_object_t v20 = &v14[88 * v13];
  sub_100D158FC(v18, a2, a3, a4);
  xpc_object_t v19 = v18 + 88;
  sub_100B6371C(a1, &v17);
  uint64_t v15 = a1[1];
  sub_100B6382C((uint64_t)&v17);
  return v15;
}

void sub_100D158E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B6382C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100D158FC(void *__dst, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  v13[0] = 0;
  if (*(unsigned char *)a3)
  {
    *(_OWORD *)uint64_t v14 = *(_OWORD *)(a3 + 8);
    uint64_t v15 = *(void *)(a3 + 24);
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 8) = 0;
    v13[0] = 1;
  }
  v10[0] = 0;
  if (*(unsigned char *)a4)
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a4 + 8);
    uint64_t v12 = *(void *)(a4 + 24);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    v10[0] = 1;
  }
  sub_100B63660(__dst, (long long *)v8, (uint64_t)v13, (uint64_t)v10);
  if (v10[0])
  {
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    v10[0] = 0;
  }
  if (v13[0])
  {
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[0]);
    }
    v13[0] = 0;
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
  return __dst;
}

void sub_100D15A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

uint64_t sub_100D15AA0(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  sub_1008275B8((void **)(a1 + 24));
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  *(unsigned char *)(a1 + 48) = *((unsigned char *)a2 + 48);
  uint64_t v5 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 56);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 79) = 0;
  *((unsigned char *)a2 + 56) = 0;
  sub_1003464A0(a1 + 80, (uint64_t)(a2 + 5));
  sub_1003464A0(a1 + 112, (uint64_t)(a2 + 7));
  return a1;
}

uint64_t sub_100D15B70(uint64_t a1)
{
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(unsigned char *)(a1 + 128))
  {
    if (*(char *)(a1 + 159) < 0) {
      operator delete(*(void **)(a1 + 136));
    }
    *(unsigned char *)(a1 + 128) = 0;
  }
  if (*(unsigned char *)(a1 + 96))
  {
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    *(unsigned char *)(a1 + 96) = 0;
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v3 = (void **)(a1 + 32);
  sub_1000C56F4(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100D15C18(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D15C50(uint64_t a1)
{
}

uint64_t sub_100D15C6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D15CB0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100D15CDC(ServiceManager::Service *this)
{
  *(void *)this = off_101A51078;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100D15D38(ServiceManager::Service *this)
{
  *(void *)this = off_101A51078;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100D15DA8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CellularPlanControllerPhone");
}

unsigned char *sub_100D15DB8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

uint64_t sub_100D15DFC()
{
  return 0;
}

uint64_t sub_100D15E04()
{
  return 0;
}

uint64_t sub_100D15E0C()
{
  return 0;
}

void sub_100D15E20(atomic_uint **a1)
{
  if (a1)
  {
    sub_100D15E20(*a1);
    sub_100D15E20(a1[1]);
    sub_100160AF8(a1 + 6);
    operator delete(a1);
  }
}

void sub_100D15E74(void *a1)
{
  if (a1)
  {
    sub_100D15E74(*a1);
    sub_100D15E74(a1[1]);
    sub_10005D144((void *)a1[6]);
    operator delete(a1);
  }
}

void *sub_100D15EC8(void *a1)
{
  *a1 = off_101A510F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D15F14(void *a1)
{
  *a1 = off_101A510F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100D15F80(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A510F8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D15FE4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A510F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D16024(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D16034(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100D16074(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = a1[3];
      sub_10004D2C8(v5);
      if (v6)
      {
        (***(void (****)(long long *__return_ptr))(v4 + 128))(&v17);
        *(_OWORD *)long long __p = v17;
        long long v17 = 0uLL;
        subscriber::makeSimSlotRange();
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
        if (*((void *)&v17 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
        }
        unint64_t v8 = v18;
        unint64_t v7 = v19;
        if (v18 != v19)
        {
          uint64_t v9 = v20;
          while ((v9(*v8) & 1) == 0)
          {
            if (++v8 == v7)
            {
              unint64_t v8 = v7;
              break;
            }
          }
          char v10 = v19;
          while (v8 != v10)
          {
            uint64_t v11 = *v8;
            (***(void (****)(long long *__return_ptr))(v4 + 128))(&v14);
            long long v17 = v14;
            long long v14 = 0uLL;
            PersonalityIdFromSlotId();
            uint64_t v12 = sub_100046F68(v4 + 848, __p);
            if (SHIBYTE(v16) < 0) {
              operator delete(__p[0]);
            }
            if (*((void *)&v17 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
            }
            if (*((void *)&v14 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
            }
            if ((void **)(v4 + 856) == v12)
            {
              *(void *)&long long v17 = 0;
              __p[1] = 0;
              uint64_t v16 = 0;
              __p[0] = &__p[1];
              sub_100CF98EC(v4, v11, &v17, (uint64_t)__p);
              sub_1000346F8((uint64_t)__p, (void *)__p[1]);
            }
            else
            {
              sub_100CF98EC(v4, v11, v12 + 7, (uint64_t)(v12 + 8));
            }
            unint64_t v13 = v8 + 1;
            unint64_t v8 = v7;
            if (v13 != v7)
            {
              unint64_t v8 = v13;
              while ((v9(*v8) & 1) == 0)
              {
                if (++v8 == v7)
                {
                  unint64_t v8 = v7;
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_100D16294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D16300(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D16340()
{
}

void sub_100D16350()
{
}

__n128 sub_100D16364(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A51178;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D163B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D163F0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  uint64_t v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100D16494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100D164B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D164F0()
{
}

void sub_100D16500()
{
}

__n128 sub_100D16514(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A511F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D16568(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A511F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D165A0(void *a1)
{
  uint64_t v2 = (long long *)a1[1];
  uint64_t v15 = 0;
  long long v3 = *v2;
  uint64_t v4 = *((void *)v2 + 3);
  uint64_t v10 = *((void *)v2 + 2);
  *(_OWORD *)long long __p = v3;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = 0;
  uint64_t v11 = v4;
  long long v12 = v2[2];
  uint64_t v5 = *((void *)v2 + 7);
  uint64_t v13 = *((void *)v2 + 6);
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 6) = 0;
  *((void *)v2 + 4) = 0;
  LODWORD(v15) = *((_DWORD *)v2 + 16);
  uint64_t v14 = v5;
  read_rest_value();
  uint64_t v6 = (void (*)(void *, void **))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void **))(*v8 + v6);
  }
  v6(v8, __p);
  uint64_t v16 = (void **)&v12;
  sub_1000C56F4(&v16);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D16684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  *(void *)(v15 - 24) = v14;
  sub_1000C56F4((void ***)(v15 - 24));
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D166AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D166EC()
{
}

void sub_100D166FC()
{
}

__n128 sub_100D16710(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A51278;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D16764(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51278;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D1679C(void *a1)
{
  uint64_t v2 = (long long *)a1[1];
  uint64_t v14 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v13 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  long long v7 = 0u;
  sub_100313228((char *)v6, v2);
  cellplan::read_rest_value();
  long long v3 = (void (*)(void *, void **))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    long long v3 = *(void (**)(void *, void **))(*v5 + v3);
  }
  v3(v5, v6);
  if (SBYTE7(v13) < 0) {
    operator delete(__p[0]);
  }
  if (BYTE8(v9))
  {
    if (SBYTE7(v11) < 0) {
      operator delete(v10[0]);
    }
    BYTE8(v9) = 0;
  }
  if (BYTE8(v7))
  {
    if (SBYTE7(v9) < 0) {
      operator delete(v8[0]);
    }
    BYTE8(v7) = 0;
  }
  if (SBYTE7(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_100D168D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
}

uint64_t sub_100D16940(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D16980()
{
}

void sub_100D16990()
{
}

__n128 sub_100D169A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A512F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D169F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A512F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D16A30(void *a1, xpc_object_t *a2)
{
  long long v3 = (uint64_t *)a1[1];
  long long v21 = *(_OWORD *)v3;
  uint64_t v22 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  xpc_object_t v4 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  uint64_t v6 = *v3;
  for (uint64_t i = v3[1]; i != v6; uint64_t i = sub_1003DAC14(i - 216))
    ;
  v3[1] = v6;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v25, object, 0);
    xpc_release(object[0]);
    object[0] = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v4);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v24, object, count);
    xpc_release(object[0]);
    for (uint64_t j = v26; j != v24[1] || v25 != v24[0]; uint64_t j = ++v26)
    {
      v23[0] = &v25;
      v23[1] = j;
      unint64_t v9 = v3[1];
      unint64_t v10 = v3[2];
      if (v9 >= v10)
      {
        unint64_t v12 = 0x84BDA12F684BDA13 * ((uint64_t)(v9 - *v3) >> 3);
        unint64_t v13 = v12 + 1;
        if (v12 + 1 > 0x12F684BDA12F684) {
          sub_10006A748();
        }
        unint64_t v14 = 0x84BDA12F684BDA13 * ((uint64_t)(v10 - *v3) >> 3);
        if (2 * v14 > v13) {
          unint64_t v13 = 2 * v14;
        }
        if (v14 >= 0x97B425ED097B42) {
          unint64_t v15 = 0x12F684BDA12F684;
        }
        else {
          unint64_t v15 = v13;
        }
        object[4] = v3 + 2;
        if (v15) {
          uint64_t v16 = (char *)sub_1000C5FD0((uint64_t)(v3 + 2), v15);
        }
        else {
          uint64_t v16 = 0;
        }
        long long v17 = &v16[216 * v12];
        object[0] = v16;
        object[1] = v17;
        object[3] = &v16[216 * v15];
        *(_OWORD *)long long v17 = 0u;
        *((_OWORD *)v17 + 1) = 0u;
        *((_OWORD *)v17 + 2) = 0u;
        *((_OWORD *)v17 + 3) = 0u;
        *((_OWORD *)v17 + 4) = 0u;
        *((_OWORD *)v17 + 5) = 0u;
        *((_OWORD *)v17 + 6) = 0u;
        *((_OWORD *)v17 + 7) = 0u;
        *((_OWORD *)v17 + 8) = 0u;
        *((_OWORD *)v17 + 9) = 0u;
        *((_OWORD *)v17 + 10) = 0u;
        *((_OWORD *)v17 + 11) = 0u;
        *((_OWORD *)v17 + 12) = 0u;
        *((void *)v17 + 26) = 0;
        object[2] = v17 + 216;
        sub_10078C504(v3, object);
        uint64_t v11 = v3[1];
        sub_10078C610((uint64_t)object);
      }
      else
      {
        *(void *)(v9 + 208) = 0;
        *(_OWORD *)(v9 + 176) = 0u;
        *(_OWORD *)(v9 + 192) = 0u;
        *(_OWORD *)(v9 + 144) = 0u;
        *(_OWORD *)(v9 + 160) = 0u;
        *(_OWORD *)(v9 + 112) = 0u;
        *(_OWORD *)(v9 + 128) = 0u;
        *(_OWORD *)(v9 + 80) = 0u;
        *(_OWORD *)(v9 + 96) = 0u;
        *(_OWORD *)(v9 + 48) = 0u;
        *(_OWORD *)(v9 + 64) = 0u;
        *(_OWORD *)(v9 + 16) = 0u;
        *(_OWORD *)(v9 + 32) = 0u;
        *(_OWORD *)unint64_t v9 = 0u;
        uint64_t v11 = v9 + 216;
        v3[1] = v9 + 216;
      }
      v3[1] = v11;
      sub_1000492E0((uint64_t)v23, object);
      cellplan::read_rest_value();
      xpc_release(object[0]);
    }
    xpc_release(v25);
    xpc_release(v25);
  }
  xpc_release(v4);
  xpc_object_t v18 = (void (*)(void *, long long *))a1[3];
  uint64_t v19 = a1[4];
  xpc_object_t v20 = (void *)(a1[2] + (v19 >> 1));
  if (v19) {
    xpc_object_t v18 = *(void (**)(void *, long long *))(*v20 + v18);
  }
  v18(v20, &v21);
  object[0] = &v21;
  sub_1003DACB8((void ***)object);
}

void sub_100D16D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, uint64_t a15, uint64_t *a16, uint64_t a17, xpc_object_t object)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a16);
  xpc_release(v18);
  a16 = &a9;
  sub_1003DACB8((void ***)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100D16E28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D16E68()
{
}

void sub_100D16E78()
{
}

__n128 sub_100D16E8C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A51378;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D16EE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D16F18(void *a1, xpc_object_t *a2)
{
  xpc_object_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    *xpc_object_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *xpc_object_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  unint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    unint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100D17008(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D17048()
{
}

void sub_100D17058()
{
}

void *sub_100D1706C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A513F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100D170B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A513F8;
  a2[1] = v2;
  return result;
}

void sub_100D170E0(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100D170E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D17128()
{
}

void sub_100D17134(uint64_t a1, uint64_t a2)
{
  xpc_object_t v5 = 0;
  if (*(unsigned char *)a2) {
    cellplan::write_rest_value((cellplan *)(a2 + 8), (const cellplan::RemoteSimSubscriptionInfo *)a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/cellular_plan_remotesubscription_info");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100D171F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void *sub_100D17234(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100D1749C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100D174AC()
{
}

void *sub_100D174C0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A51488;
  result[1] = v3;
  return result;
}

uint64_t sub_100D17508(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A51488;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100D17534(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_null)
  {
    if (*(unsigned char *)(v3 + 1)) {
      *(unsigned char *)(v3 + 1) = 0;
    }
  }
  else
  {
    if (!*(unsigned char *)(v3 + 1)) {
      *(_WORD *)uint64_t v3 = 256;
    }
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, v5);
    *(unsigned char *)uint64_t v3 = (_BYTE)result;
  }
  return result;
}

uint64_t sub_100D1759C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D175DC()
{
}

void sub_100D175EC()
{
}

__n128 sub_100D17600(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A51508;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D17654(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D1768C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  long long v17 = 0;
  xpc_object_t v18 = 0;
  uint64_t v16 = &v17;
  sub_10008AAD8((uint64_t)&v16, a2);
  uint64_t v11 = 0;
  LOWORD(v11) = *(_WORD *)v3;
  uint64_t v4 = *(void *)(v3 + 24);
  *(_OWORD *)unint64_t v12 = *(_OWORD *)(v3 + 8);
  uint64_t v13 = v4;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 8) = 0;
  long long v5 = *(_OWORD *)(v3 + 32);
  uint64_t v15 = *(void *)(v3 + 48);
  *(_OWORD *)long long __p = v5;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 32) = 0;
  unint64_t v9 = v16;
  v10[0] = v17;
  v10[1] = v18;
  if (v18)
  {
    v17[2] = v10;
    uint64_t v16 = &v17;
    long long v17 = 0;
    xpc_object_t v18 = 0;
  }
  else
  {
    unint64_t v9 = v10;
  }
  sub_1007D52CC((std::string *)v3, (uint64_t)&v9);
  sub_100087F94((uint64_t)&v9, v10[0]);
  if (rest::operator!=())
  {
    uint64_t v6 = (void (*)(void *))a1[3];
    uint64_t v7 = a1[4];
    uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(void (**)(void *))(*v8 + v6);
    }
    v6(v8);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  sub_100087F94((uint64_t)&v16, v17);
}

void sub_100D177E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_100087F94((uint64_t)&a10, a11);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  sub_100087F94(v25 - 56, *(void **)(v25 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_100D17834(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D17874()
{
}

void sub_100D17884()
{
}

__n128 sub_100D17898(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A51588;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D178EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51588;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D17924(uint64_t a1, xpc_object_t *a2)
{
  sub_1008EA904(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100D179A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D179E0()
{
}

void sub_100D179F0()
{
}

__n128 sub_100D17A04(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A51608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D17A58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D17A90(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D17AD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D17B18()
{
}

uint64_t sub_100D17B24(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

NSObject **sub_100D17B70(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_100D17BC0(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    __n128 result = (uint64_t)sub_100D17B70((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100D182A4(v6);
  }
  __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100D17C98(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3 && (v4 = _Block_copy(v3)) != 0 && (v5 = _Block_copy(v4), (uint64_t v6 = v5) != 0))
  {
    uint64_t v7 = _Block_copy(v5);
    uint64_t v8 = v7;
    if (v7)
    {
      unint64_t v9 = _Block_copy(v7);
      uint64_t v10 = v9;
      if (v9)
      {
        uint64_t v11 = _Block_copy(v9);
        unint64_t v12 = v11;
        if (v11)
        {
          uint64_t v13 = _Block_copy(v11);
          unint64_t v14 = v13;
          if (v13)
          {
            xpc_object_t v18 = _Block_copy(v13);
            _Block_release(v14);
          }
          else
          {
            xpc_object_t v18 = 0;
          }
          _Block_release(v12);
        }
        else
        {
          xpc_object_t v18 = 0;
        }
        _Block_release(v10);
      }
      else
      {
        xpc_object_t v18 = 0;
      }
      long long v17 = off_101A516B8;
      _Block_release(v8);
    }
    else
    {
      long long v17 = off_101A516B8;
      xpc_object_t v18 = 0;
    }
    _Block_release(v6);
  }
  else
  {
    long long v17 = off_101A516B8;
    xpc_object_t v18 = 0;
  }
  sub_100A34AD8();
}

void sub_100D17E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  sub_100A35098(&a16);
  if ((v17 & 1) == 0) {
    _Block_release(v16);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100D17E88(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100D17F64(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void *sub_100D17F74(void *a1)
{
  *a1 = off_101A516E8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D17FC0(void *a1)
{
  *a1 = off_101A516E8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100D1802C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100D180DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D180F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100D18114()
{
}

void *sub_100D18180(void *a1)
{
  *a1 = off_101A51738;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100D181CC(void *a1)
{
  *a1 = off_101A51738;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100D18238()
{
}

uint64_t sub_100D182A4(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_100D182E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100D182F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D1830C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100D18320()
{
}

void *sub_100D18334()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A517B0;
  return result;
}

void sub_100D1836C(uint64_t a1, void *a2)
{
  *a2 = off_101A517B0;
}

void sub_100D18394(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "CellularPlanRemoteProvisioning", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_100D1840C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1844C()
{
}

uint64_t *sub_100D18458(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    uint64_t v9 = *(void *)(v1 + 24);
    *(_OWORD *)long long __p = v3;
  }
  uint64_t v4 = *(void **)(v1 + 32);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  v10[0] = off_101A51830;
  v10[1] = v4;
  _OWORD v10[3] = v10;
  sub_100D0B23C(v2, 1, (unsigned __int8 **)__p, (uint64_t)v10);
  sub_10030C800(v10);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_100D18598(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100D1854C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
}

uint64_t *sub_100D18598(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(const void **)(v1 + 32);
    if (v2) {
      _Block_release(v2);
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void *sub_100D18600(void *a1)
{
  *a1 = off_101A51830;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100D18650(void *a1)
{
  *a1 = off_101A51830;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100D186C0(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A51830;
  sub_100D1885C(v2 + 1, v1);
  return v2;
}

void *sub_100D18714(uint64_t a1, void *a2)
{
  *a2 = off_101A51830;
  return sub_100D1885C(a2 + 1, (void **)(a1 + 8));
}

void sub_100D18740(uint64_t a1)
{
}

void sub_100D18748(const void **a1)
{
  sub_100D18894(a1[1]);

  operator delete(a1);
}

const void **sub_100D18784(uint64_t a1, const void **a2, const void **a3, unsigned __int16 *a4)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v6 = *a3;
  uint64_t v7 = v4;
  *a3 = 0;
  (*(void (**)(void, BOOL))(*(void *)(a1 + 8) + 16))(*(void *)(a1 + 8), *a4 < 0x100u);
  sub_100057D78(&v6);
  return sub_1000558F4(&v7);
}

void sub_100D187F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_100D18810(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D18850()
{
}

void *sub_100D1885C(void *a1, void **a2)
{
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_100D18894(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

uint64_t *sub_100D188B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    uint64_t v8 = *(void *)(v1 + 24);
    *(_OWORD *)long long __p = v3;
  }
  sub_100328018((uint64_t)v9, v1 + 32);
  sub_100D0B23C(v2, 0, (unsigned __int8 **)__p, (uint64_t)v9);
  sub_10030C800(v9);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_100328A60(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100D18984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
}

uint64_t sub_100D189C8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100D18A60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void sub_100D18AE0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 5;
    if (*((char *)v1 + 63) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I user wants to manage remote plan (%s)", buf, 0xCu);
  }
  uint64_t v5 = (char *)operator new(0x330uLL);
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *(void *)uint64_t v5 = off_101A518B0;
  uint64_t v6 = (std::string *)(v5 + 24);
  bzero(v5 + 24, 0x311uLL);
  uint64_t v7 = dispatch_group_create();
  uint64_t v8 = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v8);
    dispatch_retain(v8);
    dispatch_group_enter(v8);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
  v5[808] = 0;
  long long v48 = 0uLL;
  if (*(unsigned char *)(v2 + 1224)) {
    uint64_t v9 = v2 + 1368;
  }
  else {
    uint64_t v9 = v2 + 328;
  }
  uint64_t v11 = v9 + 32;
  uint64_t v10 = *(void *)(v9 + 32);
  if (*(void *)(v11 + 8) == v10)
  {
    uint64_t v16 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "csn not available", buf, 2u);
    }
    v5[808] = 6;
LABEL_59:
    sub_10004D2C8((std::__shared_weak_count *)v5);
    if (v8)
    {
      dispatch_group_leave(v8);
      dispatch_release(v8);
    }
    *(void *)std::string buf = v2;
    long long v31 = *(std::__shared_weak_count **)(v2 + 16);
    if (v31)
    {
      uint64_t v32 = *(void *)(v2 + 8);
      long long v33 = std::__shared_weak_count::lock(v31);
      if (v33)
      {
        *(void *)&uint8_t buf[8] = v32;
        char v40 = v33;
        atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v33);
        uint64_t v41 = v5 + 24;
        long long v42 = v5;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
        sub_100D189C8((uint64_t)&v43, (uint64_t)(v1 + 1));
        operator new();
      }
    }
    sub_100088B9C();
  }
  long long v48 = *(_OWORD *)(v10 + 16);
  bzero(buf, 0x318uLL);
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 160) + 224))(buf);
  if (buf[0])
  {
    if (v47)
    {
      unint64_t v12 = sub_100CCD974(v44, (uint64_t *)(v2 + 304));
      if ((v12 & 0xFF00000000) != 0)
      {
        unsigned __int8 v14 = v12;
        unsigned int v15 = v12 >> 8;
LABEL_25:
        ctu::hex((uint64_t *)v49, (ctu *)&v48, (const void *)0x10, v13);
        sub_1008EB2C8((uint64_t *)(v2 + 896), (uint64_t)v49, v34);
        p_p = (char *)&__p;
        if (SHIBYTE(v46) < 0) {
          operator delete((void *)__p);
        }
        long long __p = *(_OWORD *)v34;
        long long v46 = v35;
        HIBYTE(v35) = 0;
        v34[0] = 0;
        if (v50 < 0) {
          operator delete(v49[0]);
        }
        uint64_t v20 = HIBYTE(v46);
        if (SHIBYTE(v46) < 0) {
          uint64_t v20 = *((void *)&__p + 1);
        }
        if (!v20)
        {
          if (SHIBYTE(v46) < 0)
          {
            *((void *)&__p + 1) = 11;
            p_p = (char *)__p;
          }
          else
          {
            HIBYTE(v46) = 11;
          }
          strcpy(p_p, "Apple Watch");
        }
        sub_100D0180C(v2, v14 | (v15 << 8), 0, (uint64_t)(v1 + 5), (uint64_t)v44);
LABEL_41:
        uint64_t v22 = sub_10082550C(buf);
        std::string::operator=(v6, (const std::string *)v22);
        __int16 v23 = *((_WORD *)v22 + 12);
        v5[50] = v22[26];
        *((_WORD *)v5 + 24) = v23;
        std::string::operator=((std::string *)(v5 + 56), (const std::string *)(v22 + 32));
        sub_100827168(v5 + 80, (uint64_t)(v22 + 56));
        sub_1008272B4((uint64_t)(v5 + 424), (uint64_t)(v22 + 400));
        sub_100179AF8((std::string *)(v5 + 776), (const std::string *)(v22 + 752));
        if (!buf[0]) {
          __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
        }
        if (!(_BYTE)v42) {
          goto LABEL_57;
        }
        if (v8)
        {
          dispatch_retain(v8);
          dispatch_group_enter(v8);
        }
        atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
        if (v5[47] < 0)
        {
          if (*((void *)v5 + 4))
          {
LABEL_47:
            uint64_t v24 = *(void *)(v2 + 144);
            *(void *)long long v34 = v2;
            uint64_t v25 = *(std::__shared_weak_count **)(v2 + 16);
            if (!v25 || (uint64_t v26 = *(void *)(v2 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v28 = v27;
            *(void *)&v34[8] = v26;
            uint64_t v35 = v27;
            atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v27);
            uint64_t v36 = v8;
            if (v8)
            {
              dispatch_retain(v8);
              dispatch_group_enter(v8);
            }
            long long v37 = v5 + 24;
            uint64_t v38 = v5;
            atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
            char v51 = 0;
            xpc_object_t v29 = operator new(0x38uLL);
            void *v29 = off_101A51C38;
            v29[1] = v2;
            v29[2] = v26;
            v29[3] = v28;
            *(void *)&v34[8] = 0;
            uint64_t v35 = 0;
            uint64_t v36 = 0;
            v29[4] = v8;
            v29[5] = v6;
            v29[6] = v5;
            long long v37 = 0;
            uint64_t v38 = 0;
            char v51 = v29;
            (*(void (**)(uint64_t, long long *, std::string *, void **))(*(void *)v24 + 160))(v24, &v48, v6, v49);
            sub_10037DCD8(v49);
LABEL_55:
            sub_10004D2C8((std::__shared_weak_count *)v5);
            if (v8)
            {
              dispatch_group_leave(v8);
              dispatch_release(v8);
            }
LABEL_57:
            (*(void (**)(void, void))(**(void **)(v2 + 208) + 128))(*(void *)(v2 + 208), v14 | (v15 << 8));
            goto LABEL_58;
          }
        }
        else if (v5[47])
        {
          goto LABEL_47;
        }
        long long v30 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v34 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Mising Iccid", v34, 2u);
        }
        goto LABEL_55;
      }
      if (*(unsigned char *)(v2 + 1224))
      {
        unsigned int v15 = 0;
        unsigned __int8 v14 = 0;
        goto LABEL_25;
      }
    }
    else if (*(unsigned char *)(v2 + 1224))
    {
      unsigned int v15 = 0;
      unsigned __int8 v14 = 0;
      goto LABEL_41;
    }
    long long v21 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v34 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to find slot matching ManageAccount iccid", v34, 2u);
    }
    char v18 = 5;
  }
  else
  {
    char v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v34 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Websheet launch info not found", v34, 2u);
    }
    char v18 = 6;
  }
  v5[808] = v18;
LABEL_58:
  sub_10082783C(buf);
  goto LABEL_59;
}

void sub_100D19234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21)
{
  sub_10037DCD8((void *)(v23 - 128));
  sub_100D0ECC4(&a11);
  sub_10004D2C8(v21);
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  sub_10082783C(&a17);
  sub_10004D2C8(v21);
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
    dispatch_group_leave(v22);
    dispatch_release(v22);
    dispatch_release(v22);
  }
  sub_10004D2C8(v21);
  sub_100D19340(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D19340(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    sub_100544BC4((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100D193A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A518B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D193C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A518B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D19414(uint64_t a1)
{
  uint64_t v2 = a1 + 80;
  if (*(unsigned char *)(a1 + 800) && *(char *)(a1 + 799) < 0) {
    operator delete(*(void **)(a1 + 776));
  }
  if (*(unsigned char *)(a1 + 768)) {
    sub_100310520(a1 + 424);
  }
  sub_1003107E0(v2);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    operator delete(v3);
  }
}

void *sub_100D194A4(void *result)
{
  uint64_t v1 = (void *)*result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100544BC4(v1 + 5);
    uint64_t v2 = (std::__shared_weak_count *)v1[4];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[2];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

void *sub_100D1950C(void *a1)
{
  uint64_t v20 = a1;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4) {
      uint64_t v5 = a1[1];
    }
    else {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v4 = 0;
  }
  uint64_t v6 = a1[8];
  if (!v6)
  {
    uint64_t v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
      if (!v4) {
        return sub_100D194A4(&v20);
      }
    }
    else if (!v4)
    {
      return sub_100D194A4(&v20);
    }
LABEL_13:
    sub_10004D2C8(v4);
    return sub_100D194A4(&v20);
  }
  if (!v5)
  {
LABEL_18:
    *(void *)std::string buf = 0;
    __p[0] = 0;
    sub_100D19B10(v6, (uint64_t)buf, (uint64_t)__p, 1);
LABEL_19:
    sub_100057D78((const void **)__p);
    sub_1000FE824((const void **)buf);
    if (!v4) {
      return sub_100D194A4(&v20);
    }
    goto LABEL_13;
  }
  uint64_t v7 = a1[3];
  if (!v7)
  {
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid manageAccountInfoPtr", buf, 2u);
      uint64_t v6 = a1[8];
    }
    goto LABEL_18;
  }
  char v8 = *(unsigned char *)(v7 + 784);
  if (v8)
  {
    *(void *)std::string buf = 0;
    __p[0] = 0;
    sub_100D19B10(v6, (uint64_t)buf, (uint64_t)__p, v8);
    goto LABEL_19;
  }
  CFStringRef URLString = 0;
  unint64_t v12 = (_OWORD *)(v7 + 32);
  if (*(char *)(v7 + 55) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v7 + 32), *(void *)(v7 + 40));
  }
  else
  {
    *(_OWORD *)long long __dst = *v12;
    uint64_t v22 = *(void *)(v7 + 48);
  }
  if (SHIBYTE(v22) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v26 = v22;
  }
  CFStringRef v24 = 0;
  if (SHIBYTE(v26) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v30 = v26;
  }
  CFStringRef v27 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v13 = v24;
    CFStringRef v24 = v27;
    CFTypeRef cf = v13;
    sub_1000558F4(&cf);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(*(void **)buf);
  }
  CFStringRef URLString = v24;
  CFStringRef v24 = 0;
  sub_1000558F4((const void **)&v24);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(__dst[0]);
  }
  __p[0] = 0;
  __p[0] = CFURLCreateWithString(kCFAllocatorDefault, URLString, 0);
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeRef v15 = cf;
    CFTypeRef cf = Mutable;
    *(void *)std::string buf = v15;
    sub_10005717C((const void **)buf);
  }
  if (*(unsigned char *)(v7 + 392))
  {
    CFStringRef v27 = (const __CFString *)cf;
    if (cf)
    {
      CFRetain(cf);
      if (!*(unsigned char *)(v7 + 392)) {
        sub_10016C840();
      }
    }
    uint64_t v16 = (void *)(v7 + 56);
    sub_100DDB308((CFMutableDictionaryRef *)&v27, (long long *)(v7 + 56));
    sub_10005717C((const void **)&v27);
    char v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v7 + 79) < 0) {
        uint64_t v16 = (void *)*v16;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v16;
LABEL_55:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Manage Plan PostData: %s", buf, 0xCu);
    }
  }
  else if (*(unsigned char *)(v7 + 776))
  {
    CFStringRef v27 = (const __CFString *)cf;
    if (cf)
    {
      CFRetain(cf);
      if (!*(unsigned char *)(v7 + 776)) {
        sub_10016C840();
      }
    }
    char v18 = (void *)(v7 + 752);
    sub_100DDD340((CFMutableDictionaryRef *)&v27, v7 + 752);
    sub_10005717C((const void **)&v27);
    char v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(unsigned char *)(v7 + 776)) {
        sub_10016C840();
      }
      if (*(char *)(v7 + 775) < 0) {
        char v18 = (void *)*v18;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v18;
      goto LABEL_55;
    }
  }
  uint64_t v19 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v7 + 55) < 0) {
      unint64_t v12 = *(_OWORD **)v12;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Manage Plan Url: %s", buf, 0xCu);
  }
  *(void **)std::string buf = __p[0];
  if (__p[0]) {
    CFRetain(__p[0]);
  }
  sub_10004EFE4(&v24, &cf);
  sub_100D19B10(a1[8], (uint64_t)buf, (uint64_t)&v24, *(unsigned char *)(v7 + 784));
  sub_100057D78((const void **)&v24);
  sub_1000FE824((const void **)buf);
  sub_10005717C(&cf);
  sub_1000FE824((const void **)__p);
  sub_1000558F4((const void **)&URLString);
  if (v4) {
    goto LABEL_13;
  }
  return sub_100D194A4(&v20);
}

void sub_100D19A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, const void *a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char a29,int a30,const void *a31)
{
  sub_10005717C(&a31);
  sub_1000FE824((const void **)&__p);
  sub_1000558F4(&a18);
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_100D194A4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100D19B10(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  char v5 = a4;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, a3, &v5);
}

uint64_t *sub_100D19B60(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  (***(void (****)(long long *__return_ptr))(*(void *)v1 + 128))(&v8);
  long long v9 = v8;
  long long v8 = 0uLL;
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (*((void *)&v9 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  if (isValidSimSlot)
  {
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    *(void *)&long long v9 = _NSConcreteStackBlock;
    *((void *)&v9 + 1) = 1174405120;
    uint64_t v10 = sub_100D19DB4;
    uint64_t v11 = &unk_101A518F0;
    uint64_t v12 = v2;
    sub_100D189C8((uint64_t)v13, v1 + 16);
    char v15 = *(unsigned char *)(v1 + 12);
    int v14 = *(_DWORD *)(v1 + 8);
    sub_100CFE56C(v2, v4, (uint64_t)&v9);
    sub_100544BC4(v13);
  }
  else
  {
    *(void *)&long long v9 = 0;
    *(void *)&long long v8 = 0;
    sub_100D19B10(*(void *)(v1 + 40), (uint64_t)&v9, (uint64_t)&v8, 6);
    sub_100057D78((const void **)&v8);
    sub_1000FE824((const void **)&v9);
  }
  sub_100D19D64(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100D19D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, const void *a13)
{
}

uint64_t *sub_100D19D64(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100544BC4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100D19DB4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)&long long v48 = a2;
  *((void *)&v48 + 1) = a3;
  if (a4)
  {
    uint64_t v42 = 0;
    uint64_t v41 = 0;
    sub_100D19B10(*(void *)(a1 + 64), (uint64_t)&v42, (uint64_t)&v41, a4);
    sub_100057D78(&v41);
    char v5 = (const void **)&v42;
LABEL_10:
    sub_1000FE824(v5);
    return;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if ((sub_100CFDC54(v6, *(unsigned __int8 *)(a1 + 76), (uint64_t)&v48) & 1) == 0)
  {
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    sub_100D19B10(*(void *)(a1 + 64), (uint64_t)&v40, (uint64_t)&v39, 3);
    sub_100057D78(&v39);
    char v5 = (const void **)&v40;
    goto LABEL_10;
  }
  *(_DWORD *)(v6 + 1040) = *(_DWORD *)(a1 + 72);
  (*(void (**)(void, long long *))(**(void **)(v6 + 256) + 8))(*(void *)(v6 + 256), &v48);
  *(_DWORD *)((char *)v38 + 3) = 0;
  v38[0] = 0;
  long long v37 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(v6 + 128) + 128))(&v37);
  if (v37) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    *(void *)std::string buf = 0;
    long long v21 = 0;
    uint64_t v22 = 0;
    ctu::cf::assign();
    v38[0] = 0;
    *(_DWORD *)((char *)v38 + 3) = 0;
  }
  sub_1000558F4(&v37);
  sub_1008EB218((uint64_t *)(v6 + 896), (uint64_t)buf);
  int v8 = buf[0];
  if (v35 < 0) {
    operator delete(__p);
  }
  if (v33 < 0) {
    operator delete(v32);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v23 < 0) {
    operator delete(v21);
  }
  if (v8 == 2) {
    unsigned __int8 v9 = 2;
  }
  else {
    unsigned __int8 v9 = 1;
  }
  v10.n128_f64[0] = sub_1008EB218((uint64_t *)(v6 + 896), (uint64_t)buf);
  int v11 = v36;
  if (v35 < 0) {
    operator delete(__p);
  }
  if (v33 < 0) {
    operator delete(v32);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v23 < 0) {
    operator delete(v21);
  }
  uint64_t v12 = *(void *)(v6 + 208);
  __dst[0] = 0;
  __dst[1] = 0;
  *(_DWORD *)char v18 = v38[0];
  *(_DWORD *)&v18[3] = *(_DWORD *)((char *)v38 + 3);
  char v19 = 0;
  (*(void (**)(uint8_t *__return_ptr, __n128))(**(void **)(v6 + 128) + 640))(buf, v10);
  uint64_t v16 = 0;
  uint64_t v13 = (*(uint64_t (**)(void, const void **, void))(**(void **)buf + 136))(*(void *)buf, &v16, *(unsigned int *)(v6 + 1040));
  (*(void (**)(uint64_t, void **, void, void, BOOL, uint64_t))(*(void *)v12 + 88))(v12, __dst, 0, v9, v11 != 1, v13);
  sub_100057D78(&v16);
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v19 < 0) {
    operator delete(__dst[0]);
  }
  int v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), *(unsigned int *)(a1 + 72));
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I get signup info via carrier entitlement", buf, 2u);
  }
  v47[0] = 0;
  *(void *)uint64_t v43 = v6;
  *(_DWORD *)&v43[8] = *(_DWORD *)(a1 + 72);
  *(_OWORD *)&v43[12] = v48;
  sub_100D189C8((uint64_t)v44, a1 + 40);
  long long v46 = 0;
  char v15 = (char *)operator new(0x48uLL);
  *(void *)char v15 = off_101A51930;
  *(_OWORD *)(v15 + 8) = *(_OWORD *)v43;
  *(_OWORD *)(v15 + 20) = *(_OWORD *)&v43[12];
  sub_100D189C8((uint64_t)(v15 + 40), (uint64_t)v44);
  long long v46 = v15;
  sub_100D09A28(v6, (uint64_t)v47, (uint64_t)v45);
  sub_100345BCC(v45);
  sub_100544BC4(v44);
}

void sub_100D1A290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,char a44,int a45,__int16 a46,char a47,char a48,int a49,__int16 a50,char a51,char a52)
{
  operator delete(v52);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1A378(uint64_t a1, uint64_t a2)
{
  return sub_100D189C8(a1 + 40, a2 + 40);
}

void *sub_100D1A384(uint64_t a1)
{
  return sub_100544BC4((void *)(a1 + 40));
}

void *sub_100D1A38C(void *a1)
{
  *a1 = off_101A51930;
  sub_100544BC4(a1 + 5);
  return a1;
}

void sub_100D1A3D0(void *a1)
{
  *a1 = off_101A51930;
  sub_100544BC4(a1 + 5);

  operator delete();
}

char *sub_100D1A434(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v2 = off_101A51930;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 20) = *(_OWORD *)(a1 + 20);
  sub_100D189C8((uint64_t)(v2 + 40), a1 + 40);
  return v2;
}

void sub_100D1A49C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1A4B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A51930;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 20) = *(_OWORD *)(a1 + 20);
  *(_OWORD *)(a2 + 8) = v2;
  return sub_100D189C8(a2 + 40, a1 + 40);
}

void *sub_100D1A4EC(uint64_t a1)
{
  return sub_100544BC4((void *)(a1 + 40));
}

void sub_100D1A4F4(void *a1)
{
  sub_100544BC4(a1 + 5);

  operator delete(a1);
}

const void **sub_100D1A530(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (*(uint64_t (**)(void, void))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), *(unsigned int *)(a1 + 16));
  if (v5 && *(unsigned char *)(a3 + 392))
  {
    int v8 = (NSObject **)v7;
    CFStringRef v36 = 0;
    if (*(char *)(a3 + 55) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
    }
    else
    {
      long long __dst = *(_OWORD *)(a3 + 32);
      uint64_t v35 = *(void *)(a3 + 48);
    }
    if (SHIBYTE(v35) < 0)
    {
      sub_10004FC84(&v38, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v38 = __dst;
      uint64_t v39 = v35;
    }
    CFStringRef v37 = 0;
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(__p, (void *)v38, *((unint64_t *)&v38 + 1));
    }
    else
    {
      *(_OWORD *)long long __p = v38;
      uint64_t v20 = v39;
    }
    CFMutableDictionaryRef v40 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v10 = v37;
      CFStringRef v37 = (const __CFString *)v40;
      CFURLRef v41 = (CFURLRef)v10;
      sub_1000558F4((const void **)&v41);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    CFStringRef v36 = v37;
    CFStringRef v37 = 0;
    sub_1000558F4((const void **)&v37);
    if (SHIBYTE(v39) < 0) {
      operator delete((void *)v38);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete((void *)__dst);
    }
    CFURLRef v41 = 0;
    CFURLRef v11 = CFURLCreateWithString(kCFAllocatorDefault, v36, 0);
    CFMutableDictionaryRef v40 = 0;
    CFURLRef v41 = v11;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v13 = v40;
      CFMutableDictionaryRef v40 = Mutable;
      __p[0] = v13;
      sub_10005717C((const void **)__p);
    }
    CFStringRef v37 = (const __CFString *)v40;
    if (v40) {
      CFRetain(v40);
    }
    if (!*(unsigned char *)(a3 + 392)) {
      sub_10016C840();
    }
    sub_100DDB308((CFMutableDictionaryRef *)&v37, (long long *)(a3 + 56));
    sub_10005717C((const void **)&v37);
    (*(void (**)(long long *__return_ptr))(**(void **)(v6 + 128) + 648))(&v38);
    if ((**(unsigned int (***)(void, void))v38)(v38, *(unsigned int *)(a1 + 16)))
    {
      v14.n128_f64[0] = sub_1008EB218((uint64_t *)(v6 + 896), (uint64_t)__p);
      BOOL v15 = LOBYTE(__p[0]) == 1;
      if (v33 < 0) {
        operator delete(v32);
      }
      if (v31 < 0) {
        operator delete(v30);
      }
      if (v29 < 0) {
        operator delete(v28);
      }
      if (v27 < 0) {
        operator delete(v26);
      }
      if (v25 < 0) {
        operator delete(v24);
      }
      if (v23 < 0) {
        operator delete(v22);
      }
      if (v21 < 0) {
        operator delete(__p[1]);
      }
    }
    else
    {
      BOOL v15 = 0;
    }
    if (*((void *)&v38 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v38 + 1));
    }
    if (v15)
    {
      uint64_t v16 = *v8;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I carrier needs VoLTE setting to default", (uint8_t *)__p, 2u);
      }
      (*(void (**)(void **__return_ptr))(**(void **)(v6 + 128) + 648))(__p);
      (*(void (**)(void *))(*(void *)__p[0] + 16))(__p[0]);
      if (__p[1]) {
        sub_10004D2C8((std::__shared_weak_count *)__p[1]);
      }
      (*(void (**)(void **__return_ptr))(**(void **)(v6 + 128) + 648))(__p);
      (*(void (**)(void *))(*(void *)__p[0] + 8))(__p[0]);
      if (__p[1]) {
        sub_10004D2C8((std::__shared_weak_count *)__p[1]);
      }
    }
    uint64_t v17 = *(void *)(v6 + 256);
    if (v17)
    {
      __p[0] = 0;
      (*(void (**)(uint64_t, void **, __n128))(*(void *)v17 + 176))(v17, __p, v14);
      if (__p[0]) {
        _Block_release(__p[0]);
      }
    }
    *(void *)&long long v38 = v41;
    if (v41) {
      CFRetain(v41);
    }
    sub_10004EFE4(&v18, (CFTypeRef *)&v40);
    sub_100D19B10(*(void *)(a1 + 64), (uint64_t)&v38, (uint64_t)&v18, 0);
    sub_100057D78(&v18);
    sub_1000FE824((const void **)&v38);
    sub_10005717C((const void **)&v40);
    sub_1000FE824((const void **)&v41);
    return sub_1000558F4((const void **)&v36);
  }
  else
  {
    __p[0] = 0;
    *(void *)&long long v38 = 0;
    sub_100D19B10(*(void *)(a1 + 64), (uint64_t)__p, (uint64_t)&v38, 5);
    sub_100057D78((const void **)&v38);
    sub_1000FE824((const void **)__p);
    __n128 result = *(const void ***)(v6 + 256);
    if (result) {
      return (const void **)(*((uint64_t (**)(const void **, uint64_t))*result + 19))(result, a1 + 20);
    }
  }
  return result;
}

void sub_100D1AA44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *aBlock, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_1000558F4((const void **)(v16 - 104));
  if (*(char *)(v16 - 73) < 0) {
    operator delete(*(void **)(v16 - 96));
  }
  if (*(char *)(v16 - 121) < 0) {
    operator delete(*(void **)(v16 - 144));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D1AB64(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A51990)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D1ABA4()
{
  return &off_101A51990;
}

void sub_100D1ABB0(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 1216);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(v2 + 16))(v2, 0);
    uint64_t v3 = *(const void **)(v1 + 1216);
    *(void *)(v1 + 1216) = 0;
    if (v3) {
      _Block_release(v3);
    }
  }
  operator delete();
}

void sub_100D1AC2C()
{
}

uint64_t *sub_100D1AC58(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v32 = a1;
  uint64_t v33 = v1;
  uint64_t v2 = *(void *)v1;
  long long v63 = 0uLL;
  uint64_t v3 = v2 + 1368;
  if (!*(unsigned char *)(v2 + 1224)) {
    uint64_t v3 = v2 + 328;
  }
  uint64_t v4 = *(void *)(v3 + 32);
  if (*(void *)(v3 + 40) == v4 || !*(unsigned char *)(v3 + 24))
  {
    int v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Can't find CSN for active device", (uint8_t *)&buf, 2u);
    }
    (*(void (**)(void))(*(void *)(v1 + 32) + 16))();
    goto LABEL_97;
  }
  long long v63 = *(_OWORD *)(v4 + 16);
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 160) + 272))(&v42);
  uint64_t v5 = v42;
  uint64_t v6 = v43;
  if (v42 == v43)
  {
    unsigned __int8 v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No pending plans available", (uint8_t *)&buf, 2u);
    }
    goto LABEL_43;
  }
  if (*(void *)(v2 + 256))
  {
    uint64_t v7 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Another provisioning operation is ongoing", (uint8_t *)&buf, 2u);
    }
    goto LABEL_43;
  }
  CFStringRef v10 = (const void **)(v1 + 8);
  int v11 = *(char *)(v1 + 31);
  if (v11 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(v1 + 31);
  }
  else {
    uint64_t v12 = *(void *)(v1 + 16);
  }
  while (1)
  {
    uint64_t v13 = *(unsigned __int8 *)(v5 + 95);
    uint64_t v14 = (v13 & 0x80u) == 0 ? *(unsigned __int8 *)(v5 + 95) : *(void *)(v5 + 80);
    if (v14 == v12)
    {
      if (v11 >= 0) {
        BOOL v15 = (unsigned __int8 *)(v1 + 8);
      }
      else {
        BOOL v15 = (unsigned __int8 *)*v10;
      }
      if ((v13 & 0x80) == 0)
      {
        if (!*(unsigned char *)(v5 + 95)) {
          break;
        }
        uint64_t v16 = 0;
        while (*(unsigned __int8 *)(v5 + v16 + 72) == v15[v16])
        {
          if (v13 == ++v16) {
            goto LABEL_35;
          }
        }
        goto LABEL_33;
      }
      if (!memcmp(*(const void **)(v5 + 72), v15, *(void *)(v5 + 80))) {
        break;
      }
    }
LABEL_33:
    v5 += 312;
    if (v5 == v6) {
      goto LABEL_39;
    }
  }
LABEL_35:
  if (v5 == v6)
  {
LABEL_39:
    char v18 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if (v11 < 0) {
        CFStringRef v10 = (const void **)*v10;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Plan matching ICCID hash (%s) not found", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_43;
  }
  if (sub_100CFDC54(v2, 0, (uint64_t)&v63))
  {
    CFMutableDictionaryRef v40 = 0;
    CFURLRef v41 = 0;
    sub_100324590(&v40);
    if (*(char *)(v5 + 23) < 0) {
      uint64_t v17 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v17 = *(unsigned __int8 *)(v5 + 23);
    }
    if (v17) {
      std::string::operator=(v40, (const std::string *)v5);
    }
    if (*(char *)(v5 + 47) < 0) {
      uint64_t v20 = *(void *)(v5 + 32);
    }
    else {
      uint64_t v20 = *(unsigned __int8 *)(v5 + 47);
    }
    if (v20) {
      std::string::operator=(v40 + 2, (const std::string *)(v5 + 24));
    }
    char v21 = v40;
    v40[5].__r_.__value_.__s.__data_[2] = 1;
    if (*(char *)(v5 + 95) < 0) {
      uint64_t v22 = *(void *)(v5 + 80);
    }
    else {
      uint64_t v22 = *(unsigned __int8 *)(v5 + 95);
    }
    if (v22)
    {
      char v23 = (uint64_t *)&v21[4];
      std::string::size_type size = v21[4].__r_.__value_.__l.__size_;
      if (size >= v21[4].__r_.__value_.__r.__words[2])
      {
        uint64_t v25 = sub_10030E9EC(v23, (long long *)(v1 + 8));
      }
      else
      {
        sub_1000D87F8(v23, (long long *)(v1 + 8));
        uint64_t v25 = size + 24;
      }
      v21[4].__r_.__value_.__l.__size_ = v25;
    }
    else
    {
      uint64_t v26 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I iccidHash absent - queued install, removing the pending item", (uint8_t *)&buf, 2u);
      }
      (*(void (**)(void, long long *, uint64_t))(**(void **)(v2 + 160) + 48))(*(void *)(v2 + 160), &v63, v5 + 72);
    }
    uint64_t v27 = *(void *)(v2 + 160);
    if (*(char *)(v5 + 71) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v5 + 48), *(void *)(v5 + 56));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v5 + 48);
      uint64_t v39 = *(void *)(v5 + 64);
    }
    v45[0] = 0;
    char v46 = 0;
    sub_1003DB514((uint64_t)&buf, 0, (long long *)__dst, (uint64_t)v45, 0);
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v27 + 96))(v27, 1, &buf);
    if (v62) {
      sub_1000C584C((uint64_t)&v49);
    }
    if (v48 < 0) {
      operator delete(*((void **)&buf + 1));
    }
    if (v46) {
      sub_1000C584C((uint64_t)v45);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(__dst[0]);
    }
    (*(void (**)(void))(**(void **)(v2 + 96) + 16))(*(void *)(v2 + 96));
    uint64_t v28 = *(void *)(v2 + 256);
    CFStringRef v36 = v40;
    CFStringRef v37 = v41;
    if (v41) {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, long long *, std::string **))(*(void *)v28 + 24))(v28, &v63, &v36);
    if (v37) {
      sub_10004D2C8(v37);
    }
    (*(void (**)(void))(*(void *)(v1 + 32) + 16))();
    uint64_t v29 = *(void *)(v2 + 208);
    sub_100058DB0(v34, "");
    v30.n128_f64[0] = sub_1008EB218((uint64_t *)(v2 + 896), (uint64_t)&buf);
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t, BOOL, void, __n128))(*(void *)v29 + 88))(v29, v34, 3, 2, v61 == 1, 0, v30);
    if (v60 < 0) {
      operator delete(v59);
    }
    if (v58 < 0) {
      operator delete(v57);
    }
    if (v56 < 0) {
      operator delete(v55);
    }
    if (v54 < 0) {
      operator delete(v53);
    }
    if (v52 < 0) {
      operator delete(v51);
    }
    if (v50 < 0) {
      operator delete(v49);
    }
    if (v48 < 0) {
      operator delete(*((void **)&buf + 1));
    }
    if (v35 < 0) {
      operator delete(v34[0]);
    }
    if (v41) {
      sub_10004D2C8(v41);
    }
    goto LABEL_96;
  }
  char v19 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to create provisioning operation", (uint8_t *)&buf, 2u);
  }
LABEL_43:
  (*(void (**)(void))(*(void *)(v1 + 32) + 16))();
LABEL_96:
  *(void *)&long long buf = &v42;
  sub_1000C63B8((void ***)&buf);
LABEL_97:
  sub_100D1B4BC(&v33);
  return sub_100046B58((uint64_t *)&v32);
}

void sub_100D1B364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  if (a21) {
    sub_10004D2C8((std::__shared_weak_count *)a21);
  }
  a53 = (uint64_t)&a22;
  sub_1000C63B8((void ***)&a53);
  sub_100D1B4BC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D1B4BC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(const void **)(v1 + 32);
    if (v2) {
      _Block_release(v2);
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void *sub_100D1B524(void *a1)
{
  *a1 = off_101A519B0;
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D1B580(void *a1)
{
  *a1 = off_101A519B0;
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100D1B5FC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A519B0;
  sub_100D1BA98((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100D1B650(uint64_t a1, void *a2)
{
  *a2 = off_101A519B0;
  return sub_100D1BA98((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100D1B67C(uint64_t a1)
{
}

void sub_100D1B684(void *a1)
{
  sub_100D1BAF0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100D1B6C0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (!v2)
  {
    uint64_t v4 = 0;
    goto LABEL_33;
  }
  uint64_t v3 = a1[1];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4 || !a1[2])
  {
LABEL_33:
    *(void *)&long long v18 = 0;
    sub_100D0F50C(a1[4], (const void **)&v18, 4u);
    sub_100044D00((const void **)&v18);
    if (!v4) {
      return;
    }
    goto LABEL_34;
  }
  CFStringRef v37 = 0;
  long long v38 = 0;
  uint64_t v39 = 0;
  uint64_t v17 = v4;
  (***(void (****)(long long *__return_ptr))(v3 + 128))(&v29);
  long long v18 = v29;
  long long v29 = 0uLL;
  subscriber::makeSimSlotRange();
  if (*((void *)&v18 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
  }
  if (*((void *)&v29 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v29 + 1));
  }
  long long v34 = 0;
  char v35 = 0;
  uint64_t v36 = 0;
  uint64_t v6 = v38;
  uint64_t v5 = v39;
  uint64_t v7 = v37;
  v33[0] = v37;
  v33[1] = v39;
  void v33[2] = v38;
  if (v37 != v38)
  {
    do
    {
      if (((uint64_t (*)(void))v5)(*v7)) {
        break;
      }
      v33[0] = ++v7;
    }
    while (v7 != v6);
    uint64_t v7 = v38;
    uint64_t v5 = v39;
  }
  v32[0] = v7;
  v32[1] = v5;
  v32[2] = v7;
  sub_100D1BF74(&v34, v33, v32);
  *(void *)&long long v29 = 0;
  *((void *)&v29 + 1) = &v29;
  uint64_t v30 = 0x2000000000;
  char v31 = 0;
  v27[0] = 0;
  v27[1] = v27;
  void v27[2] = 0x2000000000;
  int v28 = 0;
  unsigned __int8 v9 = v37;
  int v8 = v38;
  if (v37 != v38)
  {
    unint64_t v10 = v35 - v34;
    int v11 = v39;
    while ((((uint64_t (*)(void))v11)(*v9) & 1) == 0)
    {
      if (++v9 == v8)
      {
        unsigned __int8 v9 = v8;
        break;
      }
    }
    uint64_t v12 = v38;
    if (v9 != v38)
    {
      unint64_t v13 = v10 >> 2;
      do
      {
        uint64_t v14 = *v9;
        *(void *)&long long v18 = _NSConcreteStackBlock;
        *((void *)&v18 + 1) = 1174405120;
        char v19 = sub_100D1BB44;
        uint64_t v20 = &unk_101A51A28;
        int v25 = v14;
        char v21 = v27;
        uint64_t v22 = &v29;
        uint64_t v23 = v3;
        char v26 = v13;
        BOOL v15 = (void *)a1[4];
        if (v15) {
          BOOL v15 = _Block_copy(v15);
        }
        aBlock = v15;
        sub_100CFE56C(v3, v14, (uint64_t)&v18);
        if (aBlock) {
          _Block_release(aBlock);
        }
        uint64_t v16 = v9 + 1;
        unsigned __int8 v9 = v8;
        if (v16 != v8)
        {
          unsigned __int8 v9 = v16;
          while ((((uint64_t (*)(void))v11)(*v9) & 1) == 0)
          {
            if (++v9 == v8)
            {
              unsigned __int8 v9 = v8;
              break;
            }
          }
        }
      }
      while (v9 != v12);
    }
  }
  _Block_object_dispose(v27, 8);
  _Block_object_dispose(&v29, 8);
  if (v34)
  {
    char v35 = v34;
    operator delete(v34);
  }
  uint64_t v4 = v17;
LABEL_34:
  sub_10004D2C8(v4);
}

void sub_100D1B9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *aBlock, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D1BA4C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A51A58)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D1BA8C()
{
  return &off_101A51A58;
}

uint64_t sub_100D1BA98(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void **)(a2 + 24);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 24) = v4;
  return a1;
}

void sub_100D1BAF0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D1BB44(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)&long long v27 = a2;
  *((void *)&v27 + 1) = a3;
  uint64_t v5 = *(void *)(a1 + 48);
  if (!a4)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 64);
    uint64_t v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    *(_OWORD *)long long __dst = 0u;
    long long v23 = 0u;
    uint64_t v7 = 1368;
    if (*(unsigned char *)(v5 + 1224))
    {
      uint64_t v8 = v5 + 1368;
    }
    else
    {
      uint64_t v7 = 328;
      uint64_t v8 = v5 + 328;
    }
    if (*(char *)(v8 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v5 + v7), *(void *)(v8 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v8;
      *(void *)&long long v23 = *(void *)(v8 + 16);
    }
    uint64_t v10 = *(void *)(v8 + 24);
    uint64_t v9 = *(void *)(v8 + 32);
    *(void *)&long long v25 = 0;
    *((void *)&v23 + 1) = v10;
    long long v24 = 0uLL;
    sub_100311ED8(&v24, v9, *(void *)(v8 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v8 + 40) - v9) >> 3));
    *((void *)&v25 + 1) = *(void *)(v8 + 56);
    LODWORD(v26) = *(_DWORD *)(v8 + 64);
    (*(void (**)(void ***__return_ptr))(**(void **)(v5 + 160) + 240))(&v28);
    int v11 = v28;
    sub_100D1568C((uint64_t)&v28);
    if (v11) {
      goto LABEL_22;
    }
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(v5 + 128) + 640))(&v20);
    (*(void (**)(void ***__return_ptr))(*(void *)v20 + 48))(&v28);
    if (v30 < 0)
    {
      BOOL v12 = __p == 0;
      operator delete(v28);
    }
    else
    {
      BOOL v12 = v30 == 0;
    }
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (v12) {
      goto LABEL_22;
    }
    sub_100CF9568((uint64_t)&v28, v5, v6);
    if (!(_BYTE)v28) {
      goto LABEL_22;
    }
    if (v31 < 0) {
      operator delete(__p);
    }
    if (BYTE13(v25) && BYTE12(v25) == 1
      || ((*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 160) + 168))(*(void *)(v5 + 160), v6) & 1) != 0
      || *(void *)(v5 + 256))
    {
LABEL_22:
      int v13 = 0;
    }
    else
    {
      int v13 = 0;
      if (*((void *)&v24 + 1) != (void)v24 && BYTE8(v23))
      {
        long long v27 = *(_OWORD *)(v24 + 16);
        int v13 = 1;
      }
    }
    int v28 = (void **)&v24;
    sub_1000C56F4(&v28);
    if (SBYTE7(v23) < 0)
    {
      operator delete(__dst[0]);
      if (!v13) {
        goto LABEL_31;
      }
    }
    else if (!v13)
    {
      goto LABEL_31;
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(_DWORD *)(v14 + 24)) {
      int v15 = 3;
    }
    else {
      int v15 = *(_DWORD *)(a1 + 64);
    }
    *(_DWORD *)(v14 + 24) = v15;
  }
LABEL_31:
  if (++*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == *(unsigned char *)(a1 + 68))
  {
    int v16 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v17 = *(const void **)(a1 + 56);
    if (v17) {
      long long v18 = _Block_copy(v17);
    }
    else {
      long long v18 = 0;
    }
    char v19 = v18;
    sub_100D05A78(v5, v16, (uint64_t)&v27, (uint64_t *)&v19);
    if (v18) {
      _Block_release(v18);
    }
  }
}

void sub_100D1BE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void *sub_100D1BF1C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)(a2 + 56);
  if (result) {
    __n128 result = _Block_copy(result);
  }
  *(void *)(a1 + 56) = result;
  return result;
}

void sub_100D1BF50(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 56);
  if (v1) {
    _Block_release(v1);
  }
}

void *sub_100D1BF74(void *a1, unsigned int **a2, unsigned int **a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  if (*a2 == *a3)
  {
    unint64_t v8 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = a2[1];
    uint64_t v10 = a2[2];
    do
    {
      int v11 = v6 + 1;
      uint64_t v6 = v10;
      if (v11 != v10)
      {
        uint64_t v6 = v11;
        while ((((uint64_t (*)(void))v9)(*v6) & 1) == 0)
        {
          if (++v6 == v10)
          {
            uint64_t v6 = v10;
            break;
          }
        }
      }
      ++v8;
    }
    while (v6 != v7);
  }
  long long v15 = *(_OWORD *)a2;
  int v16 = a2[2];
  long long v13 = *(_OWORD *)a3;
  uint64_t v14 = a3[2];
  sub_100D1C058(a1, &v15, &v13, v8);
  return a1;
}

void *sub_100D1C058(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = (uint64_t)result;
    sub_10005CCE8(result, a4);
    long long v9 = *a2;
    uint64_t v10 = *((void *)a2 + 2);
    long long v7 = *a3;
    uint64_t v8 = *((void *)a3 + 2);
    return (void *)sub_100D1C0F0(v6, (uint64_t)&v9, &v7);
  }
  return result;
}

void sub_100D1C0D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D1C0F0(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(_DWORD **)a2;
  uint64_t v5 = (_DWORD *)*a3;
  if (*(void *)a2 == *a3)
  {
    uint64_t v8 = *(_DWORD **)(result + 8);
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(a2 + 8);
    long long v7 = *(_DWORD **)(a2 + 16);
    uint64_t v8 = *(_DWORD **)(result + 8);
    do
    {
      long long v9 = v4 + 1;
      *uint64_t v8 = *v4;
      uint64_t v4 = v7;
      if (v9 != v7)
      {
        uint64_t v4 = v9;
        while (1)
        {
          __n128 result = v6(*v4);
          if (result) {
            break;
          }
          if (++v4 == v7)
          {
            uint64_t v4 = v7;
            break;
          }
        }
      }
      ++v8;
    }
    while (v4 != v5);
  }
  *(void *)(v3 + 8) = v8;
  return result;
}

void sub_100D1C194(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *sub_100D1C19C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100D1C220(uint64_t **a1)
{
  uint64_t v1 = *a1;
  long long v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = (char *)operator new(0x58uLL);
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 1) = 0;
  *(void *)uint64_t v5 = off_101A51A78;
  *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  v5[40] = *(unsigned char *)(v3 + 16);
  *((void *)v5 + 6) = v4;
  *(void *)(v3 + 24) = 0;
  sub_100540CCC((uint64_t)(v5 + 56), v3 + 32);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
  sub_10004D2C8((std::__shared_weak_count *)v5);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v5 + 4);
  *((void *)v5 + 3) = 0;
  *((void *)v5 + 4) = 0;
  if (v6) {
    sub_10004D2C8(v6);
  }
  if ((sub_100CF965C(v2) & 1) == 0)
  {
    v5[40] = 5;
    if (!v5) {
      goto LABEL_14;
    }
LABEL_13:
    sub_10004D2C8((std::__shared_weak_count *)v5);
    goto LABEL_14;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v7 = *(void *)(v2 + 160);
  sub_100058DB0(&__p, "");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v7 + 264))(&v19, v7, &__p);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p);
  }
  uint64_t v8 = v19;
  uint64_t v9 = v20;
  if (v19 == v20)
  {
    v5[40] = 1;
  }
  else
  {
    do
    {
      sub_100CFB2A4(v2, v8);
      v8 += 72;
    }
    while (v8 != v9);
    long long __p = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    sub_100CFB894((uint64_t)&__p, v2);
    sub_100CD1D9C(&v19, (uint64_t)&__p, &v15);
    long long v10 = v15;
    long long v15 = 0uLL;
    int v11 = (std::__shared_weak_count *)*((void *)v5 + 4);
    *(_OWORD *)(v5 + 24) = v10;
    if (v11)
    {
      sub_10004D2C8(v11);
      if (*((void *)&v15 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
      }
    }
    v5[40] = 0;
    sub_1000DA2E4(v17);
  }
  long long __p = &v19;
  sub_1003DD6DC((void ***)&__p);
  if (v5) {
    goto LABEL_13;
  }
LABEL_14:
  sub_100D1C488((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100D1C410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *__p, char *a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  sub_1000DA2E4(a14);
  long long __p = &a19;
  sub_1003DD6DC((void ***)&__p);
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_100D1C488(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D1C488(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100540A0C((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100D1C4DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A51A78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D1C4FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A51A78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D1C550(uint64_t a1)
{
  return sub_100540A5C(a1 + 24);
}

uint64_t *sub_100D1C55C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  long long v15 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v5 = (char *)operator new(0x58uLL);
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 1) = 0;
  *(void *)uint64_t v5 = off_101A51AC8;
  *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  v5[40] = *(unsigned char *)(v3 + 16);
  *((void *)v5 + 6) = v4;
  *(void *)(v3 + 24) = 0;
  sub_100541090((uint64_t)(v5 + 56), v3 + 32);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
  sub_10004D2C8((std::__shared_weak_count *)v5);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v5 + 4);
  *((void *)v5 + 3) = 0;
  *((void *)v5 + 4) = 0;
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (sub_100CF965C(v2))
  {
    uint64_t v20 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0uLL;
    uint64_t v18 = 0;
    long long v19 = 0uLL;
    uint64_t v7 = *(void *)(v2 + 160);
    uint64_t v20 = 0;
    (*(void (**)(long long *__return_ptr))(*(void *)v7 + 264))(&v19);
    uint64_t v8 = v19;
    if ((void)v19 == *((void *)&v19 + 1))
    {
      int v11 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        long long v13 = __p;
        if (v18 < 0) {
          long long v13 = (void **)__p[0];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "did not find device info for EID (%s)", (uint8_t *)&buf, 0xCu);
      }
      v5[40] = 16;
    }
    else
    {
      sub_100CFB2A4(v2, v19);
      long long buf = 0uLL;
      uint64_t v22 = 0;
      sub_100CFB894((uint64_t)&buf, v2);
      sub_100CD19E8(v8, (uint64_t)&buf, &v16);
      uint64_t v9 = (std::__shared_weak_count *)*((void *)v5 + 4);
      *(_OWORD *)(v5 + 24) = v16;
      if (v9) {
        sub_10004D2C8(v9);
      }
      long long v10 = (char *)*((void *)&buf + 1);
      v5[40] = 0;
      sub_1000DA2E4(v10);
    }
    *(void *)&long long buf = &v19;
    sub_1003DD6DC((void ***)&buf);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    v5[40] = 5;
  }
  if (v5) {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  sub_100D1C85C((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100D1C7D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,void **a22,char *a23)
{
  sub_1000DA2E4(a23);
  a22 = (void **)&a19;
  sub_1003DD6DC(&a22);
  if (a18 < 0) {
    operator delete(a13);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_100D1C85C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D1C85C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 16));
    sub_100540DD0((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100D1C8C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A51AC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D1C8E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A51AC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D1C938(uint64_t a1)
{
  return sub_100540E20(a1 + 24);
}

void sub_100D1C944(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (*(void *)(v1 + 256))
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 128) + 640))(buf);
    uint64_t v8 = 0;
    int v2 = (*(uint64_t (**)(void, const void **, void))(**(void **)buf + 136))(*(void *)buf, &v8, *(unsigned int *)(v1 + 1040));
    sub_100057D78(&v8);
    if (v10) {
      sub_10004D2C8(v10);
    }
    uint64_t v3 = *(NSObject **)(v1 + 40);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I websheet dismiss", buf, 2u);
      }
      uint64_t v5 = *(void **)(v1 + 256);
      uint64_t v6 = (void (**)(void *))(*v5 + 168);
    }
    else
    {
      if (v4)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I websheet quit", buf, 2u);
      }
      uint64_t v5 = *(void **)(v1 + 256);
      uint64_t v6 = (void (**)(void *))(*v5 + 184);
    }
    (*v6)(v5);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I no provisioning operation", buf, 2u);
    }
  }
  operator delete();
}

void sub_100D1CB44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

uint64_t **sub_100D1CB8C(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 1;
    long long v10 = (char *)operator new(0xA0uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *(_OWORD *)(v10 + 136) = 0u;
    *((void *)v10 + 19) = 0;
    sub_100046C38(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    sub_100344BCC((uint64_t)v12, 0);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_100D1CC7C(uint64_t a1, char *a2)
{
  if (*(unsigned char *)a1)
  {
    sub_100058DB0(&v4, a2);
    uint64_t v3 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v3);
    }
    *(_OWORD *)uint64_t v3 = v4;
    *(void *)(a1 + 24) = v5;
  }
  else
  {
    sub_100058DB0((void *)(a1 + 8), a2);
    *(unsigned char *)a1 = 1;
  }
}

void sub_100D1CCEC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A51B18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D1CD0C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A51B18;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D1CD60(uint64_t a1)
{
  uint64_t v2 = a1 + 80;
  if (*(unsigned char *)(a1 + 800) && *(char *)(a1 + 799) < 0) {
    operator delete(*(void **)(a1 + 776));
  }
  if (*(unsigned char *)(a1 + 768)) {
    sub_100310520(a1 + 424);
  }
  sub_1003107E0(v2);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    operator delete(v3);
  }
}

void *sub_100D1CDF0(void *a1)
{
  *a1 = off_101A51B68;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100345BCC(a1 + 4);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D1CE50(void *a1)
{
  *a1 = off_101A51B68;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100345BCC(a1 + 4);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100D1CED0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_101A51B68;
  sub_100D1D76C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100D1CF24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1CF38(uint64_t a1, void *a2)
{
  *a2 = off_101A51B68;
  return sub_100D1D76C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100D1CF64(uint64_t a1)
{
}

void sub_100D1CF6C(void *a1)
{
  sub_100D1D7F0(a1 + 1);

  operator delete(a1);
}

void sub_100D1CFA8(void *a1, unsigned __int8 *a2)
{
  uint64_t v42 = 0;
  *(_OWORD *)CFMutableDictionaryRef v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  *(_OWORD *)uint64_t v39 = 0u;
  *(_OWORD *)uint64_t v36 = 0u;
  *(_OWORD *)CFStringRef v37 = 0u;
  *(_OWORD *)long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)__s1 = 0u;
  *(_OWORD *)size_t __n = 0u;
  long long v30 = 0u;
  *(_OWORD *)char v31 = 0u;
  sub_10037E570((unsigned __int8 *)&v30, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (!v3)
  {
    uint64_t v5 = 0;
LABEL_10:
    char v50 = 0;
    v51[0] = 0;
    char v52 = 0;
    LOBYTE(__p) = 0;
    char v55 = 0;
    memset(buf, 0, 27);
    v44[0] = 0;
    v44[1] = 0;
    *(void *)&v45[0] = 0;
    BYTE8(v45[0]) = 0;
    sub_100305208((uint64_t)(a1 + 4), 0);
    if (v55 && v54 < 0) {
      operator delete(__p);
    }
    if (v52) {
      sub_100310520((uint64_t)v51);
    }
    sub_1003107E0((uint64_t)v45 + 8);
    if (SBYTE7(v45[0]) < 0) {
      operator delete(v44[0]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
LABEL_62:
    if (!v5) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
  uint64_t v4 = a1[1];
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5 || !a1[2]) {
    goto LABEL_10;
  }
  uint64_t v6 = (unsigned __int8 **)a1[8];
  if (v6)
  {
    if (v30 != 1)
    {
      if (v30 == 2)
      {
        uint64_t v7 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v8;
          int v9 = "Error in fetching subscription info, error = %s";
          long long v10 = v7;
          uint32_t v11 = 12;
LABEL_53:
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
          goto LABEL_61;
        }
        goto LABEL_61;
      }
      goto LABEL_83;
    }
    char v13 = HIBYTE(__n[1]);
    if ((__n[1] & 0x8000000000000000) == 0) {
      size_t v14 = HIBYTE(__n[1]);
    }
    else {
      size_t v14 = __n[0];
    }
    long long v15 = (unsigned __int8 *)*((unsigned __int8 *)v6 + 23);
    int v16 = (char)v15;
    if ((char)v15 < 0) {
      long long v15 = v6[1];
    }
    if ((unsigned __int8 *)v14 == v15)
    {
      if (v16 >= 0) {
        uint64_t v17 = (unsigned __int8 **)a1[8];
      }
      else {
        uint64_t v17 = (unsigned __int8 **)*v6;
      }
      if ((__n[1] & 0x8000000000000000) != 0)
      {
        if (memcmp(__s1[1], v17, __n[0])) {
          goto LABEL_46;
        }
      }
      else if (HIBYTE(__n[1]))
      {
        uint64_t v18 = &__s1[1];
        uint64_t v19 = HIBYTE(__n[1]);
        while (*(unsigned __int8 *)v18 == *(unsigned __int8 *)v17)
        {
          uint64_t v18 = (void **)((char *)v18 + 1);
          uint64_t v17 = (unsigned __int8 **)((char *)v17 + 1);
          if (!--v19) {
            goto LABEL_54;
          }
        }
        goto LABEL_46;
      }
LABEL_54:
      std::string::operator=((std::string *)(v6 + 4), (const std::string *)v39);
      if (v30 == 1)
      {
        if ((_BYTE)v42)
        {
          sub_100093B44((std::string *)(a1[8] + 752), (const std::string *)&v40[1]);
        }
        else
        {
          uint64_t v22 = a1[8];
          long long v23 = (std::string *)(v22 + 56);
          if (!*(unsigned char *)(v22 + 392))
          {
            uint64_t v46 = 0;
            long long v48 = 0u;
            memset(v45, 0, sizeof(v45));
            *(_OWORD *)uint64_t v44 = 0u;
            memset(buf, 0, sizeof(buf));
            char v47 = &v48;
            char v49 = 1;
            sub_10034620C((uint64_t)v23, (uint64_t)buf);
            sub_1003107E0((uint64_t)buf);
            if (v30 != 1)
            {
              if (v30 == 2)
              {
                exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                int v28 = &ctu::ResultIsError::~ResultIsError;
                ctu::ResultIsError::ResultIsError(exception);
              }
              else
              {
                exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                int v28 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
              }
              __cxa_throw(exception, v29, (void (*)(void *))v28);
            }
          }
          std::string::operator=(v23, (const std::string *)&v40[1]);
        }
        *(unsigned char *)(a1[8] + 24) = 0;
        goto LABEL_61;
      }
      if (v30 == 2)
      {
        long long v24 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        long long v25 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(v24);
        goto LABEL_84;
      }
LABEL_83:
      long long v24 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      long long v25 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(v24);
LABEL_84:
      __cxa_throw(v24, v26, (void (*)(void *))v25);
    }
LABEL_46:
    uint64_t v20 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if (v16 < 0) {
        uint64_t v6 = (unsigned __int8 **)*v6;
      }
      if (v13 >= 0) {
        uint64_t v21 = &__s1[1];
      }
      else {
        uint64_t v21 = (void **)__s1[1];
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v21;
      int v9 = "Unexpected ICCID in subscription info, expected (%s), actual (%s)";
      long long v10 = v20;
      uint32_t v11 = 22;
      goto LABEL_53;
    }
LABEL_61:
    sub_100305208((uint64_t)(a1 + 4), 1);
    goto LABEL_62;
  }
  BOOL v12 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Current websheet launch info is unknown", buf, 2u);
  }
  char v50 = 0;
  v51[0] = 0;
  char v52 = 0;
  LOBYTE(__p) = 0;
  char v55 = 0;
  memset(buf, 0, 27);
  v44[0] = 0;
  v44[1] = 0;
  *(void *)&v45[0] = 0;
  BYTE8(v45[0]) = 0;
  sub_100305208((uint64_t)(a1 + 4), 0);
  if (v55 && v54 < 0) {
    operator delete(__p);
  }
  if (v52) {
    sub_100310520((uint64_t)v51);
  }
  sub_1003107E0((uint64_t)v45 + 8);
  if (SBYTE7(v45[0]) < 0) {
    operator delete(v44[0]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
LABEL_63:
  sub_10004D2C8(v5);
LABEL_64:
  if (v30 == 1)
  {
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[1]);
    }
    if (SHIBYTE(v40[0]) < 0) {
      operator delete(v39[0]);
    }
    if (SHIBYTE(v38) < 0) {
      operator delete(v37[1]);
    }
    if (SHIBYTE(v37[0]) < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[1]);
    }
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__s1[1]);
    }
    if (SHIBYTE(__s1[0]) < 0) {
      operator delete(v31[0]);
    }
  }
}

void sub_100D1D594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  __cxa_free_exception(v54);
  if (v53) {
    sub_10004D2C8(v53);
  }
  if (a9 == 1)
  {
    if (a53 < 0) {
      operator delete(__p);
    }
    if (a47 < 0) {
      operator delete(a42);
    }
    if (a41 < 0) {
      operator delete(a36);
    }
    if (a35 < 0) {
      operator delete(a30);
    }
    if (a29 < 0) {
      operator delete(a24);
    }
    if (a22 < 0) {
      operator delete(a17);
    }
    if (a16 < 0) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D1D720(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1D760()
{
}

uint64_t sub_100D1D76C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100345B34(a1 + 24, a2 + 24);
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100D1D7D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D1D7F0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100345BCC(a1 + 3);
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D1D848(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A51BE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D1D868(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A51BE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D1D8BC(uint64_t a1)
{
  return sub_1001A03F4(a1 + 24);
}

void *sub_100D1D8C8(void *a1)
{
  *a1 = off_101A51C38;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[4];
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = a1[4];
    if (v4) {
      dispatch_release(v4);
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

void sub_100D1D938(void *a1)
{
  *a1 = off_101A51C38;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[4];
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = a1[4];
    if (v4) {
      dispatch_release(v4);
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  operator delete();
}

void *sub_100D1D9C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A51C38;
  sub_100D1E030((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100D1DA1C(uint64_t a1, void *a2)
{
  *a2 = off_101A51C38;
  return sub_100D1E030((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100D1DA48(uint64_t a1)
{
}

void sub_100D1DA50(void *a1)
{
  sub_100D1E0AC(a1 + 1);

  operator delete(a1);
}

void sub_100D1DA8C(void *a1, unsigned __int8 *a2)
{
  uint64_t v41 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)long long v38 = 0u;
  *(_OWORD *)long long v35 = 0u;
  *(_OWORD *)uint64_t v36 = 0u;
  *(_OWORD *)uint64_t v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)__s1 = 0u;
  *(_OWORD *)size_t __n = 0u;
  long long v29 = 0u;
  *(_OWORD *)long long v30 = 0u;
  sub_10037E570((unsigned __int8 *)&v29, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (!a1[2]) {
        goto LABEL_42;
      }
      uint64_t v7 = (unsigned __int8 **)a1[5];
      if (!v7)
      {
        char v13 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          long long v10 = "Invalid manageAccountInfoPtr";
          uint32_t v11 = v13;
          uint32_t v12 = 2;
          goto LABEL_34;
        }
LABEL_42:
        sub_10004D2C8(v6);
        goto LABEL_43;
      }
      if (v29 != 1)
      {
        if (v29 == 2)
        {
          uint64_t v8 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v9 = asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v9;
            long long v10 = "Error in fetching subscription info from remote device, error = %s";
            uint32_t v11 = v8;
            uint32_t v12 = 12;
LABEL_34:
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
            goto LABEL_42;
          }
          goto LABEL_42;
        }
        goto LABEL_62;
      }
      char v14 = HIBYTE(__n[1]);
      if ((__n[1] & 0x8000000000000000) == 0) {
        size_t v15 = HIBYTE(__n[1]);
      }
      else {
        size_t v15 = __n[0];
      }
      int v16 = (unsigned __int8 *)*((unsigned __int8 *)v7 + 23);
      int v17 = (char)v16;
      if ((char)v16 < 0) {
        int v16 = v7[1];
      }
      if ((unsigned __int8 *)v15 == v16)
      {
        if (v17 >= 0) {
          uint64_t v18 = (unsigned __int8 *)a1[5];
        }
        else {
          uint64_t v18 = *v7;
        }
        if ((__n[1] & 0x8000000000000000) != 0)
        {
          if (memcmp(__s1[1], v18, __n[0])) {
            goto LABEL_27;
          }
        }
        else if (HIBYTE(__n[1]))
        {
          uint64_t v19 = &__s1[1];
          uint64_t v20 = HIBYTE(__n[1]);
          while (*(unsigned __int8 *)v19 == *v18)
          {
            uint64_t v19 = (void **)((char *)v19 + 1);
            ++v18;
            if (!--v20) {
              goto LABEL_35;
            }
          }
          goto LABEL_27;
        }
LABEL_35:
        std::string::operator=((std::string *)(v7 + 4), (const std::string *)v38);
        if (v29 == 1)
        {
          if ((_BYTE)v41)
          {
            sub_100093B44((std::string *)(v7 + 94), (const std::string *)&__p[1]);
          }
          else
          {
            if (!*((unsigned char *)v7 + 392))
            {
              uint64_t v60 = 0;
              long long v62 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v48 = 0u;
              long long v49 = 0u;
              long long v46 = 0u;
              long long v47 = 0u;
              long long v44 = 0u;
              long long v45 = 0u;
              long long v43 = 0u;
              memset(buf, 0, sizeof(buf));
              char v61 = &v62;
              char v63 = 1;
              sub_10034620C((uint64_t)(v7 + 7), (uint64_t)buf);
              sub_1003107E0((uint64_t)buf);
              if (v29 != 1)
              {
                if (v29 == 2)
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  long long v27 = &ctu::ResultIsError::~ResultIsError;
                  ctu::ResultIsError::ResultIsError(exception);
                }
                else
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  long long v27 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                  ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                }
                __cxa_throw(exception, v28, (void (*)(void *))v27);
              }
            }
            std::string::operator=((std::string *)(v7 + 7), (const std::string *)&__p[1]);
          }
          *((unsigned char *)v7 + 24) = 0;
          goto LABEL_42;
        }
        if (v29 == 2)
        {
          long long v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          long long v24 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(v23);
          goto LABEL_63;
        }
LABEL_62:
        long long v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        long long v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
LABEL_63:
        __cxa_throw(v23, v25, (void (*)(void *))v24);
      }
LABEL_27:
      uint64_t v21 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        if (v17 < 0) {
          uint64_t v7 = (unsigned __int8 **)*v7;
        }
        if (v14 >= 0) {
          uint64_t v22 = &__s1[1];
        }
        else {
          uint64_t v22 = (void **)__s1[1];
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        long long v10 = "Unexpected ICCID in subscription info, expected (%s), actual (%s)";
        uint32_t v11 = v21;
        uint32_t v12 = 22;
        goto LABEL_34;
      }
      goto LABEL_42;
    }
  }
LABEL_43:
  if (v29 == 1)
  {
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v38[0]);
    }
    if (SHIBYTE(v37) < 0) {
      operator delete(v36[1]);
    }
    if (SHIBYTE(v36[0]) < 0) {
      operator delete(v35[0]);
    }
    if (SHIBYTE(v34) < 0) {
      operator delete(v33[1]);
    }
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__s1[1]);
    }
    if (SHIBYTE(__s1[0]) < 0) {
      operator delete(v30[0]);
    }
  }
}

void sub_100D1DF1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  __cxa_free_exception(v54);
  sub_10004D2C8(v53);
  if (a9 == 1)
  {
    if (a53 < 0) {
      operator delete(__p);
    }
    if (a47 < 0) {
      operator delete(a42);
    }
    if (a41 < 0) {
      operator delete(a36);
    }
    if (a35 < 0) {
      operator delete(a30);
    }
    if (a29 < 0) {
      operator delete(a24);
    }
    if (a22 < 0) {
      operator delete(a17);
    }
    if (a16 < 0) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D1DFE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1E024()
{
}

uint64_t sub_100D1E030(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(NSObject **)(a2 + 24);
  *(void *)(a1 + 24) = v5;
  if (v5)
  {
    dispatch_retain(v5);
    uint64_t v6 = *(NSObject **)(a1 + 24);
    if (v6) {
      dispatch_group_enter(v6);
    }
  }
  uint64_t v7 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100D1E0AC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[3];
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = a1[3];
    if (v4) {
      dispatch_release(v4);
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_100D1E114(uint64_t **a1)
{
  uint64_t v1 = **a1;
  long long __p = 0;
  long long v10 = 0uLL;
  if (*(_DWORD *)(v1 + 920))
  {
    (*(void (**)(const void **__return_ptr))(**(void **)(v1 + 128) + 128))(v8);
    uint32_t v11 = 0;
    long long v12 = 0uLL;
    ctu::cf::assign();
    long long __p = v11;
    *(void *)&long long v10 = v12;
    *(void *)((char *)&v10 + 7) = *(void *)((char *)&v12 + 7);
    HIBYTE(v10) = HIBYTE(v12);
    sub_1000558F4(v8);
  }
  uint32_t v11 = 0;
  long long v12 = 0uLL;
  (*(void (**)(void **__return_ptr))(**(void **)(v1 + 160) + 192))(&v11);
  memset(v8, 0, sizeof(v8));
  v7[0] = (void **)v8;
  v7[1] = &v11;
  v7[2] = (void **)v1;
  v6[0] = v1;
  v6[1] = (uint64_t)&v11;
  v6[2] = (uint64_t)v7;
  uint64_t v2 = *(void *)(v1 + 360);
  if (v2 != *(void *)(v1 + 368)) {
    sub_100D1E36C(v6, v2, 1uLL);
  }
  uint64_t v3 = *(void *)(v1 + 544);
  uint64_t v4 = *(void *)(v1 + 552);
  while (v3 != v4)
  {
    uint64_t v5 = *(void *)(v3 + 176);
    if (v5 != *(void *)(v3 + 184)) {
      sub_100D1E36C(v6, v5, 2uLL);
    }
    v3 += 216;
  }
  (*(void (**)(void, const void **, void **))(**(void **)(v1 + 208) + 112))(*(void *)(v1 + 208), v8, &__p);
  v7[0] = (void **)v8;
  sub_100257690(v7);
  sub_1003DDCEC((uint64_t)&v11, (void *)v12);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100D1E2E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (*(char *)(v24 - 33) < 0) {
    operator delete(*(void **)(v24 - 56));
  }
  sub_1000558F4(&a16);
  operator delete();
}

void sub_100D1E36C(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  if (*(_DWORD *)(a2 + 12) == 3)
  {
    int v3 = a3;
    uint64_t v5 = *a1;
    long long v99 = 0;
    uint64_t v100 = 0;
    uint64_t v101 = 0;
    ctu::hex((uint64_t *)&v99, (ctu *)(a2 + 16), (const void *)0x10, a3);
    std::string v96 = 0;
    uint64_t v97 = 0;
    unint64_t v98 = 0;
    uint64_t v6 = *(void *)(v5 + 304);
    uint64_t v7 = *(void *)(v5 + 312);
    if (v6 == v7) {
      goto LABEL_56;
    }
    do
    {
      if (subscriber::isSimReady())
      {
        uint64_t v8 = (void *)a1[1];
        uint32_t v11 = (void *)*v8;
        long long v10 = v8 + 1;
        uint64_t v9 = v11;
        if (v11 != v10)
        {
          if (v101 >= 0) {
            uint64_t v12 = HIBYTE(v101);
          }
          else {
            uint64_t v12 = v100;
          }
          if (v101 >= 0) {
            char v13 = (unsigned __int8 *)&v99;
          }
          else {
            char v13 = (unsigned __int8 *)v99;
          }
          while (1)
          {
            uint64_t v14 = *((unsigned __int8 *)v9 + 87);
            if ((v14 & 0x80u) == 0) {
              uint64_t v15 = *((unsigned __int8 *)v9 + 87);
            }
            else {
              uint64_t v15 = v9[9];
            }
            if (v15 != v12) {
              goto LABEL_39;
            }
            int v16 = (const void **)(v9 + 8);
            if ((v14 & 0x80) != 0)
            {
              if (memcmp(*v16, v13, v9[9])) {
                goto LABEL_39;
              }
            }
            else if (*((unsigned char *)v9 + 87))
            {
              int v17 = v13;
              while (*(unsigned __int8 *)v16 == *v17)
              {
                int v16 = (const void **)((char *)v16 + 1);
                ++v17;
                if (!--v14) {
                  goto LABEL_22;
                }
              }
              goto LABEL_39;
            }
LABEL_22:
            uint64_t v18 = *((unsigned __int8 *)v9 + 143);
            if ((v18 & 0x80u) == 0) {
              uint64_t v19 = *((unsigned __int8 *)v9 + 143);
            }
            else {
              uint64_t v19 = v9[16];
            }
            uint64_t v20 = *(unsigned __int8 *)(v6 + 95);
            int v21 = (char)v20;
            if ((v20 & 0x80u) != 0) {
              uint64_t v20 = *(void *)(v6 + 80);
            }
            if (v19 == v20)
            {
              uint64_t v22 = (const void **)(v9 + 15);
              if (v21 >= 0) {
                long long v23 = (unsigned __int8 *)(v6 + 72);
              }
              else {
                long long v23 = *(unsigned __int8 **)(v6 + 72);
              }
              if ((v18 & 0x80) != 0)
              {
                if (!memcmp(*v22, v23, v9[16]))
                {
LABEL_37:
                  if (*((unsigned __int8 *)v9 + 113) == v3 && (v9[14] & 0xFE) == 2) {
                    break;
                  }
                }
              }
              else
              {
                if (!*((unsigned char *)v9 + 143)) {
                  goto LABEL_37;
                }
                while (*(unsigned __int8 *)v22 == *v23)
                {
                  uint64_t v22 = (const void **)((char *)v22 + 1);
                  ++v23;
                  if (!--v18) {
                    goto LABEL_37;
                  }
                }
              }
            }
LABEL_39:
            uint64_t v24 = (void *)v9[1];
            if (v24)
            {
              do
              {
                long long v25 = v24;
                uint64_t v24 = (void *)*v24;
              }
              while (v24);
            }
            else
            {
              do
              {
                long long v25 = (void *)v9[2];
                BOOL v26 = *v25 == (void)v9;
                uint64_t v9 = v25;
              }
              while (!v26);
            }
            uint64_t v9 = v25;
            if (v25 == v10) {
              goto LABEL_54;
            }
          }
        }
        if (v9 != v10)
        {
          long long v27 = (long long *)(v9 + 4);
          int v28 = v97;
          if ((unint64_t)v97 >= v98)
          {
            long long v30 = (long long *)sub_10030E9EC((uint64_t *)&v96, v27);
          }
          else
          {
            if (*((char *)v9 + 55) < 0)
            {
              sub_10004FC84(v97, (void *)v9[4], v9[5]);
            }
            else
            {
              long long v29 = *v27;
              *((void *)v97 + 2) = v9[6];
              *int v28 = v29;
            }
            long long v30 = (long long *)((char *)v28 + 24);
          }
          uint64_t v97 = v30;
        }
      }
LABEL_54:
      v6 += 168;
    }
    while (v6 != v7);
    char v31 = v96;
    uint64_t v32 = (void **)v97;
    if (v96 == (void **)v97)
    {
LABEL_56:
      memset(v108, 0, 24);
      uint64_t v33 = (void *)a1[1];
      uint64_t v36 = (void *)*v33;
      long long v34 = v33 + 1;
      long long v35 = v36;
      if (v36 != v34)
      {
        double v37 = 0.0;
        while (1)
        {
          uint64_t v38 = *((unsigned __int8 *)v35 + 87);
          if ((v38 & 0x80u) == 0) {
            uint64_t v39 = *((unsigned __int8 *)v35 + 87);
          }
          else {
            uint64_t v39 = v35[9];
          }
          uint64_t v40 = HIBYTE(v101);
          if (v101 < 0) {
            uint64_t v40 = v100;
          }
          if (v39 != v40) {
            goto LABEL_81;
          }
          uint64_t v41 = (const void **)(v35 + 8);
          if (v101 >= 0) {
            uint64_t v42 = (unsigned __int8 *)&v99;
          }
          else {
            uint64_t v42 = (unsigned __int8 *)v99;
          }
          if ((v38 & 0x80) != 0)
          {
            if (memcmp(*v41, v42, v35[9])) {
              goto LABEL_81;
            }
          }
          else if (*((unsigned char *)v35 + 87))
          {
            while (*(unsigned __int8 *)v41 == *v42)
            {
              uint64_t v41 = (const void **)((char *)v41 + 1);
              ++v42;
              if (!--v38) {
                goto LABEL_73;
              }
            }
            goto LABEL_81;
          }
LABEL_73:
          if (*((unsigned __int8 *)v35 + 113) == v3)
          {
            if (*((char *)v35 + 143) < 0)
            {
              if (!v35[16])
              {
LABEL_78:
                if ((v35[14] & 0xFE) == 2)
                {
                  double v43 = *((double *)v35 + 7);
                  if (v43 > v37)
                  {
                    std::string::operator=((std::string *)v108, (const std::string *)(v35 + 4));
                    double v37 = v43;
                  }
                }
              }
            }
            else if (!*((unsigned char *)v35 + 143))
            {
              goto LABEL_78;
            }
          }
LABEL_81:
          long long v44 = (void *)v35[1];
          if (v44)
          {
            do
            {
              long long v45 = v44;
              long long v44 = (void *)*v44;
            }
            while (v44);
          }
          else
          {
            do
            {
              long long v45 = (void *)v35[2];
              BOOL v26 = *v45 == (void)v35;
              long long v35 = v45;
            }
            while (!v26);
          }
          long long v35 = v45;
          if (v45 == v34)
          {
            unsigned int v46 = v108[23];
            unint64_t v47 = *(void *)&v108[8];
            goto LABEL_89;
          }
        }
      }
      unint64_t v47 = 0;
      unsigned int v46 = 0;
LABEL_89:
      if ((v46 & 0x80u) == 0) {
        unint64_t v48 = v46;
      }
      else {
        unint64_t v48 = v47;
      }
      if (v48)
      {
        long long v49 = v97;
        if ((unint64_t)v97 >= v98)
        {
          long long v51 = (long long *)sub_1000D8CE8((uint64_t *)&v96, (long long *)v108);
        }
        else
        {
          if ((v46 & 0x80) != 0)
          {
            sub_10004FC84(v97, *(void **)v108, v47);
          }
          else
          {
            long long v50 = *(_OWORD *)v108;
            *((void *)v97 + 2) = *(void *)&v108[16];
            *long long v49 = v50;
          }
          long long v51 = (long long *)((char *)v49 + 24);
          uint64_t v97 = (long long *)((char *)v49 + 24);
        }
        uint64_t v97 = v51;
        LOBYTE(v46) = v108[23];
      }
      if ((v46 & 0x80) != 0) {
        operator delete(*(void **)v108);
      }
      char v31 = v96;
      uint64_t v32 = (void **)v97;
    }
    if (v31 == v32)
    {
      memset(v108, 0, 24);
      long long v52 = (void *)a1[1];
      long long v55 = (void *)*v52;
      long long v53 = v52 + 1;
      long long v54 = v55;
      if (v55 != v53)
      {
        double v56 = 0.0;
        while (1)
        {
          uint64_t v57 = *((unsigned __int8 *)v54 + 87);
          if ((v57 & 0x80u) == 0) {
            uint64_t v58 = *((unsigned __int8 *)v54 + 87);
          }
          else {
            uint64_t v58 = v54[9];
          }
          uint64_t v59 = HIBYTE(v101);
          if (v101 < 0) {
            uint64_t v59 = v100;
          }
          if (v58 != v59) {
            goto LABEL_124;
          }
          uint64_t v60 = (const void **)(v54 + 8);
          char v61 = v101 >= 0 ? &v99 : (void **)v99;
          if ((v57 & 0x80) == 0) {
            break;
          }
          if (!memcmp(*v60, v61, v54[9])) {
            goto LABEL_121;
          }
LABEL_124:
          char v63 = (void *)v54[1];
          if (v63)
          {
            do
            {
              unsigned int v64 = v63;
              char v63 = (void *)*v63;
            }
            while (v63);
          }
          else
          {
            do
            {
              unsigned int v64 = (void *)v54[2];
              BOOL v26 = *v64 == (void)v54;
              long long v54 = v64;
            }
            while (!v26);
          }
          long long v54 = v64;
          if (v64 == v53)
          {
            unsigned int v65 = v108[23];
            unint64_t v66 = *(void *)&v108[8];
            goto LABEL_132;
          }
        }
        if (*((unsigned char *)v54 + 87))
        {
          while (*(unsigned __int8 *)v60 == *(unsigned __int8 *)v61)
          {
            uint64_t v60 = (const void **)((char *)v60 + 1);
            char v61 = (void **)((char *)v61 + 1);
            if (!--v57) {
              goto LABEL_121;
            }
          }
          goto LABEL_124;
        }
LABEL_121:
        if (*((unsigned __int8 *)v54 + 113) == v3)
        {
          double v62 = *((double *)v54 + 7);
          if (v62 > v56)
          {
            std::string::operator=((std::string *)v108, (const std::string *)(v54 + 4));
            double v56 = v62;
          }
        }
        goto LABEL_124;
      }
      unint64_t v66 = 0;
      unsigned int v65 = 0;
LABEL_132:
      if ((v65 & 0x80u) == 0) {
        unint64_t v67 = v65;
      }
      else {
        unint64_t v67 = v66;
      }
      if (v67)
      {
        uint64_t v68 = v97;
        if ((unint64_t)v97 >= v98)
        {
          long long v70 = (long long *)sub_1000D8CE8((uint64_t *)&v96, (long long *)v108);
        }
        else
        {
          if ((v65 & 0x80) != 0)
          {
            sub_10004FC84(v97, *(void **)v108, v66);
          }
          else
          {
            long long v69 = *(_OWORD *)v108;
            *((void *)v97 + 2) = *(void *)&v108[16];
            long long *v68 = v69;
          }
          long long v70 = (long long *)((char *)v68 + 24);
          uint64_t v97 = (long long *)((char *)v68 + 24);
        }
        uint64_t v97 = v70;
        LOBYTE(v65) = v108[23];
      }
      if ((v65 & 0x80) != 0) {
        operator delete(*(void **)v108);
      }
      char v31 = v96;
      uint64_t v32 = (void **)v97;
    }
    long long v71 = (unint64_t **)a1[2];
    char v72 = v71[2];
    if (v31 == v32)
    {
      *(void *)&long long v109 = 0;
      memset(v108, 0, sizeof(v108));
      v108[0] = v3;
      uint64_t v73 = *v71;
      unint64_t v74 = (*v71)[1];
      if (v74 >= (*v71)[2])
      {
        unint64_t v75 = sub_100D1EDCC(*v71, (uint64_t)v108);
      }
      else
      {
        *(_WORD *)unint64_t v74 = *(_WORD *)v108;
        *(_OWORD *)(v74 + 8) = *(_OWORD *)&v108[8];
        *(void *)(v74 + 24) = *(void *)&v108[24];
        *(_WORD *)(v74 + 32) = 0;
        unint64_t v75 = v74 + 40;
        v73[1] = v74 + 40;
      }
      v73[1] = v75;
      char v31 = v96;
      uint64_t v32 = (void **)v97;
    }
    if (v31 == v32) {
      goto LABEL_204;
    }
LABEL_152:
    uint64_t v76 = (uint64_t)v71[1];
    *(void *)long long v108 = 0;
    uint64_t v77 = *sub_100046ED4(v76, v108, v31);
    if (!v77) {
      sub_1000C14F0("map::at:  key not found");
    }
    uint64_t v103 = 0;
    memset(v102, 0, sizeof(v102));
    LOBYTE(v102[0]) = *(unsigned char *)(v77 + 113);
    BYTE1(v102[0]) = *(unsigned char *)(v77 + 112);
    char v78 = (void **)(v77 + 120);
    if (*(char *)(v77 + 143) < 0)
    {
      unint64_t v81 = *(void *)(v77 + 128);
      if (!v81)
      {
LABEL_178:
        LOWORD(v103) = 257;
        long long v112 = 0uLL;
        memset(v111, 0, sizeof(v111));
        long long v109 = 0uLL;
        long long v110 = 0uLL;
        memset(v108, 0, sizeof(v108));
        VinylInfo::findProfile();
        if (BYTE8(v112))
        {
          std::string::operator=((std::string *)&v102[1], v111);
          if (BYTE8(v112)) {
            sub_1000C584C((uint64_t)v108);
          }
        }
        goto LABEL_195;
      }
      LOWORD(v103) = 256;
      unint64_t v79 = v72[38];
      unint64_t v80 = v72[39];
      sub_10004FC84(__p, *v78, v81);
    }
    else
    {
      if (!*(unsigned char *)(v77 + 143)) {
        goto LABEL_178;
      }
      LOWORD(v103) = 256;
      unint64_t v79 = v72[38];
      unint64_t v80 = v72[39];
      *(_OWORD *)long long __p = *(_OWORD *)v78;
      uint64_t v106 = *(void *)(v77 + 136);
    }
    char v82 = HIBYTE(v106);
    if (v79 == v80) {
      goto LABEL_182;
    }
    if (v106 >= 0) {
      long long v83 = (void *)HIBYTE(v106);
    }
    else {
      long long v83 = __p[1];
    }
    if (v106 >= 0) {
      long long v84 = __p;
    }
    else {
      long long v84 = (void **)__p[0];
    }
    while (1)
    {
      uint64_t v85 = *(unsigned __int8 *)(v79 + 95);
      if ((v85 & 0x80u) == 0) {
        long long v86 = (void *)*(unsigned __int8 *)(v79 + 95);
      }
      else {
        long long v86 = *(void **)(v79 + 80);
      }
      if (v86 == v83)
      {
        if ((v85 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v79 + 72), v84, *(void *)(v79 + 80)))
          {
LABEL_181:
            unint64_t v80 = v79;
LABEL_182:
            if (v82 < 0) {
              operator delete(__p[0]);
            }
            if (v80 != v72[39])
            {
              long long v104 = 0;
              (*(void (**)(const void **__return_ptr))(*(void *)v72[16] + 128))(&v104);
              if (v104) {
                long long v88 = sub_1000810B8;
              }
              else {
                long long v88 = 0;
              }
              if (v88)
              {
                memset(v108, 0, 24);
                ctu::cf::assign();
                v107[0] = *(void *)&v108[8];
                char v89 = *(void **)v108;
                *(void *)((char *)v107 + 7) = *(void *)&v108[15];
                char v90 = v108[23];
                sub_1000558F4(&v104);
                goto LABEL_192;
              }
              sub_1000558F4(&v104);
            }
            char v89 = 0;
            char v90 = 0;
            *(void *)((char *)v107 + 7) = 0;
            v107[0] = 0;
LABEL_192:
            if (SHIBYTE(v102[3]) < 0) {
              operator delete(v102[1]);
            }
            v102[1] = v89;
            v102[2] = (void *)v107[0];
            *(void **)((char *)&v102[2] + 7) = *(void **)((char *)v107 + 7);
            HIBYTE(v102[3]) = v90;
LABEL_195:
            long long v91 = *v71;
            unint64_t v92 = (*v71)[1];
            if (v92 >= (*v71)[2])
            {
              unint64_t v95 = sub_100D1EDCC(*v71, (uint64_t)v102);
            }
            else
            {
              *(_WORD *)unint64_t v92 = v102[0];
              std::string v93 = (unsigned char *)(v92 + 8);
              if (SHIBYTE(v102[3]) < 0)
              {
                sub_10004FC84(v93, v102[1], (unint64_t)v102[2]);
              }
              else
              {
                long long v94 = *(_OWORD *)&v102[1];
                *(void **)(v92 + 24) = v102[3];
                *(_OWORD *)std::string v93 = v94;
              }
              *(_WORD *)(v92 + 32) = v103;
              unint64_t v95 = v92 + 40;
              v91[1] = v92 + 40;
            }
            v91[1] = v95;
            if (SHIBYTE(v102[3]) < 0) {
              operator delete(v102[1]);
            }
            v31 += 3;
            if (v31 == v32)
            {
LABEL_204:
              *(void *)long long v108 = &v96;
              sub_100047F64((void ***)v108);
              if (SHIBYTE(v101) < 0) {
                operator delete(v99);
              }
              return;
            }
            goto LABEL_152;
          }
        }
        else
        {
          if (!*(unsigned char *)(v79 + 95)) {
            goto LABEL_181;
          }
          uint64_t v87 = 0;
          while (*(unsigned __int8 *)(v79 + v87 + 72) == *((unsigned __int8 *)v84 + v87))
          {
            if (v85 == ++v87) {
              goto LABEL_181;
            }
          }
        }
      }
      v79 += 168;
      if (v79 == v80) {
        goto LABEL_182;
      }
    }
  }
}

void sub_100D1ECE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  a22 = (uint64_t)&a13;
  sub_100047F64((void ***)&a22);
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_100D1EDCC(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v2 - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    sub_10006A748();
  }
  if (0x999999999999999ALL * ((uint64_t)(a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x999999999999999ALL * ((uint64_t)(a1[2] - v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[2] - v3) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_10006A7CC();
    }
    uint64_t v9 = operator new(40 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  long long v10 = (char *)&v9[20 * v4];
  uint64_t v19 = v9;
  v20.i64[0] = (uint64_t)v10;
  v20.i64[1] = (uint64_t)v10;
  int v21 = (char *)&v9[20 * v8];
  *(_WORD *)long long v10 = *(_WORD *)a2;
  uint32_t v11 = v10 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84(v11, *(void **)(a2 + 8), *(void *)(a2 + 16));
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
    uint64_t v12 = (char *)v20.i64[1];
    long long v10 = (char *)v20.i64[0];
  }
  else
  {
    *(_OWORD *)uint32_t v11 = *(_OWORD *)(a2 + 8);
    *((void *)v10 + 3) = *(void *)(a2 + 24);
    uint64_t v12 = (char *)&v9[20 * v4];
  }
  v9[20 * v4 + 16] = *(_WORD *)(a2 + 32);
  unint64_t v13 = (unint64_t)(v12 + 40);
  v20.i64[1] = (uint64_t)(v12 + 40);
  if (v2 == v3)
  {
    int64x2_t v16 = vdupq_n_s64(v3);
  }
  else
  {
    do
    {
      __int16 v14 = *(_WORD *)(v2 - 40);
      v2 -= 40;
      *((_WORD *)v10 - 20) = v14;
      v10 -= 40;
      long long v15 = *(_OWORD *)(v2 + 8);
      *((void *)v10 + 3) = *(void *)(v2 + 24);
      *(_OWORD *)(v10 + 8) = v15;
      *(void *)(v2 + 16) = 0;
      *(void *)(v2 + 24) = 0;
      *(void *)(v2 + 8) = 0;
      *((_WORD *)v10 + 16) = *(_WORD *)(v2 + 32);
    }
    while (v2 != v3);
    int64x2_t v16 = *(int64x2_t *)a1;
    unint64_t v13 = v20.u64[1];
  }
  *a1 = (unint64_t)v10;
  a1[1] = v13;
  int64x2_t v20 = v16;
  unint64_t v17 = a1[2];
  a1[2] = (unint64_t)v21;
  int v21 = (char *)v17;
  uint64_t v19 = (_WORD *)v16.i64[0];
  sub_100255C14((uint64_t)&v19);
  return v13;
}

void sub_100D1EF78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100255C14((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100D1EF8C(void *a1)
{
  *a1 = off_101A51CB8;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100D1EFD0(void *a1)
{
  *a1 = off_101A51CB8;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_100D1F034(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t v2 = off_101A51CB8;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100D1F08C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1F0A0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A51CB8;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100D1F0D0(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_100D1F0D8(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100D1F114(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1000607A8(a1 + 16, *a2 < 0x100u);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v2 + 96) + 16);

  return v3();
}

uint64_t sub_100D1F17C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1F1BC()
{
}

void sub_100D1F1CC()
{
}

void *sub_100D1F1E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A51D38;
  result[1] = v3;
  return result;
}

uint64_t sub_100D1F228(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A51D38;
  a2[1] = v2;
  return result;
}

void sub_100D1F254(uint64_t a1, void ***a2, unsigned __int8 *a3)
{
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  memset(v11, 0, sizeof(v11));
  sub_100D1F490((unsigned __int8 *)v11, a3);
  v13[0] = v4;
  v13[1] = v5;
  if (LOBYTE(v11[0]) == 1)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I active remote plan - received pending profiles", buf, 2u);
      if (LOBYTE(v11[0]) != 1)
      {
        if (LOBYTE(v11[0]) == 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v9 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
        }
        else
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v9 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        }
        __cxa_throw(exception, v10, (void (*)(void *))v9);
      }
    }
    (*(void (**)(void, void ***, char *))(**(void **)(v6 + 160) + 40))(*(void *)(v6 + 160), v13, (char *)v11 + 8);
    (*(void (**)(void))(**(void **)(v6 + 96) + 16))(*(void *)(v6 + 96));
    if (LOBYTE(v11[0]) == 1)
    {
      v13[0] = (void **)v11 + 1;
      sub_1000C63B8(v13);
    }
  }
}

void sub_100D1F404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  __cxa_free_exception(v13);
  if (a9 == 1)
  {
    a13 = &a10;
    sub_1000C63B8((void ***)&a13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D1F444(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1F484()
{
}

unsigned __int8 *sub_100D1F490(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 == 2)
  {
    int v5 = *a1;
    if (v5 == 1)
    {
      uint64_t v7 = (void **)(a1 + 8);
      sub_1000C63B8(&v7);
    }
    else if (v5 == 2)
    {
LABEL_9:
      a1[8] = a2[8];
      return a1;
    }
    *a1 = 2;
    goto LABEL_9;
  }
  if (v4 == 1) {
    sub_100D1F520((uint64_t)a1, (__n128 *)(a2 + 8));
  }
  return a1;
}

__n128 sub_100D1F520(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)a1 == 1)
  {
    sub_100ADB634((void **)(a1 + 8));
  }
  else
  {
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)(a1 + 8) = *a2;
  *(void *)(a1 + 24) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t sub_100D1F584(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100D1F61C(void *a1)
{
  *a1 = off_101A51DC8;
  sub_100D1C19C(a1 + 2);
  return a1;
}

void sub_100D1F660(void *a1)
{
  *a1 = off_101A51DC8;
  sub_100D1C19C(a1 + 2);

  operator delete();
}

void *sub_100D1F6C4(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A51DC8;
  v2[1] = v3;
  sub_100D1F584((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100D1F71C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D1F730(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A51DC8;
  a2[1] = v2;
  return sub_100D1F584((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100D1F760(uint64_t a1)
{
  return sub_100D1C19C((void *)(a1 + 16));
}

void sub_100D1F768(void *a1)
{
  sub_100D1C19C(a1 + 2);

  operator delete(a1);
}

void sub_100D1F7A4(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  memset(v11, 0, sizeof(v11));
  sub_100D1F490((unsigned __int8 *)v11, a3);
  v16[0] = v4;
  v16[1] = v5;
  if (LOBYTE(v11[0]) == 1)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)
      && (*(_WORD *)long long buf = 0,
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I received pending profiles", buf, 2u),
          LOBYTE(v11[0]) != 1))
    {
      if (LOBYTE(v11[0]) == 2)
      {
LABEL_13:
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v9 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
        goto LABEL_15;
      }
    }
    else
    {
      (*(void (**)(void, void *, char *))(**(void **)(v6 + 160) + 40))(*(void *)(v6 + 160), v16, (char *)v11 + 8);
      if (LOBYTE(v11[0]) == 1)
      {
        sub_100D146D8(*(void *)(a1 + 40), 1);
        goto LABEL_7;
      }
      if (LOBYTE(v11[0]) == 2) {
        goto LABEL_13;
      }
    }
    exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
    uint64_t v9 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_15:
    __cxa_throw(exception, v10, (void (*)(void *))v9);
  }
  *(void *)long long buf = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_100D146D8(*(void *)(a1 + 40), 0);
  long long v15 = buf;
  sub_1000C63B8((void ***)&v15);
LABEL_7:
  if (LOBYTE(v11[0]) == 1)
  {
    *(void *)long long buf = (char *)v11 + 8;
    sub_1000C63B8((void ***)buf);
  }
}

void sub_100D1F9C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  __cxa_free_exception(v17);
  if (a9 == 1)
  {
    a13 = &a10;
    sub_1000C63B8((void ***)&a13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D1FA24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D1FA64()
{
}

uint64_t *sub_100D1FA70(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *v1;
  long long v66 = 0uLL;
  int v3 = *(unsigned __int8 *)(v2 + 1224);
  uint64_t v4 = v2 + 328;
  if (*(unsigned char *)(v2 + 1224)) {
    uint64_t v4 = v2 + 1368;
  }
  uint64_t v5 = *(void *)(v4 + 32);
  if (*(void *)(v4 + 40) == v5 || !*(unsigned char *)(v4 + 24))
  {
    unint64_t v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No vinyl info", (uint8_t *)__p, 2u);
    }
  }
  else
  {
    long long v66 = *(_OWORD *)(v5 + 16);
    if (v3)
    {
      uint64_t v38 = 0;
      *(_OWORD *)uint64_t v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      *(_OWORD *)long long v35 = 0u;
      *(_OWORD *)uint64_t v32 = 0u;
      *(_OWORD *)uint64_t v33 = 0u;
      *(_OWORD *)long long v30 = 0u;
      long long v31 = 0u;
      *(_OWORD *)int v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      *(_OWORD *)long long v27 = 0u;
      long long v24 = 0u;
      *(_OWORD *)long long v25 = 0u;
      *(_OWORD *)uint64_t v22 = 0u;
      *(_OWORD *)long long v23 = 0u;
      long long v21 = 0u;
      memset(__p, 0, sizeof(__p));
      CFStringRef v6 = (const __CFString *)v1[1];
      if (v6) {
        uint64_t v7 = sub_1000810B8;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v7 && CFStringGetLength(v6))
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(void *)&long long v64 = 0;
        *(void *)((char *)&v64 + 7) = 0;
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        __p[0] = 0;
        __p[1] = (void *)v64;
        *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v64 + 7);
        HIBYTE(__p[2]) = 0;
      }
      else
      {
        uint64_t v9 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No server URL provided by client", buf, 2u);
        }
        (*(void (**)(long long *__return_ptr))(**(void **)(v2 + 128) + 640))(&v64);
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v64 + 48))(buf);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)long long __p = *(_OWORD *)buf;
        __p[2] = *(void **)&buf[16];
        buf[23] = 0;
        buf[0] = 0;
        if (*((void *)&v64 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v64 + 1));
        }
      }
      sub_10030C34C((char *)buf, (long long *)__p);
      long long v64 = 0uLL;
      uint64_t v65 = 0;
      v39[0] = (void **)&v64;
      v39[1] = 0;
      *(void *)&long long v64 = operator new(0x138uLL);
      *((void *)&v64 + 1) = v64;
      uint64_t v10 = v64 + 312;
      uint64_t v65 = v64 + 312;
      sub_10030C34C((char *)v64, (long long *)buf);
      *((void *)&v64 + 1) = v10;
      sub_100D10BC4(v2, (ctu *)&v66, (const std::string **)&v64);
      v39[0] = (void **)&v64;
      sub_1000C63B8(v39);
      if (v63)
      {
        if (v62 < 0) {
          operator delete(v61);
        }
        if (v60 < 0) {
          operator delete(v59);
        }
        if (v58 < 0) {
          operator delete(v57);
        }
        if (v56 < 0) {
          operator delete(v55);
        }
        if (v54 < 0) {
          operator delete(v53);
        }
        if (v52 < 0) {
          operator delete(v51);
        }
        if (v50 < 0) {
          operator delete(v49);
        }
      }
      if (v48 < 0) {
        operator delete(v47);
      }
      if (v46 < 0) {
        operator delete(v45);
      }
      if (v44 < 0) {
        operator delete(v43);
      }
      if (v42 < 0) {
        operator delete(v41);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if ((_BYTE)v38)
      {
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[1]);
        }
        if (SHIBYTE(v36[0]) < 0) {
          operator delete(v35[0]);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete(v33[1]);
        }
        if (SHIBYTE(v33[0]) < 0) {
          operator delete(v32[0]);
        }
        if (SBYTE7(v31) < 0) {
          operator delete(v30[0]);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[1]);
        }
        if (SHIBYTE(v28[0]) < 0) {
          operator delete(v27[0]);
        }
      }
      if (SBYTE7(v26) < 0) {
        operator delete(v25[0]);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(v23[1]);
      }
      if (SHIBYTE(v23[0]) < 0) {
        operator delete(v22[0]);
      }
      if (SHIBYTE(v21) < 0) {
        operator delete(__p[3]);
      }
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      v35[0] = 0;
      *(_OWORD *)uint64_t v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      *(_OWORD *)uint64_t v32 = 0u;
      long long v29 = 0u;
      *(_OWORD *)long long v30 = 0u;
      *(_OWORD *)long long v27 = 0u;
      *(_OWORD *)int v28 = 0u;
      *(_OWORD *)long long v25 = 0u;
      long long v26 = 0u;
      *(_OWORD *)long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      *(_OWORD *)uint64_t v22 = 0u;
      memset(__p, 0, sizeof(__p));
      sub_10030A548((uint64_t)__p);
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      uint32_t v11 = *(void **)buf;
      *(void *)&long long v64 = *(void *)&buf[8];
      *(void *)((char *)&v64 + 7) = *(void *)&buf[15];
      uint64_t v12 = buf[23];
      int v13 = (char)buf[23];
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v64 + 7);
      uint64_t v14 = v64;
      __p[0] = v11;
      __p[1] = (void *)v64;
      HIBYTE(__p[2]) = v13;
      if (v13 >= 0) {
        uint64_t v14 = v12;
      }
      if (!v14)
      {
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 128) + 640))(buf);
        uint64_t v17 = *(void *)buf;
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          (*(void (**)(long long *__return_ptr))(**(void **)(v2 + 128) + 640))(&v64);
          (*(void (**)(uint8_t *__return_ptr))(*(void *)v64 + 48))(buf);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)long long __p = *(_OWORD *)buf;
          __p[2] = *(void **)&buf[16];
          buf[23] = 0;
          buf[0] = 0;
          if (*((void *)&v64 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v64 + 1));
          }
        }
      }
      sub_1003268E0((char *)buf, (long long *)__p);
      long long v15 = _Block_copy(&stru_101A51E58);
      sub_100CFA334(v2, &v66, (long long *)buf, v15);
      if (v15) {
        _Block_release(v15);
      }
      sub_10030A89C((uint64_t)buf);
      sub_10030A89C((uint64_t)__p);
    }
  }
  sub_100BDD5F0((uint64_t *)&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100D200A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  int v13 = *(std::__shared_weak_count **)(v11 - 96);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10030A89C((uint64_t)&a11);
  sub_100BDD5F0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100D2031C()
{
}

void sub_100D203E8()
{
}

void sub_100D2040C()
{
}

void sub_100D204D8()
{
}

uint64_t sub_100D204FC(uint64_t a1, void *a2, NSObject **a3, char *a4, char *a5, void *a6, uint64_t *a7, char a8, char a9, void *aBlock)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v63, kCtLoggingSystemName, a5);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v17 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v17) {
    dispatch_retain(v17);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&__dst, (const OsLogContext *)&v63);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&__dst);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&__dst);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v63);
  *(void *)a1 = off_101A51EE8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v18 = a2[1];
  *(void *)(a1 + 56) = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = aBlock;
  *(void *)(a1 + 64) = *a6;
  uint64_t v20 = a6[1];
  *(void *)(a1 + 72) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v21 = *a7;
  *(_OWORD *)(a1 + 112) = 0u;
  uint64_t v22 = (void **)(a1 + 112);
  *(unsigned char *)(a1 + 80) = a9;
  *(unsigned char *)(a1 + 81) = a8;
  *(void *)(a1 + 104) = v21;
  *(void *)(a1 + 144) = 0;
  long long v23 = (const void **)(a1 + 144);
  *(_OWORD *)(a1 + 128) = 0u;
  if (aBlock) {
    uint64_t v19 = _Block_copy(aBlock);
  }
  *(void *)(a1 + 152) = v19;
  uint64_t v24 = *a7 / 4;
  uint64_t v25 = 5;
  if (v24 < 5) {
    uint64_t v25 = *a7 / 4;
  }
  uint64_t v26 = 60 * v25;
  if (v24 >= 10) {
    uint64_t v24 = 10;
  }
  *(void *)(a1 + 160) = v26;
  *(void *)(a1 + 168) = 60 * v24;
  if (a4 && *a4)
  {
    long long v27 = (std::string *)(a1 + 136);
    sub_100058DB0(&__dst, "TimedUpdater '");
    size_t v28 = strlen(a4);
    long long v29 = std::string::append(&__dst, a4, v28);
    long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
    v63.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v63.__r_.__value_.__l.__data_ = v30;
    v29->__r_.__value_.__l.__size_ = 0;
    v29->__r_.__value_.__r.__words[2] = 0;
    v29->__r_.__value_.__r.__words[0] = 0;
    long long v31 = std::string::append(&v63, "'", 1uLL);
    std::string::size_type v32 = v31->__r_.__value_.__r.__words[0];
    v66.__r_.__value_.__r.__words[0] = v31->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v66.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v31->__r_.__value_.__r.__words[1] + 7);
    char v33 = HIBYTE(v31->__r_.__value_.__r.__words[2]);
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(a1 + 135) < 0) {
      operator delete(*v22);
    }
    std::string::size_type v34 = v66.__r_.__value_.__r.__words[0];
    *(void *)(a1 + 112) = v32;
    *(void *)(a1 + 120) = v34;
    *(void *)(a1 + 127) = *(std::string::size_type *)((char *)v66.__r_.__value_.__r.__words + 7);
    *(unsigned char *)(a1 + 135) = v33;
    if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v63.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    memset(&v63, 0, sizeof(v63));
    sub_100058DB0(&v63, a4);
    char v35 = HIBYTE(v63.__r_.__value_.__r.__words[2]);
    uint64_t v36 = (std::string *)v63.__r_.__value_.__r.__words[0];
    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v37 = &v63;
    }
    else {
      long long v37 = (std::string *)v63.__r_.__value_.__r.__words[0];
    }
    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v63.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v63.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      do
      {
        int v39 = v37->__r_.__value_.__s.__data_[0];
        if (v39 < 0) {
          __uint32_t v40 = __maskrune(v37->__r_.__value_.__s.__data_[0], 0x500uLL);
        }
        else {
          __uint32_t v40 = _DefaultRuneLocale.__runetype[v39] & 0x500;
        }
        if (v39 != 46 && v40 == 0) {
          v37->__r_.__value_.__s.__data_[0] = 46;
        }
        long long v37 = (std::string *)((char *)v37 + 1);
        --size;
      }
      while (size);
      char v35 = HIBYTE(v63.__r_.__value_.__r.__words[2]);
      uint64_t v36 = (std::string *)v63.__r_.__value_.__r.__words[0];
      long long v27 = (std::string *)(a1 + 136);
    }
    if (v35 >= 0) {
      uint64_t v36 = &v63;
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithFormat(0, 0, @"%sNextUpdate", v36);
    if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v63.__r_.__value_.__l.__data_);
    }
    if (v27 != &__dst)
    {
      v63.__r_.__value_.__r.__words[0] = v27->__r_.__value_.__r.__words[0];
      v27->__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v63.__r_.__value_.__l.__data_);
    }
    sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    memset(&v66, 0, sizeof(v66));
    sub_100058DB0(&v66, a4);
    char v42 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      double v43 = &v66;
    }
    else {
      double v43 = (std::string *)v66.__r_.__value_.__r.__words[0];
    }
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v44 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v44 = v66.__r_.__value_.__l.__size_;
    }
    if (v44)
    {
      do
      {
        int v45 = v43->__r_.__value_.__s.__data_[0];
        if (v45 < 0) {
          __uint32_t v46 = __maskrune(v43->__r_.__value_.__s.__data_[0], 0x500uLL);
        }
        else {
          __uint32_t v46 = _DefaultRuneLocale.__runetype[v45] & 0x500;
        }
        if (v45 != 46 && v46 == 0) {
          v43->__r_.__value_.__s.__data_[0] = 46;
        }
        double v43 = (std::string *)((char *)v43 + 1);
        --v44;
      }
      while (v44);
      char v42 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
    }
    uint64_t v48 = *(void *)(a1 + 64);
    if (v48)
    {
      BOOL v49 = v42 < 0;
      char v50 = &v66;
      if (v49) {
        char v50 = (std::string *)v66.__r_.__value_.__r.__words[0];
      }
      long long v53 = *(const char **)(v48 + 24);
      long long v51 = (const char *)(v48 + 24);
      char v52 = v53;
      uint64_t v54 = *((unsigned __int8 *)v51 + 23);
      int v55 = (char)v54;
      if ((v54 & 0x80u) != 0) {
        uint64_t v54 = *((void *)v51 + 1);
      }
      if (v55 < 0) {
        long long v51 = v52;
      }
      if (!v54) {
        long long v51 = "<invalid>";
      }
      CFStringRef v56 = CFStringCreateWithFormat(0, 0, @"%s-%s", v50, v51);
      CFStringRef v59 = v56;
    }
    else
    {
      if (v42 < 0) {
        sub_10004FC84(&__p, v66.__r_.__value_.__l.__data_, v66.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v66;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = __p;
      }
      CFStringRef v61 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = __dst;
      }
      CFStringRef v64 = 0;
      if (ctu::cf::convert_copy())
      {
        CFStringRef v57 = v61;
        CFStringRef v61 = v64;
        CFStringRef v65 = v57;
        sub_1000558F4((const void **)&v65);
      }
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      CFStringRef v56 = v61;
      CFStringRef v59 = v61;
      CFStringRef v61 = 0;
      sub_1000558F4((const void **)&v61);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v66.__r_.__value_.__l.__data_);
    }
    if (v23 != (const void **)&v59)
    {
      v63.__r_.__value_.__r.__words[0] = (std::string::size_type)*v23;
      unsigned __int8 *v23 = v56;
      CFStringRef v59 = 0;
      sub_1000558F4((const void **)&v63.__r_.__value_.__l.__data_);
    }
    sub_1000558F4((const void **)&v59);
  }
  else
  {
    if (*(char *)(a1 + 135) < 0)
    {
      *(void *)(a1 + 120) = 12;
      uint64_t v22 = *(void ***)(a1 + 112);
    }
    else
    {
      *(unsigned char *)(a1 + 135) = 12;
    }
    strcpy((char *)v22, "TimedUpdater");
    *(_WORD *)(a1 + 80) = 0;
  }
  return a1;
}

void sub_100D20B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, ctu::OsLogLogger *a12, void *a13, uint64_t a14, const void **a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,const void *a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  sub_1000558F4(&a23);
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (*(char *)(v40 - 97) < 0) {
    operator delete(*(void **)(v40 - 120));
  }
  char v42 = *(const void **)(v36 + 152);
  if (v42) {
    _Block_release(v42);
  }
  sub_1000558F4(v37);
  sub_1000558F4(a15);
  if (*(char *)(v36 + 135) < 0) {
    operator delete(*v39);
  }
  sub_10007CA64(v38);
  double v43 = *(std::__shared_weak_count **)(v36 + 72);
  if (v43) {
    sub_10004D2C8(v43);
  }
  std::string::size_type v44 = *(std::__shared_weak_count **)(v36 + 56);
  if (v44) {
    sub_10004D2C8(v44);
  }
  ctu::OsLogLogger::~OsLogLogger(a12);
  sub_100087E88(a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100D20C98(uint64_t a1)
{
  *(void *)a1 = off_101A51EE8;
  sub_100D20D40(a1);
  uint64_t v2 = *(const void **)(a1 + 152);
  if (v2) {
    _Block_release(v2);
  }
  sub_1000558F4((const void **)(a1 + 144));
  sub_1000558F4((const void **)(a1 + 136));
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  sub_10007CA64((const void **)(a1 + 96));
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

BOOL sub_100D20D40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 88));
    dispatch_release(*(dispatch_object_t *)(a1 + 88));
    *(void *)(a1 + 88) = 0;
  }
  return v1 != 0;
}

void sub_100D20D88(uint64_t a1)
{
  sub_100D20C98(a1);

  operator delete();
}

void sub_100D20DC0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  sub_100D20D40(a1);
  uint64_t v2 = *(const void **)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  int v3 = v2;
  sub_10007CA64(&v3);
  sub_100D20E14(a1);
}

void sub_100D20E14(uint64_t a1)
{
  if (*(void *)(a1 + 136)) {
    uint64_t v1 = sub_1000810B8;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1 && *(unsigned char *)(a1 + 81))
  {
    if (*(void *)(a1 + 96)) {
      int v3 = sub_1001908E4;
    }
    else {
      int v3 = 0;
    }
    uint64_t v4 = *(void *)(a1 + 64);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    CFStringRef v6 = ServiceMap;
    if (v3)
    {
      if (v4)
      {
        if ((v7 & 0x8000000000000000) != 0)
        {
          unint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v9 = 5381;
          do
          {
            unint64_t v7 = v9;
            unsigned int v10 = *v8++;
            uint64_t v9 = (33 * v9) ^ v10;
          }
          while (v10);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v32 = v7;
        uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v32);
        if (v11)
        {
          uint64_t v13 = v11[3];
          uint64_t v12 = (std::__shared_weak_count *)v11[4];
          if (v12)
          {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v6);
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v12);
LABEL_32:
            (*(void (**)(uint64_t, uint64_t, void, void, void, void, uint64_t, void))(*(void *)v13 + 16))(v13, *(void *)(a1 + 64) + 24, *(void *)(a1 + 136), *(void *)(a1 + 96), 0, 0, 1, 0);
            goto LABEL_48;
          }
        }
        else
        {
          uint64_t v13 = 0;
        }
        std::mutex::unlock(v6);
        uint64_t v12 = 0;
        goto LABEL_32;
      }
      uint64_t v20 = "8UStorage";
      if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
      {
        uint64_t v21 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v22 = 5381;
        do
        {
          uint64_t v20 = (const char *)v22;
          unsigned int v23 = *v21++;
          uint64_t v22 = (33 * v22) ^ v23;
        }
        while (v23);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v32 = (unint64_t)v20;
      uint64_t v24 = sub_10004D37C(&v6[1].__m_.__sig, &v32);
      if (v24)
      {
        uint64_t v25 = (os_unfair_lock_s *)v24[3];
        uint64_t v12 = (std::__shared_weak_count *)v24[4];
        if (v12)
        {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v6);
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
LABEL_44:
          sub_1000825C4(v25, *(const __CFString **)(a1 + 136), *(const void **)(a1 + 96), 0, 0, 1u, 0, 0);
          goto LABEL_48;
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      std::mutex::unlock(v6);
      uint64_t v12 = 0;
      goto LABEL_44;
    }
    if (v4)
    {
      if ((v14 & 0x8000000000000000) != 0)
      {
        long long v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          unint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v32 = v14;
      uint64_t v18 = sub_10004D37C(&v6[1].__m_.__sig, &v32);
      if (v18)
      {
        uint64_t v19 = v18[3];
        uint64_t v12 = (std::__shared_weak_count *)v18[4];
        if (v12)
        {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v6);
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
LABEL_41:
          (*(void (**)(uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)v19 + 32))(v19, *(void *)(a1 + 64) + 24, *(void *)(a1 + 136), 0, 0, 1);
          goto LABEL_48;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v6);
      uint64_t v12 = 0;
      goto LABEL_41;
    }
    uint64_t v26 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      long long v27 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = (const char *)v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = (unint64_t)v26;
    long long v30 = sub_10004D37C(&v6[1].__m_.__sig, &v32);
    if (v30)
    {
      long long v31 = (os_unfair_lock_s *)v30[3];
      uint64_t v12 = (std::__shared_weak_count *)v30[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
LABEL_47:
        sub_1000832B0(v31, *(const __CFString **)(a1 + 136), 0, 0, 1u);
LABEL_48:
        if (v12) {
          sub_10004D2C8(v12);
        }
        return;
      }
    }
    else
    {
      long long v31 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    goto LABEL_47;
  }
}

void sub_100D211A8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D211E4(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = (CFDateRef *)(a1 + 96);
  if (a2)
  {
    CFDateRef v5 = *v4;
    *uint64_t v4 = 0;
    *(void *)&buf[0] = v5;
    p_CFTypeRef cf = (const void **)buf;
    goto LABEL_54;
  }
  if (*v4) {
    unint64_t v7 = sub_1001908E4;
  }
  else {
    unint64_t v7 = 0;
  }
  if (v7) {
    return 0;
  }
  CFTypeRef cf = 0;
  if (*(void *)(a1 + 136)) {
    unint64_t v8 = sub_1000810B8;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v8 && *(unsigned char *)(a1 + 81))
  {
    uint64_t v9 = *(Registry **)(a1 + 48);
    if (*(void *)(a1 + 64))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9);
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&buf[0] = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
      if (v16)
      {
        uint64_t v18 = v16[3];
        unsigned int v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
LABEL_28:
          (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)v18 + 24))(&v84, v18, *(void *)(a1 + 64) + 24, *(void *)(a1 + 136), 0, 0, 1);
LABEL_32:
          sub_100201EE4(v85, &v84);
          CFTypeRef cf = *(CFTypeRef *)&v85[0].__padding_;
          *(void *)&v85[0].__padding_ = 0;
          *(void *)&buf[0] = 0;
          sub_10007CA64((const void **)buf);
          sub_10007CA64((const void **)v85);
          sub_1000577C4(&v84);
          if (v17) {
            sub_10004D2C8(v17);
          }
          CFDateRef v19 = (const __CFDate *)cf;
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      unsigned int v17 = 0;
      goto LABEL_28;
    }
    uint64_t v20 = (std::mutex *)Registry::getServiceMap(v9);
    uint64_t v21 = v20;
    uint64_t v22 = "8UStorage";
    if (((unint64_t)"8UStorage" & 0x8000000000000000) != 0)
    {
      unsigned int v23 = (unsigned __int8 *)((unint64_t)"8UStorage" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        uint64_t v22 = (const char *)v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(v20);
    *(void *)&buf[0] = v22;
    uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
    if (v26)
    {
      long long v27 = (os_unfair_lock_s *)v26[3];
      unsigned int v17 = (std::__shared_weak_count *)v26[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v21);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
LABEL_31:
        sub_100083254(v27, *(const __CFString **)(a1 + 136), 0, 0, 1u, &v84);
        goto LABEL_32;
      }
    }
    else
    {
      long long v27 = 0;
    }
    std::mutex::unlock(v21);
    unsigned int v17 = 0;
    goto LABEL_31;
  }
  CFDateRef v19 = 0;
LABEL_35:
  if (v19) {
    uint64_t v28 = sub_1001908E4;
  }
  else {
    uint64_t v28 = 0;
  }
  if (v28)
  {
    CFDateRef theDate = v19;
    if (v19) {
      CFRetain(v19);
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v30 = CFDateCreate(kCFAllocatorDefault, Current);
    *(void *)&buf[0] = v30;
    if (v30) {
      long long v31 = sub_1001908E4;
    }
    else {
      long long v31 = 0;
    }
    if (v31)
    {
      double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(theDate, v30);
      sub_10007CA64((const void **)buf);
      sub_10007CA64((const void **)&theDate);
      if (TimeIntervalSinceDate < 0.0)
      {
        sub_100D20E14(a1);
        char v33 = *(std::__shared_weak_count **)(a1 + 16);
        if (v33)
        {
          std::string::size_type v34 = std::__shared_weak_count::lock(v33);
          if (v34)
          {
            atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v34);
            char v35 = *(std::__shared_weak_count **)(a1 + 16);
            if (v35 && std::__shared_weak_count::lock(v35)) {
              operator new();
            }
            sub_100088B9C();
          }
        }
        sub_100088B9C();
      }
    }
    else
    {
      sub_10007CA64((const void **)buf);
      sub_10007CA64((const void **)&theDate);
    }
    sub_100602120((const void **)(a1 + 96), &cf);
  }
  p_CFTypeRef cf = &cf;
LABEL_54:
  sub_10007CA64(p_cf);
  if (*v4) {
    uint64_t v36 = sub_1001908E4;
  }
  else {
    uint64_t v36 = 0;
  }
  if (v36)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(*v4);
    CFAbsoluteTime v38 = CFAbsoluteTimeGetCurrent();
    uint64_t v39 = (uint64_t)(AbsoluteTime - v38) & ~((uint64_t)(AbsoluteTime - v38) >> 63);
    uint64_t v40 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_86;
    }
    uint64_t v41 = *(PersonalityInfo **)(a1 + 64);
    if (v41)
    {
      char v42 = (const char *)PersonalityInfo::logPrefix(v41);
      if (*(void *)(a1 + 64))
      {
        double v43 = " ";
LABEL_72:
        char v52 = (void *)(a1 + 112);
        if (*(char *)(a1 + 135) < 0) {
          char v52 = (void *)*v52;
        }
        LODWORD(buf[0]) = 136315906;
        *(void *)((char *)buf + 4) = v42;
        WORD6(buf[0]) = 2080;
        *(void *)((char *)buf + 14) = v43;
        WORD3(buf[1]) = 2080;
        *((void *)&buf[1] + 1) = v52;
        LOWORD(buf[2]) = 2048;
        *(void *)((char *)&buf[2] + 2) = v39;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sRestore %s from persisted value: %+lld seconds from now", (uint8_t *)buf, 0x2Au);
        goto LABEL_86;
      }
    }
    else
    {
      char v42 = "";
    }
    double v43 = "";
    goto LABEL_72;
  }
  v85[0].__padding_ = 0;
  sub_10016AA28(v85);
  uint64_t v45 = *(void *)(a1 + 160);
  uint64_t v44 = *(void *)(a1 + 168);
  if (v44 + v45)
  {
    uint64_t v47 = v45 + v44;
    unint64_t v48 = v47 + 1;
    if (v47 == -1)
    {
      sub_100D21EEC((uint64_t)buf, (uint64_t)v85, 0x40uLL);
      uint64_t v46 = sub_100D21FDC((uint64_t)buf);
    }
    else
    {
      unint64_t v49 = __clz(v48);
      uint64_t v50 = 63;
      memset(&buf[1], 0, 48);
      if (((v48 << v49) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
        uint64_t v50 = 64;
      }
      buf[0] = 0uLL;
      sub_100D21EEC((uint64_t)buf, (uint64_t)v85, v50 - v49);
      do
        unint64_t v51 = sub_100D21FDC((uint64_t)buf);
      while (v51 >= v48);
      uint64_t v46 = v51 - v45;
    }
  }
  else
  {
    uint64_t v46 = -v45;
  }
  uint64_t v53 = *(void *)(a1 + 104);
  uint64_t v54 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    int v55 = *(PersonalityInfo **)(a1 + 64);
    if (v55)
    {
      CFStringRef v56 = (const char *)PersonalityInfo::logPrefix(v55);
      uint64_t v57 = *(void *)(a1 + 64);
    }
    else
    {
      uint64_t v57 = 0;
      CFStringRef v56 = "";
    }
    char v58 = " ";
    if (!v57) {
      char v58 = "";
    }
    CFStringRef v59 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      CFStringRef v59 = (void *)*v59;
    }
    uint64_t v60 = *(void *)(a1 + 104);
    LODWORD(buf[0]) = 136316162;
    *(void *)((char *)buf + 4) = v56;
    WORD6(buf[0]) = 2080;
    *(void *)((char *)buf + 14) = v58;
    WORD3(buf[1]) = 2080;
    *((void *)&buf[1] + 1) = v59;
    LOWORD(buf[2]) = 2048;
    *(void *)((char *)&buf[2] + 2) = v60;
    WORD5(buf[2]) = 2048;
    *(void *)((char *)&buf[2] + 12) = v46;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s%sCreating next %s for %ld minutes %+lld seconds jitter", (uint8_t *)buf, 0x34u);
  }
  CFAbsoluteTime v61 = CFAbsoluteTimeGetCurrent();
  uint64_t v39 = v46 + 60 * v53;
  CFDateRef v62 = CFDateCreate(kCFAllocatorDefault, v61 + (double)v39 + 600.0);
  uint64_t v63 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = v62;
  *(void *)&buf[0] = v63;
  sub_10007CA64((const void **)buf);
  sub_100D20E14(a1);
  std::random_device::~random_device(v85);
LABEL_86:
  sub_100D20D40(a1);
  *(void *)(a1 + 88) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 3uLL, 0, *(dispatch_queue_t *)(a1 + 24));
  CFStringRef v64 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v64 || (uint64_t v65 = *(void *)(a1 + 8), (v66 = std::__shared_weak_count::lock(v64)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v67 = v66;
  p_shared_weak_owners = &v66->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v66->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v66);
  long long v69 = *(NSObject **)(a1 + 88);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 1174405120;
  handler[2] = sub_100D21BA4;
  handler[3] = &unk_101A51EF8;
  handler[4] = a1;
  handler[5] = v65;
  unint64_t v81 = v67;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  dispatch_source_set_event_handler(v69, handler);
  long long v70 = *(NSObject **)(a1 + 88);
  dispatch_time_t v71 = dispatch_walltime(0, 1000000000 * v39);
  dispatch_source_set_timer(v70, v71, 0xFFFFFFFFFFFFFFFFLL, 0x1388uLL);
  dispatch_activate(*(dispatch_object_t *)(a1 + 88));
  if (!*(unsigned char *)(a1 + 80)) {
    goto LABEL_107;
  }
  if (!(*(void *)(a1 + 144) ? sub_1000810B8 : 0)) {
    goto LABEL_107;
  }
  if (!(*v4 ? sub_1001908E4 : 0)) {
    goto LABEL_107;
  }
  unint64_t v74 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v75 = *(PersonalityInfo **)(a1 + 64);
    if (v75)
    {
      uint64_t v76 = (const char *)PersonalityInfo::logPrefix(v75);
      if (*(void *)(a1 + 64))
      {
        uint64_t v77 = " ";
LABEL_103:
        char v78 = (void *)(a1 + 112);
        if (*(char *)(a1 + 135) < 0) {
          char v78 = (void *)*v78;
        }
        LODWORD(buf[0]) = 136315650;
        *(void *)((char *)buf + 4) = v76;
        WORD6(buf[0]) = 2080;
        *(void *)((char *)buf + 14) = v77;
        WORD3(buf[1]) = 2080;
        *((void *)&buf[1] + 1) = v78;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%sWill power up AP on %s expiry", (uint8_t *)buf, 0x20u);
        goto LABEL_106;
      }
    }
    else
    {
      uint64_t v76 = "";
    }
    uint64_t v77 = "";
    goto LABEL_103;
  }
LABEL_106:
  CPCancelWakeAtDateWithIdentifier();
  CPScheduleWakeAtDateWithIdentifier();
LABEL_107:
  if (v81) {
    std::__shared_weak_count::__release_weak(v81);
  }
  std::__shared_weak_count::__release_weak(v67);
  return 0;
}

void sub_100D21AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, int a18, const void *a19, __int16 a20,char a21,char a22,int a23,std::random_device a24,int a25,int a26,char a27)
{
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_10007CA64(&a19);
  _Unwind_Resume(a1);
}

void sub_100D21BA4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFDateRef v5 = v4;
      if (a1[5] && sub_100D20D40(v3))
      {
        CFStringRef v6 = *(const void **)(v3 + 96);
        *(void *)(v3 + 96) = 0;
        unint64_t v8 = v6;
        sub_10007CA64(&v8);
        sub_100D20E14(v3);
        uint64_t v7 = *(void *)(v3 + 152);
        if (v7) {
          (*(void (**)(void))(v7 + 16))();
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100D21C38(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D21C4C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D21C68(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D21C78(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100D21D44(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100D21E1C);
  __cxa_rethrow();
}

void sub_100D21D6C(_Unwind_Exception *a1)
{
}

void sub_100D21D84(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D21DBC(uint64_t a1)
{
}

uint64_t sub_100D21DD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D21E1C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100D21E48(void **a1)
{
  char v1 = *a1;
  uint64_t v9 = a1;
  unsigned int v10 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFStringRef v6 = v4;
      if (v1[1])
      {
        uint64_t v7 = *(void *)(v3 + 152);
        if (v7) {
          (*(void (**)(uint64_t, uint64_t))(v7 + 16))(v7, v5);
        }
      }
      sub_10004D2C8(v6);
    }
  }
  sub_100004A84((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100D21EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100D21EEC(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)__n128 result = a2;
  *(void *)(result + 8) = a3;
  if ((a3 & 0x1F) != 0) {
    unint64_t v3 = (a3 >> 5) + 1;
  }
  else {
    unint64_t v3 = a3 >> 5;
  }
  unint64_t v4 = a3 / v3;
  *(void *)(result + 16) = a3 / v3;
  *(void *)(result + 24) = v3;
  unint64_t v5 = (-1 << (a3 / v3)) & (unint64_t)&_mh_execute_header;
  if (a3 / v3 >= 0x40) {
    unint64_t v5 = 0;
  }
  *(void *)(result + 40) = v5;
  if ((v5 ^ (unint64_t)&_mh_execute_header) > v5 / v3)
  {
    ++v3;
    unint64_t v4 = a3 / v3;
    *(void *)(result + 16) = a3 / v3;
    *(void *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      *(void *)(result + 32) = v3 + v4 * v3 - a3;
      *(void *)(result + 40) = 0;
      LODWORD(v4) = 64;
      goto LABEL_16;
    }
    *(void *)(result + 40) = (-1 << v4) & (unint64_t)&_mh_execute_header;
  }
  *(void *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 >= 0x3F)
  {
LABEL_16:
    *(void *)(result + 48) = 0;
    int v8 = -(int)v4;
    unsigned int v7 = -1;
    *(_DWORD *)(result + 56) = 0xFFFFFFFF >> v8;
    goto LABEL_17;
  }
  *(void *)(result + 48) = 0x80000000uLL >> v4 << (v4 + 1);
  unsigned int v6 = 0xFFFFFFFF >> -(char)v4;
  if (!v4) {
    unsigned int v6 = 0;
  }
  *(_DWORD *)(result + 56) = v6;
  if (v4 >= 0x1F) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 0xFFFFFFFF >> ~(_BYTE)v4;
  }
LABEL_17:
  *(_DWORD *)(result + 60) = v7;
  return result;
}

uint64_t sub_100D21FDC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    unint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      do
        std::random_device::result_type v4 = std::random_device::operator()(*(std::random_device **)a1);
      while (*(void *)(a1 + 40) <= (unint64_t)v4);
      unint64_t v5 = *(void *)(a1 + 16);
      if (v5 >= 0x40) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = v3 << v5;
      }
      uint64_t v3 = v6 + (*(_DWORD *)(a1 + 56) & v4);
      ++v2;
      unint64_t v7 = *(void *)(a1 + 32);
    }
    while (v2 < v7);
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v7 = 0;
  }
  for (; v7 < *(void *)(a1 + 24); ++v7)
  {
    do
      std::random_device::result_type v8 = std::random_device::operator()(*(std::random_device **)a1);
    while (*(void *)(a1 + 48) <= (unint64_t)v8);
    unint64_t v9 = *(void *)(a1 + 16);
    if (v9 >= 0x3F) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v3 << (v9 + 1);
    }
    uint64_t v3 = v10 + (*(_DWORD *)(a1 + 60) & v8);
  }
  return v3;
}

uint64_t sub_100D220B0(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5, void *a6, void *a7, void *a8)
{
  uint64_t v16 = "vinyl.sUnknown";
  if (a5 == 2) {
    uint64_t v16 = "vinyl.s2";
  }
  if (a5 == 1) {
    unsigned int v17 = "vinyl.s1";
  }
  else {
    unsigned int v17 = v16;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v25, kCtLoggingSystemName, v17);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v18 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v18) {
    dispatch_retain(v18);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v26, &v25);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v26);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v26);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  *(void *)a1 = off_101A52030;
  *(void *)(a1 + 48) = *a2;
  uint64_t v19 = a2[1];
  *(void *)(a1 + 56) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v20 = a4[1];
  *(void *)(a1 + 72) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 80) = a5;
  *(_DWORD *)(a1 + 84) = (*(uint64_t (**)(void, uint64_t))(*(void *)*a4 + 48))(*a4, a5);
  *(void *)(a1 + 88) = *a6;
  uint64_t v21 = a6[1];
  *(void *)(a1 + 96) = v21;
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 104) = *a7;
  uint64_t v22 = a7[1];
  *(void *)(a1 + 112) = v22;
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = *a8;
  uint64_t v23 = a8[1];
  *(void *)(a1 + 128) = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 321) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  return a1;
}

void sub_100D222CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v16 = *(std::__shared_weak_count **)(v12 + 72);
  if (v16) {
    sub_10004D2C8(v16);
  }
  unsigned int v17 = *(std::__shared_weak_count **)(v12 + 56);
  if (v17) {
    sub_10004D2C8(v17);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v13);
  _Unwind_Resume(a1);
}

void *sub_100D22328(void *a1)
{
  *a1 = off_101A52030;
  uint64_t v2 = a1[50];
  a1[50] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void **)a1[45];
  std::random_device::result_type v4 = (void **)a1[46];
  if (v4 == v3)
  {
    std::random_device::result_type v8 = a1 + 49;
    std::random_device::result_type v4 = (void **)a1[45];
  }
  else
  {
    unint64_t v5 = a1[48];
    uint64_t v6 = &v3[v5 >> 9];
    unint64_t v7 = (const void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    std::random_device::result_type v8 = a1 + 49;
    uint64_t v9 = *(uint64_t *)((char *)v3 + (((a1[49] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[49] + v5) & 0x1FF);
    if (v7 != (const void **)v9)
    {
      do
      {
        uint64_t v10 = *v7++;
        sub_100D38F54(v10);
        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v11 = (const void **)v6[1];
          ++v6;
          unint64_t v7 = v11;
        }
      }
      while (v7 != (const void **)v9);
      uint64_t v3 = (void **)a1[45];
      std::random_device::result_type v4 = (void **)a1[46];
    }
  }
  *std::random_device::result_type v8 = 0;
  unint64_t v12 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      std::random_device::result_type v4 = (void **)a1[46];
      uint64_t v3 = (void **)(a1[45] + 8);
      a1[45] = v3;
      unint64_t v12 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 256;
    goto LABEL_16;
  }
  if (v13 == 2)
  {
    uint64_t v14 = 512;
LABEL_16:
    a1[48] = v14;
  }
  if (v3 != v4)
  {
    do
    {
      unsigned int v15 = *v3++;
      operator delete(v15);
    }
    while (v3 != v4);
    uint64_t v17 = a1[45];
    uint64_t v16 = a1[46];
    if (v16 != v17) {
      a1[46] = v16 + ((v17 - v16 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v18 = (void *)a1[44];
  if (v18) {
    operator delete(v18);
  }
  uint64_t v19 = a1[43];
  a1[43] = 0;
  if (v19) {
    sub_1007A8468((uint64_t)(a1 + 43), v19);
  }
  uint64_t v20 = (void **)a1[37];
  uint64_t v21 = (void **)a1[38];
  if (v21 == v20)
  {
    uint64_t v26 = a1 + 41;
    uint64_t v21 = (void **)a1[37];
  }
  else
  {
    unint64_t v22 = a1[40];
    uint64_t v23 = &v20[v22 >> 8];
    uint64_t v24 = (uint64_t)*v23;
    uint64_t v25 = (uint64_t)*v23 + 16 * v22;
    uint64_t v26 = a1 + 41;
    uint64_t v27 = *(uint64_t *)((char *)v20 + (((a1[41] + v22) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*((unsigned char *)a1 + 328) + v22);
    if (v25 != v27)
    {
      do
      {
        uint64_t v28 = *(std::__shared_weak_count **)(v25 + 8);
        if (v28)
        {
          sub_10004D2C8(v28);
          uint64_t v24 = (uint64_t)*v23;
        }
        v25 += 16;
        if (v25 - v24 == 4096)
        {
          uint64_t v29 = (uint64_t)v23[1];
          ++v23;
          uint64_t v24 = v29;
          uint64_t v25 = v29;
        }
      }
      while (v25 != v27);
      uint64_t v20 = (void **)a1[37];
      uint64_t v21 = (void **)a1[38];
    }
  }
  *uint64_t v26 = 0;
  unint64_t v30 = (char *)v21 - (char *)v20;
  if ((unint64_t)((char *)v21 - (char *)v20) >= 0x11)
  {
    do
    {
      operator delete(*v20);
      uint64_t v21 = (void **)a1[38];
      uint64_t v20 = (void **)(a1[37] + 8);
      a1[37] = v20;
      unint64_t v30 = (char *)v21 - (char *)v20;
    }
    while ((unint64_t)((char *)v21 - (char *)v20) > 0x10);
  }
  unint64_t v31 = v30 >> 3;
  if (v31 == 1)
  {
    uint64_t v32 = 128;
    goto LABEL_40;
  }
  if (v31 == 2)
  {
    uint64_t v32 = 256;
LABEL_40:
    a1[40] = v32;
  }
  if (v20 != v21)
  {
    do
    {
      char v33 = *v20++;
      operator delete(v33);
    }
    while (v20 != v21);
    uint64_t v35 = a1[37];
    uint64_t v34 = a1[38];
    if (v34 != v35) {
      a1[38] = v34 + ((v35 - v34 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v36 = (void *)a1[36];
  if (v36) {
    operator delete(v36);
  }
  long long v37 = (void **)a1[31];
  CFAbsoluteTime v38 = (void **)a1[32];
  if (v38 == v37)
  {
    double v43 = a1 + 35;
    CFAbsoluteTime v38 = (void **)a1[31];
  }
  else
  {
    unint64_t v39 = a1[34];
    uint64_t v40 = &v37[v39 >> 8];
    uint64_t v41 = (uint64_t)*v40;
    uint64_t v42 = (uint64_t)*v40 + 16 * v39;
    double v43 = a1 + 35;
    uint64_t v44 = *(uint64_t *)((char *)v37 + (((a1[35] + v39) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*((unsigned char *)a1 + 280) + v39);
    if (v42 != v44)
    {
      do
      {
        uint64_t v45 = *(std::__shared_weak_count **)(v42 + 8);
        if (v45)
        {
          sub_10004D2C8(v45);
          uint64_t v41 = (uint64_t)*v40;
        }
        v42 += 16;
        if (v42 - v41 == 4096)
        {
          uint64_t v46 = (uint64_t)v40[1];
          ++v40;
          uint64_t v41 = v46;
          uint64_t v42 = v46;
        }
      }
      while (v42 != v44);
      long long v37 = (void **)a1[31];
      CFAbsoluteTime v38 = (void **)a1[32];
    }
  }
  void *v43 = 0;
  unint64_t v47 = (char *)v38 - (char *)v37;
  if ((unint64_t)((char *)v38 - (char *)v37) >= 0x11)
  {
    do
    {
      operator delete(*v37);
      CFAbsoluteTime v38 = (void **)a1[32];
      long long v37 = (void **)(a1[31] + 8);
      a1[31] = v37;
      unint64_t v47 = (char *)v38 - (char *)v37;
    }
    while ((unint64_t)((char *)v38 - (char *)v37) > 0x10);
  }
  unint64_t v48 = v47 >> 3;
  if (v48 == 1)
  {
    uint64_t v49 = 128;
    goto LABEL_62;
  }
  if (v48 == 2)
  {
    uint64_t v49 = 256;
LABEL_62:
    a1[34] = v49;
  }
  if (v37 != v38)
  {
    do
    {
      uint64_t v50 = *v37++;
      operator delete(v50);
    }
    while (v37 != v38);
    uint64_t v52 = a1[31];
    uint64_t v51 = a1[32];
    if (v51 != v52) {
      a1[32] = v51 + ((v52 - v51 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v53 = (void *)a1[30];
  if (v53) {
    operator delete(v53);
  }
  uint64_t v54 = (void **)a1[25];
  int v55 = (void **)a1[26];
  if (v55 == v54)
  {
    CFStringRef v56 = a1 + 29;
    int v55 = (void **)a1[25];
  }
  else
  {
    CFStringRef v56 = a1 + 29;
    unint64_t v57 = a1[28];
    char v58 = &v54[v57 >> 8];
    uint64_t v59 = (uint64_t)*v58;
    uint64_t v60 = (uint64_t)*v58 + 16 * v57;
    uint64_t v61 = *(uint64_t *)((char *)v54 + (((a1[29] + v57) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*((unsigned char *)a1 + 232) + v57);
    if (v60 != v61)
    {
      do
      {
        CFDateRef v62 = *(std::__shared_weak_count **)(v60 + 8);
        if (v62)
        {
          sub_10004D2C8(v62);
          uint64_t v59 = (uint64_t)*v58;
        }
        v60 += 16;
        if (v60 - v59 == 4096)
        {
          uint64_t v63 = (uint64_t)v58[1];
          ++v58;
          uint64_t v59 = v63;
          uint64_t v60 = v63;
        }
      }
      while (v60 != v61);
      uint64_t v54 = (void **)a1[25];
      int v55 = (void **)a1[26];
    }
  }
  *CFStringRef v56 = 0;
  unint64_t v64 = (char *)v55 - (char *)v54;
  if ((unint64_t)((char *)v55 - (char *)v54) >= 0x11)
  {
    do
    {
      operator delete(*v54);
      int v55 = (void **)a1[26];
      uint64_t v54 = (void **)(a1[25] + 8);
      a1[25] = v54;
      unint64_t v64 = (char *)v55 - (char *)v54;
    }
    while ((unint64_t)((char *)v55 - (char *)v54) > 0x10);
  }
  unint64_t v65 = v64 >> 3;
  if (v65 == 1)
  {
    uint64_t v66 = 128;
    goto LABEL_84;
  }
  if (v65 == 2)
  {
    uint64_t v66 = 256;
LABEL_84:
    a1[28] = v66;
  }
  if (v54 != v55)
  {
    do
    {
      unint64_t v67 = *v54++;
      operator delete(v67);
    }
    while (v54 != v55);
    uint64_t v69 = a1[25];
    uint64_t v68 = a1[26];
    if (v68 != v69) {
      a1[26] = v68 + ((v69 - v68 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  long long v70 = (void *)a1[24];
  if (v70) {
    operator delete(v70);
  }
  dispatch_time_t v71 = (std::__shared_weak_count *)a1[23];
  if (v71) {
    sub_10004D2C8(v71);
  }
  char v72 = (std::__shared_weak_count *)a1[21];
  if (v72) {
    sub_10004D2C8(v72);
  }
  uint64_t v73 = (std::__shared_weak_count *)a1[18];
  if (v73) {
    sub_10004D2C8(v73);
  }
  unint64_t v74 = (std::__shared_weak_count *)a1[16];
  if (v74) {
    std::__shared_weak_count::__release_weak(v74);
  }
  unint64_t v75 = (std::__shared_weak_count *)a1[14];
  if (v75) {
    sub_10004D2C8(v75);
  }
  uint64_t v76 = (std::__shared_weak_count *)a1[12];
  if (v76) {
    sub_10004D2C8(v76);
  }
  uint64_t v77 = (std::__shared_weak_count *)a1[9];
  if (v77) {
    sub_10004D2C8(v77);
  }
  char v78 = (std::__shared_weak_count *)a1[7];
  if (v78) {
    sub_10004D2C8(v78);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100D2289C(void *a1)
{
  sub_100D22328(a1);

  operator delete();
}

void sub_100D228D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  if (v1)
  {
    *(unsigned char *)(a1 + 336) = 0;
    *(_DWORD *)(a1 + 156) = 0;
    uint64_t v3 = *(void *)(v1 + 176);
    if (v3 && ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3) & 1) == 0)
    {
      std::random_device::result_type v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband reset detected: cancelling the receipts operation", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(*(void *)(a1 + 160) + 176) + 24))(*(void *)(*(void *)(a1 + 160) + 176));
    }
    uint64_t v5 = *(void *)(*(void *)(a1 + 160) + 160);
    if (v5 && ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5) & 1) == 0)
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Baseband reset detected: pausing the install operation", v9, 2u);
      }
      (*(void (**)(void))(**(void **)(*(void *)(a1 + 160) + 160) + 40))(*(void *)(*(void *)(a1 + 160) + 160));
    }
    if (*(unsigned char *)(*(void *)(a1 + 160) + 154))
    {
      unint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::random_device::result_type v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I baseband reset while fetch in progress", v8, 2u);
      }
    }
  }
}

void sub_100D22A88(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      unint64_t v7 = v6;
      if (a1[5])
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 1174405120;
        void v16[2] = sub_100D22C44;
        void v16[3] = &unk_101A52040;
        memset(&v16[5], 0, 17);
        v16[4] = v5;
        int v8 = *a2;
        if (v8 == 2)
        {
          LOBYTE(v16[5]) = 2;
          *(_WORD *)((char *)&v16[5] + 1) = *(_WORD *)(a2 + 1);
          BYTE3(v16[5]) = a2[3];
        }
        else if (v8 == 1)
        {
          LOBYTE(v16[5]) = 1;
          *(_OWORD *)((char *)&v16[5] + 1) = *(_OWORD *)(a2 + 1);
        }
        uint64_t v9 = (std::__shared_weak_count *)v5[2];
        if (!v9 || (v10 = v5[1], (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        unint64_t v12 = v11;
        unint64_t v13 = v5[3];
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 1174405120;
        v14[2] = sub_100D391E4;
        v14[3] = &unk_101A52AE8;
        v14[5] = v10;
        unsigned int v15 = v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        v14[4] = v16;
        dispatch_async(v13, v14);
        if (v15) {
          sub_10004D2C8(v15);
        }
        sub_10004D2C8(v12);
        LOBYTE(v16[5]) = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D22C38(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100D22C44(uint64_t a1)
{
  uint64_t v2 = (unsigned __int8 *)(a1 + 40);
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v1 == 2)
  {
    int v13 = *(unsigned __int8 *)(a1 + 41);
    if (v13 == 3)
    {
      unsigned int v15 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = asString();
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I CSN temporarily failed; will try again later (availability left at %s)",
          __p,
          0xCu);
      }
    }
    else if (v13 == 6)
    {
      uint64_t v14 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Sim not supported; clearing CSN",
          __p,
          2u);
      }
      sub_100D22F74(v3, 2u);
    }
    else
    {
      uint64_t v16 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        sub_100D2316C(v2);
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "CSN retrieval failed with error %s; disabling Vinyl",
          __p,
          0xCu);
      }
      sub_100D22F74(v3, 2u);
    }
  }
  else
  {
    if (v1 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    uint64_t v4 = *(void *)(v3 + 160);
    if (v4
      && ((uint64_t v6 = *(void *)(v4 + 8), v5 = *(void *)(v4 + 16), v6 == *(void *)(a1 + 41))
        ? (BOOL v7 = v5 == *(void *)(a1 + 49))
        : (BOOL v7 = 0),
          v7))
    {
      uint64_t v17 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        sCardSerialNumberAsString();
        uint64_t v18 = v21 >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)long long buf = 136315138;
        uint64_t v23 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I CSN did not change: %s", buf, 0xCu);
        if (v21 < 0) {
          operator delete(*(void **)__p);
        }
      }
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 41);
      uint64_t v9 = *(void *)(a1 + 49);
      sub_100D23B14(*(void **)(a1 + 32));
      uint64_t v10 = (char *)operator new(0x118uLL);
      *((void *)v10 + 1) = 0;
      *((void *)v10 + 2) = 0;
      *(void *)uint64_t v10 = off_101A52B28;
      int v11 = *(_DWORD *)(v3 + 80);
      *((_DWORD *)v10 + 6) = 1;
      *((_DWORD *)v10 + 7) = v11;
      *((void *)v10 + 4) = v8;
      *((void *)v10 + 5) = v9;
      v10[48] = 0;
      v10[112] = 0;
      v10[136] = 0;
      v10[144] = 0;
      v10[168] = 0;
      *((void *)v10 + 34) = 0;
      *((void *)v10 + 11) = 0;
      *((void *)v10 + 12) = 0;
      *((void *)v10 + 10) = 0;
      *((_DWORD *)v10 + 26) = 0;
      *((_DWORD *)v10 + 44) = 0;
      *((_WORD *)v10 + 90) = 0;
      *(_OWORD *)(v10 + 184) = 0u;
      *(_OWORD *)(v10 + 200) = 0u;
      v10[216] = 0;
      unint64_t v12 = *(std::__shared_weak_count **)(v3 + 168);
      *(void *)(v3 + 160) = v10 + 24;
      *(void *)(v3 + 168) = v10;
      if (v12) {
        sub_10004D2C8(v12);
      }
      sub_100D23794(v3);
    }
    sub_100D22F74(v3, 3u);
  }
}

void sub_100D22F58(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D22F74(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 152) == a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v8 = 136315138;
      *(void *)&v8[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Vinyl availability has not changed: %s", v8, 0xCu);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 152) = a2;
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v8 = 136315394;
      *(void *)&v8[4] = asString();
      *(_WORD *)&v8[12] = 2080;
      *(void *)&v8[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Vinyl availability changing from %s to %s", v8, 0x16u);
    }
    if (a2 <= 6 && ((1 << a2) & 0x56) != 0) {
      sub_100D23C00((void *)a1);
    }
    int v6 = *(_DWORD *)(a1 + 80);
    *(void *)uint64_t v8 = _NSConcreteStackBlock;
    *(void *)&char v8[8] = 0x40000000;
    *(void *)&uint8_t v8[16] = sub_1004EFDE4;
    uint64_t v9 = &unk_1019DB118;
    int v10 = v6;
    BOOL v11 = a2 == 3;
    sub_1004EFC04((wis::MetricFactory *)0x800C8);
  }
  int v7 = *(_DWORD *)(a1 + 152);
  if (*(unsigned char *)(a1 + 336) && ((v7 - 3) & 0xFFFFFFFD) == 0)
  {
    sub_100D25690((void *)a1);
    sub_100D259C0(a1);
  }
  else if ((v7 - 1) <= 1)
  {
    sub_100D23B14((void *)a1);
  }
}

unsigned __int8 *sub_100D2316C(unsigned __int8 *a1)
{
  int v1 = *a1;
  if (v1 != 2)
  {
    if (v1 == 1)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(exception);
      uint64_t v5 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      uint64_t v5 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(exception, v4, (void (*)(void *))v5);
  }
  return a1 + 1;
}

void sub_100D231F4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100D2320C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = (unsigned char *)(a1 + 40);
  v2[16] = 0;
  return sub_100D38F74(v2, (unsigned __int8 *)(a2 + 40));
}

uint64_t sub_100D2321C(uint64_t result)
{
  *(unsigned char *)(result + 40) = 0;
  return result;
}

uint64_t sub_100D23224(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D23240(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D23250(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 1174405120;
        void v16[2] = sub_100D23414;
        void v16[3] = &unk_101A520A0;
        memset(&v16[6], 0, 17);
        v16[4] = v5;
        int v8 = *a2;
        if (v8 == 2)
        {
          LOBYTE(v16[6]) = 2;
          *(_WORD *)((char *)&v16[6] + 1) = *(_WORD *)(a2 + 1);
          BYTE3(v16[6]) = a2[3];
        }
        else if (v8 == 1)
        {
          LOBYTE(v16[6]) = 1;
          *(_OWORD *)((char *)&v16[6] + 1) = *(_OWORD *)(a2 + 1);
        }
        v16[5] = a1[7];
        uint64_t v9 = (std::__shared_weak_count *)v5[2];
        if (!v9 || (v10 = v5[1], (BOOL v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        unint64_t v12 = v11;
        int v13 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v10;
        unsigned int v15 = v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v16;
        dispatch_async(v13, block);
        if (v15) {
          sub_10004D2C8(v15);
        }
        sub_10004D2C8(v12);
        LOBYTE(v16[6]) = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D23408(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100D23414(uint64_t a1)
{
  uint64_t v3 = (unsigned __int8 *)(a1 + 48);
  int v2 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v2 != 2)
  {
    if (v2 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    uint64_t v5 = *(void **)(v4 + 160);
    if (v5 && (v5[1] == *(void *)(a1 + 49) ? (BOOL v6 = v5[2] == *(void *)(a1 + 57)) : (BOOL v6 = 0), v6))
    {
      if (v5[7] != v5[8])
      {
        uint64_t v18 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          sCardSerialNumberAsString();
          uint64_t v19 = v22 >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)long long buf = 136315138;
          uint64_t v24 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Eid did not change: %s", buf, 0xCu);
          if (v22 < 0) {
            operator delete(*(void **)__p);
          }
        }
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 49);
      uint64_t v8 = *(void *)(a1 + 57);
      sub_100D23B14(*(void **)(a1 + 32));
      uint64_t v9 = (char *)operator new(0x118uLL);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)uint64_t v9 = off_101A52B28;
      int v10 = *(_DWORD *)(v4 + 80);
      *((_DWORD *)v9 + 6) = 2;
      *((_DWORD *)v9 + 7) = v10;
      *((void *)v9 + 4) = v7;
      *((void *)v9 + 5) = v8;
      v9[48] = 0;
      v9[112] = 0;
      v9[136] = 0;
      v9[144] = 0;
      v9[168] = 0;
      *((void *)v9 + 34) = 0;
      *((void *)v9 + 11) = 0;
      *((void *)v9 + 12) = 0;
      *((void *)v9 + 10) = 0;
      *((_DWORD *)v9 + 26) = 0;
      *((_DWORD *)v9 + 44) = 0;
      *((_WORD *)v9 + 90) = 0;
      *(_OWORD *)(v9 + 184) = 0u;
      *(_OWORD *)(v9 + 200) = 0u;
      v9[216] = 0;
      BOOL v11 = *(std::__shared_weak_count **)(v4 + 168);
      *(void *)(v4 + 160) = v9 + 24;
      *(void *)(v4 + 168) = v9;
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
    sub_100D23794(v4);
LABEL_11:
    if (*(unsigned char *)(a1 + 44))
    {
      uint64_t v12 = *(void *)(v4 + 160);
      if (v12) {
        *(_DWORD *)(v12 + 80) = *(_DWORD *)(a1 + 40);
      }
    }
    if (*(_DWORD *)(v4 + 156) == 9) {
      sub_100D22F74(v4, 5u);
    }
    else {
      sub_100D22F74(v4, 3u);
    }
    return;
  }
  int v13 = *(unsigned __int8 *)(a1 + 49);
  if (v13 == 3 || v13 == 9)
  {
    unsigned int v15 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I EID temporarily failed; will try again later (availability left at %s)",
        __p,
        0xCu);
    }
  }
  else if (v13 == 6)
  {
    uint64_t v16 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Sim not supported; clearing CSN", __p, 2u);
    }
    sub_100D22F74(v4, 2u);
  }
  else
  {
    uint64_t v17 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      sub_100D2316C(v3);
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "EID retrieval failed with error %s; disabling Vinyl",
        __p,
        0xCu);
    }
    sub_100D22F74(v4, 2u);
  }
}

void sub_100D23778(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D23794(uint64_t a1)
{
  if (((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) != 0)
  {
    if (*(_DWORD *)(a1 + 84) == 1)
    {
      int v2 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v2 || (v3 = *(void *)(a1 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v5 = v4;
      p_shared_weak_owners = &v4->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
      uint64_t v7 = *(void *)(a1 + 160);
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 168);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = _NSConcreteStackBlock;
      uint64_t v19 = 1174405120;
      uint64_t v20 = sub_100D23E74;
      char v21 = &unk_101A52130;
      uint64_t v22 = a1;
      uint64_t v23 = v3;
      uint64_t v24 = v5;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      uint64_t v25 = v7;
      uint64_t v26 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::getCardInfo();
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      std::__shared_weak_count::__release_weak(v24);
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
      std::__shared_weak_count::__release_weak(v5);
    }
    else
    {
      int v10 = operator new(3uLL);
      *(_WORD *)int v10 = 8383;
      _OWORD v10[2] = 0;
      BOOL v11 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v11 || (uint64_t v12 = std::__shared_weak_count::lock(v11)) == 0) {
        sub_100088B9C();
      }
      int v13 = v12;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      uint64_t v14 = *(std::__shared_weak_count **)(a1 + 168);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      std::string __p = 0;
      sub_10005C928(&__p, v10, (uint64_t)(v10 + 3), 3uLL);
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::getTapeEuiccInfo();
      if (__p)
      {
        uint64_t v16 = __p;
        operator delete(__p);
      }
      if (v14) {
        std::__shared_weak_count::__release_weak(v14);
      }
      std::__shared_weak_count::__release_weak(v13);
      if (v14) {
        std::__shared_weak_count::__release_weak(v14);
      }
      std::__shared_weak_count::__release_weak(v13);
      operator delete(v10);
    }
  }
  else
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Skipping update card info - invalid state", buf, 2u);
    }
  }
}

void sub_100D23A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v32) {
    std::__shared_weak_count::__release_weak(v32);
  }
  std::__shared_weak_count::__release_weak(v31);
  operator delete(v30);
  _Unwind_Resume(a1);
}

unsigned char *sub_100D23AFC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  int v2 = (unsigned char *)(a1 + 48);
  v2[16] = 0;
  return sub_100D38F74(v2, (unsigned __int8 *)(a2 + 48));
}

uint64_t sub_100D23B0C(uint64_t result)
{
  *(unsigned char *)(result + 48) = 0;
  return result;
}

void sub_100D23B14(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[18];
  a1[17] = 0;
  a1[18] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[20];
  if (v3)
  {
    uint64_t v4 = (std::__shared_weak_count *)a1[21];
    a1[20] = 0;
    a1[21] = 0;
    sub_100D23C00(a1);
    uint64_t v5 = *(void *)(v3 + 176);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    uint64_t v6 = *(void *)(v3 + 160);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    }
    if (v4)
    {
      sub_10004D2C8(v4);
    }
  }
}

void sub_100D23BE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D23C00(void *a1)
{
  uint64_t v2 = a1[20];
  if (!v2 || !*(unsigned char *)(v2 + 155) && !*(unsigned char *)(v2 + 156))
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[16];
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = a1[15];
        if (v6)
        {
          sub_100D27DF8((uint64_t)a1, (uint64_t)v8);
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v6 + 16))(v6, v8);
          if (v11[24])
          {
            uint64_t v7 = (void **)v11;
            sub_1000C57C8(&v7);
          }
          if (v10 < 0) {
            operator delete(__p);
          }
        }
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_100D23CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10015A318((uint64_t)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_100D23D20(uint64_t a1, int *a2)
{
  if (*(void *)(a1 + 160))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Model already exists, already received baseband vinyl info", v13, 2u);
    }
  }
  else
  {
    unsigned int v5 = a2[3];
    BOOL v6 = v5 > 6;
    int v7 = (1 << v5) & 0x57;
    if (v6 || v7 == 0)
    {
      uint64_t v9 = (char *)operator new(0x118uLL);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)uint64_t v9 = off_101A52B28;
      int v10 = *a2;
      *((_DWORD *)v9 + 7) = *(_DWORD *)(a1 + 80);
      *((_OWORD *)v9 + 2) = *((_OWORD *)a2 + 1);
      v9[48] = 0;
      v9[112] = 0;
      v9[136] = 0;
      v9[144] = 0;
      v9[168] = 0;
      *((void *)v9 + 34) = 0;
      *((void *)v9 + 11) = 0;
      *((void *)v9 + 12) = 0;
      *((void *)v9 + 10) = 0;
      *((_DWORD *)v9 + 26) = 0;
      *((_WORD *)v9 + 90) = 0;
      *((_DWORD *)v9 + 44) = 0;
      *(_OWORD *)(v9 + 184) = 0u;
      *(_OWORD *)(v9 + 200) = 0u;
      v9[216] = 0;
      BOOL v11 = *(std::__shared_weak_count **)(a1 + 168);
      *(void *)(a1 + 168) = v9;
      *((_DWORD *)v9 + 6) = v10;
      uint64_t v12 = v9 + 24;
      *(void *)(a1 + 160) = v12;
      if (v11)
      {
        sub_10004D2C8(v11);
        uint64_t v12 = *(char **)(a1 + 160);
      }
      sub_10032AFC0(v12 + 24, (const std::string *)(a2 + 8));
      sub_1000C86CC(*(void *)(a1 + 160) + 88, (uint64_t)(a2 + 14));
      *(_DWORD *)(a1 + 152) = 6;
    }
  }
}

void sub_100D23E74(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    unsigned int v5 = (void *)a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_100D24028;
        v15[3] = &unk_101A52100;
        uint64_t v9 = a1[7];
        uint64_t v8 = (std::__shared_weak_count *)a1[8];
        void v15[4] = v5;
        v15[5] = v9;
        uint64_t v16 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1007A816C((uint64_t)v17, a2);
        int v10 = (std::__shared_weak_count *)v5[2];
        if (!v10 || (uint64_t v11 = v5[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        uint64_t v14 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v11;
        char v21 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v13);
        if (v17[0] == 1 && __p)
        {
          uint64_t v19 = __p;
          operator delete(__p);
        }
        v17[0] = 0;
        if (v16) {
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D24004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D24028(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        if (v5 == *(void *)(v2 + 160))
        {
          BOOL v6 = (unsigned __int8 *)(a1 + 56);
          int v7 = *(unsigned __int8 *)(a1 + 56);
          if (v7 == 1)
          {
            uint64_t v8 = (void *)(a1 + 64);
            uint64_t v9 = *(void *)(v2 + 344);
            if (v9)
            {
              sub_100EE8BC8(v9, "Info");
              int v10 = *v6;
              __n128 buf = 0uLL;
              unint64_t v31 = 0;
              if (v10 != 1)
              {
                if (v10 == 2)
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v12 = &ctu::ResultIsError::~ResultIsError;
                  ctu::ResultIsError::ResultIsError(exception);
                }
                else
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v12 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                  ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                }
                __cxa_throw(exception, v13, (void (*)(void *))v12);
              }
            }
            else
            {
              *(void *)(v2 + 344) = 0;
              __n128 buf = 0uLL;
              unint64_t v31 = 0;
            }
            sub_1003EF00C(v8, (uint64_t)&buf);
            int v19 = SHIBYTE(v31);
            if (SHIBYTE(v31) >= 0) {
              unint64_t v20 = HIBYTE(v31);
            }
            else {
              unint64_t v20 = buf.n128_u64[1];
            }
            char v21 = *(NSObject **)(v2 + 40);
            BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
            if (v20)
            {
              if (v22)
              {
                p___n128 buf = (__n128 *)buf.n128_u64[0];
                if (v19 >= 0) {
                  p___n128 buf = &buf;
                }
                int v28 = 136315138;
                uint64_t v29 = p_buf;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Vinyl version: %s", (uint8_t *)&v28, 0xCu);
              }
              sub_1003DF348(*(void *)(v2 + 160) + 24, &buf);
            }
            else
            {
              if (v22)
              {
                LOWORD(v28) = 0;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Vinyl version: not detected", (uint8_t *)&v28, 2u);
              }
              uint64_t v24 = *(void *)(v2 + 160);
              if (*(unsigned char *)(v24 + 24))
              {
                if (*(char *)(v24 + 55) < 0) {
                  operator delete(*(void **)(v24 + 32));
                }
                *(unsigned char *)(v24 + 24) = 0;
              }
            }
            if (SHIBYTE(v31) < 0) {
              operator delete((void *)buf.n128_u64[0]);
            }
          }
          else
          {
            unsigned int v15 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              sub_1007998A4((unsigned __int8 *)(a1 + 56));
              buf.n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf.n128_u64 + 4) = asString();
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Vinyl info failed: %s", (uint8_t *)&buf, 0xCu);
              int v7 = *v6;
            }
            if (v7 != 2)
            {
              uint64_t v25 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
              if (v7 == 1)
              {
                uint64_t v26 = &ctu::ResultIsNotError::~ResultIsNotError;
                ctu::ResultIsNotError::ResultIsNotError(v25);
              }
              else
              {
                uint64_t v26 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(v25);
              }
              __cxa_throw(v25, v27, (void (*)(void *))v26);
            }
            if (*(unsigned char *)(a1 + 64) == 2)
            {
              int v16 = *(_DWORD *)(v2 + 80);
              int v17 = *(unsigned __int8 *)(a1 + 65);
              int v18 = *(unsigned __int8 *)(a1 + 66);
              buf.n128_u64[0] = (unint64_t)_NSConcreteStackBlock;
              buf.n128_u64[1] = 0x40000000;
              unint64_t v31 = sub_1004F09E8;
              uint64_t v32 = &unk_1019DB198;
              int v33 = v16;
              int v34 = 3;
              int v35 = v17;
              int v36 = v18;
              sub_1004F0808((wis::MetricFactory *)0x800F1);
            }
          }
LABEL_14:
          sub_10004D2C8(v4);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v14 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    buf.n128_u16[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; dropping info result.",
      (uint8_t *)&buf,
      2u);
  }
  if (v4) {
    goto LABEL_14;
  }
}

void sub_100D243F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  __cxa_free_exception(v17);
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100D24444(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1007A816C(a1 + 56, (unsigned __int8 *)(a2 + 56));
}

void sub_100D24488(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D244A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56) == 1)
  {
    uint64_t v2 = *(void **)(a1 + 64);
    if (v2)
    {
      *(void *)(a1 + 72) = v2;
      operator delete(v2);
    }
  }
  *(unsigned char *)(a1 + 56) = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_100D24504(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D24538(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D24588(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_100D2473C;
        v15[3] = &unk_101A52160;
        uint64_t v9 = a1[7];
        uint64_t v8 = (std::__shared_weak_count *)a1[8];
        void v15[4] = v5;
        v15[5] = v9;
        int v16 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1007A816C((uint64_t)v17, a2);
        int v10 = (std::__shared_weak_count *)v5[2];
        if (!v10 || (uint64_t v11 = v5[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        int v13 = v12;
        uint64_t v14 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v11;
        char v21 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v13);
        if (v17[0] == 1 && __p)
        {
          int v19 = __p;
          operator delete(__p);
        }
        v17[0] = 0;
        if (v16) {
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D24718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D2473C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        if (v5 == *(void *)(v2 + 160))
        {
          BOOL v6 = (unsigned __int8 *)(a1 + 56);
          int v7 = *(unsigned __int8 *)(a1 + 56);
          if (v7 == 1)
          {
            __n128 buf = 0uLL;
            unint64_t v30 = 0;
            uint64_t v8 = (uint64_t *)(a1 + 64);
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v28 = 0;
            uint64_t v9 = *(void *)(v2 + 344);
            if (v9)
            {
              sub_100EE8BC8(v9, "ES10Info1");
              int v10 = *v6;
              if (v10 != 1)
              {
                if (v10 == 2)
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v12 = &ctu::ResultIsError::~ResultIsError;
                  ctu::ResultIsError::ResultIsError(exception);
                }
                else
                {
                  exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v12 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                  ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
                }
                __cxa_throw(exception, v13, (void (*)(void *))v12);
              }
            }
            else
            {
              *(void *)(v2 + 344) = 0;
            }
            if (sub_10074D7E0(v8, (uint64_t)&buf, (unint64_t *)__p))
            {
              int v19 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t v26 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not decode card version", v26, 2u);
              }
              uint64_t v20 = *(void *)(v2 + 160);
              if (*(unsigned char *)(v20 + 24))
              {
                if (*(char *)(v20 + 55) < 0) {
                  operator delete(*(void **)(v20 + 32));
                }
                *(unsigned char *)(v20 + 24) = 0;
              }
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
            }
            else
            {
              sub_1003DF348(*(void *)(v2 + 160) + 24, &buf);
              char v21 = *(void **)(v2 + 160);
              BOOL v22 = (void *)v21[7];
              if (v22)
              {
                v21[8] = v22;
                operator delete(v22);
                v21[7] = 0;
                v21[8] = 0;
                v21[9] = 0;
              }
              *(_OWORD *)(v21 + 7) = *(_OWORD *)__p;
              v21[9] = v28;
            }
            if (SHIBYTE(v30) < 0) {
              operator delete((void *)buf.n128_u64[0]);
            }
          }
          else
          {
            unsigned int v15 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              sub_1007998A4((unsigned __int8 *)(a1 + 56));
              buf.n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf.n128_u64 + 4) = asString();
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Tape info failed: %s", (uint8_t *)&buf, 0xCu);
              int v7 = *v6;
            }
            if (v7 != 2)
            {
              uint64_t v23 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
              if (v7 == 1)
              {
                uint64_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
                ctu::ResultIsNotError::ResultIsNotError(v23);
              }
              else
              {
                uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
              }
              __cxa_throw(v23, v25, (void (*)(void *))v24);
            }
            if (*(unsigned char *)(a1 + 64) == 2)
            {
              int v16 = *(_DWORD *)(v2 + 80);
              int v17 = *(unsigned __int8 *)(a1 + 65);
              int v18 = *(unsigned __int8 *)(a1 + 66);
              buf.n128_u64[0] = (unint64_t)_NSConcreteStackBlock;
              buf.n128_u64[1] = 0x40000000;
              unint64_t v30 = sub_1004F09E8;
              unint64_t v31 = &unk_1019DB198;
              int v32 = v16;
              int v33 = 4;
              int v34 = v17;
              int v35 = v18;
              sub_1004F0808((wis::MetricFactory *)0x800F1);
            }
          }
LABEL_14:
          sub_10004D2C8(v4);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v14 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    buf.n128_u16[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Tape model expired; dropping info result.",
      (uint8_t *)&buf,
      2u);
  }
  if (v4) {
    goto LABEL_14;
  }
}

void sub_100D24AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  __cxa_free_exception(v21);
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100D24B5C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    int v26 = 136315394;
    uint64_t v27 = subscriber::asString();
    __int16 v28 = 2080;
    uint64_t v29 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handling SIM state %s vinyl type %s", (uint8_t *)&v26, 0x16u);
  }
  int v6 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 156) = v6;
  switch(*(_DWORD *)(a2 + 64))
  {
    case 0:
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v26) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I VinylCapability is unknown. Do nothing.", (uint8_t *)&v26, 2u);
      }
      return;
    case 1:
      uint64_t v9 = (capabilities::ct *)capabilities::ct::supportsGemini((capabilities::ct *)v5);
      if ((v9 & 1) != 0 || capabilities::ct::supportsDynamicSID(v9))
      {
        BOOL v10 = *(_DWORD *)(a1 + 84) != 0;
        *(_DWORD *)(a1 + 84) = 0;
        *(unsigned char *)(a1 + 336) = 1;
      }
      else
      {
        BOOL v10 = 0;
      }
      if (*(void *)(a1 + 176) && subscriber::isSimSettled())
      {
        int v13 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v26) = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I dropping delete operation as sim is not capable", (uint8_t *)&v26, 2u);
        }
        uint64_t v14 = **(void **)(a1 + 176);
        LOWORD(v26) = 514;
        (*(void (**)(uint64_t))(v14 + 16))(v14);
        unsigned int v15 = *(std::__shared_weak_count **)(a1 + 184);
        *(void *)(a1 + 176) = 0;
        *(void *)(a1 + 184) = 0;
        if (v15) {
          sub_10004D2C8(v15);
        }
      }
      if (!v10) {
        goto LABEL_27;
      }
      goto LABEL_24;
    case 2:
      if (*(_DWORD *)(a1 + 84) == 1) {
        goto LABEL_27;
      }
      int v7 = 1;
      break;
    case 3:
    case 4:
      if (*(_DWORD *)(a1 + 84) == 2) {
        goto LABEL_27;
      }
      int v7 = 2;
      break;
    case 5:
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      {
        uint64_t v12 = subscriber::asString();
        int v26 = 136315138;
        uint64_t v27 = v12;
        _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Invalid vinyl capability %s", (uint8_t *)&v26, 0xCu);
      }
      return;
    default:
      goto LABEL_28;
  }
  *(_DWORD *)(a1 + 84) = v7;
LABEL_24:
  int v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = asString();
    int v26 = 136315138;
    uint64_t v27 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I changed card type to %s", (uint8_t *)&v26, 0xCu);
  }
  (*(void (**)(void, void, void))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), *(unsigned int *)(a1 + 80), *(unsigned int *)(a1 + 84));
LABEL_27:
  int v6 = *(_DWORD *)(a1 + 156);
LABEL_28:
  switch(v6)
  {
    case 1:
    case 7:
      unsigned int v18 = *(_DWORD *)(a2 + 64);
      BOOL v19 = v18 >= 3;
      unsigned int v20 = v18 - 3;
      if (v19)
      {
        if (v20 <= 2) {
          *(unsigned char *)(a1 + 336) = 1;
        }
      }
      else
      {
        *(unsigned char *)(a1 + 336) = 0;
        sub_100D22F74(a1, 1u);
        sub_100D24FA0(a1);
      }
      break;
    case 2:
    case 8:
      if (*(_DWORD *)(a1 + 84))
      {
        unsigned int v21 = *(unsigned __int16 *)(a2 + 68);
        uint64_t v22 = 0x100000001;
        uint64_t v23 = 0x100000002;
        if ((v21 & 2) != 0) {
          uint64_t v23 = 0x100000003;
        }
        if ((v21 & 0x40) != 0) {
          uint64_t v22 = v23;
        }
        if (v21 >= 0x100) {
          uint64_t v24 = (const mach_header_64 *)v22;
        }
        else {
          uint64_t v24 = &_mh_execute_header;
        }
        sub_100D252D4(a1, (uint64_t)v24);
      }
      else
      {
        sub_100D22F74(a1, 2u);
        sub_100D24FA0(a1);
      }
      break;
    case 3:
    case 4:
    case 5:
    case 6:
      if (!*(_DWORD *)(a1 + 84)) {
        sub_100D22F74(a1, 2u);
      }
      sub_100D25F88(a1, 0);
      break;
    case 9:
      if (*(_DWORD *)(a1 + 84)) {
        unsigned int v25 = 5;
      }
      else {
        unsigned int v25 = 2;
      }
      sub_100D22F74(a1, v25);
      sub_100D25F88(a1, 0);
      break;
    default:
      return;
  }
}

BOOL sub_100D24FA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 392);
  if (!v1) {
    return v1 != 0;
  }
  uint64_t v3 = *(void *)(a1 + 400);
  if (!v3) {
    return v1 != 0;
  }
  *(void *)(a1 + 400) = 0;
  (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  uint64_t v11 = sub_100D255BC;
  uint64_t v12 = &unk_101A521C0;
  uint64_t v13 = a1;
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__n128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Get firmware update data internal", buf, 2u);
  }
  if (!*(_DWORD *)(a1 + 84))
  {
    BOOL v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__n128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Invalid card type", buf, 2u);
    }
    goto LABEL_16;
  }
  if (((subscriber::isSimDead() & 1) != 0 || (subscriber::isSimInserted() & 1) == 0) && *(_DWORD *)(a1 + 84) != 2)
  {
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__n128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I No SIM", buf, 2u);
    }
LABEL_16:
    int v16 = 0;
    buf[0] = 0;
    sub_1000C7FE8((const void **)buf, &v16);
    v11((uint64_t)v10, (const void **)buf);
    if (buf[0] == 1) {
      sub_100057D78(v15);
    }
    buf[0] = 0;
    int v7 = &v16;
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 336))
  {
    *(void *)__n128 buf = _NSConcreteStackBlock;
    v15[0] = (const void *)0x40000000;
    v15[1] = sub_100D37928;
    v15[2] = &unk_101A52A18;
    v15[3] = v10;
    void v15[4] = (const void *)a1;
    VinylCommandDriver::getFirmwareUpdateData();
    return v1 != 0;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__n128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I driver not ready", buf, 2u);
  }
  buf[0] = 2;
  LOBYTE(v15[0]) = 19;
  v11((uint64_t)v10, (const void **)buf);
  if (buf[0] == 1)
  {
    int v7 = v15;
LABEL_19:
    sub_100057D78(v7);
  }
  return v1 != 0;
}

void sub_100D25288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a15 == 1) {
    sub_100057D78(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D252D4(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::requireVinylManagerInd((capabilities::ct *)a1))
  {
    if (!*(unsigned char *)(a1 + 336)) {
      return;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 336) = 1;
  }
  if (subscriber::isSimInserted())
  {
    int v4 = *(_DWORD *)(a1 + 84);
    if (v4 == 2)
    {
      if (subscriber::isSimDead()) {
        return;
      }
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Updating EID", (uint8_t *)&v17, 2u);
      }
      uint64_t v12 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v12 || (v13 = *(void *)(a1 + 8), (uint64_t v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v9 = v14;
      p_shared_weak_owners = &v14->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      *(void *)&long long v17 = _NSConcreteStackBlock;
      *((void *)&v17 + 1) = 1174405120;
      unsigned int v18 = sub_100D23250;
      BOOL v19 = &unk_101A520D0;
      uint64_t v20 = a1;
      uint64_t v21 = v13;
      uint64_t v22 = v9;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      uint64_t v23 = a2;
      VinylCommandDriver::getTapeEid();
      goto LABEL_19;
    }
    if (v4 == 1)
    {
      BOOL v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating Vinyl", (uint8_t *)&v17, 2u);
      }
      int v6 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v6 || (uint64_t v7 = *(void *)(a1 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v9 = v8;
      BOOL v10 = &v8->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      *(void *)&long long v17 = _NSConcreteStackBlock;
      *((void *)&v17 + 1) = 1174405120;
      unsigned int v18 = sub_100D22A88;
      BOOL v19 = &unk_101A52070;
      uint64_t v20 = a1;
      uint64_t v21 = v7;
      uint64_t v22 = v9;
      atomic_fetch_add_explicit(v10, 1uLL, memory_order_relaxed);
      VinylCommandDriver::queryCsn();
LABEL_19:
      if (v22) {
        std::__shared_weak_count::__release_weak(v22);
      }
      std::__shared_weak_count::__release_weak(v9);
      return;
    }
    int v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v17) = 136315138;
      *(void *)((char *)&v17 + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Card type invalid (%s)", (uint8_t *)&v17, 0xCu);
    }
  }
}

void sub_100D25590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v15);
  _Unwind_Resume(a1);
}

void sub_100D255BC(uint64_t a1, const void **a2)
{
  for (uint64_t i = *(void **)(a1 + 32); i[49]; sub_100D3935C((uint64_t)(i + 44)))
  {
    uint64_t v4 = *(void *)(*(void *)(i[45] + ((i[48] >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (i[48] & 0x1FFLL));
    BOOL v5 = 0;
    int v6 = 0;
    sub_1000C6188(&v5, a2);
    (*(void (**)(uint64_t, const void **))(v4 + 16))(v4, &v5);
    if (v5 == 1) {
      sub_100057D78(&v6);
    }
  }
}

void sub_100D25670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9)
{
  if (a9 == 1) {
    sub_100057D78(v9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D25690(void *a1)
{
  uint64_t v1 = a1[20];
  if (v1 && !*(unsigned char *)(v1 + 154))
  {
    *(unsigned char *)(v1 + 154) = 1;
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
      sub_100088B9C();
    }
    int v6 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
    uint64_t v8 = (int *)a1[20];
    uint64_t v7 = (std::__shared_weak_count *)a1[21];
    uint64_t v9 = v8;
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v9 = (int *)a1[20];
    }
    int v10 = *v9;
    uint64_t v11 = a1[5];
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v10 == 1)
    {
      if (v12)
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I fetching profile list", buf, 2u);
      }
      uint64_t v20 = _NSConcreteStackBlock;
      uint64_t v21 = 1174405120;
      uint64_t v22 = sub_100D27F30;
      uint64_t v23 = &unk_101A52230;
      uint64_t v24 = a1;
      uint64_t v25 = v4;
      int v26 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v27 = v8;
      __int16 v28 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::fetchProfiles();
      if (v28) {
        std::__shared_weak_count::__release_weak(v28);
      }
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    else
    {
      if (v12)
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I fetching tape profile info list", buf, 2u);
      }
      *(void *)__n128 buf = 0;
      unsigned int v18 = 0;
      uint64_t v19 = 0;
      int v13 = capabilities::ct::supportsHydra((capabilities::ct *)v12);
      sub_10074B368(buf, v13);
      unsigned int v15 = 0;
      uint64_t v16 = 0;
      std::string __p = 0;
      sub_10005C928(&__p, *(const void **)buf, (uint64_t)v18, (size_t)v18 - *(void *)buf);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::tapeListProfilesInfo();
      if (__p)
      {
        unsigned int v15 = __p;
        operator delete(__p);
      }
      if (v7) {
        std::__shared_weak_count::__release_weak(v7);
      }
      std::__shared_weak_count::__release_weak(v6);
      if (*(void *)buf)
      {
        unsigned int v18 = *(const void **)buf;
        operator delete(*(void **)buf);
      }
    }
    if (v7) {
      std::__shared_weak_count::__release_weak(v7);
    }
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_100D25940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  std::__shared_weak_count::__release_weak(v32);
  _Unwind_Resume(a1);
}

void sub_100D259C0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  if (v1 && *(unsigned char *)(a1 + 336) && ((*(_DWORD *)(a1 + 152) - 3) & 0xFFFFFFFD) == 0 && *(_DWORD *)(a1 + 84) != 1)
  {
    uint64_t v3 = *(void *)(v1 + 176);
    if (v3)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 56))(v3))
      {
        uint64_t v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__n128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Receipts operation complete; resetting to start a new one",
            buf,
            2u);
        }
        uint64_t v5 = *(void *)(a1 + 160);
        int v6 = *(std::__shared_weak_count **)(v5 + 184);
        *(void *)(v5 + 176) = 0;
        *(void *)(v5 + 184) = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      else if (*(void *)(*(void *)(a1 + 160) + 176))
      {
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__n128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Receipts operation already in progress", buf, 2u);
        }
        sub_100D25F88(a1, 0);
      }
    }
    if (!*(void *)(*(void *)(a1 + 160) + 176))
    {
      uint64_t v8 = *(void *)(a1 + 64);
      uint64_t v9 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v9;
      if (v9) {
        dispatch_retain(v9);
      }
      uint64_t v10 = *(unsigned int *)(a1 + 80);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000;
      v17[2] = sub_100D27EC0;
      v17[3] = &unk_101A521E0;
      v17[4] = a1;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, dispatch_object_t *, uint64_t, void *))(*(void *)v8 + 104))(buf, v8, &object, v10, v17);
      uint64_t v11 = *(void *)(a1 + 160);
      long long v12 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      int v13 = *(std::__shared_weak_count **)(v11 + 184);
      *(_OWORD *)(v11 + 176) = v12;
      if (v13)
      {
        sub_10004D2C8(v13);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      uint64_t v14 = (capabilities::ct *)object;
      if (object) {
        dispatch_release(object);
      }
      uint64_t v15 = *(void *)(*(void *)(a1 + 160) + 176);
      int v16 = capabilities::ct::supportedLPASVN(v14);
      sub_10132A380(v15, v16);
      sub_100D25F88(a1, 0);
    }
  }
}

void sub_100D25BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D25BFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  BOOL result = 0;
  if (v1)
  {
    if (*(_DWORD *)(a1 + 84) != 2)
    {
      uint64_t v3 = *(void *)(v1 + 160);
      if (v3)
      {
        if (((*(uint64_t (**)(uint64_t))(*(void *)v3 + 56))(v3) & 1) == 0
          && !(*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 160) + 160) + 64))(*(void *)(*(void *)(a1 + 160) + 160)))
        {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100D25C9C(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 155))
    {
      BOOL result = *(void *)(result + 160);
      if (result) {
        return (*(unsigned int (**)(uint64_t))(*(void *)result + 56))(result) ^ 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100D25CF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  if (!v1) {
    return 1;
  }
  if (*(unsigned char *)(v1 + 152))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v4)
    {
      __int16 v21 = 0;
      int v6 = "#I profile change still in flight; must wait.";
      uint64_t v7 = (uint8_t *)&v21;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
      return 0;
    }
    return result;
  }
  if (!*(unsigned char *)(v1 + 153))
  {
    if (*(unsigned char *)(v1 + 157))
    {
      uint64_t v3 = *(NSObject **)(a1 + 40);
      BOOL v9 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v9)
      {
        *(_WORD *)__n128 buf = 0;
        int v6 = "#I profile delete in progress; must wait for a profile deletion";
        uint64_t v7 = buf;
        goto LABEL_11;
      }
      return result;
    }
    if (*(_DWORD *)(a1 + 84) == 2 && *(void *)(a1 + 232))
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v18 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I allow signed payload", v18, 2u);
      }
    }
    else
    {
      uint64_t v11 = *(void *)(v1 + 176);
      if (v11)
      {
        char v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 56))(v11);
        uint64_t v1 = *(void *)(a1 + 160);
        if ((v12 & 1) == 0)
        {
          if (!(*(unsigned int (**)(void))(**(void **)(v1 + 176) + 64))(*(void *)(v1 + 176)))
          {
            uint64_t v3 = *(NSObject **)(a1 + 40);
            BOOL v14 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
            uint64_t result = 0;
            if (v14)
            {
              __int16 v17 = 0;
              int v6 = "#I receipts operation is already active; must wait.";
              uint64_t v7 = (uint8_t *)&v17;
              goto LABEL_11;
            }
            return result;
          }
          uint64_t v1 = *(void *)(a1 + 160);
        }
      }
      uint64_t v13 = *(void *)(v1 + 160);
      if (v13
        && ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 56))(v13) & 1) == 0
        && ((*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 160) + 160) + 64))(*(void *)(*(void *)(a1 + 160) + 160)) & 1) == 0)
      {
        uint64_t v3 = *(NSObject **)(a1 + 40);
        BOOL v15 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (v15)
        {
          __int16 v16 = 0;
          int v6 = "#I install operation is already active; must wait";
          uint64_t v7 = (uint8_t *)&v16;
          goto LABEL_11;
        }
        return result;
      }
    }
    return 1;
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  BOOL v8 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v8)
  {
    __int16 v20 = 0;
    int v6 = "#I profile update required; must wait for a profiles update";
    uint64_t v7 = (uint8_t *)&v20;
    goto LABEL_11;
  }
  return result;
}

void sub_100D25F88(uint64_t a1, char a2)
{
  if (*(void *)(a1 + 160))
  {
    BOOL v4 = *(std::__shared_weak_count **)(a1 + 128);
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5) {
        uint64_t v6 = *(void *)(a1 + 120);
      }
      else {
        uint64_t v6 = 0;
      }
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v5 = 0;
    }
    if (subscriber::isSimDead() && *(_DWORD *)(a1 + 84) != 2)
    {
      __int16 v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I SIM is dead, nothing to do", buf, 2u);
      }
      unsigned int v18 = *(std::__shared_weak_count **)(a1 + 144);
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
      if (v18) {
        sub_10004D2C8(v18);
      }
      if (v6 && (a2 & 1) == 0) {
        (*(void (**)(uint64_t, void))(*(void *)v6 + 40))(v6, *(unsigned int *)(a1 + 80));
      }
      goto LABEL_54;
    }
    uint64_t v11 = *(void *)(a1 + 136);
    if (!v11)
    {
      BOOL v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I have pending operation, boot baseband", buf, 2u);
      }
      v51[0] = off_101A52B78;
      v51[1] = a1;
      v51[3] = v51;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void *))(*(void *)v6 + 32))(buf, v6, v51);
      long long v15 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      __int16 v16 = *(std::__shared_weak_count **)(a1 + 144);
      *(_OWORD *)(a1 + 136) = v15;
      if (v16)
      {
        sub_10004D2C8(v16);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      sub_10003B34C(v51);
      goto LABEL_54;
    }
    if ((!*(unsigned char *)(a1 + 336) || ((*(_DWORD *)(a1 + 152) - 3) & 0xFFFFFFFD) != 0) && !*(void *)(a1 + 392))
    {
      uint64_t v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(_DWORD *)__n128 buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      uint64_t v13 = "#I availability %s not ready yet";
LABEL_39:
      __int16 v20 = v19;
      uint32_t v21 = 12;
LABEL_53:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v13, buf, v21);
      goto LABEL_54;
    }
    if (*(unsigned char *)(*(void *)(a1 + 160) + 154))
    {
      char v12 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(_WORD *)__n128 buf = 0;
      uint64_t v13 = "#I fetch-profiles is pending, nothing to start";
      goto LABEL_52;
    }
    if (v6)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v6 + 24))(v6))
      {
        char v12 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_54;
        }
        *(_WORD *)__n128 buf = 0;
        uint64_t v13 = "#I Can Start Next Operation false, must wait";
        goto LABEL_52;
      }
      uint64_t v11 = *(void *)(a1 + 136);
    }
    uint64_t v22 = *(void *)(v11 + 32);
    if (!v22 || *(_DWORD *)(v22 + 68) != 2)
    {
      char v12 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(_WORD *)__n128 buf = 0;
      uint64_t v13 = "#I Required vinyl assertions not ready, must wait";
      goto LABEL_52;
    }
    if (subscriber::isSimInTransientState())
    {
      uint64_t v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(_DWORD *)__n128 buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      uint64_t v13 = "#I Cannot run any operations, due to sim state (%s)";
      goto LABEL_39;
    }
    if (sub_100D24FA0(a1))
    {
      char v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        uint64_t v13 = "#I Get firmware data callback";
LABEL_52:
        __int16 v20 = v12;
        uint32_t v21 = 2;
        goto LABEL_53;
      }
LABEL_54:
      if (v5) {
        sub_10004D2C8(v5);
      }
      return;
    }
    if (*(void *)(a1 + 232))
    {
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I signed payload required", buf, 2u);
      }
      sub_100D269DC(a1);
      goto LABEL_54;
    }
    if (*(void *)(a1 + 280))
    {
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I secure auth required", buf, 2u);
      }
      sub_100D26D20((void *)a1);
      goto LABEL_54;
    }
    if (*(void *)(a1 + 328))
    {
      uint64_t v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I set nickname required", buf, 2u);
      }
      sub_100D26EFC((void *)a1);
      goto LABEL_54;
    }
    if (sub_100D2716C(a1))
    {
      int v26 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I profile change required", buf, 2u);
      }
      sub_100D27444((void *)a1);
      goto LABEL_54;
    }
    uint64_t v27 = *(void *)(a1 + 160);
    if (v27 && *(unsigned char *)(v27 + 192))
    {
      if (!*(void *)(a1 + 176))
      {
        __int16 v28 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__n128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I profile delete required", buf, 2u);
        }
        sub_100D279B4((void *)a1);
        goto LABEL_54;
      }
      goto LABEL_83;
    }
    if (*(void *)(a1 + 176))
    {
LABEL_83:
      sub_100D278D0((void *)a1);
      goto LABEL_54;
    }
    if (((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) != 0)
    {
      if ((sub_100D25C9C(v27) & 1) == 0)
      {
        uint64_t v29 = *(void *)(*(void *)(a1 + 160) + 176);
        if (v29)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 64))(v29))
          {
            char v30 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 64))(v6);
            unint64_t v31 = *(NSObject **)(a1 + 40);
            BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
            if (v30)
            {
              if (v32)
              {
                *(_WORD *)__n128 buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I starting receipts operation", buf, 2u);
              }
              uint64_t v33 = *(void *)(*(void *)(a1 + 160) + 176);
              int v34 = *(std::__shared_weak_count **)(a1 + 96);
              uint64_t v48 = *(void *)(a1 + 88);
              uint64_t v49 = v34;
              if (v34) {
                atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_100D27DF8(a1, (uint64_t)buf);
              (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v33 + 16))(v33, &v48, buf);
              sub_10015A318((uint64_t)buf);
              int v35 = v49;
              if (!v49) {
                goto LABEL_54;
              }
              goto LABEL_118;
            }
            if (v32)
            {
              *(_WORD *)__n128 buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Cannot start receipt operation without Internet", buf, 2u);
            }
            uint64_t v39 = *(void *)(a1 + 160);
            uint64_t v40 = *(std::__shared_weak_count **)(v39 + 184);
            *(void *)(v39 + 176) = 0;
            *(void *)(v39 + 184) = 0;
            if (v40) {
              sub_10004D2C8(v40);
            }
          }
        }
      }
      uint64_t v41 = *(void *)(*(void *)(a1 + 160) + 160);
      if (v41 && (*(unsigned int (**)(uint64_t))(*(void *)v41 + 64))(v41))
      {
        uint64_t v42 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__n128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Start install operation", buf, 2u);
        }
        uint64_t v43 = *(void *)(*(void *)(a1 + 160) + 160);
        uint64_t v44 = *(std::__shared_weak_count **)(a1 + 96);
        uint64_t v46 = *(void *)(a1 + 88);
        unint64_t v47 = v44;
        if (v44) {
          atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100D27DF8(a1, (uint64_t)buf);
        (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v43 + 16))(v43, &v46, buf);
        sub_10015A318((uint64_t)buf);
        int v35 = v47;
        if (!v47) {
          goto LABEL_54;
        }
LABEL_118:
        sub_10004D2C8(v35);
        goto LABEL_54;
      }
      uint64_t v45 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__n128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I All operations appear to be complete; nothing to do",
          buf,
          2u);
      }
      if (v6 && (a2 & 1) == 0) {
        (*(void (**)(uint64_t, void))(*(void *)v6 + 40))(v6, *(unsigned int *)(a1 + 80));
      }
    }
    else
    {
      int v36 = *(std::__shared_weak_count **)(v27 + 184);
      *(void *)(v27 + 176) = 0;
      *(void *)(v27 + 184) = 0;
      if (v36) {
        sub_10004D2C8(v36);
      }
      uint64_t v37 = *(void *)(a1 + 160);
      CFAbsoluteTime v38 = *(std::__shared_weak_count **)(v37 + 168);
      *(void *)(v37 + 160) = 0;
      *(void *)(v37 + 168) = 0;
      if (v38) {
        sub_10004D2C8(v38);
      }
    }
    if (!*(void *)(a1 + 136)) {
      goto LABEL_54;
    }
    int v35 = *(std::__shared_weak_count **)(a1 + 144);
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
    if (!v35) {
      goto LABEL_54;
    }
    goto LABEL_118;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__n128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I no model, so nothing to do", buf, 2u);
  }
  BOOL v8 = *(std::__shared_weak_count **)(a1 + 144);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
  if ((subscriber::isSimInTransientState() & 1) == 0 && *(void *)(a1 + 392))
  {
    do
    {
      unint64_t v9 = *(void *)(a1 + 384);
      uint64_t v10 = *(void *)(*(void *)(a1 + 360) + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8));
      *(void *)__n128 buf = 0;
      sub_100D26958(*(void *)(v10 + 8 * (v9 & 0x1FF)), (const void **)buf);
      sub_100057D78((const void **)buf);
      sub_100D3935C(a1 + 352);
    }
    while (*(void *)(a1 + 392));
  }
}

void sub_100D268D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va, a5);
  sub_10015A318((uint64_t)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

const void **sub_100D26958(uint64_t a1, const void **a2)
{
  LOBYTE(v4) = 0;
  sub_1000C7FE8(&v4, a2);
  uint64_t result = (const void **)(*(uint64_t (**)(uint64_t, const void **))(a1 + 16))(a1, &v4);
  if (v4 == 1) {
    return sub_100057D78(&v5);
  }
  return result;
}

void sub_100D269B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, const void *a10)
{
  if (a9 == 1) {
    sub_100057D78(&a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D269DC(uint64_t a1)
{
  if (*(void *)(a1 + 232))
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 200) + ((*(void *)(a1 + 224) >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v3 = a1 + 192;
    long long v4 = *(_OWORD *)(v2 + 16 * *(void *)(a1 + 224));
    long long v10 = v4;
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 16 * *(void *)(a1 + 224) + 8);
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100D393E0(v3);
    if (*(_DWORD *)(a1 + 84) == 1)
    {
      uint64_t v6 = *(void *)(a1 + 344);
      uint64_t v7 = v10;
      if (v6)
      {
        sub_100EE8BC8(v6, "SignId");
        uint64_t v7 = v10;
      }
      else
      {
        *(void *)(a1 + 344) = 0;
      }
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v23 = 0;
      sub_10005C928(&v23, *(const void **)v7, *(void *)(v7 + 8), *(void *)(v7 + 8) - *(void *)v7);
      __int16 v17 = _NSConcreteStackBlock;
      uint64_t v18 = 1174405120;
      uint64_t v19 = sub_100D2E864;
      __int16 v20 = &unk_101A52550;
      uint64_t v21 = a1;
      long long v22 = v10;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::getSignIdMap();
      if (v23)
      {
        uint64_t v24 = v23;
        operator delete(v23);
      }
      if (*((void *)&v22 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v22 + 1));
      }
    }
    else
    {
      *(void *)__n128 buf = 0;
      long long v15 = 0;
      uint64_t v16 = 0;
      if (sub_100753E3C(*(void *)(a1 + 160) + 56, v10, (unint64_t *)buf))
      {
        uint64_t v9 = *(void *)(a1 + 344);
        if (v9) {
          sub_100EE8BC8(v9, "SignId");
        }
        else {
          *(void *)(a1 + 344) = 0;
        }
        char v12 = 0;
        uint64_t v13 = 0;
        std::string __p = 0;
        sub_10005C928(&__p, *(const void **)buf, (uint64_t)v15, (size_t)v15 - *(void *)buf);
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        VinylCommandDriver::signPayload();
        if (__p)
        {
          char v12 = __p;
          operator delete(__p);
        }
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
      }
      else
      {
        sub_100D2EA24(*(void *)(v10 + 24), 1);
      }
      if (*(void *)buf)
      {
        long long v15 = *(const void **)buf;
        operator delete(*(void **)buf);
      }
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    BOOL v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__n128 buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Attempt to generated signed payload but no operation exists", buf, 2u);
    }
  }
}

void sub_100D26CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D26D20(void *a1)
{
  if (a1[35])
  {
    uint64_t v2 = *(void *)(a1[31] + ((a1[34] >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v3 = (uint64_t)(a1 + 30);
    long long v4 = *(_OWORD *)(v2 + 16 * a1[34]);
    long long v8 = v4;
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 16 * a1[34] + 8);
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100D393E0(v3);
    uint64_t v6 = a1[43];
    if (v6) {
      sub_100EE8BC8(v6, "SecureAuthReq");
    }
    else {
      a1[43] = 0;
    }
    long long v10 = 0;
    uint64_t v11 = 0;
    std::string __p = 0;
    sub_10005C928(&__p, *(const void **)v8, *(void *)(v8 + 8), *(void *)(v8 + 8) - *(void *)v8);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    VinylCommandDriver::secureAuth();
    if (__p)
    {
      long long v10 = __p;
      operator delete(__p);
    }
    if (*((void *)&v8 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    uint64_t v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__n128 buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Attempt to generated signed payload but no operation exists", buf, 2u);
    }
  }
}

void sub_100D26EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D26EFC(void *a1)
{
  if (a1[41])
  {
    uint64_t v2 = *(void *)(a1[37] + ((a1[40] >> 5) & 0x7FFFFFFFFFFFFF8));
    uint64_t v3 = (uint64_t)(a1 + 36);
    long long v4 = *(_OWORD *)(v2 + 16 * a1[40]);
    long long v11 = v4;
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 16 * a1[40] + 8);
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100D393E0(v3);
    *(void *)__n128 buf = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    if (sub_100750C78(v11, (const void **)(v11 + 24), (unint64_t *)buf))
    {
      uint64_t v6 = (std::__shared_weak_count *)a1[2];
      if (!v6 || (uint64_t v7 = std::__shared_weak_count::lock(v6)) == 0) {
        sub_100088B9C();
      }
      long long v8 = v7;
      p_shared_weak_owners = &v7->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      std::string __p = 0;
      sub_10005C928(&__p, *(const void **)buf, (uint64_t)v16, (size_t)v16 - *(void *)buf);
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      VinylCommandDriver::tapeSetNickname();
      if (__p)
      {
        uint64_t v13 = __p;
        operator delete(__p);
      }
      if (*((void *)&v11 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
      }
      std::__shared_weak_count::__release_weak(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (*(void *)buf)
    {
      uint64_t v16 = *(const void **)buf;
      operator delete(*(void **)buf);
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    long long v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__n128 buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Attempt to set nickname but no operation exists", buf, 2u);
    }
  }
}

void sub_100D27100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v22);
  uint64_t v25 = *(void **)(v23 - 96);
  if (v25)
  {
    *(void *)(v23 - 88) = v25;
    operator delete(v25);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D2716C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  if (*(unsigned char *)(v1 + 144))
  {
    if (*(unsigned char *)(v1 + 112))
    {
      uint64_t v2 = *(void *)(v1 + 88);
      uint64_t v3 = *(void *)(v1 + 96);
      if (v2 != v3 && ((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) != 0)
      {
        unsigned int v5 = 0;
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        int v26 = &v27;
        do
        {
          if (*(unsigned char *)(v2 + 89)) {
            sub_100046BAC((uint64_t **)&v26, (void **)(v2 + 16), v2 + 16);
          }
          if (sub_10010E128(*(void *)(a1 + 160) + 120, (void **)(v2 + 16))) {
            ++v5;
          }
          v2 += 216;
        }
        while (v2 != v3);
        uint64_t v6 = *(void *)(a1 + 160);
        if (*(void *)(v6 + 136) > (unint64_t)v5)
        {
          uint64_t v7 = *(NSObject **)(a1 + 40);
          uint64_t v8 = 0;
          if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
LABEL_45:
            sub_10005CD2C((uint64_t)&v26, v27);
            return v8;
          }
          LOWORD(v24[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Missing user selected profile", (uint8_t *)v24, 2u);
LABEL_14:
          uint64_t v8 = 0;
          goto LABEL_45;
        }
        if (*(unsigned char *)(v6 + 155))
        {
          uint64_t v10 = *(void *)(v6 + 160);
          if (v10)
          {
            if (((*(uint64_t (**)(uint64_t))(*(void *)v10 + 56))(v10) & 1) == 0)
            {
              if (*(void *)(*(void *)(a1 + 160) + 136) != v28) {
                goto LABEL_14;
              }
              __int16 v20 = *(std::__shared_weak_count **)(a1 + 128);
              if (v20)
              {
                uint64_t v21 = std::__shared_weak_count::lock(v20);
                if (v21)
                {
                  long long v22 = v21;
                  uint64_t v23 = *(void *)(a1 + 120);
                  if (v23)
                  {
                    (*(void (**)(void **__return_ptr))(*(void *)v23 + 48))(v24);
                    if (v25 < 0)
                    {
                      uint64_t v8 = v24[1] != 0;
                      operator delete(v24[0]);
                    }
                    else
                    {
                      uint64_t v8 = v25 != 0;
                    }
                    sub_10004D2C8(v22);
                    goto LABEL_45;
                  }
                  sub_10004D2C8(v22);
                }
              }
            }
          }
        }
        uint64_t v11 = *(void *)(a1 + 160);
        if (v28 == *(void *)(v11 + 136))
        {
          char v12 = (uint64_t *)v26;
          if (v26 == &v27)
          {
            int v14 = 1;
          }
          else
          {
            uint64_t v13 = *(unsigned __int8 **)(v11 + 120);
            do
            {
              int v14 = sub_1000609C0((uint64_t)v24, (unsigned __int8 *)v12 + 32, v13 + 32);
              if (!v14) {
                break;
              }
              long long v15 = (uint64_t *)v12[1];
              uint64_t v16 = v12;
              if (v15)
              {
                do
                {
                  char v12 = v15;
                  long long v15 = (uint64_t *)*v15;
                }
                while (v15);
              }
              else
              {
                do
                {
                  char v12 = (uint64_t *)v16[2];
                  BOOL v17 = *v12 == (void)v16;
                  uint64_t v16 = v12;
                }
                while (!v17);
              }
              uint64_t v18 = (unsigned __int8 *)*((void *)v13 + 1);
              if (v18)
              {
                do
                {
                  uint64_t v19 = v18;
                  uint64_t v18 = *(unsigned __int8 **)v18;
                }
                while (v18);
              }
              else
              {
                do
                {
                  uint64_t v19 = (unsigned __int8 *)*((void *)v13 + 2);
                  BOOL v17 = *(void *)v19 == (void)v13;
                  uint64_t v13 = v19;
                }
                while (!v17);
              }
              uint64_t v13 = v19;
            }
            while (v12 != (uint64_t *)&v27);
          }
        }
        else
        {
          int v14 = 0;
        }
        uint64_t v8 = v14 ^ 1u;
        goto LABEL_45;
      }
    }
  }
  return 0;
}

void sub_100D27418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13)
{
  sub_10004D2C8(v13);
  sub_10005CD2C((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

void sub_100D27444(void *a1)
{
  uint64_t v1 = a1[20];
  if (*(unsigned char *)(v1 + 152)) {
    return;
  }
  *(_WORD *)(v1 + 152) = 257;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  BOOL v32 = &v33;
  if (!*(unsigned char *)(v1 + 112) || (v3 = *(void *)(v1 + 88), uint64_t v4 = *(void *)(v1 + 96), v3 == v4))
  {
    memset(&__p, 0, sizeof(__p));
  }
  else
  {
    do
    {
      if (*(unsigned char *)(v3 + 89)) {
        sub_100046BAC((uint64_t **)&v32, (void **)(v3 + 16), v3 + 16);
      }
      v3 += 216;
    }
    while (v3 != v4);
    uint64_t v1 = a1[20];
    memset(&__p, 0, sizeof(__p));
    if (!v1)
    {
LABEL_13:
      uint64_t v6 = (uint64_t *)v32;
      if (v32 != &v33)
      {
        while (sub_10010E128(a1[20] + 120, (void **)v6 + 4))
        {
          uint64_t v7 = (char *)v6[1];
          if (v7)
          {
            do
            {
              uint64_t v8 = (char **)v7;
              uint64_t v7 = *(char **)v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              uint64_t v8 = (char **)v6[2];
              BOOL v9 = *v8 == (char *)v6;
              uint64_t v6 = (uint64_t *)v8;
            }
            while (!v9);
          }
          uint64_t v6 = (uint64_t *)v8;
          if (v8 == &v33) {
            goto LABEL_23;
          }
        }
        std::string::operator=(&__p, (const std::string *)(v6 + 4));
      }
      goto LABEL_23;
    }
  }
  if (!*(unsigned char *)(v1 + 155)) {
    goto LABEL_13;
  }
  uint64_t v5 = *(void *)(v1 + 160);
  if (!v5 || ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5) & 1) != 0) {
    goto LABEL_13;
  }
  if (*(void *)(a1[20] + 136) == v34)
  {
    long long v22 = (std::__shared_weak_count *)a1[16];
    if (v22)
    {
      uint64_t v23 = std::__shared_weak_count::lock(v22);
      if (v23)
      {
        uint64_t v24 = v23;
        uint64_t v25 = a1[15];
        if (v25)
        {
          (*(void (**)(std::string *__return_ptr))(*(void *)v25 + 48))(&buf);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = buf;
        }
        sub_10004D2C8(v24);
      }
    }
LABEL_23:
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    int v11 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      char v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if (v11 >= 0) {
          p_p = &__p;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Disabling iccid: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v15 = a1[20];
      uint64_t v14 = a1[21];
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
      }
      CFAbsoluteTime v38 = 0;
      uint64_t v16 = operator new(0x20uLL);
      *uint64_t v16 = off_101A52BF8;
      v16[1] = a1;
      void v16[2] = v15;
      void v16[3] = v14;
      CFAbsoluteTime v38 = v16;
      sub_100D28F74((uint64_t)a1, (uint64_t)&__p, (uint64_t)v37);
      sub_1000C6B58(v37);
    }
    else
    {
      memset(&buf, 0, sizeof(buf));
      uint64_t v17 = a1[20];
      uint64_t v18 = *(void **)(v17 + 120);
      uint64_t v19 = (void *)(v17 + 128);
      if (v18 != (void *)(v17 + 128))
      {
        while (sub_10010E128((uint64_t)&v32, (void **)v18 + 4))
        {
          __int16 v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              uint64_t v21 = v20;
              __int16 v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              uint64_t v21 = (void *)v18[2];
              BOOL v9 = *v21 == (void)v18;
              uint64_t v18 = v21;
            }
            while (!v9);
          }
          uint64_t v18 = v21;
          if (v21 == v19) {
            goto LABEL_51;
          }
        }
        std::string::operator=(&buf, (const std::string *)(v18 + 4));
      }
LABEL_51:
      std::string::size_type v26 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      char v27 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v26 = buf.__r_.__value_.__l.__size_;
      }
      if (v26)
      {
        uint64_t v29 = a1[20];
        uint64_t v28 = a1[21];
        if (v28) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 16), 1uLL, memory_order_relaxed);
        }
        int v36 = 0;
        char v30 = operator new(0x20uLL);
        *char v30 = off_101A52C78;
        v30[1] = a1;
        v30[2] = v29;
        void v30[3] = v28;
        int v36 = v30;
        sub_100D2926C((uint64_t)a1, (uint64_t)&buf, (uint64_t)v35);
        sub_1000C6B58(v35);
        char v27 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      if (v27 < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10005CD2C((uint64_t)&v32, v33);
}

void sub_100D2782C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, char *a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  sub_10004D2C8(v22);
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005CD2C((uint64_t)&a15, a16);
  _Unwind_Resume(a1);
}

void sub_100D278D0(void *a1)
{
  if (a1[22])
  {
    uint64_t v2 = a1[20];
    if (v2)
    {
      if (!*(unsigned char *)(v2 + 157))
      {
        uint64_t v3 = a1[5];
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sending pending delete on model avilability", buf, 2u);
          uint64_t v2 = a1[20];
        }
        *(unsigned char *)(v2 + 157) = 1;
        sub_100D2CDFC((uint64_t)a1);
      }
    }
  }
}

void sub_100D279B4(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[20];
  uint64_t v3 = (std::__shared_weak_count *)a1[21];
  uint64_t v4 = v2;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = (unsigned char *)a1[20];
  }
  if (v4[192])
  {
    if (v4[240])
    {
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 1174405120;
      v14[2] = sub_100D28AC0;
      v14[3] = &unk_101A522C0;
      v14[4] = a1;
      v14[5] = v2;
      uint64_t v15 = v3;
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v4 = (unsigned char *)a1[20];
      }
      v4[157] = 1;
      sub_1002EF958((uint64_t)v20);
      buf[0] = 0;
      long long v25 = *(_OWORD *)v20;
      if (SHIBYTE(v22) < 0)
      {
        sub_10004FC84(&v26, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        long long v26 = __p;
        uint64_t v27 = v22;
      }
      char v28 = v23;
      buf[0] = 1;
      if (v4[192])
      {
        int v6 = sub_1003D5918((uint64_t)(v4 + 200), (uint64_t)&v25);
        if (!buf[0])
        {
LABEL_18:
          if (SHIBYTE(v22) < 0) {
            operator delete((void *)__p);
          }
          uint64_t v7 = a1[5];
          BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
          if (v6)
          {
            if (v8)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Delete all profiles", buf, 2u);
            }
            sub_100D28C48((uint64_t)a1);
          }
          else
          {
            if (v8)
            {
              uint64_t v9 = a1[20];
              if (!*(unsigned char *)(v9 + 192)) {
                __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
              }
              long long v16 = *(_OWORD *)(v9 + 200);
              if (*(char *)(v9 + 239) < 0)
              {
                sub_10004FC84(&v17, *(void **)(v9 + 216), *(void *)(v9 + 224));
              }
              else
              {
                long long v17 = *(_OWORD *)(v9 + 216);
                uint64_t v18 = *(void *)(v9 + 232);
              }
              char v19 = *(unsigned char *)(v9 + 240);
              sVinylUniversalProfileIdAsString();
              if (v25 >= 0) {
                uint64_t v10 = buf;
              }
              else {
                uint64_t v10 = *(uint8_t **)buf;
              }
              *(_DWORD *)__int16 v20 = 136315138;
              *(void *)&void v20[4] = v10;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Deleting profile %s", v20, 0xCu);
              if (SHIBYTE(v25) < 0) {
                operator delete(*(void **)buf);
              }
              if (SHIBYTE(v18) < 0) {
                operator delete((void *)v17);
              }
            }
            uint64_t v11 = a1[20];
            if (!*(unsigned char *)(v11 + 192)) {
              __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
            }
            if (*(char *)(v11 + 239) < 0)
            {
              sub_10004FC84(v12, *(void **)(v11 + 216), *(void *)(v11 + 224));
            }
            else
            {
              *(_OWORD *)char v12 = *(_OWORD *)(v11 + 216);
              uint64_t v13 = *(void *)(v11 + 232);
            }
            sub_100D28D48((uint64_t)a1, (uint64_t)v12, (uint64_t)v14);
            if (SHIBYTE(v13) < 0) {
              operator delete(v12[0]);
            }
          }
          sub_100D259C0((uint64_t)a1);
          if (v15) {
            std::__shared_weak_count::__release_weak(v15);
          }
          goto LABEL_44;
        }
      }
      else
      {
        int v6 = 0;
      }
      if (SHIBYTE(v27) < 0) {
        operator delete((void *)v26);
      }
      goto LABEL_18;
    }
    uint64_t v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Invalid profile type to attempt delete", buf, 2u);
    }
  }
LABEL_44:
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D27D6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100D27DF8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 56) = 0u;
  uint64_t result = (unsigned char *)(a2 + 56);
  *(_OWORD *)(a2 + 72) = 0u;
  int v5 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = v5;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *uint64_t result = 0;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 152);
  uint64_t v6 = *(void *)(a1 + 160);
  if (v6)
  {
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(v6 + 8);
    if (*(unsigned char *)(v6 + 112))
    {
      uint64_t result = (unsigned char *)sub_100D29CF4((uint64_t)result, (uint64_t *)(v6 + 88));
      uint64_t v6 = *(void *)(a1 + 160);
    }
    *(_DWORD *)a2 = *(_DWORD *)v6;
    if (*(unsigned char *)(v6 + 24))
    {
      uint64_t result = std::string::operator=((std::string *)(a2 + 32), (const std::string *)(v6 + 32));
      uint64_t v6 = *(void *)(a1 + 160);
    }
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 80);
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

void sub_100D27EAC(_Unwind_Exception *a1)
{
  sub_10015A318(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D27EC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I did complete receipts operation", v4, 2u);
  }
  return sub_100D25F88(v1, 0);
}

void sub_100D27F30(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_100D280E4;
        v15[3] = &unk_101A52200;
        uint64_t v9 = a1[7];
        BOOL v8 = (std::__shared_weak_count *)a1[8];
        void v15[4] = v5;
        v15[5] = v9;
        long long v16 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1007A816C((uint64_t)v17, a2);
        uint64_t v10 = (std::__shared_weak_count *)v5[2];
        if (!v10 || (uint64_t v11 = v5[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        uint64_t v14 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v11;
        uint64_t v21 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v13);
        if (v17[0] == 1 && __p)
        {
          char v19 = __p;
          operator delete(__p);
        }
        v17[0] = 0;
        if (v16) {
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D280C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D280E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = (capabilities::ct *)std::__shared_weak_count::lock(v3);
    int v5 = (std::__shared_weak_count *)v4;
    if (v4)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (v6)
      {
        if (v6 == *(void *)(v2 + 160))
        {
          int v7 = *(unsigned __int8 *)(a1 + 56);
          if (v7 != 1)
          {
            long long v16 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              sub_1007998A4((unsigned __int8 *)(a1 + 56));
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = asString();
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Vinyl profile fetch failed: %s; leaving profiles as is",
                (uint8_t *)&buf,
                0xCu);
              int v7 = *(unsigned __int8 *)(a1 + 56);
            }
            if (v7 != 2)
            {
              exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
              if (v7 == 1)
              {
                uint64_t v21 = &ctu::ResultIsNotError::~ResultIsNotError;
                ctu::ResultIsNotError::ResultIsNotError(exception);
              }
              else
              {
                uint64_t v21 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
              }
              __cxa_throw(exception, v22, (void (*)(void *))v21);
            }
            if (*(unsigned char *)(a1 + 64) == 2)
            {
              int v17 = *(_DWORD *)(v2 + 80);
              int v18 = *(unsigned __int8 *)(a1 + 65);
              int v19 = *(unsigned __int8 *)(a1 + 66);
              *(void *)&long long buf = _NSConcreteStackBlock;
              *((void *)&buf + 1) = 0x40000000;
              uint64_t v27 = sub_1004F09E8;
              char v28 = &unk_1019DB198;
              int v29 = v17;
              int v30 = 5;
              int v31 = v18;
              int v32 = v19;
              sub_1004F0808((wis::MetricFactory *)0x800F1);
            }
            goto LABEL_24;
          }
          long long buf = 0uLL;
          uint64_t v27 = 0;
          char v8 = capabilities::ct::getProvisioningProfileSupport(v4) == 0;
          sub_1003EE3F0((void *)(a1 + 64), v8, (uint64_t *)&buf);
          long long v9 = buf;
          uint64_t v10 = *(NSObject **)(v2 + 40);
          BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if ((void)v9 == *((void *)&v9 + 1))
          {
            if (v11)
            {
              LOWORD(v24) = 0;
              char v12 = "#I No profiles decoded from baseband";
              uint64_t v13 = v10;
              uint32_t v14 = 2;
              goto LABEL_22;
            }
          }
          else if (v11)
          {
            LODWORD(v24) = 134217984;
            *(void *)((char *)&v24 + 4) = 0x84BDA12F684BDA13 * ((uint64_t)(*((void *)&v9 + 1) - v9) >> 3);
            char v12 = "#I Decoded %lu profiles from baseband";
            uint64_t v13 = v10;
            uint32_t v14 = 12;
LABEL_22:
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v24, v14);
          }
          long long v24 = 0uLL;
          uint64_t v25 = 0;
          sub_1000C5EF0(&v24, buf, *((uint64_t *)&buf + 1), 0x84BDA12F684BDA13 * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3));
          sub_100D29560(v2, (uint64_t *)&v24);
          p_long long buf = (void **)&v24;
          sub_1000C57C8(&p_buf);
          p_long long buf = (void **)&buf;
          sub_1000C57C8(&p_buf);
LABEL_24:
          *(_WORD *)(*(void *)(v2 + 160) + 153) = 0;
          sub_100D25F88(v2, 0);
LABEL_13:
          sub_10004D2C8(v5);
          return;
        }
      }
    }
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v15 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; dropping fetch profiles result.",
      (uint8_t *)&buf,
      2u);
  }
  if (v5) {
    goto LABEL_13;
  }
}

void sub_100D28450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __cxa_free_exception(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D284A8(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    int v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_100D2865C;
        v15[3] = &unk_101A52260;
        uint64_t v9 = a1[7];
        char v8 = (std::__shared_weak_count *)a1[8];
        void v15[4] = v5;
        v15[5] = v9;
        long long v16 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1007A816C((uint64_t)v17, a2);
        uint64_t v10 = (std::__shared_weak_count *)v5[2];
        if (!v10 || (uint64_t v11 = v5[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        uint32_t v14 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v11;
        uint64_t v21 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v15;
        dispatch_async(v14, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v13);
        if (v17[0] == 1 && __p)
        {
          int v19 = __p;
          operator delete(__p);
        }
        v17[0] = 0;
        if (v16) {
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D28638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D2865C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        if (v5 == *(void *)(v2 + 160))
        {
          uint64_t v6 = (unsigned __int8 *)(a1 + 56);
          int v7 = *(unsigned __int8 *)(a1 + 56);
          if (v7 == 1)
          {
            long long v23 = 0uLL;
            long long v24 = 0;
            if (sub_10074B41C((uint64_t *)(a1 + 64)))
            {
              char v8 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to decode tape profile info list from baseband", buf, 2u);
              }
            }
            else
            {
              uint64_t v15 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I No tape profiles decoded from baseband", buf, 2u);
              }
            }
            *(void *)long long buf = 0;
            uint64_t v21 = 0;
            uint64_t v22 = 0;
            sub_1000C5EF0(buf, v23, *((uint64_t *)&v23 + 1), 0x84BDA12F684BDA13 * ((uint64_t)(*((void *)&v23 + 1) - v23) >> 3));
            sub_100D29560(v2, (uint64_t *)buf);
            int v19 = buf;
            sub_1000C57C8((void ***)&v19);
            int v19 = (uint8_t *)&v23;
            sub_1000C57C8((void ***)&v19);
LABEL_24:
            *(_WORD *)(*(void *)(v2 + 160) + 153) = 0;
            sub_100D25F88(v2, 0);
LABEL_13:
            sub_10004D2C8(v4);
            return;
          }
          uint64_t v10 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            sub_1007998A4((unsigned __int8 *)(a1 + 56));
            LODWORD(v23) = 136315138;
            *(void *)((char *)&v23 + 4) = asString();
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Tape profile info list failed: %s", (uint8_t *)&v23, 0xCu);
            int v7 = *v6;
          }
          if (v7 == 2)
          {
            int v11 = *(_DWORD *)(v2 + 80);
            int v12 = *(unsigned __int8 *)(a1 + 65);
            int v13 = *(unsigned __int8 *)(a1 + 66);
            *(void *)&long long v23 = _NSConcreteStackBlock;
            *((void *)&v23 + 1) = 0x40000000;
            long long v24 = sub_1004F09E8;
            uint64_t v25 = &unk_1019DB198;
            int v26 = v11;
            int v27 = 13;
            int v28 = v12;
            int v29 = v13;
            sub_1004F0808((wis::MetricFactory *)0x800F1);
            int v14 = *v6;
            if (v14 == 2)
            {
              if (*(unsigned char *)(a1 + 64) == 11) {
                sub_100D22F74(v2, 4);
              }
              goto LABEL_24;
            }
            if (v14 == 1) {
              goto LABEL_28;
            }
          }
          else if (v7 == 1)
          {
LABEL_28:
            exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
            int v17 = &ctu::ResultIsNotError::~ResultIsNotError;
            ctu::ResultIsNotError::ResultIsNotError(exception);
            goto LABEL_30;
          }
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          int v17 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_30:
          __cxa_throw(exception, v18, (void (*)(void *))v17);
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v9 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v23) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; dropping tape profile info list result.",
      (uint8_t *)&v23,
      2u);
  }
  if (v4) {
    goto LABEL_13;
  }
}

void sub_100D28A60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __cxa_free_exception(v16);
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100D28AC0(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = a1[5];
      if (v7)
      {
        if (v7 == *(void *)(v3 + 160))
        {
          uint64_t v8 = *(void *)(v7 + 248);
          __int16 v15 = 0;
          if (*a2 - 1 <= 1) {
            __int16 v15 = *(_WORD *)a2;
          }
          (*(void (**)(uint64_t, __int16 *))(v8 + 16))(v8, &v15);
          uint64_t v9 = *(void *)(v3 + 160);
          uint64_t v10 = *(const void **)(v9 + 248);
          *(void *)(v9 + 248) = 0;
          if (v10) {
            _Block_release(v10);
          }
          uint64_t v11 = *(void *)(v3 + 160);
          if (*(unsigned char *)(v11 + 192))
          {
            uint64_t v12 = *(void *)(v3 + 160);
            if (*(char *)(v11 + 239) < 0)
            {
              operator delete(*(void **)(v11 + 216));
              uint64_t v12 = *(void *)(v3 + 160);
            }
            *(unsigned char *)(v11 + 192) = 0;
            uint64_t v11 = v12;
          }
          *(unsigned char *)(v11 + 157) = 0;
          if (*a2 == 1)
          {
            if (a2[1]) {
              sub_100D25690(v3);
            }
          }
LABEL_20:
          sub_10004D2C8(v6);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  int v13 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; ignoring delete profile result.",
      v14,
      2u);
  }
  if (v6) {
    goto LABEL_20;
  }
}

void sub_100D28C08(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D28C1C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D28C38(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D28C48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v1 || (uint64_t v2 = std::__shared_weak_count::lock(v1)) == 0) {
    sub_100088B9C();
  }
  uint64_t v3 = v2;
  p_shared_weak_owners = &v2->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v2);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  VinylCommandDriver::tapeResetMemory();
  std::__shared_weak_count::__release_weak(v3);
  std::__shared_weak_count::__release_weak(v3);
}

void sub_100D28D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void sub_100D28D48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  BOOL v5 = sub_10075180C((uint64_t)__dst, (uint64_t)&v17);
  BOOL v6 = v5;
  if ((SHIBYTE(v16) & 0x80000000) == 0)
  {
    if (v5) {
      goto LABEL_6;
    }
LABEL_12:
    __int16 v14 = 258;
    (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v14);
    LOBYTE(v14) = 0;
    goto LABEL_13;
  }
  operator delete(__dst[0]);
  if (!v6) {
    goto LABEL_12;
  }
LABEL_6:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v7 || (uint64_t v8 = std::__shared_weak_count::lock(v7)) == 0) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  p_shared_weak_owners = &v8->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  long long __p = 0;
  sub_10005C928(&__p, v17, (uint64_t)v18, v18 - (unsigned char *)v17);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  VinylCommandDriver::deleteTapeProfile();
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v9);
  std::__shared_weak_count::__release_weak(v9);
LABEL_13:
  if (v17)
  {
    int v18 = v17;
    operator delete(v17);
  }
}

void sub_100D28EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  int v30 = *(void **)(v28 - 88);
  if (v30)
  {
    *(void *)(v28 - 80) = v30;
    operator delete(v30);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D28F74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4 || (uint64_t v7 = *(std::__shared_weak_count **)(a1 + 8), (v8 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  if (*(_DWORD *)(a1 + 84) == 1)
  {
    sub_100D2B534(a2);
    v23[4] = (std::__shared_weak_count *)_NSConcreteStackBlock;
    v23[5] = (std::__shared_weak_count *)1174405120;
    v23[6] = (std::__shared_weak_count *)sub_100D2BB18;
    v23[7] = (std::__shared_weak_count *)&unk_101A523A8;
    v23[8] = (std::__shared_weak_count *)a1;
    v23[9] = v7;
    v23[10] = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_1000C6AC0((uint64_t)v24, a3);
    VinylCommandDriver::deactivateProfile();
    sub_1000C6B58(v24);
    std::__shared_weak_count::__release_weak(v9);
  }
  else
  {
    uint64_t v13 = 0;
    __int16 v14 = 0;
    uint64_t v15 = 0;
    if (sub_1007513C0(a2, 0, 0, (uint64_t)&v13))
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      long long __p = 0;
      sub_10005C928(&__p, v13, (uint64_t)v14, v14 - (unsigned char *)v13);
      uint64_t v16 = _NSConcreteStackBlock;
      uint64_t v17 = 1174405120;
      int v18 = sub_100D2BD1C;
      uint64_t v19 = &unk_101A523D8;
      uint64_t v20 = a1;
      uint64_t v21 = v7;
      uint64_t v22 = v9;
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_1000C6AC0((uint64_t)v23, a3);
      VinylCommandDriver::disableTapeProfile();
      if (__p)
      {
        uint64_t v11 = __p;
        operator delete(__p);
      }
      sub_1000C6B58(v23);
      if (v22) {
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    else
    {
      sub_1000C26BC(a3, 257);
    }
    if (v13)
    {
      __int16 v14 = v13;
      operator delete(v13);
    }
  }
  std::__shared_weak_count::__release_weak(v9);
}

void sub_100D291E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33)
{
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v33);
  _Unwind_Resume(a1);
}

void sub_100D2926C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4 || (uint64_t v7 = *(std::__shared_weak_count **)(a1 + 8), (v8 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  if (*(_DWORD *)(a1 + 84) == 1)
  {
    sub_100D2B534(a2);
    v23[4] = (std::__shared_weak_count *)_NSConcreteStackBlock;
    v23[5] = (std::__shared_weak_count *)1174405120;
    v23[6] = (std::__shared_weak_count *)sub_100D2B698;
    v23[7] = (std::__shared_weak_count *)&unk_101A52348;
    v23[8] = (std::__shared_weak_count *)a1;
    v23[9] = v7;
    v23[10] = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_1000C6AC0((uint64_t)v24, a3);
    VinylCommandDriver::activateProfile();
    sub_1000C6B58(v24);
    std::__shared_weak_count::__release_weak(v9);
  }
  else
  {
    uint64_t v13 = 0;
    __int16 v14 = 0;
    uint64_t v15 = 0;
    if (sub_1007513C0(a2, 1, 0, (uint64_t)&v13))
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      long long __p = 0;
      sub_10005C928(&__p, v13, (uint64_t)v14, v14 - (unsigned char *)v13);
      uint64_t v16 = _NSConcreteStackBlock;
      uint64_t v17 = 1174405120;
      int v18 = sub_100D2B928;
      uint64_t v19 = &unk_101A52378;
      uint64_t v20 = a1;
      uint64_t v21 = v7;
      uint64_t v22 = v9;
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_1000C6AC0((uint64_t)v23, a3);
      VinylCommandDriver::enableTapeProfile();
      if (__p)
      {
        uint64_t v11 = __p;
        operator delete(__p);
      }
      sub_1000C6B58(v23);
      if (v22) {
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    else
    {
      sub_1000C26BC(a3, 257);
    }
    if (v13)
    {
      __int16 v14 = v13;
      operator delete(v13);
    }
  }
  std::__shared_weak_count::__release_weak(v9);
}

void sub_100D294D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33)
{
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v33);
  _Unwind_Resume(a1);
}

uint64_t sub_100D29560(uint64_t a1, uint64_t *a2)
{
  memset(v44, 0, sizeof(v44));
  sub_100D29B60(v44, *(void *)(a1 + 160));
  if (*(_DWORD *)(a1 + 156) == 9)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a2[1];
    if (*a2 != v5)
    {
      do
      {
        *(unsigned char *)(v4 + 90) = 1;
        v4 += 216;
      }
      while (v4 != v5);
    }
  }
  sub_1008793A4(*(void *)(a1 + 160) + 88, (uint64_t)a2);
  int v6 = *(_DWORD *)(a1 + 80);
  uint64_t v7 = *(void *)(a1 + 160);
  if (v7 && *(unsigned char *)(v7 + 112))
  {
    uint64_t v8 = *(void *)(v7 + 88);
    uint64_t v9 = *(void *)(v7 + 96);
    while (v8 != v9)
    {
      if (*(unsigned char *)(v8 + 88))
      {
        sub_1000C5AB4((uint64_t)v45, v8);
        char v10 = 1;
        goto LABEL_11;
      }
      v8 += 216;
    }
  }
  char v10 = 0;
  v45[0] = 0;
LABEL_11:
  char v46 = v10;
  uint64_t v11 = (uint64_t *)sub_10068F3AC(&event::vinyl_bootstrap_profile[1]);
  sub_1003DABB4(v47, (uint64_t)v45);
  int v41 = v6;
  long long v40 = 0uLL;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  uint64_t v12 = (pthread_mutex_t *)sub_100060E64(v11 + 3);
  sub_100061F70(&v48, v12);
  uint64_t v13 = v11[1];
  if (v13)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire) == 1) {
      sub_10068F674(v11, &v48, 0, 1);
    }
    uint64_t v14 = *v11;
    uint64_t v15 = v11[1];
    if (v15) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v15 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = *v11;
  }
  long long v16 = v40;
  *(void *)&long long v40 = v14;
  *((void *)&v40 + 1) = v15;
  v71[0] = v16;
  sub_10000A740((atomic_uint **)v71 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v59 + 1));
  sub_10000A5F8(&v48);
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v48 = 0u;
  uint64_t v63 = 0;
  uint64_t v64 = 10;
  unint64_t v65 = (char *)&v48 + 8;
  uint64_t v66 = 0;
  unint64_t v67 = &v41;
  uint64_t v68 = v47;
  uint64_t v70 = 0;
  uint64_t v69 = 0;
  uint64_t v17 = (uint64_t *)sub_10068F3F0((uint64_t *)&v40);
  v39[0] = &v48;
  v39[1] = v11;
  void v39[2] = sub_100690228(v17);
  uint64_t v18 = sub_10068F3F0((uint64_t *)&v40);
  sub_100060EA8((uint64_t *)(v18 + 16));
  uint64_t v19 = (uint64_t *)sub_10068F3F0((uint64_t *)&v40);
  uint64_t v20 = *(void *)(sub_100690228(v19) + 8);
  uint64_t v21 = (uint64_t *)sub_10068F3F0((uint64_t *)&v40);
  *(void *)&long long v37 = v20;
  *((void *)&v37 + 1) = sub_100690228(v21);
  *(void *)&long long v38 = &v48;
  *((void *)&v38 + 1) = *((void *)&v37 + 1);
  sub_100D39D30((uint64_t *)&v37);
  uint64_t v22 = (uint64_t *)sub_10068F3F0((uint64_t *)&v40);
  uint64_t v23 = sub_100690228(v22);
  long long v24 = (uint64_t *)sub_10068F3F0((uint64_t *)&v40);
  uint64_t v33 = v23;
  uint64_t v34 = sub_100690228(v24);
  int v35 = &v48;
  uint64_t v36 = v34;
  sub_100D39D30(&v33);
  long long v42 = v37;
  long long v43 = v38;
  uint64_t v25 = v33;
  uint64_t v26 = v37;
  if ((void)v37 != v33)
  {
    uint64_t v27 = v43;
    BOOL v28 = *(unsigned char *)v43 == 0;
    do
    {
      if (v28)
      {
        uint64_t v29 = sub_10068F434((uint64_t *)(v26 + 16));
        uint64_t v30 = sub_10068FDC4((uint64_t *)(v29 + 32));
        uint64_t v31 = **(unsigned int **)(v27 + 272);
        sub_1003DABB4(v71, *(void *)(v27 + 280));
        sub_100690828((void *)(v30 + 24), v31, (uint64_t)v71);
        if (v72) {
          sub_1000C584C((uint64_t)v71);
        }
        if (!*(unsigned char *)v27) {
          *(unsigned char *)uint64_t v27 = 1;
        }
      }
      if (!*(unsigned char *)v43) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      *(void *)&long long v42 = *(void *)(v42 + 8);
      sub_100D39D30((uint64_t *)&v42);
      uint64_t v27 = v43;
      if (*(unsigned char *)v43) {
        *(unsigned char *)long long v43 = 0;
      }
      uint64_t v26 = v42;
      BOOL v28 = 1;
    }
    while ((void)v42 != v25);
  }
  sub_100D3A0AC(v39);
  sub_100D3A274((uint64_t)&v48);
  sub_10000A740((atomic_uint **)&v40 + 1);
  if (v47[216]) {
    sub_1000C584C((uint64_t)v47);
  }
  if (v46) {
    sub_1000C584C((uint64_t)v45);
  }
  sub_100D23C00((void *)a1);
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  uint64_t result = (uint64_t)sub_100D29B60(&v48, *(void *)(a1 + 160));
  if (!v44[0] || !(_BYTE)v48)
  {
    if ((v44[0] != 0) != (v48 == 0)) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  uint64_t result = VinylProfileDetails::operator==();
  if ((result & 1) == 0) {
LABEL_39:
  }
    uint64_t result = sub_1004EFB74();
LABEL_40:
  if ((_BYTE)v48) {
    uint64_t result = sub_1000C584C((uint64_t)&v48 + 8);
  }
  if (v44[0]) {
    return sub_1000C584C((uint64_t)&v44[8]);
  }
  return result;
}

void sub_100D29A9C(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100D29B58);
}

void sub_100D29AE0()
{
}

void sub_100D29AE8()
{
}

void sub_100D29AF0()
{
}

void sub_100D29B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,atomic_uint *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (LOBYTE(STACK[0x348])) {
    sub_1000C584C((uint64_t)&STACK[0x270]);
  }
  if (LOBYTE(STACK[0x268])) {
    sub_1000C584C((uint64_t)&a59);
  }
  if (a31) {
    sub_1000C584C((uint64_t)&a32);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100D29B60(unsigned char *result, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = result;
  if (a2)
  {
    if (*(unsigned char *)(a2 + 112))
    {
      uint64_t v4 = *(void *)(a2 + 88);
      uint64_t v5 = *(void *)(v2 + 96);
      while (v4 != v5)
      {
        if (*(unsigned char *)(v4 + 89))
        {
          *uint64_t result = 0;
          uint64_t result = (unsigned char *)sub_1000C5AB4((uint64_t)(result + 8), v4);
          LOBYTE(v2) = 1;
          goto LABEL_9;
        }
        v4 += 216;
      }
    }
    LOBYTE(v2) = 0;
  }
LABEL_9:
  unsigned char *v3 = v2;
  return result;
}

void *sub_100D29BC8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 40))
  {
    uint64_t v2 = *(void *)(a1 + 160);
    if (v2 && *(unsigned char *)(v2 + 112))
    {
      uint64_t v3 = *(void *)(v2 + 88);
      uint64_t v4 = *(void *)(v2 + 96);
      if (v3 == v4)
      {
LABEL_33:
        if (v3 == v4) {
          return 0;
        }
        else {
          return (void *)v3;
        }
      }
      else
      {
        char v5 = *(unsigned char *)(a2 + 39);
        if (v5 >= 0) {
          uint64_t v6 = *(unsigned __int8 *)(a2 + 39);
        }
        else {
          uint64_t v6 = *(void *)(a2 + 24);
        }
        if (v5 >= 0) {
          uint64_t v7 = (unsigned __int8 *)(a2 + 16);
        }
        else {
          uint64_t v7 = *(unsigned __int8 **)(a2 + 16);
        }
        do
        {
          uint64_t v8 = *(unsigned __int8 *)(v3 + 39);
          if ((v8 & 0x80u) == 0) {
            uint64_t v9 = *(unsigned __int8 *)(v3 + 39);
          }
          else {
            uint64_t v9 = *(void *)(v3 + 24);
          }
          if (v9 == v6)
          {
            if ((v8 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v3 + 16), v7, *(void *)(v3 + 24))) {
                goto LABEL_33;
              }
            }
            else
            {
              if (!*(unsigned char *)(v3 + 39)) {
                goto LABEL_33;
              }
              uint64_t v10 = 0;
              while (*(unsigned __int8 *)(v3 + v10 + 16) == v7[v10])
              {
                if (v8 == ++v10) {
                  goto LABEL_33;
                }
              }
            }
          }
          uint64_t result = 0;
          v3 += 216;
        }
        while (v3 != v4);
      }
      return result;
    }
    return 0;
  }
  uint64_t v12 = *(void *)(a1 + 160);
  if (!v12 || !*(unsigned char *)(v12 + 112)) {
    return 0;
  }
  uint64_t v13 = *(void **)(v12 + 88);
  uint64_t v14 = *(void **)(v12 + 96);
  if (v13 != v14)
  {
    while (*v13 != *(void *)a2 || v13[1] != *(void *)(a2 + 8))
    {
      v13 += 27;
      if (v13 == v14) {
        return 0;
      }
    }
  }
  if (v13 == v14) {
    return 0;
  }
  else {
    return v13;
  }
}

uint64_t sub_100D29CF4(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if ((uint64_t *)a1 != a2) {
      sub_1000C87AC(a1, *a2, a2[1], 0x84BDA12F684BDA13 * ((a2[1] - *a2) >> 3));
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1000C5EF0((void *)a1, *a2, a2[1], 0x84BDA12F684BDA13 * ((a2[1] - *a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_100D29D94(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 496) = 0;
  *(_OWORD *)(a2 + 464) = 0u;
  *(_OWORD *)(a2 + 480) = 0u;
  *(_OWORD *)(a2 + 432) = 0u;
  *(_OWORD *)(a2 + 448) = 0u;
  *(_OWORD *)(a2 + 400) = 0u;
  *(_OWORD *)(a2 + 416) = 0u;
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  unsigned int v4 = *(_DWORD *)(a1 + 152);
  if (v4 > 4 || v4 == 3)
  {
    uint64_t v5 = *(void *)(a1 + 160);
    if (v5)
    {
      *(_OWORD *)a2 = *(_OWORD *)(v5 + 8);
      *(unsigned char *)(a2 + 16) = 1;
      sub_100CFBAA0((char *)(v5 + 24), (uint64_t)&__p);
      sub_100179CB0(a2 + 24, &__p);
      if (v11 && v10 < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      uint64_t v6 = *(void *)(a1 + 160);
      if (v6)
      {
        if (*(unsigned char *)(v6 + 112))
        {
          uint64_t v7 = *(void *)(v6 + 88);
          for (uint64_t i = *(void *)(v6 + 96); v7 != i; v7 += 216)
          {
            if (*(unsigned char *)(v7 + 88)) {
              sub_1007866A0(a2 + 56, v7);
            }
            if (*(unsigned char *)(v7 + 89)) {
              sub_1007866A0(a2 + 280, v7);
            }
          }
        }
      }
    }
  }
}

void sub_100D29ED4(_Unwind_Exception *a1)
{
  sub_100484FC8(v1);
  _Unwind_Resume(a1);
}

void sub_100D29EEC(uint64_t a1, uint64_t *a2, void *aBlock, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 84) == 2)
  {
    if (aBlock) {
      uint64_t v7 = _Block_copy(aBlock);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *a2;
    uint64_t v9 = (std::__shared_weak_count *)a2[1];
    v14[0] = v8;
    v14[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 1174405120;
    v12[2] = sub_100D2A88C;
    void v12[3] = &unk_101A522F0;
    if (v7) {
      char v10 = _Block_copy(v7);
    }
    else {
      char v10 = 0;
    }
    aBlocka = v10;
    sub_100D2A0B4(a1, v14, (uint64_t)v12, a4);
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (aBlocka) {
      _Block_release(aBlocka);
    }
    if (v7) {
      _Block_release(v7);
    }
  }
  else
  {
    __int16 v11 = 514;
    v15[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v11, v15);
    sub_1000C60A0(v15);
  }
}

void sub_100D2A050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, uint64_t a16, uint64_t a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2A0B4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch' as vinyl availability is %s", buf, 0xCu);
    }
    __int16 v62 = 514;
    v71[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v62, v71);
    uint64_t v7 = v71;
LABEL_71:
    sub_1000C60A0(v7);
    return;
  }
  uint64_t v8 = *(void *)(a1 + 160);
  if (!v8)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch' until we have seen availability", buf, 2u);
    }
    __int16 v61 = 770;
    v70[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v61, v70);
    uint64_t v7 = v70;
    goto LABEL_71;
  }
  uint64_t v11 = *(void *)(v8 + 160);
  if (v11 && ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 56))(v11) & 1) == 0)
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch'; an installation procedure already exists",
        buf,
        2u);
    }
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 160) + 160) + 80))(*(void *)(*(void *)(a1 + 160) + 160));
    __int16 v60 = 1282;
    v69[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v60, v69);
    uint64_t v7 = v69;
    goto LABEL_71;
  }
  if (*(_DWORD *)(a1 + 84) != 2)
  {
    long long v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch'; invalid card type",
        buf,
        2u);
    }
    __int16 v59 = 514;
    v68[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v59, v68);
    uint64_t v7 = v68;
    goto LABEL_71;
  }
  if (((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) == 0)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch' as the SIM is %s", buf, 0xCu);
    }
    __int16 v58 = 770;
    v67[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v58, v67);
    uint64_t v7 = v67;
    goto LABEL_71;
  }
  uint64_t v12 = *(void *)(a1 + 160);
  if (*(unsigned char *)(v12 + 112))
  {
    uint64_t v13 = *(void *)(v12 + 88);
    uint64_t v14 = *(void *)(v12 + 96);
    if (v13 != v14)
    {
      while (!*(unsigned char *)(v13 + 91))
      {
        v13 += 216;
        if (v13 == v14) {
          goto LABEL_31;
        }
      }
    }
    if (v13 != v14)
    {
      uint64_t v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'fetch'; current profile cannot be disabled",
          buf,
          2u);
      }
      __int16 v57 = 2818;
      v66[0] = 0;
      (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v57, v66);
      uint64_t v7 = v66;
      goto LABEL_71;
    }
  }
LABEL_31:
  uint64_t v20 = *(std::__shared_weak_count **)(a1 + 128);
  if (!v20 || (uint64_t v21 = std::__shared_weak_count::lock(v20)) == 0)
  {
LABEL_39:
    uint64_t v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Queueing up a Tape Install operation", buf, 2u);
    }
    sub_100D259C0(a1);
    BOOL v26 = 0;
    uint64_t v27 = *(void *)(a1 + 160);
    *(unsigned char *)(v27 + 155) = 0;
    uint64_t v28 = *a2;
    uint64_t v29 = *(unsigned __int8 *)(*a2 + 215);
    int v30 = (char)v29;
    if ((v29 & 0x80u) != 0) {
      uint64_t v29 = *(void *)(*a2 + 200);
    }
    if (v29 == 4)
    {
      uint64_t v33 = *(_DWORD **)(v28 + 192);
      int v32 = (_DWORD *)(v28 + 192);
      uint64_t v31 = v33;
      if (v30 >= 0) {
        uint64_t v31 = v32;
      }
      BOOL v26 = *v31 == 825241653;
    }
    *(unsigned char *)(v27 + 156) = v26;
    uint64_t v34 = *(std::__shared_weak_count **)(a1 + 56);
    uint64_t v35 = *(void *)(a1 + 64);
    uint64_t v54 = *(void *)(a1 + 48);
    long long v55 = v34;
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v36 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v36;
    if (v36) {
      dispatch_retain(v36);
    }
    uint64_t v37 = *(unsigned int *)(a1 + 80);
    long long v38 = *(std::__shared_weak_count **)(a1 + 112);
    uint64_t v51 = *(void *)(a1 + 104);
    long long v52 = v38;
    if (v38) {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v39 = (std::__shared_weak_count *)a2[1];
    uint64_t v49 = *a2;
    long long v50 = v39;
    if (v39) {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 0x40000000;
    v48[2] = sub_100D2A97C;
    v48[3] = &unk_101A52328;
    v48[4] = a4;
    v48[5] = a1;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t *, dispatch_object_t *, uint64_t, uint64_t *, uint64_t *, uint64_t, void *))(*(void *)v35 + 112))(buf, v35, &v54, &object, v37, &v51, &v49, a3, v48);
    uint64_t v40 = *(void *)(a1 + 160);
    long long v41 = *(_OWORD *)buf;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    long long v42 = *(std::__shared_weak_count **)(v40 + 168);
    *(_OWORD *)(v40 + 160) = v41;
    if (v42)
    {
      sub_10004D2C8(v42);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    if (v50) {
      sub_10004D2C8(v50);
    }
    if (v52) {
      sub_10004D2C8(v52);
    }
    if (object) {
      dispatch_release(object);
    }
    long long v43 = (capabilities::ct *)v55;
    if (v55) {
      sub_10004D2C8(v55);
    }
    uint64_t v44 = *(void *)(*(void *)(a1 + 160) + 160);
    if (v44)
    {
      int v45 = capabilities::ct::supportedLPASVN(v43);
      sub_10132A380(v44, v45);
      sub_100D25F88(a1, 0);
      return;
    }
    char v46 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Missing installation operation", buf, 2u);
    }
    __int16 v47 = 258;
    v63[0] = 0;
    (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v47, v63);
    uint64_t v7 = v63;
    goto LABEL_71;
  }
  uint64_t v22 = v21;
  uint64_t v23 = *(void *)(a1 + 120);
  if (!v23
    || !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v23 + 56))(v23, *a2 + 96, *a2 + 48))
  {
    sub_10004D2C8(v22);
    goto LABEL_39;
  }
  long long v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Skipping Vinyl Install as retry limit has exceeded threshold", buf, 2u);
  }
  __int16 v56 = 257;
  v65[0] = 0;
  (*(void (**)(uint64_t, __int16 *, unsigned char *))(a4 + 16))(a4, &v56, v65);
  sub_1000C60A0(v65);
  LOBYTE(v56) = 0;
  sub_10004D2C8(v22);
}

void sub_100D2A7D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_object_t object,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  sub_1000C60A0(&a40);
  sub_10004D2C8(v40);
  _Unwind_Resume(a1);
}

unsigned char *sub_100D2A88C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = 0;
  sub_1000C5A48((uint64_t)v4, a2);
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  return sub_1000C5D34(v4);
}

void sub_100D2A908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void *sub_100D2A924(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 32);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 32) = result;
  return result;
}

void sub_100D2A958(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100D2A97C(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v8 = *(void **)(a1 + 40);
  uint64_t v9 = v8[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 0xA) {
      char v10 = "???";
    }
    else {
      char v10 = off_101A52E28[(char)a2];
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v23 = 1024;
    int v24 = a3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Install complete: %s, %d", buf, 0x12u);
  }
  __int16 v19 = 0;
  if (a2 <= 0xA)
  {
    if (((1 << a2) & 0x3E7) != 0)
    {
      uint64_t v11 = v8[20];
      if (v11) {
        *(_WORD *)(v11 + 155) = 0;
      }
      if (a2 > 9) {
        char v12 = 0;
      }
      else {
        char v12 = byte_101569235[(char)a2];
      }
      buf[0] = 2;
      buf[1] = v12;
      sub_100D38FF4((char *)&v19, buf);
      sub_100D25690(v8);
    }
    else if (a2 == 4)
    {
      uint64_t v15 = v8[5];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Activating a deactivate-assertion.", buf, 2u);
      }
      uint64_t v16 = v8[20];
      if (v16) {
        *(unsigned char *)(v16 + 155) = 1;
      }
    }
    else if (a2 == 10)
    {
      uint64_t v14 = v8[20];
      if (v14) {
        *(_WORD *)(v14 + 155) = 0;
      }
      *(_WORD *)long long buf = 257;
      sub_100D38FF4((char *)&v19, buf);
      if (!*(unsigned char *)a4) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      if (*(unsigned char *)(a4 + 88))
      {
        memset(v18, 0, sizeof(v18));
        sub_1000C5EF0(v18, *(void *)(a4 + 64), *(void *)(a4 + 72), 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(a4 + 72) - *(void *)(a4 + 64)) >> 3));
        sub_100D29560((uint64_t)v8, v18);
        *(void *)long long buf = v18;
        sub_1000C57C8((void ***)buf);
      }
    }
  }
  if (a3) {
    sub_100D259C0((uint64_t)v8);
  }
  if ((_BYTE)v19)
  {
    uint64_t v13 = *(void *)(a1 + 32);
    __int16 v17 = 0;
    if (v19 <= 2u) {
      __int16 v17 = v19;
    }
    v20[0] = 0;
    if (*(unsigned char *)a4)
    {
      sub_1000C5DA8((uint64_t)&v21, a4 + 8);
      v20[0] = 1;
    }
    (*(void (**)(uint64_t, __int16 *, char *))(v13 + 16))(v13, &v17, v20);
    sub_1000C60A0(v20);
    LOBYTE(v17) = 0;
  }
  if ((a3 & 1) == 0) {
    sub_100D25F88((uint64_t)v8, 0);
  }
}

void sub_100D2AC6C(_Unwind_Exception *a1)
{
  *uint64_t v2 = v1;
  sub_1000C57C8((void ***)(v3 - 96));
  _Unwind_Resume(a1);
}

void sub_100D2AC9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_DWORD *)(a1 + 152) - 1) > 1)
  {
    uint64_t v6 = *(void *)(a1 + 160);
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 160);
      if (v7 && !(*(unsigned int (**)(uint64_t))(*(void *)v7 + 56))(v7))
      {
        if (*(_DWORD *)(a1 + 84) == 2)
        {
          if (((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) != 0)
          {
            (*(void (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 160) + 160) + 48))(*(void *)(*(void *)(a1 + 160) + 160), a2);
            __int16 v13 = 257;
            (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v13);
            LOBYTE(v13) = 0;
            sub_100D25F88(a1, 0);
          }
          else
          {
            char v12 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              uint64_t v20 = subscriber::asString();
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'user consent' as the SIM is %s", buf, 0xCu);
            }
            __int16 v14 = 770;
            (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v14);
          }
        }
        else
        {
          uint64_t v11 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Invalid card type", buf, 2u);
          }
          __int16 v15 = 514;
          (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v15);
        }
      }
      else
      {
        uint64_t v9 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'user consent'; no installation procedure exists",
            buf,
            2u);
        }
        __int16 v16 = 258;
        (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v16);
      }
    }
    else
    {
      char v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I No vinyl model", buf, 2u);
      }
      __int16 v17 = 770;
      (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v17);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v20 = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Ignoring vinyl availability is %s", buf, 0xCu);
    }
    __int16 v18 = 514;
    (*(void (**)(uint64_t, __int16 *))(a3 + 16))(a3, &v18);
  }
}

void sub_100D2AFB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 16) >= 2uLL && (capabilities::ct::supportsHydra((capabilities::ct *)a1) & 1) == 0)
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34(*(std::string **)a2, (std::string *)(a2 + 8), ",", 1uLL, &buf);
      char v10 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      *(_DWORD *)uint64_t v39 = 136315138;
      uint64_t v40 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate', too many iccids to activate: %s", v39, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    sub_1000C26BC(a3, 257);
    return;
  }
  if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate' as vinyl availability is %s", (uint8_t *)&buf, 0xCu);
    }
    sub_1000C26BC(a3, 258);
    return;
  }
  uint64_t v7 = *(void *)(a1 + 160);
  if (!v7)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate' until we have seen availability", (uint8_t *)&buf, 2u);
    }
    goto LABEL_70;
  }
  if (!*(unsigned char *)(v7 + 112))
  {
    uint64_t v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate' as we have no information about profiles yet", (uint8_t *)&buf, 2u);
    }
    goto LABEL_70;
  }
  if (((*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD) == 0 && *(_DWORD *)(a1 + 84) == 2)
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate' as the SIM is %s", (uint8_t *)&buf, 0xCu);
    }
LABEL_70:
    sub_1000C26BC(a3, 259);
    return;
  }
  uint64_t v36 = a3;
  char v12 = *(std::string **)a2;
  if (*(void *)a2 == a2 + 8) {
    goto LABEL_52;
  }
  uint64_t v13 = *(void *)(v7 + 88);
  uint64_t v14 = *(void *)(v7 + 96);
  __int16 v15 = *(std::string **)a2;
  uint64_t v37 = v13;
  do
  {
    p_std::string::size_type size = &v15[1].__r_.__value_.__l.__size_;
    if (v13 == v14)
    {
LABEL_71:
      uint64_t v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (v12[2].__r_.__value_.__s.__data_[7] < 0) {
          p_std::string::size_type size = (std::string::size_type *)*p_size;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_size;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate' missing ICCID: %s", (uint8_t *)&buf, 0xCu);
      }
      sub_1000C26BC(v36, 257);
      return;
    }
    int v17 = v15[2].__r_.__value_.__s.__data_[7];
    if (v17 >= 0) {
      std::string::size_type v18 = v15[2].__r_.__value_.__s.__data_[7];
    }
    else {
      std::string::size_type v18 = v15[1].__r_.__value_.__r.__words[2];
    }
    while (1)
    {
      uint64_t v19 = *(unsigned __int8 *)(v13 + 39);
      if ((v19 & 0x80u) == 0) {
        uint64_t v20 = *(unsigned __int8 *)(v13 + 39);
      }
      else {
        uint64_t v20 = *(void *)(v13 + 24);
      }
      if (v20 != v18) {
        goto LABEL_44;
      }
      uint64_t v21 = v17 >= 0 ? &v15[1].__r_.__value_.__r.__words[1] : (std::string::size_type *)*p_size;
      if ((v19 & 0x80) != 0) {
        break;
      }
      if (!*(unsigned char *)(v13 + 39)) {
        goto LABEL_46;
      }
      uint64_t v22 = 0;
      while (*(unsigned __int8 *)(v13 + v22 + 16) == *((unsigned __int8 *)v21 + v22))
      {
        if (v19 == ++v22) {
          goto LABEL_46;
        }
      }
LABEL_44:
      v13 += 216;
      if (v13 == v14)
      {
        char v12 = v15;
        goto LABEL_71;
      }
    }
    if (memcmp(*(const void **)(v13 + 16), v21, *(void *)(v13 + 24))) {
      goto LABEL_44;
    }
LABEL_46:
    std::string::size_type size = (std::string *)v15->__r_.__value_.__l.__size_;
    if (size)
    {
      do
      {
        int v24 = (std::string **)size;
        std::string::size_type size = (std::string *)size->__r_.__value_.__r.__words[0];
      }
      while (size);
    }
    else
    {
      do
      {
        int v24 = (std::string **)v15->__r_.__value_.__r.__words[2];
        BOOL v25 = *v24 == v15;
        __int16 v15 = (std::string *)v24;
      }
      while (!v25);
    }
    __int16 v15 = (std::string *)v24;
    uint64_t v13 = v37;
  }
  while (v24 != (std::string **)(a2 + 8));
LABEL_52:
  if (!*(unsigned char *)(v7 + 144))
  {
    uint64_t v26 = v36;
    goto LABEL_78;
  }
  uint64_t v26 = v36;
  if (*(void *)(v7 + 136) != *(void *)(a2 + 16))
  {
LABEL_76:
    uint64_t v7 = *(void *)(a1 + 160);
LABEL_78:
    sub_100634518(v7 + 120, a2);
    sub_1000C26BC(v26, 0);
    sub_100D25F88(a1, 0);
    return;
  }
  uint64_t v27 = *(unsigned __int8 **)(v7 + 120);
  uint64_t v28 = (unsigned __int8 *)(v7 + 128);
  while (v27 != v28)
  {
    if ((sub_1000609C0((uint64_t)&buf, v27 + 32, (unsigned __int8 *)&v12[1].__r_.__value_.__s.__data_[8]) & 1) == 0) {
      goto LABEL_76;
    }
    uint64_t v29 = (unsigned __int8 *)*((void *)v27 + 1);
    int v30 = v27;
    if (v29)
    {
      do
      {
        uint64_t v27 = v29;
        uint64_t v29 = *(unsigned __int8 **)v29;
      }
      while (v29);
    }
    else
    {
      do
      {
        uint64_t v27 = (unsigned __int8 *)*((void *)v30 + 2);
        BOOL v25 = *(void *)v27 == (void)v30;
        int v30 = v27;
      }
      while (!v25);
    }
    uint64_t v31 = (std::string *)v12->__r_.__value_.__l.__size_;
    if (v31)
    {
      do
      {
        int v32 = (std::string **)v31;
        uint64_t v31 = (std::string *)v31->__r_.__value_.__r.__words[0];
      }
      while (v31);
    }
    else
    {
      do
      {
        int v32 = (std::string **)v12->__r_.__value_.__r.__words[2];
        BOOL v25 = *v32 == v12;
        char v12 = (std::string *)v32;
      }
      while (!v25);
    }
    char v12 = (std::string *)v32;
  }
  uint64_t v35 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'activate': possible duplicate request", (uint8_t *)&buf, 2u);
  }
  sub_1000C26BC(v36, 0);
}

uint64_t sub_100D2B534(uint64_t a1)
{
  uint64_t __dst = 0;
  uint64_t v8 = 0;
  memset(&v6, 0, sizeof(v6));
  LODWORD(v2) = *(char *)(a1 + 23);
  if ((v2 & 0x80000000) == 0)
  {
    std::string v6 = *(std::string *)a1;
LABEL_4:
    int v3 = 0;
    unint64_t v4 = v2;
    goto LABEL_5;
  }
  sub_10004FC84(&v6, *(void **)a1, *(void *)(a1 + 8));
  LODWORD(v2) = *(char *)(a1 + 23);
  if ((v2 & 0x80000000) == 0) {
    goto LABEL_4;
  }
  unint64_t v4 = *(void *)(a1 + 8);
  int v3 = 1;
LABEL_5:
  if (v4 <= 0x13)
  {
    uint64_t v2 = v2;
    if (v3) {
      uint64_t v2 = *(void *)(a1 + 8);
    }
    std::string::append(&v6, 20 - v2, 102);
  }
  ctu::parse_hex();
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  return __dst;
}

void sub_100D2B670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void sub_100D2B698(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    std::string v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1000C6AC0((uint64_t)&v9, (uint64_t)(a1 + 7));
        int v10 = 0;
        int v7 = *a2;
        if (v7 == 2)
        {
          LOBYTE(v10) = 2;
          *(_WORD *)((char *)&v10 + 1) = *(_WORD *)(a2 + 1);
          HIBYTE(v10) = a2[3];
        }
        else if (v7 == 1)
        {
          LOBYTE(v10) = 1;
          BYTE1(v10) = a2[1];
        }
        uint64_t v8 = *(std::__shared_weak_count **)(v5 + 16);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D2B854(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100D2B880(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1000C6AC0(a1 + 56, a2 + 56);
}

void sub_100D2B8C4(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2B8DC(uint64_t a1)
{
  sub_1000C6B58((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100D2B928(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    std::string v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1000C6AC0((uint64_t)&v8, (uint64_t)(a1 + 7));
        sub_1007A816C((uint64_t)v9, a2);
        int v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D2BADC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D2BB18(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        sub_1000C6AC0((uint64_t)&v6, (uint64_t)(a1 + 7));
        uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100D2BCE0(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D2BD1C(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1007A816C((uint64_t)v8, a2);
        sub_1000C6AC0((uint64_t)&v9, (uint64_t)(a1 + 7));
        int v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D2BED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D2BF50(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = *(void *)a3;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Set associated IMEI for profile %s : %s", buf, 0x16u);
  }
  uint64_t v11 = (std::__shared_weak_count *)a1[2];
  if (!v11 || (uint64_t v12 = a1[1], (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v14 = v13;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  memset(buf, 0, sizeof(buf));
  if (sub_1007542B8(a2, a3, (unint64_t *)buf))
  {
    std::string::size_type v18 = 0;
    uint64_t v19 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, *(const void **)buf, *(uint64_t *)&buf[8], *(void *)&buf[8] - *(void *)buf);
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 1174405120;
    int v24 = sub_100D2C250;
    BOOL v25 = &unk_101A52408;
    uint64_t v26 = a1;
    uint64_t v27 = v12;
    uint64_t v28 = v14;
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_1000C7494((uint64_t)v29, a4);
    VinylCommandDriver::tapeSetProprietaryData();
    if (__p)
    {
      std::string::size_type v18 = __p;
      operator delete(__p);
    }
    sub_1000C752C(v29);
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  else
  {
    __int16 v15 = a1[5];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "encodeTapeSetProprietaryDataReq failed", v21, 2u);
    }
    __int16 v20 = 770;
    uint64_t v16 = *(void *)(a4 + 24);
    if (!v16) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, __int16 *))(*(void *)v16 + 48))(v16, &v20);
    LOBYTE(v20) = 0;
  }
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  std::__shared_weak_count::__release_weak(v14);
}

void sub_100D2C1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  sub_1000C752C(v23);
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  if (__p) {
    operator delete(__p);
  }
  uint64_t v26 = *(void **)(v24 - 80);
  if (v26)
  {
    *(void *)(v24 - 72) = v26;
    operator delete(v26);
  }
  std::__shared_weak_count::__release_weak(v22);
  _Unwind_Resume(a1);
}

void sub_100D2C250(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      if (a1[5])
      {
        sub_1007A816C((uint64_t)v8, a2);
        sub_1000C7494((uint64_t)&v9, (uint64_t)(a1 + 7));
        int v7 = *(std::__shared_weak_count **)(v5 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D2C408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100D2C484(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1000C7494(a1 + 56, a2 + 56);
}

void sub_100D2C4C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2C4E0(uint64_t a1)
{
  sub_1000C752C((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100D2C52C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (*(void *)(a1 + 48))
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 1174405120;
        void v16[2] = sub_100D2C6F4;
        void v16[3] = &unk_101A52440;
        v16[5] = v5;
        int v17 = 0;
        int v8 = *a2;
        if (v8 == 2)
        {
          LOBYTE(v17) = 2;
          *(_WORD *)((char *)&v17 + 1) = *(_WORD *)(a2 + 1);
          HIBYTE(v17) = a2[3];
        }
        else if (v8 == 1)
        {
          LOBYTE(v17) = 1;
          BYTE1(v17) = a2[1];
        }
        long long v18 = *(_OWORD *)(a1 + 64);
        v16[4] = *(void *)(a1 + 32);
        uint64_t v9 = (std::__shared_weak_count *)v5[2];
        if (!v9 || (v10 = v5[1], (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v12 = v11;
        uint64_t v13 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v10;
        __int16 v15 = v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v16;
        dispatch_async(v13, block);
        if (v15) {
          sub_10004D2C8(v15);
        }
        sub_10004D2C8(v12);
        LOBYTE(v17) = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D2C6E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100D2C6F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 == 2)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 49) - 1;
    if (v8 > 0xA) {
      int v9 = 0;
    }
    else {
      int v9 = byte_10156923F[(char)v8];
    }
    int v10 = *(_DWORD *)(v2 + 80);
    *(void *)__n128 __p = _NSConcreteStackBlock;
    *(void *)&__p[8] = 0x40000000;
    *(void *)&__p[16] = sub_1004F0E60;
    int v32 = &unk_1019DB1D8;
    int v33 = v10;
    LODWORD(v34) = 1;
    LOBYTE(v35) = 0;
    HIDWORD(v34) = v9;
    sub_1004F0C80((wis::MetricFactory *)0x8010C);
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sVinylProfileIdAsString();
      if (v30 >= 0) {
        uint64_t v12 = buf;
      }
      else {
        uint64_t v12 = *(unsigned char **)buf;
      }
      uint64_t v13 = asString();
      int v14 = *(unsigned __int8 *)(a1 + 48);
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v26 = &ctu::ResultIsNotError::~ResultIsNotError;
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        else
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v26 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        }
        __cxa_throw(exception, v27, (void (*)(void *))v26);
      }
      uint64_t v15 = v13;
      uint64_t v16 = asString();
      *(_DWORD *)__n128 __p = 136315650;
      *(void *)&__p[4] = v12;
      *(_WORD *)&unsigned char __p[12] = 2080;
      *(void *)&__p[14] = v15;
      *(_WORD *)&__p[22] = 2080;
      int v32 = (void *)v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Deletion of %s failed with error %s (driver error %s)", __p, 0x20u);
      if (v30 < 0) {
        operator delete(*(void **)buf);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    int v17 = *(unsigned __int8 *)(a1 + 48);
    if (v17 != 2)
    {
      if (v17 == 1)
      {
        uint64_t v22 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v22);
      }
      uint64_t v28 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v28);
    }
    if (*(unsigned char *)(a1 + 49) == 2)
    {
      int v18 = *(_DWORD *)(v2 + 80);
      int v19 = *(unsigned __int8 *)(a1 + 50);
      int v20 = *(unsigned __int8 *)(a1 + 51);
      *(void *)__n128 __p = _NSConcreteStackBlock;
      *(void *)&__p[8] = 0x40000000;
      *(void *)&__p[16] = sub_1004F09E8;
      int v32 = &unk_1019DB198;
      int v33 = v18;
      LODWORD(v34) = 22;
      HIDWORD(v34) = v19;
      int v35 = v20;
      sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
  else
  {
    if (v3 != 1)
    {
      uint64_t v23 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
    }
    int v4 = *(_DWORD *)(v2 + 80);
    *(void *)__n128 __p = _NSConcreteStackBlock;
    *(void *)&__p[8] = 0x40000000;
    *(void *)&__p[16] = sub_1004F0E60;
    int v32 = &unk_1019DB1D8;
    int v33 = v4;
    LOBYTE(v35) = 0;
    uint64_t v34 = 1;
    sub_1004F0C80((wis::MetricFactory *)0x8010C);
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      sVinylProfileIdAsString();
      uint64_t v6 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Deletion of %s succeeded", buf, 0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    int v7 = *(unsigned __int8 *)(a1 + 48);
    if (v7 != 1)
    {
      if (v7 == 2)
      {
        uint64_t v21 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v21);
      }
      uint64_t v24 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v24);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  sub_100D25690((void *)v2);
}

void sub_100D2CBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  __cxa_free_exception(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D2CC48(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = 0;
  int v2 = *(unsigned __int8 *)(a2 + 48);
  if (v2 == 2)
  {
    *(unsigned char *)(result + 48) = 2;
    __int16 v3 = *(_WORD *)(a2 + 49);
    *(unsigned char *)(result + 51) = *(unsigned char *)(a2 + 51);
    *(_WORD *)(result + 49) = v3;
  }
  else if (v2 == 1)
  {
    *(unsigned char *)(result + 48) = 1;
    *(unsigned char *)(result + 49) = *(unsigned char *)(a2 + 49);
  }
  return result;
}

uint64_t sub_100D2CC88(uint64_t result)
{
  *(unsigned char *)(result + 48) = 0;
  return result;
}

uint64_t sub_100D2CC90(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D2CCAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D2CCBC(uint64_t a1, const void *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64)))
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I queue delete as bb may need to be booted", v10, 2u);
    }
    uint64_t v5 = operator new(0x20uLL);
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = 0;
    uint64_t v6 = (const void **)(v5 + 3);
    *uint64_t v5 = off_101A52CF8;
    if (a2)
    {
      int v7 = _Block_copy(a2);
      unsigned int v8 = *v6;
      *uint64_t v6 = v7;
      if (v8) {
        _Block_release(v8);
      }
    }
    int v9 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = v6;
    *(void *)(a1 + 184) = v5;
    if (v9) {
      sub_10004D2C8(v9);
    }
    sub_100D25F88(a1, 0);
  }
  else
  {
    sub_100D2CDFC(a1);
  }
}

void sub_100D2CDFC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Deleting User Profiles", buf, 2u);
  }
  if (*(_DWORD *)(a1 + 84) == 2)
  {
    sub_100D28C48(a1);
  }
  else
  {
    __int16 v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3 || (int v4 = std::__shared_weak_count::lock(v3)) == 0) {
      sub_100088B9C();
    }
    uint64_t v5 = v4;
    p_shared_weak_owners = &v4->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    VinylCommandDriver::fetchProfiles();
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_100D2CF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void sub_100D2CF54(void *a1, unsigned __int8 *a2)
{
  __int16 v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    uint64_t v5 = (void *)a1[5];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[6])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        v13[2] = sub_100D2D0E0;
        uint64_t v13[3] = &unk_101A524E8;
        void v13[5] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        void v13[4] = a1[4];
        unsigned int v8 = (std::__shared_weak_count *)v5[2];
        if (!v8 || (v9 = v5[1], (int v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v11 = v10;
        uint64_t v12 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v9;
        int v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D2D0C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D2D0E0(uint64_t a1)
{
  __int16 v3 = (unsigned __int8 *)(a1 + 48);
  int v2 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 40);
  if (v2 != 2)
  {
    if (v2 == 1)
    {
      uint64_t v5 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 64) - *(void *)(a1 + 56);
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Force listing profiles succeeded: %lu bytes", buf, 0xCu);
        int v7 = *(unsigned __int8 *)(a1 + 48);
        if (v7 != 1)
        {
          if (v7 == 2)
          {
            exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            long long v43 = &ctu::ResultIsError::~ResultIsError;
            ctu::ResultIsError::ResultIsError(exception);
          }
          else
          {
            exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            long long v43 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          }
          __cxa_throw(exception, v44, (void (*)(void *))v43);
        }
      }
      unsigned int v8 = *(capabilities::ct **)(v4 + 344);
      if (v8)
      {
        sub_100EE8BC8((uint64_t)v8, "CardProfiles");
        int v9 = *v3;
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        uint64_t v62 = 0;
        if (v9 != 1)
        {
          if (v9 == 2)
          {
            int v10 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            uint64_t v11 = &ctu::ResultIsError::~ResultIsError;
            ctu::ResultIsError::ResultIsError(v10);
          }
          else
          {
            int v10 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            uint64_t v11 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
            ctu::ResultIsEmptyError::ResultIsEmptyError(v10);
          }
          __cxa_throw(v10, v12, (void (*)(void *))v11);
        }
      }
      else
      {
        *(void *)(v4 + 344) = 0;
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        uint64_t v62 = 0;
      }
      char v20 = capabilities::ct::getProvisioningProfileSupport(v8) == 0;
      sub_1003EE3F0((void *)(a1 + 56), v20, &v60);
      uint64_t v21 = v60;
      if (v61 == v60)
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        *(void *)std::string buf = &v60;
        sub_1000C57C8((void ***)buf);
      }
      else
      {
        uint64_t v49 = v3;
        uint64_t v50 = a1;
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        unint64_t v25 = 0;
        do
        {
          unint64_t v26 = v21 + 216 * v25;
          if (!*(unsigned char *)(v26 + 88))
          {
            if ((unint64_t)v23 >= v24)
            {
              uint64_t v27 = v4;
              uint64_t v28 = (v23 - v22) >> 4;
              unint64_t v29 = v28 + 1;
              if ((unint64_t)(v28 + 1) >> 60) {
                sub_10006A748();
              }
              if ((uint64_t)(v24 - (void)v22) >> 3 > v29) {
                unint64_t v29 = (uint64_t)(v24 - (void)v22) >> 3;
              }
              if (v24 - (unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v30 = v29;
              }
              if (v30) {
                unint64_t v30 = (unint64_t)sub_1009C886C(v30);
              }
              else {
                uint64_t v31 = 0;
              }
              int v32 = (_OWORD *)(v30 + 16 * v28);
              *int v32 = *(_OWORD *)v26;
              if (v23 == v22)
              {
                uint64_t v34 = (char *)(v30 + 16 * v28);
                uint64_t v4 = v27;
              }
              else
              {
                unint64_t v33 = v30 + 16 * v28;
                uint64_t v4 = v27;
                do
                {
                  uint64_t v34 = (char *)(v33 - 16);
                  *(_OWORD *)(v33 - 16) = *((_OWORD *)v23 - 1);
                  v23 -= 16;
                  v33 -= 16;
                }
                while (v23 != v22);
              }
              unint64_t v24 = v30 + 16 * v31;
              uint64_t v23 = (char *)(v32 + 1);
              if (v22) {
                operator delete(v22);
              }
              uint64_t v22 = v34;
            }
            else
            {
              *(_OWORD *)uint64_t v23 = *(_OWORD *)v26;
              v23 += 16;
            }
            uint64_t v21 = v60;
            if (*(unsigned char *)(v60 + 216 * v25 + 89))
            {
              uint64_t v35 = *(void *)(v4 + 160);
              if (v35)
              {
                *(unsigned char *)(v35 + 155) = 1;
                uint64_t v36 = v35 + 120;
                if (*(unsigned char *)(v35 + 144))
                {
                  long long v38 = *(char **)(v35 + 128);
                  uint64_t v37 = (void *)(v35 + 128);
                  sub_10005CD2C(v36, v38);
                  *(v37 - 1) = v37;
                  void *v37 = 0;
                  v37[1] = 0;
                }
                else
                {
                  buf[0] = 0;
                  LOBYTE(v64) = 0;
                  sub_100B61500(v36, (uint64_t)buf);
                  if ((_BYTE)v64) {
                    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
                  }
                }
              }
              uint64_t v21 = v60;
            }
          }
          ++v25;
        }
        while (v25 < 0x84BDA12F684BDA13 * ((v61 - v21) >> 3));
        uint64_t v39 = v23 - v22;
        if (v23 == v22)
        {
          (*(void (**)(void))(*(void *)(v50 + 32) + 16))(*(void *)(v50 + 32));
        }
        else
        {
          unint64_t v40 = v39 >> 4;
          __int16 v58 = 0;
          uint64_t v59 = 0;
          __n128 __p = 0;
          sub_100D3904C(&__p, v22, (uint64_t)v23, v39 >> 4);
          uint64_t v51 = 0;
          long long v52 = 0;
          uint64_t v53 = 0;
          sub_100D3904C(&v51, v22, (uint64_t)v23, v40);
          sub_1007A816C((uint64_t)v54, v49);
          VinylCommandDriver::deleteProfiles();
          if (__p)
          {
            __int16 v58 = __p;
            operator delete(__p);
          }
          if (v54[0] == 1 && v55)
          {
            __int16 v56 = v55;
            operator delete(v55);
          }
          v54[0] = 0;
          if (v51)
          {
            long long v52 = v51;
            operator delete(v51);
          }
        }
        *(void *)std::string buf = &v60;
        sub_1000C57C8((void ***)buf);
        if (v22) {
          operator delete(v22);
        }
      }
      return;
    }
    goto LABEL_72;
  }
  uint64_t v13 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    int v15 = *v3;
    if (v15 != 2)
    {
      if (v15 == 1)
      {
        int v45 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v45);
        __int16 v47 = &ctu::ResultIsNotError::~ResultIsNotError;
        goto LABEL_73;
      }
LABEL_72:
      int v45 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v45);
      __int16 v47 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_73:
      __cxa_throw(v45, v46, (void (*)(void *))v47);
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I List UICC profiles failed with error %s (driver error %s)", buf, 0x16u);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  int v16 = *(unsigned __int8 *)(a1 + 48);
  if (v16 != 2)
  {
    if (v16 == 1)
    {
      long long v41 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(v41);
    }
    long long v48 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(v48);
  }
  if (*(unsigned char *)(a1 + 56) == 2)
  {
    int v17 = *(_DWORD *)(v4 + 80);
    int v18 = *(unsigned __int8 *)(a1 + 57);
    int v19 = *(unsigned __int8 *)(a1 + 58);
    *(void *)std::string buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    uint64_t v64 = &unk_1019DB198;
    int v65 = v17;
    int v66 = 5;
    int v67 = v18;
    int v68 = v19;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
}

void sub_100D2D830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  *(void *)(v34 + 24) = &a33;
  sub_1000C57C8((void ***)(v35 - 160));
  if (v33) {
    operator delete(v33);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D2D92C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 != 2)
  {
    if (v5 == 1)
    {
      int v6 = *(_DWORD *)(v4 + 80);
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_1004F0E60;
      unint64_t v29 = &unk_1019DB1D8;
      int v30 = v6;
      LOBYTE(v32) = 1;
      uint64_t v31 = 1;
      sub_1004F0C80((wis::MetricFactory *)0x8010C);
      int v7 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 4;
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Deletion of %lu profile(s) succeeded", buf, 0xCu);
      }
      int v9 = *a2;
      if (v9 != 1)
      {
        if (v9 == 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsError::ResultIsError(exception);
        }
        unint64_t v26 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v26);
      }
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    goto LABEL_26;
  }
  unsigned int v11 = a2[1] - 1;
  if (v11 > 0xA) {
    int v12 = 0;
  }
  else {
    int v12 = byte_10156923F[(char)v11];
  }
  int v13 = *(_DWORD *)(v4 + 80);
  *(void *)std::string buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1004F0E60;
  unint64_t v29 = &unk_1019DB1D8;
  int v30 = v13;
  LODWORD(v31) = 1;
  LOBYTE(v32) = 1;
  HIDWORD(v31) = v12;
  sub_1004F0C80((wis::MetricFactory *)0x8010C);
  uint64_t v14 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asString();
    int v16 = *a2;
    if (v16 != 2)
    {
      if (v16 == 1)
      {
        uint64_t v23 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v23);
        unint64_t v25 = &ctu::ResultIsNotError::~ResultIsNotError;
        goto LABEL_27;
      }
LABEL_26:
      uint64_t v23 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
      unint64_t v25 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_27:
      __cxa_throw(v23, v24, (void (*)(void *))v25);
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Delete User profiles failed with error %s (driver error %s)", buf, 0x16u);
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  int v17 = *(unsigned __int8 *)(a1 + 72);
  if (v17 != 2)
  {
    if (v17 == 1)
    {
      uint64_t v22 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(v22);
    }
    uint64_t v27 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(v27);
  }
  if (*(unsigned char *)(a1 + 80) == 2)
  {
    int v18 = *(_DWORD *)(v4 + 80);
    int v19 = *(unsigned __int8 *)(a1 + 81);
    int v20 = *(unsigned __int8 *)(a1 + 82);
    *(void *)std::string buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    unint64_t v29 = &unk_1019DB198;
    int v30 = v18;
    LODWORD(v31) = 22;
    HIDWORD(v31) = v19;
    int v32 = v20;
    return sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
  return result;
}

void sub_100D2DDA0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D2DDD4(void *a1, uint64_t a2)
{
  a1[6] = 0;
  a1[7] = 0;
  __int16 v3 = a1 + 6;
  a1[8] = 0;
  sub_100D3904C(a1 + 6, *(const void **)(a2 + 48), *(void *)(a2 + 56), (uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 4);
  return sub_1007A816C((uint64_t)(v3 + 3), (unsigned __int8 *)(a2 + 72));
}

void sub_100D2DE30(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 56) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2DE4C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72) == 1)
  {
    int v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(void *)(a1 + 88) = v2;
      operator delete(v2);
    }
  }
  *(unsigned char *)(a1 + 72) = 0;
  __int16 v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 56) = v3;
    operator delete(v3);
  }
}

uint64_t sub_100D2DEB4(uint64_t a1, uint64_t a2)
{
  return sub_1007A816C(a1 + 48, (unsigned __int8 *)(a2 + 48));
}

void sub_100D2DEC0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48) == 1)
  {
    int v2 = *(void **)(a1 + 56);
    if (v2)
    {
      *(void *)(a1 + 64) = v2;
      operator delete(v2);
    }
  }
  *(unsigned char *)(a1 + 48) = 0;
}

uint64_t sub_100D2DF00(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Cancel Previous Install", buf, 2u);
  }
  uint64_t v5 = *(void *)(a1 + 160);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 160)) != 0 && (*(unsigned int (**)(uint64_t))(*(void *)v6 + 72))(v6))
  {
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cancel Previous Install as Failure", v10, 2u);
    }
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 160) + 160) + 32))(*(void *)(*(void *)(a1 + 160) + 160));
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v8);
}

void sub_100D2E02C(uint64_t a1, uint64_t a2, void (**a3)(void, void))
{
  if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'generate sign id' as vinyl availability is %s", (uint8_t *)&buf, 0xCu);
    }
    v127[0] = 2;
    LOBYTE(v128) = 2;
    ((void (**)(void, char *))a3)[2](a3, v127);
    if (v127[0] == 1)
    {
      uint64_t v6 = v128;
      if (v128)
      {
        long long v129 = v128;
LABEL_19:
        operator delete(v6);
        return;
      }
    }
    return;
  }
  if ((*(_DWORD *)(a1 + 84) - 1) >= 2)
  {
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'generate sign id' incompatible SIM card", (uint8_t *)&buf, 2u);
    }
    v124[0] = 2;
    LOBYTE(__p) = 11;
    ((void (**)(void, char *))a3)[2](a3, v124);
    if (v124[0] == 1)
    {
      uint64_t v6 = __p;
      if (__p)
      {
        long long v126 = __p;
        goto LABEL_19;
      }
    }
    return;
  }
  if (!sub_100D25BFC(a1))
  {
    int v10 = *(const void **)a2;
    uint64_t v11 = *(void *)(a2 + 8);
    int v12 = operator new(0x38uLL);
    v12[1] = 0;
    v12[2] = 0;
    *int v12 = off_101A52D48;
    long long buf = 0uLL;
    uint64_t v131 = 0;
    sub_10005C928(&buf, v10, v11, v11 - (void)v10);
    void v12[3] = 0;
    void v12[4] = 0;
    v12[5] = 0;
    sub_10005C928(v12 + 3, (const void *)buf, *((uint64_t *)&buf + 1), *((void *)&buf + 1) - buf);
    if (a3) {
      int v13 = _Block_copy(a3);
    }
    else {
      int v13 = 0;
    }
    void v12[6] = v13;
    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    uint64_t v14 = *(char **)(a1 + 208);
    uint64_t v15 = *(char **)(a1 + 200);
    uint64_t v16 = v14 - v15;
    if (v14 == v15) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = 32 * (v14 - v15) - 1;
    }
    unint64_t v19 = *(void *)(a1 + 224);
    uint64_t v18 = *(void *)(a1 + 232);
    unint64_t v20 = v18 + v19;
    if (v17 != v18 + v19) {
      goto LABEL_61;
    }
    if (v19 < 0x100)
    {
      uint64_t v35 = v16 >> 3;
      uint64_t v36 = *(char **)(a1 + 216);
      uint64_t v37 = *(char **)(a1 + 192);
      if (v16 >> 3 >= (unint64_t)((v36 - v37) >> 3))
      {
        if (v36 == v37) {
          unint64_t v40 = 1;
        }
        else {
          unint64_t v40 = (v36 - v37) >> 2;
        }
        long long v41 = (char *)sub_100048350(v40);
        uint64_t v43 = v42;
        uint64_t v44 = operator new(0x1000uLL);
        int v45 = &v41[8 * v35];
        uint64_t v46 = v43;
        __int16 v47 = &v41[8 * v43];
        if (v35 == v46)
        {
          uint64_t v48 = 8 * v35;
          if (v16 < 1)
          {
            uint64_t v87 = v44;
            uint64_t v88 = v48 >> 2;
            if (v14 == v15) {
              unint64_t v89 = 1;
            }
            else {
              unint64_t v89 = v88;
            }
            char v90 = (char *)sub_100048350(v89);
            int v45 = &v90[8 * (v89 >> 2)];
            __int16 v47 = &v90[8 * v91];
            if (v41) {
              operator delete(v41);
            }
            long long v41 = v90;
            uint64_t v44 = v87;
          }
          else
          {
            uint64_t v49 = v48 >> 3;
            if (v49 >= -1) {
              unint64_t v50 = v49 + 1;
            }
            else {
              unint64_t v50 = v49 + 2;
            }
            v45 -= 8 * (v50 >> 1);
          }
        }
        *(void *)int v45 = v44;
        unint64_t v92 = v45 + 8;
        for (uint64_t i = *(void *)(a1 + 208); i != *(void *)(a1 + 200); i -= 8)
        {
          if (v45 == v41)
          {
            if (v92 >= v47)
            {
              if (v47 == v41) {
                unint64_t v98 = 1;
              }
              else {
                unint64_t v98 = (v47 - v41) >> 2;
              }
              long long v99 = (char *)sub_100048350(v98);
              uint64_t v101 = v99;
              int v45 = &v99[(2 * v98 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v102 = v92 - v41;
              BOOL v51 = v92 == v41;
              unint64_t v92 = v45;
              if (!v51)
              {
                unint64_t v92 = &v45[v102 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v103 = 8 * (v102 >> 3);
                long long v104 = v45;
                char v105 = (uint64_t *)v41;
                do
                {
                  uint64_t v106 = *v105++;
                  *(void *)long long v104 = v106;
                  v104 += 8;
                  v103 -= 8;
                }
                while (v103);
              }
              __int16 v47 = &v99[8 * v100];
              if (v41) {
                operator delete(v41);
              }
              long long v41 = v101;
            }
            else
            {
              uint64_t v94 = (v47 - v92) >> 3;
              if (v94 >= -1) {
                uint64_t v95 = v94 + 1;
              }
              else {
                uint64_t v95 = v94 + 2;
              }
              uint64_t v96 = v95 >> 1;
              int v45 = &v41[8 * (v95 >> 1)];
              uint64_t v97 = v41;
              if (v92 != v41)
              {
                memmove(v45, v41, v92 - v41);
                uint64_t v97 = v92;
              }
              unint64_t v92 = &v97[8 * v96];
            }
          }
          uint64_t v107 = *(void *)(i - 8);
          *((void *)v45 - 1) = v107;
          v45 -= 8;
        }
        long long v108 = *(void **)(a1 + 192);
        *(void *)(a1 + 192) = v41;
        *(void *)(a1 + 200) = v45;
        *(void *)(a1 + 208) = v92;
        *(void *)(a1 + 216) = v47;
        if (v108) {
          operator delete(v108);
        }
        goto LABEL_60;
      }
      long long v38 = operator new(0x1000uLL);
      uint64_t v39 = v38;
      if (v36 == v14)
      {
        if (v15 == v37)
        {
          if (v14 == v15) {
            unint64_t v65 = 1;
          }
          else {
            unint64_t v65 = (v36 - v15) >> 2;
          }
          int v66 = (char *)sub_100048350(v65);
          uint64_t v15 = &v66[(2 * v65 + 6) & 0xFFFFFFFFFFFFFFF8];
          int v68 = *(uint64_t **)(a1 + 200);
          uint64_t v69 = v15;
          uint64_t v70 = *(void *)(a1 + 208) - (void)v68;
          if (v70)
          {
            uint64_t v69 = &v15[v70 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v71 = 8 * (v70 >> 3);
            char v72 = &v66[(2 * v65 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v73 = *v68++;
              *(void *)char v72 = v73;
              v72 += 8;
              v71 -= 8;
            }
            while (v71);
          }
          unint64_t v74 = *(void **)(a1 + 192);
          *(void *)(a1 + 192) = v66;
          *(void *)(a1 + 200) = v15;
          *(void *)(a1 + 208) = v69;
          *(void *)(a1 + 216) = &v66[8 * v67];
          if (v74)
          {
            operator delete(v74);
            uint64_t v15 = *(char **)(a1 + 200);
          }
        }
        *((void *)v15 - 1) = v39;
        unint64_t v75 = *(char **)(a1 + 200);
        uint64_t v76 = *(char **)(a1 + 208);
        *(void *)(a1 + 200) = v75 - 8;
        uint64_t v77 = *((void *)v75 - 1);
        *(void *)(a1 + 200) = v75;
        if (v76 == *(char **)(a1 + 216))
        {
          unint64_t v78 = *(void *)(a1 + 192);
          uint64_t v79 = (uint64_t)&v75[-v78];
          if ((unint64_t)v75 <= v78)
          {
            uint64_t v109 = (uint64_t)&v76[-v78];
            BOOL v51 = v109 == 0;
            uint64_t v110 = v109 >> 2;
            if (v51) {
              unint64_t v111 = 1;
            }
            else {
              unint64_t v111 = v110;
            }
            long long v112 = (char *)sub_100048350(v111);
            long long v114 = &v112[8 * (v111 >> 2)];
            long long v115 = *(uint64_t **)(a1 + 200);
            uint64_t v76 = v114;
            uint64_t v116 = *(void *)(a1 + 208) - (void)v115;
            if (v116)
            {
              uint64_t v76 = &v114[v116 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v117 = 8 * (v116 >> 3);
              long long v118 = &v112[8 * (v111 >> 2)];
              do
              {
                uint64_t v119 = *v115++;
                *(void *)long long v118 = v119;
                v118 += 8;
                v117 -= 8;
              }
              while (v117);
            }
            char v120 = *(void **)(a1 + 192);
            *(void *)(a1 + 192) = v112;
            *(void *)(a1 + 200) = v114;
            *(void *)(a1 + 208) = v76;
            *(void *)(a1 + 216) = &v112[8 * v113];
            if (v120)
            {
              operator delete(v120);
              uint64_t v76 = *(char **)(a1 + 208);
            }
          }
          else
          {
            uint64_t v80 = v79 >> 3;
            BOOL v27 = v79 >> 3 < -1;
            uint64_t v81 = (v79 >> 3) + 2;
            if (v27) {
              uint64_t v82 = v81;
            }
            else {
              uint64_t v82 = v80 + 1;
            }
            uint64_t v83 = -(v82 >> 1);
            uint64_t v84 = v82 >> 1;
            uint64_t v85 = &v75[-8 * v84];
            int64_t v86 = v76 - v75;
            if (v76 != v75)
            {
              memmove(&v75[-8 * v84], v75, v76 - v75);
              unint64_t v75 = *(char **)(a1 + 200);
            }
            uint64_t v76 = &v85[v86];
            *(void *)(a1 + 200) = &v75[8 * v83];
            *(void *)(a1 + 208) = &v85[v86];
          }
        }
        *(void *)uint64_t v76 = v77;
      }
      else
      {
        *(void *)uint64_t v14 = v38;
      }
    }
    else
    {
      *(void *)(a1 + 224) = v19 - 256;
      uint64_t v23 = *(void *)v15;
      uint64_t v21 = v15 + 8;
      uint64_t v22 = v23;
      *(void *)(a1 + 200) = v21;
      if (v14 == *(char **)(a1 + 216))
      {
        unint64_t v24 = *(void *)(a1 + 192);
        uint64_t v25 = (uint64_t)&v21[-v24];
        if ((unint64_t)v21 <= v24)
        {
          uint64_t v52 = (uint64_t)&v14[-v24];
          BOOL v51 = v52 == 0;
          uint64_t v53 = v52 >> 2;
          if (v51) {
            unint64_t v54 = 1;
          }
          else {
            unint64_t v54 = v53;
          }
          long long v55 = (char *)sub_100048350(v54);
          __int16 v57 = &v55[8 * (v54 >> 2)];
          __int16 v58 = *(uint64_t **)(a1 + 200);
          uint64_t v14 = v57;
          uint64_t v59 = *(void *)(a1 + 208) - (void)v58;
          if (v59)
          {
            uint64_t v14 = &v57[v59 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v60 = 8 * (v59 >> 3);
            uint64_t v61 = &v55[8 * (v54 >> 2)];
            do
            {
              uint64_t v62 = *v58++;
              *(void *)uint64_t v61 = v62;
              v61 += 8;
              v60 -= 8;
            }
            while (v60);
          }
          uint64_t v63 = *(void **)(a1 + 192);
          *(void *)(a1 + 192) = v55;
          *(void *)(a1 + 200) = v57;
          *(void *)(a1 + 208) = v14;
          *(void *)(a1 + 216) = &v55[8 * v56];
          if (v63)
          {
            operator delete(v63);
            uint64_t v14 = *(char **)(a1 + 208);
          }
        }
        else
        {
          uint64_t v26 = v25 >> 3;
          BOOL v27 = v25 >> 3 < -1;
          uint64_t v28 = (v25 >> 3) + 2;
          if (v27) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v26 + 1;
          }
          uint64_t v30 = -(v29 >> 1);
          uint64_t v31 = v29 >> 1;
          int v32 = &v21[-8 * v31];
          int64_t v33 = v14 - v21;
          if (v14 != v21)
          {
            memmove(&v21[-8 * v31], v21, v14 - v21);
            uint64_t v14 = *(char **)(a1 + 200);
          }
          uint64_t v34 = &v14[8 * v30];
          uint64_t v14 = &v32[v33];
          *(void *)(a1 + 200) = v34;
          *(void *)(a1 + 208) = &v32[v33];
        }
      }
      *(void *)uint64_t v14 = v22;
    }
    *(void *)(a1 + 208) += 8;
LABEL_60:
    uint64_t v15 = *(char **)(a1 + 200);
    uint64_t v18 = *(void *)(a1 + 232);
    unint64_t v20 = v18 + *(void *)(a1 + 224);
LABEL_61:
    uint64_t v64 = (void *)(*(void *)&v15[(v20 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v20);
    *uint64_t v64 = v12 + 3;
    v64[1] = v12;
    *(void *)(a1 + 232) = v18 + 1;
    sub_100D25F88(a1, 0);
    return;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'generate sign id' as operations are in 'busy' state", (uint8_t *)&buf, 2u);
  }
  v121[0] = 2;
  LOBYTE(v122) = 5;
  ((void (**)(void, char *))a3)[2](a3, v121);
  if (v121[0] == 1)
  {
    uint64_t v6 = v122;
    if (v122)
    {
      long long v123 = v122;
      goto LABEL_19;
    }
  }
}

void sub_100D2E784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  operator delete(v24);
  if (v23) {
    operator delete(v23);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_100D2E864(uint64_t a1, unsigned __int8 *a2)
{
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1007A816C((uint64_t)v5, a2);
  __int16 v3 = *(std::__shared_weak_count **)(v4 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D2E9DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D2E9F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D2EA14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100D2EA24(uint64_t a1, char a2)
{
  v2[0] = 2;
  LOBYTE(__p) = a2;
  (*(void (**)(uint64_t, char *))(a1 + 16))(a1, v2);
  if (v2[0] == 1)
  {
    if (__p)
    {
      long long v4 = __p;
      operator delete(__p);
    }
  }
}

void sub_100D2EA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *__p, uint64_t a11)
{
  if (a9 == 1)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2EAA8(uint64_t a1, unsigned __int8 *a2)
{
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1007A816C((uint64_t)v5, a2);
  __int16 v3 = *(std::__shared_weak_count **)(v4 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D2EC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D2EC3C(uint64_t a1, char **a2, char **a3, char **a4, uint64_t a5)
{
  if (capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)a1))
  {
    if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
    {
      int v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v164 = asString();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'secure auth' as vinyl availability is %s", buf, 0xCu);
      }
      v151[0] = 0;
      char v153 = 0;
      v149 = 0;
      uint64_t v150 = 0;
      __n128 __p = 0;
      sub_10048548C(a5, (uint64_t)v151, (uint64_t)&__p, 258);
      if (__p)
      {
        v149 = __p;
        operator delete(__p);
      }
      if (v153)
      {
        uint64_t v11 = v152;
        int v12 = v151;
LABEL_15:
        sub_10026CF54((uint64_t)v12, v11);
        return;
      }
      return;
    }
    if (*(_DWORD *)(a1 + 84) != 2)
    {
      uint64_t v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'secure auth' incompatible SIM card", buf, 2u);
      }
      v145[0] = 0;
      char v147 = 0;
      v143 = 0;
      uint64_t v144 = 0;
      v142 = 0;
      sub_10048548C(a5, (uint64_t)v145, (uint64_t)&v142, 267);
      if (v142)
      {
        v143 = v142;
        operator delete(v142);
      }
      if (v147)
      {
        uint64_t v11 = v146;
        int v12 = v145;
        goto LABEL_15;
      }
      return;
    }
    if (sub_100D25BFC(a1))
    {
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'secure auth' as operations are in 'busy' state", buf, 2u);
      }
      v139[0] = 0;
      char v141 = 0;
      v137 = 0;
      uint64_t v138 = 0;
      v136 = 0;
      sub_10048548C(a5, (uint64_t)v139, (uint64_t)&v136, 261);
      if (v136)
      {
        v137 = v136;
        operator delete(v136);
      }
      if (v141)
      {
        uint64_t v11 = v140;
        int v12 = v139;
        goto LABEL_15;
      }
      return;
    }
    v133 = 0;
    v134 = 0;
    uint64_t v135 = 0;
    if ((sub_1003F0AC0(a2, a3, a4, &v133) & 1) == 0)
    {
      long long v41 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Ignoring 'secure auth' encoding payload failed", buf, 2u);
      }
      v130[0] = 0;
      char v132 = 0;
      long long v128 = 0;
      uint64_t v129 = 0;
      long long v127 = 0;
      sub_10048548C(a5, (uint64_t)v130, (uint64_t)&v127, 257);
      if (v127)
      {
        long long v128 = v127;
        operator delete(v127);
      }
      if (v132) {
        sub_10026CF54((uint64_t)v130, v131);
      }
      goto LABEL_77;
    }
    uint64_t v16 = v133;
    uint64_t v17 = (uint64_t)v134;
    uint64_t v18 = operator new(0x50uLL);
    v18[1] = 0;
    v18[2] = 0;
    *uint64_t v18 = off_101A52D98;
    v161 = 0;
    uint64_t v162 = 0;
    v160 = 0;
    sub_10005C928(&v160, v16, v17, v17 - (void)v16);
    sub_1004913B0((uint64_t)buf, a5);
    unint64_t v19 = v18 + 3;
    uint64_t v18[3] = 0;
    void v18[4] = 0;
    v18[5] = 0;
    sub_10005C928(v18 + 3, v160, (uint64_t)v161, v161 - (unsigned char *)v160);
    sub_1004913B0((uint64_t)(v18 + 6), (uint64_t)buf);
    sub_100491448(buf);
    if (v160)
    {
      v161 = v160;
      operator delete(v160);
    }
    unint64_t v20 = *(char **)(a1 + 256);
    uint64_t v21 = *(char **)(a1 + 248);
    uint64_t v22 = v20 - v21;
    if (v20 == v21) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = 32 * (v20 - v21) - 1;
    }
    unint64_t v25 = *(void *)(a1 + 272);
    uint64_t v24 = *(void *)(a1 + 280);
    unint64_t v26 = v24 + v25;
    if (v23 != v24 + v25)
    {
LABEL_76:
      uint64_t v70 = (void *)(*(void *)&v21[(v26 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v26);
      *uint64_t v70 = v19;
      v70[1] = v18;
      *(void *)(a1 + 280) = v24 + 1;
      sub_100D25F88(a1, 0);
LABEL_77:
      if (v133)
      {
        v134 = v133;
        operator delete(v133);
      }
      return;
    }
    if (v25 < 0x100)
    {
      uint64_t v42 = v22 >> 3;
      uint64_t v43 = *(char **)(a1 + 264);
      uint64_t v44 = *(char **)(a1 + 240);
      if (v22 >> 3 >= (unint64_t)((v43 - v44) >> 3))
      {
        if (v43 == v44) {
          unint64_t v47 = 1;
        }
        else {
          unint64_t v47 = (v43 - v44) >> 2;
        }
        uint64_t v48 = (char *)sub_100048350(v47);
        uint64_t v50 = v49;
        BOOL v51 = operator new(0x1000uLL);
        uint64_t v52 = &v48[8 * v42];
        uint64_t v53 = &v48[8 * v50];
        if (v42 == v50)
        {
          uint64_t v54 = 8 * v42;
          if (v22 < 1)
          {
            std::string v93 = v51;
            uint64_t v94 = v54 >> 2;
            if (v20 == v21) {
              unint64_t v95 = 1;
            }
            else {
              unint64_t v95 = v94;
            }
            uint64_t v96 = (char *)sub_100048350(v95);
            uint64_t v52 = &v96[8 * (v95 >> 2)];
            uint64_t v53 = &v96[8 * v97];
            if (v48) {
              operator delete(v48);
            }
            uint64_t v48 = v96;
            BOOL v51 = v93;
          }
          else
          {
            uint64_t v55 = v54 >> 3;
            if (v55 >= -1) {
              unint64_t v56 = v55 + 1;
            }
            else {
              unint64_t v56 = v55 + 2;
            }
            v52 -= 8 * (v56 >> 1);
          }
        }
        *(void *)uint64_t v52 = v51;
        unint64_t v98 = v52 + 8;
        for (uint64_t i = *(void *)(a1 + 256); i != *(void *)(a1 + 248); i -= 8)
        {
          if (v52 == v48)
          {
            if (v98 >= v53)
            {
              if (v53 == v48) {
                unint64_t v104 = 1;
              }
              else {
                unint64_t v104 = (v53 - v48) >> 2;
              }
              char v105 = (char *)sub_100048350(v104);
              uint64_t v107 = v105;
              uint64_t v52 = &v105[(2 * v104 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v108 = v98 - v48;
              BOOL v57 = v98 == v48;
              unint64_t v98 = v52;
              if (!v57)
              {
                unint64_t v98 = &v52[v108 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v109 = 8 * (v108 >> 3);
                uint64_t v110 = v52;
                unint64_t v111 = (uint64_t *)v48;
                do
                {
                  uint64_t v112 = *v111++;
                  *(void *)uint64_t v110 = v112;
                  v110 += 8;
                  v109 -= 8;
                }
                while (v109);
              }
              uint64_t v53 = &v105[8 * v106];
              if (v48) {
                operator delete(v48);
              }
              uint64_t v48 = v107;
            }
            else
            {
              uint64_t v100 = (v53 - v98) >> 3;
              if (v100 >= -1) {
                uint64_t v101 = v100 + 1;
              }
              else {
                uint64_t v101 = v100 + 2;
              }
              uint64_t v102 = v101 >> 1;
              uint64_t v52 = &v48[8 * (v101 >> 1)];
              uint64_t v103 = v48;
              if (v98 != v48)
              {
                memmove(v52, v48, v98 - v48);
                uint64_t v103 = v98;
              }
              unint64_t v98 = &v103[8 * v102];
            }
          }
          uint64_t v113 = *(void *)(i - 8);
          *((void *)v52 - 1) = v113;
          v52 -= 8;
        }
        long long v114 = *(void **)(a1 + 240);
        *(void *)(a1 + 240) = v48;
        *(void *)(a1 + 248) = v52;
        *(void *)(a1 + 256) = v98;
        *(void *)(a1 + 264) = v53;
        unint64_t v19 = v18 + 3;
        if (v114) {
          operator delete(v114);
        }
        goto LABEL_75;
      }
      int v45 = operator new(0x1000uLL);
      uint64_t v46 = v45;
      if (v43 == v20)
      {
        if (v21 == v44)
        {
          if (v20 == v21) {
            unint64_t v71 = 1;
          }
          else {
            unint64_t v71 = (v43 - v21) >> 2;
          }
          char v72 = (char *)sub_100048350(v71);
          uint64_t v21 = &v72[(2 * v71 + 6) & 0xFFFFFFFFFFFFFFF8];
          unint64_t v74 = *(uint64_t **)(a1 + 248);
          unint64_t v75 = v21;
          uint64_t v76 = *(void *)(a1 + 256) - (void)v74;
          if (v76)
          {
            unint64_t v75 = &v21[v76 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v77 = 8 * (v76 >> 3);
            unint64_t v78 = &v72[(2 * v71 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v79 = *v74++;
              *(void *)unint64_t v78 = v79;
              v78 += 8;
              v77 -= 8;
            }
            while (v77);
          }
          uint64_t v80 = *(void **)(a1 + 240);
          *(void *)(a1 + 240) = v72;
          *(void *)(a1 + 248) = v21;
          *(void *)(a1 + 256) = v75;
          *(void *)(a1 + 264) = &v72[8 * v73];
          if (v80)
          {
            operator delete(v80);
            uint64_t v21 = *(char **)(a1 + 248);
          }
        }
        *((void *)v21 - 1) = v46;
        uint64_t v81 = *(char **)(a1 + 248);
        uint64_t v82 = *(char **)(a1 + 256);
        *(void *)(a1 + 248) = v81 - 8;
        uint64_t v83 = *((void *)v81 - 1);
        *(void *)(a1 + 248) = v81;
        if (v82 == *(char **)(a1 + 264))
        {
          unint64_t v84 = *(void *)(a1 + 240);
          uint64_t v85 = (uint64_t)&v81[-v84];
          if ((unint64_t)v81 <= v84)
          {
            uint64_t v115 = (uint64_t)&v82[-v84];
            BOOL v57 = v115 == 0;
            uint64_t v116 = v115 >> 2;
            if (v57) {
              unint64_t v117 = 1;
            }
            else {
              unint64_t v117 = v116;
            }
            long long v118 = (char *)sub_100048350(v117);
            char v120 = &v118[8 * (v117 >> 2)];
            long long v121 = *(uint64_t **)(a1 + 248);
            uint64_t v82 = v120;
            uint64_t v122 = *(void *)(a1 + 256) - (void)v121;
            if (v122)
            {
              uint64_t v82 = &v120[v122 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v123 = 8 * (v122 >> 3);
              long long v124 = &v118[8 * (v117 >> 2)];
              do
              {
                uint64_t v125 = *v121++;
                *(void *)long long v124 = v125;
                v124 += 8;
                v123 -= 8;
              }
              while (v123);
            }
            long long v126 = *(void **)(a1 + 240);
            *(void *)(a1 + 240) = v118;
            *(void *)(a1 + 248) = v120;
            *(void *)(a1 + 256) = v82;
            *(void *)(a1 + 264) = &v118[8 * v119];
            if (v126)
            {
              operator delete(v126);
              uint64_t v82 = *(char **)(a1 + 256);
            }
          }
          else
          {
            uint64_t v86 = v85 >> 3;
            BOOL v33 = v85 >> 3 < -1;
            uint64_t v87 = (v85 >> 3) + 2;
            if (v33) {
              uint64_t v88 = v87;
            }
            else {
              uint64_t v88 = v86 + 1;
            }
            uint64_t v89 = -(v88 >> 1);
            uint64_t v90 = v88 >> 1;
            uint64_t v91 = &v81[-8 * v90];
            int64_t v92 = v82 - v81;
            if (v82 != v81)
            {
              memmove(&v81[-8 * v90], v81, v82 - v81);
              uint64_t v81 = *(char **)(a1 + 248);
            }
            uint64_t v82 = &v91[v92];
            *(void *)(a1 + 248) = &v81[8 * v89];
            *(void *)(a1 + 256) = &v91[v92];
          }
        }
        *(void *)uint64_t v82 = v83;
      }
      else
      {
        *(void *)unint64_t v20 = v45;
      }
    }
    else
    {
      *(void *)(a1 + 272) = v25 - 256;
      uint64_t v29 = *(void *)v21;
      BOOL v27 = v21 + 8;
      uint64_t v28 = v29;
      *(void *)(a1 + 248) = v27;
      if (v20 == *(char **)(a1 + 264))
      {
        unint64_t v30 = *(void *)(a1 + 240);
        uint64_t v31 = (uint64_t)&v27[-v30];
        if ((unint64_t)v27 <= v30)
        {
          uint64_t v58 = (uint64_t)&v20[-v30];
          BOOL v57 = v58 == 0;
          uint64_t v59 = v58 >> 2;
          if (v57) {
            unint64_t v60 = 1;
          }
          else {
            unint64_t v60 = v59;
          }
          uint64_t v61 = (char *)sub_100048350(v60);
          uint64_t v63 = &v61[8 * (v60 >> 2)];
          uint64_t v64 = *(uint64_t **)(a1 + 248);
          unint64_t v20 = v63;
          uint64_t v65 = *(void *)(a1 + 256) - (void)v64;
          if (v65)
          {
            unint64_t v20 = &v63[v65 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v66 = 8 * (v65 >> 3);
            uint64_t v67 = &v61[8 * (v60 >> 2)];
            do
            {
              uint64_t v68 = *v64++;
              *(void *)uint64_t v67 = v68;
              v67 += 8;
              v66 -= 8;
            }
            while (v66);
          }
          uint64_t v69 = *(void **)(a1 + 240);
          *(void *)(a1 + 240) = v61;
          *(void *)(a1 + 248) = v63;
          *(void *)(a1 + 256) = v20;
          *(void *)(a1 + 264) = &v61[8 * v62];
          if (v69)
          {
            operator delete(v69);
            unint64_t v20 = *(char **)(a1 + 256);
          }
        }
        else
        {
          uint64_t v32 = v31 >> 3;
          BOOL v33 = v31 >> 3 < -1;
          uint64_t v34 = (v31 >> 3) + 2;
          if (v33) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = v32 + 1;
          }
          uint64_t v36 = -(v35 >> 1);
          uint64_t v37 = v35 >> 1;
          long long v38 = &v27[-8 * v37];
          int64_t v39 = v20 - v27;
          if (v20 != v27)
          {
            memmove(&v27[-8 * v37], v27, v20 - v27);
            unint64_t v20 = *(char **)(a1 + 248);
          }
          unint64_t v40 = &v20[8 * v36];
          unint64_t v20 = &v38[v39];
          *(void *)(a1 + 248) = v40;
          *(void *)(a1 + 256) = &v38[v39];
        }
      }
      *(void *)unint64_t v20 = v28;
    }
    *(void *)(a1 + 256) += 8;
LABEL_75:
    uint64_t v21 = *(char **)(a1 + 248);
    uint64_t v24 = *(void *)(a1 + 280);
    unint64_t v26 = v24 + *(void *)(a1 + 272);
    goto LABEL_76;
  }
  int v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'secure auth' device doesn't support it", buf, 2u);
  }
  v157[0] = 0;
  char v159 = 0;
  v155 = 0;
  uint64_t v156 = 0;
  v154 = 0;
  sub_10048548C(a5, (uint64_t)v157, (uint64_t)&v154, 267);
  if (v154)
  {
    v155 = v154;
    operator delete(v154);
  }
  if (v159)
  {
    uint64_t v11 = v158;
    int v12 = v157;
    goto LABEL_15;
  }
}

void sub_100D2F508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,void *a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33,void *a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,char a40)
{
  operator delete(v41);
  if (v42) {
    operator delete(v42);
  }
  sub_10004D2C8(v40);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100D2F68C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 32);
  sub_1004913B0((uint64_t)&v6, v3 + 24);
  sub_1007A816C((uint64_t)v7, a2);
  long long v4 = *(std::__shared_weak_count **)(v5 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D2F810(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100D2F844(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D2F860(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100D2F870(uint64_t a1, uint64_t a2, uint64_t a3, void (**a4)(void, void))
{
  if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v130 = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'set nickname' as vinyl availability is %s", buf, 0xCu);
    }
    __int16 v128 = 514;
    ((void (**)(void, __int16 *))a4)[2](a4, &v128);
    return;
  }
  if (*(_DWORD *)(a1 + 84) == 2)
  {
    if (sub_100D25BFC(a1))
    {
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'set nickname' as operations are in 'busy' state", buf, 2u);
      }
      __int16 v126 = 1282;
      ((void (**)(void, __int16 *))a4)[2](a4, &v126);
      return;
    }
    uint64_t v11 = (char *)operator new(0x50uLL);
    int v12 = v11;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = 0;
    *(void *)uint64_t v11 = off_101A52DE8;
    int v13 = v11 + 24;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v11 + 24, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      _OWORD *v13 = *(_OWORD *)a2;
      *((void *)v11 + 5) = *(void *)(a2 + 16);
    }
    uint64_t v14 = v12 + 48;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v14 = *(_OWORD *)a3;
      *((void *)v12 + 8) = *(void *)(a3 + 16);
    }
    if (a4) {
      uint64_t v15 = _Block_copy(a4);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = (char **)(a1 + 296);
    uint64_t v17 = *(char **)(a1 + 304);
    uint64_t v18 = *(char **)(a1 + 296);
    uint64_t v19 = v17 - v18;
    *((void *)v12 + 9) = v15;
    if (v17 == v18) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = 32 * (v17 - v18) - 1;
    }
    unint64_t v22 = *(void *)(a1 + 320);
    uint64_t v21 = *(void *)(a1 + 328);
    unint64_t v23 = v21 + v22;
    if (v20 != v21 + v22) {
      goto LABEL_88;
    }
    if (v22 < 0x100)
    {
      uint64_t v125 = v13;
      uint64_t v38 = v19 >> 3;
      int64_t v39 = *(char **)(a1 + 312);
      unint64_t v40 = *(char **)(a1 + 288);
      if (v19 >> 3 >= (unint64_t)((v39 - v40) >> 3))
      {
        if (v39 == v40) {
          unint64_t v43 = 1;
        }
        else {
          unint64_t v43 = (v39 - v40) >> 2;
        }
        uint64_t v44 = (char *)sub_100048350(v43);
        uint64_t v46 = v45;
        unint64_t v47 = operator new(0x1000uLL);
        uint64_t v48 = &v44[8 * v38];
        uint64_t v49 = v46;
        uint64_t v50 = &v44[8 * v46];
        if (v38 == v49)
        {
          uint64_t v51 = 8 * v38;
          if (v19 < 1)
          {
            uint64_t v67 = v47;
            uint64_t v68 = v51 >> 2;
            if (v17 == v18) {
              unint64_t v69 = 1;
            }
            else {
              unint64_t v69 = v68;
            }
            uint64_t v70 = (char *)sub_100048350(v69);
            uint64_t v48 = &v70[8 * (v69 >> 2)];
            uint64_t v50 = &v70[8 * v71];
            if (v44) {
              operator delete(v44);
            }
            uint64_t v44 = v70;
            unint64_t v47 = v67;
          }
          else
          {
            uint64_t v52 = v51 >> 3;
            if (v52 >= -1) {
              unint64_t v53 = v52 + 1;
            }
            else {
              unint64_t v53 = v52 + 2;
            }
            v48 -= 8 * (v53 >> 1);
          }
        }
        *(void *)uint64_t v48 = v47;
        char v72 = v48 + 8;
        uint64_t v73 = *(char **)(a1 + 296);
        unint64_t v74 = *(char **)(a1 + 304);
        while (v74 != v73)
        {
          if (v48 == v44)
          {
            if (v72 >= v50)
            {
              if (v50 == v44) {
                unint64_t v79 = 1;
              }
              else {
                unint64_t v79 = (v50 - v44) >> 2;
              }
              uint64_t v80 = (char *)sub_100048350(v79);
              uint64_t v82 = v80;
              uint64_t v48 = &v80[(2 * v79 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v83 = v72 - v44;
              BOOL v54 = v72 == v44;
              char v72 = v48;
              if (!v54)
              {
                char v72 = &v48[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                uint64_t v85 = v48;
                uint64_t v86 = (uint64_t *)v44;
                do
                {
                  uint64_t v87 = *v86++;
                  *(void *)uint64_t v85 = v87;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              uint64_t v50 = &v80[8 * v81];
              if (v44) {
                operator delete(v44);
              }
              uint64_t v44 = v82;
            }
            else
            {
              uint64_t v75 = (v50 - v72) >> 3;
              if (v75 >= -1) {
                uint64_t v76 = v75 + 1;
              }
              else {
                uint64_t v76 = v75 + 2;
              }
              uint64_t v77 = v76 >> 1;
              uint64_t v48 = &v44[8 * (v76 >> 1)];
              unint64_t v78 = v44;
              if (v72 != v44)
              {
                memmove(v48, v44, v72 - v44);
                unint64_t v78 = v72;
              }
              char v72 = &v78[8 * v77];
            }
          }
          uint64_t v88 = *((void *)v74 - 1);
          v74 -= 8;
          *((void *)v48 - 1) = v88;
          v48 -= 8;
          uint64_t v73 = *v16;
        }
        uint64_t v89 = *(void **)(a1 + 288);
        *(void *)(a1 + 288) = v44;
        *(void *)(a1 + 296) = v48;
        *(void *)(a1 + 304) = v72;
        *(void *)(a1 + 312) = v50;
        int v13 = v125;
        if (v89) {
          operator delete(v89);
        }
        goto LABEL_87;
      }
      long long v41 = operator new(0x1000uLL);
      uint64_t v42 = v41;
      if (v39 != v17)
      {
        *(void *)uint64_t v17 = v41;
        *(void *)(a1 + 304) += 8;
        int v13 = v125;
LABEL_87:
        uint64_t v18 = *(char **)(a1 + 296);
        uint64_t v21 = *(void *)(a1 + 328);
        unint64_t v23 = v21 + *(void *)(a1 + 320);
LABEL_88:
        uint64_t v90 = (void *)(*(void *)&v18[(v23 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v23);
        void *v90 = v13;
        v90[1] = v12;
        *(void *)(a1 + 328) = v21 + 1;
        sub_100D25F88(a1, 0);
        return;
      }
      if (v18 == v40)
      {
        if (v17 == v18) {
          unint64_t v91 = 1;
        }
        else {
          unint64_t v91 = (v39 - v18) >> 2;
        }
        int64_t v92 = (char *)sub_100048350(v91);
        uint64_t v18 = &v92[(2 * v91 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v94 = *(uint64_t **)(a1 + 296);
        unint64_t v95 = v18;
        uint64_t v96 = *(void *)(a1 + 304) - (void)v94;
        int v13 = v125;
        if (v96)
        {
          unint64_t v95 = &v18[v96 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v97 = 8 * (v96 >> 3);
          unint64_t v98 = &v92[(2 * v91 + 6) & 0xFFFFFFFFFFFFFFF8];
          do
          {
            uint64_t v99 = *v94++;
            *(void *)unint64_t v98 = v99;
            v98 += 8;
            v97 -= 8;
          }
          while (v97);
        }
        uint64_t v100 = *(void **)(a1 + 288);
        *(void *)(a1 + 288) = v92;
        *(void *)(a1 + 296) = v18;
        *(void *)(a1 + 304) = v95;
        *(void *)(a1 + 312) = &v92[8 * v93];
        if (v100)
        {
          operator delete(v100);
          uint64_t v18 = *v16;
        }
      }
      else
      {
        int v13 = v125;
      }
      *((void *)v18 - 1) = v42;
      uint64_t v101 = *(char **)(a1 + 296);
      uint64_t v102 = *(char **)(a1 + 304);
      *(void *)(a1 + 296) = v101 - 8;
      uint64_t v103 = *((void *)v101 - 1);
      *(void *)(a1 + 296) = v101;
      if (v102 == *(char **)(a1 + 312))
      {
        unint64_t v104 = *(void *)(a1 + 288);
        uint64_t v105 = (uint64_t)&v101[-v104];
        if ((unint64_t)v101 <= v104)
        {
          uint64_t v113 = (uint64_t)&v102[-v104];
          BOOL v54 = v113 == 0;
          uint64_t v114 = v113 >> 2;
          if (v54) {
            unint64_t v115 = 1;
          }
          else {
            unint64_t v115 = v114;
          }
          uint64_t v116 = (char *)sub_100048350(v115);
          long long v118 = &v116[8 * (v115 >> 2)];
          uint64_t v119 = *(uint64_t **)(a1 + 296);
          uint64_t v102 = v118;
          uint64_t v120 = *(void *)(a1 + 304) - (void)v119;
          int v13 = v125;
          if (v120)
          {
            uint64_t v102 = &v118[v120 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v121 = 8 * (v120 >> 3);
            uint64_t v122 = &v116[8 * (v115 >> 2)];
            do
            {
              uint64_t v123 = *v119++;
              *(void *)uint64_t v122 = v123;
              v122 += 8;
              v121 -= 8;
            }
            while (v121);
          }
          long long v124 = *(void **)(a1 + 288);
          *(void *)(a1 + 288) = v116;
          *(void *)(a1 + 296) = v118;
          *(void *)(a1 + 304) = v102;
          *(void *)(a1 + 312) = &v116[8 * v117];
          if (v124)
          {
            operator delete(v124);
            uint64_t v102 = *(char **)(a1 + 304);
          }
        }
        else
        {
          uint64_t v106 = v105 >> 3;
          BOOL v30 = v105 >> 3 < -1;
          uint64_t v107 = (v105 >> 3) + 2;
          if (v30) {
            uint64_t v108 = v107;
          }
          else {
            uint64_t v108 = v106 + 1;
          }
          uint64_t v109 = -(v108 >> 1);
          uint64_t v110 = v108 >> 1;
          unint64_t v111 = &v101[-8 * v110];
          int64_t v112 = v102 - v101;
          if (v102 != v101)
          {
            memmove(&v101[-8 * v110], v101, v102 - v101);
            uint64_t v101 = *v16;
          }
          uint64_t v102 = &v111[v112];
          *(void *)(a1 + 296) = &v101[8 * v109];
          *(void *)(a1 + 304) = &v111[v112];
        }
      }
      *(void *)uint64_t v102 = v103;
    }
    else
    {
      *(void *)(a1 + 320) = v22 - 256;
      uint64_t v26 = *(void *)v18;
      uint64_t v24 = v18 + 8;
      uint64_t v25 = v26;
      *(void *)(a1 + 296) = v24;
      if (v17 == *(char **)(a1 + 312))
      {
        unint64_t v27 = *(void *)(a1 + 288);
        uint64_t v28 = (uint64_t)&v24[-v27];
        if ((unint64_t)v24 <= v27)
        {
          uint64_t v55 = (uint64_t)&v17[-v27];
          BOOL v54 = v55 == 0;
          uint64_t v56 = v55 >> 2;
          if (v54) {
            unint64_t v57 = 1;
          }
          else {
            unint64_t v57 = v56;
          }
          uint64_t v58 = (char *)sub_100048350(v57);
          unint64_t v60 = &v58[8 * (v57 >> 2)];
          uint64_t v61 = *(uint64_t **)(a1 + 296);
          uint64_t v17 = v60;
          uint64_t v62 = *(void *)(a1 + 304) - (void)v61;
          if (v62)
          {
            uint64_t v17 = &v60[v62 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v63 = 8 * (v62 >> 3);
            uint64_t v64 = &v58[8 * (v57 >> 2)];
            do
            {
              uint64_t v65 = *v61++;
              *(void *)uint64_t v64 = v65;
              v64 += 8;
              v63 -= 8;
            }
            while (v63);
          }
          uint64_t v66 = *(void **)(a1 + 288);
          *(void *)(a1 + 288) = v58;
          *(void *)(a1 + 296) = v60;
          *(void *)(a1 + 304) = v17;
          *(void *)(a1 + 312) = &v58[8 * v59];
          if (v66)
          {
            operator delete(v66);
            uint64_t v17 = *(char **)(a1 + 304);
          }
        }
        else
        {
          uint64_t v29 = v28 >> 3;
          BOOL v30 = v28 >> 3 < -1;
          uint64_t v31 = (v28 >> 3) + 2;
          if (v30) {
            uint64_t v32 = v31;
          }
          else {
            uint64_t v32 = v29 + 1;
          }
          uint64_t v33 = -(v32 >> 1);
          uint64_t v34 = v32 >> 1;
          uint64_t v35 = &v24[-8 * v34];
          int64_t v36 = v17 - v24;
          if (v17 != v24)
          {
            memmove(&v24[-8 * v34], v24, v17 - v24);
            uint64_t v17 = *v16;
          }
          uint64_t v37 = &v17[8 * v33];
          uint64_t v17 = &v35[v36];
          *(void *)(a1 + 296) = v37;
          *(void *)(a1 + 304) = &v35[v36];
        }
      }
      *(void *)uint64_t v17 = v25;
    }
    *(void *)(a1 + 304) += 8;
    goto LABEL_87;
  }
  int v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'set nickname' incompatible SIM card", buf, 2u);
  }
  __int16 v127 = 2818;
  ((void (**)(void, __int16 *))a4)[2](a4, &v127);
}

void sub_100D2FFDC(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v3) {
    operator delete(v3);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D3005C(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[5])
      {
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 1174405120;
        void v14[2] = sub_100D30204;
        v14[3] = &unk_101A525E0;
        v14[4] = v5;
        sub_1007A816C((uint64_t)v15, a2);
        uint64_t v8 = (std::__shared_weak_count *)a1[8];
        uint64_t v18 = a1[7];
        uint64_t v19 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v9 = (std::__shared_weak_count *)v5[2];
        if (!v9 || (v10 = v5[1], (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
          sub_100088B9C();
        }
        int v12 = v11;
        int v13 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v10;
        uint64_t v21 = v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v14;
        dispatch_async(v13, block);
        if (v21) {
          sub_10004D2C8(v21);
        }
        sub_10004D2C8(v12);
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v15[0] == 1)
        {
          if (__p)
          {
            uint64_t v17 = __p;
            operator delete(__p);
          }
        }
        v15[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D301EC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D30204(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == 1)
  {
    int v4 = sub_1007510F8(a1 + 48);
    if (!v4)
    {
      uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 48);
      LOWORD(v20) = 257;
      (*(void (**)(uint64_t))(v16 + 16))(v16);
      return sub_100D25690(v2);
    }
    char v5 = v4;
    uint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v20) = 136315138;
      *(void *)((char *)&v20 + 4) = sub_100746C7C(v5);
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting of profile nickname failed: %s", (uint8_t *)&v20, 0xCu);
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 48);
    LOWORD(v20) = 770;
    (*(void (**)(uint64_t))(v7 + 16))(v7);
  }
  else
  {
    if (v3 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    unsigned int v8 = *(unsigned __int8 *)(a1 + 48) - 1;
    if (v8 > 0xA) {
      char v9 = 0;
    }
    else {
      char v9 = byte_10156923F[(char)v8];
    }
    uint64_t v10 = *(void *)(*(void *)(a1 + 72) + 48);
    LOBYTE(v20) = 2;
    BYTE1(v20) = v9;
    (*(void (**)(uint64_t))(v10 + 16))(v10);
    int v11 = *(unsigned __int8 *)(a1 + 40);
    if (v11 != 2)
    {
      if (v11 == 1)
      {
        uint64_t v17 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v17);
      }
      uint64_t v19 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v19);
    }
    if (*(unsigned char *)(a1 + 48) == 2)
    {
      int v12 = *(_DWORD *)(v2 + 80);
      int v13 = *(unsigned __int8 *)(a1 + 49);
      int v14 = *(unsigned __int8 *)(a1 + 50);
      *(void *)&long long v20 = _NSConcreteStackBlock;
      *((void *)&v20 + 1) = 0x40000000;
      uint64_t v21 = sub_1004F09E8;
      unint64_t v22 = &unk_1019DB198;
      int v23 = v12;
      int v24 = 19;
      int v25 = v13;
      int v26 = v14;
      sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
  return sub_100D25F88(v2, 0);
}

void sub_100D304A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D304C4(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1007A816C(a1 + 40, (unsigned __int8 *)(a2 + 40));
  uint64_t v5 = *(void *)(a2 + 80);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D3050C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 40) == 1)
  {
    int v3 = *(void **)(a1 + 48);
    if (v3)
    {
      *(void *)(a1 + 56) = v3;
      operator delete(v3);
    }
  }
  *(unsigned char *)(a1 + 40) = 0;
}

void *sub_100D30558(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D3058C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100D305DC(uint64_t a1, uint64_t a2, void (**a3)(void, void))
{
  if ((*(_DWORD *)(a1 + 152) - 1) <= 1)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' as vinyl availability is %s", (uint8_t *)&buf, 0xCu);
    }
    __int16 v40 = 514;
    ((void (**)(void, __int16 *))a3)[2](a3, &v40);
    return;
  }
  if (sub_100D30CD4(a2))
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No profile", (uint8_t *)&buf, 2u);
    }
    __int16 v39 = 258;
    ((void (**)(void, __int16 *))a3)[2](a3, &v39);
    return;
  }
  uint64_t v8 = *(void *)(a1 + 160);
  if (v8)
  {
    if (*(unsigned char *)(v8 + 112))
    {
      if (*(unsigned char *)(v8 + 192))
      {
        char v9 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' as we have a profile to delete already", (uint8_t *)&buf, 2u);
        }
        __int16 v36 = 770;
        ((void (**)(void, __int16 *))a3)[2](a3, &v36);
        return;
      }
      if (*(_DWORD *)(a1 + 84) == 2 && subscriber::isSimDead())
      {
        int v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' as the sim state is dead", (uint8_t *)&buf, 2u);
        }
        __int16 v35 = 770;
        ((void (**)(void, __int16 *))a3)[2](a3, &v35);
        return;
      }
      sub_1002EF958((uint64_t)&buf);
      if (sub_1003D5918(a2, (uint64_t)&buf))
      {
        if (v48 < 0) {
          operator delete(__p);
        }
      }
      else
      {
        unsigned int v13 = (*(_DWORD *)(a1 + 156) - 7) & 0xFFFFFFFD;
        if (v48 < 0) {
          operator delete(__p);
        }
        if (!v13)
        {
          long long v20 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' as the sim state is unauthorized", (uint8_t *)&buf, 2u);
          }
          __int16 v34 = 770;
          ((void (**)(void, __int16 *))a3)[2](a3, &v34);
          return;
        }
      }
      sub_1002EF958((uint64_t)&buf);
      int v14 = sub_1003D5918(a2, (uint64_t)&buf);
      if (v48 < 0) {
        operator delete(__p);
      }
      if (v14)
      {
        uint64_t v15 = *(_DWORD **)(a1 + 160);
        if (*v15 == 1)
        {
          sub_100D2CDFC(a1);
          return;
        }
        goto LABEL_69;
      }
      uint64_t v16 = sub_100D29BC8(a1, a2);
      uint64_t v17 = *(NSObject **)(a1 + 40);
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v16)
      {
        if (v18)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Delete profile", (uint8_t *)&buf, 2u);
        }
        if (*((unsigned char *)v16 + 90))
        {
          uint64_t v19 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Delete not allowed (PPR2)", (uint8_t *)&buf, 2u);
          }
          __int16 v32 = 257;
          ((void (**)(void, __int16 *))a3)[2](a3, &v32);
          return;
        }
        if (*((unsigned char *)v16 + 89))
        {
          if (*((unsigned char *)v16 + 91))
          {
            unint64_t v22 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Disable not allowed (PPR1)", (uint8_t *)&buf, 2u);
            }
            __int16 v31 = 258;
            ((void (**)(void, __int16 *))a3)[2](a3, &v31);
            return;
          }
          uint64_t v23 = *(void *)(a1 + 160);
          int v24 = (uint64_t **)(v23 + 120);
          if (*(unsigned char *)(v23 + 144))
          {
            sub_1000E9358(v24, (void **)v16 + 2);
          }
          else
          {
            *((void *)&buf + 1) = 0;
            __n128 __p = 0;
            *(void *)&long long buf = (char *)&buf + 8;
            sub_100634768((uint64_t)v24, &buf);
            sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
            uint64_t v25 = *(void *)(a1 + 160);
            uint64_t v26 = *(void *)(v25 + 88);
            for (uint64_t i = *(void *)(v25 + 96); v26 != i; v26 += 216)
            {
              if (*(unsigned char *)(v26 + 89) && !sub_10001D294((unsigned __int8 *)(v26 + 16), (unsigned __int8 *)(a2 + 16))) {
                sub_100046BAC((uint64_t **)(*(void *)(a1 + 160) + 120), (void **)(v26 + 16), v26 + 16);
              }
            }
          }
        }
        uint64_t v15 = *(_DWORD **)(a1 + 160);
LABEL_69:
        sub_100D3C980((uint64_t)(v15 + 48), a2);
        if (a3) {
          uint64_t v28 = _Block_copy(a3);
        }
        else {
          uint64_t v28 = 0;
        }
        uint64_t v29 = *(void *)(a1 + 160);
        BOOL v30 = *(const void **)(v29 + 248);
        *(void *)(v29 + 248) = v28;
        if (v30) {
          _Block_release(v30);
        }
        sub_100D25F88(a1, 0);
        return;
      }
      if (v18)
      {
        sub_10010DD9C((uint64_t)v41, a2);
        sVinylUniversalProfileIdAsString();
        if (SHIBYTE(__p) >= 0) {
          p_long long buf = &buf;
        }
        else {
          p_long long buf = (long long *)buf;
        }
        *(_DWORD *)uint64_t v44 = 136315138;
        uint64_t v45 = p_buf;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete': %s is not a recognized profile id", v44, 0xCu);
        if (SHIBYTE(__p) < 0) {
          operator delete((void *)buf);
        }
        if (v43 < 0) {
          operator delete(v42);
        }
      }
      __int16 v33 = 258;
      ((void (**)(void, __int16 *))a3)[2](a3, &v33);
    }
    else
    {
      int v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' as we have no information about profiles yet", (uint8_t *)&buf, 2u);
      }
      __int16 v37 = 770;
      ((void (**)(void, __int16 *))a3)[2](a3, &v37);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Ignoring 'delete' until we have seen availability", (uint8_t *)&buf, 2u);
    }
    __int16 v38 = 770;
    ((void (**)(void, __int16 *))a3)[2](a3, &v38);
  }
}

void sub_100D30C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,char *a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
}

BOOL sub_100D30CD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0) {
      uint64_t v1 = *(void *)(a1 + 24);
    }
    else {
      uint64_t v1 = *(unsigned __int8 *)(a1 + 39);
    }
    return v1 == 0;
  }
  else
  {
    return kNoVinylProfile[0] == *(void *)a1 && kNoVinylProfile[1] == *(void *)(a1 + 8);
  }
}

void sub_100D30D18(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    uint64_t v5 = (void *)a1[5];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[6])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        v13[2] = sub_100D30EA4;
        uint64_t v13[3] = &unk_101A52648;
        void v13[5] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        void v13[4] = a1[4];
        uint64_t v8 = (std::__shared_weak_count *)v5[2];
        if (!v8 || (v9 = v5[1], (uint64_t v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        int v12 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v9;
        BOOL v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D30E8C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D30EA4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 == 2)
  {
    int v8 = *(_DWORD *)(v2 + 80);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v17 = sub_1004F0E60;
    BOOL v18 = &unk_1019DB1D8;
    int v19 = v8;
    LOBYTE(v21) = 0;
    uint64_t v20 = 0xFF00000002;
    sub_1004F0C80((wis::MetricFactory *)0x8010C);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    int v9 = *(unsigned __int8 *)(a1 + 48);
    if (v9 != 2)
    {
      if (v9 == 1)
      {
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(exception);
      }
      uint64_t v15 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v15);
    }
    if (*(unsigned char *)(a1 + 56) == 2)
    {
      int v10 = *(_DWORD *)(v2 + 80);
      int v11 = *(unsigned __int8 *)(a1 + 57);
      int v12 = *(unsigned __int8 *)(a1 + 58);
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000;
      uint64_t v17 = sub_1004F09E8;
      BOOL v18 = &unk_1019DB198;
      int v19 = v10;
      LODWORD(v20) = 16;
      HIDWORD(v20) = v11;
      int v21 = v12;
      return sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
  }
  else
  {
    if (v3 != 1)
    {
      int v14 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v14);
    }
    int v4 = sub_1007519C8(a1 + 56, 2);
    int v5 = *(_DWORD *)(v2 + 80);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v17 = sub_1004F0E60;
    BOOL v18 = &unk_1019DB1D8;
    int v19 = v5;
    LODWORD(v20) = 2;
    LOBYTE(v21) = 0;
    HIDWORD(v20) = v4;
    sub_1004F0C80((wis::MetricFactory *)0x8010C);
    if (v4)
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = sub_100746C7C(v4);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Delete profile failed: %s", (uint8_t *)&buf, 0xCu);
      }
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    else
    {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
  }
  return result;
}

void sub_100D31200(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D31224(void *a1, unsigned __int8 *a2)
{
  int v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    int v5 = (void *)a1[5];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[6])
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 1174405120;
        v13[2] = sub_100D313B0;
        uint64_t v13[3] = &unk_101A526B8;
        void v13[5] = v5;
        sub_1007A816C((uint64_t)v14, a2);
        void v13[4] = a1[4];
        int v8 = (std::__shared_weak_count *)v5[2];
        if (!v8 || (v9 = v5[1], (int v10 = std::__shared_weak_count::lock(v8)) == 0)) {
          sub_100088B9C();
        }
        int v11 = v10;
        int v12 = v5[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100D391E4;
        block[3] = &unk_101A52AE8;
        block[5] = v9;
        BOOL v18 = v11;
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v13;
        dispatch_async(v12, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        sub_10004D2C8(v11);
        if (v14[0] == 1)
        {
          if (__p)
          {
            uint64_t v16 = __p;
            operator delete(__p);
          }
        }
        v14[0] = 0;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100D31398(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D313B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 == 2)
  {
    int v10 = *(_DWORD *)(v2 + 80);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F0E60;
    __int16 v36 = &unk_1019DB1D8;
    int v37 = v10;
    LOBYTE(v39) = 1;
    uint64_t v38 = 0xFF00000002;
    sub_1004F0C80((wis::MetricFactory *)0x8010C);
    int v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      int v13 = *(unsigned __int8 *)(a1 + 48);
      if (v13 != 2)
      {
        if (v13 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          __int16 v31 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_47;
        }
LABEL_46:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        __int16 v31 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_47:
        __cxa_throw(exception, v30, (void (*)(void *))v31);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Reset Memory failed with error:%s (driver error %s)", buf, 0x16u);
    }
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    int v15 = *(unsigned __int8 *)(a1 + 48);
    if (v15 != 2)
    {
      if (v15 == 1)
      {
        unint64_t v27 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v27);
      }
      __int16 v32 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v32);
    }
    if (*(unsigned char *)(a1 + 56) == 2)
    {
      int v16 = *(_DWORD *)(v2 + 80);
      int v17 = *(unsigned __int8 *)(a1 + 57);
      int v18 = *(unsigned __int8 *)(a1 + 58);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_1004F09E8;
      __int16 v36 = &unk_1019DB198;
      int v37 = v16;
      LODWORD(v38) = 17;
      HIDWORD(v38) = v17;
      int v39 = v18;
      return sub_1004F0808((wis::MetricFactory *)0x800F1);
    }
    return result;
  }
  if (v3 != 1) {
    goto LABEL_46;
  }
  int v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 64) - *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Memory Reset succeeded %lu bytes", buf, 0xCu);
    int v6 = *(unsigned __int8 *)(a1 + 48);
    if (v6 != 1)
    {
      if (v6 == 2)
      {
        uint64_t v28 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v28);
      }
      __int16 v34 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v34);
    }
  }
  uint64_t v7 = *(void *)(v2 + 344);
  if (v7)
  {
    sub_100EE8BC8(v7, "ResetMemory");
    int v8 = *(unsigned __int8 *)(a1 + 48);
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v9);
      }
      __int16 v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
    }
  }
  else
  {
    *(void *)(v2 + 344) = 0;
  }
  int v19 = sub_100753368(a1 + 56);
  int v20 = *(_DWORD *)(v2 + 80);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1004F0E60;
  __int16 v36 = &unk_1019DB1D8;
  int v37 = v20;
  LODWORD(v38) = 2;
  LOBYTE(v39) = 1;
  HIDWORD(v38) = v19;
  sub_1004F0C80((wis::MetricFactory *)0x8010C);
  if (v19)
  {
    int v21 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v22 = sub_100746C7C(v19);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Memory reset failure: %s", buf, 0xCu);
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v23 = *(void *)(v2 + 160);
    if (v23 && *(unsigned char *)(v23 + 112))
    {
      uint64_t v24 = *(void *)(v23 + 88);
      uint64_t v25 = *(void *)(v23 + 96);
      if (v24 == v25)
      {
        uint64_t v25 = *(void *)(v23 + 88);
      }
      else
      {
        while (*(unsigned char *)(v24 + 88))
        {
          v24 += 216;
          if (v24 == v25)
          {
            uint64_t v24 = *(void *)(v23 + 96);
            goto LABEL_33;
          }
        }
        if (v24 != v25)
        {
          uint64_t v26 = v24 + 216;
          if (v24 + 216 != v25)
          {
            do
            {
              if (*(unsigned char *)(v26 + 88))
              {
                sub_10032FC84(v24, v26);
                v24 += 216;
              }
              v26 += 216;
            }
            while (v26 != v25);
            uint64_t v25 = *(void *)(v23 + 96);
          }
        }
      }
LABEL_33:
      sub_10032FA2C(v23 + 88, v24, v25);
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_100D319BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D319F8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = **(void **)(v2 + 176);
  __int16 v6 = 0;
  if (*a2 - 1 <= 1) {
    __int16 v6 = *(_WORD *)a2;
  }
  (*(void (**)(uint64_t, __int16 *))(v3 + 16))(v3, &v6);
  *(unsigned char *)(*(void *)(v2 + 160) + 157) = 0;
  int v4 = *(std::__shared_weak_count **)(v2 + 184);
  *(void *)(v2 + 176) = 0;
  *(void *)(v2 + 184) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  return sub_100D25F88(v2, 0);
}

uint64_t sub_100D31A7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 160);
  if (!v4)
  {
    __int16 v10 = 257;
    (*(void (**)(uint64_t, __int16 *))(a2 + 16))(a2, &v10);
    LOBYTE(v10) = 0;
    uint64_t v4 = *(void *)(a1 + 160);
  }
  uint64_t v5 = *(void *)(v4 + 160);
  if (v5)
  {
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 72))(v5);
    uint64_t v4 = *(void *)(a1 + 160);
    if (v6)
    {
      (*(void (**)(void))(**(void **)(v4 + 160) + 24))(*(void *)(v4 + 160));
      uint64_t v4 = *(void *)(a1 + 160);
    }
  }
  uint64_t v7 = *(void *)(v4 + 176);
  if (v7 && (*(unsigned int (**)(uint64_t))(*(void *)v7 + 72))(v7)) {
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 160) + 176) + 24))(*(void *)(*(void *)(a1 + 160) + 176));
  }
  __int16 v9 = 257;
  return (*(uint64_t (**)(uint64_t, __int16 *))(a2 + 16))(a2, &v9);
}

void sub_100D31BAC(uint64_t a1, uint64_t a2, int a3, CFDictionaryRef *a4)
{
  if ((*(_DWORD *)(a1 + 152) - 1) > 1)
  {
    uint64_t v9 = *(void *)(a1 + 160);
    if (v9)
    {
      uint64_t v12 = *(void *)(v9 + 160);
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
      }
      int v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Debug: trigger install operation", buf, 2u);
      }
      int v14 = *(std::__shared_weak_count **)(a1 + 168);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      int v15 = **(_DWORD **)(a1 + 160);
      int v16 = *(NSObject **)(a1 + 40);
      BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
      if (v15 == 2)
      {
        if (v17)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Created Tape operation", buf, 2u);
        }
        uint64_t v56 = 0;
        unint64_t v57 = 0;
        sub_100324590(&v56);
        if (*a4) {
          int v18 = sub_100080778;
        }
        else {
          int v18 = 0;
        }
        if (v18)
        {
          CFDictionaryGetValue(*a4, @"kTapeMatchingId");
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v19 = *(void *)buf;
          v58[0] = *(void *)&buf[8];
          *(void *)((char *)v58 + 7) = *(void *)&buf[15];
          uint8_t v20 = buf[23];
          uint64_t v21 = v56;
          if (*(char *)(v56 + 71) < 0) {
            operator delete(*(void **)(v56 + 48));
          }
          uint64_t v22 = v58[0];
          *(void *)(v21 + 48) = v19;
          *(void *)(v21 + 56) = v22;
          *(void *)(v21 + 63) = *(void *)((char *)v58 + 7);
          *(unsigned char *)(v21 + 71) = v20;
          CFDictionaryGetValue(*a4, @"kTapeConfirmationCode");
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v23 = *(void *)buf;
          v58[0] = *(void *)&buf[8];
          *(void *)((char *)v58 + 7) = *(void *)&buf[15];
          uint8_t v24 = buf[23];
          uint64_t v25 = v56;
          uint64_t v26 = (uint64_t *)v56;
          if (*(char *)(v56 + 95) < 0)
          {
            operator delete(*(void **)(v56 + 72));
            uint64_t v26 = (uint64_t *)v56;
          }
          uint64_t v27 = v58[0];
          *(void *)(v25 + 72) = v23;
          *(void *)(v25 + 80) = v27;
          *(void *)(v25 + 87) = *(void *)((char *)v58 + 7);
          *(unsigned char *)(v25 + 95) = v24;
          CFDictionaryGetValue(*a4, @"kTapeIccidPrefix");
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v28 = *(void *)buf;
          v58[0] = *(void *)&buf[8];
          *(void *)((char *)v58 + 7) = *(void *)&buf[15];
          uint8_t v29 = buf[23];
          unint64_t v30 = v26[14];
          unint64_t v31 = v26[13];
          if (v31 >= v30)
          {
            uint64_t v35 = v26[12];
            unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - v35) >> 3);
            unint64_t v37 = v36 + 1;
            if (v36 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v35) >> 3);
            if (2 * v38 > v37) {
              unint64_t v37 = 2 * v38;
            }
            if (v38 >= 0x555555555555555) {
              unint64_t v39 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v39 = v37;
            }
            uint64_t v61 = v26 + 14;
            if (v39) {
              __int16 v40 = (char *)sub_10004812C((uint64_t)(v26 + 14), v39);
            }
            else {
              __int16 v40 = 0;
            }
            long long v41 = &v40[24 * v36];
            *(void *)long long buf = v40;
            *(void *)&uint8_t buf[8] = v41;
            unint64_t v60 = &v40[24 * v39];
            uint64_t v42 = v58[0];
            *(void *)long long v41 = v28;
            *((void *)v41 + 1) = v42;
            *(void *)(v41 + 15) = *(void *)((char *)v58 + 7);
            v41[23] = v29;
            v58[0] = 0;
            *(void *)((char *)v58 + 7) = 0;
            *(void *)&uint8_t buf[16] = v41 + 24;
            sub_100048204(v26 + 12, buf);
            uint64_t v33 = v26[13];
            sub_100048174((uint64_t)buf);
          }
          else
          {
            uint64_t v32 = v58[0];
            *(void *)unint64_t v31 = *(void *)buf;
            *(void *)(v31 + 8) = v32;
            *(void *)(v31 + 15) = *(void *)((char *)v58 + 7);
            *(unsigned char *)(v31 + 23) = v29;
            uint64_t v33 = v31 + 24;
            v26[13] = v31 + 24;
          }
          v26[13] = v33;
          Value = (BOOL *)CFDictionaryGetValue(*a4, @"kTapeUserConsent");
          uint64_t v44 = Value;
          buf[0] = 0;
          if (Value)
          {
            CFTypeID v45 = CFGetTypeID(Value);
            if (v45 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v44, v46);
            }
          }
          CFDictionaryGetValue(*a4, @"kTapeServer");
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v47 = *(void *)buf;
          v58[0] = *(void *)&buf[8];
          *(void *)((char *)v58 + 7) = *(void *)&buf[15];
          uint8_t v48 = buf[23];
          uint64_t v49 = v56;
          if (*(char *)(v56 + 23) < 0) {
            operator delete(*(void **)v56);
          }
          uint64_t v50 = v58[0];
          *(void *)uint64_t v49 = v47;
          *(void *)(v49 + 8) = v50;
          *(void *)(v49 + 15) = *(void *)((char *)v58 + 7);
          *(unsigned char *)(v49 + 23) = v48;
        }
        uint64_t v51 = v56;
        if (a3 == 2)
        {
          unint64_t v52 = *(void *)(v56 + 96);
          if (v52 == *(void *)(v56 + 104))
          {
            if (v52 >= *(void *)(v56 + 112))
            {
              uint64_t v53 = sub_100D390E4((uint64_t *)(v56 + 96));
            }
            else
            {
              sub_100058DB0(*(void **)(v56 + 96), "8");
              uint64_t v53 = v52 + 24;
              *(void *)(v51 + 104) = v52 + 24;
            }
            *(void *)(v51 + 104) = v53;
            uint64_t v51 = v56;
          }
        }
        BOOL v54 = v57;
        v55[0] = v51;
        v55[1] = v57;
        if (v57) {
          atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100D2A0B4(a1, v55, (uint64_t)&stru_101A52760, (uint64_t)&stru_101A527A0);
        if (v54) {
          sub_10004D2C8(v54);
        }
        if (v57) {
          sub_10004D2C8(v57);
        }
      }
      else if (v17)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Invalid card type", buf, 2u);
      }
      sub_100D25F88(a1, 0);
      if (v14) {
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    else
    {
      __int16 v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v6 = "#I Ignoring 'test fetch' until we have seen availability";
        uint64_t v7 = v34;
        uint32_t v8 = 2;
        goto LABEL_26;
      }
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      int v6 = "#I Ignoring 'test fetch' as vinyl availability is %s";
      uint64_t v7 = v5;
      uint32_t v8 = 12;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

void sub_100D32148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  *(void *)(v22 + 104) = v21;
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100D321F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a2;
    if (*(char *)(a2 + 23) < 0) {
      uint64_t v7 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Debug: activate profile %s", buf, 0xCu);
  }
  sub_1000C6AC0((uint64_t)v9, a3);
  sub_100D2926C(a1, a2, (uint64_t)v9);
  return sub_1000C6B58(v9);
}

void sub_100D322D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100D322F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a2;
    if (*(char *)(a2 + 23) < 0) {
      uint64_t v7 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Debug: deactivate profile %s", buf, 0xCu);
  }
  sub_1000C6AC0((uint64_t)v9, a3);
  sub_100D28F74(a1, a2, (uint64_t)v9);
  return sub_1000C6B58(v9);
}

void sub_100D323D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100D323EC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint32_t v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Debug: delete profile", buf, 2u);
    uint32_t v8 = a1[5];
  }
  *(void *)&long long v27 = a2;
  *((void *)&v27 + 1) = a3;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    sVinylProfileIdAsString();
    uint64_t v9 = SHIBYTE(v18) >= 0 ? buf : *(uint8_t **)buf;
    LODWORD(v25) = 136315138;
    *(void *)((char *)&v25 + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Deleting profile %s", (uint8_t *)&v25, 0xCu);
    if (SHIBYTE(v18) < 0) {
      operator delete(*(void **)buf);
    }
  }
  __int16 v10 = operator new(0x10uLL);
  *__int16 v10 = v27;
  uint64_t v11 = (std::__shared_weak_count *)a1[2];
  if (!v11 || (uint64_t v12 = a1[1], (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  int v14 = v13;
  p_shared_weak_owners = &v13->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  uint64_t v26 = 0;
  long long v25 = 0uLL;
  sub_100D3904C(&v25, v10, (uint64_t)(v10 + 1), 1uLL);
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v17 = 1174405120;
  int v18 = sub_100D2C52C;
  uint64_t v19 = &unk_101A52478;
  uint64_t v21 = a1;
  uint64_t v22 = v12;
  uint64_t v23 = v14;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  long long v24 = v27;
  uint64_t v20 = a4;
  VinylCommandDriver::deleteProfiles();
  if ((void)v25)
  {
    *((void *)&v25 + 1) = v25;
    operator delete((void *)v25);
  }
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  std::__shared_weak_count::__release_weak(v14);
  operator delete(v10);
}

void sub_100D3264C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  if (__p) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v23);
  operator delete(v22);
  _Unwind_Resume(a1);
}

void sub_100D3269C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Debug: delete all user profiles", v5, 2u);
  }
  sub_100D2CCBC(a1, a2);
}

uint64_t sub_100D32718(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Sending 'get notifications' command", buf, 2u);
  }
  return VinylCommandDriver::tapeListNotifications();
}

void sub_100D327E0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v14 = a2[8] - 1;
    if (v14 > 0xA) {
      char v15 = 0;
    }
    else {
      char v15 = byte_10156923F[(char)v14];
    }
    int v16 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = asString();
      int v18 = *a2;
      if (v18 != 2)
      {
        if (v18 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          unint64_t v30 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_43;
        }
LABEL_42:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        unint64_t v30 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_43:
        __cxa_throw(exception, v29, (void (*)(void *))v30);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I List receipts failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v19 = *(void *)(a1 + 32);
    char v32 = v15;
    (*(void (**)(void))(v19 + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_42;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Get notifications succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        long long v27 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v27);
      }
      unint64_t v31 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v31);
    }
  }
  uint64_t v9 = *(void *)(v4 + 344);
  if (v9)
  {
    sub_100EE8BC8(v9, "Notifications");
    int v10 = *a2;
    memset(buf, 0, sizeof(buf));
    if (v10 != 1)
    {
      if (v10 == 2)
      {
        uint64_t v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v12 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(v11);
      }
      else
      {
        uint64_t v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v12 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(v11);
      }
      __cxa_throw(v11, v13, (void (*)(void *))v12);
    }
  }
  else
  {
    *(void *)(v4 + 344) = 0;
    memset(buf, 0, sizeof(buf));
  }
  sub_100751D1C((uint64_t *)a2 + 1);
  xpc_object_t v20 = xpc_array_create(0, 0);
  if (v20 || (xpc_object_t v20 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v20);
      xpc_object_t v21 = v20;
    }
    else
    {
      xpc_object_t v21 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
    xpc_object_t v20 = 0;
  }
  xpc_release(v20);
  uint64_t v22 = *(void *)buf;
  uint64_t v23 = *(void *)&buf[8];
  while (v22 != v23)
  {
    xpc_object_t v24 = xpc_data_create(*(const void **)v22, *(void *)(v22 + 8) - *(void *)v22);
    if (!v24) {
      xpc_object_t v24 = xpc_null_create();
    }
    xpc_array_append_value(v21, v24);
    xpc_release(v24);
    v22 += 80;
  }
  unint64_t v37 = 0;
  xpc_object_t object = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v36, (xpc *)&object, v25);
  sub_100044D6C(&v37, &v36);
  sub_1000577C4(&v36);
  xpc_release(object);
  uint64_t v26 = *(void *)(a1 + 32);
  v33[0] = 0;
  sub_100493D20((uint64_t)v33, (const void **)&v37);
  (*(void (**)(uint64_t, unsigned char *))(v26 + 16))(v26, v33);
  if (v33[0] == 1) {
    sub_100044D00(&v34);
  }
  v33[0] = 0;
  sub_100044D00((const void **)&v37);
  xpc_release(v21);
  unint64_t v37 = buf;
  sub_10079AAD4((void ***)&v37);
}

void sub_100D32C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, xpc_object_t object, char a15, uint64_t a16, char a17)
{
  __cxa_free_exception(v17);
  _Unwind_Resume(a1);
}

void sub_100D32D98(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Adding a 'send notification' operation", v3, 2u);
  }
  sub_100D259C0(a1);
}

void sub_100D32E04(uint64_t a1, char **a2, uint64_t a3)
{
  int v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sending 'get notification' command", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (sub_1007529C0(a2, (uint64_t)buf))
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, *(const void **)buf, (uint64_t)v12, (size_t)v12 - *(void *)buf);
    VinylCommandDriver::tapeGetNotification();
    if (__p)
    {
      uint64_t v7 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v9[0] = 2;
    LOBYTE(v10) = 0;
    (*(void (**)(uint64_t, char *))(a3 + 16))(a3, v9);
    if (v9[0] == 1) {
      sub_100030068(&v10);
    }
    v9[0] = 0;
  }
  if (*(void *)buf)
  {
    uint64_t v12 = *(const void **)buf;
    operator delete(*(void **)buf);
  }
}

void sub_100D32F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  xpc_object_t v21 = *(void **)(v19 - 64);
  if (v21)
  {
    *(void *)(v19 - 56) = v21;
    operator delete(v21);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D32FC4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v10 = a2[8] - 1;
    if (v10 > 0xA) {
      char v11 = 0;
    }
    else {
      char v11 = byte_10156923F[(char)v10];
    }
    uint64_t v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      int v14 = *a2;
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          uint64_t v19 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_21;
        }
LABEL_20:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        uint64_t v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_21:
        __cxa_throw(exception, v18, (void (*)(void *))v19);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v26 = 2080;
      uint64_t v27 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Get notification failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v15 = *(void *)(a1 + 32);
    char v22 = v11;
    return (const void **)(*(uint64_t (**)(void))(v15 + 16))();
  }
  if (v5 != 1) {
    goto LABEL_20;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Get notification succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        xpc_object_t v20 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v20);
      }
      xpc_object_t v21 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v21);
    }
  }
  *(void *)long long buf = CFDataCreate(kCFAllocatorDefault, *((const UInt8 **)a2 + 1), *((void *)a2 + 2) - *((void *)a2 + 1));
  uint64_t v9 = *(void *)(a1 + 32);
  v23[0] = 0;
  sub_100D3C9EC((uint64_t)v23, (const void **)buf);
  (*(void (**)(uint64_t, unsigned char *))(v9 + 16))(v9, v23);
  if (v23[0] == 1) {
    sub_100030068(&v24);
  }
  v23[0] = 0;
  return sub_100030068((const void **)buf);
}

void sub_100D332BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  __cxa_free_exception(v13);
  _Unwind_Resume(a1);
}

void sub_100D3332C(uint64_t a1, char **a2, uint64_t a3)
{
  int v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sending 'delete notification' command", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (sub_100752FBC(a2, (uint64_t)buf))
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, *(const void **)buf, (uint64_t)v12, (size_t)v12 - *(void *)buf);
    VinylCommandDriver::tapeDeleteNotification();
    if (__p)
    {
      uint64_t v7 = __p;
      operator delete(__p);
    }
  }
  else
  {
    v9[0] = 2;
    LOBYTE(v10) = 0;
    (*(void (**)(uint64_t, char *))(a3 + 16))(a3, v9);
    if (v9[0] == 1) {
      sub_100030068(&v10);
    }
    v9[0] = 0;
  }
  if (*(void *)buf)
  {
    uint64_t v12 = *(const void **)buf;
    operator delete(*(void **)buf);
  }
}

void sub_100D33498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  if (__p) {
    operator delete(__p);
  }
  xpc_object_t v21 = *(void **)(v19 - 64);
  if (v21)
  {
    *(void *)(v19 - 56) = v21;
    operator delete(v21);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D334EC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v10 = a2[8] - 1;
    if (v10 > 0xA) {
      char v11 = 0;
    }
    else {
      char v11 = byte_10156923F[(char)v10];
    }
    uint64_t v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      int v14 = *a2;
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          uint64_t v19 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_21;
        }
LABEL_20:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        uint64_t v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_21:
        __cxa_throw(exception, v18, (void (*)(void *))v19);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v26 = 2080;
      uint64_t v27 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Delete notification failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v15 = *(void *)(a1 + 32);
    char v22 = v11;
    return (const void **)(*(uint64_t (**)(void))(v15 + 16))();
  }
  if (v5 != 1) {
    goto LABEL_20;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Delete notification succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        xpc_object_t v20 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v20);
      }
      xpc_object_t v21 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v21);
    }
  }
  *(void *)long long buf = CFDataCreate(kCFAllocatorDefault, *((const UInt8 **)a2 + 1), *((void *)a2 + 2) - *((void *)a2 + 1));
  uint64_t v9 = *(void *)(a1 + 32);
  v23[0] = 0;
  sub_100D3C9EC((uint64_t)v23, (const void **)buf);
  (*(void (**)(uint64_t, unsigned char *))(v9 + 16))(v9, v23);
  if (v23[0] == 1) {
    sub_100030068(&v24);
  }
  v23[0] = 0;
  return sub_100030068((const void **)buf);
}

void sub_100D337E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  __cxa_free_exception(v13);
  _Unwind_Resume(a1);
}

uint64_t sub_100D33854(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Sending 'get uicc profiles' command for slot", buf, 2u);
  }
  return VinylCommandDriver::fetchProfiles();
}

void sub_100D3391C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v12 = a2[8] - 1;
    if (v12 > 0xA) {
      char v13 = 0;
    }
    else {
      char v13 = byte_10156923F[(char)v12];
    }
    int v14 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = asString();
      int v16 = *a2;
      if (v16 != 2)
      {
        if (v16 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          xpc_object_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_30;
        }
LABEL_29:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        xpc_object_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_30:
        __cxa_throw(exception, v23, (void (*)(void *))v24);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I List UICC profiles failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v17 = *(void *)(a1 + 32);
    char v27 = v13;
    (*(void (**)(void))(v17 + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_29;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Force listing profiles succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        xpc_object_t v21 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v21);
      }
      __int16 v26 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v26);
    }
  }
  uint64_t v9 = *(capabilities::ct **)(v4 + 344);
  if (v9)
  {
    sub_100EE8BC8((uint64_t)v9, "CardProfiles");
    int v10 = *a2;
    memset(buf, 0, sizeof(buf));
    if (v10 != 1)
    {
      if (v10 == 2)
      {
        char v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v11);
      }
      long long v25 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v25);
    }
  }
  else
  {
    *(void *)(v4 + 344) = 0;
    memset(buf, 0, sizeof(buf));
  }
  char v18 = capabilities::ct::getProvisioningProfileSupport(v9) == 0;
  sub_1003EE3F0((void *)a2 + 1, v18, (uint64_t *)buf);
  uint64_t v19 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v30 = 134217984;
    *(void *)&v30[4] = 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Decoded %lu from the force-list-profiles command to baseband", v30, 0xCu);
  }
  *(void *)unint64_t v30 = 0;
  sub_1003EEC34(buf, (NSMutableArray **)v30);
  uint64_t v20 = *(void *)(a1 + 32);
  v28[0] = 0;
  sub_100493D20((uint64_t)v28, (const void **)v30);
  (*(void (**)(uint64_t, unsigned char *))(v20 + 16))(v20, v28);
  if (v28[0] == 1) {
    sub_100044D00(&v29);
  }
  v28[0] = 0;
  sub_100044D00((const void **)v30);
  *(void *)unint64_t v30 = buf;
  sub_1000C57C8((void ***)v30);
}

void sub_100D33D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

const void **sub_100D33DD8(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 152);
  if ((v3 - 1) > 1)
  {
    if (*(unsigned char *)(a1 + 336) && ((v3 - 3) & 0xFFFFFFFD) == 0)
    {
      char v27 = 0;
      uint64_t v9 = *(void *)(a1 + 160);
      int v10 = *(unsigned __int8 *)(v9 + 112);
      char v11 = *(NSObject **)(a1 + 40);
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v12)
        {
          unint64_t v13 = 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v9 + 96) - *(void *)(v9 + 88)) >> 3);
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending back the cached array of profiles (%lu profiles)", buf, 0xCu);
        }
        xpc_object_t v14 = xpc_array_create(0, 0);
        if (v14 || (xpc_object_t v14 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_array)
          {
            xpc_retain(v14);
            xpc_object_t v15 = v14;
          }
          else
          {
            xpc_object_t v15 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v15 = xpc_null_create();
          xpc_object_t v14 = 0;
        }
        xpc_release(v14);
        uint64_t v16 = *(void *)(a1 + 160);
        uint64_t v17 = *(char **)(v16 + 88);
        char v18 = *(char **)(v16 + 96);
        while (v17 != v18)
        {
          xpc_object_t v19 = xpc_data_create(v17, 0x10uLL);
          if (!v19) {
            xpc_object_t v19 = xpc_null_create();
          }
          xpc_array_append_value(v15, v19);
          xpc_release(v19);
          v17 += 216;
        }
        xpc_object_t object = v15;
        if (v15) {
          xpc_retain(v15);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        xpc::bridge((uint64_t *)&v25, (xpc *)&object, v20);
        sub_100044D6C(&v26, &v25);
        *(void *)long long buf = v27;
        xpc_object_t v21 = v26;
        __int16 v26 = 0;
        char v27 = v21;
        sub_100044D00((const void **)buf);
        sub_100044D00(&v26);
        sub_1000577C4(&v25);
        xpc_release(object);
        xpc_release(v15);
      }
      else if (v12)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I No cached profiles available (yet?)", buf, 2u);
      }
      v22[0] = 0;
      sub_100493D20((uint64_t)v22, &v27);
      (*(void (**)(uint64_t, char *))(a2 + 16))(a2, v22);
      if (v22[0] == 1) {
        sub_100044D00(&v23);
      }
      v22[0] = 0;
      int v8 = &v27;
      return sub_100044D00(v8);
    }
    v28[0] = 2;
    uint64_t v4 = &v29;
    char v29 = 3;
    uint64_t result = (const void **)(*(uint64_t (**)(uint64_t, unsigned __int8 *))(a2 + 16))(a2, v28);
    int v6 = v28[0];
  }
  else
  {
    v30[0] = 2;
    uint64_t v4 = &v31;
    char v31 = 2;
    uint64_t result = (const void **)(*(uint64_t (**)(uint64_t, unsigned __int8 *))(a2 + 16))(a2, v30);
    int v6 = v30[0];
  }
  if (v6 != 1) {
    return result;
  }
  int v8 = (const void **)v4;
  return sub_100044D00(v8);
}

void sub_100D340E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, xpc_object_t object, char a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D341B0(uint64_t a1, uint64_t a2, void (**a3)(void, void))
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Generating debug Sign Id map", buf, 2u);
  }
  int v7 = *(_DWORD *)(a1 + 84);
  if (v7 == 2)
  {
    *(void *)long long buf = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    if (sub_100753E3C(*(void *)(a1 + 160) + 56, a2, (unint64_t *)buf))
    {
      BOOL v12 = 0;
      uint64_t v13 = 0;
      __n128 __p = 0;
      sub_10005C928(&__p, *(const void **)buf, (uint64_t)v17, (size_t)v17 - *(void *)buf);
      v10[1] = _NSConcreteStackBlock;
      void v10[2] = (const void *)0x40000000;
      _OWORD v10[3] = sub_100D34918;
      void v10[4] = &unk_101A52890;
      void v10[5] = a3;
      void v10[6] = (const void *)a1;
      VinylCommandDriver::signPayload();
      if (__p)
      {
        BOOL v12 = __p;
        operator delete(__p);
      }
    }
    else
    {
      v14[0] = 2;
      LOBYTE(v15) = 3;
      ((void (**)(void, char *))a3)[2](a3, v14);
      if (v14[0] == 1) {
        sub_100030068(&v15);
      }
      v14[0] = 0;
    }
    int v8 = *(void **)buf;
    if (*(void *)buf)
    {
      uint64_t v17 = *(const void **)buf;
LABEL_17:
      operator delete(v8);
    }
  }
  else
  {
    if (v7 == 1)
    {
      __int16 v26 = 0;
      uint64_t v27 = 0;
      long long v25 = 0;
      sub_10005C928(&v25, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
      xpc_object_t v19 = _NSConcreteStackBlock;
      uint64_t v20 = 0x40000000;
      xpc_object_t v21 = sub_100D34494;
      char v22 = &unk_101A52868;
      uint64_t v23 = a3;
      uint64_t v24 = a1;
      VinylCommandDriver::getSignIdMap();
      int v8 = v25;
      if (!v25) {
        return;
      }
      __int16 v26 = v25;
      goto LABEL_17;
    }
    v9[0] = 2;
    LOBYTE(v10[0]) = 2;
    ((void (**)(void, char *))a3)[2](a3, v9);
    if (v9[0] == 1) {
      sub_100030068(v10);
    }
  }
}

void sub_100D34410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void *__p,uint64_t a24)
{
  if (a21 == 1) {
    sub_100030068(v24);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D34494(uint64_t a1, const void **a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(unsigned __int8 *)a2;
  if (v5 == 2)
  {
    unsigned int v9 = *((unsigned __int8 *)a2 + 8) - 1;
    if (v9 > 0xA) {
      char v10 = 0;
    }
    else {
      char v10 = byte_10156923F[(char)v9];
    }
    char v11 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      int v13 = *(unsigned __int8 *)a2;
      if (v13 != 2)
      {
        if (v13 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          uint64_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_33;
        }
LABEL_32:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_33:
        __cxa_throw(exception, v23, (void (*)(void *))v24);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v32 = 2080;
      uint64_t v33 = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sign Id map failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v14 = *(void *)(a1 + 32);
    char v26 = v10;
    (*(void (**)(void))(v14 + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_32;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sign Id map generated", buf, 2u);
    int v7 = *(unsigned __int8 *)a2;
    *(void *)long long buf = 0;
    if (v7 != 1)
    {
      if (v7 == 2)
      {
        int v8 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v8);
      }
      long long v25 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v25);
    }
  }
  else
  {
    *(void *)long long buf = 0;
  }
  *(void *)long long buf = xpc_data_create(a2[1], (unsigned char *)a2[2] - (unsigned char *)a2[1]);
  if (!*(void *)buf) {
    *(void *)long long buf = xpc_null_create();
  }
  unint64_t v30 = 0;
  xpc::bridge((uint64_t *)&v29, (xpc *)buf, v15);
  sub_1000C15D8(&v30, &v29);
  sub_1000577C4(&v29);
  int v16 = *(unsigned __int8 *)a2;
  if (v16 != 1)
  {
    if (v16 == 2)
    {
      xpc_object_t v19 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v20 = &ctu::ResultIsError::~ResultIsError;
      ctu::ResultIsError::ResultIsError(v19);
    }
    else
    {
      xpc_object_t v19 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v20 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(v19);
    }
    __cxa_throw(v19, v21, (void (*)(void *))v20);
  }
  uint64_t v17 = *(void *)(v4 + 344);
  if (v17) {
    sub_100EE8BC8(v17, "DebugSignIdResult");
  }
  else {
    *(void *)(v4 + 344) = 0;
  }
  uint64_t v18 = *(void *)(a1 + 32);
  v27[0] = 0;
  sub_100D3C9EC((uint64_t)v27, &v30);
  (*(void (**)(uint64_t, unsigned char *))(v18 + 16))(v18, v27);
  if (v27[0] == 1) {
    sub_100030068(&v28);
  }
  v27[0] = 0;
  sub_100030068(&v30);
  xpc_release(*(xpc_object_t *)buf);
}

void sub_100D34848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object)
{
  __cxa_free_exception(v18);
  _Unwind_Resume(a1);
}

void sub_100D34918(uint64_t a1, const void **a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(unsigned __int8 *)a2;
  if (v5 == 2)
  {
    unsigned int v9 = *((unsigned __int8 *)a2 + 8) - 1;
    if (v9 > 0xA) {
      char v10 = 0;
    }
    else {
      char v10 = byte_10156923F[(char)v9];
    }
    char v11 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = asString();
      int v13 = *(unsigned __int8 *)a2;
      if (v13 != 2)
      {
        if (v13 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          uint64_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_33;
        }
LABEL_32:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_33:
        __cxa_throw(exception, v23, (void (*)(void *))v24);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v32 = 2080;
      uint64_t v33 = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sign Id map failed with error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v14 = *(void *)(a1 + 32);
    char v26 = v10;
    (*(void (**)(void))(v14 + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_32;
  }
  int v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sign Id map generated", buf, 2u);
    int v7 = *(unsigned __int8 *)a2;
    *(void *)long long buf = 0;
    if (v7 != 1)
    {
      if (v7 == 2)
      {
        int v8 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v8);
      }
      long long v25 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v25);
    }
  }
  else
  {
    *(void *)long long buf = 0;
  }
  *(void *)long long buf = xpc_data_create(a2[1], (unsigned char *)a2[2] - (unsigned char *)a2[1]);
  if (!*(void *)buf) {
    *(void *)long long buf = xpc_null_create();
  }
  unint64_t v30 = 0;
  xpc::bridge((uint64_t *)&v29, (xpc *)buf, v15);
  sub_1000C15D8(&v30, &v29);
  sub_1000577C4(&v29);
  int v16 = *(unsigned __int8 *)a2;
  if (v16 != 1)
  {
    if (v16 == 2)
    {
      xpc_object_t v19 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v20 = &ctu::ResultIsError::~ResultIsError;
      ctu::ResultIsError::ResultIsError(v19);
    }
    else
    {
      xpc_object_t v19 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v20 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(v19);
    }
    __cxa_throw(v19, v21, (void (*)(void *))v20);
  }
  uint64_t v17 = *(void *)(v4 + 344);
  if (v17) {
    sub_100EE8BC8(v17, "DebugSignIdResult");
  }
  else {
    *(void *)(v4 + 344) = 0;
  }
  uint64_t v18 = *(void *)(a1 + 32);
  v27[0] = 0;
  sub_100D3C9EC((uint64_t)v27, &v30);
  (*(void (**)(uint64_t, unsigned char *))(v18 + 16))(v18, v27);
  if (v27[0] == 1) {
    sub_100030068(&v28);
  }
  v27[0] = 0;
  sub_100030068(&v30);
  xpc_release(*(xpc_object_t *)buf);
}

void sub_100D34CCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, char a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object)
{
  __cxa_free_exception(v18);
  _Unwind_Resume(a1);
}

uint64_t sub_100D34D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)a2 == 1)
  {
    long long v7 = *(_OWORD *)(a2 + 1);
    char v6 = 1;
    int v3 = &v6;
  }
  else
  {
    char v5 = 0;
    int v3 = &v5;
  }
  return (*(uint64_t (**)(uint64_t, char *))(v2 + 16))(v2, v3);
}

void sub_100D34E20(uint64_t a1, uint64_t a2, uint64_t a3, void (**a4)(void, void))
{
  int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I debug tape set profile nickname", v9, 2u);
  }
  sub_100D2F870(a1, a2, a3, a4);
}

void sub_100D34EB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I debug delete tape profile", buf, 2u);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__n128 __p = *(_OWORD *)a2;
    uint64_t v8 = *(void *)(a2 + 16);
  }
  sub_100D28D48(a1, (uint64_t)__p, a3);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D34F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D34F8C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Sending 'get tape profiles' command", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v3 = capabilities::ct::supportsHydra((capabilities::ct *)v2);
  sub_10074B368(buf, v3);
  char v5 = 0;
  uint64_t v6 = 0;
  __n128 __p = 0;
  sub_10005C928(&__p, *(const void **)buf, (uint64_t)v8, (size_t)v8 - *(void *)buf);
  VinylCommandDriver::tapeListProfilesInfo();
  if (__p)
  {
    char v5 = __p;
    operator delete(__p);
  }
  if (*(void *)buf)
  {
    uint64_t v8 = *(const void **)buf;
    operator delete(*(void **)buf);
  }
}

void sub_100D350B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  xpc_object_t v19 = *(void **)(v17 - 64);
  if (v19)
  {
    *(void *)(v17 - 56) = v19;
    operator delete(v19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D350E4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    uint64_t v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      int v14 = *a2;
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          xpc_object_t v19 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_26;
        }
LABEL_25:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        xpc_object_t v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_26:
        __cxa_throw(exception, v18, (void (*)(void *))v19);
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v26 = v13;
      __int16 v27 = 2080;
      uint64_t v28 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I List UICC Tape profiles failed with error %s (driver error %s)", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_25;
  }
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v26 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Force listing profiles succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        int v16 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v16);
      }
      xpc_object_t v21 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v21);
    }
  }
  uint64_t v9 = *(void *)(v4 + 344);
  if (v9)
  {
    sub_100EE8BC8(v9, "TapeCardProfiles");
    int v10 = *a2;
    if (v10 != 1)
    {
      if (v10 == 2)
      {
        char v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v11);
      }
      uint64_t v20 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v20);
    }
  }
  else
  {
    *(void *)(v4 + 344) = 0;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  v22[0] = 0;
  sub_1000C59A0((uint64_t)v22, (char **)a2 + 1);
  (*(void (**)(uint64_t, char *))(v15 + 16))(v15, v22);
  if (v22[0] == 1 && __p)
  {
    uint64_t v24 = __p;
    operator delete(__p);
  }
}

void sub_100D35454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *__p, uint64_t a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100D354D0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Sending 'getTapeDeviceCaps' command", buf, 2u);
  }
  return VinylCommandDriver::tapeGetDeviceCapabilities();
}

uint64_t sub_100D35594(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    int v8 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    uint64_t v9 = asString();
    int v10 = *a2;
    if (v10 == 2)
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v18 = v9;
      __int16 v19 = 2080;
      uint64_t v20 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I GetTapeDeviceCapsReq failed with error %s (driver error %s)", buf, 0x16u);
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    if (v10 == 1)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(exception);
      int v14 = &ctu::ResultIsNotError::~ResultIsNotError;
      goto LABEL_16;
    }
LABEL_15:
    exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    int v14 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_16:
    __cxa_throw(exception, v13, (void (*)(void *))v14);
  }
  if (v5 != 1) {
    goto LABEL_15;
  }
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I GetTapeDeviceCapsReq succeeded", buf, 2u);
    int v7 = *a2;
    if (v7 != 1)
    {
      if (v7 == 2)
      {
        uint64_t v15 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v15);
      }
      int v16 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v16);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100D3582C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D35858(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Getting debug tape EUICC Info 1", buf, 2u);
  }
  BOOL v2 = operator new(3uLL);
  *(_WORD *)BOOL v2 = 8383;
  v2[2] = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  __n128 __p = 0;
  sub_10005C928(&__p, v2, (uint64_t)(v2 + 3), 3uLL);
  VinylCommandDriver::getTapeEuiccInfo();
  if (__p)
  {
    uint64_t v4 = __p;
    operator delete(__p);
  }
  operator delete(v2);
}

void sub_100D35980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_100D359AC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    uint64_t v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      int v14 = *a2;
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          __int16 v19 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_26;
        }
LABEL_25:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        __int16 v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_26:
        __cxa_throw(exception, v18, (void (*)(void *))v19);
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v26 = v13;
      __int16 v27 = 2080;
      uint64_t v28 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Tape Euicc Info1 error %s (driver error %s)", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_25;
  }
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v26 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I debug getEUICC info 1 succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        int v16 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v16);
      }
      xpc_object_t v21 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v21);
    }
  }
  uint64_t v9 = *(void *)(v4 + 344);
  if (v9)
  {
    sub_100EE8BC8(v9, "TapeEuiccInfo1");
    int v10 = *a2;
    if (v10 != 1)
    {
      if (v10 == 2)
      {
        char v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v11);
      }
      uint64_t v20 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v20);
    }
  }
  else
  {
    *(void *)(v4 + 344) = 0;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  v22[0] = 0;
  sub_1000C59A0((uint64_t)v22, (char **)a2 + 1);
  (*(void (**)(uint64_t, char *))(v15 + 16))(v15, v22);
  if (v22[0] == 1 && __p)
  {
    uint64_t v24 = __p;
    operator delete(__p);
  }
}

void sub_100D35D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *__p, uint64_t a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

void sub_100D35D98(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 160);
  if (v4 && *(unsigned char *)(v4 + 112))
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    sub_1000C5EF0(&v21, *(void *)(v4 + 88), *(void *)(v4 + 96), 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v4 + 96) - *(void *)(v4 + 88)) >> 3));
    uint64_t v6 = v21;
    uint64_t v7 = v22;
    if (v21 != v22)
    {
      char v8 = a2[23];
      if (v8 >= 0) {
        uint64_t v9 = a2[23];
      }
      else {
        uint64_t v9 = *((void *)a2 + 1);
      }
      if (v8 < 0) {
        a2 = *(unsigned char **)a2;
      }
      do
      {
        uint64_t v10 = *(unsigned __int8 *)(v6 + 39);
        if ((v10 & 0x80u) == 0) {
          uint64_t v11 = *(unsigned __int8 *)(v6 + 39);
        }
        else {
          uint64_t v11 = *(void *)(v6 + 24);
        }
        if (v11 == v9)
        {
          if ((v10 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(v6 + 16), a2, *(void *)(v6 + 24)))
            {
LABEL_26:
              v18[0] = 0;
              sub_100493D40((uint64_t)v18, (const std::string *)(v6 + 192));
              uint64_t v14 = *(void *)(a3 + 24);
              if (!v14) {
                sub_10007B600();
              }
              (*(void (**)(uint64_t, unsigned char *))(*(void *)v14 + 48))(v14, v18);
              if (v18[0] == 1 && v20 < 0) {
                operator delete(v19);
              }
              v18[0] = 0;
              uint64_t v24 = (void **)&v21;
              sub_1000C57C8(&v24);
              return;
            }
          }
          else
          {
            if (!*(unsigned char *)(v6 + 39)) {
              goto LABEL_26;
            }
            uint64_t v12 = 0;
            while (*(unsigned __int8 *)(v6 + v12 + 16) == a2[v12])
            {
              if (v10 == ++v12) {
                goto LABEL_26;
              }
            }
          }
        }
        v6 += 216;
      }
      while (v6 != v7);
    }
    uint64_t v24 = (void **)&v21;
    sub_1000C57C8(&v24);
  }
  v15[0] = 2;
  LOBYTE(__p) = 1;
  uint64_t v13 = *(void *)(a3 + 24);
  if (!v13) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char *))(*(void *)v13 + 48))(v13, v15);
  if (v15[0] == 1 && v17 < 0) {
    operator delete(__p);
  }
}

void sub_100D35F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a16 == 1 && a22 < 0) {
    operator delete(__p);
  }
  *(void *)(v23 - 56) = &a23;
  sub_1000C57C8((void ***)(v23 - 56));
  _Unwind_Resume(a1);
}

void *sub_100D35FF4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000C7494((uint64_t)v8, a4);
  sub_100D2BF50(a1, a2, a3, (uint64_t)v8);
  return sub_1000C752C(v8);
}

void sub_100D36080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C752C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100D3609C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Debug get session data", buf, 2u);
  }
  return VinylCommandDriver::getSessionData();
}

void sub_100D36164(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v12 = a2[8] - 1;
    if (v12 > 0xA) {
      char v13 = 0;
    }
    else {
      char v13 = byte_10156923F[(char)v12];
    }
    uint64_t v14 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = asString();
      int v16 = *a2;
      if (v16 != 2)
      {
        if (v16 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          char v29 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_41;
        }
LABEL_40:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        char v29 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_41:
        __cxa_throw(exception, v28, (void (*)(void *))v29);
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Get Session error %s (driver error %s)", buf, 0x16u);
    }
    uint64_t v17 = *(void *)(a1 + 32);
    char v30 = v13;
    (*(void (**)(void))(v17 + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_40;
  }
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I debug get session data: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    memset(buf, 0, sizeof(buf));
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v10 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(v9);
      }
      else
      {
        uint64_t v9 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v10 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(v9);
      }
      __cxa_throw(v9, v11, (void (*)(void *))v10);
    }
  }
  else
  {
    memset(buf, 0, sizeof(buf));
  }
  if (sub_1007537AC((uint64_t)(a2 + 8)))
  {
    xpc_object_t v18 = xpc_array_create(0, 0);
    if (v18 || (xpc_object_t v18 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v18);
        xpc_object_t v19 = v18;
      }
      else
      {
        xpc_object_t v19 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
    }
    xpc_release(v18);
    uint64_t v21 = *(void *)buf;
    uint64_t v22 = *(void *)&buf[8];
    while (v21 != v22)
    {
      uint64_t v23 = (const char *)v21;
      if (*(char *)(v21 + 23) < 0) {
        uint64_t v23 = *(const char **)v21;
      }
      xpc_object_t v24 = xpc_string_create(v23);
      if (!v24) {
        xpc_object_t v24 = xpc_null_create();
      }
      xpc_array_append_value(v19, v24);
      xpc_release(v24);
      v21 += 24;
    }
    unint64_t v37 = 0;
    xpc_object_t object = v19;
    if (v19) {
      xpc_retain(v19);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc::bridge((uint64_t *)&v36, (xpc *)&object, v25);
    sub_100044D6C(&v37, &v36);
    sub_1000577C4(&v36);
    xpc_release(object);
    uint64_t v26 = *(void *)(a1 + 32);
    v33[0] = 0;
    sub_100493D20((uint64_t)v33, (const void **)&v37);
    (*(void (**)(uint64_t, unsigned char *))(v26 + 16))(v26, v33);
    if (v33[0] == 1) {
      sub_100044D00(&v34);
    }
    v33[0] = 0;
    sub_100044D00((const void **)&v37);
    xpc_release(v19);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 32);
    char v31 = 2;
    char v32 = 0;
    (*(void (**)(void))(v20 + 16))();
    char v31 = 0;
  }
  unint64_t v37 = buf;
  sub_100047F64((void ***)&v37);
}

void sub_100D365B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, xpc_object_t object, char a17, uint64_t a18, char a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D366E4(uint64_t a1, char **a2)
{
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Debug clear session data", buf, 2u);
  }
  *(void *)long long buf = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  if (sub_10075369C(a2, (uint64_t)buf))
  {
    int v5 = 0;
    uint64_t v6 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, *(const void **)buf, (uint64_t)v8, (size_t)v8 - *(void *)buf);
    VinylCommandDriver::clearSessionData();
    if (__p)
    {
      int v5 = __p;
      operator delete(__p);
    }
  }
  if (*(void *)buf)
  {
    int v8 = *(const void **)buf;
    operator delete(*(void **)buf);
  }
}

void sub_100D3680C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  xpc_object_t v19 = *(void **)(v17 - 64);
  if (v19)
  {
    *(void *)(v17 - 56) = v19;
    operator delete(v19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D36840(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 != 2)
  {
    if (v4 == 1) {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    goto LABEL_11;
  }
  uint64_t v6 = *(NSObject **)(*(void *)(a1 + 40) + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asString();
    int v8 = *a2;
    if (v8 != 2)
    {
      if (v8 == 1)
      {
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(exception);
        uint64_t v11 = &ctu::ResultIsNotError::~ResultIsNotError;
        goto LABEL_12;
      }
LABEL_11:
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      uint64_t v11 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_12:
      __cxa_throw(exception, v10, (void (*)(void *))v11);
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v13 = v7;
    __int16 v14 = 2080;
    uint64_t v15 = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Clear Session error %s (driver error %s)", buf, 0x16u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100D36A10(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100D36A34(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Getting debug tape EUICC Challenge", buf, 2u);
  }
  BOOL v2 = operator new(3uLL);
  *(_WORD *)BOOL v2 = 11967;
  v2[2] = 0;
  int v4 = 0;
  uint64_t v5 = 0;
  __n128 __p = 0;
  sub_10005C928(&__p, v2, (uint64_t)(v2 + 3), 3uLL);
  VinylCommandDriver::getTapeEuiccChallenge();
  if (__p)
  {
    int v4 = __p;
    operator delete(__p);
  }
  operator delete(v2);
}

void sub_100D36B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_100D36B88(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *a2;
  if (v5 == 2)
  {
    unsigned int v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = asString();
      int v14 = *a2;
      if (v14 != 2)
      {
        if (v14 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
          xpc_object_t v19 = &ctu::ResultIsNotError::~ResultIsNotError;
          goto LABEL_26;
        }
LABEL_25:
        exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        xpc_object_t v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_26:
        __cxa_throw(exception, v18, (void (*)(void *))v19);
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v26 = v13;
      __int16 v27 = 2080;
      uint64_t v28 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Tape Euicc Challenge error %s (driver error %s)", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    return;
  }
  if (v5 != 1) {
    goto LABEL_25;
  }
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a2 + 2) - *((void *)a2 + 1);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v26 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I debug getEUICC challenge succeeded: %lu bytes", buf, 0xCu);
    int v8 = *a2;
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        int v16 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v16);
      }
      uint64_t v21 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v21);
    }
  }
  uint64_t v9 = *(void *)(v4 + 344);
  if (v9)
  {
    sub_100EE8BC8(v9, "TapeEuiccChallenge");
    int v10 = *a2;
    if (v10 != 1)
    {
      if (v10 == 2)
      {
        uint64_t v11 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsError::ResultIsError(v11);
      }
      uint64_t v20 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v20);
    }
  }
  else
  {
    *(void *)(v4 + 344) = 0;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  v22[0] = 0;
  sub_1000C59A0((uint64_t)v22, (char **)a2 + 1);
  (*(void (**)(uint64_t, char *))(v15 + 16))(v15, v22);
  if (v22[0] == 1 && __p)
  {
    xpc_object_t v24 = __p;
    operator delete(__p);
  }
}

void sub_100D36EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *__p, uint64_t a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

void sub_100D36F74(uint64_t a1, uint64_t a2, void (**a3)(void, void), char a4)
{
  uint64_t v7 = *(NSObject **)(a1 + 40);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Get firmware update data", (uint8_t *)&buf, 2u);
  }
  if ((a4 & 1) != 0
    || (uint64_t v15 = (capabilities::euicc *)capabilities::ct::supportsVinylFirmwareUpdate((capabilities::ct *)v8), v15)
    && !capabilities::euicc::supportsEOS(v15))
  {
    if (!*(void *)(a1 + 392) && !*(void *)(a1 + 400))
    {
      Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 48));
      uint64_t v9 = buf;
      sub_100058DB0(__p, "Vinyl Firmware Info");
      int v10 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v10;
      if (v10) {
        dispatch_retain(v10);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = sub_100D37804;
      aBlock[3] = &unk_101A529C8;
      aBlock[4] = a1;
      __int16 v128 = _Block_copy(aBlock);
      sub_100118A44(v9, (uint64_t)__p, 0, 20000000, &object, &v128);
      uint64_t v11 = v132;
      uint64_t v132 = 0;
      uint64_t v12 = *(void *)(a1 + 400);
      *(void *)(a1 + 400) = v11;
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        uint64_t v13 = v132;
        uint64_t v132 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      if (v128) {
        _Block_release(v128);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v131 < 0) {
        operator delete(__p[0]);
      }
      if (*((void *)&buf + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
      }
    }
    if (a3) {
      int v14 = _Block_copy(a3);
    }
    else {
      int v14 = 0;
    }
    uint64_t v17 = (char **)(a1 + 360);
    xpc_object_t v18 = *(char **)(a1 + 368);
    xpc_object_t v19 = *(char **)(a1 + 360);
    uint64_t v20 = v18 - v19;
    if (v18 == v19) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = ((v18 - v19) << 6) - 1;
    }
    unint64_t v23 = *(void *)(a1 + 384);
    uint64_t v22 = *(void *)(a1 + 392);
    unint64_t v24 = v22 + v23;
    if (v21 != v22 + v23) {
      goto LABEL_66;
    }
    if (v23 < 0x200)
    {
      uint64_t v39 = v20 >> 3;
      __int16 v40 = *(char **)(a1 + 376);
      long long v41 = *(char **)(a1 + 352);
      if (v20 >> 3 >= (unint64_t)((v40 - v41) >> 3))
      {
        if (v40 == v41) {
          unint64_t v44 = 1;
        }
        else {
          unint64_t v44 = (v40 - v41) >> 2;
        }
        CFTypeID v45 = (char *)sub_100048350(v44);
        uint64_t v47 = v46;
        __int16 v126 = v14;
        uint8_t v48 = operator new(0x1000uLL);
        uint64_t v49 = &v45[8 * v39];
        uint64_t v50 = &v45[8 * v47];
        if (v39 == v47)
        {
          uint64_t v51 = 8 * v39;
          if (v20 < 1)
          {
            unint64_t v91 = v48;
            uint64_t v92 = v51 >> 2;
            if (v18 == v19) {
              unint64_t v93 = 1;
            }
            else {
              unint64_t v93 = v92;
            }
            uint64_t v94 = (char *)sub_100048350(v93);
            uint64_t v49 = &v94[8 * (v93 >> 2)];
            uint64_t v50 = &v94[8 * v95];
            if (v45) {
              operator delete(v45);
            }
            CFTypeID v45 = v94;
            uint8_t v48 = v91;
          }
          else
          {
            uint64_t v52 = v51 >> 3;
            if (v52 >= -1) {
              unint64_t v53 = v52 + 1;
            }
            else {
              unint64_t v53 = v52 + 2;
            }
            v49 -= 8 * (v53 >> 1);
          }
        }
        *(void *)uint64_t v49 = v48;
        uint64_t v96 = v49 + 8;
        uint64_t v97 = *(char **)(a1 + 360);
        unint64_t v98 = *(char **)(a1 + 368);
        while (v98 != v97)
        {
          if (v49 == v45)
          {
            if (v96 >= v50)
            {
              if (v50 == v45) {
                unint64_t v103 = 1;
              }
              else {
                unint64_t v103 = (v50 - v45) >> 2;
              }
              unint64_t v104 = (char *)sub_100048350(v103);
              uint64_t v106 = v104;
              uint64_t v49 = &v104[(2 * v103 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v107 = v96 - v45;
              BOOL v54 = v96 == v45;
              uint64_t v96 = v49;
              if (!v54)
              {
                uint64_t v96 = &v49[v107 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v108 = 8 * (v107 >> 3);
                uint64_t v109 = v49;
                uint64_t v110 = (uint64_t *)v45;
                do
                {
                  uint64_t v111 = *v110++;
                  *(void *)uint64_t v109 = v111;
                  v109 += 8;
                  v108 -= 8;
                }
                while (v108);
              }
              uint64_t v50 = &v104[8 * v105];
              if (v45) {
                operator delete(v45);
              }
              CFTypeID v45 = v106;
            }
            else
            {
              uint64_t v99 = (v50 - v96) >> 3;
              if (v99 >= -1) {
                uint64_t v100 = v99 + 1;
              }
              else {
                uint64_t v100 = v99 + 2;
              }
              uint64_t v101 = v100 >> 1;
              uint64_t v49 = &v45[8 * (v100 >> 1)];
              uint64_t v102 = v45;
              if (v96 != v45)
              {
                memmove(v49, v45, v96 - v45);
                uint64_t v102 = v96;
              }
              uint64_t v96 = &v102[8 * v101];
            }
          }
          uint64_t v112 = *((void *)v98 - 1);
          v98 -= 8;
          *((void *)v49 - 1) = v112;
          v49 -= 8;
          uint64_t v97 = *v17;
        }
        uint64_t v113 = *(void **)(a1 + 352);
        *(void *)(a1 + 352) = v45;
        *(void *)(a1 + 360) = v49;
        *(void *)(a1 + 368) = v96;
        *(void *)(a1 + 376) = v50;
        int v14 = v126;
        if (v113) {
          operator delete(v113);
        }
        goto LABEL_65;
      }
      uint64_t v42 = operator new(0x1000uLL);
      char v43 = v42;
      if (v40 == v18)
      {
        if (v19 == v41)
        {
          if (v18 == v19) {
            unint64_t v69 = 1;
          }
          else {
            unint64_t v69 = (v40 - v19) >> 2;
          }
          uint64_t v70 = (char *)sub_100048350(v69);
          xpc_object_t v19 = &v70[(2 * v69 + 6) & 0xFFFFFFFFFFFFFFF8];
          char v72 = *(uint64_t **)(a1 + 360);
          uint64_t v73 = v19;
          uint64_t v74 = *(void *)(a1 + 368) - (void)v72;
          if (v74)
          {
            uint64_t v73 = &v19[v74 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v75 = 8 * (v74 >> 3);
            uint64_t v76 = &v70[(2 * v69 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v77 = *v72++;
              *(void *)uint64_t v76 = v77;
              v76 += 8;
              v75 -= 8;
            }
            while (v75);
          }
          unint64_t v78 = *(void **)(a1 + 352);
          *(void *)(a1 + 352) = v70;
          *(void *)(a1 + 360) = v19;
          *(void *)(a1 + 368) = v73;
          *(void *)(a1 + 376) = &v70[8 * v71];
          if (v78)
          {
            operator delete(v78);
            xpc_object_t v19 = *v17;
          }
        }
        *((void *)v19 - 1) = v43;
        unint64_t v79 = *(char **)(a1 + 360);
        uint64_t v80 = *(char **)(a1 + 368);
        *(void *)(a1 + 360) = v79 - 8;
        uint64_t v81 = *((void *)v79 - 1);
        *(void *)(a1 + 360) = v79;
        if (v80 == *(char **)(a1 + 376))
        {
          unint64_t v82 = *(void *)(a1 + 352);
          uint64_t v83 = (uint64_t)&v79[-v82];
          if ((unint64_t)v79 <= v82)
          {
            uint64_t v114 = (uint64_t)&v80[-v82];
            BOOL v54 = v114 == 0;
            uint64_t v115 = v114 >> 2;
            if (v54) {
              unint64_t v116 = 1;
            }
            else {
              unint64_t v116 = v115;
            }
            uint64_t v117 = (char *)sub_100048350(v116);
            uint64_t v119 = &v117[8 * (v116 >> 2)];
            uint64_t v120 = *(uint64_t **)(a1 + 360);
            uint64_t v80 = v119;
            uint64_t v121 = *(void *)(a1 + 368) - (void)v120;
            if (v121)
            {
              uint64_t v80 = &v119[v121 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v122 = 8 * (v121 >> 3);
              uint64_t v123 = &v117[8 * (v116 >> 2)];
              do
              {
                uint64_t v124 = *v120++;
                *(void *)uint64_t v123 = v124;
                v123 += 8;
                v122 -= 8;
              }
              while (v122);
            }
            uint64_t v125 = *(void **)(a1 + 352);
            *(void *)(a1 + 352) = v117;
            *(void *)(a1 + 360) = v119;
            *(void *)(a1 + 368) = v80;
            *(void *)(a1 + 376) = &v117[8 * v118];
            if (v125)
            {
              operator delete(v125);
              uint64_t v80 = *(char **)(a1 + 368);
            }
          }
          else
          {
            uint64_t v84 = v83 >> 3;
            BOOL v31 = v83 >> 3 < -1;
            uint64_t v85 = (v83 >> 3) + 2;
            if (v31) {
              uint64_t v86 = v85;
            }
            else {
              uint64_t v86 = v84 + 1;
            }
            uint64_t v87 = -(v86 >> 1);
            uint64_t v88 = v86 >> 1;
            uint64_t v89 = &v79[-8 * v88];
            int64_t v90 = v80 - v79;
            if (v80 != v79)
            {
              memmove(&v79[-8 * v88], v79, v80 - v79);
              unint64_t v79 = *v17;
            }
            uint64_t v80 = &v89[v90];
            *(void *)(a1 + 360) = &v79[8 * v87];
            *(void *)(a1 + 368) = &v89[v90];
          }
        }
        *(void *)uint64_t v80 = v81;
      }
      else
      {
        *(void *)xpc_object_t v18 = v42;
      }
    }
    else
    {
      *(void *)(a1 + 384) = v23 - 512;
      uint64_t v27 = *(void *)v19;
      long long v25 = v19 + 8;
      uint64_t v26 = v27;
      *(void *)(a1 + 360) = v25;
      if (v18 == *(char **)(a1 + 376))
      {
        unint64_t v28 = *(void *)(a1 + 352);
        uint64_t v29 = (uint64_t)&v25[-v28];
        if ((unint64_t)v25 <= v28)
        {
          uint64_t v55 = (uint64_t)&v18[-v28];
          BOOL v54 = v55 == 0;
          uint64_t v56 = v55 >> 2;
          if (v54) {
            unint64_t v57 = 1;
          }
          else {
            unint64_t v57 = v56;
          }
          uint64_t v58 = (char *)sub_100048350(v57);
          unint64_t v60 = &v58[8 * (v57 >> 2)];
          uint64_t v61 = *(uint64_t **)(a1 + 360);
          xpc_object_t v18 = v60;
          uint64_t v62 = *(void *)(a1 + 368) - (void)v61;
          if (v62)
          {
            xpc_object_t v18 = &v60[v62 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v63 = 8 * (v62 >> 3);
            uint64_t v64 = &v58[8 * (v57 >> 2)];
            do
            {
              uint64_t v65 = *v61++;
              *(void *)uint64_t v64 = v65;
              v64 += 8;
              v63 -= 8;
            }
            while (v63);
          }
          uint64_t v66 = *(void **)(a1 + 352);
          *(void *)(a1 + 352) = v58;
          *(void *)(a1 + 360) = v60;
          *(void *)(a1 + 368) = v18;
          *(void *)(a1 + 376) = &v58[8 * v59];
          if (v66)
          {
            operator delete(v66);
            xpc_object_t v18 = *(char **)(a1 + 368);
          }
        }
        else
        {
          uint64_t v30 = v29 >> 3;
          BOOL v31 = v29 >> 3 < -1;
          uint64_t v32 = (v29 >> 3) + 2;
          if (v31) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = v30 + 1;
          }
          uint64_t v34 = -(v33 >> 1);
          uint64_t v35 = v33 >> 1;
          unint64_t v36 = &v25[-8 * v35];
          int64_t v37 = v18 - v25;
          if (v18 != v25)
          {
            memmove(&v25[-8 * v35], v25, v18 - v25);
            xpc_object_t v18 = *v17;
          }
          unint64_t v38 = &v18[8 * v34];
          xpc_object_t v18 = &v36[v37];
          *(void *)(a1 + 360) = v38;
          *(void *)(a1 + 368) = &v36[v37];
        }
      }
      *(void *)xpc_object_t v18 = v26;
    }
    *(void *)(a1 + 368) += 8;
LABEL_65:
    xpc_object_t v19 = *(char **)(a1 + 360);
    uint64_t v22 = *(void *)(a1 + 392);
    unint64_t v24 = *(void *)(a1 + 384) + v22;
LABEL_66:
    *(void *)(*(void *)&v19[(v24 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v24 & 0x1FF)) = v14;
    uint64_t v67 = v22 + 1;
    *(void *)(a1 + 392) = v22 + 1;
    uint64_t v68 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v67;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Enqueuing request, requests waiting: %lu", (uint8_t *)&buf, 0xCu);
    }
    sub_100D25F88(a1, 0);
    return;
  }
  int v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Preflight vinyl slot id unknown", (uint8_t *)&buf, 2u);
  }
  if (a3)
  {
    *(void *)&long long buf = 0;
    LOBYTE(v133) = 0;
    sub_1000C7FE8(&v133, (const void **)&buf);
    ((void (**)(void, const void **))a3)[2](a3, &v133);
    if (v133 == 1) {
      sub_100057D78(&v134);
    }
    LOBYTE(v133) = 0;
    sub_100057D78((const void **)&buf);
  }
}

void sub_100D37724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27)
{
  operator delete(v27);
  if (v28) {
    operator delete(v28);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D37804(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  BOOL v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Get firmware update data timed out", buf, 2u);
  }
  while (v1[49])
  {
    unint64_t v3 = v1[48];
    uint64_t v4 = *(void *)(v1[45] + ((v3 >> 6) & 0x3FFFFFFFFFFFFF8));
    uint64_t v6 = 0;
    sub_100D26958(*(void *)(v4 + 8 * (v3 & 0x1FF)), &v6);
    sub_100057D78(&v6);
    sub_100D3935C((uint64_t)(v1 + 44));
  }
  uint64_t result = v1[50];
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = v1[50];
    v1[50] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void sub_100D37914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100D37928(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v3 = *(void **)(a1 + 40);
  v22[0] = 0;
  v22[1] = v22;
  void v22[2] = 0x14802000000;
  void v22[3] = sub_100D37C10;
  v22[4] = sub_100D37CD4;
  long long v23 = 0u;
  memset(&v22[5], 0, 272);
  int v4 = *a2;
  if (v4 == 2)
  {
    LOBYTE(v22[5]) = 2;
    LOWORD(v22[6]) = *((_WORD *)a2 + 4);
    BYTE2(v22[6]) = a2[10];
  }
  else if (v4 == 1)
  {
    LOBYTE(v22[5]) = 1;
    long long v5 = *(_OWORD *)(a2 + 216);
    *(_OWORD *)&v22[30] = *(_OWORD *)(a2 + 200);
    *(_OWORD *)&v22[32] = v5;
    long long v6 = *(_OWORD *)(a2 + 248);
    *(_OWORD *)&v22[34] = *(_OWORD *)(a2 + 232);
    *(_OWORD *)&v22[36] = v6;
    long long v7 = *(_OWORD *)(a2 + 152);
    *(_OWORD *)&v22[22] = *(_OWORD *)(a2 + 136);
    *(_OWORD *)&v22[24] = v7;
    long long v8 = *(_OWORD *)(a2 + 184);
    *(_OWORD *)&v22[26] = *(_OWORD *)(a2 + 168);
    *(_OWORD *)&v22[28] = v8;
    long long v9 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)&v22[14] = *(_OWORD *)(a2 + 72);
    *(_OWORD *)&unsigned char v22[16] = v9;
    long long v10 = *(_OWORD *)(a2 + 120);
    *(_OWORD *)&v22[18] = *(_OWORD *)(a2 + 104);
    *(_OWORD *)&v22[20] = v10;
    long long v11 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)&v22[6] = *(_OWORD *)(a2 + 8);
    *(_OWORD *)&char v22[8] = v11;
    long long v12 = *(_OWORD *)(a2 + 56);
    *(_OWORD *)&v22[10] = *(_OWORD *)(a2 + 40);
    *(_OWORD *)&v22[12] = v12;
    v22[38] = 0;
    long long v23 = 0uLL;
    sub_10005C928(&v22[38], *((const void **)a2 + 33), *((void *)a2 + 34), *((void *)a2 + 34) - *((void *)a2 + 33));
  }
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000;
  v19[2] = sub_100D37D14;
  v19[3] = &unk_101A529F0;
  uint64_t v13 = *(void *)(a1 + 32);
  v19[5] = v22;
  v19[6] = v3;
  v19[4] = v13;
  int v14 = (std::__shared_weak_count *)v3[2];
  if (!v14 || (uint64_t v15 = v3[1], (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v17 = v16;
  xpc_object_t v18 = v3[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D391E4;
  block[3] = &unk_101A52AE8;
  block[5] = v15;
  uint64_t v21 = v17;
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v19;
  dispatch_async(v18, block);
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_10004D2C8(v17);
  _Block_object_dispose(v22, 8);
  if (LOBYTE(v22[5]) == 1)
  {
    if (v22[38])
    {
      *(void *)&long long v23 = v22[38];
      operator delete((void *)v22[38]);
    }
  }
}

void sub_100D37BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62)
{
  if (a28 == 1)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D37C10(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 296) = 0u;
  *(_OWORD *)(result + 312) = 0u;
  *(_OWORD *)(result + 264) = 0u;
  *(_OWORD *)(result + 280) = 0u;
  *(_OWORD *)(result + 232) = 0u;
  *(_OWORD *)(result + 248) = 0u;
  *(_OWORD *)(result + 200) = 0u;
  *(_OWORD *)(result + 216) = 0u;
  *(_OWORD *)(result + 168) = 0u;
  *(_OWORD *)(result + 184) = 0u;
  *(_OWORD *)(result + 136) = 0u;
  *(_OWORD *)(result + 152) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(_OWORD *)(result + 120) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  int v2 = *(unsigned __int8 *)(a2 + 40);
  if (v2 == 2)
  {
    *(unsigned char *)(result + 40) = 2;
    __int16 v15 = *(_WORD *)(a2 + 48);
    *(unsigned char *)(result + 50) = *(unsigned char *)(a2 + 50);
    *(_WORD *)(result + 48) = v15;
  }
  else if (v2 == 1)
  {
    *(unsigned char *)(result + 40) = 1;
    long long v3 = *(_OWORD *)(a2 + 48);
    long long v4 = *(_OWORD *)(a2 + 64);
    long long v5 = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(result + 80) = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(result + 96) = v5;
    *(_OWORD *)(result + 48) = v3;
    *(_OWORD *)(result + 64) = v4;
    long long v6 = *(_OWORD *)(a2 + 112);
    long long v7 = *(_OWORD *)(a2 + 128);
    long long v8 = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(result + 144) = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(result + 160) = v8;
    *(_OWORD *)(result + 112) = v6;
    *(_OWORD *)(result + 128) = v7;
    long long v9 = *(_OWORD *)(a2 + 176);
    long long v10 = *(_OWORD *)(a2 + 192);
    long long v11 = *(_OWORD *)(a2 + 224);
    *(_OWORD *)(result + 208) = *(_OWORD *)(a2 + 208);
    *(_OWORD *)(result + 224) = v11;
    *(_OWORD *)(result + 176) = v9;
    *(_OWORD *)(result + 192) = v10;
    long long v12 = *(_OWORD *)(a2 + 240);
    long long v13 = *(_OWORD *)(a2 + 256);
    long long v14 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(result + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(result + 288) = v14;
    *(_OWORD *)(result + 240) = v12;
    *(_OWORD *)(result + 256) = v13;
    *(void *)(result + 304) = 0;
    *(void *)(result + 312) = 0;
    *(void *)(result + 320) = 0;
    *(_OWORD *)(result + 304) = *(_OWORD *)(a2 + 304);
    *(void *)(result + 320) = *(void *)(a2 + 320);
    *(void *)(a2 + 304) = 0;
    *(void *)(a2 + 312) = 0;
    *(void *)(a2 + 320) = 0;
  }
  return result;
}

void sub_100D37CD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40) == 1)
  {
    int v2 = *(void **)(a1 + 304);
    if (v2)
    {
      *(void *)(a1 + 312) = v2;
      operator delete(v2);
    }
  }
  *(unsigned char *)(a1 + 40) = 0;
}

uint64_t sub_100D37D14(void *a1)
{
  uint64_t v2 = a1[6];
  long long v3 = *(unsigned __int8 **)(a1[5] + 8);
  int v4 = v3[40];
  if (v4 != 2)
  {
    if (v4 == 1)
    {
      unint64_t v82 = 0;
      CFStringRef v5 = (const __CFString *)kCommCenterPreferencesNoBackupAppID;
      *(void *)dispatch_object_t object = CFPreferencesCopyValue(@"VinylFailureSent", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100084068(&v82, (CFTypeRef *)object);
      if (v82) {
        long long v7 = sub_100080778;
      }
      else {
        long long v7 = 0;
      }
      if (v7)
      {
        xpc_object_t v83 = 0;
        ctu::cf_to_xpc((uint64_t *)object, v82, v6);
        long long v8 = *(void **)object;
        xpc_object_t v83 = *(xpc_object_t *)object;
        if (*(void *)object && xpc_get_type(*(xpc_object_t *)object) == (xpc_type_t)&_xpc_type_dictionary) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v83 = xpc_null_create();
        }
        xpc_release(*(xpc_object_t *)object);
        *(void *)dispatch_object_t object = &v83;
        *(void *)&object[8] = "Sent";
        sub_100048BAC((uint64_t)object, &v81);
        int v18 = xpc::dyn_cast_or_default((xpc *)&v81, 0, v23);
        xpc_release(v81);
        xpc_release(v83);
      }
      else
      {
        int v18 = 0;
      }
      uint64_t v24 = *(void *)(a1[5] + 8);
      int v25 = *(unsigned __int8 *)(v24 + 40);
      if (v25 != 1)
      {
        if (v25 == 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v56 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
LABEL_97:
          goto LABEL_105;
        }
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v56 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_104:
LABEL_105:
        __cxa_throw(exception, v64, (void (*)(void *))v56);
      }
      if (*(unsigned char *)(v24 + 65) == 1)
      {
        if (v18) {
          goto LABEL_50;
        }
        int v26 = *(_DWORD *)(v2 + 80);
        *(void *)dispatch_object_t object = _NSConcreteStackBlock;
        *(void *)&object[8] = 0x40000000;
        *(void *)&object[16] = sub_1004F0C34;
        uint64_t v85 = &unk_1019DB1B8;
        int v86 = v26;
        int v87 = 1;
        sub_1004F0A54((wis::MetricFactory *)0x80103);
      }
      else if (!v18)
      {
        goto LABEL_50;
      }
      xpc_object_t v83 = 0;
      xpc_object_t v27 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v28 = v27;
      if (v27)
      {
        xpc_object_t v83 = v27;
      }
      else
      {
        xpc_object_t v28 = xpc_null_create();
        xpc_object_t v83 = v28;
        if (!v28)
        {
          xpc_object_t v29 = xpc_null_create();
          xpc_object_t v28 = 0;
          goto LABEL_42;
        }
      }
      if (xpc_get_type(v28) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v28);
LABEL_43:
        xpc_release(v28);
        uint64_t v30 = *(void *)(a1[5] + 8);
        int v31 = *(unsigned __int8 *)(v30 + 40);
        if (v31 != 1)
        {
          if (v31 == 2)
          {
            uint64_t v61 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            uint64_t v62 = &ctu::ResultIsError::~ResultIsError;
            ctu::ResultIsError::ResultIsError(v61);
          }
          else
          {
            uint64_t v61 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
            uint64_t v62 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
            ctu::ResultIsEmptyError::ResultIsEmptyError(v61);
          }
          __cxa_throw(v61, v63, (void (*)(void *))v62);
        }
        xpc_object_t v79 = xpc_BOOL_create(*(unsigned char *)(v30 + 65) == 1);
        if (!v79) {
          xpc_object_t v79 = xpc_null_create();
        }
        *(void *)dispatch_object_t object = &v83;
        *(void *)&object[8] = "Sent";
        sub_100035E70((uint64_t)object, &v79, &v80);
        xpc_release(v80);
        xpc_object_t v80 = 0;
        xpc_release(v79);
        xpc_object_t v79 = 0;
        *(void *)dispatch_object_t object = 0;
        xpc_object_t v81 = v83;
        if (v83) {
          xpc_retain(v83);
        }
        else {
          xpc_object_t v81 = xpc_null_create();
        }
        xpc::bridge((uint64_t *)object, (xpc *)&v81, v32);
        xpc_release(v81);
        CFPreferencesSetValue(@"VinylFailureSent", *(CFPropertyListRef *)object, v5, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        CFPreferencesSynchronize(v5, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_1000577C4((const void **)object);
        xpc_release(v83);
        uint64_t v24 = *(void *)(a1[5] + 8);
        int v33 = *(unsigned __int8 *)(v24 + 40);
        if (v33 == 1)
        {
LABEL_50:
          if (*(_DWORD *)(v24 + 261) == 1989270689)
          {
            uint64_t v34 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)dispatch_object_t object = 0;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#E Vinyl Firmware is too old to update, pretend like it doesn't exist", object, 2u);
            }
            uint64_t v35 = a1[4];
            *(void *)dispatch_object_t object = 0;
            LOBYTE(v77) = 0;
            sub_1000C7FE8(&v77, (const void **)object);
            (*(void (**)(uint64_t, const void **))(v35 + 16))(v35, &v77);
            if (v77 == 1) {
              sub_100057D78(&v78);
            }
            LOBYTE(v77) = 0;
            unint64_t v36 = (const void **)object;
            goto LABEL_82;
          }
          if (*(_DWORD *)(v24 + 300))
          {
            xpc_object_t v83 = 0;
LABEL_77:
            sub_1003EF220(v24 + 48, &v83);
            uint64_t v52 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)dispatch_object_t object = 138412290;
              *(void *)&object[4] = v83;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Get firmware update data success, %@", object, 0xCu);
            }
            uint64_t v53 = a1[4];
            v75[0] = 0;
            sub_1000C61E0((uint64_t)v75, (const void **)&v83);
            (*(void (**)(uint64_t, unsigned char *))(v53 + 16))(v53, v75);
            if (v75[0] == 1) {
              sub_100057D78(&v76);
            }
            v75[0] = 0;
            unint64_t v36 = (const void **)&v83;
LABEL_82:
            sub_100057D78(v36);
            uint64_t v17 = &v82;
LABEL_83:
            sub_100057D78((const void **)v17);
            return sub_100D25F88(v2, 0);
          }
          xpc_object_t v81 = 0;
          (*(void (**)(unsigned char *__return_ptr))(**(void **)(v2 + 64) + 72))(object);
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)object);
          unint64_t v38 = ServiceMap;
          if (v39 < 0)
          {
            __int16 v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v41 = 5381;
            do
            {
              uint64_t v39 = v41;
              unsigned int v42 = *v40++;
              uint64_t v41 = (33 * v41) ^ v42;
            }
            while (v42);
          }
          std::mutex::lock(ServiceMap);
          xpc_object_t v83 = (xpc_object_t)v39;
          char v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)&v83);
          if (v43)
          {
            uint64_t v45 = v43[3];
            unint64_t v44 = (std::__shared_weak_count *)v43[4];
            if (v44)
            {
              atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v38);
              atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v44);
              char v46 = 0;
LABEL_66:
              (*(void (**)(xpc_object_t *__return_ptr, uint64_t))(*(void *)v45 + 176))(&v81, v45);
              if ((v46 & 1) == 0) {
                sub_10004D2C8(v44);
              }
              if (*(void *)&object[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&object[8]);
              }
              if (v81) {
                uint8_t v48 = sub_100081E58;
              }
              else {
                uint8_t v48 = 0;
              }
              if (v48)
              {
                *(_DWORD *)dispatch_object_t object = 0;
                ctu::cf::assign((ctu::cf *)object, (int *)v81, v47);
                uint64_t v49 = *(void *)(a1[5] + 8);
                int v50 = *(unsigned __int8 *)(v49 + 40);
                if (v50 != 1)
                {
                  if (v50 == 2)
                  {
                    unint64_t v69 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                    uint64_t v70 = &ctu::ResultIsError::~ResultIsError;
                    ctu::ResultIsError::ResultIsError(v69);
                  }
                  else
                  {
                    unint64_t v69 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                    uint64_t v70 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                    ctu::ResultIsEmptyError::ResultIsEmptyError(v69);
                  }
                  __cxa_throw(v69, v71, (void (*)(void *))v70);
                }
                *(_DWORD *)(v49 + 300) = *(_DWORD *)object;
              }
              sub_1000570E8((const void **)&v81);
              uint64_t v24 = *(void *)(a1[5] + 8);
              int v51 = *(unsigned __int8 *)(v24 + 40);
              xpc_object_t v83 = 0;
              if (v51 != 1)
              {
                if (v51 == 2)
                {
                  uint64_t v66 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v67 = &ctu::ResultIsError::~ResultIsError;
                  ctu::ResultIsError::ResultIsError(v66);
                }
                else
                {
                  uint64_t v66 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
                  uint64_t v67 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
                  ctu::ResultIsEmptyError::ResultIsEmptyError(v66);
                }
                __cxa_throw(v66, v68, (void (*)(void *))v67);
              }
              goto LABEL_77;
            }
          }
          else
          {
            uint64_t v45 = 0;
          }
          std::mutex::unlock(v38);
          unint64_t v44 = 0;
          char v46 = 1;
          goto LABEL_66;
        }
        if (v33 == 2)
        {
          exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
          uint64_t v56 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
          goto LABEL_97;
        }
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v56 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_104;
      }
      xpc_object_t v29 = xpc_null_create();
LABEL_42:
      xpc_object_t v83 = v29;
      goto LABEL_43;
    }
    goto LABEL_98;
  }
  int v9 = v3[48];
  if ((v9 - 1) > 0xA) {
    char v10 = 0;
  }
  else {
    char v10 = byte_10156923F[(char)(v9 - 1)];
  }
  long long v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asString();
    int v13 = *(unsigned __int8 *)(*(void *)(a1[5] + 8) + 40);
    if (v13 != 2)
    {
      if (v13 == 1)
      {
        unint64_t v57 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v57);
        uint64_t v59 = &ctu::ResultIsNotError::~ResultIsNotError;
        goto LABEL_99;
      }
LABEL_98:
      unint64_t v57 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v57);
      uint64_t v59 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
LABEL_99:
      __cxa_throw(v57, v58, (void (*)(void *))v59);
    }
    *(_DWORD *)dispatch_object_t object = 136315394;
    *(void *)&object[4] = v12;
    *(_WORD *)&object[12] = 2080;
    *(void *)&object[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E Get firmware update data error : %s, driver error: %s", object, 0x16u);
    long long v3 = *(unsigned __int8 **)(a1[5] + 8);
    int v14 = v3[40];
    if (v14 != 2)
    {
      if (v14 == 1)
      {
        unint64_t v60 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsNotError::ResultIsNotError(v60);
      }
      uint64_t v65 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(v65);
    }
    int v9 = v3[48];
  }
  if (v9 == 2)
  {
    int v19 = *(_DWORD *)(v2 + 80);
    int v20 = v3[49];
    int v21 = v3[50];
    *(void *)dispatch_object_t object = _NSConcreteStackBlock;
    *(void *)&object[8] = 0x40000000;
    *(void *)&object[16] = sub_1004F09E8;
    uint64_t v85 = &unk_1019DB198;
    int v86 = v19;
    int v87 = 64;
    int v88 = v20;
    int v89 = v21;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
  else if (v9 == 10)
  {
    __int16 v15 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)dispatch_object_t object = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I return empty as no hardware present", object, 2u);
    }
    uint64_t v16 = a1[4];
    *(void *)dispatch_object_t object = 0;
    LOBYTE(v73) = 0;
    sub_1000C7FE8(&v73, (const void **)object);
    (*(void (**)(uint64_t, const void **))(v16 + 16))(v16, &v73);
    if (v73 == 1) {
      sub_100057D78(&v74);
    }
    LOBYTE(v73) = 0;
    uint64_t v17 = (ctu **)object;
    goto LABEL_83;
  }
  uint64_t v22 = a1[4];
  char v72 = v10;
  (*(void (**)(void))(v22 + 16))();
  return sub_100D25F88(v2, 0);
}

void sub_100D3883C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,const void *a21,xpc_object_t object,char a23,uint64_t a24)
{
  __cxa_free_exception(v24);
  sub_1000570E8((const void **)&a20);
  sub_100057D78(&a21);
  _Unwind_Resume(a1);
}

void sub_100D38A48(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asString();
    if (*(unsigned char *)(a1 + 336)) {
      int v4 = "True";
    }
    else {
      int v4 = "False";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v3;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v4;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
    uint64_t v32 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fAvailability = %s, fDriverReady = %s, fSimState = %s", (uint8_t *)&__p, 0x20u);
  }
  uint64_t v5 = *(void *)(a1 + 160);
  if (v5)
  {
    long long v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sCardSerialNumberAsString();
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      uint64_t v8 = *(void *)(a1 + 160);
      if (*(unsigned char *)(v8 + 24))
      {
        int v9 = (const char *)(v8 + 32);
        if (*(char *)(v8 + 55) < 0) {
          int v9 = *(const char **)v9;
        }
      }
      else
      {
        int v9 = "none";
      }
      *(_DWORD *)long long buf = 136315394;
      unint64_t v38 = p_p;
      __int16 v39 = 2080;
      __int16 v40 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I CSN=%s, version=%s", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      uint64_t v5 = *(void *)(a1 + 160);
      long long v6 = *(NSObject **)(a1 + 40);
    }
    if (*(unsigned char *)(v5 + 112) && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v10 = 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v5 + 96) - *(void *)(v5 + 88)) >> 3);
      LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Profiles: %lu detected; ",
        (uint8_t *)&__p,
        0xCu);
      uint64_t v5 = *(void *)(a1 + 160);
      long long v6 = *(NSObject **)(a1 + 40);
    }
    int v11 = *(unsigned __int8 *)(v5 + 144);
    BOOL v12 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      if (v12)
      {
        sub_1000E8F34(*(std::string **)(v5 + 120), (std::string *)(v5 + 128), ",", 1uLL, &__p);
        int v13 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)long long buf = 136315138;
        unint64_t v38 = v13;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Expected enabled profiles: [%s]", buf, 0xCu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
    else if (v12)
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Have not received user selected info", (uint8_t *)&__p, 2u);
    }
    int v14 = *(NSObject **)(a1 + 40);
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    uint64_t v16 = *(void *)(a1 + 160);
    if (v15)
    {
      if (*(unsigned char *)(v16 + 152)) {
        uint64_t v17 = "True";
      }
      else {
        uint64_t v17 = "False";
      }
      if (*(unsigned char *)(v16 + 153)) {
        int v18 = "True";
      }
      else {
        int v18 = "False";
      }
      if (*(unsigned char *)(v16 + 154)) {
        int v19 = "True";
      }
      else {
        int v19 = "False";
      }
      int v20 = *(unsigned __int8 *)(v16 + 155);
      int v21 = *(unsigned __int8 *)(v16 + 156);
      if (v20) {
        uint64_t v22 = "True";
      }
      else {
        uint64_t v22 = "False";
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
      if (v21) {
        BOOL v23 = "True";
      }
      else {
        BOOL v23 = "False";
      }
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      uint64_t v32 = (uint64_t)v19;
      __int16 v33 = 2080;
      uint64_t v34 = v22;
      __int16 v35 = 2080;
      unint64_t v36 = v23;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I fProfileChangeInProgress = %s, fBlockedByProfileUpdate = %s, fFetchProfilesInProgress = %s, fDeactivationAssertion = %s, fInstallReplaceOperationAssertion = %s", (uint8_t *)&__p, 0x34u);
      uint64_t v16 = *(void *)(a1 + 160);
    }
    uint64_t v24 = *(void *)(v16 + 176);
    if (v24)
    {
      (*(void (**)(uint64_t))(*(void *)v24 + 80))(v24);
    }
    else
    {
      int v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I fReceiptsOperation = none", (uint8_t *)&__p, 2u);
      }
    }
    uint64_t v26 = *(void *)(*(void *)(a1 + 160) + 160);
    if (v26)
    {
      (*(void (**)(uint64_t))(*(void *)v26 + 80))(v26);
    }
    else
    {
      xpc_object_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I fInstallOperation = none", (uint8_t *)&__p, 2u);
      }
    }
  }
  xpc_object_t v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v29 = *(void *)(a1 + 392);
    LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Waiting firmware callbacks: %lu", (uint8_t *)&__p, 0xCu);
    xpc_object_t v28 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v30 = *(void *)(a1 + 232);
    LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v30;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %lu Signed payload operations", (uint8_t *)&__p, 0xCu);
  }
}

void sub_100D38F54(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

unsigned char *sub_100D38F74(unsigned char *result, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (v2 == 2)
  {
    if (*result == 2)
    {
      result[1] = a2[1];
      result[2] = a2[2];
      result[3] = a2[3];
    }
    else
    {
      *uint64_t result = 2;
      __int16 v3 = *(_WORD *)(a2 + 1);
      result[3] = a2[3];
      *(_WORD *)(result + 1) = v3;
    }
  }
  else if (v2 == 1)
  {
    if (*result != 1) {
      *uint64_t result = 1;
    }
    *(_OWORD *)(result + 1) = *(_OWORD *)(a2 + 1);
  }
  return result;
}

char *sub_100D38FF4(char *result, char *a2)
{
  if (result != a2)
  {
    int v2 = *a2;
    if (v2 == 2)
    {
      if (*result != 2)
      {
        char v3 = 2;
        goto LABEL_8;
      }
LABEL_9:
      result[1] = a2[1];
      return result;
    }
    if (v2 == 1)
    {
      if (*result != 1)
      {
        char v3 = 1;
LABEL_8:
        *uint64_t result = v3;
        goto LABEL_9;
      }
      goto LABEL_9;
    }
    *uint64_t result = 0;
  }
  return result;
}

void *sub_100D3904C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v4 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    uint64_t result = sub_1009C886C(a4);
    long long v7 = result;
    *int v4 = result;
    v4[1] = result;
    v4[2] = &result[2 * v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_100D390C8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D390E4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1000D8578();
  }
  uint64_t v5 = (uint64_t)(a1 + 2);
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v2) >> 3);
  if (2 * v6 > v4) {
    unint64_t v4 = 2 * v6;
  }
  if (v6 >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v4;
  }
  BOOL v15 = a1 + 2;
  if (v7) {
    uint64_t v8 = (char *)sub_10004812C(v5, v7);
  }
  else {
    uint64_t v8 = 0;
  }
  int v11 = v8;
  BOOL v12 = &v8[24 * v3];
  int v14 = &v8[24 * v7];
  sub_100058DB0(v12, "8");
  int v13 = v12 + 24;
  sub_100048204(a1, &v11);
  uint64_t v9 = a1[1];
  sub_100048174((uint64_t)&v11);
  return v9;
}

void sub_100D391D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100D391E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100D391F4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D39210(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100D39220(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A52B28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D39240(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A52B28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D39294(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 272);
  if (v2) {
    _Block_release(v2);
  }
  if (*(unsigned char *)(a1 + 216))
  {
    if (*(char *)(a1 + 263) < 0) {
      operator delete(*(void **)(a1 + 240));
    }
    *(unsigned char *)(a1 + 216) = 0;
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 208);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 192);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(unsigned char *)(a1 + 168)) {
    sub_10005CD2C(a1 + 144, *(char **)(a1 + 152));
  }
  if (*(unsigned char *)(a1 + 136))
  {
    unint64_t v6 = (void **)(a1 + 112);
    sub_1000C57C8(&v6);
  }
  uint64_t v5 = *(void **)(a1 + 80);
  if (v5)
  {
    *(void *)(a1 + 88) = v5;
    operator delete(v5);
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
}

void sub_100D3935C(uint64_t a1)
{
  sub_100D38F54(*(const void **)(*(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 6) & 0x3FFFFFFFFFFFFF8))
                               + 8 * (*(void *)(a1 + 32) & 0x1FFLL)));
  int64x2_t v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_10144F900);
  *(int64x2_t *)(a1 + 32) = v2;
  if (v2.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
}

void sub_100D393E0(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a1 + 8) + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v2
                                    + 8);
  if (v3)
  {
    sub_10004D2C8(v3);
    unint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t v4 = *(void *)(a1 + 40) - 1;
  unint64_t v5 = v2 + 1;
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v4;
  if (v5 >= 0x200)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 256;
  }
}

void sub_100D39468()
{
}

void *sub_100D3947C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A52B78;
  result[1] = v3;
  return result;
}

uint64_t sub_100D394C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A52B78;
  a2[1] = v2;
  return result;
}

void sub_100D394F0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Requesting assertions timed out!", buf, 2u);
  }
  while (v1[29])
  {
    sub_100D2EA24(*(void *)(*(void *)(*(void *)(v1[25] + ((v1[28] >> 5) & 0x7FFFFFFFFFFFFF8))+ 16 * v1[28])+ 24), 3);
    sub_100D393E0((uint64_t)(v1 + 24));
  }
  while (v1[35])
  {
    uint64_t v3 = *(void *)(*(void *)(v1[31] + ((v1[34] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v1[34]);
    buf[0] = 0;
    char v12 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    std::string __p = 0;
    sub_10048548C(v3 + 24, (uint64_t)buf, (uint64_t)&__p, 259);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
    if (v12) {
      sub_10026CF54((uint64_t)buf, v11);
    }
    sub_100D393E0((uint64_t)(v1 + 30));
  }
  while (v1[41])
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(v1[37] + ((v1[40] >> 5) & 0x7FFFFFFFFFFFFF8))
                               + 16 * v1[40])
                   + 48);
    __int16 v13 = 770;
    (*(void (**)(void))(v4 + 16))();
    sub_100D393E0((uint64_t)(v1 + 36));
  }
  while (v1[49])
  {
    uint64_t v5 = *(void *)(*(void *)(v1[45] + ((v1[48] >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v1[48] & 0x1FFLL));
    LOBYTE(v13) = 2;
    LOBYTE(v14) = 3;
    (*(void (**)(void))(v5 + 16))();
    if (v13 == 1) {
      sub_100057D78(&v14);
    }
    sub_100D3935C((uint64_t)(v1 + 44));
  }
  unint64_t v6 = (std::__shared_weak_count *)v1[18];
  v1[17] = 0;
  v1[18] = 0;
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100D39710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20)
{
  if (a18 == 1) {
    sub_100057D78(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D3975C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D3979C()
{
}

void *sub_100D397A8(void *a1)
{
  *a1 = off_101A52BF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D397F4(void *a1)
{
  *a1 = off_101A52BF8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100D39860(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A52BF8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D398C4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A52BF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D39904(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D39914(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100D39954(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = a1[2];
      if (v5)
      {
        if (v5 == v2[20])
        {
          *(unsigned char *)(v5 + 152) = 0;
          sub_100D25690(v2);
LABEL_10:
          sub_10004D2C8(v4);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  unint64_t v6 = v2[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; ignoring deactivate profile result.",
      v7,
      2u);
  }
  if (v4) {
    goto LABEL_10;
  }
}

void sub_100D39A0C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D39A20(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D39A60()
{
}

void *sub_100D39A6C(void *a1)
{
  *a1 = off_101A52C78;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D39AB8(void *a1)
{
  *a1 = off_101A52C78;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100D39B24(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A52C78;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D39B88(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A52C78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D39BC8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D39BD8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100D39C18(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = a1[2];
      if (v5)
      {
        if (v5 == v2[20])
        {
          *(unsigned char *)(v5 + 152) = 0;
          sub_100D25690(v2);
LABEL_10:
          sub_10004D2C8(v4);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  unint64_t v6 = v2[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Vinyl model expired; ignoring deactivate profile result.",
      v7,
      2u);
  }
  if (v4) {
    goto LABEL_10;
  }
}

void sub_100D39CD0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D39CE4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D39D24()
{
}

void sub_100D39D30(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100D3A06C(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_10068F434((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        uint64_t v8 = *(_DWORD **)sub_10068FDC4((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_10068FDC4(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_10068FDC4(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_10068F434((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_10068F434((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100D3A06C(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100D3A014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D3A06C(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100D3A0AC(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_10068F3F0(v2);
    if (sub_100690228(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_10068F3F0(v2);
      uint64_t v9 = *(uint64_t **)(sub_100690228(v7) + 8);
      sub_10068F538(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100D3A218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D3A274(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100D3A348(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100D3A368(unsigned char *result, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (v2 == 2)
  {
    if (*result == 2)
    {
      result[1] = a2[1];
      result[2] = a2[2];
      result[3] = a2[3];
    }
    else
    {
      *uint64_t result = 2;
      __int16 v3 = *(_WORD *)(a2 + 1);
      result[3] = a2[3];
      *(_WORD *)(result + 1) = v3;
    }
  }
  else if (v2 == 1)
  {
    if (*result != 1) {
      *uint64_t result = 1;
    }
    result[1] = a2[1];
  }
  return result;
}

uint64_t *sub_100D3A3E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v17 = a1;
  uint64_t v18 = v1;
  int v2 = *(unsigned __int8 *)(v1 + 40);
  if (v2 != 2)
  {
    if (v2 == 1)
    {
      sub_1000C26BC(v1 + 8, 0);
      goto LABEL_11;
    }
    goto LABEL_21;
  }
  uint64_t v3 = *(void *)v1;
  unsigned int v4 = *(unsigned __int8 *)(v1 + 41) - 1;
  if (v4 > 0xA) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = byte_10156923F[(char)v4];
  }
  uint64_t v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = asString();
    int v13 = *(unsigned __int8 *)(v1 + 40);
    if (v13 != 2)
    {
      if (v13 != 1)
      {
LABEL_21:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v15 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_22;
      }
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v15 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_18:
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Activate profile failed error %s (driver error %s)", buf, 0x16u);
  }
  sub_1000C26BC(v1 + 8, v5 | 0x100);
  int v7 = *(unsigned __int8 *)(v1 + 40);
  if (v7 != 2)
  {
    if (v7 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v15 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_22:
LABEL_23:
      __cxa_throw(exception, v16, (void (*)(void *))v15);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    uint64_t v15 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_18;
  }
  if (*(unsigned char *)(v1 + 41) == 2)
  {
    int v8 = *(_DWORD *)(v3 + 80);
    int v9 = *(unsigned __int8 *)(v1 + 42);
    int v10 = *(unsigned __int8 *)(v1 + 43);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    long long v20 = &unk_1019DB198;
    int v21 = v8;
    int v22 = 20;
    int v23 = v9;
    int v24 = v10;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
LABEL_11:
  sub_100D3A6CC(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_100D3A690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3A6CC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3A6CC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    *(unsigned char *)(v1 + 40) = 0;
    sub_1000C6B58((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

unsigned __int8 *sub_100D3A720(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 == 2)
  {
    int v6 = *a1;
    if (v6 == 1)
    {
      int v7 = (void *)*((void *)a1 + 1);
      if (v7)
      {
        *((void *)a1 + 2) = v7;
        operator delete(v7);
      }
    }
    else if (v6 == 2)
    {
      a1[8] = a2[8];
      a1[9] = a2[9];
      a1[10] = a2[10];
      return a1;
    }
    *a1 = 2;
    __int16 v8 = *((_WORD *)a2 + 4);
    a1[10] = a2[10];
    *((_WORD *)a1 + 4) = v8;
    return a1;
  }
  if (v4 == 1)
  {
    __int16 v5 = (__n128 *)(a2 + 8);
    if (*a1 == 1)
    {
      sub_10005C9A4((uint64_t)(a1 + 8), v5);
    }
    else
    {
      *a1 = 1;
      *((void *)a1 + 2) = 0;
      *((void *)a1 + 3) = 0;
      *((void *)a1 + 1) = 0;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
      *((void *)a1 + 3) = *((void *)a2 + 3);
      v5->n128_u64[0] = 0;
      *((void *)a2 + 2) = 0;
      *((void *)a2 + 3) = 0;
    }
  }
  return a1;
}

uint64_t *sub_100D3A800(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 40);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      int v4 = sub_1007519C8(v1 + 48, 0);
      char v5 = v4;
      if (v4)
      {
        int v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = sub_100746C7C(v5);
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Activate profile failed: %s", buf, 0xCu);
        }
        __int16 v7 = 259;
      }
      else
      {
        __int16 v7 = 0;
      }
      sub_1000C26BC(v1 + 8, v7);
      goto LABEL_16;
    }
    goto LABEL_26;
  }
  unsigned int v8 = *(unsigned __int8 *)(v1 + 48) - 1;
  if (v8 > 0xA) {
    __int16 v9 = 0;
  }
  else {
    __int16 v9 = byte_10156923F[(char)v8];
  }
  int v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = asString();
    int v17 = *(unsigned __int8 *)(v1 + 40);
    if (v17 != 2)
    {
      if (v17 != 1)
      {
LABEL_26:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        long long v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_27;
      }
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      long long v19 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_23:
      goto LABEL_28;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Activate profile failed error %s (driver error %s)", buf, 0x16u);
  }
  sub_1000C26BC(v1 + 8, v9 | 0x100);
  int v11 = *(unsigned __int8 *)(v1 + 40);
  if (v11 != 2)
  {
    if (v11 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      long long v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_27:
LABEL_28:
      __cxa_throw(exception, v20, (void (*)(void *))v19);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    long long v19 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_23;
  }
  if (*(unsigned char *)(v1 + 48) == 2)
  {
    int v12 = *(_DWORD *)(v2 + 80);
    int v13 = *(unsigned __int8 *)(v1 + 49);
    int v14 = *(unsigned __int8 *)(v1 + 50);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    int v24 = &unk_1019DB198;
    int v25 = v12;
    int v26 = 14;
    int v27 = v13;
    int v28 = v14;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
LABEL_16:
  sub_100D3AB54(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100D3AB18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3AB54(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3AB54(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 40) == 1)
    {
      uint64_t v2 = *(void **)(v1 + 48);
      if (v2)
      {
        *(void *)(v1 + 56) = v2;
        operator delete(v2);
      }
    }
    *(unsigned char *)(v1 + 40) = 0;
    sub_1000C6B58((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100D3ABC4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v17 = a1;
  uint64_t v18 = v1;
  int v2 = *(unsigned __int8 *)(v1 + 8);
  if (v2 != 2)
  {
    if (v2 == 1)
    {
      sub_1000C26BC(v1 + 16, 0);
      goto LABEL_11;
    }
    goto LABEL_21;
  }
  uint64_t v3 = *(void *)v1;
  unsigned int v4 = *(unsigned __int8 *)(v1 + 9) - 1;
  if (v4 > 0xA) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = byte_10156923F[(char)v4];
  }
  int v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = asString();
    int v13 = *(unsigned __int8 *)(v1 + 8);
    if (v13 != 2)
    {
      if (v13 != 1)
      {
LABEL_21:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v15 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_22;
      }
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v15 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_18:
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Deactivate profile failed error %s (driver error %s)", buf, 0x16u);
  }
  sub_1000C26BC(v1 + 16, v5 | 0x100);
  int v7 = *(unsigned __int8 *)(v1 + 8);
  if (v7 != 2)
  {
    if (v7 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v15 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_22:
LABEL_23:
      __cxa_throw(exception, v16, (void (*)(void *))v15);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    uint64_t v15 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_18;
  }
  if (*(unsigned char *)(v1 + 9) == 2)
  {
    int v8 = *(_DWORD *)(v3 + 80);
    int v9 = *(unsigned __int8 *)(v1 + 10);
    int v10 = *(unsigned __int8 *)(v1 + 11);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    long long v20 = &unk_1019DB198;
    int v21 = v8;
    int v22 = 21;
    int v23 = v9;
    int v24 = v10;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
LABEL_11:
  sub_100D3AEAC(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_100D3AE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3AEAC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3AEAC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000C6B58((void *)(v1 + 16));
    *(unsigned char *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_100D3AF00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      int v4 = sub_1007519C8(v1 + 16, 1);
      char v5 = v4;
      if (v4)
      {
        int v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = sub_100746C7C(v5);
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Deactivate profile failed: %s", buf, 0xCu);
        }
        __int16 v7 = 259;
      }
      else
      {
        __int16 v7 = 0;
      }
      sub_1000C26BC(v1 + 40, v7);
      goto LABEL_16;
    }
    goto LABEL_26;
  }
  unsigned int v8 = *(unsigned __int8 *)(v1 + 16) - 1;
  if (v8 > 0xA) {
    __int16 v9 = 0;
  }
  else {
    __int16 v9 = byte_10156923F[(char)v8];
  }
  int v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = asString();
    int v17 = *(unsigned __int8 *)(v1 + 8);
    if (v17 != 2)
    {
      if (v17 != 1)
      {
LABEL_26:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        long long v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
        goto LABEL_27;
      }
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      long long v19 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_23:
      goto LABEL_28;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Deactivate profile failed error %s (driver error %s)", buf, 0x16u);
  }
  sub_1000C26BC(v1 + 40, v9 | 0x100);
  int v11 = *(unsigned __int8 *)(v1 + 8);
  if (v11 != 2)
  {
    if (v11 != 1)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      long long v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_27:
LABEL_28:
      __cxa_throw(exception, v20, (void (*)(void *))v19);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    long long v19 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_23;
  }
  if (*(unsigned char *)(v1 + 16) == 2)
  {
    int v12 = *(_DWORD *)(v2 + 80);
    int v13 = *(unsigned __int8 *)(v1 + 17);
    int v14 = *(unsigned __int8 *)(v1 + 18);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    int v24 = &unk_1019DB198;
    int v25 = v12;
    int v26 = 15;
    int v27 = v13;
    int v28 = v14;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
LABEL_16:
  sub_100D3B254(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100D3B218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3B254(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3B254(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000C6B58((void *)(v1 + 40));
    if (*(unsigned char *)(v1 + 8) == 1)
    {
      uint64_t v2 = *(void **)(v1 + 16);
      if (v2)
      {
        *(void *)(v1 + 24) = v2;
        operator delete(v2);
      }
    }
    *(unsigned char *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_100D3B2C4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v23 = a1;
  uint64_t v24 = v1;
  uint64_t v2 = *(void **)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  if (v3 == 2)
  {
    unsigned int v7 = *(unsigned __int8 *)(v1 + 16) - 1;
    if (v7 > 0xA) {
      uint8_t v8 = 0;
    }
    else {
      uint8_t v8 = byte_10156923F[(char)v7];
    }
    __int16 v9 = v2[5];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    uint64_t v13 = asString();
    int v14 = *(unsigned __int8 *)(v1 + 8);
    if (v14 == 2)
    {
      uint64_t v15 = (const char *)v13;
      uint64_t v16 = asString();
      int v17 = *(unsigned __int8 *)(v1 + 8);
      if (v17 == 2)
      {
        int v18 = *(unsigned __int8 *)(v1 + 17);
        int v19 = *(unsigned __int8 *)(v1 + 18);
        *(_DWORD *)long long buf = 136315906;
        int v26 = v15;
        __int16 v27 = 2080;
        uint64_t v28 = v16;
        __int16 v29 = 1024;
        int v30 = v18;
        __int16 v31 = 1024;
        int v32 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "tapeSetProprietaryData error %s (driver error %s), SW1:%x, SW2:%x", buf, 0x22u);
LABEL_11:
        buf[0] = 2;
        buf[1] = v8;
        goto LABEL_12;
      }
      if (v17 != 1) {
        goto LABEL_25;
      }
    }
    else if (v14 != 1)
    {
      goto LABEL_25;
    }
    exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    int v21 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_26;
  }
  if (v3 != 1)
  {
LABEL_25:
    exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    int v21 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_26:
    __cxa_throw(exception, v22, (void (*)(void *))v21);
  }
  int v4 = sub_100754BE4(v1 + 16);
  char v5 = v4;
  if (!v4)
  {
    *(_WORD *)long long buf = 257;
    uint64_t v12 = *(void *)(v1 + 64);
    if (v12)
    {
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v12 + 48))(v12, buf);
      buf[0] = 0;
      sub_100D25690(v2);
      goto LABEL_14;
    }
LABEL_20:
    sub_10007B600();
  }
  int v6 = v2[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    int v26 = sub_100746C7C(v5);
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Set proprietary data failed: %s", buf, 0xCu);
  }
  *(_WORD *)long long buf = 770;
LABEL_12:
  uint64_t v10 = *(void *)(v1 + 64);
  if (!v10) {
    goto LABEL_20;
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 48))(v10, buf);
LABEL_14:
  sub_100D3B624(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_100D3B5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3B624(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3B624(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000C752C((void *)(v1 + 40));
    if (*(unsigned char *)(v1 + 8) == 1)
    {
      uint64_t v2 = *(void **)(v1 + 16);
      if (v2)
      {
        *(void *)(v1 + 24) = v2;
        operator delete(v2);
      }
    }
    *(unsigned char *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

void sub_100D3B694(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A52CF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D3B6B4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A52CF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D3B708(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100D3B730(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A52D48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D3B750(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A52D48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D3B7A4(void *a1)
{
  uint64_t v2 = (const void *)a1[6];
  if (v2) {
    _Block_release(v2);
  }
  int v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
}

uint64_t *sub_100D3B800(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 24);
  if (v3 == 2)
  {
    unsigned int v8 = *(unsigned __int8 *)(v1 + 32) - 1;
    if (v8 > 0xA) {
      char v9 = 0;
    }
    else {
      char v9 = byte_10156923F[(char)v8];
    }
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = asString();
      int v12 = *(unsigned __int8 *)(v1 + 24);
      if (v12 != 2)
      {
        if (v12 != 1)
        {
LABEL_30:
          exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
          int v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          goto LABEL_31;
        }
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        int v19 = &ctu::ResultIsNotError::~ResultIsNotError;
        ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_28:
        goto LABEL_32;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sign Id map failed with error %s  (driver error %s)", buf, 0x16u);
    }
    sub_100D2EA24(*(void *)(*(void *)(v1 + 8) + 24), v9);
    int v13 = *(unsigned __int8 *)(v1 + 24);
    if (v13 == 2)
    {
      if (*(unsigned char *)(v1 + 32) == 2)
      {
        int v14 = *(_DWORD *)(v2 + 80);
        int v15 = *(unsigned __int8 *)(v1 + 33);
        int v16 = *(unsigned __int8 *)(v1 + 34);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_1004F09E8;
        uint64_t v24 = &unk_1019DB198;
        int v25 = v14;
        int v26 = 16;
        int v27 = v15;
        int v28 = v16;
        sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
      goto LABEL_20;
    }
    if (v13 != 1)
    {
LABEL_29:
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      int v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_31:
LABEL_32:
      __cxa_throw(exception, v20, (void (*)(void *))v19);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    int v19 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_28;
  }
  if (v3 != 1) {
    goto LABEL_30;
  }
  int v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sign Id map generated", buf, 2u);
    int v5 = *(unsigned __int8 *)(v1 + 24);
    if (v5 != 1)
    {
      if (v5 == 2)
      {
LABEL_25:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        int v19 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
        goto LABEL_32;
      }
      goto LABEL_29;
    }
  }
  uint64_t v6 = *(void *)(v2 + 344);
  if (v6)
  {
    sub_100EE8BC8(v6, "SignIdResult");
    int v7 = *(unsigned __int8 *)(v1 + 24);
    if (v7 != 1)
    {
      if (v7 == 2) {
        goto LABEL_25;
      }
      goto LABEL_29;
    }
  }
  else
  {
    *(void *)(v2 + 344) = 0;
  }
  sub_100D3BC8C(*(void *)(*(void *)(v1 + 8) + 24), (char **)(v1 + 32));
LABEL_20:
  sub_100D25F88(v2, 0);
  sub_100D3BC18(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100D3BBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3BC18(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3BC18(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 24) == 1)
    {
      uint64_t v2 = *(void **)(v1 + 32);
      if (v2)
      {
        *(void *)(v1 + 40) = v2;
        operator delete(v2);
      }
    }
    *(unsigned char *)(v1 + 24) = 0;
    int v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

void sub_100D3BC8C(uint64_t a1, char **a2)
{
  v3[0] = 0;
  sub_1000C59A0((uint64_t)v3, a2);
  (*(void (**)(uint64_t, unsigned char *))(a1 + 16))(a1, v3);
  if (v3[0] == 1)
  {
    if (__p)
    {
      int v5 = __p;
      operator delete(__p);
    }
  }
}

void sub_100D3BCF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *__p, uint64_t a11)
{
  if (a9 == 1 && __p != 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100D3BD1C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 24);
  if (v3 == 2)
  {
    unsigned int v8 = *(unsigned __int8 *)(v1 + 32) - 1;
    if (v8 > 0xA) {
      char v9 = 0;
    }
    else {
      char v9 = byte_10156923F[(char)v8];
    }
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = asString();
      int v12 = *(unsigned __int8 *)(v1 + 24);
      if (v12 != 2)
      {
        if (v12 != 1)
        {
LABEL_30:
          exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
          int v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
          ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          goto LABEL_31;
        }
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        int v19 = &ctu::ResultIsNotError::~ResultIsNotError;
        ctu::ResultIsNotError::ResultIsNotError(exception);
LABEL_28:
        goto LABEL_32;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SignPayload failed with error %s  (driver error %s)", buf, 0x16u);
    }
    sub_100D2EA24(*(void *)(*(void *)(v1 + 8) + 24), v9);
    int v13 = *(unsigned __int8 *)(v1 + 24);
    if (v13 == 2)
    {
      if (*(unsigned char *)(v1 + 32) == 2)
      {
        int v14 = *(_DWORD *)(v2 + 80);
        int v15 = *(unsigned __int8 *)(v1 + 33);
        int v16 = *(unsigned __int8 *)(v1 + 34);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_1004F09E8;
        uint64_t v24 = &unk_1019DB198;
        int v25 = v14;
        int v26 = 129;
        int v27 = v15;
        int v28 = v16;
        sub_1004F0808((wis::MetricFactory *)0x800F1);
      }
      goto LABEL_20;
    }
    if (v13 != 1)
    {
LABEL_29:
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      int v19 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_31:
LABEL_32:
      __cxa_throw(exception, v20, (void (*)(void *))v19);
    }
    exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    int v19 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(exception);
    goto LABEL_28;
  }
  if (v3 != 1) {
    goto LABEL_30;
  }
  int v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Signed payload generated", buf, 2u);
    int v5 = *(unsigned __int8 *)(v1 + 24);
    if (v5 != 1)
    {
      if (v5 == 2)
      {
LABEL_25:
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        int v19 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
        goto LABEL_32;
      }
      goto LABEL_29;
    }
  }
  uint64_t v6 = *(void *)(v2 + 344);
  if (v6)
  {
    sub_100EE8BC8(v6, "SignIdResult");
    int v7 = *(unsigned __int8 *)(v1 + 24);
    if (v7 != 1)
    {
      if (v7 == 2) {
        goto LABEL_25;
      }
      goto LABEL_29;
    }
  }
  else
  {
    *(void *)(v2 + 344) = 0;
  }
  sub_100D3BC8C(*(void *)(*(void *)(v1 + 8) + 24), (char **)(v1 + 32));
LABEL_20:
  sub_100D25F88(v2, 0);
  sub_100D3BC18(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100D3C0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  sub_100D3BC18(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100D3C134(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A52D98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D3C154(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A52D98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D3C1A8(void *a1)
{
  sub_100491448(a1 + 6);
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
}

uint64_t *sub_100D3C1FC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v26 = a1;
  uint64_t v27 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 40);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      int v4 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)
        || (*(_WORD *)long long buf = 0,
            _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SecureAuth generated", buf, 2u),
            int v5 = *(unsigned __int8 *)(v1 + 40),
            v5 == 1))
      {
        uint64_t v6 = *(void *)(v2 + 344);
        if (v6)
        {
          sub_100EE8BC8(v6, "SecureAuthRsp");
          int v7 = *(unsigned __int8 *)(v1 + 40);
          int v28 = 0;
          __int16 v29 = 0;
          uint64_t v30 = 0;
          std::string __p = 0;
          int64_t v37 = 0;
          uint64_t v38 = 0;
          __int16 v35 = 0;
          if (v7 != 1)
          {
            if (v7 == 2)
            {
              exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
              char v9 = &ctu::ResultIsError::~ResultIsError;
              ctu::ResultIsError::ResultIsError(exception);
            }
            else
            {
              exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
              char v9 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
              ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
            }
            __cxa_throw(exception, v10, (void (*)(void *))v9);
          }
        }
        else
        {
          *(void *)(v2 + 344) = 0;
          int v28 = 0;
          __int16 v29 = 0;
          uint64_t v30 = 0;
          std::string __p = 0;
          int64_t v37 = 0;
          uint64_t v38 = 0;
          __int16 v35 = 0;
        }
        int v20 = sub_1003F0DD0(v1 + 48, (uint64_t)&v28, (uint64_t)&__p, &v35);
        if (v20)
        {
          int v21 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v20;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Decode secure auth failed: %d", buf, 8u);
          }
          buf[0] = 0;
          LOBYTE(v40) = 0;
          __int16 v33 = 0;
          uint64_t v34 = 0;
          int v32 = 0;
          sub_10048548C(v1 + 8, (uint64_t)buf, (uint64_t)&v32, 259);
        }
        else
        {
          subscriber::sDecodeEapAka();
          int v32 = 0;
          __int16 v33 = 0;
          uint64_t v34 = 0;
          sub_10005C928(&v32, __p, (uint64_t)v37, v37 - (unsigned char *)__p);
          sub_10048548C(v1 + 8, (uint64_t)buf, (uint64_t)&v32, 0);
        }
        if (v32)
        {
          __int16 v33 = v32;
          operator delete(v32);
        }
        if ((_BYTE)v40) {
          sub_10026CF54((uint64_t)buf, *(void **)&buf[8]);
        }
        if (__p)
        {
          int64_t v37 = __p;
          operator delete(__p);
        }
        if (v28)
        {
          __int16 v29 = v28;
          operator delete(v28);
        }
        goto LABEL_36;
      }
      if (v5 == 2)
      {
        int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v24 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(v23);
        goto LABEL_51;
      }
      int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  unsigned int v11 = *(unsigned __int8 *)(v1 + 48) - 1;
  if (v11 > 0xA) {
    __int16 v12 = 0;
  }
  else {
    __int16 v12 = byte_10156923F[(char)v11];
  }
  int v13 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    int v15 = *(unsigned __int8 *)(v1 + 40);
    if (v15 != 2)
    {
      if (v15 != 1)
      {
LABEL_49:
        int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
        goto LABEL_50;
      }
      int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(v23);
LABEL_44:
      goto LABEL_51;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I SecureAuth failed with error %s  (driver error %s)", buf, 0x16u);
  }
  LOBYTE(v28) = 0;
  char v31 = 0;
  int64_t v37 = 0;
  uint64_t v38 = 0;
  std::string __p = 0;
  sub_10048548C(v1 + 8, (uint64_t)&v28, (uint64_t)&__p, v12 | 0x100);
  if (__p)
  {
    int64_t v37 = __p;
    operator delete(__p);
  }
  if (v31) {
    sub_10026CF54((uint64_t)&v28, v29);
  }
  int v16 = *(unsigned __int8 *)(v1 + 40);
  if (v16 != 2)
  {
    if (v16 != 1)
    {
      int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v24 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(v23);
LABEL_50:
LABEL_51:
      __cxa_throw(v23, v25, (void (*)(void *))v24);
    }
    int v23 = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
    uint64_t v24 = &ctu::ResultIsNotError::~ResultIsNotError;
    ctu::ResultIsNotError::ResultIsNotError(v23);
    goto LABEL_44;
  }
  if (*(unsigned char *)(v1 + 48) == 2)
  {
    int v17 = *(_DWORD *)(v2 + 80);
    int v18 = *(unsigned __int8 *)(v1 + 49);
    int v19 = *(unsigned __int8 *)(v1 + 50);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1004F09E8;
    __int16 v40 = &unk_1019DB198;
    int v41 = v17;
    int v42 = 65;
    int v43 = v18;
    int v44 = v19;
    sub_1004F0808((wis::MetricFactory *)0x800F1);
  }
LABEL_36:
  sub_100D25F88(v2, 0);
  sub_100D3C830(&v27);
  return sub_100046B58((uint64_t *)&v26);
}

void sub_100D3C74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26)
{
  __cxa_free_exception(v26);
  sub_100D3C830(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D3C830(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 40) == 1)
    {
      uint64_t v2 = *(void **)(v1 + 48);
      if (v2)
      {
        *(void *)(v1 + 56) = v2;
        operator delete(v2);
      }
    }
    *(unsigned char *)(v1 + 40) = 0;
    sub_100491448((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100D3C8A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A52DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D3C8C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A52DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D3C914(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 72);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    int v3 = *(void **)(a1 + 24);
    operator delete(v3);
  }
}

std::string *sub_100D3C980(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
    uint64_t result = std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 16));
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 40);
  }
  else
  {
    return (std::string *)sub_1003DBF48(a1, a2);
  }
  return result;
}

const void **sub_100D3C9EC(uint64_t a1, const void **a2)
{
  if (*(unsigned char *)a1 == 1) {
    return sub_1003C5CD0((const void **)(a1 + 8), a2);
  }
  *(unsigned char *)a1 = 1;
  return sub_10002FD9C((const void **)(a1 + 8), a2);
}

const char *asString(unsigned int a1)
{
  if (a1 > 0xD) {
    return "???";
  }
  else {
    return off_101A52E80[a1];
  }
}

CFStringRef sub_100D3CA30(int a1, int a2)
{
  switch(a2)
  {
    case 0:
      return @"None";
    case 2:
      if (a1 == 1) {
        return @"NITZ-1";
      }
      if (a1 == 2) {
        return @"NITZ-2";
      }
      int v3 = &type metadata for __ObjC;
      break;
    case 1:
      if (a1 == 1) {
        return @"CDMA-1";
      }
      if (a1 == 2) {
        return @"CDMA-2";
      }
      int v3 = &type metadata for __ObjC;
      break;
    default:
      return @"Invalid";
  }
  return *(const __CFString **)v3;
}

CFStringRef sub_100D3CAC8(int a1)
{
  switch(a1)
  {
    case 0:
      return @"None";
    case 2:
      uint64_t v1 = &type metadata for __ObjC;
      return *(const __CFString **)v1;
    case 1:
      uint64_t v1 = &type metadata for __ObjC;
      return *(const __CFString **)v1;
  }
  return @"Invalid";
}

uint64_t sub_100D3CB10(uint64_t a1, uint64_t a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v52, (const OsLogContext *)&buf);
  int v4 = (os_log_t *)(a1 + 56);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 56), (const ctu::OsLogLogger *)v52);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v52);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  int v50 = 0;
  uint64_t v51 = 0;
  std::string __p = 0;
  sub_10010556C(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  sub_10010549C((void *)a1, (uint64_t)&__p);
  if (__p)
  {
    int v50 = __p;
    operator delete(__p);
  }
  *(void *)(a1 + 64) = 0;
  int v5 = (void **)(a1 + 64);
  *(void *)a1 = off_101A52F00;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v6 = *(char **)a2;
  int v7 = *(char **)(a2 + 8);
  uint64_t v8 = (uint64_t)&v7[-*(void *)a2];
  if ((v8 & 8) != 0)
  {
    char v9 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid length of lat/long. last coordinate ignored...", (uint8_t *)&buf, 2u);
      uint64_t v6 = *(char **)a2;
      int v7 = *(char **)(a2 + 8);
    }
    v7 -= 8;
    *(void *)(a2 + 8) = v7;
    uint64_t v8 = v7 - v6;
  }
  if ((unint64_t)v8 <= 0x17)
  {
    uint64_t v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Polygon missing minimum vertices.", (uint8_t *)&buf, 2u);
    }
    return a1;
  }
  unsigned int v11 = &v6[8 * (v8 >> 3)];
  if (*(void *)v6 != *((void *)v11 - 2) || *((void *)v6 + 1) != *((void *)v11 - 1))
  {
    __int16 v12 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Polygon not closed. Force closing the polygon by repeating the first coordinates", (uint8_t *)&buf, 2u);
      uint64_t v6 = *(char **)a2;
      int v7 = *(char **)(a2 + 8);
    }
    int v13 = *(char **)(a2 + 16);
    if (v7 >= v13)
    {
      uint64_t v15 = (v7 - v6) >> 3;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        goto LABEL_72;
      }
      uint64_t v17 = v13 - v6;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        int v19 = (char *)sub_10004EF74(a2 + 16, v18);
        int v20 = *(char **)a2;
        int v7 = *(char **)(a2 + 8);
      }
      else
      {
        int v19 = 0;
        int v20 = v6;
      }
      int v21 = &v19[8 * v15];
      int v13 = &v19[8 * v18];
      *(void *)int v21 = *(void *)v6;
      uint64_t v14 = v21 + 8;
      while (v7 != v20)
      {
        uint64_t v22 = *((void *)v7 - 1);
        v7 -= 8;
        *((void *)v21 - 1) = v22;
        v21 -= 8;
      }
      *(void *)a2 = v21;
      *(void *)(a2 + 8) = v14;
      *(void *)(a2 + 16) = v13;
      if (v20)
      {
        operator delete(v20);
        uint64_t v6 = *(char **)a2;
        int v13 = *(char **)(a2 + 16);
      }
      else
      {
        uint64_t v6 = v21;
      }
    }
    else
    {
      *(void *)int v7 = *(void *)v6;
      uint64_t v14 = v7 + 8;
    }
    *(void *)(a2 + 8) = v14;
    if (v14 < v13)
    {
      *(void *)uint64_t v14 = *((void *)v6 + 1);
      int v7 = v14 + 8;
LABEL_47:
      *(void *)(a2 + 8) = v7;
      uint64_t v6 = *(char **)a2;
      goto LABEL_48;
    }
    uint64_t v23 = (v14 - v6) >> 3;
    unint64_t v24 = v23 + 1;
    if (!((unint64_t)(v23 + 1) >> 61))
    {
      uint64_t v25 = v13 - v6;
      if (v25 >> 2 > v24) {
        unint64_t v24 = v25 >> 2;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v24;
      }
      if (v26)
      {
        uint64_t v27 = (char *)sub_10004EF74(a2 + 16, v26);
        int v28 = *(char **)a2;
        uint64_t v14 = *(char **)(a2 + 8);
      }
      else
      {
        uint64_t v27 = 0;
        int v28 = v6;
      }
      __int16 v29 = &v27[8 * v23];
      uint64_t v30 = &v27[8 * v26];
      *(void *)__int16 v29 = *((void *)v6 + 1);
      int v7 = v29 + 8;
      while (v14 != v28)
      {
        uint64_t v31 = *((void *)v14 - 1);
        v14 -= 8;
        *((void *)v29 - 1) = v31;
        v29 -= 8;
      }
      *(void *)a2 = v29;
      *(void *)(a2 + 8) = v7;
      *(void *)(a2 + 16) = v30;
      if (v28) {
        operator delete(v28);
      }
      goto LABEL_47;
    }
LABEL_72:
    sub_10010562C();
  }
LABEL_48:
  if (v7 != v6)
  {
    uint64_t v32 = 0;
    unsigned __int8 v33 = 0;
    uint64_t v34 = (void *)(a1 + 80);
    __int16 v35 = *(double **)(a1 + 72);
    do
    {
      double v36 = (double)(unint64_t)(180 * *(void *)&v6[8 * v32]) * 0.000000238418579 + -90.0;
      double v37 = (double)(unint64_t)(360 * *(void *)&v6[8 * (v33 | 1)]) * 0.000000238418579 + -180.0;
      if ((unint64_t)v35 >= *v34)
      {
        uint64_t v38 = (double *)*v5;
        uint64_t v39 = ((char *)v35 - (unsigned char *)*v5) >> 4;
        unint64_t v40 = v39 + 1;
        if ((unint64_t)(v39 + 1) >> 60) {
          sub_100408264();
        }
        uint64_t v41 = *v34 - (void)v38;
        if (v41 >> 3 > v40) {
          unint64_t v40 = v41 >> 3;
        }
        if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v42 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v42 = v40;
        }
        if (v42)
        {
          int v43 = (char *)sub_10006A794(a1 + 80, v42);
          uint64_t v38 = *(double **)(a1 + 64);
          __int16 v35 = *(double **)(a1 + 72);
        }
        else
        {
          int v43 = 0;
        }
        int v44 = (double *)&v43[16 * v39];
        *int v44 = v36;
        v44[1] = v37;
        uint64_t v45 = v44;
        if (v35 != v38)
        {
          do
          {
            *((_OWORD *)v45 - 1) = *((_OWORD *)v35 - 1);
            v45 -= 2;
            v35 -= 2;
          }
          while (v35 != v38);
          uint64_t v38 = (double *)*v5;
        }
        __int16 v35 = v44 + 2;
        *(void *)(a1 + 64) = v45;
        *(void *)(a1 + 72) = v44 + 2;
        *(void *)(a1 + 80) = &v43[16 * v42];
        if (v38) {
          operator delete(v38);
        }
      }
      else
      {
        *__int16 v35 = v36;
        v35[1] = v37;
        v35 += 2;
      }
      *(void *)(a1 + 72) = v35;
      v33 += 2;
      uint64_t v32 = v33;
      uint64_t v6 = *(char **)a2;
    }
    while (v33 < (unint64_t)((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
  sub_101230220((uint64_t *)(a1 + 64), &buf);
  char v46 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v46);
  }
  *(_OWORD *)char v46 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  *(void *)(a1 + 48) = *((void *)&buf.__r_.__value_.__l + 2);
  return a1;
}

void sub_100D3D018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  int v21 = *v19;
  if (*v19)
  {
    *(void *)(v18 + 72) = v21;
    operator delete(v21);
  }
  sub_100105504(v18);
  ctu::OsLogLogger::~OsLogLogger(a10);
  _Unwind_Resume(a1);
}

void *sub_100D3D07C(void *a1)
{
  *a1 = off_101A52F00;
  uint64_t v2 = (void *)a1[8];
  if (v2)
  {
    a1[9] = v2;
    operator delete(v2);
  }
  sub_100105504((uint64_t)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 7));
  return a1;
}

void sub_100D3D0E0(void *a1)
{
  sub_100D3D07C(a1);

  operator delete();
}

uint64_t sub_100D3D118@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  *(_OWORD *)unint64_t v40 = 0u;
  long long v41 = 0u;
  memset(v39, 0, sizeof(v39));
  long long v38 = 0u;
  sub_10004BD84((uint64_t)&v38);
  (*(void (**)(long long *__return_ptr, void *))(*a1 + 16))(&v53, a1);
  if (SHIBYTE(v54) >= 0) {
    int v4 = &v53;
  }
  else {
    int v4 = (long long *)v53;
  }
  if (SHIBYTE(v54) >= 0) {
    uint64_t v5 = HIBYTE(v54);
  }
  else {
    uint64_t v5 = *((void *)&v53 + 1);
  }
  sub_10004B96C(v39, (uint64_t)v4, v5);
  if (SHIBYTE(v54) < 0) {
    operator delete((void *)v53);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1[9] != a1[8])
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      if (v7 && 50 * (v7 / 0x32) == v7)
      {
        sub_10004BC98((uint64_t)v39 + 8, __p);
        unint64_t v9 = a2[1];
        unint64_t v8 = a2[2];
        if (v9 >= v8)
        {
          unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *a2) >> 3);
          unint64_t v12 = v11 + 1;
          if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *a2) >> 3);
          if (2 * v13 > v12) {
            unint64_t v12 = 2 * v13;
          }
          if (v13 >= 0x555555555555555) {
            unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v14 = v12;
          }
          uint64_t v56 = a2 + 2;
          if (v14) {
            uint64_t v15 = (char *)sub_10004812C((uint64_t)(a2 + 2), v14);
          }
          else {
            uint64_t v15 = 0;
          }
          unint64_t v16 = &v15[24 * v11];
          *(void *)&long long v53 = v15;
          *((void *)&v53 + 1) = v16;
          uint64_t v55 = &v15[24 * v14];
          long long v17 = *(_OWORD *)__p;
          *((void *)v16 + 2) = v37;
          *(_OWORD *)unint64_t v16 = v17;
          __p[1] = 0;
          uint64_t v37 = 0;
          __p[0] = 0;
          BOOL v54 = v16 + 24;
          sub_100048204(a2, &v53);
          uint64_t v18 = a2[1];
          sub_100048174((uint64_t)&v53);
          int v19 = SHIBYTE(v37);
          a2[1] = v18;
          if (v19 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v10 = *(_OWORD *)__p;
          *(void *)(v9 + 16) = v37;
          *(_OWORD *)unint64_t v9 = v10;
          a2[1] = v9 + 24;
        }
        long long v53 = 0uLL;
        BOOL v54 = 0;
        sub_1004FD2F4((uint64_t)v39 + 8, &v53);
        if (SHIBYTE(v54) < 0) {
          operator delete((void *)v53);
        }
        std::ios_base::clear((std::ios_base *)((char *)&v39[-1] + *(void *)(v38 - 24)), 0);
        sub_10004B96C(v39, (uint64_t)"    ", 4);
      }
      sub_10004B96C(v39, (uint64_t)"[", 1);
      int v20 = (void *)std::ostream::operator<<();
      sub_10004B96C(v20, (uint64_t)", ", 2);
      int v21 = (void *)std::ostream::operator<<();
      sub_10004B96C(v21, (uint64_t)"] ", 2);
      ++v7;
      v6 += 16;
    }
    while (v7 < (uint64_t)(a1[9] - a1[8]) >> 4);
  }
  sub_10004BC98((uint64_t)v39 + 8, __p);
  unint64_t v22 = a2[2];
  unint64_t v23 = a2[1];
  if (v23 >= v22)
  {
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - *a2) >> 3);
    unint64_t v26 = v25 + 1;
    if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - *a2) >> 3);
    if (2 * v27 > v26) {
      unint64_t v26 = 2 * v27;
    }
    if (v27 >= 0x555555555555555) {
      unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v28 = v26;
    }
    uint64_t v56 = a2 + 2;
    if (v28) {
      __int16 v29 = (char *)sub_10004812C((uint64_t)(a2 + 2), v28);
    }
    else {
      __int16 v29 = 0;
    }
    uint64_t v30 = &v29[24 * v25];
    *(void *)&long long v53 = v29;
    *((void *)&v53 + 1) = v30;
    uint64_t v55 = &v29[24 * v28];
    long long v31 = *(_OWORD *)__p;
    *((void *)v30 + 2) = v37;
    *(_OWORD *)uint64_t v30 = v31;
    __p[1] = 0;
    uint64_t v37 = 0;
    __p[0] = 0;
    BOOL v54 = v30 + 24;
    sub_100048204(a2, &v53);
    uint64_t v32 = a2[1];
    sub_100048174((uint64_t)&v53);
    int v33 = SHIBYTE(v37);
    a2[1] = v32;
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v24 = *(_OWORD *)__p;
    *(void *)(v23 + 16) = v37;
    *(_OWORD *)unint64_t v23 = v24;
    a2[1] = v23 + 24;
  }
  *(void *)((char *)&v39[-1]
  *(void *)&v39[0] = v34;
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100D3D65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_100048174(v16 - 136);
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100047F64((void ***)&__p);
  sub_10008248C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

char *sub_100D3D6EC@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[55] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 4), *((void *)result + 5));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 2);
  *(void *)(a2 + 16) = *((void *)result + 6);
  return result;
}

void AudioController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D3DC90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

const char *sub_100D3DF04(int a1)
{
  uint64_t v1 = "audio.controller.?";
  if (a1 == 2) {
    uint64_t v1 = "audio.controller.2";
  }
  if (a1 == 1) {
    return "audio.controller.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100D3DF30(uint64_t a1)
{
  *(void *)a1 = off_101A52F78;
  *(void *)(a1 + 56) = off_101A530A0;
  sub_10005D144(*(void **)(a1 + 368));
  uint64_t v2 = *(void **)(a1 + 336);
  if (v2)
  {
    *(void *)(a1 + 344) = v2;
    operator delete(v2);
  }
  sub_10019D5B8(a1 + 312, *(void **)(a1 + 320));
  sub_10003FB28(a1 + 288, *(void **)(a1 + 296));
  sub_1000346F8(a1 + 256, *(void **)(a1 + 264));
  int v3 = *(std::__shared_weak_count **)(a1 + 240);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10005CD2C(a1 + 208, *(char **)(a1 + 216));
  int v4 = *(std::__shared_weak_count **)(a1 + 200);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 144);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 128);
  if (v7) {
    sub_10004D2C8(v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 112);
  if (v8) {
    sub_10004D2C8(v8);
  }
  unint64_t v9 = *(std::__shared_weak_count **)(a1 + 96);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100160A84((atomic_uint **)(a1 + 64));
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100D3E07C(uint64_t a1)
{
  return sub_100D3DF30(a1 - 56);
}

void sub_100D3E084(uint64_t a1)
{
  sub_100D3DF30(a1);

  operator delete();
}

void sub_100D3E0BC(uint64_t a1)
{
  sub_100D3DF30(a1 - 56);

  operator delete();
}

void sub_100D3E0F8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D3E1F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  v6[0] = a1;
  v6[1] = v3;
  unint64_t v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100D4466C;
  block[3] = &unk_101A53410;
  block[4] = a1 + 8;
  block[5] = v6;
  uint64_t v5 = a1 + 24;
  int v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100D3E2A4(uint64_t a1, uint64_t *a2)
{
}

void sub_100D3E2AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D3E3B0(uint64_t a1)
{
}

void sub_100D3E3B8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 168);
    int v3 = *(_DWORD *)(a1 + 172);
    int v6 = *(_DWORD *)(a1 + 176);
    int v5 = *(_DWORD *)(a1 + 180);
    int v7 = *(_DWORD *)(a1 + 184);
    uint64_t v8 = *(int *)(a1 + 188);
    if (v8 > 2) {
      unint64_t v9 = "AudioStackType Undefined";
    }
    else {
      unint64_t v9 = off_101A53A58[v8];
    }
    int v12 = 67110658;
    if (sub_100D40F50(a1)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    *(_DWORD *)unint64_t v13 = v4;
    *(_WORD *)&void v13[4] = 1024;
    *(_DWORD *)&void v13[6] = v3;
    __int16 v14 = 1024;
    int v15 = v6;
    __int16 v16 = 1024;
    int v17 = v7;
    __int16 v18 = 1024;
    int v19 = v5;
    __int16 v20 = 2080;
    int v21 = v9;
    __int16 v22 = 2080;
    unint64_t v23 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Vocoder info: type: %d, sample rate: %d I2S Clock Rate: %d, EVS UL Bandwidth: %d, EVS DL Bandwidth: %d, stack: %s, audio logging enabled: %s", (uint8_t *)&v12, 0x34u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 280)) {
      unint64_t v11 = "true";
    }
    else {
      unint64_t v11 = "false";
    }
    int v12 = 136315138;
    *(void *)unint64_t v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Driver ready: %s", (uint8_t *)&v12, 0xCu);
  }
}

void sub_100D3E550(uint64_t a1)
{
  void (***v10)(uint64_t *__return_ptr, void, uint64_t);
  char v11;
  NSObject *v12;
  void *v13;
  long long v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  BOOL v19;
  const char *v20;
  BOOL v21;
  const char *v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  uint64_t v26;
  BOOL v27;
  const char *v28;
  const char *v29;
  const char *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  BOOL v35;
  const char *v36;
  const char *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unsigned char buf[22];
  char v45;

  if (!*(void *)(a1 + 192))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(0, *(Registry **)(a1 + 88));
    int v3 = ServiceMap;
    if (v4 < 0)
    {
      int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        uint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v4;
    uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
    if (v8)
    {
      uint64_t v10 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v8[3];
      unint64_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        unint64_t v11 = 0;
        if (!v10) {
          goto LABEL_8;
        }
LABEL_12:
        unint64_t v13 = *(void **)(a1 + 208);
        if (v13 == (void *)(a1 + 216))
        {
LABEL_66:
          if ((v11 & 1) == 0) {
            sub_10004D2C8(v9);
          }
          return;
        }
        while (!*((unsigned char *)v13 + 56))
        {
LABEL_60:
          long long v38 = (void *)v13[1];
          if (v38)
          {
            do
            {
              uint64_t v39 = v38;
              long long v38 = (void *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              uint64_t v39 = (void *)v13[2];
              int v21 = *v39 == (void)v13;
              unint64_t v13 = v39;
            }
            while (!v21);
          }
          unint64_t v13 = v39;
          if (v39 == (void *)(a1 + 216)) {
            goto LABEL_66;
          }
        }
        long long v42 = 0;
        long long v43 = 0;
        (**v10)(&v42, v10, (uint64_t)(v13 + 4));
        if (v42)
        {
          if (*(_DWORD *)(v42 + 52) != 1) {
            goto LABEL_58;
          }
          (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 32))(buf);
          __int16 v14 = *(_OWORD *)buf;
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          int v15 = *(std::__shared_weak_count **)(a1 + 200);
          *(_OWORD *)(a1 + 192) = v14;
          if (v15)
          {
            sub_10004D2C8(v15);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            __int16 v16 = *(void *)(a1 + 192);
          }
          else
          {
            __int16 v16 = v14;
          }
          unint64_t v25 = *(NSObject **)(a1 + 40);
          if (v16)
          {
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v26 = *((unsigned __int8 *)v13 + 55);
              unint64_t v27 = (v26 & 0x80u) != 0;
              if ((v26 & 0x80u) != 0) {
                unint64_t v26 = v13[5];
              }
              if (v27) {
                unint64_t v28 = (const char *)v13[4];
              }
              else {
                unint64_t v28 = (const char *)(v13 + 4);
              }
              int v21 = v26 == 0;
              __int16 v29 = "<invalid>";
              if (!v21) {
                __int16 v29 = v28;
              }
              uint64_t v30 = "now ready";
              if (!*((unsigned char *)v13 + 56)) {
                uint64_t v30 = "not ready";
              }
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = v29;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v30;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I IMS client for PersonalityID: %s is %s", buf, 0x16u);
              __int16 v16 = *(void *)(a1 + 192);
            }
            sub_100058DB0(buf, "AudioController");
            long long v31 = *(std::__shared_weak_count **)(a1 + 16);
            if (!v31 || (uint64_t v32 = *(void *)(a1 + 8), (v33 = std::__shared_weak_count::lock(v31)) == 0)) {
              sub_100088B9C();
            }
            unint64_t v40 = v32;
            long long v41 = v33;
            (*(void (**)(uint64_t, unsigned char *, uint64_t *, void))(*(void *)v16 + 168))(v16, buf, &v40, *(void *)(a1 + 24));
            if (v41) {
              sub_10004D2C8(v41);
            }
            if (v45 < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_58;
          }
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
LABEL_58:
            if (v43) {
              sub_10004D2C8(v43);
            }
            goto LABEL_60;
          }
          xpc_object_t v34 = *((unsigned __int8 *)v13 + 55);
          __int16 v35 = (v34 & 0x80u) != 0;
          if ((v34 & 0x80u) != 0) {
            xpc_object_t v34 = v13[5];
          }
          if (v35) {
            double v36 = (const char *)v13[4];
          }
          else {
            double v36 = (const char *)(v13 + 4);
          }
          int v21 = v34 == 0;
          uint64_t v37 = "<invalid>";
          if (!v21) {
            uint64_t v37 = v36;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v37;
          unint64_t v23 = v25;
          long long v24 = "PersonalityID: %s no longer exists";
        }
        else
        {
          int v17 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            goto LABEL_58;
          }
          __int16 v18 = *((unsigned __int8 *)v13 + 55);
          int v19 = (v18 & 0x80u) != 0;
          if ((v18 & 0x80u) != 0) {
            __int16 v18 = v13[5];
          }
          if (v19) {
            __int16 v20 = (const char *)v13[4];
          }
          else {
            __int16 v20 = (const char *)(v13 + 4);
          }
          int v21 = v18 == 0;
          __int16 v22 = "<invalid>";
          if (!v21) {
            __int16 v22 = v20;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v22;
          unint64_t v23 = v17;
          long long v24 = "PersonalityID: %s is not found";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, buf, 0xCu);
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    std::mutex::unlock(v3);
    unint64_t v9 = 0;
    unint64_t v11 = 1;
    if (!v10)
    {
LABEL_8:
      int v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
      }
      goto LABEL_66;
    }
    goto LABEL_12;
  }
}

void sub_100D3E9C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D3EA30(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/last_visible_plmns");
  v4[0] = off_101A53540;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100D3EAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100D3EB10(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/last_known_home_plmn");
  v4[0] = off_101A535C0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100D3EBC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100D3EBF0(uint64_t a1, void *a2)
{
  char v3 = (void *)a2[2];
  if (v3 == *(void **)(a1 + 272))
  {
    int v5 = (void *)*a2;
    uint64_t v4 = a2 + 1;
    char v3 = v5;
    if (v5 == v4) {
      return;
    }
    uint64_t v6 = *(void **)(a1 + 256);
    while (1)
    {
      BOOL v7 = *((_DWORD *)v3 + 7) == *((_DWORD *)v6 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v6 + 8);
      if (!v7) {
        break;
      }
      uint64_t v8 = (void *)v3[1];
      unint64_t v9 = v3;
      if (v8)
      {
        do
        {
          char v3 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          char v3 = (void *)v9[2];
          BOOL v7 = *v3 == (void)v9;
          unint64_t v9 = v3;
        }
        while (!v7);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unint64_t v11 = (void *)v6[2];
          BOOL v7 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v7);
      }
      uint64_t v6 = v11;
      if (v3 == v4) {
        return;
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 264);
  if (!v12) {
    goto LABEL_32;
  }
  char v3 = (void *)(a1 + 264);
  do
  {
    int v13 = *(_DWORD *)(v12 + 28);
    BOOL v14 = v13 < 1;
    if (v13 >= 1) {
      int v15 = (uint64_t *)v12;
    }
    else {
      int v15 = (uint64_t *)(v12 + 8);
    }
    if (!v14) {
      char v3 = (void *)v12;
    }
    uint64_t v12 = *v15;
  }
  while (*v15);
  if (v3 == (void *)(a1 + 264) || *((int *)v3 + 7) > 1) {
LABEL_32:
  }
    int v16 = 11;
  else {
    int v16 = *((_DWORD *)v3 + 8);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 88));
  __int16 v18 = ServiceMap;
  if (v19 < 0)
  {
    __int16 v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v19;
  unint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    long long v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      if (!v25) {
        goto LABEL_39;
      }
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  long long v24 = 0;
  char v26 = 1;
  if (!v25)
  {
LABEL_39:
    unint64_t v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not get SystemObserver to handle %s RAT change", buf, 0xCu);
    }
    goto LABEL_44;
  }
LABEL_43:
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)v25 + 48))(v29, v25);
  sub_1000681B8(a1, (uint64_t)v29, v16);
LABEL_44:
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
}

void sub_100D3EE80(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D3EEB4(uint64_t a1, uint64_t a2, int a3)
{
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  uint64_t v13 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v6 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  if (!v6)
  {
    int v8 = 9;
LABEL_14:
    v10[0] = v8;
    v10[1] = a3;
    void v10[2] = a3;
    int32x2_t v11 = vdup_n_s32(0x1F40u);
    sub_100D3F1B8(a1, v10, 1);
    return;
  }
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  uint64_t v13 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v7 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  if (!v7)
  {
    int v8 = 10;
    goto LABEL_14;
  }
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  uint64_t v13 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v9 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  if (!v9)
  {
    int v8 = 17;
    goto LABEL_14;
  }
}

void sub_100D3F190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D3F1B8(uint64_t a1, int *a2, int a3)
{
  int v5 = *a2;
  int v6 = a2[1];
  int v8 = a2[2];
  int v7 = a2[3];
  int v9 = a2[4];
  int v10 = *(_DWORD *)(a1 + 188);
  int v46 = 1;
  char v45 = 0;
  BOOL v11 = sub_100D41198((void *)a1, &v45, &v46);
  if (v45) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (!v11) {
    int v12 = v10;
  }
  if (*(_DWORD *)(a1 + 168) == v5
    && *(_DWORD *)(a1 + 172) == v6
    && *(_DWORD *)(a1 + 176) == v8
    && *(_DWORD *)(a1 + 180) == v7
    && *(_DWORD *)(a1 + 184) == v9)
  {
    int v13 = *(_DWORD *)(a1 + 188);
    *(_DWORD *)(a1 + 168) = v5;
    *(_DWORD *)(a1 + 172) = v6;
    *(_DWORD *)(a1 + 176) = v8;
    *(_DWORD *)(a1 + 180) = v7;
    *(_DWORD *)(a1 + 184) = v9;
    *(_DWORD *)(a1 + 188) = v12;
    if (v13 == v12 && (a3 & 1) == 0) {
      return;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 168) = v5;
    *(_DWORD *)(a1 + 172) = v6;
    *(_DWORD *)(a1 + 176) = v8;
    *(_DWORD *)(a1 + 180) = v7;
    *(_DWORD *)(a1 + 184) = v9;
    *(_DWORD *)(a1 + 188) = v12;
  }
  long long v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = "false";
    LODWORD(buf) = 67109890;
    DWORD1(buf) = v5;
    WORD4(buf) = 1024;
    if (a3) {
      uint64_t v15 = "true";
    }
    *(_DWORD *)((char *)&buf + 10) = v6;
    HIWORD(buf) = 1024;
    LODWORD(v48[0]) = v8;
    WORD2(v48[0]) = 2080;
    *(void *)((char *)v48 + 6) = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Notifying audio rate available with vocoderType = %d, rate = %d, I2S Clock Rate = %d, indication = %s; Dropping"
      " EVS bandwidth uplink and downlink values",
      (uint8_t *)&buf,
      0x1Eu);
  }
  xpc_object_t v44 = 0;
  xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v17 = v16;
  if (v16)
  {
    xpc_object_t v44 = v16;
  }
  else
  {
    xpc_object_t v17 = xpc_null_create();
    xpc_object_t v44 = v17;
    if (!v17)
    {
      xpc_object_t v18 = xpc_null_create();
      xpc_object_t v17 = 0;
      goto LABEL_26;
    }
  }
  if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v18 = xpc_null_create();
LABEL_26:
    xpc_object_t v44 = v18;
    goto LABEL_27;
  }
  xpc_retain(v17);
LABEL_27:
  xpc_release(v17);
  sub_100A0D870(v5);
  long long buf = 0uLL;
  v48[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v40 = buf;
  uint64_t v41 = v48[0];
  if (v48[0] >= 0) {
    uint64_t v19 = v40;
  }
  else {
    uint64_t v19 = (void **)v40[0];
  }
  xpc_object_t v42 = xpc_string_create((const char *)v19);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  long long buf = 0uLL;
  v48[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = buf;
  uint64_t v38 = v48[0];
  __int16 v20 = (void **)buf;
  if (v48[0] >= 0) {
    __int16 v20 = __p;
  }
  v39[0] = &v44;
  v39[1] = v20;
  sub_100035E70((uint64_t)v39, &v42, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v42);
  xpc_object_t v42 = 0;
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
  v39[0] = 0;
  LODWORD(buf) = v6;
  v39[0] = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &buf);
  LODWORD(buf) = 0;
  ctu::cf::assign((ctu::cf *)&buf, (unsigned int *)v39[0], v21);
  xpc_object_t v35 = xpc_int64_create(buf);
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  long long buf = 0uLL;
  v48[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v40 = buf;
  uint64_t v41 = v48[0];
  unsigned int v22 = (void **)buf;
  if (v48[0] >= 0) {
    unsigned int v22 = v40;
  }
  __p[0] = &v44;
  __p[1] = v22;
  sub_100035E70((uint64_t)__p, &v35, &v36);
  xpc_release(v36);
  xpc_object_t v36 = 0;
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
  xpc_release(v35);
  xpc_object_t v35 = 0;
  LODWORD(buf) = v8;
  xpc_object_t v34 = (unsigned int *)CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &buf);
  LODWORD(buf) = 0;
  ctu::cf::assign((ctu::cf *)&buf, v34, v23);
  xpc_object_t v32 = xpc_int64_create(buf);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  long long buf = 0uLL;
  v48[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v40 = buf;
  uint64_t v41 = v48[0];
  long long v24 = (void **)buf;
  if (v48[0] >= 0) {
    long long v24 = v40;
  }
  __p[0] = &v44;
  __p[1] = v24;
  sub_100035E70((uint64_t)__p, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
  xpc_release(v32);
  xpc_object_t v32 = 0;
  uint64_t v25 = *(int *)(a1 + 188);
  if (v25 > 2) {
    char v26 = "AudioStackType Undefined";
  }
  else {
    char v26 = off_101A53A58[v25];
  }
  xpc_object_t v30 = xpc_string_create(v26);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  long long buf = 0uLL;
  v48[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)unint64_t v40 = buf;
  uint64_t v41 = v48[0];
  unint64_t v27 = (void **)buf;
  if (v48[0] >= 0) {
    unint64_t v27 = v40;
  }
  __p[0] = &v44;
  __p[1] = v27;
  sub_100035E70((uint64_t)__p, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v28 = v44;
  *(void *)&long long buf = v44;
  if (v44)
  {
    xpc_retain(v44);
  }
  else
  {
    xpc_object_t v28 = xpc_null_create();
    *(void *)&long long buf = v28;
  }
  xpc_object_t v29 = xpc_null_create();
  v40[0] = v29;
  sub_1000452AC(129, (xpc_object_t *)&buf, v40);
  xpc_release(v29);
  xpc_release(v28);
  sub_1000570E8((const void **)&v34);
  sub_1000570E8(v39);
  xpc_release(v44);
}

void sub_100D3F760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, uint64_t a13, char a14, xpc_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,xpc_object_t a30)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D3F900(uint64_t a1, int *a2)
{
  int v5 = (os_log_t *)(a1 + 40);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Submitting Audio metrics", buf, 2u);
  }
  sub_100392B14(a2, v5);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 88));
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    long long v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_9;
      }
LABEL_14:
      uint64_t v18 = *a2;
      uint64_t v19 = "CALL_TYPE_CS_Voice";
      if (v18 == 5) {
        uint64_t v19 = "CALL_TYPE_NR_Voice";
      }
      if (v18 == 4) {
        __int16 v20 = "CALL_TYPE_VoLTE_Voice";
      }
      else {
        __int16 v20 = v19;
      }
      if (v18 > 5) {
        CFNumberRef v21 = "???";
      }
      else {
        CFNumberRef v21 = off_101A53A88[v18];
      }
      if (a2[1]) {
        unsigned int v22 = "DL";
      }
      else {
        unsigned int v22 = "UL";
      }
      v138[0] = 0;
      xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v24 = v23;
      if (v23)
      {
        v138[0] = v23;
      }
      else
      {
        xpc_object_t v24 = xpc_null_create();
        v138[0] = v24;
        if (!v24)
        {
          xpc_object_t v25 = xpc_null_create();
          xpc_object_t v24 = 0;
          goto LABEL_32;
        }
      }
      if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v24);
        goto LABEL_33;
      }
      xpc_object_t v25 = xpc_null_create();
LABEL_32:
      v138[0] = v25;
LABEL_33:
      xpc_release(v24);
      xpc_object_t v136 = xpc_string_create(v20);
      if (!v136) {
        xpc_object_t v136 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "call_type";
      sub_100035E70((uint64_t)buf, &v136, &v137);
      xpc_release(v137);
      xpc_object_t v137 = 0;
      xpc_release(v136);
      xpc_object_t v136 = 0;
      xpc_object_t v132 = xpc_string_create(v21);
      if (!v132) {
        xpc_object_t v132 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "rat_type";
      sub_100035E70((uint64_t)buf, &v132, &v133);
      xpc_release(v133);
      xpc_object_t v133 = 0;
      xpc_release(v132);
      xpc_object_t v132 = 0;
      xpc_object_t v130 = xpc_string_create(v22);
      if (!v130) {
        xpc_object_t v130 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "direction";
      sub_100035E70((uint64_t)buf, &v130, &v131);
      xpc_release(v131);
      xpc_object_t v131 = 0;
      xpc_release(v130);
      xpc_object_t v130 = 0;
      char v26 = (const char *)(a2 + 2);
      unint64_t v27 = (const char *)(a2 + 2);
      if (*((char *)a2 + 31) < 0) {
        unint64_t v27 = *(const char **)v26;
      }
      xpc_object_t v128 = xpc_string_create(v27);
      if (!v128) {
        xpc_object_t v128 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "vocoder_type";
      sub_100035E70((uint64_t)buf, &v128, &v129);
      xpc_release(v129);
      xpc_object_t v129 = 0;
      xpc_release(v128);
      xpc_object_t v128 = 0;
      xpc_object_t v126 = xpc_int64_create(a2[9]);
      if (!v126) {
        xpc_object_t v126 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "vocoder_bit_rate";
      sub_100035E70((uint64_t)buf, &v126, &v127);
      xpc_release(v127);
      xpc_object_t v127 = 0;
      xpc_release(v126);
      xpc_object_t v126 = 0;
      xpc_object_t v124 = xpc_int64_create(a2[8]);
      if (!v124) {
        xpc_object_t v124 = xpc_null_create();
      }
      char v44 = v16;
      *(void *)long long buf = v138;
      uint64_t v135 = "vocoder_sample_rate";
      sub_100035E70((uint64_t)buf, &v124, &v125);
      xpc_release(v125);
      xpc_object_t v125 = 0;
      xpc_release(v124);
      xpc_object_t v124 = 0;
      xpc_object_t v122 = xpc_int64_create(a2[11]);
      if (!v122) {
        xpc_object_t v122 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "active_num_frames";
      sub_100035E70((uint64_t)buf, &v122, &v123);
      xpc_release(v123);
      xpc_object_t v123 = 0;
      xpc_release(v122);
      xpc_object_t v122 = 0;
      xpc_object_t v120 = xpc_int64_create(a2[13]);
      if (!v120) {
        xpc_object_t v120 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "bad_num_frames";
      sub_100035E70((uint64_t)buf, &v120, &v121);
      xpc_release(v121);
      xpc_object_t v121 = 0;
      xpc_release(v120);
      xpc_object_t v120 = 0;
      xpc_object_t v118 = xpc_int64_create(a2[14]);
      if (!v118) {
        xpc_object_t v118 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "lost_num_frames";
      sub_100035E70((uint64_t)buf, &v118, &v119);
      xpc_release(v119);
      xpc_object_t v119 = 0;
      xpc_release(v118);
      xpc_object_t v118 = 0;
      xpc_object_t v116 = xpc_int64_create(a2[12]);
      if (!v116) {
        xpc_object_t v116 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "silence_num_frames";
      sub_100035E70((uint64_t)buf, &v116, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v116);
      xpc_object_t v116 = 0;
      xpc_object_t v114 = xpc_int64_create(a2[10]);
      if (!v114) {
        xpc_object_t v114 = xpc_null_create();
      }
      *(void *)long long buf = v138;
      uint64_t v135 = "total_num_frames";
      sub_100035E70((uint64_t)buf, &v114, &v115);
      xpc_release(v115);
      xpc_object_t v115 = 0;
      xpc_release(v114);
      xpc_object_t v114 = 0;
      xpc_object_t v113 = v138[0];
      if (v138[0]) {
        xpc_retain(v138[0]);
      }
      else {
        xpc_object_t v113 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterAudioStatsInd", &v113);
      xpc_release(v113);
      xpc_object_t v113 = 0;
      xpc_object_t v112 = 0;
      xpc_object_t v28 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v29 = v28;
      if (v28)
      {
        xpc_object_t v112 = v28;
      }
      else
      {
        xpc_object_t v29 = xpc_null_create();
        xpc_object_t v112 = v29;
        if (!v29)
        {
          xpc_object_t v30 = xpc_null_create();
          xpc_object_t v29 = 0;
          goto LABEL_67;
        }
      }
      if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v29);
        goto LABEL_68;
      }
      xpc_object_t v30 = xpc_null_create();
LABEL_67:
      xpc_object_t v112 = v30;
LABEL_68:
      xpc_release(v29);
      xpc_object_t v110 = xpc_string_create(v20);
      if (!v110) {
        xpc_object_t v110 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "call_type";
      sub_100035E70((uint64_t)buf, &v110, &v111);
      xpc_release(v111);
      xpc_object_t v111 = 0;
      xpc_release(v110);
      xpc_object_t v110 = 0;
      xpc_object_t v108 = xpc_string_create(v21);
      if (!v108) {
        xpc_object_t v108 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "rat_type";
      sub_100035E70((uint64_t)buf, &v108, &v109);
      xpc_release(v109);
      xpc_object_t v109 = 0;
      xpc_release(v108);
      xpc_object_t v108 = 0;
      xpc_object_t v106 = xpc_string_create(v22);
      if (!v106) {
        xpc_object_t v106 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "direction";
      sub_100035E70((uint64_t)buf, &v106, &v107);
      xpc_release(v107);
      xpc_object_t v107 = 0;
      xpc_release(v106);
      xpc_object_t v106 = 0;
      xpc_object_t v31 = (const char *)(a2 + 2);
      if (*((char *)a2 + 31) < 0) {
        xpc_object_t v31 = *(const char **)v26;
      }
      xpc_object_t v104 = xpc_string_create(v31);
      if (!v104) {
        xpc_object_t v104 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "vocoder_type";
      sub_100035E70((uint64_t)buf, &v104, &v105);
      xpc_release(v105);
      xpc_object_t v105 = 0;
      xpc_release(v104);
      xpc_object_t v104 = 0;
      xpc_object_t v102 = xpc_int64_create(a2[9]);
      if (!v102) {
        xpc_object_t v102 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "vocoder_bit_rate";
      sub_100035E70((uint64_t)buf, &v102, &v103);
      xpc_release(v103);
      xpc_object_t v103 = 0;
      xpc_release(v102);
      xpc_object_t v102 = 0;
      xpc_object_t v100 = xpc_int64_create(a2[8]);
      if (!v100) {
        xpc_object_t v100 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "vocoder_sample_rate";
      sub_100035E70((uint64_t)buf, &v100, &v101);
      xpc_release(v101);
      xpc_object_t v101 = 0;
      xpc_release(v100);
      xpc_object_t v100 = 0;
      xpc_object_t v32 = (const char *)(a2 + 16);
      if (*((char *)a2 + 87) < 0)
      {
        if (!*((void *)a2 + 9)) {
          goto LABEL_90;
        }
        xpc_object_t v32 = *(const char **)v32;
      }
      else if (!*((unsigned char *)a2 + 87))
      {
        goto LABEL_90;
      }
      xpc_object_t v98 = xpc_string_create(v32);
      if (!v98) {
        xpc_object_t v98 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "top1UsedBitRate";
      sub_100035E70((uint64_t)buf, &v98, &v99);
      xpc_release(v99);
      xpc_object_t v99 = 0;
      xpc_release(v98);
      xpc_object_t v98 = 0;
LABEL_90:
      xpc_object_t v33 = (const char *)(a2 + 22);
      if (*((char *)a2 + 111) < 0)
      {
        if (!*((void *)a2 + 12)) {
          goto LABEL_98;
        }
        xpc_object_t v33 = *(const char **)v33;
      }
      else if (!*((unsigned char *)a2 + 111))
      {
        goto LABEL_98;
      }
      xpc_object_t v96 = xpc_string_create(v33);
      if (!v96) {
        xpc_object_t v96 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "top2UsedBitRate";
      sub_100035E70((uint64_t)buf, &v96, &v97);
      xpc_release(v97);
      xpc_object_t v97 = 0;
      xpc_release(v96);
      xpc_object_t v96 = 0;
LABEL_98:
      xpc_object_t v34 = (const char *)(a2 + 28);
      if (*((char *)a2 + 135) < 0)
      {
        if (!*((void *)a2 + 15)) {
          goto LABEL_106;
        }
        xpc_object_t v34 = *(const char **)v34;
      }
      else if (!*((unsigned char *)a2 + 135))
      {
        goto LABEL_106;
      }
      xpc_object_t v94 = xpc_string_create(v34);
      if (!v94) {
        xpc_object_t v94 = xpc_null_create();
      }
      *(void *)long long buf = &v112;
      uint64_t v135 = "top3UsedBitRate";
      sub_100035E70((uint64_t)buf, &v94, &v95);
      xpc_release(v95);
      xpc_object_t v95 = 0;
      xpc_release(v94);
      xpc_object_t v94 = 0;
LABEL_106:
      xpc_object_t v93 = v112;
      if (v112) {
        xpc_retain(v112);
      }
      else {
        xpc_object_t v93 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterVocoderBitRateDistribution", &v93);
      xpc_release(v93);
      xpc_object_t v93 = 0;
      if (!*((unsigned char *)a2 + 136) && !*((unsigned char *)a2 + 156)) {
        goto LABEL_174;
      }
      xpc_object_t v92 = 0;
      xpc_object_t v35 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v36 = v35;
      if (v35)
      {
        xpc_object_t v92 = v35;
      }
      else
      {
        xpc_object_t v36 = xpc_null_create();
        xpc_object_t v92 = v36;
        if (!v36)
        {
          xpc_object_t v37 = xpc_null_create();
          xpc_object_t v36 = 0;
          goto LABEL_118;
        }
      }
      if (xpc_get_type(v36) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v36);
LABEL_119:
        xpc_release(v36);
        xpc_object_t v90 = xpc_string_create(v20);
        if (!v90) {
          xpc_object_t v90 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "call_type";
        sub_100035E70((uint64_t)buf, &v90, &v91);
        xpc_release(v91);
        xpc_object_t v91 = 0;
        xpc_release(v90);
        xpc_object_t v90 = 0;
        xpc_object_t v88 = xpc_string_create(v22);
        if (!v88) {
          xpc_object_t v88 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "direction";
        sub_100035E70((uint64_t)buf, &v88, &v89);
        xpc_release(v89);
        xpc_object_t v89 = 0;
        xpc_release(v88);
        xpc_object_t v88 = 0;
        if (*((char *)a2 + 31) < 0) {
          char v26 = *(const char **)v26;
        }
        xpc_object_t v86 = xpc_string_create(v26);
        if (!v86) {
          xpc_object_t v86 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "vocoder_type";
        sub_100035E70((uint64_t)buf, &v86, &v87);
        xpc_release(v87);
        xpc_object_t v87 = 0;
        xpc_release(v86);
        xpc_object_t v86 = 0;
        xpc_object_t v84 = xpc_int64_create(a2[9]);
        if (!v84) {
          xpc_object_t v84 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "vocoder_bit_rate";
        sub_100035E70((uint64_t)buf, &v84, &v85);
        xpc_release(v85);
        xpc_object_t v85 = 0;
        xpc_release(v84);
        xpc_object_t v84 = 0;
        xpc_object_t v82 = xpc_int64_create(a2[8]);
        if (!v82) {
          xpc_object_t v82 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "vocoder_sample_rate";
        sub_100035E70((uint64_t)buf, &v82, &v83);
        xpc_release(v83);
        xpc_object_t v83 = 0;
        xpc_release(v82);
        xpc_object_t v82 = 0;
        xpc_object_t v80 = xpc_int64_create(a2[50]);
        if (!v80) {
          xpc_object_t v80 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "totalCallDuration";
        sub_100035E70((uint64_t)buf, &v80, &v81);
        xpc_release(v81);
        xpc_object_t v81 = 0;
        xpc_release(v80);
        xpc_object_t v80 = 0;
        xpc_object_t v78 = xpc_int64_create(a2[51]);
        if (!v78) {
          xpc_object_t v78 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "distortion_types_count";
        sub_100035E70((uint64_t)buf, &v78, &v79);
        xpc_release(v79);
        xpc_object_t v79 = 0;
        xpc_release(v78);
        xpc_object_t v78 = 0;
        xpc_object_t v76 = xpc_string_create(*((const char **)a2 + 26));
        if (!v76) {
          xpc_object_t v76 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "largest_distortion_type";
        sub_100035E70((uint64_t)buf, &v76, &v77);
        xpc_release(v77);
        xpc_object_t v77 = 0;
        xpc_release(v76);
        xpc_object_t v76 = 0;
        xpc_object_t v74 = xpc_int64_create(a2[54]);
        if (!v74) {
          xpc_object_t v74 = xpc_null_create();
        }
        *(void *)long long buf = &v92;
        uint64_t v135 = "largest_distortion_duration";
        sub_100035E70((uint64_t)buf, &v74, &v75);
        xpc_release(v75);
        xpc_object_t v75 = 0;
        xpc_release(v74);
        xpc_object_t v74 = 0;
        if (*((unsigned char *)a2 + 136))
        {
          xpc_object_t v72 = xpc_int64_create(a2[35]);
          if (!v72) {
            xpc_object_t v72 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "highNoiseTxCount";
          sub_100035E70((uint64_t)buf, &v72, &v73);
          xpc_release(v73);
          xpc_object_t v73 = 0;
          xpc_release(v72);
          xpc_object_t v72 = 0;
          xpc_object_t v70 = xpc_int64_create(a2[36]);
          if (!v70) {
            xpc_object_t v70 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "lowEnergyTxCount";
          sub_100035E70((uint64_t)buf, &v70, &v71);
          xpc_release(v71);
          xpc_object_t v71 = 0;
          xpc_release(v70);
          xpc_object_t v70 = 0;
          xpc_object_t v68 = xpc_int64_create(a2[37]);
          if (!v68) {
            xpc_object_t v68 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "txSilenceCount";
          sub_100035E70((uint64_t)buf, &v68, &v69);
          xpc_release(v69);
          xpc_object_t v69 = 0;
          xpc_release(v68);
          xpc_object_t v68 = 0;
          xpc_object_t v66 = xpc_int64_create(a2[38]);
          if (!v66) {
            xpc_object_t v66 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "zerosTxCount";
          sub_100035E70((uint64_t)buf, &v66, &v67);
          xpc_release(v67);
          xpc_object_t v67 = 0;
          xpc_release(v66);
          xpc_object_t v66 = 0;
        }
        else
        {
          xpc_object_t v64 = xpc_int64_create(a2[40]);
          if (!v64) {
            xpc_object_t v64 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "highNoiseRxCount";
          sub_100035E70((uint64_t)buf, &v64, &v65);
          xpc_release(v65);
          xpc_object_t v65 = 0;
          xpc_release(v64);
          xpc_object_t v64 = 0;
          xpc_object_t v62 = xpc_int64_create(a2[41]);
          if (!v62) {
            xpc_object_t v62 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "lowEnergyRxCount";
          sub_100035E70((uint64_t)buf, &v62, &v63);
          xpc_release(v63);
          xpc_object_t v63 = 0;
          xpc_release(v62);
          xpc_object_t v62 = 0;
          xpc_object_t v60 = xpc_int64_create(a2[42]);
          if (!v60) {
            xpc_object_t v60 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "rxSilenceCount";
          sub_100035E70((uint64_t)buf, &v60, &v61);
          xpc_release(v61);
          xpc_object_t v61 = 0;
          xpc_release(v60);
          xpc_object_t v60 = 0;
          xpc_object_t v58 = xpc_int64_create(a2[43]);
          if (!v58) {
            xpc_object_t v58 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "zerosRxCount";
          sub_100035E70((uint64_t)buf, &v58, &v59);
          xpc_release(v59);
          xpc_object_t v59 = 0;
          xpc_release(v58);
          xpc_object_t v58 = 0;
          xpc_object_t v56 = xpc_int64_create(a2[48]);
          if (!v56) {
            xpc_object_t v56 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "audioDistortionRxLinkBrokenCount";
          sub_100035E70((uint64_t)buf, &v56, &v57);
          xpc_release(v57);
          xpc_object_t v57 = 0;
          xpc_release(v56);
          xpc_object_t v56 = 0;
          LODWORD(v38) = a2[49];
          LODWORD(v39) = a2[50];
          xpc_object_t v54 = xpc_double_create((double)v38 / (double)v39 * 100.0);
          if (!v54) {
            xpc_object_t v54 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "rxLinkBrokenDurationPercentage";
          sub_100035E70((uint64_t)buf, &v54, &v55);
          xpc_release(v55);
          xpc_object_t v55 = 0;
          xpc_release(v54);
          xpc_object_t v54 = 0;
          xpc_object_t v52 = xpc_int64_create(a2[44]);
          if (!v52) {
            xpc_object_t v52 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "averageSpeechLossCount";
          sub_100035E70((uint64_t)buf, &v52, &v53);
          xpc_release(v53);
          xpc_object_t v53 = 0;
          xpc_release(v52);
          xpc_object_t v52 = 0;
          LODWORD(v40) = a2[45];
          LODWORD(v41) = a2[50];
          xpc_object_t v50 = xpc_double_create((double)v40 / (double)v41 * 100.0);
          if (!v50) {
            xpc_object_t v50 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "averageSpeechLossDurationPercentage";
          sub_100035E70((uint64_t)buf, &v50, &v51);
          xpc_release(v51);
          xpc_object_t v51 = 0;
          xpc_release(v50);
          xpc_object_t v50 = 0;
          xpc_object_t v48 = xpc_int64_create(a2[46]);
          if (!v48) {
            xpc_object_t v48 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "continuousSpeechLossCount";
          sub_100035E70((uint64_t)buf, &v48, &v49);
          xpc_release(v49);
          xpc_object_t v49 = 0;
          xpc_release(v48);
          xpc_object_t v48 = 0;
          LODWORD(v42) = a2[47];
          LODWORD(v43) = a2[50];
          xpc_object_t v46 = xpc_double_create((double)v42 / (double)v43 * 100.0);
          if (!v46) {
            xpc_object_t v46 = xpc_null_create();
          }
          *(void *)long long buf = &v92;
          uint64_t v135 = "continuousSpeechLossDurationPercentage";
          sub_100035E70((uint64_t)buf, &v46, &v47);
          xpc_release(v47);
          xpc_object_t v47 = 0;
          xpc_release(v46);
          xpc_object_t v46 = 0;
        }
        xpc_object_t v45 = v92;
        if (v92) {
          xpc_retain(v92);
        }
        else {
          xpc_object_t v45 = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterAudioDistortionSummary", &v45);
        xpc_release(v45);
        xpc_object_t v45 = 0;
        xpc_release(v92);
LABEL_174:
        xpc_release(v112);
        xpc_release(v138[0]);
        if (v44) {
          return;
        }
        goto LABEL_175;
      }
      xpc_object_t v37 = xpc_null_create();
LABEL_118:
      xpc_object_t v92 = v37;
      goto LABEL_119;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  long long v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_14;
  }
LABEL_9:
  xpc_object_t v17 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find TelephonyAnalytics service", buf, 2u);
    if (v16) {
      return;
    }
  }
  else if (v16)
  {
    return;
  }
LABEL_175:
  sub_10004D2C8(v14);
}

void sub_100D40D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,xpc_object_t a58)
{
  xpc_release(object);
  xpc_release(a58);
  xpc_release((xpc_object_t)STACK[0x220]);
  xpc_release(*(xpc_object_t *)(v59 - 96));
  if ((a10 & 1) == 0) {
    sub_10004D2C8(v58);
  }
  _Unwind_Resume(a1);
}

BOOL *sub_100D40F50(uint64_t a1)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 120) + 40))(&cf);
  char v2 = (BOOL *)cf;
  buf[0] = 0;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v2, v4);
      char v2 = (BOOL *)(buf[0] != 0);
    }
    else
    {
      char v2 = 0;
    }
  }
  int v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = "false";
    if (v2) {
      int v6 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    int v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I AudioLoggingEnabled is set to: %s", buf, 0xCu);
  }
  sub_1000577C4(&cf);
  return v2;
}

void sub_100D410B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_100D410D0(uint64_t a1, uint64_t a2)
{
  char v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152));
  if ((v4 & 1) != 0 || result)
  {
    uint64_t result = capabilities::ct::supportsAudioLoggingUserConsent((capabilities::ct *)result);
    if (result)
    {
      if (*(unsigned char *)(a1 + 280)) {
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 136) + 64))(*(void *)(a1 + 136), a2);
      }
      return 1;
    }
  }
  return result;
}

BOOL sub_100D41198(void *a1, unsigned char *a2, _DWORD *a3)
{
  *a2 = 0;
  CFTypeID v3 = (unsigned __int8 *)a1[42];
  char v4 = (unsigned __int8 *)a1[43];
  if (v3 != v4)
  {
    for (uint64_t i = (unsigned __int8 *)a1[42]; i != v4; i += 12)
    {
      int v9 = *i;
      if (v9 != 1)
      {
        uint64_t v10 = *((unsigned int *)i + 1);
        if (v9 == 2) {
          goto LABEL_13;
        }
        uint64_t v11 = (std::__shared_weak_count *)a1[12];
        v15[0] = a1[11];
        v15[1] = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v12 = sub_100D415E0((sd::IMSSubscriberConfigInterface *)v15, v10);
        char v13 = v12;
        if (v11)
        {
          sub_10004D2C8(v11);
          if (v13) {
            goto LABEL_13;
          }
        }
        else if (v12)
        {
LABEL_13:
          *a2 = 1;
          *a3 = v10;
          return v3 != v4;
        }
      }
    }
  }
  return v3 != v4;
}

void sub_100D41278(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D41290(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D41380(uint64_t a1)
{
}

void sub_100D41388(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  CFTypeID v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D41488(uint64_t a1, uint64_t a2)
{
}

BOOL sub_100D41490(uint64_t a1, int a2, long long *a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  long long v8 = *a3;
  uint64_t v9 = *((void *)a3 + 2);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_100D47550;
  int v10[3] = &unk_101A539F8;
  void v10[4] = a1 + 8;
  void v10[5] = &v6;
  uint64_t v11 = v10;
  uint64_t v4 = a1 + 24;
  CFTypeID v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    long long v14 = sub_10005B20C;
    uint64_t v15 = &unk_101A53A38;
    char v16 = &v18;
    xpc_object_t v17 = &v11;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    long long v14 = sub_10005A4A8;
    uint64_t v15 = &unk_101A53A18;
    char v16 = &v18;
    xpc_object_t v17 = &v11;
    dispatch_sync(v3, &block);
  }
  return v18 != 0;
}

BOOL sub_100D415D8(uint64_t a1, int a2, long long *a3)
{
  return sub_100D41490(a1 - 56, a2, a3);
}

uint64_t sub_100D415E0(sd::IMSSubscriberConfigInterface *a1, uint64_t a2)
{
  uint64_t v4 = sd::IMSSubscriberConfigInterface::APOnlyModeDefaultVal(a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)a1);
  int v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, &v17);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (v14) {
LABEL_10:
  }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 288))(v14, a2);
LABEL_11:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  return v4;
}

void sub_100D41714(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D41790(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D417C8(uint64_t a1)
{
}

uint64_t sub_100D417E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D41828(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100D41854(ServiceManager::Service *this)
{
  *(void *)this = off_101A53230;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100D418B0(ServiceManager::Service *this)
{
  *(void *)this = off_101A53230;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100D41920@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "AudioController");
}

unsigned char *sub_100D41930@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100D41970(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  CFTypeID v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100D3E0F8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100D3E0F8(v4, 0);
}

uint64_t sub_100D419F4()
{
  return 0;
}

uint64_t sub_100D419FC()
{
  return 1;
}

uint64_t sub_100D41A04()
{
  return 0;
}

void sub_100D41A10(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D41AF0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D41C08()
{
}

uint64_t sub_100D41C1C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100D41C28(void **a1)
{
  char v1 = *a1;
  int v7 = a1;
  unint64_t v8 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = *(void *)(*v1 + 136);
  dispatch_group_t group = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v4 + 32))(v4, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v3 + 232));
  for (uint64_t i = *(void *)(v3 + 72); i != v3 + 64; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v3 + 64));
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100D41D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
}

uint64_t *sub_100D41D40(uint64_t **a1)
{
  char v1 = *a1;
  xpc_object_t v30 = a1;
  xpc_object_t v31 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(std::__shared_weak_count **)(*v1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(v2 + 8), (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  int v7 = (std::__shared_weak_count *)operator new(0x30uLL);
  v7->__shared_owners_ = 0;
  v7->__shared_weak_owners_ = 0;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_101A532F0;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A533C8;
  v7[1].__shared_owners_ = v4;
  v7[1].__shared_weak_owners_ = (uint64_t)v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A53340;
  uint64_t v8 = *(void *)(v2 + 136);
  uint64_t v9 = v1[1];
  dispatch_group_t group = v9;
  if (v9)
  {
    dispatch_retain(v9);
    dispatch_group_enter(v9);
  }
  xpc_object_t v34 = v7 + 1;
  xpc_object_t v35 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  xpc_object_t v32 = xpc_null_create();
  xpc_object_t object = xpc_null_create();
  (*(void (**)(uint64_t, dispatch_group_t *, std::__shared_weak_count **, xpc_object_t *))(*(void *)v8 + 16))(v8, &group, &v34, &v32);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v10 = operator new(0x20uLL);
  *uint64_t v10 = off_101A53440;
  v10[1] = v2;
  void v10[2] = sub_100D3E3B8;
  int v10[3] = 0;
  *((void *)&v41 + 1) = v10;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v40);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/ims_client_state");
  unsigned int v11 = operator new(0x28uLL);
  *unsigned int v11 = off_101A534C0;
  v11[1] = v2 + 208;
  _OWORD v11[2] = v2;
  v11[3] = sub_100D3E550;
  v11[4] = 0;
  *((void *)&v41 + 1) = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v40);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  sub_100D3EA30(v2 + 288);
  sub_100D3EB10(v2 + 312);
  sub_100058DB0(__p, "/cc/props/current_calls");
  *(void *)&long long v40 = off_101A53640;
  *((void *)&v40 + 1) = v2 + 336;
  *((void *)&v41 + 1) = &v40;
  ctu::RestModule::observeProperty();
  int v12 = (capabilities::ct *)sub_10003F600(&v40);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v13 = (capabilities::ct *)capabilities::ct::supportsAudioPolicyForTopAntenna(v12);
  if ((v13 & 1) != 0 || capabilities::ct::supportsAudioPolicyForBottomAntenna(v13))
  {
    uint64_t v14 = *(std::__shared_weak_count **)(v2 + 16);
    if (v14)
    {
      char v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        char v16 = v15;
        unint64_t v17 = *(NSObject **)(v2 + 24);
        dispatch_retain(v17);
        *(_OWORD *)std::string __p = 0u;
        long long v38 = 0u;
        dispatch_retain(v17);
        dispatch_retain(v17);
        dispatch_retain(v17);
        dispatch_retain(v17);
        dispatch_retain(v17);
        dispatch_retain(v17);
        dispatch_retain(v17);
        v39[1] = (uint64_t)v17;
        void v39[2] = v2;
        dispatch_retain(v17);
        dispatch_release(v17);
        dispatch_release(v17);
        dispatch_release(v17);
        v39[0] = (uint64_t)off_101A53888;
        dispatch_release(v17);
        dispatch_release(v17);
        long long v41 = 0u;
        long long v40 = 0u;
        sub_100D46DE4((uint64_t)&v40, v39);
        sub_100D46DE4((uint64_t)v39, (uint64_t *)&v38 + 1);
        sub_100D46DE4((uint64_t)&v38 + 8, (uint64_t *)&v40);
        sub_100061E28((uint64_t *)&v40);
        sub_100061E28(v39);
        dispatch_release(v17);
        dispatch_release(v17);
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
    sub_100088B9C();
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v40, *(Registry **)(v2 + 88));
  ctu::RestModule::connect();
  if (*((void *)&v40 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v40 + 1));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(v2 + 88));
  __int16 v20 = ServiceMap;
  if (v21 < 0)
  {
    unsigned int v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v40 = v21;
  xpc_object_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v40);
  if (v25)
  {
    uint64_t v26 = v25[3];
    unint64_t v27 = (std::__shared_weak_count *)v25[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v20);
  unint64_t v27 = 0;
LABEL_31:
  xpc_object_t v28 = *(std::__shared_weak_count **)(v2 + 160);
  *(void *)(v2 + 152) = v26;
  *(void *)(v2 + 160) = v27;
  if (v28) {
    sub_10004D2C8(v28);
  }
  sub_10004D2C8(v7);
  sub_100088C88((uint64_t *)&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_100D4291C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a2)
  {
    sub_100163C60((void ***)&a30);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100D42934(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a39);
    if (a30) {
      (*(void (**)(uint64_t))(*(void *)a30 + 8))(a30);
    }
    std::__shared_weak_count::__release_weak(v39);
    JUMPOUT(0x100D42C64);
  }
  _Unwind_Resume(a1);
}

void sub_100D42958(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100D42A8CLL);
}

void sub_100D42980()
{
  sub_100160AF8(v0);
  JUMPOUT(0x100D42C28);
}

void sub_100D42998(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100D429D8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint **a12)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(a12);
    JUMPOUT(0x100D42C5CLL);
  }
  _Unwind_Resume(a1);
}

void sub_100D429EC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100D46AB8(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100D42A0C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v3);
    *(void *)uint64_t v2 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v2 + 16));
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100D42A28(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100D42A30);
  }
  _Unwind_Resume(a1);
}

void sub_100D42A4C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100D42A54);
  }
  _Unwind_Resume(a1);
}

void sub_100D42A94(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100D42C64);
}

void sub_100D42AA0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100D42AA8);
  }
  _Unwind_Resume(a1);
}

void sub_100D42AD8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100D42AE0);
  }
  _Unwind_Resume(a1);
}

void sub_100D42AF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,std::__shared_weak_count *a40)
{
  if (a40) {
    sub_10004D2C8(a40);
  }
  JUMPOUT(0x100D42C28);
}

uint64_t sub_100D42B08(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, void *a19, void *a20,uint64_t a21,uint64_t a22,NSObject *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  return sub_100D42B18(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, v45, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45);
}

void sub_100D42B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, xpc_object_t a16, xpc_object_t object, uint64_t a18, uint64_t a19, dispatch_group_t group,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(a13);
  sub_100088C88(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

void sub_100D42C7C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A532F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D42C9C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A532F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D42CF0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D42D18(AudioCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A533C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  AudioCommandDriverDelegateInterface::~AudioCommandDriverDelegateInterface(this);
}

void sub_100D42D74(AudioCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A533C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  AudioCommandDriverDelegateInterface::~AudioCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100D42DE4(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        int v8 = *(unsigned __int8 *)(v7 + 280);
        if (v8 != a2)
        {
          uint64_t v9 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = "true";
            if (v8) {
              unsigned int v11 = "true";
            }
            else {
              unsigned int v11 = "false";
            }
            if (!a2) {
              uint64_t v10 = "false";
            }
            int v15 = 136315394;
            char v16 = v11;
            __int16 v17 = 2080;
            char v18 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Driver ready state is changing from %s to %s", (uint8_t *)&v15, 0x16u);
          }
          *(unsigned char *)(v7 + 280) = a2;
        }
        if (a2)
        {
          int v12 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Re-sending audio logging setting to baseband", (uint8_t *)&v15, 2u);
          }
          uint64_t v13 = sub_100D40F50(v7);
          sub_100D410D0(v7, (uint64_t)v13);
          uint64_t v14 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Driver is ready, querying vocoder info", (uint8_t *)&v15, 2u);
          }
          (*(void (**)(void))(**(void **)(v7 + 136) + 40))(*(void *)(v7 + 136));
        }
        else
        {
          *(_OWORD *)(v7 + 168) = xmmword_1015692A0;
          *(_DWORD *)(v7 + 184) = 8000;
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D43000(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D43014(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3) {
    return;
  }
  int v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    if (a2 == 1)
    {
      int v8 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v11 = 0;
        uint64_t v9 = "#I Failed to ack vocoder switch complete";
        uint64_t v10 = (uint8_t *)&v11;
        goto LABEL_11;
      }
    }
    else if (!a2)
    {
      int v8 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v12 = 0;
        uint64_t v9 = "#I Failed to query vocoder info";
        uint64_t v10 = (uint8_t *)&v12;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
      }
    }
  }

  sub_10004D2C8(v6);
}

void sub_100D43104(uint64_t a1, long long *a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        long long v10 = *a2;
        int v11 = *((_DWORD *)a2 + 4);
        sub_100D3F1B8(v9, (int *)&v10, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100D4319C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D431B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (!v7)
      {
LABEL_80:
        sub_10004D2C8(v6);
        return;
      }
      int64_t value = *(void *)a2;
      unsigned int v32 = *(_DWORD *)(a2 + 8);
      if (*(char *)(a2 + 39) < 0)
      {
        sub_10004FC84(&__p, *(void **)(a2 + 16), *(void *)(a2 + 24));
      }
      else
      {
        long long __p = *(_OWORD *)(a2 + 16);
        uint64_t v34 = *(void *)(a2 + 32);
      }
      long long v8 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)xpc_object_t v35 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)xpc_object_t v36 = v8;
      *(_OWORD *)&v36[13] = *(_OWORD *)(a2 + 69);
      long long v10 = (os_log_t *)(v7 + 40);
      uint64_t v9 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Submitting Audio distortion metrics.", buf, 2u);
      }
      sub_1003939F4((uint64_t)&value, (os_log_t *)(v7 + 40));
      ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(v7 + 88));
      uint64_t v13 = ServiceMap;
      if (v14 < 0)
      {
        int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          uint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v14;
      char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
      if (v18)
      {
        uint64_t v20 = v18[3];
        uint64_t v19 = (std::__shared_weak_count *)v18[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          char v21 = 0;
          if (!v20) {
            goto LABEL_15;
          }
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v20 = 0;
      }
      std::mutex::unlock(v13);
      uint64_t v19 = 0;
      char v21 = 1;
      if (!v20)
      {
LABEL_15:
        unsigned int v22 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find TelephonyAnalytics service", buf, 2u);
        }
LABEL_76:
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete((void *)__p);
        }
        goto LABEL_80;
      }
LABEL_19:
      xpc_object_t v71 = 0;
      xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v24 = v23;
      if (v23)
      {
        xpc_object_t v71 = v23;
      }
      else
      {
        xpc_object_t v24 = xpc_null_create();
        xpc_object_t v71 = v24;
        if (!v24)
        {
          xpc_object_t v25 = xpc_null_create();
          xpc_object_t v24 = 0;
          goto LABEL_26;
        }
      }
      if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v24);
LABEL_27:
        xpc_release(v24);
        if (v32 > 5) {
          uint64_t v26 = "???";
        }
        else {
          uint64_t v26 = off_101A53A88[v32];
        }
        xpc_object_t v69 = xpc_string_create(v26);
        if (!v69) {
          xpc_object_t v69 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "rat_type";
        sub_100035E70((uint64_t)buf, &v69, &v70);
        xpc_release(v70);
        xpc_object_t v70 = 0;
        xpc_release(v69);
        xpc_object_t v69 = 0;
        xpc_object_t v65 = xpc_int64_create(HIDWORD(value));
        if (!v65) {
          xpc_object_t v65 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "distortion_duration";
        sub_100035E70((uint64_t)buf, &v65, &v66);
        xpc_release(v66);
        xpc_object_t v66 = 0;
        xpc_release(v65);
        xpc_object_t v65 = 0;
        unint64_t v27 = sub_100392AF0(value);
        xpc_object_t v63 = xpc_string_create(v27);
        if (!v63) {
          xpc_object_t v63 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "DistortionType";
        sub_100035E70((uint64_t)buf, &v63, &v64);
        xpc_release(v64);
        xpc_object_t v64 = 0;
        xpc_release(v63);
        xpc_object_t v63 = 0;
        if (v34 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        xpc_object_t v61 = xpc_string_create(p_p);
        if (!v61) {
          xpc_object_t v61 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "vocoder_type";
        sub_100035E70((uint64_t)buf, &v61, &v62);
        xpc_release(v62);
        xpc_object_t v62 = 0;
        xpc_release(v61);
        xpc_object_t v61 = 0;
        xpc_object_t v59 = xpc_int64_create(LODWORD(v35[0]));
        if (!v59) {
          xpc_object_t v59 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "vocoder_bit_rate";
        sub_100035E70((uint64_t)buf, &v59, &v60);
        xpc_release(v60);
        xpc_object_t v60 = 0;
        xpc_release(v59);
        xpc_object_t v59 = 0;
        xpc_object_t v57 = xpc_int64_create(HIDWORD(v35[0]));
        if (!v57) {
          xpc_object_t v57 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "vocoder_bandwidth";
        sub_100035E70((uint64_t)buf, &v57, &v58);
        xpc_release(v58);
        xpc_object_t v58 = 0;
        xpc_release(v57);
        xpc_object_t v57 = 0;
        xpc_object_t v29 = "CALL_TYPE_CS_Voice";
        if (v32 == 5) {
          xpc_object_t v29 = "CALL_TYPE_NR_Voice";
        }
        if (v32 == 4) {
          xpc_object_t v30 = "CALL_TYPE_VoLTE_Voice";
        }
        else {
          xpc_object_t v30 = v29;
        }
        xpc_object_t v55 = xpc_string_create(v30);
        if (!v55) {
          xpc_object_t v55 = xpc_null_create();
        }
        *(void *)long long buf = &v71;
        xpc_object_t v68 = "call_type";
        sub_100035E70((uint64_t)buf, &v55, &v56);
        xpc_release(v56);
        xpc_object_t v56 = 0;
        xpc_release(v55);
        xpc_object_t v55 = 0;
        if (v36[28])
        {
          xpc_object_t v53 = xpc_int64_create(SLODWORD(v35[1]));
          if (!v53) {
            xpc_object_t v53 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "rsrp_dl";
          sub_100035E70((uint64_t)buf, &v53, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v53);
          xpc_object_t v53 = 0;
          xpc_object_t v51 = xpc_int64_create(SHIDWORD(v35[1]));
          if (!v51) {
            xpc_object_t v51 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "rssi_dl";
          sub_100035E70((uint64_t)buf, &v51, &v52);
          xpc_release(v52);
          xpc_object_t v52 = 0;
          xpc_release(v51);
          xpc_object_t v51 = 0;
          xpc_object_t v49 = xpc_int64_create(*(int *)v36);
          if (!v49) {
            xpc_object_t v49 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "snr_dl";
          sub_100035E70((uint64_t)buf, &v49, &v50);
          xpc_release(v50);
          xpc_object_t v50 = 0;
          xpc_release(v49);
          xpc_object_t v49 = 0;
          xpc_object_t v47 = xpc_int64_create(*(unsigned int *)&v36[4]);
          if (!v47) {
            xpc_object_t v47 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "bler_ul";
          sub_100035E70((uint64_t)buf, &v47, &v48);
          xpc_release(v48);
          xpc_object_t v48 = 0;
          xpc_release(v47);
          xpc_object_t v47 = 0;
          xpc_object_t v45 = xpc_int64_create(*(unsigned int *)&v36[8]);
          if (!v45) {
            xpc_object_t v45 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "bler_dl";
          sub_100035E70((uint64_t)buf, &v45, &v46);
          xpc_release(v46);
          xpc_object_t v46 = 0;
          xpc_release(v45);
          xpc_object_t v45 = 0;
          xpc_object_t v43 = xpc_int64_create(*(unsigned int *)&v36[12]);
          if (!v43) {
            xpc_object_t v43 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "tti_bundling_state";
          sub_100035E70((uint64_t)buf, &v43, &v44);
          xpc_release(v44);
          xpc_object_t v44 = 0;
          xpc_release(v43);
          xpc_object_t v43 = 0;
          xpc_object_t v41 = xpc_int64_create(*(unsigned int *)&v36[16]);
          if (!v41) {
            xpc_object_t v41 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "cdrx_state";
          sub_100035E70((uint64_t)buf, &v41, &v42);
          xpc_release(v42);
          xpc_object_t v42 = 0;
          xpc_release(v41);
          xpc_object_t v41 = 0;
          xpc_object_t v39 = xpc_int64_create(*(unsigned int *)&v36[20]);
          if (!v39) {
            xpc_object_t v39 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "cdrx_cycle_ms";
          sub_100035E70((uint64_t)buf, &v39, &v40);
          xpc_release(v40);
          xpc_object_t v40 = 0;
          xpc_release(v39);
          xpc_object_t v39 = 0;
          xpc_object_t v37 = xpc_int64_create(*(unsigned int *)&v36[24]);
          if (!v37) {
            xpc_object_t v37 = xpc_null_create();
          }
          *(void *)long long buf = &v71;
          xpc_object_t v68 = "last_ho_end_elapse_time";
          sub_100035E70((uint64_t)buf, &v37, &v38);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          xpc_release(v37);
          xpc_object_t v37 = 0;
        }
        *(void *)long long buf = v71;
        if (v71) {
          xpc_retain(v71);
        }
        else {
          *(void *)long long buf = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v20 + 16))(v20, "commCenterAudioDistortionInfo", buf);
        xpc_release(*(xpc_object_t *)buf);
        *(void *)long long buf = 0;
        xpc_release(v71);
        goto LABEL_76;
      }
      xpc_object_t v25 = xpc_null_create();
LABEL_26:
      xpc_object_t v71 = v25;
      goto LABEL_27;
    }
  }
}

void sub_100D43A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100D43B70(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = *a2;
        if (*((char *)a2 + 31) < 0)
        {
          sub_10004FC84(&v9, (void *)a2[1], a2[2]);
        }
        else
        {
          long long v9 = *(_OWORD *)(a2 + 1);
          uint64_t v10 = a2[3];
        }
        v11[0] = *((_OWORD *)a2 + 2);
        *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)((char *)a2 + 44);
        if (*((char *)a2 + 87) < 0)
        {
          sub_10004FC84(&v12, (void *)a2[8], a2[9]);
        }
        else
        {
          long long v12 = *((_OWORD *)a2 + 4);
          uint64_t v13 = a2[10];
        }
        if (*((char *)a2 + 111) < 0)
        {
          sub_10004FC84(&v14, (void *)a2[11], a2[12]);
        }
        else
        {
          long long v14 = *(_OWORD *)(a2 + 11);
          uint64_t v15 = a2[13];
        }
        if (*((char *)a2 + 135) < 0)
        {
          sub_10004FC84(&__p, (void *)a2[14], a2[15]);
        }
        else
        {
          long long __p = *((_OWORD *)a2 + 7);
          uint64_t v17 = a2[16];
        }
        long long v20 = *(_OWORD *)(a2 + 21);
        long long v21 = *(_OWORD *)(a2 + 23);
        long long v22 = *(_OWORD *)(a2 + 25);
        int v23 = *((_DWORD *)a2 + 54);
        long long v18 = *(_OWORD *)(a2 + 17);
        long long v19 = *(_OWORD *)(a2 + 19);
        sub_100D3F900(v7, (int *)&v8);
        if (SHIBYTE(v17) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v15) < 0) {
          operator delete((void *)v14);
        }
        if (SHIBYTE(v13) < 0) {
          operator delete((void *)v12);
        }
        if (SHIBYTE(v10) < 0) {
          operator delete((void *)v9);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D43D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  sub_10004D2C8(v31);
  _Unwind_Resume(a1);
}

void sub_100D43D8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (!v7)
      {
LABEL_57:
        sub_10004D2C8(v6);
        return;
      }
      unsigned int v27 = *(_DWORD *)a2;
      if (*(char *)(a2 + 31) < 0)
      {
        sub_10004FC84(&__p, *(void **)(a2 + 8), *(void *)(a2 + 16));
      }
      else
      {
        long long __p = *(_OWORD *)(a2 + 8);
        uint64_t v29 = *(void *)(a2 + 24);
      }
      *(_OWORD *)xpc_object_t v30 = *(_OWORD *)(a2 + 32);
      int64_t value = *(void *)(a2 + 48);
      long long v9 = (os_log_t *)(v7 + 40);
      uint64_t v8 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Submitting Ps Audio metrics", buf, 2u);
      }
      sub_100393704((int *)&v27, (os_log_t *)(v7 + 40));
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(v7 + 88));
      long long v12 = ServiceMap;
      if (v13 < 0)
      {
        long long v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          uint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v13;
      uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
      if (v17)
      {
        uint64_t v19 = v17[3];
        long long v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
          if (!v19) {
            goto LABEL_15;
          }
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      long long v18 = 0;
      char v20 = 1;
      if (!v19)
      {
LABEL_15:
        long long v21 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find TelephonyAnalytics service", buf, 2u);
        }
LABEL_53:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete((void *)__p);
        }
        goto LABEL_57;
      }
LABEL_19:
      if (v27 > 5) {
        long long v22 = "???";
      }
      else {
        long long v22 = off_101A53A88[v27];
      }
      xpc_object_t v50 = 0;
      xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v24 = v23;
      if (v23)
      {
        xpc_object_t v50 = v23;
      }
      else
      {
        xpc_object_t v24 = xpc_null_create();
        xpc_object_t v50 = v24;
        if (!v24)
        {
          xpc_object_t v25 = xpc_null_create();
          xpc_object_t v24 = 0;
          goto LABEL_29;
        }
      }
      if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v24);
LABEL_30:
        xpc_release(v24);
        xpc_object_t v48 = xpc_string_create(v22);
        if (!v48) {
          xpc_object_t v48 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "rat_type";
        sub_100035E70((uint64_t)buf, &v48, &v49);
        xpc_release(v49);
        xpc_object_t v49 = 0;
        xpc_release(v48);
        xpc_object_t v48 = 0;
        if (v29 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        xpc_object_t v44 = xpc_string_create(p_p);
        if (!v44) {
          xpc_object_t v44 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "vocoder_type";
        sub_100035E70((uint64_t)buf, &v44, &v45);
        xpc_release(v45);
        xpc_object_t v45 = 0;
        xpc_release(v44);
        xpc_object_t v44 = 0;
        xpc_object_t v42 = xpc_int64_create(value);
        if (!v42) {
          xpc_object_t v42 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "frame_delay_avg";
        sub_100035E70((uint64_t)buf, &v42, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v42);
        xpc_object_t v42 = 0;
        xpc_object_t v40 = xpc_int64_create(HIDWORD(value));
        if (!v40) {
          xpc_object_t v40 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "frame_delay_max";
        sub_100035E70((uint64_t)buf, &v40, &v41);
        xpc_release(v41);
        xpc_object_t v41 = 0;
        xpc_release(v40);
        xpc_object_t v40 = 0;
        xpc_object_t v38 = xpc_int64_create(LODWORD(v30[1]));
        if (!v38) {
          xpc_object_t v38 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "inter_arrival_jitter_avg";
        sub_100035E70((uint64_t)buf, &v38, &v39);
        xpc_release(v39);
        xpc_object_t v39 = 0;
        xpc_release(v38);
        xpc_object_t v38 = 0;
        xpc_object_t v36 = xpc_int64_create(HIDWORD(v30[1]));
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "inter_arrival_jitter_max";
        sub_100035E70((uint64_t)buf, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
        xpc_object_t v34 = xpc_int64_create(LODWORD(v30[0]));
        if (!v34) {
          xpc_object_t v34 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "rtp_pkt_loss_rate_jb";
        sub_100035E70((uint64_t)buf, &v34, &v35);
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_release(v34);
        xpc_object_t v34 = 0;
        xpc_object_t v32 = xpc_int64_create(HIDWORD(v30[0]));
        if (!v32) {
          xpc_object_t v32 = xpc_null_create();
        }
        *(void *)long long buf = &v50;
        xpc_object_t v47 = "rtp_pkt_loss_rate_nw";
        sub_100035E70((uint64_t)buf, &v32, &v33);
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_release(v32);
        xpc_object_t v32 = 0;
        *(void *)long long buf = v50;
        if (v50) {
          xpc_retain(v50);
        }
        else {
          *(void *)long long buf = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v19 + 16))(v19, "commCenterPSAudioJBStatistics", buf);
        xpc_release(*(xpc_object_t *)buf);
        *(void *)long long buf = 0;
        xpc_release(v50);
        goto LABEL_53;
      }
      xpc_object_t v25 = xpc_null_create();
LABEL_29:
      xpc_object_t v50 = v25;
      goto LABEL_30;
    }
  }
}

void sub_100D44338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100D44410(uint64_t a1, BOOL a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (*(void *)(a1 + 8)) {
        sub_100A0D650(a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D44484(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D44498(AudioCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A533C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  AudioCommandDriverDelegateInterface::~AudioCommandDriverDelegateInterface(this);
}

void sub_100D444F4(AudioCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A533C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  AudioCommandDriverDelegateInterface::~AudioCommandDriverDelegateInterface(this);

  operator delete();
}

uint64_t sub_100D44564(uint64_t a1)
{
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100D445C8(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 136) + 24))(*(void *)(**(void **)a1 + 136));
  operator delete();
}

void sub_100D44640()
{
}

void sub_100D4466C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  unsigned int v59 = 1;
  char v58 = 0;
  BOOL v3 = sub_100D41198((void *)v2, &v58, &v59);
  signed int v4 = v59;
  int v5 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v59);
  xpc_object_t v57 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v57 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v57 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  xpc_object_t v57 = v8;
LABEL_9:
  xpc_release(v7);
  if (v58)
  {
    long long v9 = *v5;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Getting vocoderInfo for an active call on AP media stack", buf, 2u);
    }
    uint64_t v10 = *(void *)(v2 + 368);
    if (v10)
    {
      uint64_t v11 = v2 + 368;
      do
      {
        signed int v12 = *(_DWORD *)(v10 + 28);
        BOOL v13 = v12 < v4;
        if (v12 >= v4) {
          long long v14 = (uint64_t *)v10;
        }
        else {
          long long v14 = (uint64_t *)(v10 + 8);
        }
        if (!v13) {
          uint64_t v11 = v10;
        }
        uint64_t v10 = *v14;
      }
      while (*v14);
      if (v11 != v2 + 368 && v4 >= *(_DWORD *)(v11 + 28))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v61 = 0;
        ctu::cf::assign();
        *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
        uint64_t v54 = v61;
        if (v61 >= 0) {
          char v20 = v53;
        }
        else {
          char v20 = (xpc_object_t *)v53[0];
        }
        xpc_object_t v55 = xpc_string_create((const char *)v20);
        if (!v55) {
          xpc_object_t v55 = xpc_null_create();
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v61 = 0;
        ctu::cf::assign();
        *(_OWORD *)long long __p = *(_OWORD *)buf;
        uint64_t v50 = v61;
        long long v21 = *(void ***)buf;
        if (v61 >= 0) {
          long long v21 = __p;
        }
        xpc_object_t object = &v57;
        xpc_object_t v52 = v21;
        sub_100035E70((uint64_t)&object, &v55, &v56);
        xpc_release(v56);
        xpc_object_t v56 = 0;
        if (SHIBYTE(v50) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(v55);
        xpc_object_t v55 = 0;
        if (SHIBYTE(v54) < 0) {
          operator delete(v53[0]);
        }
        xpc_object_t v47 = xpc_int64_create(*(unsigned int *)(v11 + 48));
        if (!v47) {
          xpc_object_t v47 = xpc_null_create();
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v61 = 0;
        ctu::cf::assign();
        *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
        uint64_t v54 = v61;
        long long v22 = *(xpc_object_t **)buf;
        if (v61 >= 0) {
          long long v22 = v53;
        }
        __p[0] = &v57;
        __p[1] = v22;
        sub_100035E70((uint64_t)__p, &v47, &v48);
        xpc_release(v48);
        xpc_object_t v48 = 0;
        if (SHIBYTE(v54) < 0) {
          operator delete(v53[0]);
        }
        xpc_release(v47);
        xpc_object_t v47 = 0;
        xpc_object_t v45 = xpc_int64_create(*(unsigned int *)(v2 + 176));
        if (!v45) {
          xpc_object_t v45 = xpc_null_create();
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v61 = 0;
        ctu::cf::assign();
        *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
        uint64_t v54 = v61;
        xpc_object_t v23 = *(xpc_object_t **)buf;
        if (v61 >= 0) {
          xpc_object_t v23 = v53;
        }
        __p[0] = &v57;
        __p[1] = v23;
        sub_100035E70((uint64_t)__p, &v45, &v46);
        xpc_release(v46);
        xpc_object_t v46 = 0;
        if (SHIBYTE(v54) < 0) {
          operator delete(v53[0]);
        }
        xpc_release(v45);
        xpc_object_t v45 = 0;
        if (*(unsigned __int8 *)(v11 + 36) > 1u)
        {
          AudioCodecInfo::getEvsBitrate((uint64_t *)v53, (AudioCodecInfo *)(v11 + 32));
          if (v54 >= 0) {
            xpc_object_t v25 = v53;
          }
          else {
            xpc_object_t v25 = (xpc_object_t *)v53[0];
          }
          xpc_object_t v43 = xpc_string_create((const char *)v25);
          if (!v43) {
            xpc_object_t v43 = xpc_null_create();
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v61 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long __p = *(_OWORD *)buf;
          uint64_t v50 = v61;
          uint64_t v26 = *(void ***)buf;
          if (v61 >= 0) {
            uint64_t v26 = __p;
          }
          xpc_object_t object = &v57;
          xpc_object_t v52 = v26;
          sub_100035E70((uint64_t)&object, &v43, &v44);
          xpc_release(v44);
          xpc_object_t v44 = 0;
          if (SHIBYTE(v50) < 0) {
            operator delete(__p[0]);
          }
          xpc_release(v43);
          xpc_object_t v43 = 0;
          if (SHIBYTE(v54) < 0) {
            operator delete(v53[0]);
          }
          AudioCodecInfo::getEvsBandwidth((uint64_t *)v53, (AudioCodecInfo *)(v11 + 32));
          if (v54 >= 0) {
            unsigned int v27 = v53;
          }
          else {
            unsigned int v27 = (xpc_object_t *)v53[0];
          }
          xpc_object_t v41 = xpc_string_create((const char *)v27);
          if (!v41) {
            xpc_object_t v41 = xpc_null_create();
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v61 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long __p = *(_OWORD *)buf;
          uint64_t v50 = v61;
          xpc_object_t v28 = *(void ***)buf;
          if (v61 >= 0) {
            xpc_object_t v28 = __p;
          }
          xpc_object_t object = &v57;
          xpc_object_t v52 = v28;
          sub_100035E70((uint64_t)&object, &v41, &v42);
          xpc_release(v42);
          xpc_object_t v42 = 0;
          if (SHIBYTE(v50) < 0) {
            operator delete(__p[0]);
          }
          xpc_release(v41);
          xpc_object_t v41 = 0;
          if (SHIBYTE(v54) < 0) {
            operator delete(v53[0]);
          }
        }
        else
        {
          xpc_object_t v44 = xpc_int64_create(*(unsigned int *)(v11 + 40));
          if (!v44) {
            xpc_object_t v44 = xpc_null_create();
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v61 = 0;
          ctu::cf::assign();
          *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
          uint64_t v54 = v61;
          xpc_object_t v24 = *(xpc_object_t **)buf;
          if (v61 >= 0) {
            xpc_object_t v24 = v53;
          }
          __p[0] = &v57;
          __p[1] = v24;
          sub_100035E70((uint64_t)__p, &v44, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          if (SHIBYTE(v54) < 0) {
            operator delete(v53[0]);
          }
          xpc_release(v44);
          xpc_object_t v44 = 0;
        }
      }
    }
    xpc_object_t v39 = xpc_BOOL_create(1);
    if (!v39) {
      xpc_object_t v39 = xpc_null_create();
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v61 = 0;
    ctu::cf::assign();
    *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
    uint64_t v54 = v61;
    uint64_t v29 = *(xpc_object_t **)buf;
    if (v61 >= 0) {
      uint64_t v29 = v53;
    }
    __p[0] = &v57;
    __p[1] = v29;
    sub_100035E70((uint64_t)__p, &v39, &v40);
    xpc_release(v40);
    xpc_object_t v40 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[0]);
    }
    xpc_release(v39);
    xpc_object_t v39 = 0;
  }
  else
  {
    if (sub_100A0D870(*(_DWORD *)(v2 + 168)))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v61 = 0;
      ctu::cf::assign();
      *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
      uint64_t v54 = v61;
      if (v61 >= 0) {
        uint64_t v15 = v53;
      }
      else {
        uint64_t v15 = (xpc_object_t *)v53[0];
      }
      xpc_object_t v55 = xpc_string_create((const char *)v15);
      if (!v55) {
        xpc_object_t v55 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v61 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v50 = v61;
      unsigned int v16 = *(void ***)buf;
      if (v61 >= 0) {
        unsigned int v16 = __p;
      }
      xpc_object_t object = &v57;
      xpc_object_t v52 = v16;
      sub_100035E70((uint64_t)&object, &v55, &v56);
      xpc_release(v56);
      xpc_object_t v56 = 0;
      if (SHIBYTE(v50) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v55);
      xpc_object_t v55 = 0;
      if (SHIBYTE(v54) < 0) {
        operator delete(v53[0]);
      }
      xpc_object_t v48 = xpc_int64_create(*(unsigned int *)(v2 + 172));
      if (!v48) {
        xpc_object_t v48 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v61 = 0;
      ctu::cf::assign();
      *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
      uint64_t v54 = v61;
      uint64_t v17 = *(xpc_object_t **)buf;
      if (v61 >= 0) {
        uint64_t v17 = v53;
      }
      __p[0] = &v57;
      __p[1] = v17;
      sub_100035E70((uint64_t)__p, &v48, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      if (SHIBYTE(v54) < 0) {
        operator delete(v53[0]);
      }
      xpc_release(v48);
      xpc_object_t v48 = 0;
      xpc_object_t v46 = xpc_int64_create(*(unsigned int *)(v2 + 176));
      if (!v46) {
        xpc_object_t v46 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v61 = 0;
      ctu::cf::assign();
      *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
      uint64_t v54 = v61;
      long long v18 = *(xpc_object_t **)buf;
      if (v61 >= 0) {
        long long v18 = v53;
      }
      __p[0] = &v57;
      __p[1] = v18;
      sub_100035E70((uint64_t)__p, &v46, &v47);
      xpc_release(v47);
      xpc_object_t v47 = 0;
      if (SHIBYTE(v54) < 0) {
        operator delete(v53[0]);
      }
      xpc_release(v46);
      xpc_object_t v46 = 0;
    }
    xpc_object_t v44 = xpc_BOOL_create(1);
    if (!v44) {
      xpc_object_t v44 = xpc_null_create();
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v61 = 0;
    ctu::cf::assign();
    *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
    uint64_t v54 = v61;
    uint64_t v19 = *(xpc_object_t **)buf;
    if (v61 >= 0) {
      uint64_t v19 = v53;
    }
    __p[0] = &v57;
    __p[1] = v19;
    sub_100035E70((uint64_t)__p, &v44, &v45);
    xpc_release(v45);
    xpc_object_t v45 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[0]);
    }
    xpc_release(v44);
    xpc_object_t v44 = 0;
  }
  if (*(unsigned char *)(v2 + 280)) {
    (*(void (**)(void))(**(void **)(v2 + 136) + 40))(*(void *)(v2 + 136));
  }
  if (v3)
  {
    BOOL v30 = v58 == 0;
    if (v58) {
      int v31 = 2;
    }
    else {
      int v31 = 1;
    }
    *(_DWORD *)(v2 + 188) = v31;
    if (v30) {
      xpc_object_t v32 = "BB vocoder";
    }
    else {
      xpc_object_t v32 = "AP vocoder";
    }
    xpc_object_t v37 = xpc_string_create(v32);
    if (!v37) {
      xpc_object_t v37 = xpc_null_create();
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v61 = 0;
    ctu::cf::assign();
    *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
    uint64_t v54 = v61;
    xpc_object_t v33 = v53;
    if (v61 < 0) {
      xpc_object_t v33 = (xpc_object_t *)v53[0];
    }
    __p[0] = &v57;
    __p[1] = v33;
    sub_100035E70((uint64_t)__p, &v37, &v38);
    xpc_release(v38);
    xpc_object_t v38 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[0]);
    }
  }
  else
  {
    int v34 = *(_DWORD *)(v2 + 188);
    switch(v34)
    {
      case 0:
        goto LABEL_144;
      case 2:
        xpc_object_t v35 = "AP vocoder";
        break;
      case 1:
        xpc_object_t v35 = "BB vocoder";
        break;
      default:
        xpc_object_t v35 = "AudioStackType Undefined";
        break;
    }
    xpc_object_t v37 = xpc_string_create(v35);
    if (!v37) {
      xpc_object_t v37 = xpc_null_create();
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v61 = 0;
    ctu::cf::assign();
    *(_OWORD *)xpc_object_t v53 = *(_OWORD *)buf;
    uint64_t v54 = v61;
    xpc_object_t v36 = v53;
    if (v61 < 0) {
      xpc_object_t v36 = (xpc_object_t *)v53[0];
    }
    __p[0] = &v57;
    __p[1] = v36;
    sub_100035E70((uint64_t)__p, &v37, &v38);
    xpc_release(v38);
    xpc_object_t v38 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[0]);
    }
  }
  xpc_release(v37);
  xpc_object_t v37 = 0;
LABEL_144:
  __p[0] = v57;
  if (v57) {
    xpc_retain(v57);
  }
  else {
    __p[0] = xpc_null_create();
  }
  *(void *)long long buf = v1[1];
  *(void *)&uint8_t buf[8] = "kAudioVocoderInfo";
  sub_10014E03C((uint64_t)buf, __p, v53);
  xpc_release(v53[0]);
  v53[0] = 0;
  xpc_release(__p[0]);
  __p[0] = 0;
  xpc_release(v57);
}

void sub_100D45224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, xpc_object_t a15, xpc_object_t a16, xpc_object_t a17, xpc_object_t a18, xpc_object_t a19, xpc_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (*(char *)(v32 - 73) < 0) {
    operator delete(*(void **)(v32 - 96));
  }
  xpc_release(object);
  if (a32 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v32 - 112));
  _Unwind_Resume(a1);
}

void sub_100D4555C(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v1 = *(_DWORD **)a1;
  uint64_t v2 = *(void *)(*(void *)a1 + 16);
  if (**(_DWORD **)a1 == 18) {
    *uint64_t v1 = *(_DWORD *)(v2 + 168);
  }
  if (!v1[1])
  {
    int v3 = *(_DWORD *)(v2 + 172);
    v1[1] = v3;
    signed int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I audioRateSwitchComplete: But user did not give SampleRate, using cache value of %d", buf, 8u);
    }
  }
  if (!v1[2])
  {
    int v5 = *(_DWORD *)(v2 + 176);
    v1[2] = v5;
    xpc_object_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I audioRateSwitchComplete: But user did not give I2SClockRate, using cache value of %d", buf, 8u);
    }
  }
  xpc_object_t v7 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Acking audio rate switch complete", buf, 2u);
  }
  int v8 = v1[2];
  uint64_t v9 = *(void *)(v2 + 136);
  *(void *)long long buf = *(void *)v1;
  int v12 = v8;
  int32x2_t v13 = vdup_n_s32(0x1F40u);
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 48))(v9, buf);
  operator delete();
}

void sub_100D45728()
{
}

void sub_100D45758()
{
}

__n128 sub_100D4576C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A53440;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D457C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A53440;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D457F8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  int v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D45840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D45880()
{
}

void sub_100D45890()
{
}

__n128 sub_100D458A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A534C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D458F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A534C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D45930(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  signed int v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v11 = (char **)*v3;
  int v12 = (char *)v5;
  int32x2_t v13 = (char *)v3[2];
  if (v13)
  {
    *(void *)(v5 + 16) = &v12;
    void *v3 = v4;
    *signed int v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v11 = &v12;
  }
  sub_100256368((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  uint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    *((void *)v12 + 2) = v10;
    uint64_t v11 = &v12;
    int v12 = 0;
    int32x2_t v13 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10[0]);
  sub_10005CD2C((uint64_t)&v11, v12);
}

void sub_100D45A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
}

uint64_t sub_100D45A58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D45A98()
{
}

void sub_100D45AA8()
{
}

void *sub_100D45ABC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A53540;
  result[1] = v3;
  return result;
}

uint64_t sub_100D45B04(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A53540;
  a2[1] = v2;
  return result;
}

uint64_t sub_100D45B30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D45B70()
{
}

void sub_100D45B80()
{
}

void *sub_100D45B94(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A535C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100D45BDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A535C0;
  a2[1] = v2;
  return result;
}

void sub_100D45C08(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100D45C10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D45C50()
{
}

void sub_100D45C60()
{
}

void *sub_100D45C74(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A53640;
  result[1] = v3;
  return result;
}

uint64_t sub_100D45CBC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A53640;
  a2[1] = v2;
  return result;
}

void sub_100D45CE8(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  xpc_object_t v33 = 0;
  int v34 = 0;
  uint64_t v35 = 0;
  sub_1001F299C((uint64_t *)&v33, a2);
  BOOL v30 = 0;
  int v31 = 0;
  uint64_t v32 = 0;
  sub_1001F1EB0(&v30, v33, v34, v34 - v33);
  uint64_t v3 = v30;
  signed int v4 = v31;
  if (v30 != v31)
  {
    uint64_t v29 = v31;
    do
    {
      xpc_object_t v5 = *v3;
      if (*v3)
      {
        xpc_retain(*v3);
        v2[1] = *v2;
        xpc_object_t v40 = v5;
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
        v2[1] = *v2;
        xpc_object_t v40 = v5;
        if (!v5)
        {
          xpc_object_t v5 = 0;
          xpc_object_t v40 = xpc_null_create();
          goto LABEL_7;
        }
      }
      xpc_retain(v5);
LABEL_7:
      int v39 = 0;
      xpc_object_t v36 = (void ***)&v40;
      xpc_object_t v37 = "kCallStatus";
      sub_100048BAC((uint64_t)&v36, &object);
      int v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
      xpc_release(object);
      int v39 = v7;
      if (isCallStateActive())
      {
        xpc_object_t v36 = (void ***)&v40;
        xpc_object_t v37 = "kCallSubType";
        sub_100048BAC((uint64_t)&v36, &object);
        char v9 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v8);
        xpc_release(object);
        xpc_object_t v36 = (void ***)&v40;
        xpc_object_t v37 = "kCallSimSlot";
        sub_100048BAC((uint64_t)&v36, &object);
        int v11 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v10);
        xpc_release(object);
        int v12 = v39;
        long long v14 = (char *)v2[1];
        unint64_t v13 = v2[2];
        if ((unint64_t)v14 >= v13)
        {
          unsigned int v16 = (char *)*v2;
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*v2] >> 2);
          unint64_t v18 = v17 + 1;
          if (v17 + 1 > 0x1555555555555555) {
            sub_10006A748();
          }
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v16) >> 2);
          if (2 * v19 > v18) {
            unint64_t v18 = 2 * v19;
          }
          if (v19 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v20 = 0x1555555555555555;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            if (v20 > 0x1555555555555555) {
              sub_10006A7CC();
            }
            long long v21 = v2;
            int v22 = v39;
            unint64_t v23 = v20;
            xpc_object_t v24 = (char *)operator new(12 * v20);
            int v12 = v22;
            unint64_t v20 = v23;
            uint64_t v2 = v21;
          }
          else
          {
            xpc_object_t v24 = 0;
          }
          xpc_object_t v25 = &v24[12 * v17];
          *xpc_object_t v25 = v9;
          *(_WORD *)(v25 + 1) = 0;
          v25[3] = 0;
          *((_DWORD *)v25 + 1) = v11;
          *((_DWORD *)v25 + 2) = v12;
          uint64_t v26 = v25;
          if (v14 == v16)
          {
            signed int v4 = v29;
          }
          else
          {
            signed int v4 = v29;
            do
            {
              uint64_t v27 = *(void *)(v14 - 12);
              v14 -= 12;
              int v28 = *((_DWORD *)v14 + 2);
              *(void *)(v26 - 12) = v27;
              v26 -= 12;
              *((_DWORD *)v26 + 2) = v28;
            }
            while (v14 != v16);
            long long v14 = (char *)*v2;
          }
          uint64_t v15 = v25 + 12;
          *uint64_t v2 = v26;
          v2[1] = v25 + 12;
          v2[2] = &v24[12 * v20];
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *long long v14 = v9;
          *(_WORD *)(v14 + 1) = 0;
          v14[3] = 0;
          uint64_t v15 = v14 + 12;
          *((_DWORD *)v14 + 1) = v11;
          *((_DWORD *)v14 + 2) = v12;
        }
        v2[1] = v15;
      }
      xpc_release(v40);
      xpc_release(v5);
      ++v3;
    }
    while (v3 != v4);
  }
  xpc_object_t v36 = &v30;
  sub_1001F1FAC((void ***)&v36);
  xpc_object_t v36 = &v33;
  sub_1001F1FAC((void ***)&v36);
}

void sub_100D46000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char *a16, uint64_t a17, xpc_object_t a18, uint64_t a19, xpc_object_t object)
{
  a16 = &a13;
  sub_1001F1FAC((void ***)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100D460BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D460FC()
{
}

uint64_t sub_100D46108(uint64_t a1)
{
  sub_100061E28((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100D46148(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100D46208(&v2, a2);
}

uint64_t sub_100D461C4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100D46208(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100D46274(&v2);
}

void sub_100D46260(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100D46274(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100D462E4(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100D462F8(_Unwind_Exception *a1)
{
}

void sub_100D46310()
{
}

uint64_t sub_100D46324(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100D46388()
{
  return 0;
}

uint64_t sub_100D46390()
{
  return 0;
}

uint64_t sub_100D46398()
{
  return 0;
}

void sub_100D463A0()
{
}

void sub_100D4641C()
{
}

uint64_t sub_100D46440(uint64_t a1, uint64_t a2)
{
  signed int v4 = sub_100D465CC((uint64_t *)a1, a2);
  sub_100D46638((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  xpc_object_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    int v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      int v11 = v10;
      int v12 = v5;
      if (v10)
      {
        do
        {
          unint64_t v13 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          unsigned int v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          xpc_object_t v5 = v16;
        }
        while (!v14);
      }
      unint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          unint64_t v18 = v17;
          unint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          unint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          int v7 = v18;
        }
        while (!v14);
      }
      xpc_object_t v5 = v16;
      int v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100D465A4(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D465CC(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100D46624(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D46638(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100D46688(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100D466A0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100D4670C(&v2);
}

void sub_100D466F8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100D4670C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100D4677C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100D46790(_Unwind_Exception *a1)
{
}

void sub_100D467A8()
{
}

uint64_t sub_100D467BC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100D46824()
{
  return 0;
}

uint64_t sub_100D4682C()
{
  return 0;
}

uint64_t sub_100D46834()
{
  return 0;
}

uint64_t *sub_100D4683C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_10000A4A8(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

void sub_100D468A8(uint64_t a1)
{
  sub_100D46B9C(a1);

  operator delete();
}

BOOL sub_100D468E0(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_10000A4A8((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_10000A4A8((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_100D46A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_100D46A5C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_100D46AB8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100061E28((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100D46B18()
{
}

uint64_t sub_100D46B2C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100061E28((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100D46B84()
{
  return 0;
}

uint64_t sub_100D46B8C()
{
  return 0;
}

uint64_t sub_100D46B94()
{
  return 0;
}

uint64_t sub_100D46B9C(uint64_t a1)
{
  *(void *)a1 = off_101A53780;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100D46C10()
{
}

uint64_t sub_100D46C24(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100D46C54()
{
  return 0;
}

uint64_t sub_100D46C5C()
{
  return 0;
}

uint64_t sub_100D46C64()
{
  return 0;
}

void sub_100D46C6C(uint64_t a1, void *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    uint64_t v6 = *(NSObject **)a1;
    *a2 = *(void *)a1;
    a2[1] = *(void *)(a1 + 8);
    dispatch_retain(v6);
    if (a3 != 1) {
      return;
    }
    long long v7 = *(NSObject **)a1;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *((_WORD *)a2 + 4) = 0;
      return;
    }
    long long v7 = *a2;
LABEL_10:
    dispatch_release(v7);
    return;
  }
  uint64_t v8 = (const char *)(*(void *)(*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
  if (v8 == (const char *)((unint64_t)"N3ctu12DispatchSlotIZN15AudioController16setupEvents_syncEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)
    || !strcmp(v8, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN15AudioController16setupEvents_syncEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    *a2 = a1;
  }
  else
  {
    *a2 = 0;
  }
}

uint64_t sub_100D46D4C(uint64_t result, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        a2[4] = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"ZN15AudioController16setupEvents_syncEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"ZN15AudioController16setupEvents_syncEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    *(void *)a2 = *(void *)result;
  }
  return result;
}

uint64_t sub_100D46DE4(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100D46E80(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100D46E90(_Unwind_Exception *a1)
{
}

void *sub_100D46EA4(void *a1)
{
  *a1 = off_101A538F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D46EF0(void *a1)
{
  *a1 = off_101A538F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100D46F5C()
{
}

void *sub_100D46FC8(void *a1)
{
  *a1 = off_101A53948;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100D47018()
{
}

__n128 sub_100D4702C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A53988;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D47080(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A53988;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D470B8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100D47178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100D47190(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D471D0()
{
}

void sub_100D471DC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (sub_100D410D0(v2, *((unsigned __int8 *)*a1 + 8)))
  {
    int v3 = *((unsigned __int8 *)v1 + 8);
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "true";
      if (!v3) {
        uint64_t v5 = "false";
      }
      *(_DWORD *)long long buf = 136315138;
      int v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Persisting audio logging setting value: %s", buf, 0xCu);
    }
    uint64_t v6 = &kCFBooleanTrue;
    if (!v3) {
      uint64_t v6 = &kCFBooleanFalse;
    }
    (*(void (**)(void, const __CFString *, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v2 + 120) + 16))(*(void *)(v2 + 120), @"AudioLoggingEnabled", *v6, @"com.apple.commcenter.audio", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    int v7 = (*(uint64_t (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v2 + 120) + 48))(*(void *)(v2 + 120), @"com.apple.commcenter.audio", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    uint64_t v8 = *(NSObject **)(v2 + 40);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (!v9) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v10 = "#I Successfully persisted the AudioLoggingEnabled key";
    }
    else
    {
      if (!v9) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v10 = "#N Failed to persist the AudioLoggingEnabled key";
    }
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
  }
LABEL_14:
  operator delete();
}

void sub_100D473E0()
{
}

uint64_t *sub_100D4740C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void))(**(void **)(*v1 + 152) + 32))(*(void *)(*v1 + 152)))
  {
    unsigned __int8 v3 = sub_100D40F50(v2);
    xpc_object_t object = xpc_BOOL_create(v3);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t object = xpc_BOOL_create(0);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
  }
  v7[0] = v1[1];
  v7[1] = "kAudioLoggingEnabled";
  sub_100035E70((uint64_t)v7, &object, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(object);
  sub_10024F798((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100D47534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100D47550(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = *((_DWORD *)v1 + 2);
  uint64_t v4 = *(uint64_t **)(*v1 + 368);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v4;
        int v6 = *((_DWORD *)v4 + 7);
        if (v6 <= v3) {
          break;
        }
        uint64_t v4 = *v5;
        int v7 = v5;
        if (!*v5) {
          goto LABEL_10;
        }
      }
      if (v6 >= v3)
      {
        uint64_t v10 = v5;
        goto LABEL_13;
      }
      uint64_t v4 = v5[1];
    }
    while (v4);
    int v7 = v5 + 1;
  }
  else
  {
    int v7 = (uint64_t **)(v2 + 368);
    uint64_t v5 = (uint64_t **)(v2 + 368);
  }
LABEL_10:
  uint64_t v10 = operator new(0x38uLL);
  v10[7] = v3;
  AudioCodecInfo::AudioCodecInfo((AudioCodecInfo *)(v10 + 8));
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = v5;
  *int v7 = (uint64_t *)v10;
  uint64_t v8 = **(void **)(v2 + 360);
  xpc_object_t v9 = (uint64_t *)v10;
  if (v8)
  {
    *(void *)(v2 + 360) = v8;
    xpc_object_t v9 = *v7;
  }
  sub_100046C90(*(uint64_t **)(v2 + 368), v9);
  ++*(void *)(v2 + 376);
LABEL_13:
  long long v11 = *(_OWORD *)((char *)v1 + 12);
  *((void *)v10 + 6) = *(uint64_t *)((char *)v1 + 28);
  *((_OWORD *)v10 + 2) = v11;
  int v12 = *(std::__shared_weak_count **)(v2 + 96);
  v16[0] = *(void *)(v2 + 88);
  v16[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v13 = (capabilities::ct *)sub_100D415E0((sd::IMSSubscriberConfigInterface *)v16, *((unsigned int *)v1 + 2));
  if (v13)
  {
    char v14 = capabilities::ct::supportsSetVoLTEAudioCodec(v13);
    if (v12) {
      sub_10004D2C8(v12);
    }
    if ((v14 & 1) == 0) {
      return 1;
    }
  }
  else if (v12)
  {
    sub_10004D2C8(v12);
  }
  return 0;
}

void sub_100D47698(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100D476C0()
{
}

void sub_100D476FC(SystemConfigurationFactoryInterface *a1)
{
  SystemConfigurationFactoryInterface::~SystemConfigurationFactoryInterface(a1);

  operator delete();
}

void sub_100D47738(RegistrationInterface *a1)
{
  RegistrationInterface::~RegistrationInterface(a1);

  operator delete();
}

uint64_t sub_100D47770(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10002F4E8(a3, 0);
}

uint64_t sub_100D4777C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47788(a3, 0);
}

uint64_t sub_100D47788(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100D477DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100356304(a3, 0);
}

uint64_t sub_100D477E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

uint64_t sub_100D477F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100060854(a3, 0x2D00000001);
}

uint64_t sub_100D47804(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47814(a3, 0, 0);
}

uint64_t sub_100D47814(uint64_t a1, char a2, char a3)
{
  char v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_100D47870(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D4787C(a3, 14);
}

uint64_t sub_100D4787C(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100D478D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D478E0(a3, -1, -1);
}

uint64_t sub_100D478E0(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void sub_100D4793C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_100D47948(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = 0;
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 48))(v3, __p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D479BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D479D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = 0;
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 48))(v3, __p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D47A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D47A68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47A74(a3, 11);
}

uint64_t sub_100D47A74(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

void sub_100D47AC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = 0;
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 48))(v3, __p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D47B3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D47B58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MCC::MCC((MCC *)&v5);
  uint64_t v4 = *(void *)(a3 + 24);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, &v5);
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_100D47BD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D47BEC(MCC *a1@<X8>)
{
}

void sub_100D47BF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MNC::MNC((MNC *)&v5);
  uint64_t v4 = *(void *)(a3 + 24);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, &v5);
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_100D47C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D47C88(MNC *a1@<X8>)
{
}

uint64_t sub_100D47C90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

void sub_100D47C9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MCC::MCC((MCC *)&v5);
  uint64_t v4 = *(void *)(a3 + 24);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, &v5);
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_100D47D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D47D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47D3C(a3, 0);
}

uint64_t sub_100D47D3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100D47D90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47D9C(a3, 0);
}

uint64_t sub_100D47D9C(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100D47DF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D47DFC(a3, 4);
}

uint64_t sub_100D47DFC(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

void sub_100D47E50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NetworkListOperator::NetworkListOperator((NetworkListOperator *)&v4);
  sub_100D47EE8(a3, 0, 2);
  if (v11 < 0) {
    operator delete(__p);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
}

void sub_100D47ED4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004BEA24((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100D47EE8(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_100D47F44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

uint64_t sub_100D47F50()
{
  return 0;
}

uint64_t sub_100D47F58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100060854(a3, 0x2D00000001);
}

uint64_t sub_100D47F68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100060854(a3, 0x2D00000001);
}

uint64_t sub_100D47F78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100060854(a4, 0x2D00000001);
}

void sub_100D47F88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NetworkListOperator::NetworkListOperator((NetworkListOperator *)v5);
  uint64_t v4 = *(void *)(a3 + 24);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v4 + 48))(v4, v5);
  if (v12 < 0) {
    operator delete(__p);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_100D48030(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004BEA24((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100D48044(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v4, 0, sizeof(v4));
  uint64_t v3 = *(void *)(a3 + 24);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v4);
  int v5 = (void **)v4;
  sub_1004C3EF8(&v5);
}

void sub_100D480B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1004C3EF8(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100D480D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

uint64_t sub_100D480E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = std::generic_category();

  return sub_100D48124(a3, 0, 45, (uint64_t)v4);
}

uint64_t sub_100D48124(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v7 = a2;
  v6[0] = a3;
  v6[1] = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, void *))(*(void *)v4 + 48))(v4, &v7, v6);
}

void sub_100D48180(NRStatus *a1@<X8>)
{
  NRDisableStatus::NRDisableStatus((NRDisableStatus *)v2, 1, 1);
  NRStatus::NRStatus(a1, 0, 0, (const NRDisableStatus *)v2);
}

uint64_t sub_100D481CC()
{
  return 0x2D00000002;
}

uint64_t sub_100D481D8()
{
  return 0x2D00000002;
}

uint64_t sub_100D481EC()
{
  return 14;
}

uint64_t sub_100D481F4()
{
  return 0;
}

uint64_t sub_100D4820C()
{
  return 0;
}

uint64_t sub_100D4824C()
{
  return 1;
}

uint64_t sub_100D48254()
{
  return 11;
}

uint64_t sub_100D4825C()
{
  return 0;
}

void sub_100D48270(uint64_t a1, int a2)
{
  int v11 = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    goto LABEL_11;
  }
  uint64_t v3 = a1 + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      char v6 = (uint64_t *)v2;
    }
    else {
      char v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 8 && *(_DWORD *)(v3 + 32) <= a2)
  {
    uint64_t v7 = *(int *)(v3 + 44);
    if (v7 <= 4) {
      *(_DWORD *)(v3 + 44) = dword_10156A6B0[v7];
    }
  }
  else
  {
LABEL_11:
    __int16 v10 = 0;
    *(_OWORD *)long long __p = 0u;
    long long v9 = 0u;
    sub_100D49290((uint64_t **)a1, &v11, &v11, (uint64_t)__p);
    if (__p[1])
    {
      *(void **)&long long v9 = __p[1];
      operator delete(__p[1]);
    }
  }
}

void sub_100D48324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D48340(uint64_t a1, os_log_t *a2)
{
  *(_DWORD *)(a1 + 24) = 0;
  int v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    char v6 = "kNone";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sim file manager: new read stage = %s", (uint8_t *)&v5, 0xCu);
  }
  sub_100D48400(a1, a2);
}

void sub_100D48400(uint64_t a1, os_log_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 == 1)
  {
    char v12 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      v19[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Sim file manager: reset files that can't be read in locked state", (uint8_t *)v19, 2u);
    }
    uint64_t v15 = *(void **)a1;
    unint64_t v13 = (void *)(a1 + 8);
    char v14 = v15;
    if (v15 != v13)
    {
      do
      {
        if (*((_DWORD *)v14 + 8))
        {
          unsigned int v16 = (void *)v14[6];
          void v14[5] = 0;
          if (v16)
          {
            v14[7] = v16;
            operator delete(v16);
          }
          void v14[6] = 0;
          v14[7] = 0;
          *((_WORD *)v14 + 36) = 0;
          char v14[8] = 0;
        }
        unint64_t v17 = (void *)v14[1];
        if (v17)
        {
          do
          {
            unint64_t v18 = v17;
            unint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            unint64_t v18 = (void *)v14[2];
            BOOL v11 = *v18 == (void)v14;
            char v14 = v18;
          }
          while (!v11);
        }
        char v14 = v18;
      }
      while (v18 != v13);
    }
  }
  else if (!v3)
  {
    int v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sim file manager: reset all files data", buf, 2u);
    }
    uint64_t v7 = *(void **)a1;
    int v5 = (void *)(a1 + 8);
    char v6 = v7;
    if (v7 != v5)
    {
      do
      {
        char v8 = (void *)v6[6];
        v6[5] = 0;
        if (v8)
        {
          v6[7] = v8;
          operator delete(v8);
        }
        v6[6] = 0;
        v6[7] = 0;
        *((_WORD *)v6 + 36) = 0;
        v6[8] = 0;
        long long v9 = (void *)v6[1];
        if (v9)
        {
          do
          {
            __int16 v10 = v9;
            long long v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            __int16 v10 = (void *)v6[2];
            BOOL v11 = *v10 == (void)v6;
            char v6 = v10;
          }
          while (!v11);
        }
        char v6 = v10;
      }
      while (v10 != v5);
    }
  }
}

uint64_t sub_100D48594(uint64_t a1, char a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  int v3 = *(void **)a1;
  if (*(void *)a1 == a1 + 8) {
    return 1;
  }
  while (1)
  {
    if (subscriber::isSimFileEssential()
      && (subscriber::getSimCardForSimFilePath() != 2 || (a2 & 1) == 0)
      && (*(_DWORD *)(a1 + 24) != 1 || !*((_DWORD *)v3 + 8)))
    {
      unsigned int v6 = *((_DWORD *)v3 + 11);
      if (v6 < 5 && ((0x17u >> v6) & 1) != 0) {
        break;
      }
    }
    uint64_t v7 = (void *)v3[1];
    if (v7)
    {
      do
      {
        char v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        char v8 = (void *)v3[2];
        BOOL v9 = *v8 == (void)v3;
        int v3 = v8;
      }
      while (!v9);
    }
    int v3 = v8;
    if (v8 == v2) {
      return 1;
    }
  }
  return 0;
}

void sub_100D48668(void *a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v3 = a1 + 1;
  int v4 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    uint64_t v7 = (uint64_t)(a3 + 2);
    do
    {
      uint64_t v8 = *(void *)(a2 + 24);
      int v26 = *((_DWORD *)v4 + 8);
      if (!v8) {
        sub_10007B600();
      }
      if ((*(uint64_t (**)(uint64_t, int *))(*(void *)v8 + 48))(v8, &v26))
      {
        unsigned int v9 = *((_DWORD *)v4 + 11);
        BOOL v10 = v9 > 4;
        int v11 = (1 << v9) & 0x13;
        BOOL v12 = v10 || v11 == 0;
        if (!v12)
        {
          char v14 = a3[1];
          unint64_t v13 = (unint64_t)a3[2];
          if ((unint64_t)v14 >= v13)
          {
            unsigned int v16 = *a3;
            uint64_t v17 = (v14 - *a3) >> 2;
            unint64_t v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62) {
              sub_10006A748();
            }
            uint64_t v19 = v13 - (void)v16;
            if (v19 >> 1 > v18) {
              unint64_t v18 = v19 >> 1;
            }
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v20 = v18;
            }
            if (v20)
            {
              long long v21 = (char *)sub_10005ECD8(v7, v20);
              unsigned int v16 = *a3;
              char v14 = a3[1];
            }
            else
            {
              long long v21 = 0;
            }
            int v22 = &v21[4 * v17];
            *(_DWORD *)int v22 = *((_DWORD *)v4 + 8);
            uint64_t v15 = v22 + 4;
            while (v14 != v16)
            {
              int v23 = *((_DWORD *)v14 - 1);
              v14 -= 4;
              *((_DWORD *)v22 - 1) = v23;
              v22 -= 4;
            }
            *a3 = v22;
            a3[1] = v15;
            a3[2] = &v21[4 * v20];
            if (v16) {
              operator delete(v16);
            }
          }
          else
          {
            *(_DWORD *)char v14 = *((_DWORD *)v4 + 8);
            uint64_t v15 = v14 + 4;
          }
          a3[1] = v15;
          *((_DWORD *)v4 + 11) = 2;
        }
      }
      xpc_object_t v24 = (void *)v4[1];
      if (v24)
      {
        do
        {
          xpc_object_t v25 = v24;
          xpc_object_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          xpc_object_t v25 = (void *)v4[2];
          BOOL v12 = *v25 == (void)v4;
          int v4 = v25;
        }
        while (!v12);
      }
      int v4 = v25;
    }
    while (v25 != v3);
  }
}

void sub_100D4882C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100D48850@<X0>(void *result@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, void *a5@<X8>)
{
  int v5 = result;
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  int v7 = *((_DWORD *)result + 6);
  if (v7 == 2)
  {
    unsigned int v13 = sub_100D48594((uint64_t)result, a3);
    uint64_t v14 = 0x10000;
    if (!a4) {
      uint64_t v14 = 0;
    }
    uint64_t v15 = 256;
    if (!a3) {
      uint64_t v15 = 0;
    }
    v19[0] = off_101A53DD0;
    v19[1] = a2;
    v19[2] = v14 | v15 | v13;
    v19[3] = v19;
    sub_100D48668(v5, (uint64_t)v19, (char **)&v17);
    uint64_t v16 = v18;
    *(_OWORD *)a5 = v17;
    a5[2] = v16;
    uint64_t v18 = 0;
    long long v17 = 0uLL;
    unsigned int v9 = v19;
  }
  else
  {
    if (v7 != 1) {
      return result;
    }
    v20[0] = off_101A53D40;
    v20[3] = v20;
    sub_100D48668(result, (uint64_t)v20, (char **)&v17);
    uint64_t v8 = v18;
    *(_OWORD *)a5 = v17;
    a5[2] = v8;
    uint64_t v18 = 0;
    long long v17 = 0uLL;
    unsigned int v9 = v20;
  }
  return sub_100D4944C(v9);
}

void sub_100D489B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100D4944C(va);
  _Unwind_Resume(a1);
}

void sub_100D489D8(uint64_t a1, os_log_t *a2)
{
  if (subscriber::isSimReady())
  {
    int v4 = 2;
  }
  else if (subscriber::isSimLocked() & 1) != 0 || (subscriber::isSimPermanentlyBlocked())
  {
    int v4 = 1;
  }
  else
  {
    if (!subscriber::isSimSettled()) {
      return;
    }
    int v4 = 0;
  }
  int v5 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = off_101A53E40[v4];
    uint64_t v7 = *(int *)(a1 + 24);
    if (v7 > 2) {
      uint64_t v8 = "?";
    }
    else {
      uint64_t v8 = off_101A53E40[v7];
    }
    int v9 = 136315394;
    BOOL v10 = v6;
    __int16 v11 = 2080;
    BOOL v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sim file manager: read stage = %s (was %s)", (uint8_t *)&v9, 0x16u);
  }
  if (v4 != *(_DWORD *)(a1 + 24))
  {
    *(_DWORD *)(a1 + 24) = v4;
    sub_100D48400(a1, a2);
  }
}

BOOL sub_100D48B18(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v2 || *(_DWORD *)(v5 + 32) > a2) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(v5 + 44);
  return v10 > 4 || (v10 & 0x1F) == 2;
}

uint64_t sub_100D48B80(uint64_t **a1, int a2)
{
  int v7 = a2;
  if (sub_100D48B18((uint64_t)a1, a2))
  {
    uint64_t v8 = &v7;
    uint64_t v3 = sub_100D49628(a1, &v7, (uint64_t)&unk_10144E20E, &v8);
    int v4 = *((_DWORD *)v3 + 10) != 2;
    v3[7] = v3[6];
    v3[5] = (uint64_t *)0x300000002;
    int v5 = 1;
  }
  else
  {
    int v5 = 0;
    int v4 = 0;
  }
  return v5 | (v4 << 8);
}

uint64_t sub_100D48C0C(uint64_t **a1, int a2, uint64_t a3)
{
  int v12 = a2;
  if (sub_100D48B18((uint64_t)a1, a2))
  {
    unsigned int v13 = &v12;
    int v5 = sub_100D49628(a1, &v12, (uint64_t)&unk_10144E20E, &v13);
    int v6 = v5;
    int v9 = *((_DWORD *)v5 + 10) != 1
      || (int v7 = v5[6], v8 = (char *)v6[7] - (char *)v7, v8 != *(void *)(a3 + 8) - *(void *)a3)
      || memcmp(v7, *(const void **)a3, v8) != 0;
    sub_10005C9A4((uint64_t)(v6 + 6), (__n128 *)a3);
    v6[5] = (uint64_t *)0x300000001;
    int v10 = 1;
  }
  else
  {
    int v10 = 0;
    int v9 = 0;
  }
  return v10 | (v9 << 8);
}

uint64_t sub_100D48CD8(uint64_t a1, int a2, char *a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t result = a1 + 8;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = result;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        int v9 = (uint64_t *)v4;
      }
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != result && *(_DWORD *)(v6 + 32) <= a2)
    {
      char v10 = *a3;
      if (!*(unsigned char *)(v6 + 73)) {
        *(unsigned char *)(v6 + 73) = 1;
      }
      *(unsigned char *)(v6 + 72) = v10;
    }
  }
  return result;
}

uint64_t sub_100D48D30(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = v2;
    do
    {
      int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        BOOL v8 = (uint64_t *)v3;
      }
      else {
        BOOL v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 == v2 || *(_DWORD *)(v5 + 32) > a2)
    {
      LOBYTE(v9) = 0;
      LODWORD(v3) = 0;
    }
    else
    {
      unsigned int v9 = *(unsigned __int16 *)(v5 + 72);
      LODWORD(v3) = v9 >> 8;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  return v9 | (v3 << 8);
}

double sub_100D48D94@<D0>(uint64_t a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v4 = a1 + 8;
  uint64_t v5 = v6;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (v6)
  {
    uint64_t v8 = v4;
    do
    {
      int v9 = *(_DWORD *)(v5 + 32);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        __int16 v11 = (uint64_t *)v5;
      }
      else {
        __int16 v11 = (uint64_t *)(v5 + 8);
      }
      if (!v10) {
        uint64_t v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 != v4 && *(_DWORD *)(v8 + 32) <= a2)
    {
      if ((a2 - 1) < 2)
      {
        ctu::hex((uint64_t *)&v13, *(ctu **)(v8 + 48), (const void *)(*(void *)(v8 + 56) - *(void *)(v8 + 48)), a3);
      }
      else if (a2)
      {
        if (a2 != 3) {
          return result;
        }
        subscriber::sDecodeImsi((uint64_t *)&v13, *(subscriber **)(v8 + 48), (const unsigned __int8 *)(*(void *)(v8 + 56) - *(void *)(v8 + 48)), a3);
      }
      else
      {
        subscriber::sDecodeIccid((uint64_t *)&v13, *(subscriber **)(v8 + 48), (const unsigned __int8 *)(*(void *)(v8 + 56) - *(void *)(v8 + 48)), a3);
      }
      double result = *(double *)&v13;
      *(_OWORD *)a4 = v13;
      a4[2] = v14;
    }
  }
  return result;
}

uint64_t sub_100D48E60(uint64_t a1, NSObject **a2)
{
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  sub_10004DE24((uint64_t)v20);
  uint64_t v4 = (void *)(a1 + 8);
  uint64_t v5 = *(void **)a1;
  memset(&v35, 0, sizeof(v35));
  if (v5 != (void *)(a1 + 8))
  {
    sub_100D496F8(&__s, (uint64_t)(v5 + 4));
    uint64_t v6 = (void *)v5[1];
    std::string v35 = __s;
    if (v6)
    {
      do
      {
        BOOL v7 = v6;
        uint64_t v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        BOOL v7 = (void *)v5[2];
        BOOL v8 = *v7 == (void)v5;
        uint64_t v5 = v7;
      }
      while (!v8);
    }
    if (v7 != v4)
    {
      do
      {
        *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
        strcpy((char *)&__s, ", ");
        std::string::append(&v35, (const std::string::value_type *)&__s, 2uLL);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
        sub_100D496F8(&__s, (uint64_t)(v7 + 4));
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_s = &__s;
        }
        else {
          p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
        }
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __s.__r_.__value_.__l.__size_;
        }
        std::string::append(&v35, (const std::string::value_type *)p_s, size);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
        __int16 v11 = (void *)v7[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            __int16 v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v7[2];
            BOOL v8 = *v12 == (void)v7;
            BOOL v7 = v12;
          }
          while (!v8);
        }
        BOOL v7 = v12;
      }
      while (v12 != v4);
    }
  }
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v13 = &v35;
  }
  else {
    long long v13 = (std::string *)v35.__r_.__value_.__r.__words[0];
  }
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v35.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v20, (uint64_t)v13, v14);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  uint64_t v15 = *a2;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(int *)(a1 + 24);
    long long v17 = v16 > 2 ? "?" : off_101A53E40[v16];
    sub_10004BC98((uint64_t)v20 + 8, &__s);
    uint64_t v18 = (__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__s
        : (std::string *)__s.__r_.__value_.__r.__words[0];
    LODWORD(v35.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v35.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    WORD2(v35.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v35.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I fReadStage= %s ; files=[%{public}s]",
      (uint8_t *)&v35,
      0x16u);
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100D491D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100D49230@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  double result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = result;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v4;
    }
    else {
      int v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = (void *)v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *((_DWORD *)v6 + 8) <= a2)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return sub_10005C928(a3, (const void *)v6[6], v6[7], v6[7] - v6[6]);
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return result;
}

uint64_t **sub_100D49290(uint64_t **a1, int *a2, _DWORD *a3, uint64_t a4)
{
  BOOL v8 = a1 + 1;
  int v7 = a1[1];
  if (v7)
  {
    int v9 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v10 = (uint64_t **)v7;
        int v11 = *((_DWORD *)v7 + 8);
        if (v9 >= v11) {
          break;
        }
        int v7 = *v10;
        BOOL v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }
      if (v11 >= v9) {
        break;
      }
      int v7 = v10[1];
      if (!v7)
      {
        BOOL v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v10 = a1 + 1;
LABEL_10:
    int v12 = operator new(0x50uLL);
    unsigned char v12[8] = *a3;
    *((void *)v12 + 5) = *(void *)a4;
    *((_OWORD *)v12 + 3) = *(_OWORD *)(a4 + 8);
    *((void *)v12 + 8) = *(void *)(a4 + 24);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    *((_WORD *)v12 + 36) = *(_WORD *)(a4 + 32);
    sub_100046C38(a1, (uint64_t)v10, v8, (uint64_t *)v12);
    return (uint64_t **)v12;
  }
  return v10;
}

void sub_100D4937C()
{
}

void *sub_100D49390()
{
  double result = operator new(0x10uLL);
  *double result = off_101A53D40;
  return result;
}

void sub_100D493C8(uint64_t a1, void *a2)
{
  *a2 = off_101A53D40;
}

BOOL sub_100D493F0(uint64_t a1, _DWORD *a2)
{
  return *a2 == 0;
}

uint64_t sub_100D49400(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D49440()
{
}

void *sub_100D4944C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D494D4()
{
}

__n128 sub_100D494E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A53DD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100D49534(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A53DD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D49564(unsigned char *a1)
{
  if (subscriber::getSimCardForSimFilePath() == 2 && a1[17] != 0) {
    return 0;
  }
  if (a1[16]) {
    return a1[18] == 0;
  }

  return subscriber::isSimFileEssential();
}

uint64_t sub_100D495DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D4961C()
{
}

uint64_t **sub_100D49628(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    int v11 = (char *)operator new(0x50uLL);
    *((_DWORD *)v11 + 8) = **a4;
    *((void *)v11 + 9) = 0;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

double sub_100D496F8(std::string *a1, uint64_t a2)
{
  memset(&v21, 0, sizeof(v21));
  uint64_t v4 = (char *)subscriber::asString();
  uint64_t v5 = (std::string *)sub_100058DB0(&v21, v4);
  if (*(unsigned char *)(a2 + 40)) {
    uint64_t v6 = "[w]";
  }
  else {
    uint64_t v6 = "[-]";
  }
  if (*(unsigned char *)(a2 + 41)) {
    int v7 = v6;
  }
  else {
    int v7 = "[?]";
  }
  std::string::append(v5, v7, 3uLL);
  uint64_t v8 = *(int *)(a2 + 12);
  if v8 <= 4 && ((0x17u >> v8)) {
    std::string::append(&v21, off_101A53E58[v8], qword_10156A6C8[v8]);
  }
  int v9 = *(_DWORD *)(a2 + 8);
  if (v9 == 1)
  {
    std::to_string(&v17, *(void *)(a2 + 24) - *(void *)(a2 + 16));
    int v10 = std::string::insert(&v17, 0, ":", 1uLL);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    int v12 = std::string::append(&v18, "B", 1uLL);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    int64_t v20 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    if (v20 >= 0) {
      std::string::size_type v14 = __p;
    }
    else {
      std::string::size_type v14 = (void **)__p[0];
    }
    if (v20 >= 0) {
      std::string::size_type v15 = HIBYTE(v20);
    }
    else {
      std::string::size_type v15 = (std::string::size_type)__p[1];
    }
    std::string::append(&v21, (const std::string::value_type *)v14, v15);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
  }
  else if (v9 == 2)
  {
    std::string::append(&v21, ":none", 5uLL);
  }
  double result = *(double *)&v21.__r_.__value_.__l.__data_;
  *a1 = v21;
  return result;
}

void sub_100D498AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v28 - 17) < 0) {
    operator delete(*(void **)(v28 - 40));
  }
  _Unwind_Resume(exception_object);
}

void sub_100D49914()
{
}

double sub_100D49A08(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  *(_WORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 32);
    if (v2) {
      uint64_t v2 = *(void *)(v2 + 24);
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  *(void *)(a1 + 24) = v2;
  *(void *)a1 = off_101A53E90;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(void *)(a1 + 32) = off_101A1EBD0;
  *(unsigned char *)(a1 + 104) = 0;
  return result;
}

void sub_100D49A90()
{
}

void sub_100D49AD8()
{
}

void sub_100D49B78()
{
  sub_100365414(v0);
  operator delete();
}

uint64_t sub_100D49BA0(uint64_t a1, char *__s)
{
  uint64_t v2 = __s;
  memset(&__dst, 0, sizeof(__dst));
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v4 = strchr(__s, 59);
  if (v4)
  {
    uint64_t v5 = v4;
    sub_10003ECB8(&__dst, v2, ((_BYTE)v4 - (_BYTE)v2));
    uint64_t v2 = v5 + 1;
    p_p = (std::string *)&__p;
  }
  else
  {
    p_p = &__dst;
  }
  sub_10003ED78(p_p, v2);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  uint64_t v8 = sub_1003656DC(a1, (char *)p_dst);
  if (v8)
  {
    if (SHIBYTE(v13) < 0)
    {
      if (!v12) {
        goto LABEL_14;
      }
      int v9 = (char *)__p;
    }
    else
    {
      if (!HIBYTE(v13)) {
        goto LABEL_14;
      }
      int v9 = (char *)&__p;
    }
    sub_10095B7BC(a1 + 32, v9);
  }
LABEL_14:
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v8;
}

void sub_100D49C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D49CC0(uint64_t a1, std::string *a2)
{
  uint64_t v4 = sub_10036580C(a1, a2);
  if (v4) {
    sub_10095B4B0(a1 + 32, a2);
  }
  return v4;
}

uint64_t sub_100D49D08(unsigned char *a1, uint64_t a2)
{
  unsigned int v20 = 0;
  if (a1[104])
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v18 = 0;
    sub_100FEC944(a2, (std::string *)__p, 0xFFFFFFFF);
    if ((SBYTE7(v18) & 0x80u) == 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    uint64_t v5 = (*(uint64_t (**)(unsigned char *, void **))(*(void *)a1 + 16))(a1, v4);
    if (SBYTE7(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    if (!sub_100FECA8C(a2, (int *)&v20)) {
      return 0;
    }
    unsigned int v6 = v20;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    uint64_t v7 = *(unsigned int *)(a2 + 20);
    BOOL v9 = v8 >= v7;
    unsigned int v10 = v8 - v7;
    if (v10 == 0 || !v9 || v20 > v10)
    {
      return 0;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      *(_DWORD *)(a2 + 20) = v7 + 1;
      a1[17] = *(unsigned char *)(v12 + v7);
      uint64_t v19 = 0;
      *(_OWORD *)long long __p = 0u;
      long long v18 = 0u;
      sub_100FEC818((ctu::OsLogLogger *)__p, a2, v6 - 1);
      uint64_t v13 = sub_100FED928((uint64_t)__p, (uint64_t)(a1 + 32));
      uint64_t v5 = v13;
      if (v13)
      {
        int v14 = DWORD1(v18);
        int v15 = *(_DWORD *)(a2 + 20);
        if ((*(_DWORD *)(a2 + 16) - v15) < DWORD1(v18)) {
          int v14 = *(_DWORD *)(a2 + 16) - v15;
        }
        *(_DWORD *)(a2 + 20) = v14 + v15;
      }
      ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
    }
  }
  return v5;
}

void sub_100D49E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

BOOL sub_100D49E78(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    std::string::push_back((std::string *)(a2 + 8), byte_101B0B234 | 0x80);
  }
  return v2 != 0;
}

BOOL sub_100D49EB8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)long long __p = 0u;
  long long v10 = 0u;
  LODWORD(__p[0]) = *(_DWORD *)a2;
  uint64_t v11 = 0;
  __p[1] = 0;
  long long v10 = 0uLL;
  std::string::push_back((std::string *)&__p[1], *(unsigned char *)(a1 + 17));
  BOOL v4 = sub_10078E9B4((uint64_t)__p, a1 + 32);
  if (v4)
  {
    if (v10 >= 0) {
      unsigned int v5 = HIBYTE(v10);
    }
    else {
      unsigned int v5 = v10;
    }
    sub_10078E718(a2, v5);
    if (v10 >= 0) {
      unsigned int v6 = (const std::string::value_type *)&__p[1];
    }
    else {
      unsigned int v6 = (const std::string::value_type *)__p[1];
    }
    if (v10 >= 0) {
      std::string::size_type v7 = HIBYTE(v10);
    }
    else {
      std::string::size_type v7 = v10;
    }
    std::string::append((std::string *)(a2 + 8), v6, v7);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  return v4;
}

void sub_100D49F80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100D49FA0()
{
  return "content-disposition";
}

uint64_t sub_100D49FAC(void *a1)
{
  *a1 = off_101A53E90;
  sub_100CC9A2C(a1 + 4);

  return sub_100365414((uint64_t)a1);
}

void sub_100D4A000(void *a1)
{
  *a1 = off_101A53E90;
  sub_100CC9A2C(a1 + 4);
  sub_100365414((uint64_t)a1);

  operator delete();
}

void sub_100D4A068(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v4 = ServiceMap;
  if (v5 < 0)
  {
    unsigned int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  long long __p = (void *)v5;
  BOOL v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__p);
  if (v9)
  {
    uint64_t v11 = (GestaltUtilityInterface *)v9[3];
    long long v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  long long v10 = 0;
  char v12 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  *a2 = 0;
  a2[1] = 0;
  if ((isWatch & 1) == 0) {
    operator new();
  }
}

void sub_100D4A588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    (*((void (**)(dispatch_object_t))a11->isa + 1))(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

const char *sub_100D4A7D4(int a1)
{
  uint64_t v1 = "subscr.alert.?";
  if (a1 == 2) {
    uint64_t v1 = "subscr.alert.2";
  }
  if (a1 == 1) {
    return "subscr.alert.1";
  }
  else {
    return v1;
  }
}

void sub_100D4A800(uint64_t a1)
{
  *(void *)a1 = off_101A53F20;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 432);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000346F8(a1 + 392, *(void **)(a1 + 400));
  sub_10005D144(*(void **)(a1 + 368));
  sub_100D4FBEC(*(const void ***)(a1 + 344));
  sub_10005D144(*(void **)(a1 + 320));
  sub_10030AB98((void *)(a1 + 272));
  sub_1000886C0(a1 + 248, *(char **)(a1 + 256));
  if (*(unsigned char *)(a1 + 240) && *(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  BOOL v9 = (void **)(a1 + 192);
  sub_1000C56F4(&v9);
  sub_100088048(a1 + 152, *(void **)(a1 + 160));
  sub_100088048(a1 + 128, *(void **)(a1 + 136));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  SubscriberUserAlertManagerInterface::~SubscriberUserAlertManagerInterface((SubscriberUserAlertManagerInterface *)a1);
}

void sub_100D4A978(uint64_t a1)
{
  sub_100D4A800(a1);

  operator delete();
}

void sub_100D4A9B0(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4AAB0(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)(a1 + 128);
  if (!sub_100D4DFD4(a2, (void *)(a1 + 128))) {
    return;
  }
  if (sub_100D4CA88(a1 + 56, v3))
  {
    for (uint64_t i = *(void *)(a1 + 192); i != *(void *)(a1 + 200); i += 88)
    {
      if (*(unsigned char *)(i + 80)) {
        BOOL v5 = *(void *)(i + 56) == *(void *)(i + 64);
      }
      else {
        BOOL v5 = 1;
      }
      if (!v5) {
        goto LABEL_23;
      }
    }
    BOOL v9 = *(void **)(a1 + 128);
    long long v10 = (void *)(a1 + 136);
    if (v9 == (void *)(a1 + 136))
    {
LABEL_23:
      sub_100D4D710(a1, 1u);
      sub_100D4D7E4((const void **)a1, 1);
      sub_100A37530((uint64_t **)(a1 + 312), 1);
      sub_100D52D50(a1 + 336, 1);
      goto LABEL_24;
    }
    while (subscriber::isEsimCapable())
    {
      uint64_t v11 = (void *)v9[1];
      if (v11)
      {
        do
        {
          char v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          char v12 = (void *)v9[2];
          BOOL v5 = *v12 == (void)v9;
          BOOL v9 = v12;
        }
        while (!v5);
      }
      BOOL v9 = v12;
      if (v12 == v10) {
        goto LABEL_23;
      }
    }
    uint64_t v13 = (void *)*v3;
    if (v13 != v10)
    {
      while (subscriber::isSimAbsent() && (subscriber::isPhySimDisabled() & 1) == 0)
      {
        int v14 = (void *)v13[1];
        if (v14)
        {
          do
          {
            int v15 = v14;
            int v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            int v15 = (void *)v13[2];
            BOOL v5 = *v15 == (void)v13;
            uint64_t v13 = v15;
          }
          while (!v5);
        }
        uint64_t v13 = v15;
        if (v15 == v10) {
          goto LABEL_36;
        }
      }
      goto LABEL_23;
    }
LABEL_36:
    if (*(unsigned char *)(a1 + 384))
    {
      int v16 = *(unsigned __int8 *)(a1 + 385);
      std::string v17 = *(NSObject **)(a1 + 40);
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v16)
      {
        if (v18)
        {
          *(_WORD *)std::string v21 = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I NO SIM alert is suppressed by user", v21, 2u);
        }
        *(unsigned char *)(a1 + 384) = 0;
      }
      else
      {
        if (v18)
        {
          *(_WORD *)unsigned int v20 = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I enqueue NO SIM alert", v20, 2u);
        }
        sub_10005D144(*(void **)(a1 + 320));
        *(void *)(a1 + 320) = 0;
        *(void *)(a1 + 328) = 0;
        *(void *)(a1 + 312) = a1 + 320;
        unsigned int v19 = 1;
        sub_1001DA584((uint64_t **)(a1 + 312), 1, &v19);
        sub_100D4CBEC(a1);
      }
      goto LABEL_24;
    }
    unsigned int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v22 = 0;
      uint64_t v7 = "#I No SIM alert not allowed";
      uint64_t v8 = (uint8_t *)&v22;
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v7 = "#I SIMs not settled, wait to evaluate No SIM state";
      uint64_t v8 = buf;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
    }
  }
LABEL_24:

  sub_100D4D948(a1);
}

void **sub_100D4AD64(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)(a1 + 152);
  double result = (void **)sub_100D4DFD4(a2, (void *)(a1 + 152));
  if (!result) {
    return result;
  }
  xpc_object_t v57 = _os_activity_create((void *)&_mh_execute_header, "sim state changed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v57, &state);
  os_activity_scope_leave(&state);
  BOOL v5 = *(void **)(a1 + 152);
  unsigned int v6 = (void *)(a1 + 160);
  if (v5 == (void *)(a1 + 160))
  {
LABEL_41:
    sub_1000346F8(a1 + 392, *(void **)(a1 + 400));
    *(void *)(a1 + 400) = 0;
    *(void *)(a1 + 408) = 0;
    *(void *)(a1 + 392) = a1 + 400;
    sub_100D4D7E4((const void **)a1, 2);
    sub_100A37530((uint64_t **)(a1 + 312), 2);
    sub_100D52D50(a1 + 336, 2);
  }
  else
  {
    char v7 = 0;
    char v8 = 0;
    BOOL v9 = (uint64_t *)(a1 + 400);
    long long v10 = (uint64_t **)(a1 + 320);
    while (subscriber::isSimSettled())
    {
      uint64_t v11 = *v9;
      if (!*v9) {
        goto LABEL_15;
      }
      int v12 = *((_DWORD *)v5 + 8);
      uint64_t v13 = a1 + 400;
      do
      {
        int v14 = *(_DWORD *)(v11 + 28);
        BOOL v15 = v14 < v12;
        if (v14 >= v12) {
          int v16 = (uint64_t *)v11;
        }
        else {
          int v16 = (uint64_t *)(v11 + 8);
        }
        if (!v15) {
          uint64_t v13 = v11;
        }
        uint64_t v11 = *v16;
      }
      while (*v16);
      if ((uint64_t *)v13 == v9 || v12 < *(_DWORD *)(v13 + 28)) {
LABEL_15:
      }
        uint64_t v13 = a1 + 400;
      int isSimPermanentlyBlocked = subscriber::isSimPermanentlyBlocked();
      if ((uint64_t *)v13 == v9) {
        int v18 = isSimPermanentlyBlocked;
      }
      else {
        int v18 = 0;
      }
      if (v18 == 1)
      {
        unsigned int v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v5 + 8));
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(state.opaque[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I enqueue Permanently Blocked SIM alert", (uint8_t *)&state, 2u);
        }
        unsigned int v20 = *v10;
        std::string v21 = (uint64_t **)(a1 + 320);
        __int16 v22 = (uint64_t **)(a1 + 320);
        if (*v10)
        {
          while (1)
          {
            while (1)
            {
              __int16 v22 = (uint64_t **)v20;
              int v23 = *((_DWORD *)v20 + 7);
              if (v23 < 3) {
                break;
              }
              unsigned int v20 = *v22;
              std::string v21 = v22;
              if (!*v22) {
                goto LABEL_29;
              }
            }
            if (v23 == 2) {
              break;
            }
            unsigned int v20 = v22[1];
            if (!v20)
            {
              std::string v21 = v22 + 1;
              goto LABEL_29;
            }
          }
        }
        else
        {
LABEL_29:
          long long v24 = (uint64_t *)operator new(0x28uLL);
          *((_DWORD *)v24 + 7) = 2;
          *((_DWORD *)v24 + 8) = *((_DWORD *)v5 + 8);
          sub_100046C38((uint64_t **)(a1 + 312), (uint64_t)v22, v21, v24);
        }
        char v8 = 1;
        char v7 = 1;
      }
      else
      {
        v7 |= isSimPermanentlyBlocked;
      }
      long long v25 = (void *)v5[1];
      if (v25)
      {
        do
        {
          long long v26 = v25;
          long long v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          long long v26 = (void *)v5[2];
          BOOL v27 = *v26 == (void)v5;
          BOOL v5 = v26;
        }
        while (!v27);
      }
      BOOL v5 = v26;
      if (v26 == v6)
      {
        if (v8) {
          sub_100D4CBEC(a1);
        }
        if (v7) {
          break;
        }
        goto LABEL_41;
      }
    }
  }
  uint64_t v28 = (void *)*v3;
  if ((void *)*v3 == v6) {
    goto LABEL_72;
  }
  char v29 = 0;
  char v30 = 0;
  long long v31 = (uint64_t *)(a1 + 368);
  do
  {
    if (subscriber::isSimSettled())
    {
      int isSimDead = subscriber::isSimDead();
      v30 |= isSimDead;
      uint64_t v33 = *v31;
      if (!*v31) {
        goto LABEL_56;
      }
      int v34 = *((_DWORD *)v28 + 11);
      uint64_t v35 = a1 + 368;
      do
      {
        int v36 = *(_DWORD *)(v33 + 28);
        BOOL v37 = v36 < v34;
        if (v36 >= v34) {
          xpc_object_t v38 = (uint64_t *)v33;
        }
        else {
          xpc_object_t v38 = (uint64_t *)(v33 + 8);
        }
        if (!v37) {
          uint64_t v35 = v33;
        }
        uint64_t v33 = *v38;
      }
      while (*v38);
      if ((uint64_t *)v35 == v31 || v34 < *(_DWORD *)(v35 + 28) || *(_DWORD *)(v35 + 32) != *((_DWORD *)v28 + 12))
      {
LABEL_56:
        if (isSimDead)
        {
          if (subscriber::isSimReady())
          {
            int v39 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
            {
              uint64_t v42 = subscriber::asString();
              LODWORD(state.opaque[0]) = 136315138;
              *(uint64_t *)((char *)state.opaque + 4) = v42;
              _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Ready to Dead SIM on (%s)", (uint8_t *)&state, 0xCu);
            }
          }
          char v30 = 1;
          char v29 = 1;
        }
      }
    }
    xpc_object_t v40 = (void *)v28[1];
    if (v40)
    {
      do
      {
        xpc_object_t v41 = v40;
        xpc_object_t v40 = (void *)*v40;
      }
      while (v40);
    }
    else
    {
      do
      {
        xpc_object_t v41 = (void *)v28[2];
        BOOL v27 = *v41 == (void)v28;
        uint64_t v28 = v41;
      }
      while (!v27);
    }
    uint64_t v28 = v41;
  }
  while (v41 != v6);
  if (v29)
  {
    xpc_object_t v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(state.opaque[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I enqueue Dead SIM alert", (uint8_t *)&state, 2u);
    }
    LODWORD(state.opaque[0]) = 3;
    sub_1001DA584((uint64_t **)(a1 + 312), 3, (unsigned int *)&state);
    sub_100D4CBEC(a1);
    goto LABEL_73;
  }
  if ((v30 & 1) == 0)
  {
LABEL_72:
    sub_100D4D7E4((const void **)a1, 3);
    sub_100A37530((uint64_t **)(a1 + 312), 3);
    sub_100D52D50(a1 + 336, 3);
  }
LABEL_73:
  if (sub_100D4CA88(a1 + 56, v3))
  {
    if (sub_100D4E11C(v3))
    {
      sub_100D4CBEC(a1);
    }
    else
    {
      sub_100D4D7E4((const void **)a1, 5);
      sub_100A37530((uint64_t **)(a1 + 312), 5);
      sub_100D52D50(a1 + 336, 5);
    }
  }
  xpc_object_t v44 = (void *)*v3;
  if ((void *)*v3 != v6)
  {
    xpc_object_t v45 = (uint64_t **)(a1 + 368);
    do
    {
      if (subscriber::isSimSettled())
      {
        int v46 = *((_DWORD *)v44 + 12);
        xpc_object_t v47 = *v45;
        xpc_object_t v48 = (uint64_t **)(a1 + 368);
        xpc_object_t v49 = (uint64_t **)(a1 + 368);
        if (*v45)
        {
          int v50 = *((_DWORD *)v44 + 11);
          do
          {
            while (1)
            {
              xpc_object_t v49 = (uint64_t **)v47;
              int v51 = *((_DWORD *)v47 + 7);
              if (v51 <= v50) {
                break;
              }
              xpc_object_t v47 = *v49;
              xpc_object_t v48 = v49;
              if (!*v49) {
                goto LABEL_89;
              }
            }
            if (v51 >= v50)
            {
              uint64_t v54 = v49;
              goto LABEL_92;
            }
            xpc_object_t v47 = v49[1];
          }
          while (v47);
          xpc_object_t v48 = v49 + 1;
        }
LABEL_89:
        uint64_t v54 = operator new(0x28uLL);
        v54[7] = *((_DWORD *)v44 + 11);
        char v54[8] = 0;
        *(void *)uint64_t v54 = 0;
        *((void *)v54 + 1) = 0;
        *((void *)v54 + 2) = v49;
        *xpc_object_t v48 = (uint64_t *)v54;
        uint64_t v52 = **(void **)(a1 + 360);
        xpc_object_t v53 = (uint64_t *)v54;
        if (v52)
        {
          *(void *)(a1 + 360) = v52;
          xpc_object_t v53 = *v48;
        }
        sub_100046C90(*(uint64_t **)(a1 + 368), v53);
        ++*(void *)(a1 + 376);
LABEL_92:
        char v54[8] = v46;
      }
      xpc_object_t v55 = (void *)v44[1];
      if (v55)
      {
        do
        {
          xpc_object_t v56 = v55;
          xpc_object_t v55 = (void *)*v55;
        }
        while (v55);
      }
      else
      {
        do
        {
          xpc_object_t v56 = (void *)v44[2];
          BOOL v27 = *v56 == (void)v44;
          xpc_object_t v44 = v56;
        }
        while (!v27);
      }
      xpc_object_t v44 = v56;
    }
    while (v56 != v6);
  }
  return sub_100687EB8((void **)&v57);
}

void sub_100D4B340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100687EB8((void **)va);
  _Unwind_Resume(a1);
}

void sub_100D4B360(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 176);
  if (v2 != a2)
  {
    BOOL v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v5 = "true";
      if (!v2) {
        BOOL v5 = "false";
      }
      int v6 = 136315138;
      char v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SpringBoardFinishedStartup state : %s", (uint8_t *)&v6, 0xCu);
    }
    sub_100D4CBEC(a1);
  }
}

void sub_100D4B430(uint64_t a1)
{
  int v2 = (DisplayStatus *)(a1 + 177);
  if ((operator==() & 1) == 0)
  {
    DisplayStatus::dumpState(v2, (const ctu::OsLogLogger *)(a1 + 40));
    if (*(unsigned char *)(a1 + 177))
    {
      if (!*(unsigned char *)(a1 + 178) && !*(unsigned char *)(a1 + 179))
      {
        uint64_t v3 = *(uint64_t **)(a1 + 336);
        if ((uint64_t *)(a1 + 344) != v3)
        {
          do
          {
            sub_100D4D7E4((const void **)a1, *((_DWORD *)v3 + 8));
            BOOL v4 = sub_10006C514((uint64_t **)(a1 + 336), v3);
            sub_1001D88DC((const void **)v3 + 5);
            operator delete(v3);
            uint64_t v3 = v4;
          }
          while ((uint64_t *)(a1 + 344) != v4);
        }
      }
    }
    sub_100D4CBEC(a1);
  }
}

void sub_100D4B4F8(uint64_t a1, int a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I buddy state changed : %s, previous : %s", buf, 0x16u);
  }
  if (*(_DWORD *)(a1 + 184) == 1)
  {
    v18[0] = off_101A54778;
    v18[1] = a1;
    uint64_t v18[3] = v18;
    sub_100D4DD48(a1, (uint64_t)v18);
    sub_100D5172C(v18);
  }
  else
  {
    sub_100D4CBEC(a1);
  }
  if (a2 == 1 && *(_DWORD *)(a1 + 184) != 1)
  {
    BOOL v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v5 || (uint64_t v6 = *(void *)(a1 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
      sub_100088B9C();
    }
    char v8 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v7);
    BOOL v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I schedule timer for RUIM alert", buf, 2u);
    }
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 56));
    uint64_t v10 = *(void *)buf;
    sub_100058DB0(__p, "RUIM alert");
    uint64_t v11 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v11;
    if (v11) {
      dispatch_retain(v11);
    }
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 1174405120;
    v12[2] = sub_100D4E19C;
    void v12[3] = &unk_101A53F80;
    void v12[4] = a1;
    v12[5] = v6;
    uint64_t v13 = v8;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    aBlock = _Block_copy(v12);
    sub_10027A2C0(v10, (uint64_t)__p, 0, 5000000, &object, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v13) {
      std::__shared_weak_count::__release_weak(v13);
    }
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_100D4B798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100D4B82C(void *result, int a2)
{
  if (*((unsigned char *)result + 188)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = a2 == 0;
  }
  if (!v2)
  {
    v3[0] = off_101A547F8;
    v3[1] = result;
    v3[3] = v3;
    sub_100D4DD48((uint64_t)result, (uint64_t)v3);
    return sub_100D5172C(v3);
  }
  return result;
}

void sub_100D4B8C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100D5172C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100D4B8D4(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 176)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = (uint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SpringBoardFinishedStartup state : %s", buf, 0xCu);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v4 = "true";
    if (*(unsigned char *)(a1 + 178)) {
      BOOL v5 = "true";
    }
    else {
      BOOL v5 = "false";
    }
    int v6 = *(unsigned __int8 *)(a1 + 179);
    if (*(unsigned char *)(a1 + 177)) {
      char v7 = "true";
    }
    else {
      char v7 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    if (!v6) {
      BOOL v4 = "false";
    }
    uint64_t v30 = (uint64_t)v5;
    __int16 v31 = 2080;
    uint64_t v32 = (uint64_t)v7;
    __int16 v33 = 2080;
    int v34 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I display status : locked %s, on %s, coversheet active %s", buf, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = asString();
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I buddy state : %s", buf, 0xCu);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = "true";
    if (*(unsigned char *)(a1 + 384)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    if (!*(unsigned char *)(a1 + 385)) {
      BOOL v9 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v30 = (uint64_t)v10;
    __int16 v31 = 2080;
    uint64_t v32 = (uint64_t)v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I no sim alert allowed : %s, suppressed : %s", buf, 0x16u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 416)) {
      uint64_t v11 = "true";
    }
    else {
      uint64_t v11 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = (uint64_t)v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I RUIM alert shown: %s", buf, 0xCu);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 417)) {
      int v12 = "true";
    }
    else {
      int v12 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = (uint64_t)v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I sim unlock in progress : %s", buf, 0xCu);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 418)) {
      uint64_t v13 = "true";
    }
    else {
      uint64_t v13 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = (uint64_t)v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I sim unlock allowed during buddy : %s", buf, 0xCu);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 424)) {
      int v14 = "true";
    }
    else {
      int v14 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v30 = (uint64_t)v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset assertion held: %s", buf, 0xCu);
  }
  BOOL v15 = *(void **)(a1 + 152);
  if (v15 != (void *)(a1 + 160))
  {
    do
    {
      BOOL v16 = sub_100D4F488(a1, *((unsigned int *)v15 + 8));
      char v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v15 + 8));
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (v16) {
          int v18 = "true";
        }
        else {
          int v18 = "false";
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v30 = (uint64_t)v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I sim unlock alert allowed : %s", buf, 0xCu);
      }
      unsigned int v19 = (void *)v15[1];
      if (v19)
      {
        do
        {
          unsigned int v20 = v19;
          unsigned int v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          unsigned int v20 = (void *)v15[2];
          BOOL v21 = *v20 == (void)v15;
          BOOL v15 = v20;
        }
        while (!v21);
      }
      BOOL v15 = v20;
    }
    while (v20 != (void *)(a1 + 160));
  }
  __int16 v22 = *(void **)(a1 + 312);
  if (v22 != (void *)(a1 + 320))
  {
    do
    {
      int v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v24 = *((_DWORD *)v22 + 7) - 1;
        long long v25 = "kNone";
        if (v24 <= 4) {
          long long v25 = off_101A54868[v24];
        }
        uint64_t v26 = subscriber::asString();
        *(_DWORD *)long long buf = 136315394;
        uint64_t v30 = (uint64_t)v25;
        __int16 v31 = 2080;
        uint64_t v32 = v26;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I pending alert : %s (%s)", buf, 0x16u);
      }
      BOOL v27 = (void *)v22[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          BOOL v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v22[2];
          BOOL v21 = *v28 == (void)v22;
          __int16 v22 = v28;
        }
        while (!v21);
      }
      __int16 v22 = v28;
    }
    while (v28 != (void *)(a1 + 320));
  }
}

void sub_100D4BE70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4BF60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C050(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C140(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C230(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C320(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C400(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C4E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C5C0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  long long v29 = 0u;
  memset(&v30, 0, sizeof(v30));
  long long v27 = 0u;
  long long v28 = 0u;
  memset(v26, 0, sizeof(v26));
  LOBYTE(v26[0]) = 1;
  BOOL v4 = *(void **)(a1 + 248);
  BOOL v5 = (void *)(a1 + 256);
  if (v4 != (void *)(a1 + 256))
  {
    do
    {
      int v6 = *((_DWORD *)v4 + 8);
      char v7 = (std::string *)((char *)&v28 + 8);
      if (v6 == 2 || (char v7 = (std::string *)&v27, v6 == 1))
      {
        std::string::operator=(v7, (const std::string *)(v4 + 5));
      }
      else
      {
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Invalid slot in IMEIs", buf, 2u);
        }
      }
      BOOL v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v4[2];
          BOOL v11 = *v10 == (void)v4;
          BOOL v4 = v10;
        }
        while (!v11);
      }
      BOOL v4 = v10;
    }
    while (v10 != v5);
  }
  if (*(unsigned char *)(a1 + 178)) {
    goto LABEL_14;
  }
  if (*(unsigned char *)(a1 + 240))
  {
    if (*(char *)(a1 + 239) < 0)
    {
      if (!*(void *)(a1 + 224)) {
        goto LABEL_37;
      }
    }
    else if (!*(unsigned char *)(a1 + 239))
    {
      goto LABEL_37;
    }
    std::string::operator=(&v30, (const std::string *)(a1 + 216));
  }
LABEL_37:
  uint64_t v13 = *(_DWORD **)(a1 + 192);
  int v14 = *(_DWORD **)(a1 + 200);
  if (v13 != v14)
  {
    while (!*v13)
    {
      v13 += 22;
      if (v13 == v14) {
        goto LABEL_14;
      }
    }
    ctu::hex((uint64_t *)buf, (ctu *)(v13 + 4), (const void *)0x10, a3);
    if (SHIBYTE(v26[3]) < 0) {
      operator delete((void *)v26[1]);
    }
    *(_OWORD *)&v26[1] = *(_OWORD *)buf;
    v26[3] = v25;
  }
LABEL_14:
  uint64_t v12 = *(void *)(a1 + 96);
  sub_100D4F62C((uint64_t)v15, (uint64_t)v26);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v12 + 72))(v12, v15);
  if (v23 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(*((void **)&v28 + 1));
  }
  if (SBYTE7(v28) < 0) {
    operator delete((void *)v27);
  }
  if (SHIBYTE(v26[3]) < 0) {
    operator delete((void *)v26[1]);
  }
}

void sub_100D4C838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t sub_100D4C864(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100D4C8C8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4C9A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100D4CA88(uint64_t a1, void *a2)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  subscriber::makeSimSlotRange();
  long long __p = 0;
  BOOL v15 = 0;
  uint64_t v16 = 0;
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  sub_100D1BF74(&__p, v13, v12);
  uint64_t v3 = __p;
  if (a2[2] < (unint64_t)((v15 - (unsigned char *)__p) >> 2))
  {
    uint64_t isSimSettled = 0;
    if (!__p) {
      return isSimSettled;
    }
    goto LABEL_13;
  }
  char v7 = (void *)*a2;
  BOOL v5 = a2 + 1;
  int v6 = v7;
  if (v7 == v5)
  {
    uint64_t isSimSettled = 1;
    if (!__p) {
      return isSimSettled;
    }
    goto LABEL_13;
  }
  do
  {
    uint64_t isSimSettled = subscriber::isSimSettled();
    if (!isSimSettled) {
      break;
    }
    uint64_t v8 = (void *)v6[1];
    if (v8)
    {
      do
      {
        BOOL v9 = v8;
        uint64_t v8 = (void *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        BOOL v9 = (void *)v6[2];
        BOOL v10 = *v9 == (void)v6;
        int v6 = v9;
      }
      while (!v10);
    }
    int v6 = v9;
  }
  while (v9 != v5);
  uint64_t v3 = __p;
  if (__p)
  {
LABEL_13:
    BOOL v15 = v3;
    operator delete(v3);
  }
  return isSimSettled;
}

void sub_100D4CBD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D4CBEC(uint64_t a1)
{
  if (!*(void *)(a1 + 328)) {
    return;
  }
  if (*(unsigned char *)(a1 + 176))
  {
    uint64_t v2 = *(void *)(a1 + 320);
    if (!v2) {
      return;
    }
    uint64_t v3 = (uint64_t *)(a1 + 320);
    uint64_t v4 = a1 + 320;
    uint64_t v5 = *(void *)(a1 + 320);
    do
    {
      int v6 = *(_DWORD *)(v5 + 28);
      BOOL v7 = v6 < 1;
      if (v6 >= 1) {
        uint64_t v8 = (uint64_t *)v5;
      }
      else {
        uint64_t v8 = (uint64_t *)(v5 + 8);
      }
      if (!v7) {
        uint64_t v4 = v5;
      }
      uint64_t v5 = *v8;
    }
    while (*v8);
    if ((uint64_t *)v4 == v3)
    {
      uint64_t v10 = a1 + 320;
    }
    else
    {
      int v9 = *(_DWORD *)(v4 + 28);
      uint64_t v10 = a1 + 320;
      if (v9 <= 1)
      {
        if (*(_DWORD *)(a1 + 184) == 1)
        {
          BOOL v11 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v12 = "#I not showing NO SIM alert in buddy";
LABEL_18:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
            return;
          }
          return;
        }
        uint64_t v34 = *(void *)(a1 + 344);
        if (v34)
        {
          uint64_t v35 = a1 + 344;
          do
          {
            int v36 = *(_DWORD *)(v34 + 32);
            BOOL v37 = v36 < 1;
            if (v36 >= 1) {
              xpc_object_t v38 = (uint64_t *)v34;
            }
            else {
              xpc_object_t v38 = (uint64_t *)(v34 + 8);
            }
            if (!v37) {
              uint64_t v35 = v34;
            }
            uint64_t v34 = *v38;
          }
          while (*v38);
          if (v35 != a1 + 344 && *(int *)(v35 + 32) <= 1)
          {
            uint64_t v39 = *(void *)(a1 + 96);
            sub_1001D89F0(&v79, (const void **)(v35 + 40));
            LODWORD(v39) = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v39 + 48))(v39, &v79);
            sub_1001D88DC(&v79);
            if (v39)
            {
              BOOL v11 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                uint64_t v12 = "#I No SIM alert is already active";
                goto LABEL_18;
              }
              return;
            }
          }
        }
        xpc_object_t v40 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I showing NO SIM alert", buf, 2u);
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(v41, *(Registry **)(a1 + 56));
        xpc_object_t v43 = ServiceMap;
        if (v44 < 0)
        {
          xpc_object_t v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v46 = 5381;
          do
          {
            uint64_t v44 = v46;
            unsigned int v47 = *v45++;
            uint64_t v46 = (33 * v46) ^ v47;
          }
          while (v47);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v44;
        xpc_object_t v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)buf);
        if (v48)
        {
          uint64_t v50 = v48[3];
          xpc_object_t v49 = (std::__shared_weak_count *)v48[4];
          if (v49)
          {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v43);
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v49);
            char v51 = 0;
            goto LABEL_100;
          }
        }
        else
        {
          uint64_t v50 = 0;
        }
        std::mutex::unlock(v43);
        xpc_object_t v49 = 0;
        char v51 = 1;
LABEL_100:
        if (v50)
        {
          *(_OWORD *)long long __p = 0u;
          long long v83 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v81 = 0u;
          uint64_t v52 = kCBMessageLocalizationTable;
          (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v50 + 40))(&v78, v50, kCBMessageLocalizationTable, @"NO_SIM_CARD_INSTALLED", @"NO_SIM_CARD_INSTALLED");
          xpc_object_t v84 = *(const void **)buf;
          *(void *)long long buf = v78;
          xpc_object_t v78 = 0;
          sub_1000558F4(&v84);
          sub_1000558F4(&v78);
          (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v50 + 40))(&v78, v50, v52, @"OK", @"OK");
          xpc_object_t v84 = *(const void **)&buf[8];
          *(void *)&uint8_t buf[8] = v78;
          xpc_object_t v78 = 0;
          sub_1000558F4(&v84);
          sub_1000558F4(&v78);
          BYTE8(v83) = 1;
          (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 40))(&v78);
          int v77 = 1;
          xpc_object_t v53 = (const void **)(sub_1002C74D0((uint64_t **)(a1 + 336), 1, &v77) + 5);
          if (v53 != &v78)
          {
            xpc_object_t v84 = *v53;
            *xpc_object_t v53 = v78;
            xpc_object_t v78 = 0;
            sub_1001D88DC(&v84);
          }
          sub_1001D88DC(&v78);
          if (!*(unsigned char *)(a1 + 178))
          {
            sub_100A37530((uint64_t **)(a1 + 312), 1);
            sub_100D4D710(a1, 0);
          }
          if (SBYTE7(v83) < 0) {
            operator delete(__p[0]);
          }
          sub_1000558F4((const void **)&v81 + 1);
          sub_1000558F4((const void **)&v81);
          sub_1000558F4((const void **)&buf[8]);
          sub_1000558F4((const void **)buf);
          if (v51) {
            return;
          }
        }
        else
        {
          uint64_t v54 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
            if (v51) {
              return;
            }
          }
          else if (v51)
          {
            return;
          }
        }
        sub_10004D2C8(v49);
        return;
      }
    }
    do
    {
      int v13 = *(_DWORD *)(v2 + 28);
      BOOL v14 = v13 < 2;
      if (v13 >= 2) {
        BOOL v15 = (uint64_t *)v2;
      }
      else {
        BOOL v15 = (uint64_t *)(v2 + 8);
      }
      if (!v14) {
        uint64_t v10 = v2;
      }
      uint64_t v2 = *v15;
    }
    while (*v15);
    if ((uint64_t *)v10 == v3 || *(int *)(v10 + 28) > 2)
    {
LABEL_33:
      uint64_t v17 = *v3;
      if (*v3)
      {
        uint64_t v18 = a1 + 320;
        do
        {
          int v19 = *(_DWORD *)(v17 + 28);
          BOOL v20 = v19 < 3;
          if (v19 >= 3) {
            char v21 = (uint64_t *)v17;
          }
          else {
            char v21 = (uint64_t *)(v17 + 8);
          }
          if (!v20) {
            uint64_t v18 = v17;
          }
          uint64_t v17 = *v21;
        }
        while (*v21);
        if ((uint64_t *)v18 != v3 && *(int *)(v18 + 28) <= 3)
        {
          if (!*(unsigned char *)(a1 + 177) || *(unsigned char *)(a1 + 178) || *(unsigned char *)(a1 + 179))
          {
            __int16 v22 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I display is not on/unlocked, can't show alert", buf, 2u);
            }
          }
          else
          {
            sub_100D4E250(a1);
          }
        }
        uint64_t v23 = *v3;
        if (*v3)
        {
          uint64_t v24 = a1 + 320;
          do
          {
            int v25 = *(_DWORD *)(v23 + 28);
            BOOL v26 = v25 < 4;
            if (v25 >= 4) {
              long long v27 = (uint64_t *)v23;
            }
            else {
              long long v27 = (uint64_t *)(v23 + 8);
            }
            if (!v26) {
              uint64_t v24 = v23;
            }
            uint64_t v23 = *v27;
          }
          while (*v27);
          if ((uint64_t *)v24 != v3 && *(int *)(v24 + 28) <= 4)
          {
            if (!*(unsigned char *)(a1 + 177) || *(unsigned char *)(a1 + 178) || *(unsigned char *)(a1 + 179))
            {
              long long v28 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I display is not on/unlocked, can't show alert", buf, 2u);
              }
            }
            else
            {
              sub_100D4E584(a1);
            }
          }
          uint64_t v29 = *v3;
          if (*v3)
          {
            uint64_t v30 = a1 + 320;
            do
            {
              int v31 = *(_DWORD *)(v29 + 28);
              BOOL v32 = v31 < 5;
              if (v31 >= 5) {
                __int16 v33 = (uint64_t *)v29;
              }
              else {
                __int16 v33 = (uint64_t *)(v29 + 8);
              }
              if (!v32) {
                uint64_t v30 = v29;
              }
              uint64_t v29 = *v33;
            }
            while (*v33);
            if ((uint64_t *)v30 != v3 && *(int *)(v30 + 28) <= 5 && sub_100D4EA58(a1))
            {
              sub_100D4EB70(a1);
            }
          }
        }
      }
      return;
    }
    if (!*(unsigned char *)(a1 + 177) || *(unsigned char *)(a1 + 178) || *(unsigned char *)(a1 + 179))
    {
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I display is not on/unlocked, can't show alert", buf, 2u);
      }
      goto LABEL_33;
    }
    xpc_object_t v55 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I showing Permanently Blocked SIM alert", buf, 2u);
    }
    xpc_object_t v57 = (std::mutex *)Registry::getServiceMap(v56, *(Registry **)(a1 + 56));
    char v58 = v57;
    if (v59 < 0)
    {
      xpc_object_t v60 = (unsigned __int8 *)(v59 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v61 = 5381;
      do
      {
        uint64_t v59 = v61;
        unsigned int v62 = *v60++;
        uint64_t v61 = (33 * v61) ^ v62;
      }
      while (v62);
    }
    std::mutex::lock(v57);
    *(void *)long long buf = v59;
    xpc_object_t v63 = sub_10004D37C(&v58[1].__m_.__sig, (unint64_t *)buf);
    if (v63)
    {
      uint64_t v65 = v63[3];
      xpc_object_t v64 = (std::__shared_weak_count *)v63[4];
      if (v64)
      {
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v58);
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v64);
        char v66 = 0;
LABEL_125:
        if (v65)
        {
          *(_OWORD *)long long __p = 0u;
          long long v83 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v81 = 0u;
          uint64_t v67 = kCBMessageLocalizationTable;
          (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v65 + 40))(&v79, v65, kCBMessageLocalizationTable, @"PERMANENTLY_BLOCKED_SIM_TITLE", @"PERMANENTLY_BLOCKED_SIM_TITLE");
          xpc_object_t v84 = *(const void **)buf;
          xpc_object_t v68 = v79;
          xpc_object_t v79 = 0;
          *(void *)long long buf = v68;
          sub_1000558F4(&v84);
          sub_1000558F4(&v79);
          (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v65 + 40))(&v79, v65, v67, @"PERMANENTLY_BLOCKED_SIM_MESSAGE", @"PERMANENTLY_BLOCKED_SIM_MESSAGE");
          xpc_object_t v84 = (const void *)*((void *)&v81 + 1);
          *((void *)&v81 + 1) = v79;
          xpc_object_t v79 = 0;
          sub_1000558F4(&v84);
          sub_1000558F4(&v79);
          (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v65 + 40))(&v79, v65, v67, @"OK", @"OK");
          xpc_object_t v84 = *(const void **)&buf[8];
          *(void *)&uint8_t buf[8] = v79;
          xpc_object_t v79 = 0;
          sub_1000558F4(&v84);
          sub_1000558F4(&v79);
          BYTE8(v83) = 0;
          (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 40))(&v79);
          LODWORD(v78) = 2;
          xpc_object_t v69 = (const void **)(sub_1002C74D0((uint64_t **)(a1 + 336), 2, &v78) + 5);
          if (v69 != &v79)
          {
            xpc_object_t v84 = *v69;
            *xpc_object_t v69 = v79;
            xpc_object_t v79 = 0;
            sub_1001D88DC(&v84);
          }
          sub_1001D88DC(&v79);
          LODWORD(v84) = 2;
          int v70 = *((_DWORD *)sub_1001DA584((uint64_t **)(a1 + 312), 2, (unsigned int *)&v84) + 8);
          xpc_object_t v71 = *(uint64_t **)(a1 + 400);
          if (v71)
          {
            while (1)
            {
              while (1)
              {
                xpc_object_t v72 = (uint64_t **)v71;
                int v73 = *((_DWORD *)v71 + 7);
                if (v73 <= v70) {
                  break;
                }
                xpc_object_t v71 = *v72;
                xpc_object_t v74 = v72;
                if (!*v72) {
                  goto LABEL_138;
                }
              }
              if (v73 >= v70) {
                break;
              }
              xpc_object_t v71 = v72[1];
              if (!v71)
              {
                xpc_object_t v74 = v72 + 1;
                goto LABEL_138;
              }
            }
          }
          else
          {
            xpc_object_t v74 = (uint64_t **)(a1 + 400);
            xpc_object_t v72 = (uint64_t **)(a1 + 400);
LABEL_138:
            xpc_object_t v76 = (uint64_t *)operator new(0x20uLL);
            *((_DWORD *)v76 + 7) = v70;
            sub_100046C38((uint64_t **)(a1 + 392), (uint64_t)v72, v74, v76);
          }
          sub_100A37530((uint64_t **)(a1 + 312), 2);
          if (SBYTE7(v83) < 0) {
            operator delete(__p[0]);
          }
          sub_1000558F4((const void **)&v81 + 1);
          sub_1000558F4((const void **)&v81);
          sub_1000558F4((const void **)&buf[8]);
          sub_1000558F4((const void **)buf);
        }
        else
        {
          xpc_object_t v75 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
          }
        }
        if ((v66 & 1) == 0) {
          sub_10004D2C8(v64);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v65 = 0;
    }
    std::mutex::unlock(v58);
    xpc_object_t v64 = 0;
    char v66 = 1;
    goto LABEL_125;
  }
  BOOL v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v12 = "#I SpringBoard has not finished startup, can't send alert";
    goto LABEL_18;
  }
}

void sub_100D4D688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  BOOL v7 = va_arg(va1, const void *);
  sub_1001D88DC((const void **)va);
  sub_100D4F1AC((uint64_t)va1);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100D4D710(uint64_t a1, unsigned __int8 a2)
{
  unsigned __int8 v8 = a2;
  *(unsigned char *)(a1 + 384) = a2;
  uint64_t v3 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&__p, "kNoSimAlertPreferenceKey");
  char v4 = sub_1002264FC(v3, &__p, &v8);
  char v5 = v4;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v5) {
      return;
    }
  }
  else if (v4)
  {
    return;
  }
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "failed to persist no sim alert preference", (uint8_t *)&__p, 2u);
  }
}

void sub_100D4D7C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D4D7E4(const void **result, int a2)
{
  uint64_t v2 = (char *)result[43];
  if (v2)
  {
    char v4 = result;
    char v5 = result + 43;
    do
    {
      int v6 = *((_DWORD *)v2 + 8);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        unsigned __int8 v8 = (const void **)v2;
      }
      else {
        unsigned __int8 v8 = (const void **)(v2 + 8);
      }
      if (!v7) {
        char v5 = (const void **)v2;
      }
      uint64_t v2 = (char *)*v8;
    }
    while (*v8);
    if (v5 != result + 43 && *((_DWORD *)v5 + 8) <= a2)
    {
      int v9 = result[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if ((a2 - 1) > 4) {
          uint64_t v10 = "kNone";
        }
        else {
          uint64_t v10 = off_101A54868[a2 - 1];
        }
        *(_DWORD *)long long buf = 136315138;
        BOOL v14 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I canceling alert:%s", buf, 0xCu);
      }
      BOOL v11 = v4[12];
      sub_1001D89F0(&v12, v5 + 5);
      (*(void (**)(const void *, const void **))(*(void *)v11 + 56))(v11, &v12);
      return sub_1001D88DC(&v12);
    }
  }
  return result;
}

void sub_100D4D934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001D88DC((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100D4D948(uint64_t a1)
{
  if (!capabilities::ct::getRUIMDeprecationStrategy((capabilities::ct *)a1)) {
    return;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12B18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12B18))
  {
    __cxa_atexit((void (*)(void *))&std::string::~string, a898603, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B12B18);
  }
  uint64_t v2 = *(void **)(a1 + 128);
  if (v2 == (void *)(a1 + 136))
  {
LABEL_44:
    if (sub_100D4CA88(a1 + 56, (void *)(a1 + 128)) && *(unsigned char *)(a1 + 416))
    {
      BOOL v26 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Reset Ruim alert already shown status", buf, 2u);
      }
      *(unsigned char *)(a1 + 416) = 0;
    }
    return;
  }
  while (1)
  {
    uint64_t v3 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
    char v4 = (NSObject **)v3;
    int v6 = (_DWORD *)v2[7];
    char v5 = (_DWORD *)v2[8];
    if (v6 != v5)
    {
      while (*v6 != 4)
      {
        if (++v6 == v5)
        {
          int v6 = (_DWORD *)v2[8];
          break;
        }
      }
    }
    if (v6 == v5) {
      goto LABEL_25;
    }
    RUIMDeprecationStrategy = (capabilities::ct *)capabilities::ct::getRUIMDeprecationStrategy(v3);
    if (RUIMDeprecationStrategy == 2) {
      break;
    }
    int64_t v8 = *((unsigned __int8 *)v2 + 135);
    uint64_t v9 = (v8 & 0x80u) == 0 ? (uint64_t)(v2 + 14) : v2[14];
    uint64_t v10 = byte_101B0B24F >= 0 ? a898603 : *(char **)a898603;
    int64_t v11 = byte_101B0B24F >= 0 ? byte_101B0B24F : unk_101B0B240;
    if (!v11) {
      break;
    }
    if ((v8 & 0x80u) != 0) {
      int64_t v8 = v2[15];
    }
    if (v8 >= v11)
    {
      uint64_t v16 = (char *)(v9 + v8);
      int v17 = *v10;
      uint64_t v18 = (void *)v9;
      do
      {
        uint64_t v19 = v8 - v11;
        if (v19 == -1) {
          break;
        }
        BOOL v20 = (char *)memchr(v18, v17, v19 + 1);
        if (!v20) {
          break;
        }
        char v21 = v20;
        RUIMDeprecationStrategy = (capabilities::ct *)memcmp(v20, v10, v11);
        if (!RUIMDeprecationStrategy)
        {
          if (v21 == v16 || v21 != (char *)v9) {
            break;
          }
          goto LABEL_40;
        }
        uint64_t v18 = v21 + 1;
        int64_t v8 = v16 - (v21 + 1);
      }
      while (v8 >= v11);
    }
    uint64_t v12 = *v4;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v31 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I ICCID '%s' does not match prefix", buf, 0xCu);
    }
LABEL_25:
    int v13 = (void *)v2[1];
    if (v13)
    {
      do
      {
        BOOL v14 = v13;
        int v13 = (void *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        BOOL v14 = (void *)v2[2];
        BOOL v15 = *v14 == (void)v2;
        uint64_t v2 = v14;
      }
      while (!v15);
    }
    uint64_t v2 = v14;
    if (v14 == (void *)(a1 + 136)) {
      goto LABEL_44;
    }
  }
LABEL_40:
  if (*(unsigned char *)(a1 + 416))
  {
    __int16 v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v23 = "#I We've already shown the RUIM deprecated popup this power cycle";
      uint64_t v24 = v22;
      uint32_t v25 = 2;
      goto LABEL_43;
    }
  }
  else if (capabilities::ct::getRUIMDeprecationStrategy(RUIMDeprecationStrategy) == 1 {
         && *(_DWORD *)(a1 + 184) == 1)
  }
  {
    long long v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v31 = v28;
      uint64_t v23 = "#I Not showing RUIM deprecated alert due to buddy state (%s)";
      uint64_t v24 = v27;
      uint32_t v25 = 12;
LABEL_43:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
    }
  }
  else
  {
    uint64_t v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I enqueue RUIM support alert", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    sub_1001DA584((uint64_t **)(a1 + 312), 4, (unsigned int *)buf);
    sub_100D4CBEC(a1);
  }
}

void sub_100D4DD48(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 417))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v23) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I SIM unlock in progress", (uint8_t *)&v23, 2u);
    }
    return;
  }
  if (!a2) {
    sub_10007B600();
  }
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
  if (v4)
  {
    int v5 = v4;
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 136315138;
      uint64_t v24 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I enqueue SIM unlock alert (%s)", (uint8_t *)&v23, 0xCu);
    }
    BOOL v7 = (uint64_t ***)(a1 + 312);
    int64_t v8 = (uint64_t **)(a1 + 320);
    uint64_t v9 = *(uint64_t **)(a1 + 320);
    if (v9)
    {
      uint64_t v10 = a1 + 320;
      uint64_t v11 = *(void *)(a1 + 320);
      do
      {
        int v12 = *(_DWORD *)(v11 + 28);
        BOOL v13 = v12 < 5;
        if (v12 >= 5) {
          BOOL v14 = (uint64_t *)v11;
        }
        else {
          BOOL v14 = (uint64_t *)(v11 + 8);
        }
        if (!v13) {
          uint64_t v10 = v11;
        }
        uint64_t v11 = *v14;
      }
      while (*v14);
      BOOL v15 = *(uint64_t **)(a1 + 320);
      uint64_t v16 = (uint64_t **)(a1 + 320);
      if ((uint64_t **)v10 != v8)
      {
        if (*(int *)(v10 + 28) < 6)
        {
          *(_DWORD *)(v10 + 32) = v5;
LABEL_47:
          sub_100D4CBEC(a1);
          return;
        }
        BOOL v15 = *(uint64_t **)v10;
        uint64_t v16 = (uint64_t **)v10;
      }
      if (*v7 == v16)
      {
        uint64_t v18 = (uint64_t)v16;
        goto LABEL_39;
      }
      if (v15)
      {
        int v17 = v15;
        do
        {
          uint64_t v18 = (uint64_t)v17;
          int v17 = (uint64_t *)v17[1];
        }
        while (v17);
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v16 = (uint64_t **)(a1 + 320);
      if (*v7 == v8)
      {
        BOOL v15 = 0;
        uint64_t v16 = (uint64_t **)(a1 + 320);
        uint64_t v18 = a1 + 320;
        goto LABEL_39;
      }
    }
    uint64_t v18 = (uint64_t)v16;
    do
    {
      uint64_t v19 = v18;
      uint64_t v18 = *(void *)(v18 + 16);
    }
    while (*(void *)v18 == v19);
    BOOL v15 = 0;
LABEL_28:
    if (*(int *)(v18 + 28) >= 5)
    {
      BOOL v20 = (uint64_t **)(a1 + 320);
      if (v9)
      {
        while (1)
        {
          while (1)
          {
            BOOL v20 = (uint64_t **)v9;
            int v21 = *((_DWORD *)v9 + 7);
            if (v21 < 6) {
              break;
            }
            uint64_t v9 = *v20;
            int64_t v8 = v20;
            if (!*v20) {
              goto LABEL_46;
            }
          }
          if (v21 == 5) {
            goto LABEL_47;
          }
          uint64_t v9 = v20[1];
          if (!v9)
          {
            int64_t v8 = v20 + 1;
            break;
          }
        }
      }
LABEL_46:
      __int16 v22 = (uint64_t *)operator new(0x28uLL);
      *((_DWORD *)v22 + 7) = 5;
      *((_DWORD *)v22 + 8) = v5;
      sub_100046C38((uint64_t **)(a1 + 312), (uint64_t)v20, v8, v22);
      goto LABEL_47;
    }
LABEL_39:
    if (v15) {
      BOOL v20 = (uint64_t **)v18;
    }
    else {
      BOOL v20 = v16;
    }
    if (v15) {
      int64_t v8 = (uint64_t **)(v18 + 8);
    }
    else {
      int64_t v8 = v16;
    }
    if (*v8) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }
}

uint64_t sub_100D4DFD4(void *a1, void *a2)
{
  int v4 = (void *)*a1;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v4;
  if (v4 == v2)
  {
LABEL_18:
    uint64_t v16 = (void *)*a2;
    BOOL v14 = a2 + 1;
    BOOL v15 = v16;
    if (v16 == v14)
    {
      return 0;
    }
    else
    {
      do
      {
        if (!*v2) {
          goto LABEL_29;
        }
        int v17 = *((_DWORD *)v15 + 8);
        uint64_t v18 = v2;
        uint64_t v19 = *v2;
        do
        {
          int v20 = *(_DWORD *)(v19 + 32);
          BOOL v21 = v20 < v17;
          if (v20 >= v17) {
            __int16 v22 = (uint64_t *)v19;
          }
          else {
            __int16 v22 = (uint64_t *)(v19 + 8);
          }
          if (!v21) {
            uint64_t v18 = (void *)v19;
          }
          uint64_t v19 = *v22;
        }
        while (*v22);
        if (v18 != v2 && v17 >= *((_DWORD *)v18 + 8)) {
          int v23 = *((_DWORD *)v18 + 12);
        }
        else {
LABEL_29:
        }
          int v23 = 0;
        int v24 = *((_DWORD *)v15 + 12);
        BOOL v13 = v24 == v23;
        BOOL v25 = v24 != v23;
        if (!v13) {
          break;
        }
        BOOL v26 = (void *)v15[1];
        if (v26)
        {
          do
          {
            long long v27 = v26;
            BOOL v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            long long v27 = (void *)v15[2];
            BOOL v13 = *v27 == (void)v15;
            BOOL v15 = v27;
          }
          while (!v13);
        }
        BOOL v15 = v27;
      }
      while (v27 != v14);
    }
  }
  else
  {
    if (a2[1])
    {
      while (1)
      {
        int v5 = *((_DWORD *)v3 + 8);
        int v6 = a2 + 1;
        uint64_t v7 = a2[1];
        do
        {
          int v8 = *(_DWORD *)(v7 + 32);
          BOOL v9 = v8 < v5;
          if (v8 >= v5) {
            uint64_t v10 = (uint64_t *)v7;
          }
          else {
            uint64_t v10 = (uint64_t *)(v7 + 8);
          }
          if (!v9) {
            int v6 = (void *)v7;
          }
          uint64_t v7 = *v10;
        }
        while (*v10);
        if (v6 == a2 + 1 || v5 < *((_DWORD *)v6 + 8)) {
          break;
        }
        uint64_t v11 = (void *)v3[1];
        if (v11)
        {
          do
          {
            int v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            int v12 = (void *)v3[2];
            BOOL v13 = *v12 == (void)v3;
            uint64_t v3 = v12;
          }
          while (!v13);
        }
        uint64_t v3 = v12;
        if (v12 == v2) {
          goto LABEL_18;
        }
      }
    }
    return 1;
  }
  return v25;
}

uint64_t sub_100D4E11C(void *a1)
{
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)*a1;
  if ((void *)*a1 == a1 + 1) {
    return 0;
  }
  while (1)
  {
    uint64_t result = subscriber::isSimLocked();
    if (result) {
      break;
    }
    int v4 = (void *)v2[1];
    if (v4)
    {
      do
      {
        int v5 = v4;
        int v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        int v5 = (void *)v2[2];
        BOOL v6 = *v5 == (void)v2;
        uint64_t v2 = v5;
      }
      while (!v6);
    }
    uint64_t v2 = v5;
    if (v5 == v1) {
      return result;
    }
  }
  return 1;
}

void sub_100D4E19C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5]) {
        sub_100D4D948(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100D4E210(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D4E224(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D4E240(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D4E250(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I showing Dead SIM alert", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 56));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_9:
    BOOL v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
    }
    goto LABEL_18;
  }
LABEL_13:
  *(_OWORD *)std::string __p = 0u;
  long long v23 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v21 = 0u;
  uint64_t v15 = kCBMessageLocalizationTable;
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&v19, v12, kCBMessageLocalizationTable, @"SIM_FAILURE", @"SIM_FAILURE");
  int v24 = *(const void **)buf;
  uint64_t v16 = v19;
  uint64_t v19 = 0;
  *(void *)long long buf = v16;
  sub_1000558F4(&v24);
  sub_1000558F4(&v19);
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&v19, v12, v15, @"OK", @"OK");
  int v24 = *(const void **)&buf[8];
  *(void *)&uint8_t buf[8] = v19;
  uint64_t v19 = 0;
  sub_1000558F4(&v24);
  sub_1000558F4(&v19);
  BYTE8(v23) = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 40))(&v19);
  int v18 = 3;
  int v17 = (const void **)(sub_1002C74D0((uint64_t **)(a1 + 336), 3, &v18) + 5);
  if (v17 != &v19)
  {
    int v24 = *v17;
    *int v17 = v19;
    uint64_t v19 = 0;
    sub_1001D88DC(&v24);
  }
  sub_1001D88DC(&v19);
  sub_100A37530((uint64_t **)(a1 + 312), 3);
  if (SBYTE7(v23) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4((const void **)&v21 + 1);
  sub_1000558F4((const void **)&v21);
  sub_1000558F4((const void **)&buf[8]);
  sub_1000558F4((const void **)buf);
LABEL_18:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100D4E548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v5 = va_arg(va1, const void *);
  sub_1001D88DC((const void **)va);
  sub_100D4F1AC((uint64_t)va1);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100D4E584(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I showing RUIM support alert", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 56));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v14 = 0;
      if (!v12) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v14 = 1;
  if (!v12)
  {
LABEL_9:
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
    }
    goto LABEL_35;
  }
LABEL_13:
  *(_OWORD *)std::string __p = 0u;
  long long v30 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v28 = 0u;
  int RUIMDeprecationStrategy = capabilities::ct::getRUIMDeprecationStrategy(v13);
  switch(RUIMDeprecationStrategy)
  {
    case 0:
      uint64_t v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v31 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unexpected RUIM deprecation strategy", v31, 2u);
      }
      break;
    case 1:
      uint64_t v20 = kAlertDialogLocalizationTable;
      (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v26, v12, kAlertDialogLocalizationTable, @"RUIM_DEPRECATED_TITLE", 1);
      *(void *)uint64_t v31 = *(void *)buf;
      long long v21 = v26;
      BOOL v26 = 0;
      *(void *)long long buf = v21;
      sub_1000558F4((const void **)v31);
      sub_1000558F4(&v26);
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v26, v12, v20, @"RUIM_DEPRECATED_BODY", 1);
      goto LABEL_20;
    case 2:
      uint64_t v17 = kAlertDialogLocalizationTable;
      (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v26, v12, kAlertDialogLocalizationTable, @"RUIM_NOT_SUPPORTED_TITLE", 1);
      *(void *)uint64_t v31 = *(void *)buf;
      int v18 = v26;
      BOOL v26 = 0;
      *(void *)long long buf = v18;
      sub_1000558F4((const void **)v31);
      sub_1000558F4(&v26);
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v12 + 16))(&v26, v12, v17, @"RUIM_NOT_SUPPORTED_BODY", 1);
LABEL_20:
      *(void *)uint64_t v31 = *((void *)&v28 + 1);
      *((void *)&v28 + 1) = v26;
      BOOL v26 = 0;
      sub_1000558F4((const void **)v31);
      sub_1000558F4(&v26);
      break;
  }
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v12 + 40))(&v26, v12, kAlertDialogLocalizationTable, @"OK", @"OK");
  *(void *)uint64_t v31 = *(void *)&buf[8];
  *(void *)&uint8_t buf[8] = v26;
  BOOL v26 = 0;
  sub_1000558F4((const void **)v31);
  sub_1000558F4(&v26);
  if (*(void *)buf) {
    __int16 v22 = sub_1000810B8;
  }
  else {
    __int16 v22 = 0;
  }
  if (v22 && (*((void *)&v28 + 1) ? (long long v23 = sub_1000810B8) : (long long v23 = 0), v23))
  {
    BYTE8(v30) = 2;
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 40))(&v25);
    sub_1001D88DC(&v25);
  }
  else
  {
    int v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v31 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Missing title or body for RUIM alert", v31, 2u);
    }
  }
  *(unsigned char *)(a1 + 416) = 1;
  sub_100A37530((uint64_t **)(a1 + 312), 4);
  if (SBYTE7(v30) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4((const void **)&v28 + 1);
  sub_1000558F4((const void **)&v28);
  sub_1000558F4((const void **)&buf[8]);
  sub_1000558F4((const void **)buf);
LABEL_35:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100D4EA20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100D4F1AC((uint64_t)va);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D4EA58(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 417))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v3) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    int v5 = "#I SIM unlock already in progress";
    uint64_t v6 = buf;
    goto LABEL_4;
  }
  if (*(_DWORD *)(a1 + 184) == 1 && !*(unsigned char *)(a1 + 418))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    BOOL v8 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v8)
    {
      __int16 v10 = 0;
      int v5 = "#I Not allowed to show SIM unlock during buddy";
      uint64_t v6 = (uint8_t *)&v10;
      goto LABEL_4;
    }
  }
  else
  {
    if (sub_100D4CA88(a1 + 56, (void *)(a1 + 152))) {
      return 1;
    }
    uint64_t v2 = *(NSObject **)(a1 + 40);
    BOOL v7 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v7)
    {
      __int16 v9 = 0;
      int v5 = "#I SIMs not settled, wait...";
      uint64_t v6 = (uint8_t *)&v9;
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
      return 0;
    }
  }
  return result;
}

void sub_100D4EB70(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 177))
  {
    if (!*(unsigned char *)(a1 + 178) && *(unsigned char *)(a1 + 179)) {
      goto LABEL_69;
    }
LABEL_23:
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I showing SIM unlock alert on lock screen", buf, 2u);
    }
    uint64_t v14 = *(void *)(a1 + 344);
    if (v14)
    {
      uint64_t v13 = a1 + 344;
      do
      {
        int v15 = *(_DWORD *)(v14 + 32);
        BOOL v16 = v15 < 5;
        if (v15 >= 5) {
          uint64_t v17 = (uint64_t *)v14;
        }
        else {
          uint64_t v17 = (uint64_t *)(v14 + 8);
        }
        if (!v16) {
          uint64_t v13 = v14;
        }
        uint64_t v14 = *v17;
      }
      while (*v17);
      if (v13 != a1 + 344 && *(int *)(v13 + 32) <= 5)
      {
        uint64_t v18 = *(void *)(a1 + 96);
        sub_1001D89F0(&v46, (const void **)(v13 + 40));
        LODWORD(v18) = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v18 + 48))(v18, &v46);
        sub_1001D88DC(&v46);
        if (v18)
        {
          uint64_t v19 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_WORD *)long long buf = 0;
          uint64_t v20 = "#I SIM unlock alert is already active";
LABEL_71:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 2u);
          return;
        }
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v13, *(Registry **)(a1 + 56));
    __int16 v22 = ServiceMap;
    if (v23 < 0)
    {
      int v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v23;
    long long v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    if (v27)
    {
      uint64_t v29 = v27[3];
      long long v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        if (!v29) {
          goto LABEL_44;
        }
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    long long v28 = 0;
    char v30 = 1;
    if (!v29)
    {
LABEL_44:
      uint64_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Missing LocalizationInterface!", buf, 2u);
      }
LABEL_65:
      if (v30) {
        return;
      }
      uint64_t v11 = v28;
      goto LABEL_67;
    }
LABEL_48:
    BOOL v32 = *(void **)(a1 + 152);
    if (v32 == (void *)(a1 + 160))
    {
      *(_OWORD *)std::string __p = 0u;
      long long v45 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v43 = 0u;
    }
    else
    {
      int v33 = 0;
      do
      {
        int isSimLocked = subscriber::isSimLocked();
        uint64_t v35 = (void *)v32[1];
        if (v35)
        {
          do
          {
            int v36 = v35;
            uint64_t v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            int v36 = (void *)v32[2];
            BOOL v37 = *v36 == (void)v32;
            BOOL v32 = v36;
          }
          while (!v37);
        }
        v33 += isSimLocked;
        BOOL v32 = v36;
      }
      while (v36 != (void *)(a1 + 160));
      *(_OWORD *)std::string __p = 0u;
      long long v45 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v43 = 0u;
      if (v33 == 1)
      {
        (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v29 + 40))(&v41, v29, kCBMessageLocalizationTable, @"SIM_CARD_LOCKED", @"SIM_CARD_LOCKED");
LABEL_60:
        *(void *)&long long v47 = *(void *)buf;
        xpc_object_t v38 = v41;
        xpc_object_t v41 = 0;
        *(void *)long long buf = v38;
        sub_1000558F4((const void **)&v47);
        sub_1000558F4(&v41);
        BYTE8(v45) = 1;
        (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 40))(&v41);
        int v40 = 5;
        uint64_t v39 = (const void **)(sub_1002C74D0((uint64_t **)(a1 + 336), 5, &v40) + 5);
        if (v39 != &v41)
        {
          *(void *)&long long v47 = *v39;
          *uint64_t v39 = v41;
          xpc_object_t v41 = 0;
          sub_1001D88DC((const void **)&v47);
        }
        sub_1001D88DC(&v41);
        if (SBYTE7(v45) < 0) {
          operator delete(__p[0]);
        }
        sub_1000558F4((const void **)&v43 + 1);
        sub_1000558F4((const void **)&v43);
        sub_1000558F4((const void **)&buf[8]);
        sub_1000558F4((const void **)buf);
        goto LABEL_65;
      }
    }
    (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v29 + 40))(&v41, v29, kCBMessageLocalizationTable, @"MULTIPLE_SIM_CARDS_LOCKED", @"MULTIPLE_SIM_CARDS_LOCKED");
    goto LABEL_60;
  }
  if (*(unsigned char *)(a1 + 178)) {
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 179))
  {
LABEL_69:
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "#I screen is not locked but coversheet is active, don't display any alert";
    goto LABEL_71;
  }
  uint64_t v2 = *(void *)(a1 + 320);
  if (v2)
  {
    uint64_t v3 = a1 + 320;
    do
    {
      int v4 = *(_DWORD *)(v2 + 28);
      BOOL v5 = v4 < 5;
      if (v4 >= 5) {
        uint64_t v6 = (uint64_t *)v2;
      }
      else {
        uint64_t v6 = (uint64_t *)(v2 + 8);
      }
      if (!v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 320 && *(int *)(v3 + 28) <= 5)
    {
      uint64_t v7 = *(unsigned int *)(v3 + 32);
      BOOL v8 = *(NSObject **)(a1 + 40);
      if (v7)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I launching SIM unlock alert", buf, 2u);
        }
        (*(void (**)(void, uint64_t, BOOL))(**(void **)(a1 + 96) + 64))(*(void *)(a1 + 96), v7, *(_DWORD *)(a1 + 184) == 1);
        *(unsigned char *)(a1 + 417) = 1;
        sub_100058DB0(buf, "/cc/assertions/prevent_baseband_reset");
        ctu::rest::AssertionHandle::create();
        if (SBYTE7(v43) < 0) {
          operator delete(*(void **)buf);
        }
        long long v9 = v47;
        long long v47 = 0uLL;
        __int16 v10 = *(std::__shared_weak_count **)(a1 + 432);
        *(_OWORD *)(a1 + 424) = v9;
        if (!v10) {
          return;
        }
        sub_10004D2C8(v10);
        uint64_t v11 = (std::__shared_weak_count *)*((void *)&v47 + 1);
        if (!*((void *)&v47 + 1)) {
          return;
        }
LABEL_67:
        sub_10004D2C8(v11);
        return;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "unknown slot for SIM unlock alert", buf, 2u);
      }
      sub_100A37530((uint64_t **)(a1 + 312), 5);
    }
  }
}

void sub_100D4F13C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100D4F1AC(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  sub_1000558F4((const void **)(a1 + 24));
  sub_1000558F4((const void **)(a1 + 16));
  sub_1000558F4((const void **)(a1 + 8));

  return sub_1000558F4((const void **)a1);
}

void sub_100D4F208(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  unsigned __int8 v11 = a3;
  memset(&v10, 0, sizeof(v10));
  sub_100058DB0(__p, "kSimUnlockAlertPreferenceKey");
  sub_100D4F338(&v10, (uint64_t)__p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  BOOL v5 = (uint64_t **)sub_100365D74();
  if ((sub_1002264FC(v5, &v10, &v11) & 1) == 0)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "failed to persist lock preference", v7, 2u);
    }
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_100D4F300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D4F338(std::string *a1, uint64_t a2)
{
  sub_100058DB0(&v15, "_");
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    BOOL v5 = (const std::string::value_type *)a2;
  }
  else {
    BOOL v5 = *(const std::string::value_type **)a2;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = std::string::insert(&v15, 0, v5, v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  char v9 = (char *)subscriber::asString();
  sub_100058DB0(__p, v9);
  if ((v14 & 0x80u) == 0) {
    std::string v10 = __p;
  }
  else {
    std::string v10 = (void **)__p[0];
  }
  if ((v14 & 0x80u) == 0) {
    std::string::size_type v11 = v14;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  uint64_t v12 = std::string::append(&v16, (const std::string::value_type *)v10, v11);
  *a1 = *v12;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((char)v14 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_100D4F43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D4F488(uint64_t a1, uint64_t a2)
{
  memset(&v13, 0, sizeof(v13));
  sub_100058DB0(__p, "kSimUnlockAlertPreferenceKey");
  sub_100D4F338(&v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  BOOL v10 = 0;
  uint64_t v4 = sub_100365D74();
  if (sub_1002260B0(v4, (void **)&v13.__r_.__value_.__l.__data_, &v10))
  {
    BOOL v5 = v10;
    BOOL v6 = !v10;
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      long long v8 = "locked";
      if (!v5) {
        long long v8 = "unlocked";
      }
      *(_DWORD *)long long buf = 136315138;
      std::string v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I last sim lock status : %s", buf, 0xCu);
    }
  }
  else
  {
    BOOL v6 = 1;
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return v6;
}

void sub_100D4F5EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D4F62C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
  }
  uint64_t v7 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v7, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_100D4F728(_Unwind_Exception *exception_object)
{
  if (v1[79] < 0) {
    operator delete(*v4);
  }
  if (v1[55] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D4F778(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D4F7B0(uint64_t a1)
{
}

uint64_t sub_100D4F7CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D4F810(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100D4F83C(ServiceManager::Service *this)
{
  *(void *)this = off_101A540E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100D4F898(ServiceManager::Service *this)
{
  *(void *)this = off_101A540E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100D4F908@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SubscriberUserAlertManager");
}

unsigned char *sub_100D4F918@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100D4F958(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100D4A9B0(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100D4A9B0(v4, 0);
}

uint64_t sub_100D4F9DC()
{
  return 0;
}

uint64_t sub_100D4F9E4()
{
  return 1;
}

uint64_t sub_100D4F9EC()
{
  return 0;
}

void sub_100D4F9F8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4FAD8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D4FBEC(const void **a1)
{
  if (a1)
  {
    sub_100D4FBEC(*a1);
    sub_100D4FBEC(a1[1]);
    sub_1001D88DC(a1 + 5);
    operator delete(a1);
  }
}

uint64_t *sub_100D4FC40(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  (*(void (**)(void))(**(void **)(v2 + 96) + 32))(*(void *)(v2 + 96));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100D4FCEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100D4FD08(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::getMobileHelper((uint64_t *)buf, *(Registry **)(v2 + 56));
  long long v4 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  long long v5 = *(std::__shared_weak_count **)(v2 + 120);
  *(_OWORD *)(v2 + 112) = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v27, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v28) {
    sub_10004D2C8(v28);
  }
  sub_100058DB0(__p, "/cc/props/sims_on_device");
  uint64_t v6 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v6 = off_101A54168;
  *((void *)v6 + 1) = v2 + 128;
  *((void *)v6 + 2) = v2;
  *((void *)v6 + 3) = sub_100D4AAB0;
  *((void *)v6 + 4) = 0;
  int v33 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v7 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v7 = off_101A541E8;
  *((void *)v7 + 1) = v2 + 152;
  *((void *)v7 + 2) = v2;
  *((void *)v7 + 3) = sub_100D4AD64;
  *((void *)v7 + 4) = 0;
  int v33 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/springboard_finished_startup");
  long long v8 = (uint8_t *)operator new(0x28uLL);
  *(void *)long long v8 = off_101A54268;
  *((void *)v8 + 1) = v2 + 176;
  *((void *)v8 + 2) = v2;
  *((void *)v8 + 3) = sub_100D4B360;
  *((void *)v8 + 4) = 0;
  int v33 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/display_status");
  char v9 = (uint8_t *)operator new(0x28uLL);
  *(void *)char v9 = off_101A542E8;
  *((void *)v9 + 1) = v2 + 177;
  *((void *)v9 + 2) = v2;
  *((void *)v9 + 3) = sub_100D4B430;
  *((void *)v9 + 4) = 0;
  int v33 = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/buddy_state");
  BOOL v10 = (uint8_t *)operator new(0x28uLL);
  *(void *)BOOL v10 = off_101A54368;
  *((void *)v10 + 1) = v2 + 184;
  *((void *)v10 + 2) = v2;
  *((void *)v10 + 3) = sub_100D4B4F8;
  *((void *)v10 + 4) = 0;
  int v33 = v10;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  std::string::size_type v11 = (uint8_t *)operator new(0x28uLL);
  *(void *)std::string::size_type v11 = off_101A543E8;
  *((void *)v11 + 1) = v2 + 188;
  *((void *)v11 + 2) = v2;
  *((void *)v11 + 3) = sub_100D4B82C;
  *((void *)v11 + 4) = 0;
  int v33 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  sub_1001067E0(v2 + 192);
  sub_100722258(v2 + 216);
  sub_1005FE9F4(v2 + 248);
  *(void *)long long buf = off_101A54468;
  *(void *)&uint8_t buf[8] = v2 + 72;
  int v33 = buf;
  sub_100318874(buf, (void *)(v2 + 272));
  sub_10030AB98(buf);
  uint64_t v12 = *(void *)(v2 + 296);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, v2 + 304);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  std::string v13 = (uint8_t *)operator new(0x20uLL);
  *(void *)std::string v13 = off_101A544E8;
  *((void *)v13 + 1) = v2;
  *((void *)v13 + 2) = sub_100D4B8D4;
  *((void *)v13 + 3) = 0;
  int v33 = v13;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  LOBYTE(__p[0]) = 0;
  uint64_t v14 = sub_100365D74();
  sub_100058DB0(buf, "kNoSimAlertPreferenceKey");
  BOOL v15 = sub_1002260B0(v14, (void **)buf, (BOOL *)__p);
  BOOL v16 = v15;
  if (v32 < 0)
  {
    operator delete(*(void **)buf);
    if (!v16) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v15) {
LABEL_26:
  }
    *(unsigned char *)(v2 + 384) = __p[0];
LABEL_27:
  uint64_t v17 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v17
    || (uint64_t v18 = *(void *)(v2 + 96), v19 = *(void *)(v2 + 8), (v20 = std::__shared_weak_count::lock(v17)) == 0))
  {
    sub_100088B9C();
  }
  long long v21 = v20;
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  __int16 v22 = std::__shared_weak_count::lock(v21);
  if (v22)
  {
    uint64_t v23 = v22;
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *(void *)long long buf = v19;
    *(void *)&uint8_t buf[8] = v22;
    std::__shared_weak_count::__release_weak(v21);
    sub_10004D2C8(v23);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    std::__shared_weak_count::__release_weak(v21);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 16))(v18, buf);
  if (*(void *)&buf[8]) {
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[8]);
  }
  sub_100088C88(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100D502F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,std::__shared_weak_count *a21,int a22,__int16 a23,char a24,char a25)
{
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100D503A8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 96) + 24))(*(void *)(v1 + 96));
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v1 + 112) + 16))(&cf);
  long long v4 = (BOOL *)cf;
  if (cf) {
    long long v5 = sub_100080934;
  }
  else {
    long long v5 = 0;
  }
  if (v5)
  {
    __p[0] = (void *)cf;
    if (cf) {
      CFRetain(cf);
    }
    ctu::cf::assign((ctu::cf *)(v1 + 385), v4, v3);
    int v6 = *(unsigned __int8 *)(v1 + 385);
    if (*(unsigned __int8 *)(v1 + 304) != v6)
    {
      *(unsigned char *)(v1 + 304) = v6;
      uint64_t v7 = *(void *)(v1 + 296);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v1 + 304);
      }
    }
    long long v8 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(v1 + 385)) {
        char v9 = "true";
      }
      else {
        char v9 = "false";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fNoSimAlertSuppressed = %s", buf, 0xCu);
    }
    sub_100062778((const void **)__p);
  }
  else
  {
    BOOL v10 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v18 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v13 = v18;
      std::string::size_type v11 = __p;
      if (v18 < 0) {
        std::string::size_type v11 = *(void ***)buf;
      }
      *(_DWORD *)BOOL v15 = 136315138;
      BOOL v16 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s key not found", v15, 0xCu);
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  sub_1000577C4(&cf);
  operator delete();
}

void sub_100D50660(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, const void *a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a17);
  operator delete();
}

void sub_100D506D0()
{
}

__n128 sub_100D506E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A54168;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D50738(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54168;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D50770(void *a1, xpc_object_t *a2)
{
  CFBooleanRef v3 = (std::string *)a1[1];
  long long v23 = 0uLL;
  uint64_t v24 = 0;
  sub_100089CF0((uint64_t *)&v23, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v20 = (void **)v3->__r_.__value_.__r.__words[0];
  long long v21 = size;
  __int16 v22 = (void *)v3->__r_.__value_.__r.__words[2];
  if (v22)
  {
    size[2] = &v21;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v20 = (void **)&v21;
  }
  long long v18 = v23;
  uint64_t v19 = v24;
  uint64_t v24 = 0;
  long long v23 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v18);
  BOOL v16 = (void **)&v18;
  sub_10008A88C(&v16);
  if (v22 == (void *)v3->__r_.__value_.__r.__words[2])
  {
    int v6 = v20;
    if (v20 == (void **)&v21) {
      goto LABEL_27;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      long long v8 = (void **)v6[1];
      char v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          int v6 = v8;
          long long v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v6 = v9[2];
          BOOL v10 = *v6 == v9;
          char v9 = (void ***)v6;
        }
        while (!v10);
      }
      std::string::size_type v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          std::string::size_type v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v21) {
        goto LABEL_27;
      }
    }
  }
  uint64_t v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  BOOL v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    uint64_t v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  BOOL v16 = v20;
  v17[0] = v21;
  v17[1] = v22;
  if (v22)
  {
    v21[2] = v17;
    uint64_t v20 = (void **)&v21;
    long long v21 = 0;
    __int16 v22 = 0;
  }
  else
  {
    BOOL v16 = (void **)v17;
  }
  v13(v15, &v16);
  sub_100088048((uint64_t)&v16, v17[0]);
LABEL_27:
  sub_100088048((uint64_t)&v20, v21);
  uint64_t v20 = (void **)&v23;
  sub_10008A88C(&v20);
}

void sub_100D50970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, void *a17)
{
  sub_100088048((uint64_t)&a10, a11);
  sub_100088048((uint64_t)&a16, a17);
  a16 = (void **)(v17 - 64);
  sub_10008A88C(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100D509C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D50A08()
{
}

void sub_100D50A18()
{
}

__n128 sub_100D50A2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A541E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D50A80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A541E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D50AB8(void *a1, xpc_object_t *a2)
{
  CFBooleanRef v3 = (std::string *)a1[1];
  long long v23 = 0uLL;
  uint64_t v24 = 0;
  sub_100089CF0((uint64_t *)&v23, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v20 = (void **)v3->__r_.__value_.__r.__words[0];
  long long v21 = size;
  __int16 v22 = (void *)v3->__r_.__value_.__r.__words[2];
  if (v22)
  {
    size[2] = &v21;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v20 = (void **)&v21;
  }
  long long v18 = v23;
  uint64_t v19 = v24;
  uint64_t v24 = 0;
  long long v23 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v18);
  BOOL v16 = (void **)&v18;
  sub_10008A88C(&v16);
  if (v22 == (void *)v3->__r_.__value_.__r.__words[2])
  {
    int v6 = v20;
    if (v20 == (void **)&v21) {
      goto LABEL_27;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      long long v8 = (void **)v6[1];
      char v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          int v6 = v8;
          long long v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v6 = v9[2];
          BOOL v10 = *v6 == v9;
          char v9 = (void ***)v6;
        }
        while (!v10);
      }
      std::string::size_type v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          std::string::size_type v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v21) {
        goto LABEL_27;
      }
    }
  }
  uint64_t v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  BOOL v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    uint64_t v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  BOOL v16 = v20;
  v17[0] = v21;
  v17[1] = v22;
  if (v22)
  {
    v21[2] = v17;
    uint64_t v20 = (void **)&v21;
    long long v21 = 0;
    __int16 v22 = 0;
  }
  else
  {
    BOOL v16 = (void **)v17;
  }
  v13(v15, &v16);
  sub_100088048((uint64_t)&v16, v17[0]);
LABEL_27:
  sub_100088048((uint64_t)&v20, v21);
  uint64_t v20 = (void **)&v23;
  sub_10008A88C(&v20);
}

void sub_100D50CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, void *a17)
{
  sub_100088048((uint64_t)&a10, a11);
  sub_100088048((uint64_t)&a16, a17);
  a16 = (void **)(v17 - 64);
  sub_10008A88C(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100D50D10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D50D50()
{
}

void sub_100D50D60()
{
}

__n128 sub_100D50D74(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A54268;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D50DC8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D50E00(void *a1, xpc *this, BOOL a3)
{
  long long v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *long long v4 = xpc::dyn_cast_or_default(this, 0, a3);
  int v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100D50E9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D50EDC()
{
}

void sub_100D50EEC()
{
}

__n128 sub_100D50F00(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A542E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D50F54(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A542E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D50F8C(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = **(unsigned int **)(a1 + 8);
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  long long v4 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  int v6 = (void *)(*(void *)(a1 + 16) + (v5 >> 1));
  if (v5) {
    long long v4 = *(uint64_t (**)(void *, uint64_t))(*v6 + v4);
  }
  return v4(v6, v3);
}

void sub_100D51048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_100D51064(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D510A4()
{
}

void sub_100D510B4()
{
}

__n128 sub_100D510C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A54368;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D5111C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D51154(void *a1, xpc_object_t *a2)
{
  long long v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *long long v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *long long v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  BOOL v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    BOOL v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100D5124C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D5128C()
{
}

void sub_100D5129C()
{
}

__n128 sub_100D512B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A543E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D51304(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A543E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D5133C(void *a1, xpc *this, BOOL a3)
{
  long long v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *long long v4 = xpc::dyn_cast_or_default(this, 0, a3);
  int v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100D513D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D51418()
{
}

void sub_100D51428()
{
}

void *sub_100D5143C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A54468;
  result[1] = v3;
  return result;
}

uint64_t sub_100D51484(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A54468;
  a2[1] = v2;
  return result;
}

void sub_100D514B0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/suppress_sim_alerts");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100D51560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100D515A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D515E8()
{
}

void sub_100D515F8()
{
}

__n128 sub_100D5160C(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A544E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D51660(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A544E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D51698(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D516E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D51720()
{
}

void *sub_100D5172C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D517B0(uint64_t **a1)
{
  long long v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)v1 + 2);
  v5[0] = off_101A54568;
  v5[1] = v2;
  v5[2] = v3;
  v5[3] = v5;
  sub_100D4DD48(v2, (uint64_t)v5);
  sub_100D5172C(v5);
  operator delete();
}

void sub_100D51864(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100D5172C((uint64_t *)va);
  operator delete();
}

void sub_100D5189C()
{
}

__n128 sub_100D518B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A54568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100D518FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D5192C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (sub_100D4F488(v2, *(unsigned int *)(a1 + 16))) {
    return 3;
  }
  long long v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 16));
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v5)
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I user prefers not to unlock SIM", v6, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_100D519E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D51A24()
{
}

void sub_100D51A30(uint64_t **a1)
{
  long long v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)v1 + 2);
  v5[0] = off_101A545F8;
  v5[1] = v2;
  v5[2] = v3;
  v5[3] = v5;
  sub_100D4DD48(v2, (uint64_t)v5);
  sub_100D5172C(v5);
  operator delete();
}

void sub_100D51AE4(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100D5172C((uint64_t *)va);
  operator delete();
}

void sub_100D51B1C()
{
}

__n128 sub_100D51B30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A545F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100D51B7C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A545F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D51BAC(uint64_t a1)
{
  if (sub_100D51C34(*(_DWORD *)(a1 + 16), (void *)(*(void *)(a1 + 8) + 152))) {
    return *(unsigned int *)(a1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t sub_100D51BE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D51C28()
{
}

BOOL sub_100D51C34(int a1, void *a2)
{
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    while (*((_DWORD *)v3 + 8) != a1 || (subscriber::isSimLocked() & 1) == 0)
    {
      BOOL v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          int v6 = v5;
          BOOL v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
      if (v6 == v2)
      {
        uint64_t v3 = v2;
        return v3 != v2;
      }
    }
  }
  return v3 != v2;
}

void sub_100D51CC8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v1 + 8)) {
      long long v4 = "true";
    }
    else {
      long long v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I setSimUnlockAllowedDuringBuddy %s", buf, 0xCu);
  }
  int v5 = *((unsigned __int8 *)v1 + 8);
  *(unsigned char *)(v2 + 418) = v5;
  if (*(_DWORD *)(v2 + 184) == 1)
  {
    if (v5) {
      sub_100D4CBEC(v2);
    }
    else {
      (*(void (**)(void))(**(void **)(v2 + 96) + 80))(*(void *)(v2 + 96));
    }
  }
  operator delete();
}

void sub_100D51DFC()
{
}

void sub_100D51E28(uint64_t **a1)
{
  int v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v1 + 8)) {
      long long v4 = "true";
    }
    else {
      long long v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I saveNoSimAlertPreference %s", buf, 0xCu);
  }
  sub_100D4D710(v2, *((unsigned char *)v1 + 8));
  operator delete();
}

void sub_100D51F1C()
{
}

void sub_100D51F48(uint64_t **a1)
{
  long long v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I clear sim lock status", buf, 2u);
  }
  sub_100D4F208(v2, *((unsigned int *)v1 + 2), 0);
  operator delete();
}

void sub_100D52018()
{
}

void sub_100D52044(uint64_t **a1)
{
  uint64_t v12 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 417)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    unsigned int v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SIM unlock flow finished, was in progress : %s", buf, 0xCu);
  }
  if (*(unsigned char *)(v1 + 417))
  {
    *(unsigned char *)(v1 + 417) = 0;
    long long v4 = *(std::__shared_weak_count **)(v1 + 432);
    *(void *)(v1 + 424) = 0;
    *(void *)(v1 + 432) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
    sub_100A37530((uint64_t **)(v1 + 312), 5);
    int v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I persist current sim lock preference", buf, 2u);
    }
    int v6 = *(void **)(v1 + 152);
    if (v6 != (void *)(v1 + 160))
    {
      do
      {
        if (subscriber::isSimSettled())
        {
          uint64_t v7 = *((unsigned int *)v6 + 8);
          unsigned __int8 isSimLocked = subscriber::isSimLocked();
          sub_100D4F208(v1, v7, isSimLocked);
        }
        char v9 = (void *)v6[1];
        if (v9)
        {
          do
          {
            BOOL v10 = v9;
            char v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            BOOL v10 = (void *)v6[2];
            BOOL v11 = *v10 == (void)v6;
            int v6 = v10;
          }
          while (!v11);
        }
        int v6 = v10;
      }
      while (v10 != (void *)(v1 + 160));
    }
  }
  operator delete();
}

void sub_100D52208()
{
}

void sub_100D52234(uint64_t **a1)
{
  int v5 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 417)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SIM unlock flow deactivated, was in progress : %s", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(v1 + 417))
  {
    *(unsigned char *)(v1 + 417) = 0;
    long long v4 = *(std::__shared_weak_count **)(v1 + 432);
    *(void *)(v1 + 424) = 0;
    *(void *)(v1 + 432) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
    *(void *)&long long buf = off_101A54678;
    *((void *)&buf + 1) = v1;
    p_long long buf = &buf;
    sub_100D4DD48(v1, (uint64_t)&buf);
    sub_100D5172C(&buf);
  }
  operator delete();
}

void sub_100D52370(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100D5172C((uint64_t *)va);
  operator delete();
}

void sub_100D523A8()
{
}

void *sub_100D523BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A54678;
  result[1] = v3;
  return result;
}

uint64_t sub_100D52404(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A54678;
  a2[1] = v2;
  return result;
}

uint64_t sub_100D52430(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 320);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v1 + 320;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < 5;
    if (v4 >= 5) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == v1 + 320 || *(int *)(v3 + 28) > 5) {
    return 0;
  }
  unsigned int v8 = *(_DWORD *)(v3 + 32);
  if (v8 == 3)
  {
    if (sub_100D4E11C((void *)(v1 + 152))) {
      return 3;
    }
    else {
      return 0;
    }
  }
  else if (sub_100D51C34(0, (void *)(v1 + 152)))
  {
    return v8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D524D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D52510()
{
}

void sub_100D5251C(uint64_t **a1)
{
  BOOL v5 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 417)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SIM unlock flow invalidated, was in progress : %s", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(v1 + 417))
  {
    *(unsigned char *)(v1 + 417) = 0;
    int v4 = *(std::__shared_weak_count **)(v1 + 432);
    *(void *)(v1 + 424) = 0;
    *(void *)(v1 + 432) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
    *(void *)&long long buf = off_101A546F8;
    *((void *)&buf + 1) = v1;
    p_long long buf = &buf;
    sub_100D4DD48(v1, (uint64_t)&buf);
    sub_100D5172C(&buf);
  }
  operator delete();
}

void sub_100D52658(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100D5172C((uint64_t *)va);
  operator delete();
}

void sub_100D52690()
{
}

void *sub_100D526A4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A546F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100D526EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A546F8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100D52718(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 320);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v1 + 320;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < 5;
    if (v4 >= 5) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == v1 + 320 || *(int *)(v3 + 28) > 5) {
    return 0;
  }
  unsigned int v8 = *(_DWORD *)(v3 + 32);
  if (v8 == 3)
  {
    if (sub_100D4E11C((void *)(v1 + 152))) {
      return 3;
    }
    else {
      return 0;
    }
  }
  else if (sub_100D51C34(0, (void *)(v1 + 152)))
  {
    return v8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D527B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D527F8()
{
}

void sub_100D52804(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Device info page requested...", buf, 2u);
  }
  BOOL v5 = (uint64_t *)*(unsigned __int8 *)(v1 + 178);
  if (!*(unsigned char *)(v1 + 178))
  {
    sub_100D4C5C0(v1, v3, v4);
    goto LABEL_36;
  }
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(v1 + 56));
  uint64_t v7 = ServiceMap;
  uint64_t v9 = v8;
  if (v8 < 0)
  {
    BOOL v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  uint64_t v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    unsigned int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v14 = 0;
  char v16 = 1;
LABEL_13:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 96))(&cf, v15, 1, 2, @"ShowIMEIsInLockScreen", kCFBooleanFalse, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  CFTypeRef v35 = 0;
  long long v18 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(v1 + 56));
  uint64_t v19 = v18;
  if (v8 < 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v8 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v18);
  *(void *)long long buf = v8;
  long long v23 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
LABEL_23:
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v25 + 96))(&v35, v25, 2, 2, @"ShowIMEIsInLockScreen", kCFBooleanFalse, 0);
      if ((v26 & 1) == 0) {
        sub_10004D2C8(v24);
      }
      uint64_t v29 = (BOOL *)cf;
      buf[0] = 0;
      if (cf && (CFTypeID v30 = CFGetTypeID(cf), v30 == CFBooleanGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v29, v28);
        int v31 = buf[0];
      }
      else
      {
        int v31 = 0;
      }
      char v32 = (BOOL *)v35;
      buf[0] = 0;
      if (v35 && (CFTypeID v33 = CFGetTypeID(v35), v33 == CFBooleanGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v32, v28);
        int v34 = buf[0];
      }
      else
      {
        int v34 = 0;
      }
      if (v34 | v31) {
        sub_100D4C5C0(v1, v27, (unint64_t)v28);
      }
      sub_1000577C4(&v35);
      sub_1000577C4(&cf);
LABEL_36:
      operator delete();
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v19);
  uint64_t v24 = 0;
  char v26 = 1;
  goto LABEL_23;
}

void sub_100D52B30(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  sub_1000577C4((const void **)va);
  operator delete();
}

void sub_100D52BB0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Show IDS transferring view ...", buf, 2u);
  }
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v14 = 0u;
  buf[0] = 1;
  uint64_t v3 = *(void *)(v1 + 96);
  sub_100D4F62C((uint64_t)v4, (uint64_t)buf);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v3 + 88))(v3, v4);
  if (v12 < 0) {
    operator delete(__p);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
  operator delete();
}

void sub_100D52CDC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  operator delete();
}

void sub_100D52D50(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = a1 + 8;
    do
    {
      int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 < a2;
      if (v4 >= a2) {
        char v6 = (uint64_t *)v2;
      }
      else {
        char v6 = (uint64_t *)(v2 + 8);
      }
      if (!v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 8 && *(_DWORD *)(v3 + 32) <= a2)
    {
      sub_10006C514((uint64_t **)a1, (uint64_t *)v3);
      sub_1001D88DC((const void **)(v3 + 40));
      operator delete((void *)v3);
    }
  }
}

void sub_100D52DE0()
{
}

void *sub_100D52DF4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A54778;
  result[1] = v3;
  return result;
}

uint64_t sub_100D52E3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A54778;
  a2[1] = v2;
  return result;
}

uint64_t sub_100D52E68(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void **)(v1 + 152);
  uint64_t v3 = (void *)(v1 + 160);
  if (v2 == (void *)(v1 + 160)) {
    return 0;
  }
  char v4 = 0;
  while (1)
  {
    uint64_t result = subscriber::isSimSettled();
    if (!result) {
      break;
    }
    if (subscriber::isSimReady()) {
      return 0;
    }
    if ((subscriber::isSimAbsent() & 1) == 0)
    {
      uint64_t result = subscriber::isSimLocked();
      if (!result) {
        return result;
      }
      char v4 = 1;
    }
    char v6 = (void *)v2[1];
    if (v6)
    {
      do
      {
        uint64_t v7 = v6;
        char v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        uint64_t v7 = (void *)v2[2];
        BOOL v8 = *v7 == (void)v2;
        uint64_t v2 = v7;
      }
      while (!v8);
    }
    uint64_t v2 = v7;
    if (v7 == v3)
    {
      if (v4) {
        return 3;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100D52F28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D52F68()
{
}

void sub_100D52F78()
{
}

void *sub_100D52F8C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A547F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100D52FD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A547F8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100D53000(uint64_t a1)
{
  if (sub_100D4E11C((void *)(*(void *)(a1 + 8) + 152))) {
    return 3;
  }
  else {
    return 0;
  }
}

uint64_t sub_100D5302C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D5306C()
{
}

void sub_100D53078(uint64_t a1, NSObject **a2, void *a3, long long *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "lazuli.msg.mdl");
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  BOOL v8 = *a2;
  *(void *)(a1 + 16) = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 24) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v14, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)&v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  v15[0] = off_101999E18;
  v15[1] = sub_100D5379C;
  v15[3] = v15;
  *(void *)(a1 + 40) = 0;
  if ((capabilities::ct::supportsGemini(v9) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 40)) {
    operator new();
  }
  sub_10008863C(v15);
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *(void *)(a1 + 64) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 48) = v10;
  }
  *(void *)(a1 + 72) = *a3;
  uint64_t v11 = a3[1];
  *(void *)(a1 + 80) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  int v12 = SlotIdFromPersonalityId();
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 88) = v12;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = *((void *)a4 + 5);
  uint64_t v13 = *((void *)a4 + 6);
  *(void *)(a1 + 224) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100D5355C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

const char *sub_100D5379C(int a1)
{
  uint64_t v1 = "lazuli.msg.mdl.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.msg.mdl.2";
  }
  if (a1 == 1) {
    return "lazuli.msg.mdl.1";
  }
  else {
    return v1;
  }
}

void sub_100D537C8(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  unsigned int v3 = SlotIdFromPersonalityId();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 72));
  char v6 = ServiceMap;
  if (v7 < 0)
  {
    BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  int v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_7:
    long long v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get SD interface while adding delegate", buf, 2u);
    }
    goto LABEL_57;
  }
LABEL_11:
  *(void *)long long buf = 0;
  uint64_t v44 = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 32))(buf, v13, a1 + 48);
  if (*(void *)buf)
  {
    (*(void (**)(void, uint64_t))(**(void **)buf + 232))(*(void *)buf, a1 + 48);
    *(void *)xpc_object_t v41 = 0;
    uint64_t v42 = 0;
    OsLogContext v16 = *(std::__shared_weak_count **)(a1 + 80);
    v40[0] = *(void *)(a1 + 72);
    v40[1] = (uint64_t)v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v17 = v44;
    v39[0] = *(void *)buf;
    v39[1] = (uint64_t)v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v18 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v18 || (uint64_t v19 = *(void *)a1, (v20 = std::__shared_weak_count::lock(v18)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v21 = v20;
    v38[0] = v19;
    v38[1] = (uint64_t)v20;
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v20);
    sub_10132CA2C(v3, v40, (NSObject **)(a1 + 16), v39, v38, v41);
    std::__shared_weak_count::__release_weak(v21);
    if (v17) {
      sub_10004D2C8(v17);
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
    uint64_t v22 = *(void *)v41;
    if (*(void *)v41)
    {
      long long v23 = v42;
      if (v42)
      {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v24 = *(void *)buf;
        BOOL v37 = v23;
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v24 = *(void *)buf;
        BOOL v37 = 0;
      }
      uint64_t v27 = *(NSObject **)(a1 + 16);
      dispatch_object_t object = v27;
      uint64_t v36 = v22;
      if (v27) {
        dispatch_retain(v27);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t *, dispatch_object_t *))(*(void *)v24 + 184))(v24, a1 + 48, &v36, &object);
      if (object) {
        dispatch_release(object);
      }
      if (v37) {
        sub_10004D2C8(v37);
      }
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      CFBooleanRef v28 = *(std::__shared_weak_count **)(a1 + 176);
      *(void *)(a1 + 168) = v22;
      *(void *)(a1 + 176) = v23;
      if (v28) {
        sub_10004D2C8(v28);
      }
      uint64_t v30 = *(void *)buf;
      uint64_t v29 = v44;
      if (v44) {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v31 = *(std::__shared_weak_count **)(a1 + 192);
      *(void *)(a1 + 184) = v30;
      *(void *)(a1 + 192) = v29;
      if (v31) {
        sub_10004D2C8(v31);
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v22 + 144))(v45, v22);
      long long v32 = *(_OWORD *)v45;
      memset(v45, 0, sizeof(v45));
      CFTypeID v33 = *(std::__shared_weak_count **)(a1 + 208);
      *(_OWORD *)(a1 + 200) = v32;
      if (v33)
      {
        sub_10004D2C8(v33);
        if (*(void *)&v45[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v45[8]);
        }
      }
      int v34 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 71) < 0) {
          uint64_t v2 = (void *)*v2;
        }
        *(_DWORD *)long long v45 = 136315138;
        *(void *)&v45[4] = v2;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I IMS delegate added: %s", v45, 0xCu);
      }
      sub_10019E028((uint64_t *)(a1 + 256));
      sub_10019E028((uint64_t *)(a1 + 280));
      sub_10019E028((uint64_t *)(a1 + 336));
      if (v23) {
        sub_10004D2C8(v23);
      }
    }
    else
    {
      char v26 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v45 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to get Sip stack ref", v45, 2u);
      }
    }
    if (v42) {
      sub_10004D2C8(v42);
    }
  }
  else
  {
    uint64_t v25 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v41 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to get Lazuli client while adding IMS delegate", v41, 2u);
    }
  }
  if (v44) {
    sub_10004D2C8(v44);
  }
LABEL_57:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100D53D28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D53DE4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 72));
  unsigned int v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v4;
  BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, &v16);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    int v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Failed to get SD interface while removing delegate", (uint8_t *)&v16, 2u);
    }
    goto LABEL_20;
  }
LABEL_11:
  unint64_t v16 = 0;
  long long v17 = 0;
  uint64_t v13 = (void *)(a1 + 48);
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v10 + 32))(&v16, v10, a1 + 48);
  if (v16)
  {
    (*(void (**)(unint64_t, uint64_t))(*(void *)v16 + 232))(v16, a1 + 48);
    char v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 71) < 0) {
        uint64_t v13 = (void *)*v13;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v19 = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I IMS delegate removed: %s", buf, 0xCu);
    }
  }
  else
  {
    long long v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get Lazuli client while removing IMS delegate", buf, 2u);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
LABEL_20:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100D540C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5410C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    uint64_t v9 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I slot: %s", (uint8_t *)&v8, 0xCu);
  }
  unsigned int v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = "YES";
    if (*(void *)(a1 + 168)) {
      BOOL v5 = "YES";
    }
    else {
      BOOL v5 = "NO";
    }
    uint64_t v6 = *(void *)(a1 + 232);
    if (*(void *)(a1 + 184)) {
      unsigned int v7 = "YES";
    }
    else {
      unsigned int v7 = "NO";
    }
    int v8 = 136315650;
    if (!v6) {
      unint64_t v4 = "NO";
    }
    uint64_t v9 = (uint64_t)v5;
    __int16 v10 = 2080;
    char v11 = v7;
    __int16 v12 = 2080;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sip-stack: %s, ims-client: %s, hub: %s", (uint8_t *)&v8, 0x20u);
  }
  sub_10112F3D4(*(void *)(a1 + 232));
}

void sub_100D542A0()
{
  v0[0] = 0;
  v0[1] = 0;
  uint64_t v1 = 0;
  sub_100CC786C();
}

void sub_100D548A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t *sub_100D54964(unint64_t *result, uint64_t a2, uint64_t a3)
{
  BOOL v5 = result;
  unint64_t v6 = result[2];
  unsigned int v7 = (void *)result[1];
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = *result;
    uint64_t v10 = (uint64_t)((uint64_t)v7 - *result) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_100D65248();
    }
    uint64_t v12 = v6 - v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    uint64_t v22 = result + 2;
    if (v13 >> 60) {
      sub_10006A7CC();
    }
    char v14 = (char *)operator new(16 * v13);
    long long v15 = &v14[16 * v10];
    *(void *)long long v15 = a2;
    *((void *)v15 + 1) = a3;
    if (a3)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
      unint64_t v9 = *v5;
      unsigned int v7 = (void *)v5[1];
    }
    int v8 = v15 + 16;
    if (v7 == (void *)v9)
    {
      int64x2_t v17 = vdupq_n_s64(v9);
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v7 - 1);
        v7 -= 2;
        *((_OWORD *)v15 - 1) = v16;
        v15 -= 16;
        *unsigned int v7 = 0;
        v7[1] = 0;
      }
      while (v7 != (void *)v9);
      int64x2_t v17 = *(int64x2_t *)v5;
    }
    *BOOL v5 = (unint64_t)v15;
    v5[1] = (unint64_t)v8;
    int64x2_t v20 = v17;
    unint64_t v18 = v5[2];
    v5[2] = (unint64_t)&v14[16 * v13];
    unint64_t v21 = v18;
    uint64_t v19 = v17.i64[0];
    uint64_t result = (unint64_t *)sub_10019E528((uint64_t)&v19);
  }
  else
  {
    *unsigned int v7 = a2;
    v7[1] = a3;
    if (a3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    }
    int v8 = v7 + 2;
  }
  v5[1] = (unint64_t)v8;
  return result;
}

void sub_100D54AA0()
{
  __s[0] = 0;
  __s[1] = 0;
  uint64_t v1 = 0;
  sub_100CC786C();
}

void sub_100D550E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D551EC(uint64_t a1, uint64_t a2)
{
  v2[0] = 0;
  v2[1] = 0;
  uint64_t v3 = 0;
  sub_100CC7114(&__p, a2);
  sub_100CC786C();
}

void sub_100D55508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D55560(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*(char *)(*a2 + 71) < 0)
  {
    sub_10004FC84(__s1, *(void **)(v3 + 48), *(void *)(v3 + 56));
  }
  else
  {
    *(_OWORD *)__s1 = *(_OWORD *)(v3 + 48);
    uint64_t v23 = *(void *)(v3 + 64);
  }
  if (v23 >= 0) {
    unint64_t v4 = (void *)HIBYTE(v23);
  }
  else {
    unint64_t v4 = __s1[1];
  }
  BOOL v5 = (void *)*(unsigned __int8 *)(a1 + 55);
  int v6 = (char)v5;
  if ((char)v5 < 0) {
    BOOL v5 = *(void **)(a1 + 40);
  }
  if (v4 == v5)
  {
    unint64_t v9 = *(unsigned __int8 **)(a1 + 32);
    int v8 = (unsigned __int8 *)(a1 + 32);
    unsigned int v7 = v9;
    if (v6 >= 0) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v7;
    }
    if (v23 < 0)
    {
      int64x2_t v20 = __s1[0];
      BOOL v19 = memcmp(__s1[0], v10, (size_t)__s1[1]) == 0;
      goto LABEL_26;
    }
    if (!HIBYTE(v23)) {
      return 1;
    }
    uint64_t v11 = HIBYTE(v23) - 1;
    uint64_t v12 = __s1;
    do
    {
      int v14 = *(unsigned __int8 *)v12;
      uint64_t v12 = (void **)((char *)v12 + 1);
      int v13 = v14;
      int v16 = *v10++;
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v19 = v13 == v15;
    }
    while (v13 == v15 && v18);
  }
  else
  {
    BOOL v19 = 0;
  }
  if (v23 < 0)
  {
    int64x2_t v20 = __s1[0];
LABEL_26:
    operator delete(v20);
  }
  return v19;
}

void sub_100D5565C(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  v11[0] = a3;
  v11[1] = ims::lazuli::kIsGroupChat;
  sub_100048BAC((uint64_t)v11, &object);
  int v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  xpc_object_t v8 = *a3;
  if (v7)
  {
    xpc_object_t v10 = *a3;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v10 = xpc_null_create();
    }
    sub_100D55788(a1, a2, &v10);
    xpc_release(v10);
  }
  else
  {
    xpc_object_t v9 = *a3;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v9 = xpc_null_create();
    }
    sub_100D56568(a1, a2, (uint64_t)&v9);
    xpc_release(v9);
  }
}

void sub_100D5573C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14)
{
}

void sub_100D55788(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Incoming group chat", buf, 2u);
  }
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  uint64_t v13 = 0;
  v8[0] = a3;
  v8[1] = (void *)ims::lazuli::kConferenceFocus;
  sub_100048BAC((uint64_t)v8, object);
  memset(buf, 0, sizeof(buf));
  uint64_t v15 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v15) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object[0]);
  uint64_t v6 = HIBYTE(v13);
  if (v13 < 0) {
    uint64_t v6 = v12;
  }
  if (v6)
  {
    object[1] = 0;
    object[0] = 0;
    uint64_t v10 = 0;
    sub_100D581AC((uint64_t)buf, (uint64_t)&v11);
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Dropping Incoming group chat. Invalid focus", buf, 2u);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v11);
  }
}

void sub_100D5632C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,xpc_object_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a57 < 0) {
    operator delete(__p);
  }
  if (SLOBYTE(STACK[0x227]) < 0) {
    operator delete((void *)STACK[0x210]);
  }
  if (v57) {
    sub_10004D2C8(v57);
  }
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  _Unwind_Resume(a1);
}

void sub_100D56568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Incoming 1:1 chat", buf, 2u);
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  *(void *)uint64_t v13 = a3;
  uint64_t v14 = ims::lazuli::kRemoteUri;
  sub_100048BAC((uint64_t)v13, object);
  memset(buf, 0, sizeof(buf));
  uint64_t v16 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object[0]);
  uint64_t v6 = HIBYTE(v12);
  if (v12 < 0) {
    uint64_t v6 = v11;
  }
  if (v6)
  {
    object[0] = 0;
    object[1] = 0;
    uint64_t v9 = 0;
    sub_100D5824C((uint64_t)object, (uint64_t)&v10);
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Empty remote URI. dropping incoming chat", buf, 2u);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v10);
  }
}

void sub_100D56D8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,xpc_object_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,char a59)
{
  if (v59) {
    sub_10004D2C8(v59);
  }
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  if (a58 < 0) {
    operator delete(a53);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D56F40(uint64_t a1, uint64_t a2, void *a3)
{
  __p[0] = a3;
  __p[1] = (void *)ims::lazuli::kIsChatbot;
  sub_100048BAC((uint64_t)__p, object);
  int v6 = xpc::dyn_cast_or_default((xpc *)object, 0, v5);
  xpc_release(object[0]);
  if (v6)
  {
    object[0] = 0;
    object[1] = 0;
    uint64_t v18 = 0;
    int v7 = (void *)ims::lazuli::kRemoteUri;
    v15[0] = (void **)a3;
    v15[1] = (void **)ims::lazuli::kRemoteUri;
    sub_100048BAC((uint64_t)v15, &v16);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v20 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v16);
    xpc_object_t v8 = (xpc_object_t)HIBYTE(v18);
    if (v18 < 0) {
      xpc_object_t v8 = object[1];
    }
    if (!v8)
    {
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Dropping incoming session ready event. Invalid key: %s", (uint8_t *)__p, 0xCu);
      }
      goto LABEL_29;
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 328);
    if (v9)
    {
      uint64_t v10 = std::__shared_weak_count::lock(v9);
      if (v10)
      {
        uint64_t v11 = *(void *)(a1 + 320);
        if (v11)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 88);
          if (SHIBYTE(v18) < 0)
          {
            sub_10004FC84(__p, object[0], (unint64_t)object[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)object;
            uint64_t v20 = v18;
          }
          char v25 = 0;
          char v26 = 0;
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          uint64_t v27 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          unint64_t v21 = 0;
          char v24 = 0;
          (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v11 + 104))(v11, v12, __p);
          if (SHIBYTE(v29) < 0) {
            operator delete(v27);
          }
          if (v26)
          {
            v15[0] = (void **)&v25;
            sub_100047F64(v15);
          }
          if (SHIBYTE(v23) < 0) {
            operator delete(v21);
          }
          if (SHIBYTE(v20) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_28;
        }
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Missing capabilities controller", (uint8_t *)__p, 2u);
      if (!v10) {
        goto LABEL_29;
      }
    }
    else if (!v10)
    {
LABEL_29:
      if (SHIBYTE(v18) < 0) {
        operator delete(object[0]);
      }
      return;
    }
LABEL_28:
    sub_10004D2C8(v10);
    goto LABEL_29;
  }
}

void sub_100D57230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_10004D2C8(v23);
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100D572CC(uint64_t a1, uint64_t a2, void *a3)
{
  xpc_object_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  __dst[0] = a3;
  __dst[1] = (void *)ims::lazuli::kBody;
  sub_100048BAC((uint64_t)__dst, &object);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v45 = 0;
  xpc::dyn_cast_or_default();
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  xpc_release(object);
  unint64_t v5 = v42 - (unsigned char *)v41;
  if (v42 == v41)
  {
    uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, void, char *, unint64_t))(**(void **)(a1 + 40)
                                                                                            + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88), v42, v5);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Dropping incoming message: Invalid body.", (uint8_t *)__p, 2u);
    }
  }
  else
  {
    xpc_object_t object = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    sub_10012CD04(&object, (char *)v41, v42, v5);
    uint64_t v6 = HIBYTE(v40);
    if (v40 < 0) {
      uint64_t v6 = v39;
    }
    if (v6)
    {
      CFTypeRef v35 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      int v7 = (void *)ims::lazuli::kRemoteUri;
      __dst[0] = a3;
      __dst[1] = (void *)ims::lazuli::kRemoteUri;
      sub_100048BAC((uint64_t)__dst, v33);
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v45 = 0;
      xpc::dyn_cast_or_default();
      if (SBYTE7(v45) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v33[0]);
      uint64_t v8 = HIBYTE(v37);
      if (v37 < 0) {
        uint64_t v8 = v36;
      }
      if (v8)
      {
        v33[0] = 0;
        v33[1] = 0;
        uint64_t v34 = 0;
        uint64_t v9 = (void *)ims::lazuli::kContributionId;
        __dst[0] = a3;
        __dst[1] = (void *)ims::lazuli::kContributionId;
        sub_100048BAC((uint64_t)__dst, &v27);
        __p[0] = 0;
        __p[1] = 0;
        *(void *)&long long v45 = 0;
        xpc::dyn_cast_or_default();
        if (SBYTE7(v45) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(v27);
        xpc_object_t v10 = (xpc_object_t)HIBYTE(v34);
        if (v34 < 0) {
          xpc_object_t v10 = v33[1];
        }
        if (!v10)
        {
          uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v9;
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid key: %s", (uint8_t *)__p, 0xCu);
          }
          sub_100561B00((uint64_t)__p);
          if (SHIBYTE(v34) < 0) {
            operator delete(v33[0]);
          }
          *(_OWORD *)CFTypeID v33 = *(_OWORD *)__p;
          uint64_t v34 = v45;
        }
        uint64_t v32 = 0;
        *(_OWORD *)std::string __dst = 0u;
        long long v31 = 0u;
        sub_100CC8650(__dst, (uint64_t)&object);
        xpc_object_t v27 = 0;
        uint64_t v28 = 0;
        uint64_t v29 = 0;
        uint64_t v12 = (void *)ims::lazuli::kContentType;
        __p[0] = a3;
        __p[1] = (void *)ims::lazuli::kContentType;
        sub_100048BAC((uint64_t)__p, &v24);
        xpc::dyn_cast_or_default((uint64_t *)&v27, (xpc *)&v24, (const object *)"message/cpim", v13);
        xpc_release(v24);
        uint64_t v14 = HIBYTE(v29);
        if (v29 < 0) {
          uint64_t v14 = v28;
        }
        if (v14)
        {
          __p[0] = a3;
          __p[1] = (void *)ims::lazuli::kIsGroupChat;
          sub_100048BAC((uint64_t)__p, &v24);
          xpc::dyn_cast_or_default((xpc *)&v24, 0, v15);
          xpc_release(v24);
          xpc_object_t v24 = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          v23[0] = a3;
          v23[1] = (void *)ims::lazuli::kConversationId;
          sub_100048BAC((uint64_t)v23, v22);
          __p[0] = 0;
          __p[1] = 0;
          *(void *)&long long v45 = 0;
          xpc::dyn_cast_or_default();
          if (SBYTE7(v45) < 0) {
            operator delete(__p[0]);
          }
          xpc_release(v22[0]);
          uint64_t v16 = HIBYTE(v26);
          if (v26 < 0) {
            uint64_t v16 = v25;
          }
          if (!v16)
          {
            int64x2_t v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Missing / empty conversationID", (uint8_t *)__p, 2u);
            }
          }
          sub_100D551EC(a1, (uint64_t)&v35);
        }
        unint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v12;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Dropping incoming message. Invalid key: %s", (uint8_t *)__p, 0xCu);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v27);
        }
        if (SBYTE7(v31) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete(v33[0]);
        }
      }
      else
      {
        uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v7;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Dropping incoming message. Invalid key: %s", (uint8_t *)__p, 0xCu);
        }
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(v35);
      }
    }
    else
    {
      BOOL v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Dropping incoming message: Empty body", (uint8_t *)__p, 2u);
      }
    }
    if (SHIBYTE(v40) < 0) {
      operator delete(object);
    }
  }
  if (v41)
  {
    uint64_t v42 = (char *)v41;
    operator delete(v41);
  }
}

void sub_100D57EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,xpc_object_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,xpc_object_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,xpc_object_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a72 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  if (a61) {
    operator delete(a61);
  }
  _Unwind_Resume(a1);
}

void sub_100D581AC(uint64_t a1, uint64_t a2)
{
  memset(&__p[3], 0, 24);
  sub_100CC7114(__p, a2);
  sub_100CC786C();
}

void sub_100D5821C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5824C(uint64_t a1, uint64_t a2)
{
  long long __s = 0uLL;
  uint64_t v3 = 0;
  sub_100CC7114(&__s, a2);
  sub_100CC80B0();
}

void sub_100D58394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a27 && a26 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v27 - 17) < 0) {
    operator delete(*(void **)(v27 - 40));
  }
  _Unwind_Resume(exception_object);
}

void sub_100D58414(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v39 = a3;
  uint64_t v40 = ims::lazuli::kIsSuccess;
  sub_100048BAC((uint64_t)&v39, &object);
  int v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  xpc_object_t __p = a3;
  uint64_t v32 = ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)&__p, v34);
  xpc_object_t object = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v38) < 0) {
    operator delete(object);
  }
  xpc_release(v34[0]);
  xpc_object_t object = a3;
  uint64_t v37 = ims::lazuli::kErrorCode;
  sub_100048BAC((uint64_t)&object, &__p);
  int v9 = xpc::dyn_cast_or_default((xpc *)&__p, 0, v8);
  xpc_release(__p);
  xpc_object_t object = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  v34[0] = a3;
  v34[1] = (xpc_object_t)ims::lazuli::kReason;
  sub_100048BAC((uint64_t)v34, &v35);
  xpc_object_t __p = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  xpc_release(v35);
  xpc_object_t v10 = *(uint64_t **)(a1 + 256);
  uint64_t v11 = *(uint64_t **)(a1 + 264);
  if (v10 == v11) {
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v12 = *v10;
    uint64_t v13 = (std::__shared_weak_count *)v10[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v14 = sub_100B1A0E8(v12, a2);
    if (v13) {
      sub_10004D2C8(v13);
    }
    if (v14) {
      break;
    }
    v10 += 2;
    if (v10 == v11)
    {
      xpc_object_t v10 = v11;
      break;
    }
  }
  if (v10 == *(uint64_t **)(a1 + 264)) {
    goto LABEL_26;
  }
  if (v9 == 404)
  {
LABEL_15:
    BOOL v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Message send failure (for group) with 404", (uint8_t *)&__p, 2u);
    }
    int v16 = 8;
    goto LABEL_27;
  }
  if (v38 >= 0) {
    uint64_t v17 = HIBYTE(v38);
  }
  else {
    uint64_t v17 = v37;
  }
  if (v38 >= 0) {
    p_xpc_object_t object = (char *)&object;
  }
  else {
    p_xpc_object_t object = (char *)object;
  }
  if (v17 >= 3)
  {
    uint64_t v22 = &p_object[v17];
    uint64_t v23 = v17;
    xpc_object_t v24 = p_object;
    do
    {
      uint64_t v25 = (char *)memchr(v24, 52, v23 - 2);
      if (!v25) {
        break;
      }
      if (*(_WORD *)v25 == 12340 && v25[2] == 52)
      {
        if (v25 != v22 && v25 - p_object != -1) {
          goto LABEL_15;
        }
        break;
      }
      xpc_object_t v24 = v25 + 1;
      uint64_t v23 = v22 - (unsigned char *)v24;
    }
    while (v22 - (unsigned char *)v24 >= 3);
    if (v9 == 403) {
      goto LABEL_51;
    }
    uint64_t v28 = p_object;
    while (1)
    {
      uint64_t v29 = (char *)memchr(v28, 52, v17 - 2);
      if (!v29) {
        goto LABEL_26;
      }
      if (*(_WORD *)v29 == 12340 && v29[2] == 51)
      {
        int v16 = 3;
        if (v29 != v22 && v29 - p_object != -1) {
          goto LABEL_51;
        }
        goto LABEL_27;
      }
      uint64_t v28 = v29 + 1;
      uint64_t v17 = v22 - (unsigned char *)v28;
      int v16 = 3;
      if (v22 - (unsigned char *)v28 < 3) {
        goto LABEL_27;
      }
    }
  }
  if (v9 != 403)
  {
LABEL_26:
    int v16 = 3;
    goto LABEL_27;
  }
LABEL_51:
  uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Message send failure (for group) with 403", (uint8_t *)&__p, 2u);
  }
  int v16 = 9;
LABEL_27:
  uint64_t v19 = HIBYTE(v41);
  if (v41 < 0) {
    uint64_t v19 = v40;
  }
  if (v19)
  {
    uint64_t v20 = *(void *)(a1 + 232);
    if (v7)
    {
      sub_10113460C(v20, (unsigned __int8 *)&v39);
    }
    else
    {
      LODWORD(__p) = v16;
      BYTE4(__p) = 1;
      sub_101134BE4(v20, (unsigned __int8 **)&v39, (unsigned int *)&__p);
    }
  }
  else
  {
    unint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Dropping incoming message send notification: No transaction ID", (uint8_t *)&__p, 2u);
    }
  }
  if (SHIBYTE(v38) < 0) {
    operator delete(object);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
}

void sub_100D58880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t a15, uint64_t a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5895C(uint64_t a1, uint64_t a2, void *a3)
{
  int v7 = *(uint64_t **)(a1 + 280);
  BOOL v6 = *(uint64_t **)(a1 + 288);
  if (v7 == v6)
  {
LABEL_9:
    int v8 = v6;
  }
  else
  {
    int v8 = *(uint64_t **)(a1 + 280);
    while (1)
    {
      uint64_t v9 = *v8;
      xpc_object_t v10 = (std::__shared_weak_count *)v8[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v11 = sub_100B1A0E8(v9, a2);
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (v11) {
        break;
      }
      v8 += 2;
      if (v8 == v6) {
        goto LABEL_9;
      }
    }
    if (v8 != v6)
    {
      for (uint64_t i = v8 + 2; i != v6; i += 2)
      {
        uint64_t v26 = *i;
        uint64_t v27 = (std::__shared_weak_count *)i[1];
        if (v27) {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v28 = sub_100B1A0E8(v26, a2);
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (!v28)
        {
          long long v29 = *(_OWORD *)i;
          *uint64_t i = 0;
          i[1] = 0;
          uint64_t v30 = (std::__shared_weak_count *)v8[1];
          *(_OWORD *)int v8 = v29;
          if (v30) {
            sub_10004D2C8(v30);
          }
          v8 += 2;
        }
      }
    }
  }
  sub_100D65260(a1 + 280, (uint64_t)v8, *(void *)(a1 + 288));
  if ((char *)v6 - (char *)v7 == *(void *)(a1 + 288) - *(void *)(a1 + 280))
  {
    uint64_t v13 = *(uint64_t **)(a1 + 256);
    uint64_t v12 = *(uint64_t **)(a1 + 264);
    if (v13 == v12)
    {
LABEL_19:
      BOOL v14 = v12;
    }
    else
    {
      BOOL v14 = *(uint64_t **)(a1 + 256);
      while (1)
      {
        uint64_t v15 = *v14;
        int v16 = (std::__shared_weak_count *)v14[1];
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v17 = sub_100B1A0E8(v15, a2);
        if (v16) {
          sub_10004D2C8(v16);
        }
        if (v17) {
          break;
        }
        v14 += 2;
        if (v14 == v12) {
          goto LABEL_19;
        }
      }
      if (v14 != v12)
      {
        for (uint64_t j = v14 + 2; j != v12; j += 2)
        {
          uint64_t v46 = *j;
          long long v47 = (std::__shared_weak_count *)j[1];
          if (v47) {
            atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BOOL v48 = sub_100B1A0E8(v46, a2);
          if (v47) {
            sub_10004D2C8(v47);
          }
          if (!v48)
          {
            long long v49 = *(_OWORD *)j;
            *uint64_t j = 0;
            j[1] = 0;
            uint64_t v50 = (std::__shared_weak_count *)v14[1];
            *(_OWORD *)BOOL v14 = v49;
            if (v50) {
              sub_10004D2C8(v50);
            }
            v14 += 2;
          }
        }
      }
    }
    sub_100D65260(a1 + 256, (uint64_t)v14, *(void *)(a1 + 264));
    uint64_t v18 = (uint64_t *)(*(void *)(a1 + 264) - *(void *)(a1 + 256));
    uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    if ((uint64_t *)((char *)v12 - (char *)v13) == v18)
    {
      if (!v20) {
        goto LABEL_41;
      }
      LOWORD(buf) = 0;
      unint64_t v21 = "#I No model erased";
      uint64_t v22 = v19;
      uint32_t v23 = 2;
      goto LABEL_40;
    }
    if (!v20) {
      goto LABEL_41;
    }
    uint64_t v31 = (uint64_t)(*(void *)(a1 + 264) - *(void *)(a1 + 256)) >> 4;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v31;
    unint64_t v21 = "#I Erased group model - current size: %zu";
  }
  else
  {
    uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_41;
    }
    uint64_t v24 = (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 4;
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v24;
    unint64_t v21 = "#I Erased 1:1 model - current size: %zu";
  }
  uint64_t v22 = v19;
  uint32_t v23 = 12;
LABEL_40:
  _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&buf, v23);
LABEL_41:
  *(void *)&long long buf = a3;
  *((void *)&buf + 1) = ims::lazuli::kErrorCode;
  sub_100048BAC((uint64_t)&buf, &object);
  int v33 = xpc::dyn_cast_or_default((xpc *)&object, 0, v32);
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  *(void *)&long long v64 = a3;
  *((void *)&v64 + 1) = ims::lazuli::kReason;
  sub_100048BAC((uint64_t)&v64, __p);
  long long buf = 0uLL;
  uint64_t v63 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)buf);
  }
  xpc_release(__p[0]);
  if (v33 != 404)
  {
    uint64_t v38 = HIBYTE(v61);
    if (v61 >= 0)
    {
      p_xpc_object_t object = (char *)&object;
    }
    else
    {
      uint64_t v38 = v60;
      p_xpc_object_t object = (char *)object;
    }
    if (v38 >= 3)
    {
      uint64_t v40 = &p_object[v38];
      uint64_t v41 = p_object;
      while (1)
      {
        uint64_t v42 = (char *)memchr(v41, 52, v38 - 2);
        if (!v42) {
          break;
        }
        if (*(_WORD *)v42 == 12340 && v42[2] == 52)
        {
          if (v42 != v40 && v42 - p_object != -1) {
            goto LABEL_44;
          }
          goto LABEL_92;
        }
        uint64_t v41 = v42 + 1;
        uint64_t v38 = v40 - (unsigned char *)v41;
        if (v40 - (unsigned char *)v41 < 3) {
          goto LABEL_92;
        }
      }
    }
    goto LABEL_92;
  }
LABEL_44:
  uint64_t v34 = *(std::__shared_weak_count **)(a1 + 328);
  if (v34)
  {
    xpc_object_t v35 = std::__shared_weak_count::lock(v34);
    if (v35 && *(void *)(a1 + 320))
    {
      long long buf = 0uLL;
      uint64_t v63 = 0;
      uint64_t v36 = ims::lazuli::kRemoteUri;
      __p[0] = a3;
      __p[1] = (xpc_object_t)ims::lazuli::kRemoteUri;
      sub_100048BAC((uint64_t)__p, v55);
      long long v64 = 0uLL;
      uint64_t v65 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v65) < 0) {
        operator delete((void *)v64);
      }
      xpc_release(v55[0]);
      if (v63 >= 0) {
        uint64_t v37 = HIBYTE(v63);
      }
      else {
        uint64_t v37 = *((void *)&buf + 1);
      }
      if (v37)
      {
        sub_100CC85C0(__p, (uint64_t)&buf);
        sub_100CC786C();
      }
      char v51 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v64) = 136315138;
        *(void *)((char *)&v64 + 4) = v36;
        _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Dropping session terminated callback. Missing key: %s", (uint8_t *)&v64, 0xCu);
      }
      if (SHIBYTE(v63) < 0) {
        operator delete((void *)buf);
      }
      sub_10004D2C8(v35);
      goto LABEL_96;
    }
  }
  else
  {
    xpc_object_t v35 = 0;
  }
  uint64_t v44 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
  {
    if (!v35) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  LOWORD(buf) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Missing capabilties controller", (uint8_t *)&buf, 2u);
  if (v35) {
LABEL_91:
  }
    sub_10004D2C8(v35);
LABEL_92:
  *(void *)&long long buf = a3;
  *((void *)&buf + 1) = ims::lazuli::kUserEvictedFromGroup;
  sub_100048BAC((uint64_t)&buf, &v64);
  char v53 = xpc::dyn_cast_or_default((xpc *)&v64, 0, v52);
  xpc_release((xpc_object_t)v64);
  if (v53)
  {
    long long v64 = 0uLL;
    uint64_t v65 = 0;
    v56[0] = a3;
    v56[1] = (xpc_object_t)ims::lazuli::kConferenceFocus;
    sub_100048BAC((uint64_t)v56, &v57);
    memset(v55, 0, sizeof(v55));
    xpc::dyn_cast_or_default();
    sub_100CC7114(&buf, (uint64_t)__p);
    sub_100CC786C();
  }
  uint64_t v54 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Session terminated (no actions)", (uint8_t *)&buf, 2u);
  }
LABEL_96:
  if (SHIBYTE(v61) < 0) {
    operator delete(object);
  }
}

void sub_100D59540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t object,uint64_t a32,int a33,__int16 a34,char a35,char a36,xpc_object_t a37,uint64_t a38,xpc_object_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,xpc_object_t a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (*(char *)(v54 - 185) < 0) {
    operator delete(*(void **)(v54 - 208));
  }
  if (a45 < 0) {
    operator delete(__p);
  }
  if (v53 && v52 < 0) {
    operator delete(v51);
  }
  if (*(char *)(v54 - 105) < 0) {
    operator delete(*(void **)(v54 - 128));
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D597F0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Incoming session event", v2, 2u);
  }
}

void sub_100D5987C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Incoming participant change", v2, 2u);
  }
}

void sub_100D59908(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 232);
  LOBYTE(v4) = 0;
  char v5 = 0;
  sub_101132FD8(v3, a2, a3, (uint64_t)&v4);
}

void sub_100D599C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a16 && a15 < 0) {
    operator delete(__p);
  }
  if (a23 && a22 < 0) {
    operator delete(a17);
  }
  if (a30)
  {
    *(void *)(v30 - 24) = &a25;
    sub_100155494((void ***)(v30 - 24));
  }
  if (*(unsigned char *)(v30 - 32))
  {
    if (*(char *)(v30 - 33) < 0) {
      operator delete(*(void **)(v30 - 56));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D59A30(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*(char *)(*a2 + 71) < 0)
  {
    sub_10004FC84(__s1, *(void **)(v3 + 48), *(void *)(v3 + 56));
  }
  else
  {
    *(_OWORD *)__s1 = *(_OWORD *)(v3 + 48);
    uint64_t v23 = *(void *)(v3 + 64);
  }
  if (v23 >= 0) {
    uint64_t v4 = (void *)HIBYTE(v23);
  }
  else {
    uint64_t v4 = __s1[1];
  }
  char v5 = (void *)*(unsigned __int8 *)(a1 + 55);
  int v6 = (char)v5;
  if ((char)v5 < 0) {
    char v5 = *(void **)(a1 + 40);
  }
  if (v4 == v5)
  {
    uint64_t v9 = *(unsigned __int8 **)(a1 + 32);
    int v8 = (unsigned __int8 *)(a1 + 32);
    int v7 = v9;
    if (v6 >= 0) {
      xpc_object_t v10 = v8;
    }
    else {
      xpc_object_t v10 = v7;
    }
    if (v23 < 0)
    {
      BOOL v20 = __s1[0];
      BOOL v19 = memcmp(__s1[0], v10, (size_t)__s1[1]) == 0;
      goto LABEL_26;
    }
    if (!HIBYTE(v23)) {
      return 1;
    }
    uint64_t v11 = HIBYTE(v23) - 1;
    uint64_t v12 = __s1;
    do
    {
      int v14 = *(unsigned __int8 *)v12;
      uint64_t v12 = (void **)((char *)v12 + 1);
      int v13 = v14;
      int v16 = *v10++;
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v19 = v13 == v15;
    }
    while (v13 == v15 && v18);
  }
  else
  {
    BOOL v19 = 0;
  }
  if (v23 < 0)
  {
    BOOL v20 = __s1[0];
LABEL_26:
    operator delete(v20);
  }
  return v19;
}

uint64_t sub_100D59B2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)a2 + 191);
  size_t v3 = *(void *)(*(void *)a2 + 176);
  if ((v2 & 0x80u) == 0) {
    uint64_t v4 = *(unsigned __int8 *)(*(void *)a2 + 191);
  }
  else {
    uint64_t v4 = *(void *)(*(void *)a2 + 176);
  }
  uint64_t v5 = *(unsigned __int8 *)(a1 + 55);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 40);
  }
  if (v4 != v5) {
    return 0;
  }
  int v7 = (const void **)(*(void *)a2 + 168);
  xpc_object_t v10 = *(unsigned __int8 **)(a1 + 32);
  int v8 = (unsigned __int8 *)(a1 + 32);
  uint64_t v9 = v10;
  if (v6 >= 0) {
    uint64_t v11 = v8;
  }
  else {
    uint64_t v11 = v9;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v7, v11, v3) == 0;
  }
  if (!v2) {
    return 1;
  }
  uint64_t v12 = v2 - 1;
  do
  {
    int v14 = *(unsigned __int8 *)v7;
    int v7 = (const void **)((char *)v7 + 1);
    int v13 = v14;
    int v16 = *v11++;
    int v15 = v16;
    BOOL v18 = v12-- != 0;
    uint64_t result = v13 == v15;
  }
  while (v13 == v15 && v18);
  return result;
}

void sub_100D59BD4(uint64_t a1, void *a2, void *a3)
{
  long long __s1 = 0uLL;
  uint64_t v100 = 0;
  uint64_t v6 = ims::lazuli::kTransactionId;
  xpc_object_t v81 = a3;
  uint64_t v82 = ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)&v81, &object);
  memset(buf, 0, sizeof(buf));
  uint64_t v102 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v102) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object);
  uint64_t v7 = HIBYTE(v100);
  if (v100 < 0) {
    uint64_t v7 = *((void *)&__s1 + 1);
  }
  if (!v7)
  {
    uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_146;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    uint64_t v38 = "Dropping Incoming group chat created callback. Invalid key: %s";
    goto LABEL_119;
  }
  uint64_t v9 = *(char **)(a1 + 336);
  int v8 = *(char **)(a1 + 344);
  if (v9 == v8)
  {
LABEL_38:
    long long v29 = v8;
    goto LABEL_39;
  }
  xpc_object_t v10 = *(char **)(a1 + 336);
  while (1)
  {
    uint64_t v11 = *(void *)v10;
    uint64_t v12 = (std::__shared_weak_count *)*((void *)v10 + 1);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v100 >= 0) {
      uint64_t v13 = HIBYTE(v100);
    }
    else {
      uint64_t v13 = *((void *)&__s1 + 1);
    }
    uint64_t v14 = *(unsigned __int8 *)(v11 + 39);
    int v15 = (char)v14;
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *(void *)(v11 + 24);
    }
    if (v13 == v14)
    {
      BOOL v18 = *(unsigned __int8 **)(v11 + 16);
      int v16 = (unsigned __int8 *)(v11 + 16);
      BOOL v17 = v18;
      if (v15 >= 0) {
        BOOL v19 = v16;
      }
      else {
        BOOL v19 = v17;
      }
      if (v100 < 0)
      {
        BOOL v28 = memcmp((const void *)__s1, v19, *((size_t *)&__s1 + 1)) == 0;
        goto LABEL_31;
      }
      if (HIBYTE(v100))
      {
        uint64_t v20 = HIBYTE(v100) - 1;
        p_s1 = &__s1;
        do
        {
          int v23 = *(unsigned __int8 *)p_s1;
          p_s1 = (long long *)((char *)p_s1 + 1);
          int v22 = v23;
          int v25 = *v19++;
          int v24 = v25;
          BOOL v26 = v20-- != 0;
          char v27 = v26;
          BOOL v28 = v22 == v24;
        }
        while (v22 == v24 && (v27 & 1) != 0);
LABEL_31:
        if (!v12) {
          goto LABEL_33;
        }
LABEL_32:
        sub_10004D2C8(v12);
        goto LABEL_33;
      }
      BOOL v28 = 1;
      if (v12) {
        goto LABEL_32;
      }
    }
    else
    {
      BOOL v28 = 0;
      if (v12) {
        goto LABEL_32;
      }
    }
LABEL_33:
    if (v28) {
      break;
    }
    v10 += 16;
    if (v10 == v8) {
      goto LABEL_38;
    }
  }
  long long v29 = v8;
  if (v10 != v8)
  {
    long long v47 = v10 + 16;
    if (v10 + 16 != v8)
    {
      long long v29 = v10;
      while (1)
      {
        uint64_t v48 = *((void *)v10 + 2);
        long long v49 = (std::__shared_weak_count *)*((void *)v10 + 3);
        xpc_object_t v10 = v47;
        if (v49) {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v100 >= 0) {
          uint64_t v50 = HIBYTE(v100);
        }
        else {
          uint64_t v50 = *((void *)&__s1 + 1);
        }
        uint64_t v51 = *(unsigned __int8 *)(v48 + 39);
        int v52 = (char)v51;
        if ((v51 & 0x80u) != 0) {
          uint64_t v51 = *(void *)(v48 + 24);
        }
        if (v50 != v51) {
          break;
        }
        xpc_object_t v55 = *(unsigned __int8 **)(v48 + 16);
        int v53 = (unsigned __int8 *)(v48 + 16);
        uint64_t v54 = v55;
        if (v52 >= 0) {
          xpc_object_t v56 = v53;
        }
        else {
          xpc_object_t v56 = v54;
        }
        if (v100 < 0)
        {
          BOOL v64 = memcmp((const void *)__s1, v56, *((size_t *)&__s1 + 1)) == 0;
        }
        else
        {
          if (!HIBYTE(v100))
          {
            BOOL v64 = 1;
            if (!v49) {
              goto LABEL_102;
            }
LABEL_101:
            sub_10004D2C8(v49);
            goto LABEL_102;
          }
          uint64_t v57 = HIBYTE(v100) - 1;
          char v58 = &__s1;
          do
          {
            int v60 = *(unsigned __int8 *)v58;
            char v58 = (long long *)((char *)v58 + 1);
            int v59 = v60;
            int v62 = *v56++;
            int v61 = v62;
            BOOL v26 = v57-- != 0;
            char v63 = v26;
            BOOL v64 = v59 == v61;
          }
          while (v59 == v61 && (v63 & 1) != 0);
        }
        if (v49) {
          goto LABEL_101;
        }
LABEL_102:
        if (!v64)
        {
          long long v65 = *(_OWORD *)v10;
          *(void *)xpc_object_t v10 = 0;
          *((void *)v10 + 1) = 0;
          char v66 = (std::__shared_weak_count *)v29[1];
          *(_OWORD *)long long v29 = v65;
          if (v66) {
            sub_10004D2C8(v66);
          }
          v29 += 2;
        }
        long long v47 = v10 + 16;
        if (v10 + 16 == v8) {
          goto LABEL_39;
        }
      }
      BOOL v64 = 0;
      if (!v49) {
        goto LABEL_102;
      }
      goto LABEL_101;
    }
    long long v29 = v10;
  }
LABEL_39:
  uint64_t v30 = *(void **)(a1 + 344);
  if (v29 != v30)
  {
    while (v30 != v29)
    {
      uint64_t v31 = (std::__shared_weak_count *)*(v30 - 1);
      if (v31) {
        sub_10004D2C8(v31);
      }
      v30 -= 2;
    }
    *(void *)(a1 + 344) = v29;
  }
  int v32 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 16);
  if ((void *)(v8 - v9) == (void *)((char *)v29 - *(void *)(a1 + 336)))
  {
    int v33 = *(NSObject **)v32();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Bailing out (group chat creation not requested).", buf, 2u);
    }
    uint64_t v34 = *(void *)(a1 + 336);
    for (uint64_t i = *(void *)(a1 + 344); i != v34; i -= 16)
    {
      uint64_t v36 = *(std::__shared_weak_count **)(i - 8);
      if (v36) {
        sub_10004D2C8(v36);
      }
    }
    *(void *)(a1 + 344) = v34;
    goto LABEL_146;
  }
  uint64_t v39 = *(NSObject **)v32();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v40 = &__s1;
    if (v100 < 0) {
      uint64_t v40 = (long long *)__s1;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v40;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Erased ephemeral entry for transactionID : %{public}s", buf, 0xCu);
  }
  *(void *)long long buf = a3;
  *(void *)&uint8_t buf[8] = ims::lazuli::kIsSuccess;
  sub_100048BAC((uint64_t)buf, &v81);
  char v42 = xpc::dyn_cast_or_default((xpc *)&v81, 0, v41);
  xpc_release(v81);
  if ((v42 & 1) == 0)
  {
    uint64_t v67 = *(void *)(a1 + 304);
    if (SHIBYTE(v100) < 0)
    {
      sub_10004FC84(__p, (void *)__s1, *((unint64_t *)&__s1 + 1));
    }
    else
    {
      *(_OWORD *)xpc_object_t __p = __s1;
      uint64_t v98 = v100;
    }
    xpc_object_t v68 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    sub_1002B1A80(v67, __p, 0x100000005, v68);
    if (SHIBYTE(v98) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_146;
    }
    xpc_object_t v69 = &__s1;
    if (v100 < 0) {
      xpc_object_t v69 = (long long *)__s1;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v69;
    uint64_t v38 = "Failed creating group chat with transaction id: %s";
LABEL_119:
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v38, buf, 0xCu);
    goto LABEL_146;
  }
  xpc_object_t object = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v43 = ims::lazuli::kConferenceFocus;
  xpc_object_t v81 = a3;
  uint64_t v82 = ims::lazuli::kConferenceFocus;
  sub_100048BAC((uint64_t)&v81, &v89);
  memset(buf, 0, sizeof(buf));
  uint64_t v102 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v102) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v89);
  uint64_t v44 = HIBYTE(v96);
  if (v96 < 0) {
    uint64_t v44 = v95;
  }
  if (v44)
  {
    xpc_object_t v89 = 0;
    uint64_t v90 = 0;
    uint64_t v91 = 0;
    uint64_t v45 = ims::lazuli::kConversationId;
    xpc_object_t v81 = a3;
    uint64_t v82 = ims::lazuli::kConversationId;
    sub_100048BAC((uint64_t)&v81, v83);
    memset(buf, 0, sizeof(buf));
    uint64_t v102 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v102) < 0) {
      operator delete(*(void **)buf);
    }
    xpc_release(v83[0]);
    uint64_t v46 = HIBYTE(v91);
    if (v91 < 0) {
      uint64_t v46 = v90;
    }
    if (v46)
    {
      if (*a2)
      {
        v83[0] = 0;
        v83[1] = 0;
        uint64_t v84 = 0;
        sub_100D581AC((uint64_t)buf, (uint64_t)&object);
      }
      uint64_t v74 = *(void *)(a1 + 304);
      if (SHIBYTE(v100) < 0)
      {
        sub_10004FC84(v85, (void *)__s1, *((unint64_t *)&__s1 + 1));
      }
      else
      {
        *(_OWORD *)xpc_object_t v85 = __s1;
        uint64_t v86 = v100;
      }
      xpc_object_t v78 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      sub_1002B1A80(v74, v85, 0x100000005, v78);
      if (SHIBYTE(v86) < 0) {
        operator delete(v85[0]);
      }
      xpc_object_t v79 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
      {
        xpc_object_t v80 = &__s1;
        if (v100 < 0) {
          xpc_object_t v80 = (long long *)__s1;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v80;
        _os_log_error_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "Invalid chat pointer received for transaction id: %s", buf, 0xCu);
      }
    }
    else
    {
      xpc_object_t v72 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v45;
        _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Dropping Incoming group chat created callback. Invalid key: %s", buf, 0xCu);
      }
      uint64_t v73 = *(void *)(a1 + 304);
      if (SHIBYTE(v100) < 0)
      {
        sub_10004FC84(&v87, (void *)__s1, *((unint64_t *)&__s1 + 1));
      }
      else
      {
        long long v87 = __s1;
        uint64_t v88 = v100;
      }
      int v77 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      sub_1002B1A80(v73, (void **)&v87, 0x100000005, v77);
      if (SHIBYTE(v88) < 0) {
        operator delete((void *)v87);
      }
    }
    if (SHIBYTE(v91) < 0)
    {
      xpc_object_t v76 = v89;
LABEL_143:
      operator delete(v76);
    }
  }
  else
  {
    int v70 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v43;
      _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "Dropping Incoming group chat created callback. Invalid key: %s", buf, 0xCu);
    }
    uint64_t v71 = *(void *)(a1 + 304);
    if (SHIBYTE(v100) < 0)
    {
      sub_10004FC84(&__dst, (void *)__s1, *((unint64_t *)&__s1 + 1));
    }
    else
    {
      long long __dst = __s1;
      uint64_t v93 = v100;
    }
    xpc_object_t v75 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    sub_1002B1A80(v71, (void **)&__dst, 0x100000005, v75);
    if (SHIBYTE(v93) < 0)
    {
      xpc_object_t v76 = (xpc_object_t)__dst;
      goto LABEL_143;
    }
  }
  if (SHIBYTE(v96) < 0) {
    operator delete(object);
  }
LABEL_146:
  if (SHIBYTE(v100) < 0) {
    operator delete((void *)__s1);
  }
}

void sub_100D5AC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,xpc_object_t object,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,xpc_object_t a62,uint64_t a63)
{
  if (v73) {
    sub_10004D2C8(v73);
  }
  if (v72) {
    sub_10004D2C8(v72);
  }
  if (a44 < 0) {
    operator delete(__p);
  }
  if (a58 < 0) {
    operator delete(object);
  }
  if (a67 < 0) {
    operator delete(a62);
  }
  if (a72 < 0) {
    operator delete(a71);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D5AEC0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)a2 + 191);
  size_t v3 = *(void *)(*(void *)a2 + 176);
  if ((v2 & 0x80u) == 0) {
    uint64_t v4 = *(unsigned __int8 *)(*(void *)a2 + 191);
  }
  else {
    uint64_t v4 = *(void *)(*(void *)a2 + 176);
  }
  uint64_t v5 = *(unsigned __int8 *)(a1 + 55);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 40);
  }
  if (v4 != v5) {
    return 0;
  }
  uint64_t v7 = (const void **)(*(void *)a2 + 168);
  xpc_object_t v10 = *(unsigned __int8 **)(a1 + 32);
  int v8 = (unsigned __int8 *)(a1 + 32);
  uint64_t v9 = v10;
  if (v6 >= 0) {
    uint64_t v11 = v8;
  }
  else {
    uint64_t v11 = v9;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v7, v11, v3) == 0;
  }
  if (!v2) {
    return 1;
  }
  uint64_t v12 = v2 - 1;
  do
  {
    int v14 = *(unsigned __int8 *)v7;
    uint64_t v7 = (const void **)((char *)v7 + 1);
    int v13 = v14;
    int v16 = *v11++;
    int v15 = v16;
    BOOL v18 = v12-- != 0;
    uint64_t result = v13 == v15;
  }
  while (v13 == v15 && v18);
  return result;
}

void sub_100D5AF68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Incoming group chat update", buf, 2u);
  }
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  uint64_t v13 = 0;
  *(void *)int v8 = a3;
  uint64_t v9 = ims::lazuli::kConferenceFocus;
  sub_100048BAC((uint64_t)v8, object);
  uint64_t v15 = 0;
  *(void *)long long buf = 0;
  uint64_t v16 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object[0]);
  uint64_t v6 = HIBYTE(v13);
  if (v13 < 0) {
    uint64_t v6 = v12;
  }
  if (v6)
  {
    memset(&object[28], 0, 24);
    sub_100CC7114(buf, (uint64_t)&v11);
    sub_100CC786C();
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Dropping Incoming group chat update. Invalid focus", buf, 2u);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v11);
  }
}

void sub_100D5C668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (LOBYTE(STACK[0x320]) && SLOBYTE(STACK[0x31F]) < 0) {
    operator delete((void *)STACK[0x308]);
  }
  if (LOBYTE(STACK[0x468])) {
    sub_1002B26E8((uint64_t)&STACK[0x328]);
  }
  if (SLOBYTE(STACK[0x9A7]) < 0) {
    operator delete((void *)STACK[0x990]);
  }
  if (SLOBYTE(STACK[0xCF7]) < 0) {
    operator delete((void *)STACK[0xCE0]);
  }
  if (LOBYTE(STACK[0x9C8]) && SLOBYTE(STACK[0x9C7]) < 0) {
    operator delete((void *)STACK[0x9B0]);
  }
  sub_10005CD2C((uint64_t)&STACK[0x9D8], (char *)STACK[0x9E0]);
  sub_1007202B4((uint64_t)&STACK[0x9F0]);
  sub_100B8E674((uint64_t)&STACK[0xBD0]);
  sub_1002B26E8((uint64_t)&STACK[0xD10]);
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (SLOBYTE(STACK[0xCC7]) < 0) {
    operator delete((void *)STACK[0xCB0]);
  }
  if (SLOBYTE(STACK[0xCDF]) < 0) {
    operator delete((void *)STACK[0xCC8]);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D5CAF0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*(char *)(*a2 + 71) < 0)
  {
    sub_10004FC84(__s1, *(void **)(v3 + 48), *(void *)(v3 + 56));
  }
  else
  {
    *(_OWORD *)long long __s1 = *(_OWORD *)(v3 + 48);
    uint64_t v23 = *(void *)(v3 + 64);
  }
  if (v23 >= 0) {
    uint64_t v4 = (void *)HIBYTE(v23);
  }
  else {
    uint64_t v4 = __s1[1];
  }
  uint64_t v5 = (void *)*(unsigned __int8 *)(a1 + 55);
  int v6 = (char)v5;
  if ((char)v5 < 0) {
    uint64_t v5 = *(void **)(a1 + 40);
  }
  if (v4 == v5)
  {
    uint64_t v9 = *(unsigned __int8 **)(a1 + 32);
    int v8 = (unsigned __int8 *)(a1 + 32);
    uint64_t v7 = v9;
    if (v6 >= 0) {
      xpc_object_t v10 = v8;
    }
    else {
      xpc_object_t v10 = v7;
    }
    if (v23 < 0)
    {
      uint64_t v20 = __s1[0];
      BOOL v19 = memcmp(__s1[0], v10, (size_t)__s1[1]) == 0;
      goto LABEL_26;
    }
    if (!HIBYTE(v23)) {
      return 1;
    }
    uint64_t v11 = HIBYTE(v23) - 1;
    uint64_t v12 = __s1;
    do
    {
      int v14 = *(unsigned __int8 *)v12;
      uint64_t v12 = (void **)((char *)v12 + 1);
      int v13 = v14;
      int v16 = *v10++;
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v19 = v13 == v15;
    }
    while (v13 == v15 && v18);
  }
  else
  {
    BOOL v19 = 0;
  }
  if (v23 < 0)
  {
    uint64_t v20 = __s1[0];
LABEL_26:
    operator delete(v20);
  }
  return v19;
}

void sub_100D5CBEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v5 = ims::lazuli::kTransactionId;
  *(void *)&long long v50 = a3;
  *((void *)&v50 + 1) = ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)&v50, &object);
  long long __p = 0uLL;
  uint64_t v49 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__p);
  }
  xpc_release(object);
  uint64_t v6 = HIBYTE(v47);
  if (v47 < 0) {
    uint64_t v6 = v46;
  }
  if (!v6)
  {
    BOOL v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v5;
    uint64_t v20 = "Dropping Incoming participant added callback. Invalid key: %s";
    goto LABEL_69;
  }
  *(void *)&long long __p = a3;
  *((void *)&__p + 1) = ims::lazuli::kIsSuccess;
  sub_100048BAC((uint64_t)&__p, &v50);
  int v8 = xpc::dyn_cast_or_default((xpc *)&v50, 0, v7);
  xpc_release((xpc_object_t)v50);
  uint64_t v9 = *(void **)(a1 + 304);
  xpc_object_t v10 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  int v13 = (void *)*v9;
  uint64_t v11 = v9 + 1;
  uint64_t v12 = v13;
  if (v13 == v11)
  {
LABEL_15:
    BOOL v17 = *v10;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = &v45;
      if (v47 < 0) {
        uint64_t v34 = v45;
      }
      LODWORD(__p) = 136446210;
      *(void *)((char *)&__p + 4) = v34;
      BOOL v28 = "No operation holds transaction: %{public}s";
LABEL_46:
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&__p, 0xCu);
    }
LABEL_16:
    BOOL v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    BOOL v19 = &v45;
    if (v47 < 0) {
      BOOL v19 = v45;
    }
    LODWORD(__p) = 136446210;
    *(void *)((char *)&__p + 4) = v19;
    uint64_t v20 = "Dropping Incoming participant added callback. Invalid operation for: %{public}s";
LABEL_69:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&__p, 0xCu);
    goto LABEL_21;
  }
  while (1)
  {
    uint64_t v14 = v12[7];
    if (v14)
    {
      if ((*(unsigned int (**)(uint64_t, void **))(*(void *)v14 + 24))(v14, &v45)) {
        break;
      }
    }
    int v15 = (void *)v12[1];
    if (v15)
    {
      do
      {
        int v16 = v15;
        int v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        int v16 = (void *)v12[2];
        BOOL v33 = *v16 == (void)v12;
        uint64_t v12 = v16;
      }
      while (!v33);
    }
    uint64_t v12 = v16;
    if (v16 == v11) {
      goto LABEL_15;
    }
  }
  unint64_t v21 = (const void *)v12[7];
  if (!v21
  {
    BOOL v17 = *v10;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      char v27 = &v45;
      if (v47 < 0) {
        char v27 = v45;
      }
      LODWORD(__p) = 136446210;
      *(void *)((char *)&__p + 4) = v27;
      BOOL v28 = "Failed to convert to <T> for ID: [%{public}s]";
      goto LABEL_46;
    }
    goto LABEL_16;
  }
  uint64_t v23 = v22;
  int v24 = (std::__shared_weak_count *)v12[8];
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = (uint64_t)(v22 + 2);
  uint64_t v26 = (uint64_t)(v22 + 2);
  if (v8) {
    sub_1002B0A74(v26, (uint64_t)&v45);
  }
  else {
    sub_1002B0B38(v26, (uint64_t)&v45);
  }
  uint64_t v29 = v23[8];
  uint64_t v30 = v23[9];
  if (v29 == v30)
  {
    BOOL v32 = 1;
  }
  else
  {
    uint64_t v31 = v29 + 64;
    do
    {
      BOOL v32 = *(unsigned char *)(v31 - 4) != 0;
      if (*(unsigned char *)(v31 - 4)) {
        BOOL v33 = v31 == v30;
      }
      else {
        BOOL v33 = 1;
      }
      v31 += 64;
    }
    while (!v33);
  }
  xpc_object_t v35 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 16);
  if (v32)
  {
    uint64_t v36 = *(NSObject **)v35();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I All responses recieved", (uint8_t *)&__p, 2u);
    }
    uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002B0BFC(v25, &__p);
      uint64_t v38 = v49 >= 0 ? &__p : (long long *)__p;
      LODWORD(v50) = 136315138;
      *(void *)((char *)&v50 + 4) = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %{publics}s", (uint8_t *)&v50, 0xCu);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)__p);
      }
    }
    uint64_t v39 = *(void *)(a1 + 304);
    uint64_t v40 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    sub_1002B1D90(v39, (uint64_t *)&v45, 0, v40);
  }
  else
  {
    BOOL v41 = *(NSObject **)v35();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I More responses pending", (uint8_t *)&__p, 2u);
    }
    char v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002B0BFC((uint64_t)(v23 + 2), &__p);
      uint64_t v43 = v49 >= 0 ? &__p : (long long *)__p;
      LODWORD(v50) = 136315138;
      *(void *)((char *)&v50 + 4) = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %{publics}s", (uint8_t *)&v50, 0xCu);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)__p);
      }
    }
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
LABEL_21:
  if (SHIBYTE(v47) < 0) {
    operator delete(v45);
  }
}

void sub_100D5D250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,xpc_object_t object)
{
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5D2FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v5 = ims::lazuli::kTransactionId;
  *(void *)&long long v50 = a3;
  *((void *)&v50 + 1) = ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)&v50, &object);
  long long __p = 0uLL;
  uint64_t v49 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__p);
  }
  xpc_release(object);
  uint64_t v6 = HIBYTE(v47);
  if (v47 < 0) {
    uint64_t v6 = v46;
  }
  if (!v6)
  {
    BOOL v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v5;
    uint64_t v20 = "Dropping incoming participant removed callback. Invalid key: %s";
    goto LABEL_69;
  }
  *(void *)&long long __p = a3;
  *((void *)&__p + 1) = ims::lazuli::kIsSuccess;
  sub_100048BAC((uint64_t)&__p, &v50);
  int v8 = xpc::dyn_cast_or_default((xpc *)&v50, 0, v7);
  xpc_release((xpc_object_t)v50);
  uint64_t v9 = *(void **)(a1 + 304);
  xpc_object_t v10 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  int v13 = (void *)*v9;
  uint64_t v11 = v9 + 1;
  uint64_t v12 = v13;
  if (v13 == v11)
  {
LABEL_15:
    BOOL v17 = *v10;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = &v45;
      if (v47 < 0) {
        uint64_t v34 = v45;
      }
      LODWORD(__p) = 136446210;
      *(void *)((char *)&__p + 4) = v34;
      BOOL v28 = "No operation holds transaction: %{public}s";
LABEL_46:
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&__p, 0xCu);
    }
LABEL_16:
    BOOL v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    BOOL v19 = &v45;
    if (v47 < 0) {
      BOOL v19 = v45;
    }
    LODWORD(__p) = 136446210;
    *(void *)((char *)&__p + 4) = v19;
    uint64_t v20 = "Dropping incoming participant removed callback. Invalid operation for: %{public}s";
LABEL_69:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&__p, 0xCu);
    goto LABEL_21;
  }
  while (1)
  {
    uint64_t v14 = v12[7];
    if (v14)
    {
      if ((*(unsigned int (**)(uint64_t, void **))(*(void *)v14 + 24))(v14, &v45)) {
        break;
      }
    }
    int v15 = (void *)v12[1];
    if (v15)
    {
      do
      {
        int v16 = v15;
        int v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        int v16 = (void *)v12[2];
        BOOL v33 = *v16 == (void)v12;
        uint64_t v12 = v16;
      }
      while (!v33);
    }
    uint64_t v12 = v16;
    if (v16 == v11) {
      goto LABEL_15;
    }
  }
  unint64_t v21 = (const void *)v12[7];
  if (!v21
  {
    BOOL v17 = *v10;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      char v27 = &v45;
      if (v47 < 0) {
        char v27 = v45;
      }
      LODWORD(__p) = 136446210;
      *(void *)((char *)&__p + 4) = v27;
      BOOL v28 = "Failed to convert to <T> for ID: [%{public}s]";
      goto LABEL_46;
    }
    goto LABEL_16;
  }
  uint64_t v23 = v22;
  int v24 = (std::__shared_weak_count *)v12[8];
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = (uint64_t)(v22 + 2);
  uint64_t v26 = (uint64_t)(v22 + 2);
  if (v8) {
    sub_1002B0A74(v26, (uint64_t)&v45);
  }
  else {
    sub_1002B0B38(v26, (uint64_t)&v45);
  }
  uint64_t v29 = v23[8];
  uint64_t v30 = v23[9];
  if (v29 == v30)
  {
    BOOL v32 = 1;
  }
  else
  {
    uint64_t v31 = v29 + 64;
    do
    {
      BOOL v32 = *(unsigned char *)(v31 - 4) != 0;
      if (*(unsigned char *)(v31 - 4)) {
        BOOL v33 = v31 == v30;
      }
      else {
        BOOL v33 = 1;
      }
      v31 += 64;
    }
    while (!v33);
  }
  xpc_object_t v35 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 16);
  if (v32)
  {
    uint64_t v36 = *(NSObject **)v35();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I All responses recieved", (uint8_t *)&__p, 2u);
    }
    uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002B0BFC(v25, &__p);
      uint64_t v38 = v49 >= 0 ? &__p : (long long *)__p;
      LODWORD(v50) = 136315138;
      *(void *)((char *)&v50 + 4) = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %{publics}s", (uint8_t *)&v50, 0xCu);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)__p);
      }
    }
    uint64_t v39 = *(void *)(a1 + 304);
    uint64_t v40 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    sub_1002B1D90(v39, (uint64_t *)&v45, 0, v40);
  }
  else
  {
    BOOL v41 = *(NSObject **)v35();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I More responses pending", (uint8_t *)&__p, 2u);
    }
    char v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      sub_1002B0BFC((uint64_t)(v23 + 2), &__p);
      uint64_t v43 = v49 >= 0 ? &__p : (long long *)__p;
      LODWORD(v50) = 136315138;
      *(void *)((char *)&v50 + 4) = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %{publics}s", (uint8_t *)&v50, 0xCu);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)__p);
      }
    }
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
LABEL_21:
  if (SHIBYTE(v47) < 0) {
    operator delete(v45);
  }
}

void sub_100D5D960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,xpc_object_t object)
{
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5DA0C(uint64_t a1, uint64_t a2, void *a3)
{
  long long v40 = 0uLL;
  uint64_t v41 = 0;
  uint64_t v5 = ims::lazuli::kTransactionId;
  v38[0] = a3;
  v38[1] = (xpc_object_t)ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)v38, &object);
  long long buf = 0uLL;
  uint64_t v43 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v43) < 0) {
    operator delete((void *)buf);
  }
  xpc_release(object);
  if (SHIBYTE(v41) < 0)
  {
    if (*((void *)&v40 + 1))
    {
      uint64_t v7 = *(void *)(a1 + 304);
      sub_10004FC84(__p, (void *)v40, *((unint64_t *)&v40 + 1));
      uint64_t v6 = (uint64_t *)(a1 + 304);
LABEL_8:
      int v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      uint64_t v9 = sub_100046F68(v7, __p);
      xpc_object_t v10 = v9;
      if ((void **)(v7 + 8) == v9)
      {
        int v16 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = __p;
          if (v37 < 0) {
            uint64_t v29 = (void **)__p[0];
          }
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v29;
          BOOL v18 = "Unable to get operation with ID: [%{public}s]";
          goto LABEL_54;
        }
      }
      else
      {
        uint64_t v11 = v9[7];
        if (v11)
        {
          if (v12)
          {
            int v13 = v12;
            uint64_t v14 = (std::__shared_weak_count *)v10[8];
            if (v14) {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
            }
LABEL_21:
            if (SHIBYTE(v37) < 0)
            {
              operator delete(__p[0]);
              if (v13) {
                goto LABEL_34;
              }
            }
            else if (v13)
            {
              goto LABEL_34;
            }
            BOOL v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v20 = &v40;
              if (v41 < 0) {
                uint64_t v20 = (long long *)v40;
              }
              LODWORD(buf) = 136446210;
              *(void *)((char *)&buf + 4) = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Failed to retrieve leave group chat request from operation store for transactionID: %{public}s", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v21 = *v6;
            if (SHIBYTE(v41) < 0)
            {
              sub_10004FC84(__dst, (void *)v40, *((unint64_t *)&v40 + 1));
            }
            else
            {
              *(_OWORD *)long long __dst = v40;
              uint64_t v35 = v41;
            }
            int v22 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
            sub_1002B1A80(v21, __dst, 0x100000005, v22);
            if (SHIBYTE(v35) < 0) {
              operator delete(__dst[0]);
            }
LABEL_34:
            *(void *)&long long buf = a3;
            *((void *)&buf + 1) = ims::lazuli::kIsSuccess;
            sub_100048BAC((uint64_t)&buf, v38);
            char v24 = xpc::dyn_cast_or_default((xpc *)v38, 0, v23);
            xpc_release(v38[0]);
            uint64_t v25 = *v6;
            if (v24)
            {
              if (SHIBYTE(v41) < 0)
              {
                sub_10004FC84(&v30, (void *)v40, *((unint64_t *)&v40 + 1));
              }
              else
              {
                long long v30 = v40;
                uint64_t v31 = v41;
              }
              uint64_t v26 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
              sub_1002B1A80(v25, (void **)&v30, 0, v26);
              if (SHIBYTE(v31) < 0)
              {
                char v27 = (void **)&v30;
LABEL_45:
                operator delete(*v27);
              }
            }
            else
            {
              if (SHIBYTE(v41) < 0)
              {
                sub_10004FC84(&v32, (void *)v40, *((unint64_t *)&v40 + 1));
              }
              else
              {
                long long v32 = v40;
                uint64_t v33 = v41;
              }
              BOOL v28 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
              sub_1002B1A80(v25, (void **)&v32, 0x100000005, v28);
              if (SHIBYTE(v33) < 0)
              {
                char v27 = (void **)&v32;
                goto LABEL_45;
              }
            }
            if (v14) {
              sub_10004D2C8(v14);
            }
            goto LABEL_48;
          }
        }
        int v16 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          BOOL v17 = __p;
          if (v37 < 0) {
            BOOL v17 = (void **)__p[0];
          }
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v17;
          BOOL v18 = "Failed to convert to <T> for ID: [%{public}s]";
LABEL_54:
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v18, (uint8_t *)&buf, 0xCu);
        }
      }
      int v13 = 0;
      uint64_t v14 = 0;
      goto LABEL_21;
    }
  }
  else if (HIBYTE(v41))
  {
    uint64_t v6 = (uint64_t *)(a1 + 304);
    uint64_t v7 = *(void *)(a1 + 304);
    *(_OWORD *)long long __p = v40;
    uint64_t v37 = v41;
    goto LABEL_8;
  }
  int v15 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Dropping Incoming leave group chat callback. Invalid key: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_48:
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
}

void sub_100D5DF70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,xpc_object_t object,uint64_t a38,xpc_object_t a39)
{
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (*(char *)(v40 - 113) < 0) {
    operator delete(*(void **)(v40 - 136));
  }
  _Unwind_Resume(exception_object);
}

void sub_100D5E05C(uint64_t a1, void **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 328);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 320);
      if (v6)
      {
        uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Forwarding capability response", buf, 2u);
        }
        uint64_t v8 = *(unsigned int *)(a1 + 88);
        uint64_t v9 = *a2;
        xpc_object_t object = v9;
        if (v9) {
          xpc_retain(v9);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(*(void *)v6 + 80))(v6, v8, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  xpc_object_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Dropping capability response. Controller has disappeared", v11, 2u);
    if (!v5) {
      return;
    }
LABEL_14:
    sub_10004D2C8(v5);
    return;
  }
  if (v5) {
    goto LABEL_14;
  }
}

void sub_100D5E200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

unint64_t sub_100D5E23C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  if (v4 == v5)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v7 = "#I Creating empty group chats is not supported";
      goto LABEL_13;
    }
LABEL_14:
    uint64_t v11 = &_mh_execute_header;
    uint64_t v12 = 4;
    return v12 | (unint64_t)v11;
  }
  if ((unint64_t)(v5 - v4) <= 0x3F)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v7 = "#I Creating group chats < 2 is not supported";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
      goto LABEL_14;
    }
    goto LABEL_14;
  }
  if (*(unsigned char *)(a2 + 168))
  {
    uint64_t v10 = *(unsigned __int8 *)(a2 + 119);
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *(void *)(a2 + 104);
    }
    if (v10)
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v7 = "#I Cannot create group chat with focus";
        goto LABEL_13;
      }
      goto LABEL_14;
    }
  }
  if (!*(void *)(a1 + 168))
  {
    int v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)long long buf = 0;
    BOOL v17 = "Invalid sip stack reference";
LABEL_29:
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, buf, 2u);
    goto LABEL_14;
  }
  if (!*(void *)(a1 + 184))
  {
    int v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)long long buf = 0;
    BOOL v17 = "Invalid IMS client reference";
    goto LABEL_29;
  }
  if ((*(char *)(a1 + 143) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 143)) {
      goto LABEL_20;
    }
    goto LABEL_27;
  }
  if (!*(void *)(a1 + 128))
  {
LABEL_27:
    int v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    *(_WORD *)long long buf = 0;
    BOOL v17 = "Conference URI is invalid";
    goto LABEL_29;
  }
LABEL_20:
  xpc_object_t v81 = 0;
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v15 = v14;
  if (v14)
  {
    xpc_object_t v81 = v14;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v81 = v15;
    if (!v15)
    {
      xpc_object_t v18 = xpc_null_create();
      xpc_object_t v15 = 0;
      goto LABEL_35;
    }
  }
  if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v18 = xpc_null_create();
LABEL_35:
    xpc_object_t v81 = v18;
    goto LABEL_36;
  }
  xpc_retain(v15);
LABEL_36:
  xpc_release(v15);
  uint64_t v80 = 0;
  *(_OWORD *)xpc_object_t v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  *(_OWORD *)xpc_object_t v75 = 0u;
  uint64_t v19 = *(void *)(a2 + 24);
  uint64_t v20 = *(void *)(a2 + 32);
  if (v19 != v20)
  {
    unint64_t v21 = 0;
    do
    {
      if (v21 >= *((void *)&v77 + 1))
      {
        unint64_t v21 = sub_100048008((uint64_t *)&v76 + 1, (long long *)v19);
      }
      else
      {
        if (*(char *)(v19 + 23) < 0)
        {
          sub_10004FC84((unsigned char *)v21, *(void **)v19, *(void *)(v19 + 8));
        }
        else
        {
          long long v22 = *(_OWORD *)v19;
          *(void *)(v21 + 16) = *(void *)(v19 + 16);
          *(_OWORD *)unint64_t v21 = v22;
        }
        v21 += 24;
      }
      *(void *)&long long v77 = v21;
      v19 += 32;
    }
    while (v19 != v20);
  }
  long long v73 = 0uLL;
  uint64_t v74 = 0;
  sub_100561B00((uint64_t)&v73);
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v72 = 0;
  if (SHIBYTE(v74) < 0)
  {
    sub_10004FC84(__dst, (void *)v73, *((unint64_t *)&v73 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = v73;
    uint64_t v72 = v74;
  }
  if (v72 >= 0) {
    BOOL v23 = __dst;
  }
  else {
    BOOL v23 = (void **)__dst[0];
  }
  xpc_object_t v69 = xpc_string_create((const char *)v23);
  if (!v69) {
    xpc_object_t v69 = xpc_null_create();
  }
  *(void *)long long buf = &v81;
  *(void *)&uint8_t buf[8] = ims::lazuli::kContributionId;
  sub_100035E70((uint64_t)buf, &v69, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v69);
  xpc_object_t v69 = 0;
  if (v74 >= 0) {
    char v24 = (const char *)&v73;
  }
  else {
    char v24 = (const char *)v73;
  }
  xpc_object_t v67 = xpc_string_create(v24);
  if (!v67) {
    xpc_object_t v67 = xpc_null_create();
  }
  *(void *)long long buf = &v81;
  *(void *)&uint8_t buf[8] = ims::lazuli::kConversationId;
  sub_100035E70((uint64_t)buf, &v67, &v68);
  xpc_release(v68);
  xpc_object_t v68 = 0;
  xpc_release(v67);
  xpc_object_t v67 = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    if (*(char *)(a2 + 199) < 0)
    {
      sub_10004FC84(buf, *(void **)(a2 + 176), *(void *)(a2 + 184));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(a2 + 176);
      *(void *)&uint8_t buf[16] = *(void *)(a2 + 192);
    }
  }
  else
  {
    sub_100058DB0(buf, "");
  }
  if (buf[23] >= 0) {
    uint64_t v25 = buf;
  }
  else {
    uint64_t v25 = *(const char **)buf;
  }
  xpc_object_t v65 = xpc_string_create(v25);
  if (!v65) {
    xpc_object_t v65 = xpc_null_create();
  }
  *(void *)xpc_object_t v85 = &v81;
  *(void *)&v85[8] = ims::lazuli::kSubject;
  sub_100035E70((uint64_t)v85, &v65, &v66);
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_release(v65);
  xpc_object_t v65 = 0;
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  sub_1007203A0((uint64_t)v75, (uint64_t)buf);
  if (buf[23] >= 0) {
    uint64_t v26 = buf;
  }
  else {
    uint64_t v26 = *(const char **)buf;
  }
  xpc_object_t v63 = xpc_string_create(v26);
  if (!v63) {
    xpc_object_t v63 = xpc_null_create();
  }
  *(void *)xpc_object_t v85 = &v81;
  *(void *)&v85[8] = ims::lazuli::kResourceXml;
  sub_100035E70((uint64_t)v85, &v63, &v64);
  xpc_release(v64);
  xpc_object_t v64 = 0;
  xpc_release(v63);
  xpc_object_t v63 = 0;
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (*(char *)(a3 + 23) >= 0) {
    char v27 = (const char *)a3;
  }
  else {
    char v27 = *(const char **)a3;
  }
  xpc_object_t v61 = xpc_string_create(v27);
  if (!v61) {
    xpc_object_t v61 = xpc_null_create();
  }
  *(void *)long long buf = &v81;
  *(void *)&uint8_t buf[8] = ims::lazuli::kTransactionId;
  sub_100035E70((uint64_t)buf, &v61, &v62);
  xpc_release(v62);
  xpc_object_t v62 = 0;
  xpc_release(v61);
  BOOL v28 = (const char *)(a1 + 120);
  xpc_object_t v61 = 0;
  if (*(char *)(a1 + 143) < 0) {
    BOOL v28 = *(const char **)v28;
  }
  xpc_object_t v59 = xpc_string_create(v28);
  if (!v59) {
    xpc_object_t v59 = xpc_null_create();
  }
  *(void *)long long buf = &v81;
  *(void *)&uint8_t buf[8] = ims::lazuli::kRemoteUri;
  sub_100035E70((uint64_t)buf, &v59, &v60);
  xpc_release(v60);
  xpc_object_t v60 = 0;
  xpc_release(v59);
  xpc_object_t v59 = 0;
  uint64_t v29 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    sub_100120074(&v81, buf);
    long long v30 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)xpc_object_t v85 = 136380675;
    *(void *)&v85[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Sending request for group chat creation: [%{private}s]", v85, 0xCu);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  *(_OWORD *)xpc_object_t v85 = 0uLL;
  uint64_t v31 = *(void *)(a1 + 168);
  long long v32 = *(std::__shared_weak_count **)(a1 + 192);
  uint64_t v57 = *(void *)(a1 + 184);
  char v58 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v56 = v81;
  if (v81) {
    xpc_retain(v81);
  }
  else {
    xpc_object_t v56 = xpc_null_create();
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t *, xpc_object_t *))(*(void *)v31 + 136))(v85, v31, &v57, &v56);
  xpc_release(v56);
  xpc_object_t v56 = 0;
  if (v58) {
    sub_10004D2C8(v58);
  }
  long long v33 = *(_OWORD *)v85;
  uint64_t v34 = operator new(0x40uLL);
  uint64_t v35 = v34;
  v34[1] = 0;
  xpc_object_t v34[2] = 0;
  *uint64_t v34 = off_101A54AC0;
  uint64_t v36 = v34 + 3;
  *(_OWORD *)long long buf = v33;
  if (*((void *)&v33 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v33 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  sub_1002B018C(v34 + 3, buf, (long long *)a3);
  if (*((void *)&v33 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
  }
  uint64_t v38 = *(char **)(a1 + 344);
  unint64_t v37 = *(void *)(a1 + 352);
  if ((unint64_t)v38 >= v37)
  {
    uint64_t v40 = *(char **)(a1 + 336);
    uint64_t v41 = (v38 - v40) >> 4;
    unint64_t v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 60) {
      sub_100D65248();
    }
    if ((uint64_t)(v37 - (void)v40) >> 3 > v42) {
      unint64_t v42 = (uint64_t)(v37 - (void)v40) >> 3;
    }
    if (v37 - (unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v43 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v43 = v42;
    }
    uint64_t v84 = a1 + 352;
    if (v43 >> 60) {
      sub_10006A7CC();
    }
    uint64_t v44 = (char *)operator new(16 * v43);
    uint64_t v45 = &v44[16 * v41];
    uint64_t v46 = &v44[16 * v43];
    *(void *)uint64_t v45 = v36;
    *((void *)v45 + 1) = v35;
    uint64_t v39 = v45 + 16;
    *(void *)&uint8_t buf[16] = v45 + 16;
    long long v83 = v46;
    if (v38 == v40)
    {
      int64x2_t v48 = vdupq_n_s64((unint64_t)v38);
    }
    else
    {
      do
      {
        long long v47 = *((_OWORD *)v38 - 1);
        v38 -= 16;
        *((_OWORD *)v45 - 1) = v47;
        v45 -= 16;
        *(void *)uint64_t v38 = 0;
        *((void *)v38 + 1) = 0;
      }
      while (v38 != v40);
      int64x2_t v48 = *(int64x2_t *)(a1 + 336);
      unint64_t v37 = *(void *)(a1 + 352);
      uint64_t v39 = *(void **)&buf[16];
      uint64_t v46 = v83;
    }
    *(void *)(a1 + 336) = v45;
    *(void *)(a1 + 344) = v39;
    *(int64x2_t *)&uint8_t buf[8] = v48;
    *(void *)(a1 + 352) = v46;
    long long v83 = (char *)v37;
    *(void *)long long buf = v48.i64[0];
    sub_10019E528((uint64_t)buf);
  }
  else
  {
    *(void *)uint64_t v38 = v36;
    *((void *)v38 + 1) = v35;
    uint64_t v39 = v38 + 16;
  }
  *(void *)(a1 + 344) = v39;
  int v49 = *(_DWORD *)(a1 + 88);
  long long v50 = (std::__shared_weak_count *)operator new(0x168uLL);
  v50->__shared_owners_ = 0;
  v50->__shared_weak_owners_ = 0;
  v50->__vftable = (std::__shared_weak_count_vtbl *)off_101A54B10;
  sub_1002B2188((uint64_t)buf, a2);
  LODWORD(v50[1].__shared_owners_) = v49;
  v50[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019B3B68;
  sub_1002B2188((uint64_t)&v50[1].__shared_weak_owners_, (uint64_t)buf);
  sub_1002B26E8((uint64_t)buf);
  uint64_t v51 = *(uint64_t ***)(a1 + 304);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v55 = *(void *)(a3 + 16);
  }
  int v52 = v50 + 1;
  int v53 = v50;
  atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_1002B19D0(v51, (long long *)__p, &v52);
  if (v53) {
    sub_10004D2C8(v53);
  }
  if (SHIBYTE(v55) < 0) {
    operator delete(__p[0]);
  }
  sub_10004D2C8(v50);
  if (*(void *)&v85[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v85[8]);
  }
  if (SHIBYTE(v72) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v73);
  }
  if (SBYTE7(v79) < 0) {
    operator delete(v78[0]);
  }
  *(void *)long long buf = (char *)&v76 + 8;
  sub_100047F64((void ***)buf);
  if (SBYTE7(v76) < 0) {
    operator delete(v75[0]);
  }
  xpc_release(v81);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  return v12 | (unint64_t)v11;
}

void sub_100D5ED28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,xpc_object_t object,char a56)
{
  sub_10004D2C8(v56);
  if (*(void *)(v57 - 120)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v57 - 120));
  }
  if (a37 < 0) {
    operator delete(__p);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  sub_100D5EECC((uint64_t)&a44);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100D5EECC(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v3 = (void **)(a1 + 24);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100D5EF28()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D5F444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,std::__shared_weak_count *a32,char a33)
{
  sub_10004D2C8(v33);
  if (a32) {
    sub_10004D2C8(a32);
  }
  _Unwind_Resume(a1);
}

void sub_100D5F584()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D5FAA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,std::__shared_weak_count *a32,char a33)
{
  sub_10004D2C8(v33);
  if (a32) {
    sub_10004D2C8(a32);
  }
  _Unwind_Resume(a1);
}

void sub_100D5FBE0()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D5FFAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27,uint64_t a28,uint64_t a29)
{
  sub_10004D2C8(v29);
  long long v32 = *(std::__shared_weak_count **)(v30 - 72);
  if (v32) {
    sub_10004D2C8(v32);
  }
  _Unwind_Resume(a1);
}

void sub_100D600A8()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D60370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,xpc_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  char v24 = *(std::__shared_weak_count **)(v22 - 40);
  if (v24) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(a1);
}

void sub_100D60418()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D604B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D604E0()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D605A8()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60680()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60748()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D607E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60810()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D608A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D608D8()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D609A0()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60A68()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60B30()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D60BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60BFC()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D60C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60CC8()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D60D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60DA4()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D542A0();
}

void sub_100D60E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60E70()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D60F38()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D60FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D61000()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100D54AA0();
}

void sub_100D61098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D610C8(uint64_t a1)
{
  sub_100456034(a1 + 152);
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = (void **)(a1 + 64);
    sub_100047F64(&v3);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100D61154(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 240))
  {
    uint64_t v3 = (void **)(a1 + 216);
    sub_100155410(&v3);
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  return sub_10045468C(a1);
}

void sub_100D611DC(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  *(_OWORD *)uint64_t v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  sub_100BEC024(a2, (std::string *)v25);
  lpsrc = 0;
  char v24 = 0;
  uint64_t v6 = *(void *)(a1 + 232);
  if (SHIBYTE(v26[0]) < 0)
  {
    sub_10004FC84(__p, v25[0], (unint64_t)v25[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v25;
    *(void **)&__p[16] = v26[0];
  }
  sub_10112F6AC(v6, (void **)__p, &lpsrc);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (!lpsrc)
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_45;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v11;
    uint64_t v12 = "Failed to find One2One transaction for: %s";
    int v13 = v10;
    goto LABEL_44;
  }
  if ((*(unsigned int (**)(void *))(*(void *)lpsrc + 16))(lpsrc) == 3)
  {
    if (lpsrc)
    {
      if (v7)
      {
        uint64_t v8 = (uint64_t)v7;
        uint64_t v9 = v24;
        if (v24)
        {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        bzero(__p, 0x2F8uLL);
        *(_DWORD *)long long __p = -1;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        uint64_t v46 = 0;
        *(_OWORD *)&__p[8] = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        char v38 = 0;
        *(_OWORD *)uint64_t v39 = 0u;
        memset(v40, 0, sizeof(v40));
        sub_100BEBEBC(v8, (std::string *)buf);
        if (SHIBYTE(v40[3]) < 0) {
          operator delete(v40[1]);
        }
        *(_OWORD *)&v40[1] = *(_OWORD *)buf;
        v40[3] = v34[0];
        *(_DWORD *)long long __p = *(_DWORD *)(v8 + 56);
        *(_OWORD *)uint64_t v31 = 0u;
        long long v32 = 0u;
        *(_OWORD *)uint64_t v29 = 0u;
        long long v30 = 0u;
        memset(__str, 0, sizeof(__str));
        sub_100CC71C0();
      }
    }
    xpc_object_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = v25;
      if (SHIBYTE(v26[0]) < 0) {
        uint64_t v19 = (void **)v25[0];
      }
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v19;
      uint64_t v12 = "Failed to convert message to One2One transaction: %s";
LABEL_43:
      int v13 = v18;
LABEL_44:
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, __p, 0xCu);
    }
  }
  else
  {
    if ((*(unsigned int (**)(void *))(*(void *)lpsrc + 16))(lpsrc) != 4)
    {
      xpc_object_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_45;
      }
      unsigned int v20 = (*(uint64_t (**)(void *))(*(void *)lpsrc + 16))(lpsrc) - 1;
      if (v20 > 4) {
        unint64_t v21 = "kInvalid";
      }
      else {
        unint64_t v21 = off_101A54C90[v20];
      }
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v21;
      uint64_t v12 = "Unhandled transaction: %s";
      goto LABEL_43;
    }
    if (lpsrc)
    {
      if (v14)
      {
        xpc_object_t v15 = v14;
        int v16 = v24;
        if (v24)
        {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        bzero(__p, 0x2F8uLL);
        *(_DWORD *)long long __p = -1;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        uint64_t v46 = 0;
        *(_OWORD *)&__p[8] = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        char v38 = 0;
        *(_OWORD *)uint64_t v39 = 0u;
        memset(v40, 0, sizeof(v40));
        if (v15[31] < 0)
        {
          sub_10004FC84(buf, *((void **)v15 + 1), *((void *)v15 + 2));
          if (SHIBYTE(v40[3]) < 0) {
            operator delete(v40[1]);
          }
        }
        else
        {
          long long v17 = *(_OWORD *)(v15 + 8);
          v34[0] = *((void **)v15 + 3);
          *(_OWORD *)long long buf = v17;
        }
        *(_OWORD *)&v40[1] = *(_OWORD *)buf;
        v40[3] = v34[0];
        *(_DWORD *)long long __p = *((_DWORD *)v15 + 14);
        sub_100CC71C0();
      }
    }
    xpc_object_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = v25;
      if (SHIBYTE(v26[0]) < 0) {
        uint64_t v22 = (void **)v25[0];
      }
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v22;
      uint64_t v12 = "Failed to convert message to Group transaction: %s";
      goto LABEL_43;
    }
  }
LABEL_45:
  *a3 = 0;
  a3[760] = 0;
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[1]);
  }
  if (SHIBYTE(v26[0]) < 0) {
    operator delete(v25[0]);
  }
}

void sub_100D62D90(_Unwind_Exception *a1, uint64_t a2, void *__p, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  STACK[0x418] = v8;
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_10016FEBC((uint64_t)va1);
  sub_100D610C8((uint64_t)&STACK[0x340]);
  if (v7)
  {
    sub_10004D2C8(v7);
    sub_10004D2C8(v7);
  }
  if (a7) {
    sub_10004D2C8(a7);
  }
  sub_1001085D8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100D63184(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_10112F9D4(*(void *)(a1 + 232), (uint64_t *)&v3);
  *(_OWORD *)a2 = v3;
  *(void *)(a2 + 16) = v4;
  uint64_t v4 = 0;
  long long v3 = 0uLL;
  *(unsigned char *)(a2 + 24) = 1;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

unint64_t sub_100D631E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a3 + 64) == *(void *)(a3 + 72))
  {
    long long v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      long long v43 = "#I No message IDs to report";
LABEL_68:
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v43, buf, 2u);
    }
  }
  else
  {
    uint64_t v6 = *(unsigned __int8 *)(a3 + 31);
    if ((v6 & 0x80u) != 0) {
      uint64_t v6 = *(void *)(a3 + 16);
    }
    if (v6)
    {
      if (*(void *)(a1 + 168))
      {
        if (*(void *)(a1 + 184))
        {
          if (*(void *)(a1 + 200))
          {
            xpc_object_t v85 = (const std::string *)(a3 + 128);
            xpc_object_t v112 = 0;
            xpc_object_t v113 = 0;
            xpc_object_t v114 = 0;
            if (*(unsigned char *)(a3 + 152))
            {
              uint64_t v8 = *(unsigned __int8 *)(a3 + 151);
              if ((v8 & 0x80u) == 0) {
                uint64_t v9 = (char *)(a3 + 128);
              }
              else {
                uint64_t v9 = *(char **)(a3 + 128);
              }
              if ((v8 & 0x80u) != 0) {
                uint64_t v8 = *(void *)(a3 + 136);
              }
              if (v8)
              {
                uint64_t v10 = 0;
                uint64_t v11 = &v9[v8];
                do
                {
                  char v12 = *v9;
                  if (v10 >= v114)
                  {
                    unint64_t v14 = (unint64_t)v112;
                    uint64_t v15 = v10 - v112;
                    uint64_t v16 = v10 - v112 + 1;
                    if (v16 < 0) {
                      sub_10006A748();
                    }
                    unint64_t v17 = v114 - v112;
                    if (2 * (v114 - v112) > (unint64_t)v16) {
                      uint64_t v16 = 2 * v17;
                    }
                    if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
                      size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      size_t v18 = v16;
                    }
                    if (v18) {
                      uint64_t v19 = (char *)operator new(v18);
                    }
                    else {
                      uint64_t v19 = 0;
                    }
                    unsigned int v20 = &v19[v15];
                    unint64_t v21 = &v19[v15];
                    *unint64_t v21 = v12;
                    uint64_t v13 = v21 + 1;
                    if (v10 != (char *)v14)
                    {
                      uint64_t v22 = &v10[~v14];
                      do
                      {
                        char v23 = *--v10;
                        (v22--)[(void)v19] = v23;
                      }
                      while (v10 != (char *)v14);
                      uint64_t v10 = v112;
                      unsigned int v20 = v19;
                    }
                    xpc_object_t v112 = v20;
                    xpc_object_t v114 = &v19[v18];
                    if (v10) {
                      operator delete(v10);
                    }
                  }
                  else
                  {
                    *uint64_t v10 = v12;
                    uint64_t v13 = v10 + 1;
                  }
                  xpc_object_t v113 = v13;
                  ++v9;
                  uint64_t v10 = v13;
                }
                while (v9 != v11);
              }
            }
            xpc_object_t v109 = 0;
            xpc_object_t v110 = 0;
            xpc_object_t v111 = 0;
            if (*(unsigned char *)(a3 + 112))
            {
              uint64_t v24 = *(unsigned __int8 *)(a3 + 111);
              if ((v24 & 0x80u) == 0) {
                uint64_t v25 = (char *)(a3 + 88);
              }
              else {
                uint64_t v25 = *(char **)(a3 + 88);
              }
              if ((v24 & 0x80u) != 0) {
                uint64_t v24 = *(void *)(a3 + 96);
              }
              if (v24)
              {
                uint64_t v26 = 0;
                long long v27 = &v25[v24];
                do
                {
                  char v28 = *v25;
                  if (v26 >= v111)
                  {
                    unint64_t v30 = (unint64_t)v109;
                    uint64_t v31 = v26 - v109;
                    uint64_t v32 = v26 - v109 + 1;
                    if (v32 < 0) {
                      sub_10006A748();
                    }
                    unint64_t v33 = v111 - v109;
                    if (2 * (v111 - v109) > (unint64_t)v32) {
                      uint64_t v32 = 2 * v33;
                    }
                    if (v33 >= 0x3FFFFFFFFFFFFFFFLL) {
                      size_t v34 = 0x7FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      size_t v34 = v32;
                    }
                    if (v34) {
                      uint64_t v35 = (char *)operator new(v34);
                    }
                    else {
                      uint64_t v35 = 0;
                    }
                    long long v36 = &v35[v31];
                    long long v37 = &v35[v31];
                    char *v37 = v28;
                    uint64_t v29 = v37 + 1;
                    if (v26 != (char *)v30)
                    {
                      char v38 = &v26[~v30];
                      do
                      {
                        char v39 = *--v26;
                        (v38--)[(void)v35] = v39;
                      }
                      while (v26 != (char *)v30);
                      uint64_t v26 = v109;
                      long long v36 = v35;
                    }
                    xpc_object_t v109 = v36;
                    xpc_object_t v111 = &v35[v34];
                    if (v26) {
                      operator delete(v26);
                    }
                  }
                  else
                  {
                    *uint64_t v26 = v28;
                    uint64_t v29 = v26 + 1;
                  }
                  xpc_object_t v110 = v29;
                  ++v25;
                  uint64_t v26 = v29;
                }
                while (v25 != v27);
              }
            }
            xpc_object_t v40 = xpc_array_create(0, 0);
            if (v40 || (xpc_object_t v40 = xpc_null_create()) != 0)
            {
              if (xpc_get_type(v40) == (xpc_type_t)&_xpc_type_array)
              {
                xpc_retain(v40);
                xpc_object_t v41 = v40;
              }
              else
              {
                xpc_object_t v41 = xpc_null_create();
              }
            }
            else
            {
              xpc_object_t v41 = xpc_null_create();
              xpc_object_t v40 = 0;
            }
            xpc_release(v40);
            uint64_t v49 = *(void *)(a3 + 64);
            for (uint64_t i = *(void *)(a3 + 72); v49 != i; v49 += 24)
            {
              long long v116 = 0u;
              long long v117 = 0u;
              *(_OWORD *)long long buf = 0u;
              sub_100BEC024(v49, (std::string *)buf);
              if ((SBYTE7(v116) & 0x80u) == 0) {
                long long v50 = buf;
              }
              else {
                long long v50 = *(uint8_t **)buf;
              }
              xpc_object_t v51 = xpc_string_create((const char *)v50);
              if (!v51) {
                xpc_object_t v51 = xpc_null_create();
              }
              xpc_array_append_value(v41, v51);
              xpc_release(v51);
              if (SHIBYTE(v117) < 0) {
                operator delete(*((void **)&v116 + 1));
              }
              if (SBYTE7(v116) < 0) {
                operator delete(*(void **)buf);
              }
            }
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v108 = 0;
            if (*(unsigned char *)(a2 + 128))
            {
              if (*(char *)(a2 + 127) < 0)
              {
                sub_10004FC84(__p, *(void **)(a2 + 104), *(void *)(a2 + 112));
              }
              else
              {
                *(_OWORD *)long long __p = *(_OWORD *)(a2 + 104);
                uint64_t v108 = *(void *)(a2 + 120);
              }
            }
            else
            {
              sub_100561B00((uint64_t)__p);
            }
            xpc_object_t v106 = 0;
            xpc_object_t v52 = xpc_dictionary_create(0, 0, 0);
            xpc_object_t v53 = v52;
            if (v52)
            {
              xpc_object_t v106 = v52;
            }
            else
            {
              xpc_object_t v53 = xpc_null_create();
              xpc_object_t v106 = v53;
              if (!v53)
              {
                xpc_object_t v54 = xpc_null_create();
                xpc_object_t v53 = 0;
                goto LABEL_102;
              }
            }
            if (xpc_get_type(v53) == (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_retain(v53);
LABEL_103:
              xpc_release(v53);
              if (*(char *)(a3 + 31) >= 0) {
                uint64_t v55 = (const char *)(a3 + 8);
              }
              else {
                uint64_t v55 = *(const char **)(a3 + 8);
              }
              xpc_object_t v104 = xpc_string_create(v55);
              if (!v104) {
                xpc_object_t v104 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kRemoteUri;
              sub_100035E70((uint64_t)buf, &v104, &object);
              xpc_release(object);
              xpc_object_t object = 0;
              xpc_release(v104);
              xpc_object_t v104 = 0;
              if (*(unsigned char *)(a3 + 56))
              {
                if (*(char *)(a3 + 55) < 0)
                {
                  sub_10004FC84(buf, *(void **)(a3 + 32), *(void *)(a3 + 40));
                }
                else
                {
                  *(_OWORD *)long long buf = *(_OWORD *)(a3 + 32);
                  *(void *)&long long v116 = *(void *)(a3 + 48);
                }
              }
              else
              {
                sub_100058DB0(buf, "");
              }
              if ((SBYTE7(v116) & 0x80u) == 0) {
                xpc_object_t v56 = buf;
              }
              else {
                xpc_object_t v56 = *(uint8_t **)buf;
              }
              xpc_object_t v102 = xpc_string_create((const char *)v56);
              if (!v102) {
                xpc_object_t v102 = xpc_null_create();
              }
              v101[0] = &v106;
              v101[1] = ims::lazuli::kSpamReportingUri;
              sub_100035E70((uint64_t)v101, &v102, &v103);
              xpc_release(v103);
              xpc_object_t v103 = 0;
              xpc_release(v102);
              xpc_object_t v102 = 0;
              if (SBYTE7(v116) < 0) {
                operator delete(*(void **)buf);
              }
              xpc_object_t v99 = v41;
              if (v41) {
                xpc_retain(v41);
              }
              else {
                xpc_object_t v99 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kMessageIDList;
              sub_10017AC14((uint64_t)buf, &v99, &v100);
              xpc_release(v100);
              xpc_object_t v100 = 0;
              xpc_release(v99);
              xpc_object_t v99 = 0;
              xpc_object_t v97 = xpc_BOOL_create(*(unsigned char *)a3);
              if (!v97) {
                xpc_object_t v97 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kIsChatbot;
              sub_100035E70((uint64_t)buf, &v97, &v98);
              xpc_release(v98);
              xpc_object_t v98 = 0;
              xpc_release(v97);
              xpc_object_t v97 = 0;
              xpc_object_t v95 = xpc_data_create(v109, v110 - v109);
              if (!v95) {
                xpc_object_t v95 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kSpamContent;
              sub_100035E70((uint64_t)buf, &v95, &v96);
              xpc_release(v96);
              xpc_object_t v96 = 0;
              xpc_release(v95);
              xpc_object_t v95 = 0;
              uint64_t v57 = (const char *)Lazuli::asString();
              xpc_object_t v93 = xpc_string_create(v57);
              if (!v93) {
                xpc_object_t v93 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kSpamType;
              sub_100035E70((uint64_t)buf, &v93, &v94);
              xpc_release(v94);
              xpc_object_t v94 = 0;
              xpc_release(v93);
              xpc_object_t v93 = 0;
              xpc_object_t v91 = xpc_data_create(v112, v113 - v112);
              if (!v91) {
                xpc_object_t v91 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kFreeText;
              sub_100035E70((uint64_t)buf, &v91, &v92);
              xpc_release(v92);
              xpc_object_t v92 = 0;
              xpc_release(v91);
              xpc_object_t v91 = 0;
              if (v108 >= 0) {
                char v58 = __p;
              }
              else {
                char v58 = (void **)__p[0];
              }
              xpc_object_t v89 = xpc_string_create((const char *)v58);
              if (!v89) {
                xpc_object_t v89 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kConversationId;
              sub_100035E70((uint64_t)buf, &v89, &v90);
              xpc_release(v90);
              xpc_object_t v90 = 0;
              xpc_release(v89);
              xpc_object_t v89 = 0;
              if (*(char *)(a4 + 23) >= 0) {
                xpc_object_t v59 = (const char *)a4;
              }
              else {
                xpc_object_t v59 = *(const char **)a4;
              }
              xpc_object_t v87 = xpc_string_create(v59);
              if (!v87) {
                xpc_object_t v87 = xpc_null_create();
              }
              *(void *)long long buf = &v106;
              *(void *)&uint8_t buf[8] = ims::lazuli::kTransactionId;
              sub_100035E70((uint64_t)buf, &v87, &v88);
              xpc_release(v88);
              xpc_object_t v88 = 0;
              xpc_release(v87);
              xpc_object_t v87 = 0;
              xpc_object_t v60 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
              if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(a3 + 31) >= 0) {
                  uint64_t v61 = a3 + 8;
                }
                else {
                  uint64_t v61 = *(void *)(a3 + 8);
                }
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = v61;
                _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Reporting spam for destination URI: %{public}s", buf, 0xCu);
              }
              uint64_t v62 = *(void *)(a1 + 200);
              xpc_object_t v86 = v106;
              if (v106) {
                xpc_retain(v106);
              }
              else {
                xpc_object_t v86 = xpc_null_create();
              }
              (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v62 + 24))(v62, &v86);
              xpc_release(v86);
              xpc_object_t v86 = 0;
              xpc_object_t v63 = *(char **)(a1 + 368);
              xpc_object_t v64 = (char **)(a1 + 368);
              xpc_object_t v65 = (char **)(a1 + 368);
              if (!v63) {
                goto LABEL_158;
              }
              xpc_object_t v64 = (char **)(a1 + 368);
              while (1)
              {
                while (1)
                {
                  xpc_object_t v65 = (char **)v63;
                  xpc_object_t v66 = v63 + 32;
                  if ((sub_100046FE8((void *)a4, (void **)v63 + 4) & 0x80) == 0) {
                    break;
                  }
                  xpc_object_t v63 = *v65;
                  xpc_object_t v64 = v65;
                  if (!*v65) {
                    goto LABEL_158;
                  }
                }
                if ((sub_100046FE8(v66, (void **)a4) & 0x80) == 0) {
                  break;
                }
                xpc_object_t v64 = v65 + 1;
                xpc_object_t v63 = v65[1];
                if (!v63) {
                  goto LABEL_158;
                }
              }
              xpc_object_t v67 = *v64;
              if (!*v64)
              {
LABEL_158:
                *(void *)&long long v116 = 0;
                xpc_object_t v68 = (char *)operator new(0xD8uLL);
                *(void *)long long buf = v68;
                *(void *)&uint8_t buf[8] = a1 + 368;
                LOBYTE(v116) = 0;
                xpc_object_t v69 = v68 + 32;
                if (*(char *)(a4 + 23) < 0)
                {
                  sub_10004FC84(v69, *(void **)a4, *(void *)(a4 + 8));
                }
                else
                {
                  *(_OWORD *)xpc_object_t v69 = *(_OWORD *)a4;
                  *((void *)v68 + 6) = *(void *)(a4 + 16);
                }
                *(_OWORD *)(v68 + 168) = 0u;
                *(_OWORD *)(v68 + 200) = 0u;
                *(_OWORD *)(v68 + 184) = 0u;
                *(_OWORD *)(v68 + 152) = 0u;
                *(_OWORD *)(v68 + 136) = 0u;
                *(_OWORD *)(v68 + 120) = 0u;
                *(_OWORD *)(v68 + 104) = 0u;
                *(_OWORD *)(v68 + 88) = 0u;
                *(_OWORD *)(v68 + 72) = 0u;
                *(_OWORD *)(v68 + 56) = 0u;
                *((_DWORD *)v68 + 44) = -1;
                LOBYTE(v116) = 1;
                *(void *)xpc_object_t v68 = 0;
                *((void *)v68 + 1) = 0;
                *((void *)v68 + 2) = v65;
                *xpc_object_t v64 = v68;
                uint64_t v70 = **(void **)(a1 + 360);
                if (v70)
                {
                  *(void *)(a1 + 360) = v70;
                  xpc_object_t v68 = *v64;
                }
                sub_100046C90(*(uint64_t **)(a1 + 368), (uint64_t *)v68);
                ++*(void *)(a1 + 376);
                xpc_object_t v67 = *(char **)buf;
                *(void *)long long buf = 0;
                sub_100D66A08((uint64_t)buf);
              }
              v67[56] = *(unsigned char *)a3;
              std::string::operator=((std::string *)(v67 + 64), (const std::string *)(a3 + 8));
              sub_100179AF8((std::string *)(v67 + 88), (const std::string *)(a3 + 32));
              if (v67 + 56 == (char *)a3) {
                goto LABEL_182;
              }
              uint64_t v71 = v67 + 136;
              long long v73 = v67 + 120;
              uint64_t v72 = (std::string *)*((void *)v67 + 15);
              xpc_object_t v75 = *(long long **)(a3 + 64);
              uint64_t v74 = *(long long **)(a3 + 72);
              unint64_t v76 = 0xAAAAAAAAAAAAAAABLL * (((char *)v74 - (char *)v75) >> 3);
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v67 + 17) - (void)v72) >> 3) >= v76)
              {
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v67 + 16) - (void)v72) >> 3) >= v76)
                {
                  xpc_object_t v81 = sub_100C2FF58(*(std::string **)(a3 + 64), *(std::string **)(a3 + 72), v72);
                  for (uint64_t j = (std::string *)*((void *)v67 + 16); j != v81; --j)
                  {
                    if (SHIBYTE(j[-1].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(j[-1].__r_.__value_.__l.__data_);
                    }
                  }
                  *((void *)v67 + 16) = v81;
                  goto LABEL_182;
                }
                uint64_t v80 = (std::string *)((char *)v75 + 8 * ((uint64_t)(*((void *)v67 + 16) - (void)v72) >> 3));
                sub_100C2FF58(*(std::string **)(a3 + 64), v80, v72);
                long long v79 = sub_100454154((uint64_t)(v67 + 136), (long long *)v80, v74, *((char **)v67 + 16));
              }
              else
              {
                sub_10005CBB4((uint64_t *)v67 + 15);
                if (v76 > 0xAAAAAAAAAAAAAAALL) {
                  sub_10006A748();
                }
                unint64_t v77 = 0x5555555555555556 * ((uint64_t)(*v71 - *v73) >> 3);
                if (v77 <= v76) {
                  unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * (((char *)v74 - (char *)v75) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v71 - *v73) >> 3) >= 0x555555555555555) {
                  unint64_t v78 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v78 = v77;
                }
                sub_100157704((void *)v67 + 15, v78);
                long long v79 = sub_100454154((uint64_t)(v67 + 136), v75, v74, *((char **)v67 + 16));
              }
              *((void *)v67 + 16) = v79;
LABEL_182:
              sub_100179AF8((std::string *)v67 + 6, (const std::string *)(a3 + 88));
              *((_DWORD *)v67 + 44) = *(_DWORD *)(a3 + 120);
              sub_100179AF8((std::string *)(v67 + 184), v85);
              xpc_release(v106);
              if (SHIBYTE(v108) < 0) {
                operator delete(__p[0]);
              }
              xpc_release(v41);
              if (v109) {
                operator delete(v109);
              }
              if (v112) {
                operator delete(v112);
              }
              goto LABEL_188;
            }
            xpc_object_t v54 = xpc_null_create();
LABEL_102:
            xpc_object_t v106 = v54;
            goto LABEL_103;
          }
          uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            long long v47 = "Invalid IMS ChatServices reference";
            goto LABEL_76;
          }
LABEL_188:
          long long v44 = 0;
          uint64_t v45 = 0;
          return v45 | (unint64_t)v44;
        }
        uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          goto LABEL_188;
        }
        *(_WORD *)long long buf = 0;
        long long v47 = "Invalid IMS client reference";
      }
      else
      {
        uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
          goto LABEL_188;
        }
        *(_WORD *)long long buf = 0;
        long long v47 = "Invalid sip stack reference";
      }
LABEL_76:
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v47, buf, 2u);
      goto LABEL_188;
    }
    long long v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      long long v43 = "#I No destination URI to report spam";
      goto LABEL_68;
    }
  }
  long long v44 = &_mh_execute_header;
  uint64_t v45 = 4;
  return v45 | (unint64_t)v44;
}

void sub_100D63FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,xpc_object_t object,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  *(void *)(v42 + 128) = v41;
  xpc_release(object);
  if (a40 < 0) {
    operator delete(__p);
  }
  xpc_release(v40);
  uint64_t v45 = *(void **)(v43 - 192);
  if (v45)
  {
    *(void *)(v43 - 184) = v45;
    operator delete(v45);
  }
  uint64_t v46 = *(void **)(v43 - 168);
  if (v46)
  {
    *(void *)(v43 - 160) = v46;
    operator delete(v46);
  }
  _Unwind_Resume(a1);
}

void sub_100D64184(uint64_t a1, void *a2)
{
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  uint64_t v4 = (void *)ims::lazuli::kTransactionId;
  v20[0] = a2;
  v20[1] = (xpc_object_t)ims::lazuli::kTransactionId;
  sub_100048BAC((uint64_t)v20, object);
  __p[0] = 0;
  __p[1] = 0;
  v28[0] = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v28[0]) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object[0]);
  uint64_t v5 = (void *)HIBYTE(v26);
  if (v26 < 0) {
    uint64_t v5 = v25[1];
  }
  if (v5)
  {
    __p[0] = a2;
    __p[1] = (void *)ims::lazuli::kIsSuccess;
    sub_100048BAC((uint64_t)__p, v20);
    char v7 = xpc::dyn_cast_or_default((xpc *)v20, 0, v6);
    xpc_release(v20[0]);
    object[0] = 0;
    object[1] = 0;
    uint64_t v24 = 0;
    if (SHIBYTE(v26) < 0)
    {
      sub_10004FC84(object, v25[0], (unint64_t)v25[1]);
    }
    else
    {
      *(_OWORD *)xpc_object_t object = *(_OWORD *)v25;
      uint64_t v24 = v26;
    }
    uint64_t v9 = *(void **)(a1 + 368);
    if (!v9) {
      goto LABEL_23;
    }
    uint64_t v10 = (void **)(a1 + 368);
    do
    {
      char v11 = sub_100046FE8(v9 + 4, v25);
      if (v11 >= 0) {
        char v12 = v9;
      }
      else {
        char v12 = v9 + 1;
      }
      if (v11 >= 0) {
        uint64_t v10 = (void **)v9;
      }
      uint64_t v9 = (void *)*v12;
    }
    while (*v12);
    if (v10 == (void **)(a1 + 368) || (sub_100046FE8(v25, v10 + 4) & 0x80) != 0)
    {
LABEL_23:
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Dropping spam report response. Unknown Operation ID: %s", (uint8_t *)__p, 0xCu);
      }
      goto LABEL_25;
    }
    *(_OWORD *)uint64_t v31 = 0u;
    long long v32 = 0u;
    memset(v30, 0, sizeof(v30));
    *(_OWORD *)char v28 = 0u;
    long long v29 = 0u;
    *(_OWORD *)long long __p = 0u;
    if (*((char *)v10 + 87) < 0)
    {
      sub_10004FC84(__p, v10[8], (unint64_t)v10[9]);
    }
    else
    {
      *(_OWORD *)long long __p = *((_OWORD *)v10 + 4);
      v28[0] = v10[10];
    }
    char v14 = 0;
    LOBYTE(v30[0]) = *((unsigned char *)v10 + 56);
    v28[1] = 0;
    long long v29 = 0uLL;
    BYTE8(v30[0]) = 0;
    LOBYTE(v31[0]) = 0;
    long long v32 = 0uLL;
    v31[1] = 0;
    *(_OWORD *)unint64_t v21 = 0u;
    long long v22 = 0u;
    *(_OWORD *)unsigned int v20 = 0u;
    LOBYTE(v20[0]) = v7;
    if ((v7 & 1) == 0)
    {
      HIDWORD(v20[0]) = 3;
      char v14 = 1;
    }
    LOBYTE(v20[1]) = v14;
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(v21, object[0], (unint64_t)object[1]);
    }
    else
    {
      *(_OWORD *)unint64_t v21 = *(_OWORD *)object;
      *(void *)&long long v22 = v24;
    }
    BYTE8(v22) = 0;
    BYTE12(v22) = 0;
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 224);
    if (v15)
    {
      uint64_t v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = *(void *)(a1 + 216);
        if (v17)
        {
          (*(void (**)(uint64_t, void, void **, xpc_object_t *))(*(void *)v17 + 8))(v17, *(unsigned int *)(a1 + 88), __p, v20);
          goto LABEL_43;
        }
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    size_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19[0] = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Dropping spam report response. Messaging controller has disappeared", (uint8_t *)v19, 2u);
      if (!v16) {
        goto LABEL_44;
      }
    }
    else if (!v16)
    {
LABEL_44:
      if (SBYTE7(v22) < 0) {
        operator delete(v21[0]);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(v31[1]);
      }
      if (LOBYTE(v31[0]))
      {
        v20[0] = (char *)v30 + 8;
        sub_100047F64((void ***)v20);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete(v28[1]);
      }
      if (SHIBYTE(v28[0]) < 0) {
        operator delete(__p[0]);
      }
LABEL_25:
      if (SHIBYTE(v24) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_27;
    }
LABEL_43:
    sub_10004D2C8(v16);
    goto LABEL_44;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Dropping spam report response. Invalid key: %s", (uint8_t *)__p, 0xCu);
  }
LABEL_27:
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
}

void sub_100D64610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, xpc_object_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  sub_10004D2C8(v37);
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10016FEBC((uint64_t)&a32);
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D646E0(uint64_t a1, const void **a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  xpc_object_t v117 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v117 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v117 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v117 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v115 = xpc_string_create("Terminating chat");
  if (!v115) {
    xpc_object_t v115 = xpc_null_create();
  }
  __p[0] = &v117;
  __p[1] = (void *)ims::lazuli::kReason;
  sub_100035E70((uint64_t)__p, &v115, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v115);
  xpc_object_t v115 = 0;
  uint64_t v8 = *(uint64_t **)(a1 + 280);
  uint64_t v9 = *(uint64_t **)(a1 + 288);
  if (v8 == v9)
  {
LABEL_38:
    unint64_t v21 = *(uint64_t **)(a1 + 256);
    long long v22 = *(uint64_t **)(a1 + 264);
    if (v21 == v22)
    {
LABEL_65:
      size_t v34 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I No chat found", (uint8_t *)__p, 2u);
      }
      goto LABEL_194;
    }
    while (1)
    {
      uint64_t v23 = *v21;
      if (*(char *)(*v21 + 71) < 0)
      {
        sub_10004FC84(__p, *(void **)(v23 + 48), *(void *)(v23 + 56));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(v23 + 48);
        uint64_t v119 = *(void *)(v23 + 64);
      }
      if (v119 >= 0) {
        uint64_t v24 = (void *)HIBYTE(v119);
      }
      else {
        uint64_t v24 = __p[1];
      }
      uint64_t v25 = (void *)*((unsigned __int8 *)a2 + 23);
      int v26 = (char)v25;
      if ((char)v25 < 0) {
        uint64_t v25 = (void *)a2[1];
      }
      if (v24 == v25)
      {
        if (v26 >= 0) {
          long long v27 = (unsigned __int8 *)a2;
        }
        else {
          long long v27 = (unsigned __int8 *)*a2;
        }
        if (v119 < 0)
        {
          long long v32 = __p[0];
          int v33 = memcmp(__p[0], v27, (size_t)__p[1]);
          operator delete(v32);
          if (!v33) {
            goto LABEL_71;
          }
        }
        else
        {
          if (!HIBYTE(v119)) {
            goto LABEL_71;
          }
          uint64_t v28 = 0;
          do
          {
            int v29 = *((unsigned __int8 *)__p + v28);
            int v30 = v27[v28];
          }
          while (v29 == v30 && HIBYTE(v119) - 1 != v28++);
          if (v29 == v30)
          {
LABEL_71:
            long long v37 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__p[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Terminating chat for group", (uint8_t *)__p, 2u);
            }
            uint64_t v38 = *v21;
            xpc_object_t v113 = v117;
            if (v117) {
              xpc_retain(v117);
            }
            else {
              xpc_object_t v113 = xpc_null_create();
            }
            sub_100A6604C((uint64_t *)(v38 + 152), v4, &v113);
            xpc_release(v113);
            xpc_object_t v113 = 0;
            unint64_t v77 = *(uint64_t **)(a1 + 256);
            unint64_t v76 = *(uint64_t **)(a1 + 264);
            if (v77 == v76)
            {
LABEL_192:
              uint64_t v93 = (uint64_t)v76;
              goto LABEL_193;
            }
            while (2)
            {
              uint64_t v78 = *v77;
              long long v79 = (std::__shared_weak_count *)v77[1];
              if (v79) {
                atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (*(char *)(v78 + 71) < 0)
              {
                sub_10004FC84(__p, *(void **)(v78 + 48), *(void *)(v78 + 56));
              }
              else
              {
                *(_OWORD *)long long __p = *(_OWORD *)(v78 + 48);
                uint64_t v119 = *(void *)(v78 + 64);
              }
              uint64_t v80 = *((unsigned __int8 *)a2 + 23);
              if ((v80 & 0x80u) == 0) {
                xpc_object_t v81 = (void *)*((unsigned __int8 *)a2 + 23);
              }
              else {
                xpc_object_t v81 = (void *)a2[1];
              }
              uint64_t v82 = (void *)HIBYTE(v119);
              int v83 = SHIBYTE(v119);
              if (v119 < 0) {
                uint64_t v82 = __p[1];
              }
              if (v81 == v82)
              {
                if (v119 >= 0) {
                  uint64_t v84 = __p;
                }
                else {
                  uint64_t v84 = (void **)__p[0];
                }
                if ((v80 & 0x80) != 0)
                {
                  BOOL v92 = memcmp(*a2, v84, (size_t)a2[1]) == 0;
                  goto LABEL_183;
                }
                if (*((unsigned char *)a2 + 23))
                {
                  uint64_t v85 = v80 - 1;
                  xpc_object_t v86 = a2;
                  do
                  {
                    int v88 = *(unsigned __int8 *)v86;
                    xpc_object_t v86 = (const void **)((char *)v86 + 1);
                    int v87 = v88;
                    int v90 = *(unsigned __int8 *)v84;
                    uint64_t v84 = (void **)((char *)v84 + 1);
                    int v89 = v90;
                    BOOL v54 = v85-- != 0;
                    char v91 = v54;
                    BOOL v92 = v87 == v89;
                  }
                  while (v87 == v89 && (v91 & 1) != 0);
LABEL_183:
                  if ((v83 & 0x80000000) == 0)
                  {
LABEL_184:
                    if (v79) {
                      goto LABEL_185;
                    }
                    goto LABEL_186;
                  }
                }
                else
                {
                  BOOL v92 = 1;
                  if ((SHIBYTE(v119) & 0x80000000) == 0) {
                    goto LABEL_184;
                  }
                }
              }
              else
              {
                BOOL v92 = 0;
                if ((SHIBYTE(v119) & 0x80000000) == 0) {
                  goto LABEL_184;
                }
              }
              operator delete(__p[0]);
              if (v79) {
LABEL_185:
              }
                sub_10004D2C8(v79);
LABEL_186:
              if (v92)
              {
                uint64_t v93 = (uint64_t)v76;
                if (v77 != v76)
                {
                  xpc_object_t v95 = v77 + 2;
                  if (v77 + 2 != v76)
                  {
                    uint64_t v93 = (uint64_t)v77;
                    while (1)
                    {
                      uint64_t v96 = v77[2];
                      xpc_object_t v97 = (std::__shared_weak_count *)v77[3];
                      unint64_t v77 = v95;
                      if (v97) {
                        atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      if (*(char *)(v96 + 71) < 0)
                      {
                        sub_10004FC84(__p, *(void **)(v96 + 48), *(void *)(v96 + 56));
                      }
                      else
                      {
                        *(_OWORD *)long long __p = *(_OWORD *)(v96 + 48);
                        uint64_t v119 = *(void *)(v96 + 64);
                      }
                      uint64_t v98 = *((unsigned __int8 *)a2 + 23);
                      if ((v98 & 0x80u) == 0) {
                        xpc_object_t v99 = (void *)*((unsigned __int8 *)a2 + 23);
                      }
                      else {
                        xpc_object_t v99 = (void *)a2[1];
                      }
                      xpc_object_t v100 = (void *)HIBYTE(v119);
                      int v101 = SHIBYTE(v119);
                      if (v119 < 0) {
                        xpc_object_t v100 = __p[1];
                      }
                      if (v99 == v100)
                      {
                        if (v119 >= 0) {
                          xpc_object_t v102 = __p;
                        }
                        else {
                          xpc_object_t v102 = (void **)__p[0];
                        }
                        if ((v98 & 0x80) != 0)
                        {
                          BOOL v110 = memcmp(*a2, v102, (size_t)a2[1]) == 0;
                        }
                        else
                        {
                          if (!*((unsigned char *)a2 + 23))
                          {
                            BOOL v110 = 1;
                            if ((SHIBYTE(v119) & 0x80000000) == 0) {
                              goto LABEL_226;
                            }
LABEL_225:
                            operator delete(__p[0]);
                            goto LABEL_226;
                          }
                          uint64_t v103 = v98 - 1;
                          xpc_object_t v104 = a2;
                          do
                          {
                            int v106 = *(unsigned __int8 *)v104;
                            xpc_object_t v104 = (const void **)((char *)v104 + 1);
                            int v105 = v106;
                            int v108 = *(unsigned __int8 *)v102;
                            xpc_object_t v102 = (void **)((char *)v102 + 1);
                            int v107 = v108;
                            BOOL v54 = v103-- != 0;
                            char v109 = v54;
                            BOOL v110 = v105 == v107;
                          }
                          while (v105 == v107 && (v109 & 1) != 0);
                        }
                        if (v101 < 0) {
                          goto LABEL_225;
                        }
                      }
                      else
                      {
                        BOOL v110 = 0;
                        if (SHIBYTE(v119) < 0) {
                          goto LABEL_225;
                        }
                      }
LABEL_226:
                      if (v97) {
                        sub_10004D2C8(v97);
                      }
                      if (!v110)
                      {
                        long long v111 = *(_OWORD *)v77;
                        uint64_t *v77 = 0;
                        v77[1] = 0;
                        xpc_object_t v112 = *(std::__shared_weak_count **)(v93 + 8);
                        *(_OWORD *)uint64_t v93 = v111;
                        if (v112) {
                          sub_10004D2C8(v112);
                        }
                        v93 += 16;
                      }
                      xpc_object_t v95 = v77 + 2;
                      if (v77 + 2 == v76) {
                        goto LABEL_193;
                      }
                    }
                  }
                  uint64_t v93 = (uint64_t)v77;
                }
LABEL_193:
                sub_100D65260(a1 + 256, v93, *(void *)(a1 + 264));
                goto LABEL_194;
              }
              v77 += 2;
              if (v77 == v76) {
                goto LABEL_192;
              }
              continue;
            }
          }
        }
      }
      else if (v119 < 0)
      {
        operator delete(__p[0]);
      }
      v21 += 2;
      if (v21 == v22) {
        goto LABEL_65;
      }
    }
  }
  while (1)
  {
    uint64_t v10 = *v8;
    if (*(char *)(*v8 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(v10 + 48), *(void *)(v10 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(v10 + 48);
      uint64_t v119 = *(void *)(v10 + 64);
    }
    if (v119 >= 0) {
      char v11 = (void *)HIBYTE(v119);
    }
    else {
      char v11 = __p[1];
    }
    char v12 = (void *)*((unsigned __int8 *)a2 + 23);
    int v13 = (char)v12;
    if ((char)v12 < 0) {
      char v12 = (void *)a2[1];
    }
    if (v11 != v12)
    {
      if (v119 < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_37;
    }
    if (v13 >= 0) {
      char v14 = (unsigned __int8 *)a2;
    }
    else {
      char v14 = (unsigned __int8 *)*a2;
    }
    if (v119 < 0)
    {
      uint64_t v19 = __p[0];
      int v20 = memcmp(__p[0], v14, (size_t)__p[1]);
      operator delete(v19);
      if (!v20) {
        break;
      }
      goto LABEL_37;
    }
    if (!HIBYTE(v119)) {
      break;
    }
    uint64_t v15 = 0;
    do
    {
      int v16 = *((unsigned __int8 *)__p + v15);
      int v17 = v14[v15];
    }
    while (v16 == v17 && HIBYTE(v119) - 1 != v15++);
    if (v16 == v17) {
      break;
    }
LABEL_37:
    v8 += 2;
    if (v8 == v9) {
      goto LABEL_38;
    }
  }
  uint64_t v35 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned int *)(a1 + 88));
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Terminating chat for 1:1", (uint8_t *)__p, 2u);
  }
  uint64_t v36 = *v8;
  xpc_object_t v114 = v117;
  if (v117) {
    xpc_retain(v117);
  }
  else {
    xpc_object_t v114 = xpc_null_create();
  }
  sub_100A6604C((uint64_t *)(v36 + 152), v4, &v114);
  xpc_release(v114);
  xpc_object_t v114 = 0;
  xpc_object_t v40 = *(uint64_t **)(a1 + 280);
  char v39 = *(uint64_t **)(a1 + 288);
  if (v40 == v39)
  {
LABEL_112:
    uint64_t v57 = (uint64_t)v39;
    goto LABEL_113;
  }
  while (2)
  {
    uint64_t v41 = *v40;
    uint64_t v42 = (std::__shared_weak_count *)v40[1];
    if (v42) {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(v41 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(v41 + 48), *(void *)(v41 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(v41 + 48);
      uint64_t v119 = *(void *)(v41 + 64);
    }
    uint64_t v43 = *((unsigned __int8 *)a2 + 23);
    if ((v43 & 0x80u) == 0) {
      long long v44 = (void *)*((unsigned __int8 *)a2 + 23);
    }
    else {
      long long v44 = (void *)a2[1];
    }
    uint64_t v45 = (void *)HIBYTE(v119);
    int v46 = SHIBYTE(v119);
    if (v119 < 0) {
      uint64_t v45 = __p[1];
    }
    if (v44 == v45)
    {
      if (v119 >= 0) {
        long long v47 = __p;
      }
      else {
        long long v47 = (void **)__p[0];
      }
      if ((v43 & 0x80) != 0)
      {
        BOOL v56 = memcmp(*a2, v47, (size_t)a2[1]) == 0;
        goto LABEL_103;
      }
      if (*((unsigned char *)a2 + 23))
      {
        uint64_t v48 = v43 - 1;
        uint64_t v49 = a2;
        do
        {
          int v51 = *(unsigned __int8 *)v49;
          uint64_t v49 = (const void **)((char *)v49 + 1);
          int v50 = v51;
          int v53 = *(unsigned __int8 *)v47;
          long long v47 = (void **)((char *)v47 + 1);
          int v52 = v53;
          BOOL v54 = v48-- != 0;
          char v55 = v54;
          BOOL v56 = v50 == v52;
        }
        while (v50 == v52 && (v55 & 1) != 0);
LABEL_103:
        if ((v46 & 0x80000000) == 0)
        {
LABEL_104:
          if (v42) {
            goto LABEL_105;
          }
          goto LABEL_106;
        }
      }
      else
      {
        BOOL v56 = 1;
        if ((SHIBYTE(v119) & 0x80000000) == 0) {
          goto LABEL_104;
        }
      }
    }
    else
    {
      BOOL v56 = 0;
      if ((SHIBYTE(v119) & 0x80000000) == 0) {
        goto LABEL_104;
      }
    }
    operator delete(__p[0]);
    if (v42) {
LABEL_105:
    }
      sub_10004D2C8(v42);
LABEL_106:
    if (!v56)
    {
      v40 += 2;
      if (v40 == v39) {
        goto LABEL_112;
      }
      continue;
    }
    break;
  }
  uint64_t v57 = (uint64_t)v39;
  if (v40 != v39)
  {
    char v58 = v40 + 2;
    if (v40 + 2 != v39)
    {
      uint64_t v57 = (uint64_t)v40;
      while (1)
      {
        uint64_t v59 = v40[2];
        xpc_object_t v60 = (std::__shared_weak_count *)v40[3];
        xpc_object_t v40 = v58;
        if (v60) {
          atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (*(char *)(v59 + 71) < 0)
        {
          sub_10004FC84(__p, *(void **)(v59 + 48), *(void *)(v59 + 56));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(v59 + 48);
          uint64_t v119 = *(void *)(v59 + 64);
        }
        uint64_t v61 = *((unsigned __int8 *)a2 + 23);
        if ((v61 & 0x80u) == 0) {
          uint64_t v62 = (void *)*((unsigned __int8 *)a2 + 23);
        }
        else {
          uint64_t v62 = (void *)a2[1];
        }
        xpc_object_t v63 = (void *)HIBYTE(v119);
        int v64 = SHIBYTE(v119);
        if (v119 < 0) {
          xpc_object_t v63 = __p[1];
        }
        if (v62 == v63)
        {
          if (v119 >= 0) {
            xpc_object_t v65 = __p;
          }
          else {
            xpc_object_t v65 = (void **)__p[0];
          }
          if ((v61 & 0x80) != 0)
          {
            BOOL v73 = memcmp(*a2, v65, (size_t)a2[1]) == 0;
          }
          else
          {
            if (!*((unsigned char *)a2 + 23))
            {
              BOOL v73 = 1;
              if ((SHIBYTE(v119) & 0x80000000) == 0) {
                goto LABEL_145;
              }
LABEL_144:
              operator delete(__p[0]);
              goto LABEL_145;
            }
            uint64_t v66 = v61 - 1;
            xpc_object_t v67 = a2;
            do
            {
              int v69 = *(unsigned __int8 *)v67;
              xpc_object_t v67 = (const void **)((char *)v67 + 1);
              int v68 = v69;
              int v71 = *(unsigned __int8 *)v65;
              xpc_object_t v65 = (void **)((char *)v65 + 1);
              int v70 = v71;
              BOOL v54 = v66-- != 0;
              char v72 = v54;
              BOOL v73 = v68 == v70;
            }
            while (v68 == v70 && (v72 & 1) != 0);
          }
          if (v64 < 0) {
            goto LABEL_144;
          }
        }
        else
        {
          BOOL v73 = 0;
          if (SHIBYTE(v119) < 0) {
            goto LABEL_144;
          }
        }
LABEL_145:
        if (v60) {
          sub_10004D2C8(v60);
        }
        if (!v73)
        {
          long long v74 = *(_OWORD *)v40;
          *xpc_object_t v40 = 0;
          v40[1] = 0;
          xpc_object_t v75 = *(std::__shared_weak_count **)(v57 + 8);
          *(_OWORD *)uint64_t v57 = v74;
          if (v75) {
            sub_10004D2C8(v75);
          }
          v57 += 16;
        }
        char v58 = v40 + 2;
        if (v40 + 2 == v39) {
          goto LABEL_113;
        }
      }
    }
    uint64_t v57 = (uint64_t)v40;
  }
LABEL_113:
  sub_100D65260(a1 + 280, v57, *(void *)(a1 + 288));
LABEL_194:
  xpc_release(v117);
  return 0;
}

void sub_100D650A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14)
{
}

void sub_100D65150(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1 + 5, a2);
  std::string::operator=(a1 + 6, a2 + 2);
  sub_100CC85C0(&__p, (uint64_t)&a2[1]);
  sub_100CC7D60();
}

void sub_100D6522C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D65248()
{
}

void sub_100D65260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 != v6)
    {
      uint64_t v7 = 16 * ((a3 - a2) >> 4);
      do
      {
        uint64_t v8 = (void *)(v3 + v7);
        long long v9 = *(_OWORD *)(v3 + v7);
        *uint64_t v8 = 0;
        v8[1] = 0;
        uint64_t v10 = *(std::__shared_weak_count **)(v3 + 8);
        *(_OWORD *)uint64_t v3 = v9;
        if (v10) {
          sub_10004D2C8(v10);
        }
        v3 += 16;
      }
      while (v3 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    while (v5 != v3)
    {
      char v11 = *(std::__shared_weak_count **)(v5 - 8);
      if (v11) {
        sub_10004D2C8(v11);
      }
      v5 -= 16;
    }
    *(void *)(a1 + 8) = v3;
  }
}

uint64_t sub_100D65304(uint64_t a1, long long **a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_1002B2788((void *)(a1 + 24), a2[3], a2[4], ((char *)a2[4] - (char *)a2[3]) >> 5);
  *(unsigned char *)(a1 + 48) = 1;
  return a1;
}

void sub_100D65380(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

unsigned char *sub_100D65398(unsigned char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (a4 >> 58) {
      sub_10006A748();
    }
    uint64_t result = sub_1001A14BC((uint64_t)(result + 16), a4);
    uint64_t v7 = result;
    *uint64_t v4 = result;
    v4[1] = result;
    v4[2] = &result[64 * v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = &v7[v9];
        char v11 = (long long *)(a2 + v9);
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          sub_10004FC84(v10, *(void **)v11, *((void *)v11 + 1));
        }
        else
        {
          long long v12 = *v11;
          *((void *)v10 + 2) = *((void *)v11 + 2);
          *(_OWORD *)uint64_t v10 = v12;
        }
        *(_DWORD *)&v7[v9 + 24] = *(_DWORD *)(a2 + v9 + 24);
        uint64_t result = &v7[v9 + 32];
        int v13 = (void **)(a2 + v9 + 32);
        if (*(char *)(a2 + v9 + 55) < 0)
        {
          uint64_t result = sub_10004FC84(result, *v13, *(void *)(a2 + v9 + 40));
        }
        else
        {
          long long v14 = *(_OWORD *)v13;
          *(void *)&v7[v9 + 48] = *(void *)(a2 + v9 + 48);
          *(_OWORD *)uint64_t result = v14;
        }
        *(void *)&v7[v9 + 56] = *(void *)(a2 + v9 + 56);
        v9 += 64;
      }
      while (a2 + v9 != a3);
      v7 += v9;
    }
    v4[1] = v7;
  }
  return result;
}

void sub_100D654B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_100D65508(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  long long v3 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  char v5 = *(unsigned char *)(a2 + 56);
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 56) = v5;
  *(unsigned char *)(a1 + 88) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  long long v6 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v6;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v7 = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  sub_100458B18(a1 + 152, a2 + 152);
  *(unsigned char *)(a1 + 760) = 1;
  return a1;
}

uint64_t sub_100D655EC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    long long v3 = (void **)(a1 + 56);
    sub_100155410(&v3);
  }
  if (*(unsigned char *)(a1 + 48))
  {
    long long v3 = (void **)(a1 + 24);
    sub_100155494(&v3);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100D65658(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 104))
  {
    long long v3 = (void **)(a1 + 80);
    sub_100155494(&v3);
  }
  long long v3 = (void **)(a1 + 56);
  sub_10045647C(&v3);
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100D656C8()
{
}

uint64_t sub_100D656DC(uint64_t a1)
{
  return *(void *)(a1 + 8) + 32;
}

void sub_100D656E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A549D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65708(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A549D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D6575C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = *(void **)(a1 + 32);

  sub_1001FEC70(v3);
}

void sub_100D657A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54A20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D657C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54A20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65814(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D6583C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54A70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D6585C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54A70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D658B0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

std::string *sub_100D658D8(std::string **a1, uint64_t a2, uint64_t a3)
{
  long long v6 = (std::string *)operator new(0x2F0uLL);
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A54A20;
  uint64_t result = sub_100B8C740(v6 + 1, a2, a3);
  *a1 = result;
  a1[1] = v6;
  return result;
}

void sub_100D65944(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100D6595C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54AC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D6597C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54AC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D659D0(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100D65A28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65A48(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54B10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65A9C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D65AC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54B60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65AE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54B60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65B38(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D65B60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54BB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65B80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54BB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65BD4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D65BFC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54C00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65C1C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54C00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65C70(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D65C98(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A54C50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D65CB8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A54C50;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D65D0C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D65D34(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      long long v3 = *(int **)(a2 + 8);
      unint64_t v4 = 0x34F72C234F72C235 * (((uint64_t)v3 - *(void *)a2) >> 3);
      char v5 = *(int **)a2;
      sub_100D65E14(a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v6 = (void **)a1;
    sub_100155494(&v6);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1001FD490((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0x34F72C234F72C235 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
}

uint64_t sub_100D65E14(uint64_t a1, int *a2, int *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(_DWORD **)a1;
  if (0x34F72C234F72C235 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_100456E30((void **)a1);
    if (a4 > 0x11A7B9611A7B961) {
      sub_1001F7A28();
    }
    unint64_t v10 = 0x69EE58469EE5846ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x34F72C234F72C235 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x8D3DCB08D3DCB0) {
      unint64_t v11 = 0x11A7B9611A7B961;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_1001F9D70((void *)a1, v11);
    uint64_t result = sub_1001FD518(v8, (uint64_t)a2, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x34F72C234F72C235 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    int v13 = &a2[2 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3)];
    sub_100D65FA8(a2, v13, v9);
    uint64_t result = sub_1001FD518(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = result;
    return result;
  }
  uint64_t result = (uint64_t)sub_100D65FA8(a2, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      uint64_t v17 = v16 - 232;
      uint64_t result = sub_10015551C(v16 - 224);
      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 8) = v15;
  return result;
}

void sub_100D65F98(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100D65FA0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

int *sub_100D65FA8(int *a1, int *a2, _DWORD *a3)
{
  unint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  char v5 = a2;
  do
  {
    uint64_t v6 = (uint64_t)(v4 + 2);
    int v7 = *v4;
    v4 += 58;
    uint64_t v8 = (uint64_t)(a3 + 2);
    *a3 = v7;
    a3 += 58;
    sub_1001FAD34(v8, v6);
  }
  while (v4 != v5);
  return v5;
}

void sub_100D6600C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      unint64_t v4 = *(std::string **)a2;
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *(void *)a2) >> 4);
      uint64_t v6 = *(std::string **)a1;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < v5)
      {
        sub_1001FA6F0((void **)a1);
        if (v5 > 0x555555555555555) {
          sub_10006A748();
        }
        unint64_t v7 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
        if (v7 <= v5) {
          unint64_t v7 = v5;
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v8 = 0x555555555555555;
        }
        else {
          unint64_t v8 = v7;
        }
        sub_10019F5D0((void *)a1, v8);
        uint64_t v9 = sub_100454380(a1 + 16, (uint64_t)v4, v3, *(void *)(a1 + 8));
        goto LABEL_17;
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v6) >> 4) < v5)
      {
        unint64_t v10 = (std::string *)((char *)v4 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v6) >> 4));
        sub_1001FA758(*(std::string **)a2, v10, v6);
        uint64_t v9 = sub_100454380(a1 + 16, (uint64_t)v10, v3, *(void *)(a1 + 8));
LABEL_17:
        *(void *)(a1 + 8) = v9;
        return;
      }
      unint64_t v11 = sub_1001FA758(*(std::string **)a2, *(std::string **)(a2 + 8), v6);
      for (uint64_t i = *(void *)(a1 + 8); (std::string *)i != v11; sub_1000FECD4(i))
        i -= 48;
      *(void *)(a1 + 8) = v11;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    int v13 = (void **)a1;
    sub_100155410(&v13);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1004542F8((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4));
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void sub_100D661E4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100D661EC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100D661F4(char *__dst, std::string *__str)
{
  if (__dst[176] == __str[7].__r_.__value_.__s.__data_[8])
  {
    if (__dst[176])
    {
      std::string::operator=((std::string *)__dst, __str);
      std::string::operator=((std::string *)__dst + 1, __str + 1);
      *((void *)__dst + 6) = __str[2].__r_.__value_.__l.__data_;
      sub_100179AF8((std::string *)(__dst + 56), (std::string *)((char *)__str + 56));
      sub_100179AF8((std::string *)(__dst + 88), (std::string *)((char *)__str + 88));
      long long v4 = *(_OWORD *)&__str[5].__r_.__value_.__l.__data_;
      *((_DWORD *)__dst + 34) = __str[5].__r_.__value_.__r.__words[2];
      *(_OWORD *)(__dst + 120) = v4;
      sub_100179AF8((std::string *)__dst + 6, __str + 6);
    }
  }
  else if (__dst[176])
  {
    sub_10045840C((uint64_t)__dst);
  }
  else
  {
    sub_100D662D0(__dst, (long long *)__str);
    __dst[176] = 1;
  }
}

char *sub_100D662D0(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  *((void *)__dst + 6) = *((void *)a2 + 6);
  sub_1000593FC((uint64_t)(__dst + 56), (long long *)((char *)a2 + 56));
  sub_1000593FC((uint64_t)(__dst + 88), (long long *)((char *)a2 + 88));
  long long v6 = *(long long *)((char *)a2 + 120);
  *((_DWORD *)__dst + 34) = *((_DWORD *)a2 + 34);
  *(_OWORD *)(__dst + 120) = v6;
  sub_1000593FC((uint64_t)(__dst + 144), a2 + 9);
  return __dst;
}

void sub_100D663A4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D66418(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = sub_100D664D8(a1, a2);
  sub_1001FD3D8(v4 + 328, (uint64_t)a2 + 328);
  return a1;
}

void sub_100D66460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  if (*(unsigned char *)(v10 + 320))
  {
    a10 = (void **)(v10 + 296);
    sub_100155494(&a10);
  }
  if (*(unsigned char *)(v10 + 288) && *(char *)(v10 + 287) < 0) {
    operator delete(*(void **)(v10 + 264));
  }
  if (*(unsigned char *)(v10 + 256) && *(char *)(v10 + 255) < 0) {
    operator delete(*(void **)(v10 + 232));
  }
  sub_1004563E8(v10 + 48);
  if (*(unsigned char *)(v10 + 40))
  {
    if (*(char *)(v10 + 39) < 0) {
      operator delete(*(void **)(v10 + 16));
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D664D8(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  sub_100D665D4(a1 + 16, a2 + 1);
  sub_100D66628((char *)(a1 + 48), (uint64_t)(a2 + 3));
  sub_100D66680(a1 + 232, (_OWORD *)((char *)a2 + 232));
  sub_100D666D4(a1 + 264, (_OWORD *)((char *)a2 + 264));
  sub_1001FD3D8(a1 + 296, (uint64_t)a2 + 296);
  return a1;
}

void sub_100D66560(_Unwind_Exception *a1)
{
  if (v2[288] && v2[287] < 0) {
    operator delete(*v5);
  }
  if (v2[256] && v2[255] < 0) {
    operator delete(*v4);
  }
  sub_1004563E8(v3);
  if (v2[40])
  {
    if (v2[39] < 0) {
      operator delete(*v1);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D665D4(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100059450((_OWORD *)a1, a2);
  return a1;
}

void sub_100D66604(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_100D66628(char *__dst, uint64_t a2)
{
  *long long __dst = 0;
  __dst[176] = 0;
  if (*(unsigned char *)(a2 + 176))
  {
    sub_100D662D0(__dst, (long long *)a2);
    __dst[176] = 1;
  }
  return __dst;
}

void sub_100D6666C(_Unwind_Exception *a1)
{
  sub_1004563E8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D66680(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100059450((_OWORD *)a1, a2);
  return a1;
}

void sub_100D666B0(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D666D4(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100059450((_OWORD *)a1, a2);
  return a1;
}

void sub_100D66704(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_100D66728(void *a1, unint64_t a2)
{
  if (a2 >= 0xEA0EA0EA0EA0EBLL) {
    sub_100D65248();
  }
  uint64_t result = (char *)sub_100D66934((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[280 * v4];
  return result;
}

uint64_t sub_100D66780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100D66804((char *)(a4 + v7), a2 + v7);
      v7 += 280;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100D667E0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 280;
    do
    {
      sub_100456500(v4 + v2);
      v2 -= 280;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100D66804(char *a1, uint64_t a2)
{
  uint64_t v4 = sub_100D66628(a1, a2);
  sub_100D66680((uint64_t)(v4 + 184), (long long *)(a2 + 184));
  sub_100D666D4((uint64_t)(a1 + 216), (long long *)(a2 + 216));
  sub_1001FD3D8((uint64_t)(a1 + 248), a2 + 248);
  return a1;
}

void sub_100D66864(_Unwind_Exception *a1)
{
  if (v1[240] && v1[239] < 0) {
    operator delete(*v3);
  }
  if (v1[208])
  {
    if (v1[207] < 0) {
      operator delete(*v2);
    }
  }
  sub_1004563E8((uint64_t)v1);
  _Unwind_Resume(a1);
}

char *sub_100D668B8(std::string *__str, std::string *a2, char *__dst)
{
  if (__str != a2)
  {
    long long v5 = __str;
    do
    {
      sub_100D661F4(__dst, v5);
      sub_100179AF8((std::string *)(__dst + 184), (std::string *)((char *)v5 + 184));
      sub_100179AF8((std::string *)__dst + 9, v5 + 9);
      sub_100D65D34((uint64_t)(__dst + 248), (uint64_t)&v5[10].__r_.__value_.__l.__size_);
      __dst += 280;
      long long v5 = (std::string *)((char *)v5 + 280);
    }
    while (v5 != a2);
  }
  return __dst;
}

void *sub_100D66934(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xEA0EA0EA0EA0EBLL) {
    sub_10006A7CC();
  }
  return operator new(280 * a2);
}

void *sub_100D66980(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100D66728(result, a4);
    uint64_t result = (void *)sub_100D66780((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100D669E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10045647C(&a9);
  _Unwind_Resume(a1);
}

void sub_100D66A08(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1009394D8((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t DataUsageController::bootstrap_sync(DataUsageController *this, group_session a2)
{
  DataUsageController::initialize_sync(this);
  (*(void (**)(void))(**((void **)this + 64) + 16))(*((void *)this + 64));
  uint64_t v4 = *((void *)this + 66);
  long long v5 = *(NSObject **)a2.var0.fObj;
  dispatch_group_t group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v4 + 24))(v4, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  (*(void (**)(long long *__return_ptr))(**((void **)this + 72) + 16))(&v33);
  long long v6 = v33;
  long long v33 = 0uLL;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 71);
  *((_OWORD *)this + 35) = v6;
  if (v7)
  {
    sub_10004D2C8(v7);
    if (*((void *)&v33 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
    }
  }
  DataUsageController::subscriberInitialize_sync((Registry **)this);
  sub_100058DB0(&__p, "/cc/props/call_state");
  unint64_t v8 = (char *)operator new(0x28uLL);
  uint64_t v9 = (char *)this + 104;
  *(void *)unint64_t v8 = off_101A54E38;
  *((void *)v8 + 1) = (char *)this + 178;
  *((void *)v8 + 2) = this;
  *((void *)v8 + 3) = DataUsageController::handleCallActiveChanged_sync;
  *((void *)v8 + 4) = 0;
  size_t v34 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/data_service_config_refreshed");
  uint64_t v10 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v10 = off_101A54EB8;
  *((void *)v10 + 1) = this;
  *((void *)v10 + 2) = DataUsageController::handleDataServiceConfigRefreshed_sync;
  *((void *)v10 + 3) = 0;
  size_t v34 = v10;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/connection_state");
  unint64_t v11 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v11 = off_101A54F38;
  *((void *)v11 + 1) = (char *)this + 368;
  *((void *)v11 + 2) = this;
  *((void *)v11 + 3) = DataUsageController::handleConnectionStateChange_sync;
  *((void *)v11 + 4) = 0;
  size_t v34 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  long long v12 = (char *)operator new(0x20uLL);
  *(void *)long long v12 = off_101A54FB8;
  *((void *)v12 + 1) = this;
  *((void *)v12 + 2) = DataUsageController::handleDumpState_sync;
  *((void *)v12 + 3) = 0;
  size_t v34 = v12;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  int v13 = (char *)this + 288;
  *(void *)&long long v33 = off_101A55038;
  *((void *)&v33 + 1) = (char *)this + 104;
  size_t v34 = (char *)&v33;
  if (&v33 != (long long *)((char *)this + 288))
  {
    uint64_t v14 = (char *)*((void *)this + 39);
    if (v14 == v13)
    {
      uint64_t v36 = (char *)this + 104;
      uint64_t v37 = 0;
      size_t v34 = 0;
      long long __p = off_101A55038;
      (*(void (**)(char *, long long *))(*(void *)v13 + 24))((char *)this + 288, &v33);
      (*(void (**)(void))(**((void **)this + 39) + 32))(*((void *)this + 39));
      *((void *)this + 39) = 0;
      size_t v34 = (char *)&v33;
      (*((void (**)(void **, char *))__p + 3))(&__p, (char *)this + 288);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *((void *)this + 36) = off_101A55038;
      *((void *)this + 37) = v9;
      size_t v34 = v14;
    }
    *((void *)this + 39) = v13;
  }
  sub_100D685AC(&v33);
  uint64_t v15 = *((void *)this + 39);
  if (v15) {
    (*(void (**)(uint64_t, char *))(*(void *)v15 + 48))(v15, (char *)this + 320);
  }
  sub_100058DB0(&__p, "/cc/events/significant_time_change");
  uint64_t v16 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v16 = off_101A550C8;
  *((void *)v16 + 1) = this;
  *((void *)v16 + 2) = DataUsageController::handleSignificantTimeChanged_sync;
  *((void *)v16 + 3) = 0;
  size_t v34 = v16;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/cellular_data_blocklisted_apps");
  uint64_t v17 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v17 = off_101A55148;
  *((void *)v17 + 1) = (char *)this + 344;
  *((void *)v17 + 2) = this;
  *((void *)v17 + 3) = DataUsageController::handleBlocklistedBundlesChange_sync;
  *((void *)v17 + 4) = 0;
  size_t v34 = v17;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/reg_data_attached");
  size_t v18 = (char *)operator new(0x28uLL);
  *(void *)size_t v18 = off_101A551C8;
  *((void *)v18 + 1) = (char *)this + 392;
  *((void *)v18 + 2) = this;
  *((void *)v18 + 3) = DataUsageController::handleDataAttached_sync;
  *((void *)v18 + 4) = 0;
  size_t v34 = v18;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  uint64_t v19 = (char *)this + 464;
  *(void *)&long long v33 = off_101A55248;
  *((void *)&v33 + 1) = (char *)this + 104;
  size_t v34 = (char *)&v33;
  if (&v33 != (long long *)((char *)this + 464))
  {
    int v20 = (char *)*((void *)this + 61);
    if (v20 == v19)
    {
      uint64_t v36 = (char *)this + 104;
      uint64_t v37 = 0;
      size_t v34 = 0;
      long long __p = off_101A55248;
      (*(void (**)(char *, long long *))(*(void *)v19 + 24))((char *)this + 464, &v33);
      (*(void (**)(void))(**((void **)this + 61) + 32))(*((void *)this + 61));
      *((void *)this + 61) = 0;
      size_t v34 = (char *)&v33;
      (*((void (**)(void **, char *))__p + 3))(&__p, (char *)this + 464);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *((void *)this + 58) = off_101A55248;
      *((void *)this + 59) = v9;
      size_t v34 = v20;
    }
    *((void *)this + 61) = v19;
  }
  sub_100D68C7C(&v33);
  uint64_t v21 = *((void *)this + 61);
  if (v21) {
    (*(void (**)(uint64_t, char *))(*(void *)v21 + 48))(v21, (char *)this + 496);
  }
  DataUsageController::fixupProcessNames_sync(this);
  DataUsageController::loadProcessCache_sync(this);
  sub_100058DB0(&__p, "/cc/props/wifi_status");
  long long v22 = (char *)operator new(0x28uLL);
  *(void *)long long v22 = off_101A552D8;
  *((void *)v22 + 1) = (char *)this + 176;
  *((void *)v22 + 2) = this;
  *((void *)v22 + 3) = DataUsageController::handleWifiAvailable_sync;
  *((void *)v22 + 4) = 0;
  size_t v34 = v22;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/internet_reachability_interface");
  uint64_t v23 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v23 = off_101A55358;
  *((void *)v23 + 1) = (char *)this + 177;
  *((void *)v23 + 2) = this;
  *((void *)v23 + 3) = DataUsageController::handleInternetReachability_sync;
  *((void *)v23 + 4) = 0;
  size_t v34 = v23;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/in_home_countries");
  uint64_t v24 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v24 = off_101A553D8;
  *((void *)v24 + 1) = (char *)this + 416;
  *((void *)v24 + 2) = this;
  *((void *)v24 + 3) = DataUsageController::handleInHomeCountriesUpdate_sync;
  *((void *)v24 + 4) = 0;
  size_t v34 = v24;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/rat");
  uint64_t v25 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v25 = off_101A55458;
  *((void *)v25 + 1) = (char *)this + 440;
  *((void *)v25 + 2) = this;
  *((void *)v25 + 3) = DataUsageController::handleRatsUpdate_sync;
  *((void *)v25 + 4) = 0;
  size_t v34 = v25;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/app_state_changed");
  int v26 = (char *)operator new(0x20uLL);
  *(void *)int v26 = off_101A554D8;
  *((void *)v26 + 1) = this;
  *((void *)v26 + 2) = DataUsageController::handleAppRunState_sync;
  *((void *)v26 + 3) = 0;
  size_t v34 = v26;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/data_usage_billing_cycle");
  long long v27 = (char *)operator new(0x28uLL);
  *(void *)long long v27 = off_101A55558;
  *((void *)v27 + 1) = (char *)this + 672;
  *((void *)v27 + 2) = this;
  *((void *)v27 + 3) = DataUsageController::handleDataUsageBillingCycleUpdate_sync;
  *((void *)v27 + 4) = 0;
  size_t v34 = v27;
  ctu::RestModule::observeProperty();
  uint64_t v28 = (capabilities::ct *)sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  if (capabilities::ct::getProvisioningProfileSupport(v28) == 1)
  {
    sub_100D676F8((uint64_t)this + 720);
    sub_100058DB0(&__p, "/cc/props/cellular_plan_bootstrap_status");
    int v29 = (char *)operator new(0x28uLL);
    *(void *)int v29 = off_101A55658;
    *((void *)v29 + 1) = (char *)this + 712;
    *((void *)v29 + 2) = this;
    *((void *)v29 + 3) = DataUsageController::handleBootstrapStatusChanged_sync;
    *((void *)v29 + 4) = 0;
    size_t v34 = v29;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v33);
    if (SHIBYTE(v37) < 0) {
      operator delete(__p);
    }
  }
  sub_100058DB0(&__p, "/cc/events/rectify_tag");
  int v30 = (char *)operator new(0x20uLL);
  *(void *)int v30 = off_101A556D8;
  *((void *)v30 + 1) = this;
  *((void *)v30 + 2) = DataUsageController::handleRectifyTag_sync;
  *((void *)v30 + 3) = 0;
  size_t v34 = v30;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v33);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  return (*(uint64_t (**)(void, char *))(**((void **)this + 11) + 16))(*((void *)this + 11), (char *)this + 120);
}

void sub_100D67620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D676F8(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/vinyl_info");
  v4[0] = off_101A555D8;
  v4[1] = a1;
  void v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100D677AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void DataUsageController::setUpTriggerForCollapsingAfter_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Will start collapsing records after: %llu", (uint8_t *)&buf, 0xCu);
  }
  Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 120));
  uint64_t v5 = buf;
  sub_100058DB0(__p, "DataUsageController");
  long long v6 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472;
  aBlock[2] = sub_100D67A30;
  aBlock[3] = &unk_1019A1BF8;
  aBlock[4] = a1;
  unint64_t v11 = _Block_copy(aBlock);
  sub_100118A44(v5, (uint64_t)__p, 1, 1000000 * a2, &object, &v11);
  uint64_t v7 = v15;
  uint64_t v15 = 0;
  uint64_t v8 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v15;
    uint64_t v15 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  if (v11) {
    _Block_release(v11);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
}

void sub_100D679C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D67A30(uint64_t a1)
{
  return DataUsageController::collapseOlderRecordsAndResetContext_sync(*(DataUsageController **)(a1 + 32));
}

void DataUsageController::resetIdleDataTimer_sync(DataUsageController *this)
{
  sub_10003E168(&v17, (void *)this + 1);
  uint64_t v3 = v17;
  uint64_t v2 = v18;
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  Registry::getTimerService(&v17, *((Registry **)this + 15));
  uint64_t v4 = v17;
  sub_100058DB0(__p, "DataUsageController");
  uint64_t v5 = *((void *)this + 41);
  long long v6 = *((void *)this + 3);
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3321888768;
  aBlock[2] = sub_100D67C84;
  aBlock[3] = &unk_101A54DF8;
  aBlock[4] = this;
  void aBlock[5] = v3;
  unint64_t v11 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v12 = _Block_copy(aBlock);
  sub_100118A44(v4, (uint64_t)__p, 1, 1000000 * v5, &object, &v12);
  uint64_t v7 = v16;
  uint64_t v16 = 0;
  uint64_t v8 = *((void *)this + 42);
  *((void *)this + 42) = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v16;
    uint64_t v16 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  if (v12) {
    _Block_release(v12);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100D67C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  long long v27 = *(std::__shared_weak_count **)(v25 - 56);
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D67C84(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (DataUsageController *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5]) {
        DataUsageController::handleIdleDataTimer_sync(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100D67CF8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D67D0C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D67D28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D67D3C()
{
}

__n128 sub_100D67D50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A54E38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D67DA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54E38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D67DDC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (unsigned char *)a1[1];
  v9[0] = 0;
  v9[1] = 0;
  uint64_t v8 = v9;
  sub_10031571C((uint64_t)&v8, a2);
  int v4 = *v3;
  sub_1003159D4(v3, &v8);
  if (v4 != *v3)
  {
    uint64_t v5 = (void (*)(void *, BOOL))a1[3];
    uint64_t v6 = a1[4];
    uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      uint64_t v5 = *(void (**)(void *, BOOL))(*v7 + v5);
    }
    v5(v7, v4 != 0);
  }
  sub_10005CD2C((uint64_t)&v8, v9[0]);
}

void sub_100D67EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100D67EBC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D67EFC()
{
}

void sub_100D67F0C()
{
}

__n128 sub_100D67F20(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A54EB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D67F74(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54EB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D67FAC(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  unint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100D68090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D680D0()
{
}

void sub_100D680E0()
{
}

__n128 sub_100D680F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A54F38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D68148(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54F38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D68180(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *int v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100318E34((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10024D10C((uint64_t)&v9, v10);
}

void sub_100D68240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100D68258(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D68298()
{
}

void sub_100D682A8()
{
}

__n128 sub_100D682BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A54FB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D68310(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A54FB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D68348(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D68390(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D683D0()
{
}

void sub_100D683E0()
{
}

void *sub_100D683F4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A55038;
  result[1] = v3;
  return result;
}

uint64_t sub_100D6843C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A55038;
  a2[1] = v2;
  return result;
}

void sub_100D68468(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = (ctu::rest::detail *)*a2;
  xpc_object_t v8 = 0;
  unint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/data_usage_status");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100D6851C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100D68560(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D685A0()
{
}

void *sub_100D685AC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D68634()
{
}

__n128 sub_100D68648(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A550C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D6869C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A550C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D686D4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  unint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D6871C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6875C()
{
}

void sub_100D6876C()
{
}

__n128 sub_100D68780(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55148;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D687D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55148;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D6880C(uint64_t *a1, xpc_object_t *a2)
{
  sub_1000E4B84(a1[1], a2);
  unint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    unint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100D68888(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D688C8()
{
}

void sub_100D688D8()
{
}

__n128 sub_100D688EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A551C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D68940(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A551C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D68978(void *a1, xpc_object_t *a2)
{
  unint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100D68A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100D68A50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D68A90()
{
}

void sub_100D68AA0()
{
}

void *sub_100D68AB4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A55248;
  result[1] = v3;
  return result;
}

uint64_t sub_100D68AFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A55248;
  a2[1] = v2;
  return result;
}

void sub_100D68B28(uint64_t a1, int *a2, const char *a3)
{
  uint64_t v3 = (ctu::rest::detail *)*a2;
  if (v3 > 2) {
    uint64_t v4 = "???";
  }
  else {
    uint64_t v4 = off_101A55748[(void)v3];
  }
  xpc_object_t v8 = 0;
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v3, (uint64_t)v4, a3);
  sub_100058DB0(&__p, "/cc/props/database_integrity_check_result");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100D68BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100D68C30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D68C70()
{
}

void *sub_100D68C7C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D68D04()
{
}

__n128 sub_100D68D18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A552D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D68D6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A552D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D68DA4(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  long long v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100D68E9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D68EDC()
{
}

void sub_100D68EEC()
{
}

__n128 sub_100D68F00(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55358;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D68F54(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D68F8C(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  long long v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100D69084(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D690C4()
{
}

void sub_100D690D4()
{
}

__n128 sub_100D690E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A553D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D6913C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A553D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D69174(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D691B4()
{
}

void sub_100D691C4()
{
}

__n128 sub_100D691D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55458;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D6922C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D69264(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100D69324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100D6933C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6937C()
{
}

void sub_100D6938C()
{
}

__n128 sub_100D693A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A554D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D693F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A554D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D6942C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6946C()
{
}

void sub_100D6947C()
{
}

__n128 sub_100D69490(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55558;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D694E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D6951C(void *a1, const xpc::object *a2)
{
  uint64_t v3 = (long long *)a1[1];
  long long v4 = *v3;
  long long v5 = v3[1];
  uint64_t v11 = *((void *)v3 + 4);
  v10[0] = v4;
  v10[1] = v5;
  read_rest_value((DataUsageBillingCycle *)v3, a2);
  uint64_t v6 = (uint64_t (*)(void *, _OWORD *))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, _OWORD *))(*v8 + v6);
  }
  return v6(v8, v10);
}

uint64_t sub_100D695A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D695E8()
{
}

void sub_100D695F8()
{
}

void *sub_100D6960C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A555D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100D69654(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A555D8;
  a2[1] = v2;
  return result;
}

void sub_100D69680(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100D69688(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D696C8()
{
}

void sub_100D696D4(uint64_t *a1, xpc_object_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_10010C4E0(&v4, a2);
  memset(v3, 0, sizeof(v3));
  sub_100311ED8(v3, v4, v5, 0x2E8BA2E8BA2E8BA3 * ((v5 - v4) >> 3));
  sub_100786618(v2, v3);
  uint64_t v7 = (void **)v3;
  sub_1000C56F4(&v7);
  uint64_t v7 = (void **)&v4;
  sub_1000C56F4(&v7);
}

void sub_100D69768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 24) = v13;
  sub_1000C56F4((void ***)(v14 - 24));
  *(void *)(v14 - 24) = &a13;
  sub_1000C56F4((void ***)(v14 - 24));
  _Unwind_Resume(a1);
}

void sub_100D6979C()
{
}

__n128 sub_100D697B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55658;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D69804(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D6983C(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  int v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v6);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, int *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, int *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_100D69938(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D69978()
{
}

void sub_100D69988()
{
}

__n128 sub_100D6999C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A556D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D699F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A556D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D69A28(void *a1, xpc_object_t *a2)
{
  uint64_t v7 = 0;
  sub_1004CBC9C(&v7, a2);
  uint64_t v3 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t *))(*v5 + v3);
  }
  return v3(v5, &v7);
}

uint64_t sub_100D69AA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D69AE8()
{
}

uint64_t sub_100D69AF4(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::FileTransferDescriptor>(a1 + 8);
}

uint64_t sub_100D69AFC(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::IMCompositionIndication>(a1 + 8);
}

uint64_t sub_100D69B04(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::IMDispositionNotification>(a1 + 8);
}

uint64_t sub_100D69B0C(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::GeoPushLocation>(a1 + 8);
}

uint64_t sub_100D69B14(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::ClientAuthenticityRequest>(a1 + 8);
}

uint64_t sub_100D69B1C(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::SIPConferenceInfo>(a1 + 8);
}

uint64_t sub_100D69B24(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::SIPResourceLists>(a1 + 8);
}

uint64_t sub_100D69B2C(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::CPMGroupManagement>(a1 + 8);
}

uint64_t sub_100D69B34(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::ProvisioningConfiguration>(a1 + 8);
}

uint64_t sub_100D69B3C(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::CPIMMessage>(a1 + 8);
}

uint64_t sub_100D69B44(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::IMRevoke>(a1 + 8);
}

uint64_t sub_100D69B4C(uint64_t a1)
{
  return ctb::Client::unpackData<ctb::chatbot::RenderInformation>(a1 + 8);
}

uint64_t sub_100D69B54(uint64_t a1, uint64_t a2, unsigned __int16 a3)
{
  return ctb::Client::unpackDataWithOptions<ctb::chatbot::Message,ctb::chatbot::Message::UnpackOptions>(a1 + 8, a2, a3);
}

void sub_100D69B60(uint64_t a1)
{
  *(void *)a1 = off_101A55770;
  ctb::Client::~Client((ctb::Client *)(a1 + 8));

  BlastDoorClientInterface::~BlastDoorClientInterface((BlastDoorClientInterface *)a1);
}

void sub_100D69BB4(uint64_t a1)
{
  *(void *)a1 = off_101A55770;
  ctb::Client::~Client((ctb::Client *)(a1 + 8));
  BlastDoorClientInterface::~BlastDoorClientInterface((BlastDoorClientInterface *)a1);

  operator delete();
}

uint64_t sub_100D69C24(uint64_t a1)
{
  *(void *)a1 = off_101A55820;
  sub_100D69CC4(a1, 1);

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100057D78((const void **)(a1 + 56));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_1004FDE68(a1 + 8);
  return a1;
}

void sub_100D69CC4(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v3 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I user cancels proximity transfer", v4, 2u);
    }

    *(_DWORD *)(a1 + 132) = 0;
    sub_100D6A3AC(a1);
    sub_100D6A42C((id *)a1);
  }
  else
  {
    sub_100D6A2E8(a1, 0);
  }
}

void sub_100D69D78(uint64_t a1)
{
  sub_100D69C24(a1);

  operator delete();
}

uint64_t sub_100D69DB0(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 132))
  {
    uint64_t v4 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "already activate. skip", (uint8_t *)&buf, 2u);
    }

    return sub_10024924C(a2, 13);
  }
  else
  {
    if (*(void *)(a1 + 96))
    {
      int v6 = 1;
    }
    else
    {
      uint64_t v7 = *(void **)(a1 + 56);
      if (v7) {
        xpc_object_t v8 = sub_100080778;
      }
      else {
        xpc_object_t v8 = 0;
      }
      if (v8)
      {
        id v9 = v7;
        id v28 = 0;
        id v10 = [objc_alloc(off_101B0B260()) initWithDictionary:v9 error:&v28];
        uint64_t v11 = v28;
        if (v10)
        {
          long long v12 = objc_alloc_init(off_101B0B268());
          int v13 = [v10 identifier];
          [v12 setIdentifier:v13];

          int v14 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v10;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I create client with peer device : %@", (uint8_t *)&buf, 0xCu);
          }

          id v15 = objc_alloc_init(off_101B0B270());
          uint64_t v16 = *(void **)(a1 + 96);
          *(void *)(a1 + 96) = v15;

          uint64_t v17 = sub_100200FB4((id *)(a1 + 24));
          [*(id *)(a1 + 96) setDispatchQueue:v17];

          [*(id *)(a1 + 96) setPeerDevice:v12];
          size_t v18 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v18 || (uint64_t v19 = *(void *)(a1 + 8), (v20 = std::__shared_weak_count::lock(v18)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v21 = v20;
          p_shared_weak_owners = &v20->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3321888768;
          int v30 = sub_100D6ABC8;
          uint64_t v31 = &unk_101A55868;
          uint64_t v32 = a1;
          uint64_t v33 = v19;
          size_t v34 = v21;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          [*(id *)(a1 + 96) setEventHandler:&buf];
          uint64_t v23 = *(void **)(a1 + 96);
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3321888768;
          v26[2] = sub_100D6AFA4;
          v26[3] = &unk_101A558B8;
          void v26[4] = a1;
          v26[5] = v19;
          long long v27 = v21;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          [v23 registerRequestID:@"CTProximityTransferRequestID" options:0 requestHandler:v26 completionHandler:&stru_101A558E8];
          uint64_t v24 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v25 = 0;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I activate SKSetupSIMTransferClient", v25, 2u);
          }

          [*(id *)(a1 + 96) activate];
          if (v27) {
            std::__shared_weak_count::__release_weak(v27);
          }
          if (v34) {
            std::__shared_weak_count::__release_weak(v34);
          }
          std::__shared_weak_count::__release_weak(v21);
        }
        else
        {
          long long v12 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v11;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "decode CBDevice failed : %@", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      else
      {
        uint64_t v11 = sub_100200FB4((id *)(a1 + 40));
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid remote device info", (uint8_t *)&buf, 2u);
        }
      }

      int v6 = *(_DWORD *)(a1 + 132) + 1;
    }
    *(_DWORD *)(a1 + 132) = v6;
    return sub_10024924C(a2, 0);
  }
}

void sub_100D6A250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  _Unwind_Resume(a1);
}

void sub_100D6A2E8(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 132);
  if (a2)
  {
    *(_DWORD *)(a1 + 132) = v3 + 1;
  }
  else if (v3)
  {
    int v4 = v3 - 1;
    *(_DWORD *)(a1 + 132) = v4;
    if (!v4)
    {
      sub_100D6A3AC(a1);
      sub_100D6A42C((id *)a1);
    }
  }
  else
  {
    uint64_t v5 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "unbalance assertion", v6, 2u);
    }
  }
}

void sub_100D6A3AC(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 104) templateSession];
  [v2 invalidate];

  [*(id *)(a1 + 104) setTemplateSession:0];
  [*(id *)(a1 + 104) invalidate];
  int v3 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0;

  int v4 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0;
}

void sub_100D6A41C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D6A42C(id *a1)
{
  uint64_t v2 = sub_100200FB4(a1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I invalidate SKSetupSIMTransferClient", v5, 2u);
  }

  [a1[12] invalidate];
  id v3 = a1[12];
  a1[12] = 0;

  [a1[15] invalidate];
  id v4 = a1[15];
  a1[15] = 0;
}

void sub_100D6A4C4(uint64_t a1, uint64_t *a2)
{
  id v4 = (id *)(a1 + 40);
  uint64_t v5 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v6 = a2;
    }
    else {
      int v6 = (uint64_t *)*a2;
    }
    int v11 = 136315138;
    long long v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I post auth code : %s", (uint8_t *)&v11, 0xCu);
  }

  if (*(void *)(a1 + 96))
  {
    id v7 = objc_alloc(off_101B0B250());
    if (*((char *)a2 + 23) >= 0) {
      xpc_object_t v8 = a2;
    }
    else {
      xpc_object_t v8 = (uint64_t *)*a2;
    }
    id v9 = +[NSString stringWithUTF8String:v8];
    id v10 = [v7 initWithPassword:v9];

    [*(id *)(a1 + 96) postEvent:v10];
  }
  else
  {
    id v10 = sub_100200FB4(v4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "invalid SKSetupSIMTransferClient", (uint8_t *)&v11, 2u);
    }
  }
}

void sub_100D6A63C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D6A660(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v4 = *(void **)(a1 + 104);
  if (v4) {
    goto LABEL_11;
  }
  id v5 = objc_alloc_init((Class)NSMutableDictionary);
  int v6 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v5;

  id v7 = objc_alloc_init((Class)CUMessageSessionServer);
  xpc_object_t v8 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = v7;

  id v9 = sub_100200FB4((id *)(a1 + 24));
  [*(id *)(a1 + 104) setDispatchQueue:v9];

  id v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v10 || (uint64_t v11 = *(void *)(a1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    sub_100088B9C();
  }
  int v13 = v12;
  p_shared_weak_owners = &v12->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v26 = 3321888768;
  long long v27 = sub_100D6B4AC;
  id v28 = &unk_101A55908;
  uint64_t v29 = a1;
  uint64_t v30 = v11;
  uint64_t v31 = v13;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  [*(id *)(a1 + 104) setRegisterRequestHandler:buf];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3321888768;
  void v23[2] = sub_100D6B590;
  v23[3] = &unk_101A55938;
  v23[4] = a1;
  v23[5] = v11;
  uint64_t v24 = v13;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  [*(id *)(a1 + 104) setSendRequestHandler:v23];
  id v15 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v22[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I activate CUMessageSessionServer", (uint8_t *)v22, 2u);
  }

  [*(id *)(a1 + 104) activate];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  xpc_object_t v22[2] = sub_100D6B89C;
  void v22[3] = &unk_101A55968;
  v22[4] = a1;
  uint64_t v16 = objc_retainBlock(v22);
  uint64_t v17 = *(void **)(a1 + 112);
  size_t v18 = +[NSString stringWithUTF8String:"kUpdateProxCardVisibilityReq"];
  [v17 setObject:v16 forKeyedSubscript:v18];

  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  if (v31) {
    std::__shared_weak_count::__release_weak(v31);
  }
  std::__shared_weak_count::__release_weak(v13);
  id v4 = *(void **)(a1 + 104);
  if (v4)
  {
LABEL_11:
    *a2 = 0;
    a2[1] = 0;
    uint64_t v19 = [v4 templateSession];
    int v20 = operator new(0x20uLL);
    v20[1] = 0;
    xpc_object_t v20[2] = 0;
    *int v20 = off_1019AF4C8;
    v20[3] = v19;
    *a2 = v20 + 3;
    a2[1] = v20;
  }
  else
  {
    uint64_t v21 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid message server", buf, 2u);
    }

    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_100D6A984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  std::__shared_weak_count::__release_weak(v27);
  _Unwind_Resume(a1);
}

void sub_100D6A9E8(uint64_t a1)
{
  (***(void (****)(Registry **__return_ptr))(a1 + 64))(&v4);
  Registry::getTimerService(&v6, v4);
  uint64_t v1 = v6;
  sub_100058DB0(v2, "reset.prx.ext");
  int v10[3] = v10;
  *(_OWORD *)long long __p = *(_OWORD *)v2;
  uint64_t v9 = v3;
  v10[0] = off_101A55BD8;
  v2[0] = 0;
  v2[1] = 0;
  uint64_t v3 = 0;
  sub_1000DA470((uint64_t)v11, (uint64_t)v10);
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, void *))(*(void *)v1 + 32))(v1, __p, 2, 1000000, v11);
  sub_10003B34C(v11);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_10003B34C(v10);
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100D6AB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26)
{
  sub_10003B34C((void *)(v26 - 56));
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_10003B34C(&a26);
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100D6ABB8(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

void sub_100D6ABC8(void *a1, void *a2)
{
  id v15 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v4 = a1[4];
    id v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[5])
      {
        id v7 = v15;
        xpc_object_t v8 = sub_100200FB4((id *)(v4 + 40));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handle SKEvent : %@", buf, 0xCu);
        }

        uint64_t v9 = sub_1001DA7B0(v7);
        id v10 = v9;
        CFTypeRef cf = v9;
        if (v9) {
          CFRetain(v9);
        }
        *(_OWORD *)long long buf = 0uLL;
        (***(void (****)(uint8_t *__return_ptr))(v4 + 64))(v20);
        Registry::getNotificationSenderFactory((uint64_t *)&v22, *(Registry **)v20);
        uint64_t v11 = v22;
        (***(void (****)(Registry **__return_ptr))(v4 + 64))(&v16);
        Registry::getTimerService(&v18, v16);
        (*(void (**)(uint8_t *__return_ptr, const void *, uint64_t *, uint64_t))(*(void *)v11 + 160))(buf, v11, &v18, v4 + 24);
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v17) {
          sub_10004D2C8(v17);
        }
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
        uint64_t v12 = *(void *)buf;
        CFTypeRef v22 = cf;
        if (cf) {
          CFRetain(cf);
        }
        (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v12 + 32))(v12, &v22);
        sub_100057D78(&v22);
        id v13 = v7;
        if ([v13 eventType] == 41 || objc_msgSend(v13, "eventType") == 30)
        {
          int v14 = sub_100200FB4((id *)(v4 + 40));
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int v20 = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I connection end or invalidated. reset", v20, 2u);
          }

          sub_100D69CC4(v4, 1);
        }

        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        sub_100057D78(&cf);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D6AEB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D6AF78(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D6AF94(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D6AFA4(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (std::__shared_weak_count *)a1[6];
  if (!v13)
  {
    id v15 = 0;
    goto LABEL_8;
  }
  uint64_t v14 = a1[4];
  id v15 = std::__shared_weak_count::lock(v13);
  if (!v15 || !a1[5])
  {
LABEL_8:
    CFTypeRef v22 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6740 userInfo:0];
    (*((void (**)(id, void, void, void *, Block_layout *))v12 + 2))(v12, 0, 0, v22, &stru_101A55898);

    if (!v15) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  id v26 = 0;
  id v27 = 0;
  sub_1001DA720(v10, (uint64_t *)&v26);
  id v16 = v27;
  id v17 = v26;
  id v25 = v16;
  id v18 = v11;
  id v19 = v12;
  if (v17)
  {
    int v20 = [*(id *)(v14 + 112) objectForKeyedSubscript:v17];
    if (v20)
    {
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      uint64_t v29 = sub_100D6BCF8;
      uint64_t v30 = &unk_1019AF2B0;
      id v31 = v19;
      ((void (**)(void, id, id, long long *))v20)[2](v20, v18, v25, &buf);
      uint64_t v21 = v31;
    }
    else
    {
      uint64_t v24 = sub_100200FB4((id *)(v14 + 40));
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "missing handler for requestID : %@", (uint8_t *)&buf, 0xCu);
      }

      uint64_t v21 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6745 userInfo:0];
      (*((void (**)(id, void, void, void *, Block_layout *))v19 + 2))(v19, 0, 0, v21, &stru_101A559A8);
    }
  }
  else
  {
    uint64_t v23 = sub_100200FB4((id *)(v14 + 40));
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "invalid requestID from remote", (uint8_t *)&buf, 2u);
    }

    int v20 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6705 userInfo:0];
    (*((void (**)(id, void, void, void (**)(void, void, void, void), Block_layout *))v19
     + 2))(v19, 0, 0, v20, &stru_101A55988);
  }

LABEL_18:
  sub_10004D2C8(v15);
LABEL_19:
}

void sub_100D6B304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_100D6B3B8(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "s.prx.tr.ctr");
    uint64_t v3 = *(id *)&v5[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138412290;
      *(void *)id v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "register request CTRequest failed : %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_100D6B494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D6B4AC(void *a1, void *a2, void *a3, void *a4)
{
  id v14 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = (std::__shared_weak_count *)a1[6];
  if (v9)
  {
    uint64_t v10 = a1[4];
    id v11 = std::__shared_weak_count::lock(v9);
    if (v11)
    {
      id v12 = v11;
      if (a1[5])
      {
        id v13 = objc_retainBlock(v8);
        [*(id *)(v10 + 112) setObject:v13 forKeyedSubscript:v14];
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_100D6B568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_100D6B590(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v31 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  id v12 = (std::__shared_weak_count *)a1[6];
  if (v12)
  {
    uint64_t v13 = a1[4];
    id v14 = std::__shared_weak_count::lock(v12);
    if (v14)
    {
      id v15 = v14;
      if (a1[5])
      {
        id v16 = v31;
        id v17 = v9;
        id v30 = v10;
        id v29 = v11;
        id v27 = v16;
        id v28 = v15;
        id v18 = sub_100200FB4((id *)(v13 + 40));
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v17;
          *(_WORD *)&unsigned char buf[22] = 2112;
          uint64_t v33 = v30;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I forward %@ opt:%@ req:%@", buf, 0x20u);
        }

        id v19 = *(std::__shared_weak_count **)(v13 + 16);
        if (!v19 || (uint64_t v20 = *(void *)(v13 + 8), (v21 = std::__shared_weak_count::lock(v19)) == 0)) {
          sub_100088B9C();
        }
        CFTypeRef v22 = v21;
        p_shared_weak_owners = &v21->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        uint64_t v24 = sub_1001DA62C(v16, v30);
        id v25 = *(void **)(v13 + 96);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3321888768;
        *(void *)&uint8_t buf[16] = sub_100D6BED8;
        uint64_t v33 = &unk_101A559F0;
        uint64_t v35 = v13;
        uint64_t v36 = v20;
        uint64_t v37 = v22;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        id v26 = v29;
        id v34 = v26;
        [v25 sendRequestID:@"CTProximityTransferRequestID" requestMessage:v24 options:v17 responseHandler:buf];

        id v15 = v28;
        if (v37) {
          std::__shared_weak_count::__release_weak(v37);
        }

        std::__shared_weak_count::__release_weak(v22);
      }
      sub_10004D2C8(v15);
    }
  }
}

void sub_100D6B814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, std::__shared_weak_count *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }

  std::__shared_weak_count::__release_weak(v22);
  sub_10004D2C8(a10);

  _Unwind_Resume(a1);
}

void sub_100D6B89C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)long long buf = v8;
  if (v8) {
    CFRetain(v8);
  }
  unsigned int v11 = sub_100CD8BB4((id *)buf);
  sub_100057D78((const void **)buf);
  id v12 = sub_100200FB4((id *)(v10 + 40));
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "hide";
    if (v11) {
      uint64_t v13 = "show";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received %s prox card request", buf, 0xCu);
  }

  if (v11)
  {
    if (*(unsigned char *)(v10 + 129))
    {
      id v14 = sub_100200FB4((id *)(v10 + 40));
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Screen locked. Not showing transfer prox card", buf, 2u);
      }
    }
    else
    {
      *(void *)id v27 = @"ResumeTransferProxCardKey";
      *(void *)long long buf = &__kCFBooleanTrue;
      id v14 = +[NSDictionary dictionaryWithObjects:buf forKeys:v27 count:1];
      [*(id *)(v10 + 120) invalidate];
      uint64_t v17 = +[RemoteUILaunchHelper launchRemoteUI:@"com.apple.SIMSetupUIService" viewController:@"TSProximitySIMTransferViewController" reason:@"resume transfer prox card" userInfo:v14 observer:0];
      id v18 = *(void **)(v10 + 120);
      *(void *)(v10 + 120) = v17;
    }
  }
  else
  {
    *(_OWORD *)long long buf = 0uLL;
    (***(void (****)(Registry **__return_ptr))(v10 + 64))(&v25);
    Registry::getNotificationSenderFactory((uint64_t *)v27, v25);
    uint64_t v15 = *(void *)v27;
    (***(void (****)(Registry **__return_ptr))(v10 + 64))(&v21);
    Registry::getTimerService(&v23, v21);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t *, uint64_t))(*(void *)v15 + 160))(buf, v15, &v23, v10 + 24);
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v26) {
      sub_10004D2C8(v26);
    }
    uint64_t v16 = *(void *)buf;
    if (*(void *)buf)
    {
      sub_100CD8CA8(0, &v20);
      (*(void (**)(uint64_t, const void **))(*(void *)v16 + 40))(v16, &v20);
      sub_100057D78(&v20);
    }
    else
    {
      id v19 = sub_100200FB4((id *)(v10 + 40));
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v27 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "invalid CellularPlanManagementSender", v27, 2u);
      }
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
}

void sub_100D6BC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }

  _Unwind_Resume(a1);
}

void sub_100D6BCF8(uint64_t a1, int a2, void *a3, void *a4)
{
  id v10 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  if (a2)
  {
    id v9 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:a2 userInfo:0];
  }
  else
  {
    id v9 = 0;
  }
  (*(void (**)(uint64_t, id, id, void *, Block_layout *))(v8 + 16))(v8, v7, v10, v9, &stru_101A559C8);
  if (a2) {
}
  }

void sub_100D6BDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100D6BDE4(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "s.prx.tr.ctr");
    uint64_t v3 = *(id *)&v5[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138412290;
      *(void *)id v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "send response error : %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_100D6BEC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D6BED8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    id v12 = std::__shared_weak_count::lock(v10);
    if (v12)
    {
      uint64_t v13 = v12;
      if (*(void *)(a1 + 48))
      {
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3221225472;
        v21[2] = sub_100D6C0C0;
        v21[3] = &unk_1019AF2D8;
        id v25 = *(id *)(a1 + 32);
        id v22 = v9;
        id v23 = v8;
        id v24 = v7;
        id v14 = v21;
        uint64_t v15 = *(std::__shared_weak_count **)(v11 + 16);
        if (!v15 || (uint64_t v16 = *(void *)(v11 + 8), (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
          sub_100088B9C();
        }
        id v18 = v17;
        id v19 = sub_100200FB4((id *)(v11 + 24));
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_100D6CCA8;
        block[3] = &unk_101A55C78;
        uint64_t v28 = v16;
        id v29 = v18;
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v20 = v14;
        id v27 = v20;
        dispatch_async(v19, block);

        if (v29) {
          sub_10004D2C8(v29);
        }
        sub_10004D2C8(v18);
      }
      sub_10004D2C8(v13);
    }
  }
}

uint64_t sub_100D6C0C0(void *a1)
{
  uint64_t v2 = a1[7];
  uint64_t v3 = NSErrorToOSStatus();
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 16);

  return v6(v2, v3, v4, v5);
}

uint64_t sub_100D6C110(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D6C12C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

Class sub_100D6C13C()
{
  if (qword_101B12B40 != -1) {
    dispatch_once(&qword_101B12B40, &stru_101A55B38);
  }
  Class result = objc_getClass("SKAuthenticationResponseEvent");
  qword_101B12B38 = (uint64_t)result;
  off_101B0B250 = (uint64_t (*)())sub_100D6C1A0;
  return result;
}

id sub_100D6C1A0()
{
  return (id)qword_101B12B38;
}

void sub_100D6C1AC(id a1)
{
  qword_101B12B20 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/SetupKit.framework/SetupKit", 2);
}

Class sub_100D6C1D8()
{
  if (qword_101B12B50 != -1) {
    dispatch_once(&qword_101B12B50, &stru_101A55B58);
  }
  Class result = objc_getClass("CBDevice");
  qword_101B12B48 = (uint64_t)result;
  off_101B0B260 = (uint64_t (*)())sub_100D6C23C;
  return result;
}

id sub_100D6C23C()
{
  return (id)qword_101B12B48;
}

void sub_100D6C248(id a1)
{
  qword_101B12B28 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CoreBluetooth.framework/CoreBluetooth", 2);
}

Class sub_100D6C274()
{
  if (qword_101B12B40 != -1) {
    dispatch_once(&qword_101B12B40, &stru_101A55B38);
  }
  Class result = objc_getClass("SKDevice");
  qword_101B12B58 = (uint64_t)result;
  off_101B0B268 = (uint64_t (*)())sub_100D6C2D8;
  return result;
}

id sub_100D6C2D8()
{
  return (id)qword_101B12B58;
}

Class sub_100D6C2E4()
{
  if (qword_101B12B40 != -1) {
    dispatch_once(&qword_101B12B40, &stru_101A55B38);
  }
  Class result = objc_getClass("SKSetupSIMTransferClient");
  qword_101B12B60 = (uint64_t)result;
  off_101B0B270 = (uint64_t (*)())sub_100D6C348;
  return result;
}

id sub_100D6C348()
{
  return (id)qword_101B12B60;
}

void sub_100D6C354(char *a1@<X1>, const void **a2@<X2>, id *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  id v10 = operator new(0xA0uLL);
  sub_100D6C3E8(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_1000B3BC8((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_100D6C3D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100D6C3E8(void *a1, char *a2, const void **a3, id *a4, uint64_t *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A55B88;
  sub_100D6C4E0((uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_100D6C430(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D6C444(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A55B88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D6C464(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A55B88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D6C4B8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100D6C4E0(uint64_t a1, char *a2, const void **a3, id *a4, uint64_t *a5)
{
  char v8 = *a2;
  sub_100058198(&v20, a3);
  id v9 = *a4;
  uint64_t v11 = *a5;
  id v10 = (std::__shared_weak_count *)a5[1];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)a1 = off_101A55A30;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  id v12 = v9;
  *(void *)(a1 + 24) = v12;
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), kCtLoggingSystemName, "s.prx.tr.ctr");
  *(void *)a1 = off_101A55820;
  *(unsigned char *)(a1 + 48) = v8;
  sub_100058198((const void **)(a1 + 56), &v20);
  *(void *)(a1 + 64) = v11;
  *(void *)(a1 + 72) = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CellularPlanSourceProximityTransportControllerImpl");
  id v13 = v12;
  id v23 = 0;
  id v24 = v13;
  ctu::RestModule::RestModule();
  id v14 = v23;
  id v23 = 0;

  id v15 = v24;
  id v24 = 0;

  if (v26 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  uint64_t v16 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(unsigned __int8 *)(a1 + 48);
    id v18 = "kUnknown";
    if (v17 == 1) {
      id v18 = "kSource";
    }
    if (v17 == 2) {
      id v18 = "kTarget";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)uint64_t v28 = v18;
    *(_WORD *)&unsigned __int8 v28[8] = 2112;
    *(void *)&v28[10] = v20;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I create proximity transfer controller for : %s, remote device : %@", buf, 0x16u);
  }

  (***(void (****)(Registry **__return_ptr))(a1 + 64))(&v21);
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)buf, v21);
  ctu::RestModule::connect();
  if (*(void *)&v28[4]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v28[4]);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_1009E2ECC(a1 + 128);
  if (v10) {
    sub_10004D2C8(v10);
  }

  sub_100057D78(&v20);
  return a1;
}

void sub_100D6C7B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21)
{
  uint64_t v28 = *(std::__shared_weak_count **)(v21 + 88);
  if (v28) {
    sub_10004D2C8(v28);
  }
  id v29 = *(std::__shared_weak_count **)(v21 + 72);
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_100057D78(v26);
  ctu::OsLogLogger::~OsLogLogger(v25);
  sub_1004FDE68(v24);
  if (v22) {
    sub_10004D2C8(v22);
  }

  sub_100057D78((const void **)&a9);
  _Unwind_Resume(a1);
}

void sub_100D6C8B0()
{
}

void *sub_100D6C8C4()
{
  Class result = operator new(0x10uLL);
  *Class result = off_101A55BD8;
  return result;
}

void sub_100D6C8FC(uint64_t a1, void *a2)
{
  *a2 = off_101A55BD8;
}

void sub_100D6C924()
{
  id v0 = objc_alloc_init(off_101B0B258());
  if (objc_opt_respondsToSelector())
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "s.prx.tr.ctr");
    uint64_t v1 = (id)v4;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v3) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "reset CBExtension", (uint8_t *)&v3, 2u);
    }

    uint64_t v3 = _NSConcreteStackBlock;
    uint64_t v4 = 3221225472;
    uint64_t v5 = sub_100D6CB2C;
    uint64_t v6 = &unk_101A55C40;
    id v7 = v0;
    [v7 resetCBExtensionID:@"com.apple.SIMSetupUIService" completionHandler:&v3];
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "s.prx.tr.ctr");
    uint64_t v2 = (id)v4;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v3) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "missing @selector(resetCBExtensionID:completionHandler:)", (uint8_t *)&v3, 2u);
    }

    [v0 invalidate];
  }
}

void sub_100D6CAB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100D6CAE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6CB20()
{
}

void sub_100D6CB2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v5, kCtLoggingSystemName, "s.prx.tr.ctr");
    uint64_t v4 = *(id *)&v6[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 138412290;
      *(void *)uint64_t v6 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "resetCBExtension failed : %@", (uint8_t *)&v5, 0xCu);
    }
  }
  [*(id *)(a1 + 32) invalidate];
}

void sub_100D6CC1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

Class sub_100D6CC38()
{
  if (qword_101B12B50 != -1) {
    dispatch_once(&qword_101B12B50, &stru_101A55B58);
  }
  Class result = objc_getClass("CBController");
  qword_101B12B68 = (uint64_t)result;
  off_101B0B258 = (uint64_t (*)())sub_100D6CC9C;
  return result;
}

id sub_100D6CC9C()
{
  return (id)qword_101B12B68;
}

uint64_t sub_100D6CCA8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100D6CCB8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D6CCD4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100D6CCE4()
{
}

void NetworkUsageStrategy::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D6CEEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_100D6D058(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A55CB8;
  shared_owners = this[1].__shared_owners_;
  if (shared_owners) {
    dispatch_release(shared_owners);
  }

  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D6D0B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A55CB8;
  shared_owners = this[1].__shared_owners_;
  if (shared_owners) {
    dispatch_release(shared_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(this);

  operator delete();
}

void sub_100D6D124(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100D6D1F8;
    block[3] = &unk_1019A1BF8;
    void block[4] = v2;
    dispatch_async(*(dispatch_queue_t *)(v2 + 24), block);
  }
  id v3 = *(NSObject **)(a1 + 32);
  if (v3) {
    dispatch_release(v3);
  }
}

uint64_t sub_100D6D1B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 32;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D6D1F8(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32));
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v3();
  }
  return result;
}

void *sub_100D6D284(void *a1, dispatch_object_t *a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "lazuli.reg.ctr");
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v6 = *a2;
  a1[3] = *a2;
  if (v6) {
    dispatch_retain(v6);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  v15[0] = off_101999E18;
  v15[1] = sub_100D6D690;
  v15[3] = v15;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v15);
  *a1 = off_101A55D18;
  sub_100058DB0(&__p, "lazuli.reg.ctr");
  uint64_t v11 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::RestModule::RestModule();
  if (v11) {
    dispatch_release(v11);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  a1[9] = *a3;
  uint64_t v8 = a3[1];
  a1[10] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  DefaultLazuliRegistrationInitializerMap = GetDefaultLazuliRegistrationInitializerMap();
  sub_1001FE2D0(a1 + 11, (uint64_t)DefaultLazuliRegistrationInitializerMap);
  a1[19] = 0;
  a1[17] = 0;
  a1[18] = a1 + 19;
  a1[22] = 0;
  a1[23] = 0;
  a1[20] = 0;
  a1[21] = a1 + 22;
  return a1;
}

void sub_100D6D54C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_100D6D690(int a1)
{
  uint64_t v1 = "lazuli.reg.ctr.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.reg.ctr.2";
  }
  if (a1 == 1) {
    return "lazuli.reg.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_100D6D6BC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Powering on", buf, 2u);
  }
  if ((ctu::RestModule::isConnected((ctu::RestModule *)(a1 + 56)) & 1) == 0)
  {
    Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(a1 + 72));
    ctu::RestModule::connect();
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_100058DB0(__p, "/cc/props/lazuli_registration_initializer");
  id v3 = (uint8_t *)operator new(0x28uLL);
  *(void *)id v3 = off_101A55EC8;
  *((void *)v3 + 1) = a1 + 88;
  *((void *)v3 + 2) = a1;
  *((void *)v3 + 3) = sub_100D6DA60;
  *((void *)v3 + 4) = 0;
  id v12 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = (uint8_t *)(a1 + 112);
  *(void *)long long buf = off_101A55F48;
  uint64_t v11 = a1 + 56;
  id v12 = buf;
  if (buf != (uint8_t *)(a1 + 112))
  {
    int v5 = *(uint8_t **)(a1 + 136);
    if (v5 == v4)
    {
      __p[1] = (void *)(a1 + 56);
      uint64_t v14 = 0;
      id v12 = 0;
      __p[0] = off_101A55F48;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 24))(a1 + 112, buf);
      (*(void (**)(void))(**(void **)(a1 + 136) + 32))(*(void *)(a1 + 136));
      *(void *)(a1 + 136) = 0;
      id v12 = buf;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, a1 + 112);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(a1 + 112) = off_101A55F48;
      *(void *)(a1 + 120) = a1 + 56;
      id v12 = v5;
    }
    *(void *)(a1 + 136) = v4;
  }
  sub_100D6F2C0(buf);
  uint64_t v6 = *(void *)(a1 + 136);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 144);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_registration_state");
  id v7 = (uint8_t *)operator new(0x28uLL);
  *(void *)id v7 = off_101A55FD8;
  *((void *)v7 + 1) = a1 + 168;
  *((void *)v7 + 2) = a1;
  *((void *)v7 + 3) = sub_100D6E6BC;
  *((void *)v7 + 4) = 0;
  id v12 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D6DA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D6DA60(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 104) == a2[2])
  {
    id v3 = *(void **)(a1 + 88);
    uint64_t v4 = (void *)(a1 + 96);
    if (v3 == (void *)(a1 + 96)) {
      return;
    }
    int v5 = (void *)*a2;
    while (*((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8)
         && sub_1007ACBA8((unsigned __int8 *)v3 + 40, (unsigned __int8 *)v5 + 40))
    {
      uint64_t v6 = (void *)v3[1];
      id v7 = v3;
      if (v6)
      {
        do
        {
          id v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          id v3 = (void *)v7[2];
          BOOL v29 = *v3 == (void)v7;
          id v7 = v3;
        }
        while (!v29);
      }
      uint64_t v8 = (void *)v5[1];
      if (v8)
      {
        do
        {
          id v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          id v9 = (void *)v5[2];
          BOOL v29 = *v9 == (void)v5;
          int v5 = v9;
        }
        while (!v29);
      }
      int v5 = v9;
      if (v3 == v4) {
        return;
      }
    }
  }
  int v68 = 0;
  v69[0] = 0;
  id v10 = (uint64_t **)(a1 + 144);
  v69[1] = 0;
  sub_100D6FC00((uint64_t)&v68, (void *)(a1 + 144));
  uint64_t v11 = *(void ***)(a1 + 144);
  if (v11 != (void **)(a1 + 152))
  {
    id v12 = (uint64_t *)(a1 + 96);
    do
    {
      uint64_t v13 = SlotIdFromPersonalityId();
      uint64_t v14 = *v12;
      if (!*v12) {
        goto LABEL_30;
      }
      uint64_t v15 = a1 + 96;
      do
      {
        int v16 = *(_DWORD *)(v14 + 32);
        BOOL v17 = v16 < (int)v13;
        if (v16 >= (int)v13) {
          id v18 = (uint64_t *)v14;
        }
        else {
          id v18 = (uint64_t *)(v14 + 8);
        }
        if (!v17) {
          uint64_t v15 = v14;
        }
        uint64_t v14 = *v18;
      }
      while (*v18);
      if ((uint64_t *)v15 == v12 || (int)v13 < *(_DWORD *)(v15 + 32))
      {
LABEL_30:
        id v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Erasing registration information...", buf, 2u);
        }
        sub_100D6FE38(&v68, v11 + 4);
      }
      uint64_t v20 = (void **)v11[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = (void **)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void **)v11[2];
          BOOL v29 = *v21 == v11;
          uint64_t v11 = v21;
        }
        while (!v29);
      }
      uint64_t v11 = v21;
    }
    while (v21 != (void **)(a1 + 152));
  }
  char v55 = (void **)(a1 + 152);
  id v22 = *(void **)(a1 + 88);
  if (v22 != (void *)(a1 + 96))
  {
    do
    {
      v66[0] = 0;
      v66[1] = 0;
      uint64_t v67 = 0;
      PersonalityIdFromSlotId();
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      *(_OWORD *)uint64_t v59 = 0u;
      *(_OWORD *)long long buf = 0u;
      *(_OWORD *)uint64_t v57 = 0u;
      std::string::operator=((std::string *)buf, (const std::string *)(v22 + 5));
      std::string::operator=((std::string *)&v57[1], (const std::string *)(v22 + 8));
      std::string::operator=((std::string *)v59, (const std::string *)(v22 + 14));
      std::string::operator=((std::string *)&__p[1], (const std::string *)(v22 + 17));
      if (&v62 != (long long *)(v22 + 20)) {
        sub_10005CA3C((uint64_t)&v62, (std::string *)v22[20], (long long *)v22[21], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22[21] - v22[20]) >> 3));
      }
      if ((void *)((char *)&v63 + 8) != v22 + 23) {
        sub_10005CA3C((uint64_t)&v63 + 8, (std::string *)v22[23], (long long *)v22[24], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22[24] - v22[23]) >> 3));
      }
      LODWORD(v65) = *((_DWORD *)v22 + 73);
      int v70 = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        id v25 = v70;
        int v70 = Mutable;
        *(void *)long long __dst = v25;
        sub_10005717C((const void **)__dst);
      }
      sub_100D6FAA0(v70, (const __CFString **)"CarrierBased", *((unsigned __int8 *)v22 + 289), kCFAllocatorDefault, v24);
      sub_100D6FAA0(v70, (const __CFString **)"BusinessMessagingProvisioned", *((unsigned __int8 *)v22 + 288), kCFAllocatorDefault, v26);
      uint64_t v28 = (char *)v22 + 284;
      if (!*((unsigned char *)v22 + 285)) {
        uint64_t v28 = (char *)v22 + 287;
      }
      if (*v28) {
        BOOL v29 = *((unsigned char *)v22 + 286) == 0;
      }
      else {
        BOOL v29 = 1;
      }
      int v30 = !v29;
      sub_100D6FAA0(v70, (const __CFString **)"BusinessMessagingEnabled", v30, kCFAllocatorDefault, v27);
      if (*((unsigned char *)v22 + 216)) {
        sub_100D6FB48(v70, (const __CFString **)"T1", (void *)v22[26], kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 232)) {
        sub_100D6FB48(v70, (const __CFString **)"T2", (void *)v22[28], kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 248)) {
        sub_100D6FB48(v70, (const __CFString **)"T4", (void *)v22[30], kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 264)) {
        sub_100D6FB48(v70, (const __CFString **)"SwitchoverSize", (void *)v22[32], kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 273)) {
        sub_100D6FAA0(v70, (const __CFString **)"PsSignalingTls", *((unsigned __int8 *)v22 + 272), kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 275)) {
        sub_100D6FAA0(v70, (const __CFString **)"PsMediaTls", *((unsigned __int8 *)v22 + 274), kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 277)) {
        sub_100D6FAA0(v70, (const __CFString **)"PsSignalingRoamingTls", *((unsigned __int8 *)v22 + 276), kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 279)) {
        sub_100D6FAA0(v70, (const __CFString **)"PsMediaRoamingTls", *((unsigned __int8 *)v22 + 278), kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 283)) {
        sub_100D6FAA0(v70, (const __CFString **)"WifiSignalingTls", *((unsigned __int8 *)v22 + 282), kCFAllocatorDefault, v31);
      }
      if (*((unsigned char *)v22 + 281)) {
        sub_100D6FAA0(v70, (const __CFString **)"WifiMediaTls", *((unsigned __int8 *)v22 + 280), kCFAllocatorDefault, v31);
      }
      uint64_t v32 = (void **)(v22 + 37);
      if (*((char *)v22 + 319) < 0)
      {
        unint64_t v34 = v22[38];
        if (!v34) {
          goto LABEL_84;
        }
        uint64_t v33 = v70;
        sub_10004FC84(__dst, *v32, v34);
      }
      else
      {
        if (!*((unsigned char *)v22 + 319)) {
          goto LABEL_84;
        }
        uint64_t v33 = v70;
        *(_OWORD *)long long __dst = *(_OWORD *)v32;
        uint64_t v72 = v22[39];
      }
      v75[0] = 0;
      ctu::cf::convert_copy((ctu::cf *)v75, (const __CFString **)"LazuliConferenceFactory", (const char *)0x8000100, kCFAllocatorDefault, v31);
      long long v74 = v75[0];
      v75[0] = 0;
      ctu::cf::convert_copy();
      BOOL v73 = v75[0];
      if (v74 && v75[0]) {
        CFDictionaryAddValue(v33, v74, v75[0]);
      }
      sub_10010F494(&v73);
      sub_10010F494(&v74);
      if (SHIBYTE(v72) < 0) {
        operator delete(*(void **)__dst);
      }
LABEL_84:
      if (CFDictionaryGetCount(v70) < 1)
      {
        uint64_t v36 = *((void *)&v65 + 1);
        *((void *)&v65 + 1) = 0;
        *(void *)long long __dst = v36;
        uint64_t v35 = (const void **)__dst;
      }
      else
      {
        sub_10004EFE4(v75, (CFTypeRef *)&v70);
        *(void *)long long __dst = *((void *)&v65 + 1);
        *((const void **)&v65 + 1) = v75[0];
        v75[0] = 0;
        sub_100057D78((const void **)__dst);
        uint64_t v35 = v75;
      }
      sub_100057D78(v35);
      sub_10005717C((const void **)&v70);
      uint64_t v37 = HIBYTE(v57[0]);
      if (SHIBYTE(v57[0]) < 0) {
        uint64_t v37 = *(void *)&buf[8];
      }
      if (!v37) {
        goto LABEL_106;
      }
      uint64_t v38 = HIBYTE(v58);
      if (v58 < 0) {
        uint64_t v38 = v58;
      }
      if (!v38 || (void)v62 == *((void *)&v62 + 1) || *((void *)&v63 + 1) == (void)v64) {
        goto LABEL_106;
      }
      char v39 = sub_100046F68(a1 + 144, v66);
      if (v55 == v39)
      {
        uint64_t v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v22 + 8));
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long __dst = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Adding registration information...", __dst, 2u);
        }
        *(void *)long long __dst = v66;
        uint64_t v41 = sub_100D6FF44(&v68, v66, (long long **)__dst);
        std::string::operator=((std::string *)(v41 + 7), (const std::string *)buf);
        std::string::operator=((std::string *)(v41 + 10), (const std::string *)&v57[1]);
        std::string::operator=((std::string *)(v41 + 13), (const std::string *)v59);
        std::string::operator=((std::string *)(v41 + 16), (const std::string *)&__p[1]);
        if (v41 + 7 != (uint64_t *)buf)
        {
LABEL_104:
          sub_10005CA3C((uint64_t)(v41 + 19), (std::string *)v62, *((long long **)&v62 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v62 + 1) - v62) >> 3));
          sub_10005CA3C((uint64_t)(v41 + 22), *((std::string **)&v63 + 1), (long long *)v64, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64 - *((void *)&v63 + 1)) >> 3));
        }
LABEL_105:
        *((_DWORD *)v41 + 50) = v65;
        sub_100058140((const void **)v41 + 26, (const void **)&v65 + 1);
        goto LABEL_106;
      }
      if ((sub_100593F38((unsigned __int8 *)v39 + 56, buf) & 1) == 0)
      {
        xpc_object_t v40 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v22 + 8));
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long __dst = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Updating registration information...", __dst, 2u);
        }
        *(void *)long long __dst = v66;
        uint64_t v41 = sub_100D6FF44(&v68, v66, (long long **)__dst);
        std::string::operator=((std::string *)(v41 + 7), (const std::string *)buf);
        std::string::operator=((std::string *)(v41 + 10), (const std::string *)&v57[1]);
        std::string::operator=((std::string *)(v41 + 13), (const std::string *)v59);
        std::string::operator=((std::string *)(v41 + 16), (const std::string *)&__p[1]);
        if (v41 + 7 != (uint64_t *)buf) {
          goto LABEL_104;
        }
        goto LABEL_105;
      }
LABEL_106:
      sub_100057D78((const void **)&v65 + 1);
      *(void *)long long __dst = (char *)&v63 + 8;
      sub_100047F64((void ***)__dst);
      *(void *)long long __dst = &v62;
      sub_100047F64((void ***)__dst);
      if (SHIBYTE(v61) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v59[0]);
      }
      if (SHIBYTE(v58) < 0) {
        operator delete(v57[1]);
      }
      if (SHIBYTE(v57[0]) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v67) < 0) {
        operator delete(v66[0]);
      }
      uint64_t v43 = (void *)v22[1];
      if (v43)
      {
        do
        {
          long long v44 = v43;
          uint64_t v43 = (void *)*v43;
        }
        while (v43);
      }
      else
      {
        do
        {
          long long v44 = (void *)v22[2];
          BOOL v29 = *v44 == (void)v22;
          id v22 = v44;
        }
        while (!v29);
      }
      id v22 = v44;
    }
    while (v44 != (void *)(a1 + 96));
  }
  *(void *)long long __dst = 1;
  *(void *)&__dst[8] = a1 + 112;
  if (v10 != &v68)
  {
    uint64_t v45 = v68;
    if (*(void *)(a1 + 160))
    {
      int v46 = *v10;
      *id v10 = (uint64_t *)v55;
      *((void *)*v55 + 2) = 0;
      *char v55 = 0;
      *(void *)(a1 + 160) = 0;
      if (v46[1]) {
        uint64_t v47 = v46[1];
      }
      else {
        uint64_t v47 = (uint64_t)v46;
      }
      *(void *)long long buf = v10;
      *(void *)&uint8_t buf[8] = v47;
      v57[0] = (void *)v47;
      if (!v47 || (*(void *)&uint8_t buf[8] = sub_1000EA590(v47), v45 == (uint64_t *)v69))
      {
        int v51 = v45;
      }
      else
      {
        do
        {
          std::string::operator=((std::string *)(v47 + 32), (const std::string *)(v45 + 4));
          std::string::operator=((std::string *)(v47 + 56), (const std::string *)(v45 + 7));
          std::string::operator=((std::string *)(v47 + 80), (const std::string *)(v45 + 10));
          std::string::operator=((std::string *)(v47 + 104), (const std::string *)(v45 + 13));
          std::string::operator=((std::string *)(v47 + 128), (const std::string *)(v45 + 16));
          if ((uint64_t *)v47 != v45)
          {
            sub_10005CA3C(v47 + 152, (std::string *)v45[19], (long long *)v45[20], 0xAAAAAAAAAAAAAAABLL * ((v45[20] - v45[19]) >> 3));
            sub_10005CA3C(v47 + 176, (std::string *)v45[22], (long long *)v45[23], 0xAAAAAAAAAAAAAAABLL * ((v45[23] - v45[22]) >> 3));
          }
          *(_DWORD *)(v47 + 200) = *((_DWORD *)v45 + 50);
          sub_100058140((const void **)(v47 + 208), (const void **)v45 + 26);
          uint64_t v48 = (uint64_t *)v57[0];
          v66[0] = 0;
          uint64_t v49 = (uint64_t **)sub_1000EA518((uint64_t)v10, v66, (void *)v57[0] + 4);
          sub_100046C38(v10, (uint64_t)v66[0], v49, v48);
          uint64_t v47 = *(void *)&buf[8];
          v57[0] = *(void **)&buf[8];
          if (*(void *)&buf[8]) {
            *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
          }
          int v50 = (uint64_t *)v45[1];
          if (v50)
          {
            do
            {
              int v51 = v50;
              int v50 = (uint64_t *)*v50;
            }
            while (v50);
          }
          else
          {
            do
            {
              int v51 = (uint64_t *)v45[2];
              BOOL v29 = *v51 == (void)v45;
              uint64_t v45 = v51;
            }
            while (!v29);
          }
          if (!v47) {
            break;
          }
          uint64_t v45 = v51;
        }
        while (v51 != (uint64_t *)v69);
      }
      sub_100D700C4((uint64_t)buf);
      uint64_t v45 = v51;
    }
    if (v45 != (uint64_t *)v69)
    {
      do
      {
        memset(buf, 0, sizeof(buf));
        v57[0] = 0;
        sub_100D6FD7C(buf, (uint64_t)v10, (uint64_t)(v45 + 4));
        v66[0] = 0;
        int v52 = (uint64_t **)sub_1000EA518((uint64_t)v10, v66, (void *)(*(void *)buf + 32));
        sub_100046C38(v10, (uint64_t)v66[0], v52, *(uint64_t **)buf);
        *(void *)long long buf = 0;
        sub_100732068((uint64_t)buf, 0);
        int v53 = (uint64_t *)v45[1];
        if (v53)
        {
          do
          {
            BOOL v54 = v53;
            int v53 = (uint64_t *)*v53;
          }
          while (v53);
        }
        else
        {
          do
          {
            BOOL v54 = (uint64_t *)v45[2];
            BOOL v29 = *v54 == (void)v45;
            uint64_t v45 = v54;
          }
          while (!v29);
        }
        uint64_t v45 = v54;
      }
      while (v54 != (uint64_t *)v69);
    }
  }
  sub_100D70060((uint64_t)__dst);
  sub_1007322F4((uint64_t)&v68, v69[0]);
}

void sub_100D6E600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100731DFC((uint64_t)va);
  if (*(char *)(v7 - 177) < 0) {
    operator delete(*(void **)(v7 - 200));
  }
  sub_1007322F4(v7 - 176, *(void **)(v7 - 168));
  _Unwind_Resume(a1);
}

void sub_100D6E6BC(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 184))
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 1);
    int v5 = (unsigned __int8 *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v6 = *(unsigned __int8 **)(a1 + 168);
    while (sub_10001D294(v5 + 32, v6 + 32) && sub_10047161C((uint64_t)(v5 + 56), (uint64_t)(v6 + 56)))
    {
      uint64_t v7 = (unsigned __int8 *)*((void *)v5 + 1);
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          int v5 = v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v5 = (unsigned __int8 *)*((void *)v8 + 2);
          BOOL v9 = *(void *)v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      id v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          id v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (unsigned __int8 *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  id v12 = *(void ***)(a1 + 168);
  if (v12 != (void **)(a1 + 176))
  {
    do
    {
      uint64_t v13 = sub_100046F68((uint64_t)a2, v12 + 4);
      if (a2 + 1 == v13)
      {
        if (*((_DWORD *)v12 + 14))
        {
LABEL_23:
          uint64_t v14 = SlotIdFromPersonalityId();
          uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = sd::asString();
            BOOL v17 = "over wifi";
            if (!*((unsigned char *)v12 + 64)) {
              BOOL v17 = "over cell";
            }
            id v18 = "";
            if (*((_DWORD *)v12 + 14) == 1) {
              id v18 = v17;
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v16;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v18;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I IMS registered: [%s] %s", buf, 0x16u);
          }
          if (*((_DWORD *)v12 + 14) == 1) {
            uint64_t v19 = 1;
          }
          else {
            uint64_t v19 = 2;
          }
          xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v21 = v20;
          if (v20)
          {
            xpc_object_t v37 = v20;
            goto LABEL_35;
          }
          xpc_object_t v21 = xpc_null_create();
          xpc_object_t v37 = v21;
          if (v21)
          {
LABEL_35:
            if (xpc_get_type(v21) != (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_object_t v22 = xpc_null_create();
              goto LABEL_39;
            }
            xpc_retain(v21);
          }
          else
          {
            xpc_object_t v22 = xpc_null_create();
            xpc_object_t v21 = 0;
LABEL_39:
            xpc_object_t v37 = v22;
          }
          xpc_release(v21);
          uint64_t v23 = subscriber::asString();
          ctu::rest::detail::write_enum_string_value((uint64_t *)&v35, (ctu::rest::detail *)(int)v14, v23, v24);
          *(void *)long long buf = &v37;
          *(void *)&uint8_t buf[8] = "first";
          sub_100035E70((uint64_t)buf, &v35, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v35);
          xpc_object_t v35 = 0;
          uint64_t v25 = Lazuli::asString();
          ctu::rest::detail::write_enum_string_value((uint64_t *)&v33, (ctu::rest::detail *)v19, v25, v26);
          *(void *)long long buf = &v37;
          *(void *)&uint8_t buf[8] = "second";
          sub_100035E70((uint64_t)buf, &v33, &v34);
          xpc_release(v34);
          xpc_object_t v34 = 0;
          xpc_release(v33);
          xpc_object_t v33 = 0;
          xpc_object_t v27 = v37;
          if (v37) {
            xpc_retain(v37);
          }
          else {
            xpc_object_t v27 = xpc_null_create();
          }
          xpc_release(v37);
          sub_100058DB0(buf, "/cc/events/lazuli_registration_state_changed");
          xpc_object_t v37 = v27;
          xpc_object_t v28 = xpc_null_create();
          ctu::RestModule::sendEvent();
          xpc_release(v37);
          xpc_object_t v37 = 0;
          if (v39 < 0) {
            operator delete(*(void **)buf);
          }
          xpc_release(v28);
          if (*((_DWORD *)v12 + 14) == 2)
          {
            xpc_object_t v37 = 0;
            uint64_t v29 = subscriber::asString();
            ctu::rest::detail::write_enum_string_value((uint64_t *)&v37, (ctu::rest::detail *)(int)v14, v29, v30);
            sub_100058DB0(buf, "/cc/events/lazuli_registration_disabled");
            xpc_object_t object = v37;
            xpc_object_t v37 = xpc_null_create();
            ctu::RestModule::sendEvent();
            xpc_release(object);
            xpc_object_t object = 0;
            if (v39 < 0) {
              operator delete(*(void **)buf);
            }
            xpc_release(v37);
          }
        }
      }
      else if (*((_DWORD *)v13 + 14) != *((_DWORD *)v12 + 14))
      {
        goto LABEL_23;
      }
      CFAllocatorRef v31 = (void **)v12[1];
      if (v31)
      {
        do
        {
          uint64_t v32 = v31;
          CFAllocatorRef v31 = (void **)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          uint64_t v32 = (void **)v12[2];
          BOOL v9 = *v32 == v12;
          id v12 = v32;
        }
        while (!v9);
      }
      id v12 = v32;
    }
    while (v32 != (void **)(a1 + 176));
  }
}

void sub_100D6EB5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, xpc_object_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D6EC44(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Tearing down", v2, 2u);
  }
}

uint64_t sub_100D6ECA4(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Tear down complete", (uint8_t *)&v4, 2u);
  }
  v5[0] = 0;
  v5[1] = 0;
  uint64_t v4 = v5;
  sub_100D6ED50(a1 + 14, &v4);
  sub_1007322F4((uint64_t)&v4, v5[0]);
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 7));
}

void sub_100D6ED38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void *sub_100D6ED50(void *result, void *a2)
{
  id v3 = result;
  if (result[6] == a2[2])
  {
    uint64_t v4 = (unsigned __int8 *)result[4];
    int v5 = (unsigned __int8 *)(result + 5);
    if (v4 == (unsigned __int8 *)(result + 5)) {
      return result;
    }
    uint64_t v6 = (unsigned __int8 *)*a2;
    while (sub_10001D294(v4 + 32, v6 + 32))
    {
      uint64_t result = sub_100593F38(v4 + 56, v6 + 56);
      if (!result) {
        break;
      }
      uint64_t v7 = (unsigned __int8 *)*((void *)v4 + 1);
      uint64_t v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (unsigned __int8 *)*((void *)v8 + 2);
          BOOL v9 = *(void *)v4 == (void)v8;
          uint64_t v8 = v4;
        }
        while (!v9);
      }
      id v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          id v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (unsigned __int8 *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v4 == v5) {
        return result;
      }
    }
  }
  id v12 = v3 + 5;
  sub_1007322F4((uint64_t)(v3 + 4), (void *)v3[5]);
  void v3[4] = *a2;
  uint64_t v13 = a2 + 1;
  uint64_t v14 = a2[1];
  v3[5] = v14;
  uint64_t v15 = a2[2];
  v3[6] = v15;
  if (v15)
  {
    *(void *)(v14 + 16) = v12;
    *a2 = v13;
    void *v13 = 0;
    a2[2] = 0;
  }
  else
  {
    void v3[4] = v12;
  }
  uint64_t result = (void *)v3[3];
  if (result)
  {
    uint64_t v16 = *(uint64_t (**)(void))(*result + 48);
    return (void *)v16();
  }
  return result;
}

uint64_t sub_100D6EECC(uint64_t a1, void **a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = sub_100046F68(a1 + 168, a2);
  if ((void **)(a1 + 176) == v4)
  {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  else
  {
    int v5 = *((_DWORD *)v4 + 14);
    if (v5 == 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = 2 * (v5 == 2);
    }
  }
  uint64_t v7 = SlotIdFromPersonalityId();
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)v2 + 23) < 0) {
      uint64_t v2 = (void **)*v2;
    }
    int v10 = 136315394;
    uint64_t v11 = v2;
    __int16 v12 = 2080;
    uint64_t v13 = Lazuli::asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Current registration state: [%s: %s]", (uint8_t *)&v10, 0x16u);
  }
  return v6;
}

void sub_100D6F00C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handling subscription removed", (uint8_t *)v10, 2u);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  PersonalityIdFromSlotId();
  int v5 = (void *)(a1 + 144);
  if ((void **)(a1 + 152) != sub_100046F68(a1 + 144, __p))
  {
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v7 = a1 + 112;
    uint64_t v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Resetting lazuli info", (uint8_t *)v10, 2u);
    }
    v10[0] = 1;
    long long v11 = 0u;
    uint64_t v12 = 0;
    v10[1] = v7;
    BOOL v9 = (void *)sub_100D6FC00((uint64_t)&v11, v5);
    sub_100D6FE38(v9, __p);
    sub_100D7011C((uint64_t)v10);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D6F18C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D6F1B8(uint64_t a1)
{
  sub_100D6F1F0(a1);

  operator delete();
}

uint64_t sub_100D6F1F0(uint64_t a1)
{
  *(void *)a1 = off_101A55D18;
  sub_10005CD2C(a1 + 168, *(char **)(a1 + 176));
  sub_1007322F4(a1 + 144, *(void **)(a1 + 152));
  sub_100D6F2C0((void *)(a1 + 112));
  sub_1001F701C(a1 + 88, *(void **)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  LazuliLifetimeInterface::~LazuliLifetimeInterface((LazuliLifetimeInterface *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void *sub_100D6F2C0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D6F344(dispatch_object_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xD8uLL);
  sub_100D6F3C0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_100D6F3AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100D6F3C0(void *a1, dispatch_object_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A55E38;
  sub_100D6F4B8(a1 + 3, a2, a3);
  return a1;
}

void sub_100D6F408(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D6F41C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A55E38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D6F43C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A55E38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D6F490(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

void *sub_100D6F4B8(void *a1, dispatch_object_t *a2, uint64_t *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a3[1];
  uint64_t v6 = *a3;
  uint64_t v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100D6D284(a1, a2, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

void sub_100D6F514(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D6F530()
{
}

uint64_t sub_100D6F544(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100D6F554()
{
}

__n128 sub_100D6F568(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55EC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D6F5BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55EC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D6F5F4(void *a1, xpc_object_t *a2)
{
  id v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_1001FF71C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1001F701C((uint64_t)&v9, v10);
}

void sub_100D6F6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100D6F6CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6F70C()
{
}

void sub_100D6F71C()
{
}

void *sub_100D6F730(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A55F48;
  result[1] = v3;
  return result;
}

uint64_t sub_100D6F778(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A55F48;
  a2[1] = v2;
  return result;
}

void sub_100D6F7A4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100731C90(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/lazuli_info_ready");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100D6F848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100D6F88C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6F8CC()
{
}

void sub_100D6F8DC()
{
}

__n128 sub_100D6F8F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A55FD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D6F944(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A55FD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D6F97C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  uint64_t v5 = v3[1];
  BOOL v9 = (char **)*v3;
  int v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *char v4 = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100D6FA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100D6FA54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D6FA94()
{
}

const void **sub_100D6FAA0(__CFDictionary *a1, const __CFString **a2, int a3, unsigned int a4, const __CFAllocator *a5)
{
  key = 0;
  ctu::cf::convert_copy((ctu::cf *)&key, a2, (const char *)0x8000100, a4, a5);
  uint64_t v7 = key;
  uint64_t v12 = key;
  uint64_t v8 = (void **)&kCFBooleanTrue;
  if (!a3) {
    uint64_t v8 = (void **)&kCFBooleanFalse;
  }
  BOOL v9 = *v8;
  key = *v8;
  if (v7) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    CFDictionaryAddValue(a1, v7, v9);
  }
  sub_10010F494((const void **)&key);
  return sub_10010F494((const void **)&v12);
}

void sub_100D6FB2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_100D6FB48(__CFDictionary *a1, const __CFString **a2, void *a3, const __CFAllocator *a4, const __CFAllocator *a5)
{
  valuePtr = 0;
  ctu::cf::convert_copy((ctu::cf *)&valuePtr, a2, (const char *)0x8000100, a4, a5);
  key = valuePtr;
  valuePtr = a3;
  CFNumberRef v8 = CFNumberCreate(a4, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v11 = v8;
  if (key) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    CFDictionaryAddValue(a1, key, v8);
  }
  sub_10010F494((const void **)&v11);
  return sub_10010F494((const void **)&key);
}

void sub_100D6FBDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D6FC00(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  char v4 = (void **)(a2 + 1);
  uint64_t v5 = (void **)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v15 = 0;
      uint64_t v6 = *(void **)(a1 + 8);
      if (*(void **)a1 == v3)
      {
        CFNumberRef v8 = v3;
        if (!v6) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v7 = v3;
        if (v6)
        {
          do
          {
            CFNumberRef v8 = v6;
            uint64_t v6 = (void *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            CFNumberRef v8 = (void *)v7[2];
            BOOL v9 = *v8 == (void)v7;
            uint64_t v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, v5 + 4) & 0x80) == 0)
        {
          BOOL v10 = (uint64_t **)sub_100046ED4(a1, &v15, v5 + 4);
          goto LABEL_11;
        }
        if (!*v3)
        {
LABEL_14:
          uint64_t v15 = v3;
          BOOL v10 = (uint64_t **)v3;
LABEL_15:
          memset(v14, 0, sizeof(v14));
          sub_100D6FD7C(v14, a1, (uint64_t)(v5 + 4));
          sub_100046C38((uint64_t **)a1, (uint64_t)v15, v10, v14[0]);
          v14[0] = 0;
          sub_100732068((uint64_t)v14, 0);
          goto LABEL_16;
        }
      }
      uint64_t v15 = v8;
      BOOL v10 = (uint64_t **)(v8 + 1);
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_16:
      CFNumberRef v11 = (void **)v5[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          CFNumberRef v11 = (void **)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void **)v5[2];
          BOOL v9 = *v12 == v5;
          uint64_t v5 = v12;
        }
        while (!v9);
      }
      uint64_t v5 = v12;
    }
    while (v12 != v4);
  }
  return a1;
}

void sub_100D6FD64(_Unwind_Exception *a1)
{
  sub_1007322F4(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100D6FD7C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v6 = operator new(0xD8uLL);
  uint64_t v7 = v6;
  *a1 = v6;
  a1[1] = v5;
  *((unsigned char *)a1 + 16) = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v6 + 32, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
  }
  __n128 result = sub_100731E90(v7 + 56, (long long *)(a3 + 24));
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_100D6FE08(_Unwind_Exception *a1)
{
  sub_100732068(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100D6FE38(void *a1, void **a2)
{
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    uint64_t v6 = a1 + 1;
    do
    {
      char v7 = sub_100046FE8(v3 + 4, a2);
      if (v7 >= 0) {
        CFNumberRef v8 = v3;
      }
      else {
        CFNumberRef v8 = v3 + 1;
      }
      if (v7 >= 0) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = (void *)*v8;
    }
    while (*v8);
    if (v6 != v2 && (sub_100046FE8(a2, (void **)v6 + 4) & 0x80) == 0)
    {
      BOOL v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        CFNumberRef v11 = v6;
        do
        {
          BOOL v10 = (void *)v11[2];
          BOOL v12 = *v10 == (void)v11;
          CFNumberRef v11 = v10;
        }
        while (!v12);
      }
      if ((void *)*a1 == v6) {
        *a1 = v10;
      }
      uint64_t v13 = (uint64_t *)a1[1];
      --a1[2];
      sub_10005EE6C(v13, v6);
      sub_1007320C0((uint64_t)(v6 + 4));
      operator delete(v6);
    }
  }
}

uint64_t *sub_100D6FF44(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v16 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v16, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    char v7 = v5;
    CFNumberRef v8 = *a3;
    uint64_t v15 = 0;
    BOOL v9 = (char *)operator new(0xD8uLL);
    v14[0] = v9;
    v14[1] = a1 + 1;
    BOOL v10 = v9 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v10, *(void **)v8, *((void *)v8 + 1));
      BOOL v12 = (uint64_t *)v14[0];
    }
    else
    {
      long long v11 = *v8;
      *((void *)v9 + 6) = *((void *)v8 + 2);
      *(_OWORD *)BOOL v10 = v11;
      BOOL v12 = (uint64_t *)v9;
    }
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    *(_OWORD *)(v9 + 152) = 0u;
    *(_OWORD *)(v9 + 136) = 0u;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_OWORD *)(v9 + 104) = 0u;
    *(_OWORD *)(v9 + 88) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    LOBYTE(v15) = 1;
    sub_100046C38(a1, v16, v7, v12);
    uint64_t v6 = (uint64_t *)v14[0];
    v14[0] = 0;
    sub_100732068((uint64_t)v14, 0);
  }
  return v6;
}

void sub_100D70048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100D70060(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100D700C4(uint64_t a1)
{
  sub_1007322F4(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1007322F4(*(void *)a1, v2);
  }
  return a1;
}

uint64_t sub_100D7011C(uint64_t a1)
{
  if (*(unsigned char *)a1) {
    sub_100D6ED50(*(void **)(a1 + 8), (void *)(a1 + 16));
  }
  sub_1007322F4(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_100D7036C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100D703AC(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (std::__shared_weak_count *)*((void *)WeakRetained + 4);
    if (v6)
    {
      char v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = v5[3];
        if (v8)
        {
          BOOL v9 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v10 = "BYTelephonySIMUnlockStateUnknown";
            if (a2 == 1) {
              BOOL v10 = "BYTelephonySIMUnlockStateAllowed";
            }
            if (a2 == 2) {
              BOOL v10 = "BYTelephonySIMUnlockStateDisallowed";
            }
            int v12 = 136315138;
            uint64_t v13 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I SIM unlock state updated to: %s", (uint8_t *)&v12, 0xCu);
          }

          (*(void (**)(uint64_t, BOOL))(*(void *)v8 + 32))(v8, a2 == 1);
LABEL_16:
          sub_10004D2C8(v7);
          goto LABEL_17;
        }
      }
    }
    else
    {
      char v7 = 0;
    }
    long long v11 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "delegate is invalid", (uint8_t *)&v12, 2u);
    }

    if (v7) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

void sub_100D70558(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);

  _Unwind_Resume(a1);
}

void sub_100D70714(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D70890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D70A40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D70C30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D70C40(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v5 = 134217984;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I remote alert did activate (%p)", (uint8_t *)&v5, 0xCu);
  }

  if (([*(id *)(a1 + 40) isEqual:*(void *)(*(void *)(a1 + 32) + 40)] & 1) == 0)
  {
    char v4 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I unknown remote alert handle, ignoring", (uint8_t *)&v5, 2u);
    }
  }
}

void sub_100D70E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D70E10(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v12 = 134217984;
    uint64_t v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I remote alert did deactivate (%p)", (uint8_t *)&v12, 0xCu);
  }

  unsigned __int8 v4 = [*(id *)(a1 + 40) isEqual:*(void *)(*(void *)(a1 + 32) + 40)];
  int v5 = *(id ***)(a1 + 32);
  if (v4)
  {
    [v5 _releaseRemoteAlertHandle];
    uint64_t v6 = *(void *)(a1 + 32);
    char v7 = *(std::__shared_weak_count **)(v6 + 32);
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        uint64_t v9 = *(void *)(v6 + 24);
        if (v9)
        {
          (*(void (**)(uint64_t))(*(void *)v9 + 56))(v9);
LABEL_15:
          sub_10004D2C8(v8);
          return;
        }
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    long long v11 = sub_100200FB4(*(id **)(*(void *)(a1 + 32) + 16));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "delegate is invalid", (uint8_t *)&v12, 2u);
    }

    if (v8) {
      goto LABEL_15;
    }
  }
  else
  {
    BOOL v10 = sub_100200FB4(v5[2]);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I unknown remote alert handle, ignoring", (uint8_t *)&v12, 2u);
    }
  }
}

void sub_100D70FDC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D710DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100D710F0(uint64_t a1)
{
  BOOL v2 = *(void *)(a1 + 32) == 0;
  uint64_t v3 = sub_100200FB4(*(id **)(*(void *)(a1 + 40) + 16));
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v7 = *(void *)(a1 + 48);
      int v17 = 134217984;
      uint64_t v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I remote alert did invalidate (%p)", (uint8_t *)&v17, 0xCu);
    }
  }
  else if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    id v6 = [*(id *)(a1 + 32) description];
    int v17 = 134218242;
    uint64_t v18 = v5;
    __int16 v19 = 2080;
    id v20 = [v6 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I remote alert did invalidate (%p) with error : %s", (uint8_t *)&v17, 0x16u);
  }
  unsigned __int8 v8 = [*(id *)(a1 + 48) isEqual:*(void *)(*(void *)(a1 + 40) + 40)];
  uint64_t v9 = *(id ***)(a1 + 40);
  if (v8)
  {
    [v9 _releaseRemoteAlertHandle];
    uint64_t v10 = *(void *)(a1 + 40);
    long long v11 = *(std::__shared_weak_count **)(v10 + 32);
    if (v11)
    {
      int v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        uint64_t v13 = *(void *)(v10 + 24);
        if (v13)
        {
          uint64_t v14 = *(void **)(a1 + 32);
          if (v14)
          {
            if ([v14 code] != (id)5) {
              (*(void (**)(uint64_t))(*(void *)v13 + 64))(v13);
            }
          }
LABEL_20:
          sub_10004D2C8(v12);
          return;
        }
      }
    }
    else
    {
      int v12 = 0;
    }
    uint64_t v16 = sub_100200FB4(*(id **)(*(void *)(a1 + 40) + 16));
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "delegate is invalid", (uint8_t *)&v17, 2u);
    }

    if (v12) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v15 = sub_100200FB4(v9[2]);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I unknown remote alert handle, ignoring", (uint8_t *)&v17, 2u);
    }
  }
}

void sub_100D71348(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100D71404(void *a1, id *a2, uint64_t a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A56080;
  a1[3] = *a2;
  a1[4] = a3;
  operator new();
}

void sub_100D714AC(_Unwind_Exception *a1)
{
  sub_100200A44(v2);
  BOOL v4 = (std::__shared_weak_count *)*((void *)v1 + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  SubscriberRemoteUILaunchHelperInterface::~SubscriberRemoteUILaunchHelperInterface(v1);
  _Unwind_Resume(a1);
}

void sub_100D714F4(uint64_t a1, uint64_t a2)
{
  BOOL v2 = **(void ***)(a1 + 40);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  [v2 bootstrapWithDelegate:v3];
  if (v3[1]) {
    std::__shared_weak_count::__release_weak(v3[1]);
  }
}

void sub_100D71540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

id sub_100D71558(uint64_t a1)
{
  return [**(id **)(a1 + 40) start];
}

const void **sub_100D71568@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v7 = Mutable;
  uint64_t v38 = Mutable;
  if (*(void *)a2) {
    unsigned __int8 v8 = sub_1000810B8;
  }
  else {
    unsigned __int8 v8 = 0;
  }
  if (v8)
  {
    CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, *(const void **)a2);
    uint64_t v7 = v38;
  }
  uint64_t v9 = *(const void **)(a2 + 24);
  if (v9) {
    uint64_t v10 = sub_1000810B8;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v10)
  {
    CFDictionarySetValue(v7, kCFUserNotificationAlertMessageKey, v9);
    uint64_t v7 = v38;
  }
  long long v11 = *(const void **)(a2 + 8);
  if (v11) {
    int v12 = sub_1000810B8;
  }
  else {
    int v12 = 0;
  }
  if (v12)
  {
    CFDictionarySetValue(v7, kCFUserNotificationDefaultButtonTitleKey, v11);
    uint64_t v7 = v38;
  }
  uint64_t v13 = *(const void **)(a2 + 16);
  if (v13) {
    uint64_t v14 = sub_1000810B8;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14)
  {
    CFDictionarySetValue(v7, kCFUserNotificationAlternateButtonTitleKey, v13);
    uint64_t v7 = v38;
  }
  char v15 = *(unsigned char *)(a2 + 56);
  if (v15)
  {
    CFDictionarySetValue(v7, kCFUserNotificationAlertTopMostKey, kCFBooleanTrue);
    char v15 = *(unsigned char *)(a2 + 56);
    uint64_t v7 = v38;
  }
  if ((v15 & 2) != 0)
  {
    CFDictionarySetValue(v7, SBUserNotificationAllowInSetupKey, kCFBooleanTrue);
    uint64_t v7 = v38;
  }
  SInt32 error = -1;
  CFUserNotificationRef v16 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 1uLL, &error, v7);
  CFTypeRef cf = v16;
  if (!error)
  {
    if (v16 ? sub_1001D8360 : 0)
    {
      id v20 = operator new(0x18uLL);
      *(void *)id v20 = 0;
      *((void *)v20 + 1) = 0;
      sub_1001D89F0((const void **)v20 + 2, &cf);
      uint64_t v21 = *(void *)(a1 + 48);
      *(void *)id v20 = v21;
      *((void *)v20 + 1) = a1 + 48;
      *(void *)(v21 + 8) = v20;
      *(void *)(a1 + 48) = v20;
      ++*(void *)(a1 + 64);
      sub_100058DB0(&v33, "subscriber-alert");
      unsigned int v22 = dword_101B12B70++;
      std::to_string(&__p, v22);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v25 = std::string::append(&v33, (const std::string::value_type *)p_p, size);
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      int64_t v35 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long buf = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
      xpc_object_t v27 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
      if (v35 >= 0) {
        xpc_object_t v28 = buf;
      }
      else {
        xpc_object_t v28 = *(uint8_t **)buf;
      }
      dispatch_queue_t v29 = dispatch_queue_create((const char *)v28, v27);

      v33.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
      if (cf) {
        CFRetain(cf);
      }
      std::string::size_type v30 = *(void *)(a1 + 16);
      v33.__r_.__value_.__l.__size_ = *(void *)(a1 + 8);
      v33.__r_.__value_.__r.__words[2] = v30;
      if (v30) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 16), 1uLL, memory_order_relaxed);
      }
      CFAllocatorRef v31 = v29;
      operator new();
    }
  }
  int v17 = sub_100200FB4(*(id **)(a1 + 32));
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I failed to create notification", buf, 2u);
  }

  *a3 = 0;
  sub_1001D88DC(&cf);
  return sub_10005717C((const void **)&v38);
}

void sub_100D71984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_1001D88DC(&a25);
  sub_10005717C((const void **)(v25 - 64));
  _Unwind_Resume(a1);
}

BOOL sub_100D719E4(uint64_t a1, void *a2)
{
  uint64_t v2 = a1 + 48;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3 == a1 + 48)
  {
LABEL_4:
    uint64_t v3 = a1 + 48;
  }
  else
  {
    while (*(void *)(v3 + 16) != *a2)
    {
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == v2) {
        goto LABEL_4;
      }
    }
  }
  return v2 != v3;
}

void sub_100D71A20(const void **a1, const void **a2)
{
  if (*a2) {
    uint64_t v2 = sub_1001D8360;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    sub_1001D89F0(&v6, a2);
    int v5 = (*((uint64_t (**)(const void **, const void **))*a1 + 6))(a1, &v6);
    sub_1001D88DC(&v6);
    if (v5)
    {
      CFUserNotificationCancel((CFUserNotificationRef)*a2);
      sub_100D71AE0(a1 + 6, *a2);
    }
  }
}

void sub_100D71ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001D88DC((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100D71AE0(const void **a1, const void *a2)
{
  v11[0] = v11;
  v11[1] = v11;
  uint64_t v12 = 0;
  uint64_t v2 = (const void **)a1[1];
  if (v2 != a1)
  {
    uint64_t v3 = 0;
    do
    {
      BOOL v4 = (const void **)v2[1];
      if (v2[2] == a2)
      {
        if (v4 == a1)
        {
          BOOL v5 = 1;
LABEL_9:
          BOOL v4 = a1;
        }
        else
        {
          while (1)
          {
            BOOL v5 = v4[2] == a2;
            if (v4[2] != a2) {
              break;
            }
            BOOL v4 = (const void **)v4[1];
            if (v4 == a1) {
              goto LABEL_9;
            }
          }
        }
        if (v2 != v4)
        {
          id v6 = (const void **)*v4;
          if (v11 != a1)
          {
            uint64_t v7 = 1;
            if (v6 != v2)
            {
              unsigned __int8 v8 = v2;
              do
              {
                unsigned __int8 v8 = (const void **)v8[1];
                ++v7;
              }
              while (v8 != v6);
            }
            a1[2] = (char *)a1[2] - v7;
            v3 += v7;
            uint64_t v12 = v3;
          }
          uint64_t v9 = *v2;
          v9[1] = v6[1];
          *(void *)v6[1] = v9;
          uint64_t v10 = v11[0];
          *((void *)v11[0] + 1) = v2;
          *uint64_t v2 = v10;
          v11[0] = v6;
          v6[1] = v11;
        }
        if (!v5) {
          BOOL v4 = (const void **)v4[1];
        }
      }
      uint64_t v2 = v4;
    }
    while (v4 != a1);
  }
  sub_100D71FC4(v11);
}

void sub_100D71BE0(uint64_t a1, unsigned __int8 *a2)
{
  id v13 = objc_alloc_init((Class)NSMutableDictionary);
  if (*a2 == 1)
  {
    BOOL v4 = a2 + 8;
    if ((char)a2[31] < 0)
    {
      if (!*((void *)a2 + 2)) {
        goto LABEL_8;
      }
      BOOL v4 = (void *)*v4;
    }
    else if (!a2[31])
    {
LABEL_8:
      id v6 = a2 + 32;
      if ((char)a2[55] < 0)
      {
        if (!*((void *)a2 + 5)) {
          goto LABEL_14;
        }
        id v6 = (void *)*v6;
      }
      else if (!a2[55])
      {
LABEL_14:
        unsigned __int8 v8 = a2 + 56;
        if ((char)a2[79] < 0)
        {
          if (!*((void *)a2 + 8)) {
            goto LABEL_20;
          }
          unsigned __int8 v8 = (void *)*v8;
        }
        else if (!a2[79])
        {
LABEL_20:
          uint64_t v10 = a2 + 80;
          if ((char)a2[103] < 0)
          {
            if (!*((void *)a2 + 11))
            {
LABEL_26:
              uint64_t v12 = +[NSNumber numberWithInt:6];
              [v13 setValue:v12 forKey:@"FlowTypeKey"];

              [**(id **)(a1 + 40) launchSimSetupViewWithOptions:*a2 userInfo:v13];
              goto LABEL_27;
            }
            uint64_t v10 = (void *)*v10;
          }
          else if (!a2[103])
          {
            goto LABEL_26;
          }
          long long v11 = +[NSString stringWithUTF8String:v10];
          [v13 setValue:v11 forKey:@"MeidKey"];

          goto LABEL_26;
        }
        uint64_t v9 = +[NSString stringWithUTF8String:v8];
        [v13 setValue:v9 forKey:@"Imei2Key"];

        goto LABEL_20;
      }
      uint64_t v7 = +[NSString stringWithUTF8String:v6];
      [v13 setValue:v7 forKey:@"ImeiKey"];

      goto LABEL_14;
    }
    BOOL v5 = +[NSString stringWithUTF8String:v4];
    [v13 setValue:v5 forKey:@"EidKey"];

    goto LABEL_8;
  }
LABEL_27:
}

void sub_100D71DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100D71DDC(uint64_t a1, unsigned __int8 *a2)
{
  id v5 = objc_alloc_init((Class)NSMutableDictionary);
  BOOL v4 = +[NSNumber numberWithInt:20];
  [v5 setValue:v4 forKey:@"FlowTypeKey"];

  [**(id **)(a1 + 40) launchSimSetupViewWithOptions:*a2 userInfo:v5];
}

void sub_100D71E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_100D71E98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [**(id **)(a1 + 40) launchSimUnlockViewForSlot:a2 suppressCancellation:a3];
}

id sub_100D71EAC(uint64_t a1)
{
  return [**(id **)(a1 + 40) dismissSimUnlockView];
}

void sub_100D71EB8(uint64_t a1)
{
  *(void *)a1 = off_101A56080;
  sub_100D71FC4((const void **)(a1 + 48));
  sub_1003B1ED8((id **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  SubscriberRemoteUILaunchHelperInterface::~SubscriberRemoteUILaunchHelperInterface((SubscriberRemoteUILaunchHelperInterface *)a1);
}

void sub_100D71F34(uint64_t a1)
{
  *(void *)a1 = off_101A56080;
  sub_100D71FC4((const void **)(a1 + 48));
  sub_1003B1ED8((id **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  SubscriberRemoteUILaunchHelperInterface::~SubscriberRemoteUILaunchHelperInterface((SubscriberRemoteUILaunchHelperInterface *)a1);

  operator delete();
}

void sub_100D71FC4(const void **a1)
{
  if (a1[2])
  {
    uint64_t v2 = (void **)*a1;
    uint64_t v3 = (const void **)a1[1];
    BOOL v4 = *v3;
    v4[1] = *((void *)*a1 + 1);
    *v2[1] = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        id v5 = (const void **)v3[1];
        sub_1001D88DC(v3 + 2);
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_100D72038(uint64_t a1, id *a2, uint64_t *a3)
{
  id v5 = operator new(0x60uLL);
  sub_100D720B4(v5, a2, a3);
}

void sub_100D720A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100D720B4(void *a1, id *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A56158;
  sub_100D71404(a1 + 3, a2, *a3);
}

void sub_100D7211C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D72130(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A56158;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D72150(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A56158;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D721A4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D721CC(uint64_t a1)
{
  *(void *)a1 = off_101A56080;
  sub_100D71FC4((const void **)(a1 + 48));
  sub_1003B1ED8((id **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  SubscriberRemoteUILaunchHelperInterface::~SubscriberRemoteUILaunchHelperInterface((SubscriberRemoteUILaunchHelperInterface *)a1);
}

void sub_100D72248(uint64_t a1)
{
  *(void *)a1 = off_101A56080;
  sub_100D71FC4((const void **)(a1 + 48));
  sub_1003B1ED8((id **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  SubscriberRemoteUILaunchHelperInterface::~SubscriberRemoteUILaunchHelperInterface((SubscriberRemoteUILaunchHelperInterface *)a1);

  operator delete();
}

uint64_t *sub_100D722D8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    sub_1001D88DC((const void **)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100D72330(uint64_t a1)
{
  uint64_t v12 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      BOOL v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (!v5)
      {
LABEL_13:
        sub_10004D2C8(v4);
        return sub_100D722D8(&v12);
      }
      CFOptionFlags responseFlags = 0;
      SInt32 v6 = CFUserNotificationReceiveResponse(*(CFUserNotificationRef *)a1, 0.0, &responseFlags);
      uint64_t v7 = *(id **)(v5 + 32);
      if (v6)
      {
        unsigned __int8 v8 = sub_100200FB4(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v9 = "#I alert response error";
LABEL_9:
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, buf, 2u);
        }
      }
      else
      {
        unsigned __int8 v8 = sub_100200FB4(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v9 = "#I alert response ok";
          goto LABEL_9;
        }
      }

      sub_1001D89F0(&cf, (const void **)a1);
      uint64_t v15 = v5;
      CFTypeRef v16 = cf;
      if (cf) {
        CFRetain(cf);
      }
      uint64_t v10 = sub_100200FB4((id *)(v5 + 24));
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v18 = 3221225472;
      __int16 v19 = sub_100D724E4;
      id v20 = &unk_1019A1BF8;
      uint64_t v21 = &v15;
      dispatch_sync(v10, buf);

      sub_1001D88DC(&v16);
      sub_1001D88DC(&cf);
      goto LABEL_13;
    }
  }
  return sub_100D722D8(&v12);
}

void sub_100D724BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10004D2C8(v2);
  sub_100D722D8((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100D724E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = (const void **)(v1 + 8);
  if (v3) {
    BOOL v4 = sub_1001D8360;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    uint64_t v5 = **(const void ****)(a1 + 32);
    sub_1001D89F0(&v7, v2);
    int v6 = (*((uint64_t (**)(const void **, const void **))*v5 + 6))(v5, &v7);
    sub_1001D88DC(&v7);
    if (v6) {
      sub_100D71AE0(v5 + 6, *v2);
    }
  }
}

void sub_100D72590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001D88DC((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100D725AC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D728C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100D72A34(uint64_t a1)
{
  *(void *)a1 = off_101A56278;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1003B1ED8((id **)(a1 + 64));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100D72AAC(uint64_t a1)
{
  sub_100D72A34(a1);

  operator delete();
}

void sub_100D72AE4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100D72BF4(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    BOOL v4 = a2;
  }
  else {
    BOOL v4 = (uint64_t *)*a2;
  }
  uint64_t v5 = +[NSString stringWithUTF8String:v4];
  int v6 = +[RBSProcessPredicate predicateMatchingBundleIdentifier:v5];
  id v13 = 0;
  uint64_t v7 = +[RBSProcessHandle handleForPredicate:v6 error:&v13];
  id v8 = v13;

  BOOL v9 = 0;
  if (!v8 && v7)
  {
    uint64_t v10 = [v7 currentState];
    int v11 = sub_100055EDC(v10);

    BOOL v9 = (v11 - 3) < 2;
  }

  return v9;
}

void sub_100D72CF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100D72D24()
{
  if (qword_101B12B78 != -1) {
    dispatch_once(&qword_101B12B78, &stru_101A56320);
  }
  id v0 = (void *)qword_101B12B80;

  return v0;
}

void sub_100D72D78(id a1)
{
  uint64_t v1 = +[NSSet setWithArray:&off_101AE7E98];
  uint64_t v2 = (void *)qword_101B12B80;
  qword_101B12B80 = v1;
}

void sub_100D72DC4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D72DFC(uint64_t a1)
{
}

uint64_t sub_100D72E18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D72E5C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100D72E88(ServiceManager::Service *this)
{
  *(void *)this = off_101A563B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100D72EE4(ServiceManager::Service *this)
{
  *(void *)this = off_101A563B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100D72F54@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ApplicationStateMonitor");
}

unsigned char *sub_100D72F64@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100D72FA4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100D72AE4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100D72AE4(v4, 0);
}

uint64_t sub_100D73028()
{
  return 0;
}

uint64_t sub_100D73030()
{
  return 1;
}

uint64_t sub_100D73038()
{
  return 0;
}

uint64_t sub_100D73048(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 2)
  {
    group[0] = *(dispatch_group_t *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    isa = (std::__shared_weak_count *)group[0][2].isa;
    if (isa)
    {
      if (std::__shared_weak_count::lock(isa)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

uint64_t *sub_100D73220(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100D732A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100D732C0(uint64_t a1)
{
  uint64_t v1 = a1;
  [**(id **)(**(void **)a1 + 64) invalidate];
  operator delete();
}

void sub_100D7331C()
{
}

uint64_t *sub_100D73348(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100058DB0(&__p, "/cc/requests/get_app_state");
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = off_101A56490;
  v4[1] = v2;
  v4[2] = sub_100055928;
  void v4[3] = 0;
  id v20 = v4;
  ctu::RestModule::registerAsRequestSink();
  sub_1001F23E0(buf);
  if (v16 < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&__p, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v5 || (uint64_t v6 = *(void *)(v2 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  id v8 = v7;
  p_shared_weak_owners = &v7->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  uint64_t v10 = **(void ***)(v2 + 64);
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v18 = 3321888768;
  __int16 v19 = sub_100D735B4;
  id v20 = &unk_101A56450;
  uint64_t v21 = v2;
  uint64_t v22 = v6;
  uint64_t v23 = v8;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  [v10 updateConfiguration:buf];
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  std::__shared_weak_count::__release_weak(v8);
  sub_100088C88(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100D73540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  std::__shared_weak_count::__release_weak(v24);
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100D735B4(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = +[RBSProcessStateDescriptor descriptor];
  [v5 setValues:1];
  CFStringRef v18 = @"com.apple.frontboard.visibility";
  uint64_t v6 = +[NSArray arrayWithObjects:&v18 count:1];
  [v5 setEndowmentNamespaces:v6];

  [v3 setServiceClass:25];
  [v3 setStateDescriptor:v5];
  uint64_t v7 = sub_100D72D24();
  id v8 = +[RBSProcessPredicate predicateMatchingBundleIdentifiers:v7];

  v19[0] = v8;
  BOOL v9 = +[RBSProcessPredicate predicateMatchingProcessTypeApplication];
  v19[1] = v9;
  uint64_t v10 = +[NSArray arrayWithObjects:v19 count:2];
  int v11 = +[RBSProcessPredicate predicateMatchingAnyPredicate:v10];

  int v17 = v11;
  uint64_t v12 = +[NSArray arrayWithObjects:&v17 count:1];
  [v3 setPredicates:v12];

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3321888768;
  void v15[2] = sub_1000469F8;
  v15[3] = &unk_101A56420;
  uint64_t v14 = a1[5];
  uint64_t v13 = (std::__shared_weak_count *)a1[6];
  void v15[4] = v4;
  v15[5] = v14;
  char v16 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  [v3 setUpdateHandler:v15];
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
}

void sub_100D737D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100D7385C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_100732068((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D73878(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D7388C()
{
}

__n128 sub_100D738A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A56490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D738F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56490;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7392C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7396C()
{
}

void sub_100D73978(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A56510;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D73998(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A56510;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D739EC(uint64_t a1, int a2, int a3, char *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v7, kCtLoggingSystemName, a4);
  SignalStrengthModel::SignalStrengthModel();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)a1 = off_101A56560;
  sub_10111F0C8(a1 + 128, 1u, (ctu::OsLogLogger *)(a1 + 8));
  *(unsigned char *)(a1 + 552) = 0;
  *(unsigned char *)(a1 + 56sub_100732068((uint64_t)&a9, 0) = 0;
  *(unsigned char *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(unsigned char *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 576) = a3;
  return a1;
}

void sub_100D73AA4(_Unwind_Exception *a1)
{
  id v3 = (std::__shared_weak_count *)*((void *)v1 + 15);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  SignalStrengthModel::~SignalStrengthModel(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D73AD4(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40);

  return v2(a1, 1);
}

uint64_t sub_100D73B50()
{
  return 1000;
}

uint64_t sub_100D73B58(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Model reset", v6, 2u);
  }
  sub_10111F548(a1 + 128, a2);
  if (*(unsigned char *)(a1 + 552)) {
    *(unsigned char *)(a1 + 552) = 0;
  }
  if (*(unsigned char *)(a1 + 568)) {
    *(unsigned char *)(a1 + 568) = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112))(a1, 1, 1);
}

uint64_t sub_100D73C1C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 380);
}

void sub_100D73C24(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D73D10(_Unwind_Exception *exception_object)
{
  id v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D73D28(uint64_t a1)
{
  return *(unsigned int *)(a1 + 576);
}

const char *sub_100D73D30()
{
  return "Mav5LTE";
}

uint64_t sub_100D73D3C(uint64_t a1, uint64_t a2, double a3)
{
  if (a2 != 2) {
    return 0;
  }
  if (HIDWORD(a2) == 6)
  {
    if (a3 < -20.0 || a3 > 30.0) {
      return 1;
    }
    uint64_t v4 = (double *)(a1 + 560);
    if (*(unsigned char *)(a1 + 568)) {
      goto LABEL_18;
    }
    uint64_t v5 = (unsigned char *)(a1 + 568);
    goto LABEL_17;
  }
  if (HIDWORD(a2) != 7) {
    return 0;
  }
  if (a3 < -140.0 || a3 > -44.0) {
    return 1;
  }
  uint64_t v4 = (double *)(a1 + 544);
  if (!*(unsigned char *)(a1 + 552))
  {
    uint64_t v5 = (unsigned char *)(a1 + 552);
LABEL_17:
    *uint64_t v5 = 1;
  }
LABEL_18:
  *uint64_t v4 = a3;
  return 1;
}

void sub_100D73DC8(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v7 = (double)a2;
  uint64_t v8 = 0;
  uint64_t v6 = 1;
  sub_100ABB280(v5, 0x700000002, (uint64_t)&v6);
  double v7 = (double)a3;
  uint64_t v8 = 0;
  uint64_t v6 = 1;
  sub_100ABB280(v5, 0x600000002, (uint64_t)&v6);
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100D73E68(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D73E84(uint64_t a1)
{
  unsigned int v2 = sub_100F88174((Registry **)(a1 + 72), *(unsigned int *)(a1 + 576), __stack_chk_guard);
  id v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "???";
    if (v2 == 1) {
      uint64_t v4 = "kAlternate";
    }
    if (!v2) {
      uint64_t v4 = "kDefault";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting up %s bar mapping for LTE", buf, 0xCu);
  }
  uint64_t v9 = 0x402C000000000000;
  *(void *)&v8[0] = 0x402E000000000000;
  v8[1] = xmmword_10156F7B0;
  long long v12 = xmmword_10159F170;
  long long v13 = unk_10159F180;
  if (v2)
  {
    long long v10 = xmmword_10159F1B0;
    long long v11 = unk_10159F1C0;
    unint64_t v5 = 0xC058800000000000;
    unint64_t v6 = 0xC057C00000000000;
    unint64_t v7 = 0xC058000000000000;
  }
  else
  {
    long long v10 = xmmword_10159F190;
    long long v11 = unk_10159F1A0;
    unint64_t v5 = 0xC054C00000000000;
    unint64_t v6 = 0xC054000000000000;
    unint64_t v7 = 0xC054400000000000;
  }
  *((void *)&v8[0] + 1) = v5;
  sub_10111F680(a1 + 128, v8);
  *(_OWORD *)(a1 + 528) = xmmword_10156F7C0;
  *(void *)(a1 + 512) = v6;
  *(void *)(a1 + 52sub_100732068((uint64_t)&a9, 0) = v7;
}

void sub_100D74018(uint64_t a1)
{
  *(void *)a1 = off_101A56560;
  sub_1000346F8(a1 + 352, *(void **)(a1 + 360));
  sub_1000346F8(a1 + 328, *(void **)(a1 + 336));
  unsigned int v2 = *(void **)(a1 + 272);
  if (v2)
  {
    *(void *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = v2;
    operator delete(v2);
  }
  id v3 = *(void **)(a1 + 240);
  if (v3)
  {
    *(void *)(a1 + 248) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 192);
  if (v4)
  {
    *(void *)(a1 + 20sub_100732068((uint64_t)&a9, 0) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(a1 + 160);
  if (v5)
  {
    *(void *)(a1 + 168) = v5;
    operator delete(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 128));
  unint64_t v6 = *(std::__shared_weak_count **)(a1 + 120);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  SignalStrengthModel::~SignalStrengthModel((SignalStrengthModel *)a1);
}

uint64_t sub_100D740D8(uint64_t a1, unint64_t a2, double a3)
{
  if (*(_DWORD *)(a1 + 580) != a2) {
    return 0;
  }
  unint64_t v3 = HIDWORD(a2);
  if (HIDWORD(a2) != 1)
  {
    if (HIDWORD(a2) == 3)
    {
      if (a3 < -120.0 || a3 > -25.0) {
        return 1;
      }
      unint64_t v5 = (double *)(a1 + 544);
      if (!*(unsigned char *)(a1 + 552))
      {
        unint64_t v6 = (unsigned char *)(a1 + 552);
LABEL_15:
        *unint64_t v6 = 1;
        goto LABEL_16;
      }
      goto LABEL_16;
    }
    return 0;
  }
  if (a3 >= -128.0 && a3 <= 0.0)
  {
    unint64_t v5 = (double *)(a1 + 560);
    if (!*(unsigned char *)(a1 + 568))
    {
      unint64_t v6 = (unsigned char *)(a1 + 568);
      goto LABEL_15;
    }
LABEL_16:
    *unint64_t v5 = a3;
    return 1;
  }
  return v3;
}

void sub_100D7416C(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(unsigned int *)(a1 + 580);
  double v10 = (double)a2;
  uint64_t v11 = 0;
  uint64_t v9 = 1;
  sub_100ABB280(v6, v7 | 0x300000000, (uint64_t)&v9);
  uint64_t v8 = *(unsigned int *)(a1 + 580);
  double v10 = (double)a3;
  uint64_t v11 = 0;
  uint64_t v9 = 1;
  sub_100ABB280(v6, v8 | (unint64_t)&_mh_execute_header, (uint64_t)&v9);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100D74210(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100D7422C()
{
  return "MavTDSCDMA";
}

void sub_100D74238(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D74320(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

double sub_100D74338(uint64_t a1)
{
  unsigned int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    *(_DWORD *)long long buf = 136315138;
    uint64_t v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Setting up standard bar mapping A for %s", buf, 0xCu);
  }
  v5[0] = xmmword_10156F7D0;
  v5[1] = xmmword_10156F7E0;
  long long v7 = xmmword_10159F1D0;
  long long v8 = unk_10159F1E0;
  long long v9 = xmmword_10159F1F0;
  unint64_t v6 = 0xC008000000000000;
  long long v10 = unk_10159F200;
  sub_10111F680(a1 + 128, v5);
  double result = -60.0;
  *(_OWORD *)(a1 + 512) = xmmword_10156F7F0;
  *(_OWORD *)(a1 + 528) = xmmword_10156F800;
  return result;
}

uint64_t sub_100D74460(uint64_t a1, unint64_t a2, double a3)
{
  if (!*(unsigned char *)(a1 + 568))
  {
    *(unsigned char *)(a1 + 568) = 1;
    *(void *)(a1 + 56sub_100732068((uint64_t)&a9, 0) = 0;
  }
  return sub_100D740D8(a1, a2, a3);
}

const char *sub_100D7447C()
{
  return "KTDSCDMA";
}

void sub_100D7448C(uint64_t a1)
{
  sub_100D74018(a1);

  operator delete();
}

void sub_100D744C8(uint64_t a1)
{
  sub_100D74018(a1);

  operator delete();
}

void sub_100D74504(uint64_t a1)
{
  sub_100D74018(a1);

  operator delete();
}

void sub_100D7453C(int a1@<W1>, int *a2@<X2>, char **a3@<X3>, void *a4@<X8>)
{
  long long v8 = operator new(0x260uLL);
  sub_100D745C8(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 17, (uint64_t)(v8 + 3));
}

void sub_100D745B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100D745C8(void *a1, int a2, int *a3, char **a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A56770;
  sub_100D739EC((uint64_t)(a1 + 3), a2, *a3, *a4);
  return a1;
}

void sub_100D74618(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D7462C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A56770;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D7464C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A56770;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D746A0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D746C8(int a1@<W1>, int *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x260uLL);
  sub_100D74744((uint64_t)v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 17, (uint64_t)(v6 + 3));
}

void sub_100D74730(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D74744(uint64_t a1, int a2, int *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_101A567C0;
  uint64_t v4 = a1 + 24;
  int v5 = *a3;
  unint64_t v6 = "sig.tds.?";
  if (v5 == 2) {
    unint64_t v6 = "sig.tds.2";
  }
  if (v5 == 1) {
    long long v7 = "sig.tds.1";
  }
  else {
    long long v7 = (char *)v6;
  }
  sub_100D739EC(v4, a2, v5, v7);
  *(void *)(a1 + 24) = &off_101A565E8;
  *(_DWORD *)(a1 + 604) = 3;
  *(void *)(a1 + 52sub_100732068((uint64_t)&a9, 0) = "Rscp";
  *(void *)(a1 + 528) = "EcIo";
  return a1;
}

void sub_100D747F4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D74808(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A567C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D74828(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A567C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D7487C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D748A4(int a1@<W1>, int *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x260uLL);
  sub_100D74920((uint64_t)v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 17, (uint64_t)(v6 + 3));
}

void sub_100D7490C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100D74920(uint64_t a1, int a2, int *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_101A56810;
  uint64_t v4 = a1 + 24;
  int v5 = *a3;
  unint64_t v6 = "sig.tds.?";
  if (v5 == 2) {
    unint64_t v6 = "sig.tds.2";
  }
  if (v5 == 1) {
    long long v7 = "sig.tds.1";
  }
  else {
    long long v7 = (char *)v6;
  }
  sub_100D739EC(v4, a2, v5, v7);
  *(void *)(a1 + 24) = &off_101A56670;
  *(void *)(a1 + 52sub_100732068((uint64_t)&a9, 0) = "Rscp";
  *(void *)(a1 + 528) = "None";
  *(_DWORD *)(a1 + 604) = 0;
  return a1;
}

void sub_100D749CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100D749E0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A56810;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D74A00(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A56810;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D74A54(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D74A80()
{
}

void sub_100D74AEC()
{
}

void sub_100D74B10(uint64_t a1, void *a2)
{
  *(void *)a1 = off_101A18190;
  uint64_t v4 = a1 + 8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "loc.pref");
  *(void *)uint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)a1 = off_101A56860;
  *(void *)(a1 + 4sub_100732068((uint64_t)&a9, 0) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 8sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 88) = *a2;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 96) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  __p.var0 = 0;
  __p.var1.fRef = 0;
  uint64_t v7 = 0;
  sub_10026EFA4((void *)(a1 + 128));
}

void sub_100D74C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10005D144(*(void **)(v12 + 112));
  int v17 = *(std::__shared_weak_count **)(v12 + 96);
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_100D77C9C(v15);
  sub_10007CA64(v14);
  sub_1006C7390(v13);
  _Unwind_Resume(a1);
}

void sub_100D74CD0(uint64_t a1, int a2, NSObject **a3)
{
  unint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v7 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    long long v8 = "NO";
    if (a2) {
      long long v8 = "YES";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Force the update %s", buf, 0xCu);
  }
  sub_1003F2A04();
  __p[0] = (void *)CFPreferencesCopyValue(@"LASDNextUpdate", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  *(void *)long long buf = 0;
  sub_100D78968(buf, (CFTypeRef *)__p);
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_100732068((uint64_t)&a9, 0) = *(void *)buf;
  *(void *)long long buf = v9;
  sub_10007CA64((const void **)buf);
  if (a2) {
    goto LABEL_37;
  }
  sub_1003F2A04();
  CFDateRef theDate = 0;
  *(void *)long long buf = CFPreferencesCopyValue(@"LASDNextUpdate", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100D78968(&theDate, (CFTypeRef *)buf);
  if (theDate) {
    long long v10 = sub_1001908E4;
  }
  else {
    long long v10 = 0;
  }
  uint64_t v11 = *(NSObject **)(a1 + 32);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (!v10)
  {
    if (v12)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v34 = 0;
      ctu::cf::assign();
      *(_OWORD *)OsLogContext __p = *(_OWORD *)buf;
      uint64_t v27 = v34;
      uint64_t v21 = __p;
      if (v34 < 0) {
        uint64_t v21 = *(void ***)buf;
      }
      *(_DWORD *)dispatch_queue_t v29 = 136315138;
      std::string::size_type v30 = v21;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s key not found, assuming update required", v29, 0xCu);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
    }
    goto LABEL_31;
  }
  if (v12)
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v34 = 0;
    ctu::cf::assign();
    *(_OWORD *)OsLogContext __p = *(_OWORD *)buf;
    uint64_t v27 = v34;
    uint64_t v13 = __p;
    if (v34 < 0) {
      uint64_t v13 = *(void ***)buf;
    }
    *(_DWORD *)dispatch_queue_t v29 = 136315394;
    std::string::size_type v30 = v13;
    __int16 v31 = 2112;
    CFDateRef v32 = theDate;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s key found with value %@", v29, 0x16u);
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v15 = CFDateCreate(kCFAllocatorDefault, Current);
  __p[0] = v15;
  if (v15) {
    char v16 = sub_1001908E4;
  }
  else {
    char v16 = 0;
  }
  if (!v16)
  {
    CFStringRef v18 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      id v20 = "#N Could not get current time, assuming update required";
      goto LABEL_29;
    }
LABEL_30:
    sub_10007CA64((const void **)__p);
LABEL_31:
    sub_10007CA64((const void **)&theDate);
    uint64_t v22 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Checking the server check now", buf, 2u);
    }
    sub_100D76344(a1, 0);
    uint64_t v23 = *a3;
    *(void *)long long buf = v23;
    if (v23) {
      dispatch_retain(v23);
    }
    sub_100D75DF0(a1, (NSObject **)buf, 0);
    if (v23) {
      dispatch_release(v23);
    }
LABEL_37:
    sub_100D755C0(a1);
    goto LABEL_38;
  }
  double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(theDate, v15);
  CFStringRef v18 = *(NSObject **)(a1 + 32);
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (TimeIntervalSinceDate < 0.0)
  {
    if (v19)
    {
      *(_WORD *)long long buf = 0;
      id v20 = "#I Difference is equal to or less than zero, time to check!";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v20, buf, 2u);
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  if (v19)
  {
    *(_DWORD *)long long buf = 134217984;
    *(double *)&uint8_t buf[4] = TimeIntervalSinceDate;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Difference is still %f, we must wait", buf, 0xCu);
  }
  sub_10007CA64((const void **)__p);
  sub_10007CA64((const void **)&theDate);
  sub_100D76110(a1, v24);
  uint64_t v25 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Deferring the server check now", buf, 2u);
  }
LABEL_38:
  os_unfair_lock_unlock(v6);
}

void sub_100D75174(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2)
  {
    if (a22 < 0) {
      operator delete(__p);
    }
    sub_10007CA64(&a12);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D751EC(uint64_t a1, uint64_t a2)
{
  sub_100A0B7BC(v14, a2);
  uint64_t v3 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock(v3);
  uint64_t v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  uint64_t v5 = dispatch_queue_create("LASDResultQueue", v4);
  dispatch_object_t v26 = v5;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  sub_100D77D20(&v24, "LASDPreference", &v26);
  uint64_t v6 = v24;
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v22, *(Registry **)(a1 + 88));
  ctu::RestModule::connect();
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_100058DB0(&v15, "/var/mobile/Library/LASD");
  rest::LASDLocalUpdateParameters::LASDLocalUpdateParameters();
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  long long v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  uint64_t v11 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v30 = 0;
  rest::write_rest_value();
  sub_100058DB0(&v28, "/helper/requests/lasd_local_update");
  xpc_object_t v27 = v30;
  xpc_object_t v30 = xpc_null_create();
  CFDateRef v32 = 0;
  BOOL v12 = operator new(0x30uLL);
  *BOOL v12 = off_101A56AA8;
  v12[1] = a1;
  v12[2] = v8;
  void v12[3] = v10;
  void v12[4] = v6;
  v12[5] = v11;
  CFDateRef v32 = v12;
  ctu::RestModule::sendRequest();
  sub_10003F600(v31);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v29 < 0) {
    operator delete(v28);
  }
  xpc_release(v30);
  sub_100A0B1FC((uint64_t)&v21);
  if (v20 < 0) {
    operator delete(__p);
  }
  sub_10019D5B8((uint64_t)v17, v18);
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v5) {
    dispatch_release(v5);
  }
  os_unfair_lock_unlock(v3);
  sub_10019D5B8((uint64_t)v14, (void *)v14[1]);
}

void sub_100D75460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D755C0(uint64_t a1)
{
  unsigned int v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  uint64_t v3 = dispatch_queue_create("LASDResultQueue", v2);
  uint64_t v22 = 0;
  v23[0] = v3;
  uint64_t v21 = 0;
  sub_100D77D20(&v21, "LASDPreference", v23);
  sub_100BE0C90(v4);
  uint64_t v5 = v21;
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v19, *(Registry **)(a1 + 88));
  ctu::RestModule::connect();
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v6 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending message to CCMobileHelper to check for LASD database update.", buf, 2u);
  }
  sub_100058DB0(&v13, "/var/mobile/Library/LASD");
  rest::LASDServerUpdateParameters::LASDServerUpdateParameters();
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  long long v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  uint64_t v11 = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v31 = 0;
  rest::write_rest_value();
  sub_100058DB0(&v29, "/helper/requests/check_for_lasd_update");
  xpc_object_t v28 = v31;
  xpc_object_t v31 = xpc_null_create();
  v23[1] = (dispatch_object_t)a1;
  uint64_t v24 = v8;
  uint64_t v25 = v10;
  uint64_t v26 = v5;
  xpc_object_t v27 = v11;
  std::string v33 = 0;
  BOOL v12 = operator new(0x30uLL);
  *BOOL v12 = off_101A56B28;
  v12[1] = a1;
  v12[2] = v8;
  void v12[3] = v10;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  void v12[4] = v5;
  v12[5] = v11;
  uint64_t v26 = 0;
  xpc_object_t v27 = 0;
  std::string v33 = v12;
  ctu::RestModule::sendRequest();
  sub_10003F600(v32);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (v30 < 0) {
    operator delete(v29);
  }
  xpc_release(v31);
  sub_100A0B1FC((uint64_t)&v18);
  if (v17 < 0) {
    operator delete(__p);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v3) {
    dispatch_release(v3);
  }
}

void sub_100D75864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D7594C(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100D75988(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 16))
  {
    if (*(void *)(a1 + 80))
    {
      sub_100A0BD40(v28, a2);
      uint64_t v4 = *(void *)(a1 + 80);
      if (!v4) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, v28);
      sub_100A0AF80((uint64_t)v28, (char *)v28[1]);
    }
    else
    {
      uint64_t v6 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Can't send a callback to the controller", buf, 2u);
      }
    }
    uint64_t v9 = *(uint64_t **)(a2 + 8);
    uint64_t v7 = a2 + 8;
    uint64_t v8 = v9;
    if (v9)
    {
      uint64_t v10 = v7;
      uint64_t v11 = (uint64_t)v8;
      do
      {
        int v12 = *(_DWORD *)(v11 + 32);
        BOOL v13 = v12 < 4;
        if (v12 >= 4) {
          char v14 = (uint64_t *)v11;
        }
        else {
          char v14 = (uint64_t *)(v11 + 8);
        }
        if (!v13) {
          uint64_t v10 = v11;
        }
        uint64_t v11 = *v14;
      }
      while (*v14);
      if (v10 != v7 && *(int *)(v10 + 32) <= 4)
      {
        while (1)
        {
          while (1)
          {
            int v15 = *((_DWORD *)v8 + 8);
            if (v15 < 5) {
              break;
            }
            uint64_t v8 = (uint64_t *)*v8;
            if (!v8) {
              goto LABEL_24;
            }
          }
          if (v15 == 4) {
            break;
          }
          uint64_t v8 = (uint64_t *)v8[1];
          if (!v8) {
LABEL_24:
          }
            sub_1000C14F0("map::at:  key not found");
        }
        if (*((unsigned char *)v8 + 72))
        {
          uint64_t v16 = a1 + 128;
          if (sub_10025B63C(a1 + 128, 0) != 1)
          {
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v30 = 0;
            if (!*((unsigned char *)v8 + 72)) {
              sub_10016C840();
            }
            if (*((char *)v8 + 71) < 0)
            {
              sub_10004FC84(__p, (void *)v8[6], v8[7]);
            }
            else
            {
              *(_OWORD *)OsLogContext __p = *((_OWORD *)v8 + 3);
              uint64_t v30 = v8[8];
            }
            char v17 = (void *)HIBYTE(v30);
            int v18 = SHIBYTE(v30);
            if (v30 < 0) {
              char v17 = __p[1];
            }
            if (!v17) {
              goto LABEL_56;
            }
            uint64_t v19 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              char v20 = (void **)__p[0];
              if (v18 >= 0) {
                char v20 = __p;
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v20;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "0.2020.02.13";
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Comparing the downloaded LTE database version number: %s, with the threshold (for deployment type) version number: %s", buf, 0x16u);
            }
            sub_100058DB0(buf, "0.2020.02.13");
            if (v30 >= 0) {
              size_t v21 = HIBYTE(v30);
            }
            else {
              size_t v21 = (size_t)__p[1];
            }
            uint64_t v22 = v33;
            unsigned __int8 v23 = v33;
            if ((v33 & 0x80u) != 0) {
              uint64_t v22 = *(void *)&buf[8];
            }
            if (v21 == v22)
            {
              if (v30 >= 0) {
                uint64_t v24 = __p;
              }
              else {
                uint64_t v24 = (void **)__p[0];
              }
              if ((v33 & 0x80u) == 0) {
                uint64_t v25 = buf;
              }
              else {
                uint64_t v25 = *(unsigned char **)buf;
              }
              unsigned int v26 = memcmp(v24, v25, v21) >= 0;
              if ((v23 & 0x80) == 0) {
                goto LABEL_55;
              }
            }
            else
            {
              xpc_object_t v27 = *(NSObject **)(a1 + 32);
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)xpc_object_t v31 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "The version information of the LTE database is not in the correct format", v31, 2u);
                unsigned int v26 = 0;
                if ((v33 & 0x80) == 0) {
                  goto LABEL_55;
                }
              }
              else
              {
                unsigned int v26 = 0;
                if ((v23 & 0x80) == 0)
                {
LABEL_55:
                  sub_10025CAD8(v16, v26);
                  LOBYTE(v18) = HIBYTE(v30);
LABEL_56:
                  if ((v18 & 0x80) != 0) {
                    operator delete(__p[0]);
                  }
                  return;
                }
              }
            }
            operator delete(*(void **)buf);
            goto LABEL_55;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No update information provided by CCMobileHelper", buf, 2u);
    }
  }
}

void sub_100D75D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D75D50(os_unfair_lock_s *a1, NSObject **a2, int a3)
{
  uint64_t v6 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  uint64_t v7 = *a2;
  uint64_t v8 = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  sub_100D75DF0((uint64_t)a1, &v8, a3);
  if (v7) {
    dispatch_release(v7);
  }

  os_unfair_lock_unlock(v6);
}

void sub_100D75DD8(void *a1)
{
  if (v1) {
    dispatch_release(v1);
  }
  sub_10006A6AC(a1);
}

const void **sub_100D75DF0(uint64_t a1, NSObject **a2, int a3)
{
  if (*(unsigned char *)(a1 + 48))
  {
    double result = *(const void ***)(a1 + 160);
    if (result)
    {
      if (!a3) {
        return result;
      }
      (*((void (**)(const void **))*result + 2))(result);
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v7 = CFDateCreate(kCFAllocatorDefault, Current);
  CFDateRef v23 = v7;
  if (v7) {
    uint64_t v8 = sub_1001908E4;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(*(CFDateRef *)(a1 + 40), v7);
    *(unsigned char *)(a1 + 48) = 1;
    Registry::getTimerService(&v20, *(Registry **)(a1 + 88));
    uint64_t v10 = v20;
    sub_100058DB0(__p, "LASD update timer");
    uint64_t v11 = *a2;
    dispatch_object_t object = v11;
    if (v11) {
      dispatch_retain(v11);
    }
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = sub_100D76080;
    v15[3] = &unk_101A568C8;
    void v15[4] = a1;
    aBlock = _Block_copy(v15);
    sub_100118A44(v10, (uint64_t)__p, 0, 1000000 * TimeIntervalSinceDate, &object, &aBlock);
    uint64_t v12 = v22;
    uint64_t v22 = 0;
    uint64_t v13 = *(void *)(a1 + 160);
    *(void *)(a1 + 16sub_100732068((uint64_t)&a9, 0) = v12;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      uint64_t v14 = v22;
      uint64_t v22 = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    if (v21) {
      sub_10004D2C8(v21);
    }
    sub_100528600(a1);
  }
  return sub_10007CA64((const void **)&v23);
}

void sub_100D7601C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  sub_10007CA64((const void **)(v23 - 56));
  _Unwind_Resume(a1);
}

void sub_100D76080(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 24));
  unsigned int v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I LASD timer expired", v3, 2u);
  }
  sub_100D755C0(v1);
  *(unsigned char *)(v1 + 48) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 24));
}

void sub_100D76110(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 88));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
LABEL_11:
      int v15 = 0;
      (*(void (**)(uint64_t, const void **, const __CFString *))(*(void *)v11 + 16))(v11, &v15, @"LASDUpdaterScheduledWake");
      sub_10007CA64(&v15);
      sub_100602178(&v14, (const void **)(a1 + 40));
      (*(void (**)(uint64_t, const void **, const __CFString *))(*(void *)v11 + 24))(v11, &v14, @"LASDUpdaterScheduledWake");
      sub_10007CA64(&v14);
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v13 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get PowerAssertionInterface to schedule wake timer", buf, 2u);
  }
LABEL_12:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100D762B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_10007CA64(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100D762E8(os_unfair_lock_s *a1, int a2)
{
  uint64_t v4 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  sub_100D76344((uint64_t)a1, a2);

  os_unfair_lock_unlock(v4);
}

uint64_t sub_100D76344(uint64_t a1, int a2)
{
  int v4 = rand();
  if (a2)
  {
    double v5 = CFAbsoluteTimeGetCurrent() + 86400.0 + (double)(v4 % 24 + 1) * 3600.0;
    uint64_t v6 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_WORD *)uint64_t v13 = 0;
    uint64_t v7 = "#I Updating preference to next 24 - 48 hours";
  }
  else
  {
    double v5 = CFAbsoluteTimeGetCurrent() + (double)(v4 % 7 + 8) * 86400.0;
    uint64_t v6 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_WORD *)uint64_t v13 = 0;
    uint64_t v7 = "#I Updating preference to next 7 - 15 days";
  }
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v13, 2u);
LABEL_7:
  CFDateRef v8 = CFDateCreate(kCFAllocatorDefault, v5);
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_100732068((uint64_t)&a9, 0) = v8;
  *(void *)uint64_t v13 = v9;
  sub_10007CA64((const void **)v13);
  char v10 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 40);
    *(_DWORD *)uint64_t v13 = 138412290;
    *(void *)&void v13[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Next update scheduled for: %@", v13, 0xCu);
  }
  CFPreferencesSetValue(@"LASDNextUpdate", *(CFPropertyListRef *)(a1 + 40), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  return sub_1003F2A04();
}

void sub_100D76540(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v7 = (void *)(a1 + 80);
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v8 = a1 + 56;
  *(void *)(a1 + 8sub_100732068((uint64_t)&a9, 0) = 0;
  if (v6 == a1 + 56)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(a1 + 56);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v9 = (void *)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 24);
  if (!v10)
  {
    uint64_t v9 = (void *)(a1 + 80);
    goto LABEL_9;
  }
  if (v10 != a3)
  {
    *uint64_t v7 = v10;
LABEL_9:
    void *v9 = 0;
    goto LABEL_11;
  }
  *uint64_t v7 = v8;
  (*(void (**)(void, uint64_t))(*(void *)*v9 + 24))(*v9, a1 + 56);
LABEL_11:
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  xpc_object_t __p[2] = sub_1005285F8;
  *(void *)&long long v63 = &unk_1019E0C20;
  *((void *)&v63 + 1) = a1;
  sub_10017B514();
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  Registry::getFileSystemInterface(&v58, *(Registry **)(a1 + 88));
  uint64_t v11 = v58;
  sub_100058DB0(__p, "/var/wireless/Library/LASD/");
  char v12 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v11 + 88))(v11, __p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (v12) {
    goto LABEL_20;
  }
  int v13 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, uint64_t))(*(void *)v58 + 72))(v58, "/var/wireless/Library/LASD/", 493, 1);
  uint64_t v14 = *(NSObject **)(a1 + 32);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      uint64_t v16 = strerror(v13);
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = "/var/wireless/Library/LASD/";
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = v16;
      char v17 = "#N Could not create %s directory: %s";
      int v18 = v14;
      uint32_t v19 = 22;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)__p, v19);
    }
  }
  else if (v15)
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = "/var/wireless/Library/LASD/";
    char v17 = "#I Created %s directory";
    int v18 = v14;
    uint32_t v19 = 12;
    goto LABEL_19;
  }
LABEL_20:
  uint64_t v60 = 0;
  long long v61 = 0;
  FileSystemInterface = (capabilities::ct *)Registry::getFileSystemInterface(&v60, *(Registry **)(a1 + 88));
  lock = v5;
  int v21 = sub_100BE0C90(FileSystemInterface);
  uint64_t v22 = 0;
  uint64_t v57 = (uint64_t **)(a1 + 104);
  do
  {
    int v23 = *(_DWORD *)((char *)&unk_101A568E8 + v22);
    if ((v23 & v21) == 0) {
      goto LABEL_72;
    }
    uint64_t v24 = v60;
    uint64_t v25 = *(char **)((char *)&unk_101A568E8 + v22 + 8);
    sub_100058DB0(__p, v25);
    int v26 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v24 + 88))(v24, __p);
    int v27 = v26;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (!v27)
      {
LABEL_44:
        uint64_t v38 = *(NSObject **)(a1 + 32);
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_55;
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v25;
        char v39 = v38;
        xpc_object_t v40 = "#I %s link does not exist";
        goto LABEL_46;
      }
    }
    else if (!v26)
    {
      goto LABEL_44;
    }
    uint64_t v28 = v60;
    sub_100058DB0(__p, v25);
    char v29 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v28 + 208))(v28, __p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v30 = *(NSObject **)(a1 + 32);
    BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    if (v29)
    {
      if (v31)
      {
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v25;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s link exists", (uint8_t *)__p, 0xCu);
      }
      memset(__p, 0, sizeof(__p));
      uint64_t v32 = v60;
      sub_100058DB0(buf, v25);
      (*(void (**)(void **__return_ptr, uint64_t, unsigned char *))(*(void *)v32 + 144))(__p, v32, buf);
      if (v67 < 0) {
        operator delete(*(void **)buf);
      }
      unsigned __int8 v33 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = __p;
        if (SHIBYTE(__p[2]) < 0) {
          uint64_t v34 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v25;
        __int16 v65 = 2080;
        uint64_t v66 = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s --> %s", buf, 0x16u);
      }
      if (SHIBYTE(__p[2]) >= 0) {
        size_t v35 = HIBYTE(__p[2]);
      }
      else {
        size_t v35 = (size_t)__p[1];
      }
      if (v35 == strlen(*(const char **)((char *)&unk_101A568E8 + v22 + 16)))
      {
        if (SHIBYTE(__p[2]) >= 0) {
          uint64_t v36 = __p;
        }
        else {
          uint64_t v36 = (void **)__p[0];
        }
        BOOL v37 = memcmp(v36, *(const void **)((char *)&unk_101A568E8 + v22 + 16), v35) == 0;
      }
      else
      {
        BOOL v37 = 0;
      }
      *((unsigned char *)sub_1000BC5E4(v57, v23, (char *)&unk_101A568E8 + v22) + 32) = v37;
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_72;
    }
    if (v31)
    {
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v25;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#N %s not a link", (uint8_t *)__p, 0xCu);
    }
    uint64_t v42 = v60;
    sub_100058DB0(__p, v25);
    uint64_t v43 = (void *)(*(uint64_t (**)(uint64_t, void **))(*(void *)v42 + 112))(v42, __p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    long long v44 = *(NSObject **)(a1 + 32);
    BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
    if (v43)
    {
      if (!v45) {
        goto LABEL_55;
      }
      int v46 = strerror((int)v43);
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = v25;
      WORD2(__p[1]) = 2048;
      *(void **)((char *)&__p[1] + 6) = v43;
      HIWORD(__p[2]) = 2080;
      *(void *)&long long v63 = v46;
      char v39 = v44;
      xpc_object_t v40 = "#N Could not remove %s: %ld (%s)";
      uint32_t v41 = 32;
      goto LABEL_54;
    }
    if (v45)
    {
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v25;
      char v39 = v44;
      xpc_object_t v40 = "#I Removed %s";
LABEL_46:
      uint32_t v41 = 12;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)__p, v41);
    }
LABEL_55:
    uint64_t v47 = v60;
    uint64_t v48 = *(char **)((char *)&unk_101A568E8 + v22 + 16);
    sub_100058DB0(__p, v48);
    char v49 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v47 + 88))(v47, __p);
    char v50 = v49;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if ((v50 & 1) == 0)
      {
LABEL_59:
        int v51 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v48;
          _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%s database file does not exist", (uint8_t *)__p, 0xCu);
        }
      }
    }
    else if ((v49 & 1) == 0)
    {
      goto LABEL_59;
    }
    int v52 = (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v60 + 216))(v60, v25, v48);
    int v53 = *(NSObject **)(a1 + 32);
    BOOL v54 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
    if (!v52)
    {
      if (v54)
      {
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v25;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I %s link created successfully", (uint8_t *)__p, 0xCu);
      }
LABEL_68:
      *((unsigned char *)sub_1000BC5E4(v57, v23, (char *)&unk_101A568E8 + v22) + 32) = 1;
      goto LABEL_72;
    }
    if (v54)
    {
      char v55 = strerror(v52);
      LODWORD(__p[0]) = 136315906;
      *(void **)((char *)__p + 4) = v25;
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = v48;
      HIWORD(__p[2]) = 1024;
      LODWORD(v63) = v52;
      WORD2(v63) = 2080;
      *(void *)((char *)&v63 + 6) = v55;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#N Could not create %s --> %s symlink, error=%d (%s)", (uint8_t *)__p, 0x26u);
    }
    if (v52 != 17) {
      goto LABEL_68;
    }
LABEL_72:
    v22 += 24;
  }
  while (v22 != 144);
  if (v61) {
    sub_10004D2C8(v61);
  }
  if (v59) {
    sub_10004D2C8(v59);
  }
  os_unfair_lock_unlock(lock);
}

void sub_100D76E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_10006A6AC(exception_object);
}

void sub_100D76EDC(uint64_t a1, int a2)
{
  int v13 = a2;
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  BOOL v15 = &off_101A0BD40;
  sub_100058DB0(&__p, "/var/wireless/Library/LASD/");
  unsigned __int8 v5 = sub_1007ECCD4((uint64_t)&v15, (uint64_t *)&__p.st_dev);
  unsigned __int8 v6 = v5;
  if (SHIBYTE(__p.st_gid) < 0)
  {
    operator delete(*(void **)&__p.st_dev);
    if (v6) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if ((v5 & 1) == 0) {
LABEL_5:
  }
    sub_1007ED204((uint64_t)&v15, (uint64_t)"/var/wireless/Library/LASD/", 493, 1);
LABEL_6:
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  switch(a2)
  {
    case 1:
      uint64_t v8 = (const std::__fs::filesystem::path *)"/var/wireless/Library/LASD/lasdumts.db";
      uint64_t v7 = "/var/mobile/Library/LASD/lasdumts.db";
      break;
    case 2:
      uint64_t v8 = (const std::__fs::filesystem::path *)"/var/wireless/Library/LASD/lasdcdma.db";
      uint64_t v7 = "/var/mobile/Library/LASD/lasdcdma.db";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      break;
    case 4:
      uint64_t v8 = (const std::__fs::filesystem::path *)"/var/wireless/Library/LASD/lasdlte.db";
      uint64_t v7 = "/var/mobile/Library/LASD/lasdlte.db";
      break;
    case 8:
      uint64_t v8 = (const std::__fs::filesystem::path *)"/var/wireless/Library/LASD/lasdgsm.db";
      uint64_t v7 = "/var/mobile/Library/LASD/lasdgsm.db";
      break;
    default:
      uint64_t v9 = "/var/wireless/Library/LASD/lasdnr.db";
      uint64_t v10 = "/var/mobile/Library/LASD/lasdnr.db";
      if (a2 != 32)
      {
        uint64_t v10 = 0;
        uint64_t v9 = 0;
      }
      if (a2 == 16) {
        uint64_t v7 = "/var/mobile/Library/LASD/lasdscdma.db";
      }
      else {
        uint64_t v7 = v10;
      }
      if (a2 == 16) {
        uint64_t v8 = (const std::__fs::filesystem::path *)"/var/wireless/Library/LASD/lasdscdma.db";
      }
      else {
        uint64_t v8 = (const std::__fs::filesystem::path *)v9;
      }
      break;
  }
  memset(&__p, 0, sizeof(__p));
  if (lstat((const char *)v8, &__p) < 0)
  {
    if (*__error() != 2) {
      goto LABEL_28;
    }
  }
  else if ((__p.st_mode & 0xA000) != 0)
  {
    unlink((const char *)v8);
  }
  else
  {
    remove(v8, v11);
  }
  *((unsigned char *)sub_1000BC5E4((uint64_t **)(a1 + 104), a2, &v13) + 32) = 0;
  char v12 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    char v17 = v7;
    __int16 v18 = 2080;
    uint32_t v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Trying to establish link %s ----> %s", buf, 0x16u);
  }
  symlink(v7, (const char *)v8);
LABEL_28:
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v15);
  os_unfair_lock_unlock(v4);
}

void sub_100D77170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)(v16 - 104));
  sub_10006A6AC(exception_object);
}

BOOL sub_100D771D8(uint64_t a1, int a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 112);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 112;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 112 && *(_DWORD *)(v6 + 28) <= a2)
  {
    BOOL v12 = *(unsigned __int8 *)(v6 + 32) != 0;
  }
  else
  {
LABEL_11:
    uint64_t v10 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "gsm";
      switch(a2)
      {
        case 1:
          uint64_t v11 = "umts";
          break;
        case 2:
          uint64_t v11 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_18;
        case 4:
          uint64_t v11 = "lte";
          break;
        case 8:
          break;
        default:
          if (a2 == 16)
          {
            uint64_t v11 = "scdma";
          }
          else if (a2 == 32)
          {
            uint64_t v11 = "nr";
          }
          else
          {
LABEL_18:
            uint64_t v11 = "unknown";
          }
          break;
      }
      int v14 = 136315138;
      BOOL v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Could not find %s database to determine if bootstrap is in use or not", (uint8_t *)&v14, 0xCu);
    }
    BOOL v12 = 1;
  }
  os_unfair_lock_unlock(v4);
  return v12;
}

void sub_100D77394(uint64_t a1)
{
  lock = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v3 = *(NSObject **)(a1 + 32);
  unsigned int v2 = *(const char **)(a1 + 40);
  if (v2) {
    int v4 = sub_1001908E4;
  }
  else {
    int v4 = 0;
  }
  BOOL v5 = os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v5) {
      goto LABEL_10;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v20 = v2;
    uint64_t v6 = "#I Date of next update: %@";
    int v7 = v3;
    uint32_t v8 = 12;
  }
  else
  {
    if (!v5) {
      goto LABEL_10;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v6 = "#I Date of next update unknown";
    int v7 = v3;
    uint32_t v8 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
LABEL_10:
  uint64_t v9 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 48)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Timer running: %s", buf, 0xCu);
  }
  uint64_t v11 = *(void **)(a1 + 104);
  if (v11 != (void *)(a1 + 112))
  {
    do
    {
      BOOL v12 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = "gsm";
        switch(*((_DWORD *)v11 + 7))
        {
          case 1:
            int v13 = "umts";
            break;
          case 2:
            int v13 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_22;
          case 4:
            int v13 = "lte";
            break;
          case 8:
            break;
          default:
            if ("gsm" == 16)
            {
              int v13 = "scdma";
            }
            else if ("gsm" == 32)
            {
              int v13 = "nr";
            }
            else
            {
LABEL_22:
              int v13 = "unknown";
            }
            break;
        }
        if (*((unsigned char *)v11 + 32)) {
          int v14 = "true";
        }
        else {
          int v14 = "false";
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v20 = v13;
        __int16 v21 = 2080;
        uint64_t v22 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s bootstrap in use: %s", buf, 0x16u);
      }
      BOOL v15 = (void *)v11[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v11[2];
          BOOL v17 = *v16 == (void)v11;
          uint64_t v11 = v16;
        }
        while (!v17);
      }
      uint64_t v11 = v16;
    }
    while (v16 != (void *)(a1 + 112));
  }
  os_unfair_lock_unlock(lock);
}

void sub_100D77678(uint64_t a1@<X0>, const void **a2@<X8>)
{
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  sub_100602178(a2, (const void **)(a1 + 40));

  os_unfair_lock_unlock(v4);
}

void sub_100D776D0(uint64_t a1@<X8>)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = dword_101B12BA8;
  sub_1001369F0(a1, qword_101B12B90);
  for (uint64_t i = qword_101B12B98; i; uint64_t i = *(void *)i)
    sub_100D77898(a1, *(_DWORD *)(i + 16), i + 16);
}

void sub_100D77738(_Unwind_Exception *a1)
{
  sub_100A0B1FC(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100D77750(os_unfair_lock_s *a1)
{
  unsigned int v2 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  BOOL v3 = sub_10025B63C((uint64_t)&a1[32], 0) == 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_100D777A4(uint64_t a1)
{
  sub_100D777DC(a1);

  operator delete();
}

uint64_t sub_100D777DC(uint64_t a1)
{
  *(void *)a1 = off_101A56860;
  uint64_t v2 = *(void *)(a1 + 160);
  *(void *)(a1 + 16sub_100732068((uint64_t)&a9, 0) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v3) {
    sub_10026CD9C(a1 + 136, v3);
  }
  sub_10005D144(*(void **)(a1 + 112));
  int v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100D77C9C((void *)(a1 + 56));
  sub_10007CA64((const void **)(a1 + 40));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

void sub_100D77898(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  uint64_t v12 = a1 + 16;
  uint64_t v22 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v22 = 0;
  *((void *)v22 + 1) = v5;
  *((_DWORD *)v22 + 4) = *(_DWORD *)a3;
  int v13 = v22 + 24;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v13, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    *(_OWORD *)int v13 = *(_OWORD *)(a3 + 8);
    *((void *)v22 + 5) = *(void *)(a3 + 24);
  }
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v6 || (float)(v15 * (float)v6) < v14)
  {
    BOOL v16 = 1;
    if (v6 >= 3) {
      BOOL v16 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v6);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_1001369F0(a1, v19);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    *(void *)uint64_t v22 = *v20;
    *uint64_t v20 = v22;
  }
  else
  {
    *(void *)uint64_t v22 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v22;
    *(void *)(*(void *)a1 + 8 * v8) = v12;
    if (*(void *)v22)
    {
      unint64_t v21 = *(void *)(*(void *)v22 + 8);
      if ((v6 & (v6 - 1)) != 0)
      {
        if (v21 >= v6) {
          v21 %= v6;
        }
      }
      else
      {
        v21 &= v6 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v21) = v22;
    }
  }
  ++*(void *)(a1 + 24);
}

void sub_100D77B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  sub_100A0B564(v10, v11);
  _Unwind_Resume(a1);
}

void sub_100D77B34(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100D77BB4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D77BF0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D77C28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100D77C58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100D77C9C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100D77D20(void *a1, char *a2, dispatch_object_t *a3)
{
  unint64_t v6 = operator new(0x28uLL);
  v6[1] = 0;
  void v6[2] = 0;
  *unint64_t v6 = off_1019B45E8;
  sub_100058DB0(&__p, a2);
  uint8x8_t v7 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v7) {
    dispatch_release(v7);
  }
  if (v9 < 0) {
    operator delete(__p);
  }
  *a1 = v6 + 3;
  a1[1] = v6;
}

void sub_100D77DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a11) {
    dispatch_release(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v19);
  _Unwind_Resume(a1);
}

void *sub_100D77E30(void *a1)
{
  *a1 = off_101A56AA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D77E88(void *a1)
{
  *a1 = off_101A56AA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100D77F00(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_101A56AA8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D77F7C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A56AA8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_100732068((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D77FD4(uint64_t a1)
{
}

void sub_100D77FDC(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100D78018(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  v10[0] = 0;
  v10[1] = 0;
  char v9 = v10;
  sub_100D78188((uint64_t)&v9, v3);
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint8x8_t v7 = v6;
      if (a1[2])
      {
        unint64_t v8 = *(NSObject **)(v5 + 32);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received callback from CCMobileHelper for local LASD database update", buf, 2u);
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v5 + 24));
        sub_100D75988(v5, (uint64_t)&v9);
        os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 24));
      }
      sub_10004D2C8(v7);
    }
  }
  sub_100A0AF80((uint64_t)&v9, v10[0]);
  xpc_release(v3);
}

void sub_100D78114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  sub_100A0AF80((uint64_t)&a10, a11);
  xpc_release(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7813C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7817C()
{
}

void sub_100D78188(uint64_t a1, xpc_object_t object)
{
  if (object && (xpc_object_t v3 = object, xpc_get_type(object) == (xpc_type_t)&_xpc_type_array)) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v4 = (uint64_t **)(a1 + 8);
  sub_100A0AF80(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    objecta[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      objecta[0] = xpc_null_create();
    }
    sub_100048BF4(&v21, objecta, 0);
    xpc_release(objecta[0]);
    objecta[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      objecta[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v20, objecta, count);
    xpc_release(objecta[0]);
    for (uint64_t i = v22; ; uint64_t i = ++v22)
    {
      if (i == v20[1] && v21 == v20[0])
      {
        xpc_release(v21);
        xpc_release(v21);
        goto LABEL_44;
      }
      xpc_object_t v19 = 0;
      objecta[0] = &v21;
      objecta[1] = i;
      sub_10003FBDC((uint64_t)objecta, &v19);
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_42:
      xpc_release(v19);
    }
    *(_OWORD *)stat __p = 0u;
    long long v18 = 0u;
    *(_OWORD *)objecta = 0u;
    LODWORD(objecta[1]) = 1;
    xpc_object_t v7 = v19;
    if (v19)
    {
      xpc_retain(v19);
      xpc_object_t v26 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v26 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        int v23 = &v26;
        uint64_t v24 = "first";
        sub_100048BAC((uint64_t)&v23, &v25);
        LODWORD(objecta[0]) = xpc::dyn_cast_or_default((xpc *)&v25, 0, v9);
        xpc_release(v25);
        int v23 = &v26;
        uint64_t v24 = "second";
        sub_100048BAC((uint64_t)&v23, &v25);
        read_rest_value();
        xpc_release(v25);
        xpc_object_t v8 = v26;
      }
      xpc_release(v8);
      xpc_release(v7);
      int v10 = (int)objecta[0];
      unint64_t v11 = *v4;
      uint64_t v12 = (uint64_t **)(a1 + 8);
      int v13 = (uint64_t **)(a1 + 8);
      if (*v4)
      {
        while (1)
        {
          while (1)
          {
            int v13 = (uint64_t **)v11;
            int v14 = *((_DWORD *)v11 + 8);
            if (v14 <= SLODWORD(objecta[0])) {
              break;
            }
            unint64_t v11 = *v13;
            uint64_t v12 = v13;
            if (!*v13) {
              goto LABEL_36;
            }
          }
          if (v14 >= SLODWORD(objecta[0])) {
            break;
          }
          unint64_t v11 = v13[1];
          if (!v11)
          {
            uint64_t v12 = v13 + 1;
            goto LABEL_36;
          }
        }
      }
      else
      {
LABEL_36:
        float v15 = operator new(0x50uLL);
        v15[48] = 0;
        *((_DWORD *)v15 + 8) = v10;
        *((xpc_object_t *)v15 + 5) = objecta[1];
        v15[72] = 0;
        if (BYTE8(v18))
        {
          *((_OWORD *)v15 + 3) = *(_OWORD *)__p;
          *((void *)v15 + 8) = v18;
          __p[1] = 0;
          *(void *)&long long v18 = 0;
          __p[0] = 0;
          v15[72] = 1;
        }
        sub_100046C38((uint64_t **)a1, (uint64_t)v13, v12, (uint64_t *)v15);
      }
      if (BYTE8(v18))
      {
        if (SBYTE7(v18) < 0) {
          operator delete(__p[0]);
        }
      }
      goto LABEL_42;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v26 = v8;
    goto LABEL_27;
  }
LABEL_44:
  xpc_release(v3);
}

void sub_100D78518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,xpc_object_t a21,xpc_object_t a22,uint64_t a23,xpc_object_t a24)
{
  xpc_release(object);
  xpc_release(a24);
  xpc_release(v24);
  _Unwind_Resume(a1);
}

void *sub_100D78610(void *a1)
{
  *a1 = off_101A56B28;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100D78668(void *a1)
{
  *a1 = off_101A56B28;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100D786E0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_101A56B28;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D7875C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A56B28;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_100732068((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D787B4(uint64_t a1)
{
}

void sub_100D787BC(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100D787F8(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v9 = v10;
  sub_100D78188((uint64_t)&v9, v3);
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      xpc_object_t v7 = v6;
      if (a1[2])
      {
        xpc_object_t v8 = *(NSObject **)(v5 + 32);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received callback from CCMobileHelper for LASD database update", buf, 2u);
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v5 + 24));
        sub_100D75988(v5, (uint64_t)&v9);
        os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 24));
      }
      sub_10004D2C8(v7);
    }
  }
  sub_100A0AF80((uint64_t)&v9, v10[0]);
  xpc_release(v3);
}

void sub_100D788F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  sub_100A0AF80((uint64_t)&a10, a11);
  xpc_release(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7891C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7895C()
{
}

void *sub_100D78968(void *a1, CFTypeRef *a2)
{
  CFTypeRef v4 = *a2;
  if (*a2 && (CFTypeID v5 = CFGetTypeID(*a2), v5 == CFDateGetTypeID()))
  {
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
    if (*a2) {
      CFRelease(*a2);
    }
  }
  return a1;
}

uint64_t sub_100D789D4()
{
  v3[0] = 8;
  sub_100058DB0(v4, "/var/mobile/Library/LASD/lasdgsm.db");
  int v5 = 1;
  sub_100058DB0(v6, "/var/mobile/Library/LASD/lasdumts.db");
  int v7 = 2;
  sub_100058DB0(v8, "/var/mobile/Library/LASD/lasdcdma.db");
  int v9 = 4;
  sub_100058DB0(v10, "/var/mobile/Library/LASD/lasdlte.db");
  int v11 = 16;
  sub_100058DB0(v12, "/var/mobile/Library/LASD/lasdscdma.db");
  int v13 = 32;
  sub_100058DB0(v14, "/var/mobile/Library/LASD/lasdnr.db");
  int v15 = 0;
  sub_100058DB0(v16, "/var/mobile/Library/LASD/lasdunknown.db");
  uint64_t v0 = 0;
  unk_101B12B88 = 0u;
  *(_OWORD *)&qword_101B12B98 = 0u;
  dword_101B12BA8 = 1065353216;
  do
  {
    sub_100D77898((uint64_t)&unk_101B12B88, v3[v0], (uint64_t)&v3[v0]);
    v0 += 8;
  }
  while (v0 != 56);
  for (uint64_t i = 0; i != -28; i -= 4)
  {
    if (SHIBYTE(v16[i + 2]) < 0) {
      operator delete((void *)v16[i]);
    }
  }
  return __cxa_atexit((void (*)(void *))sub_100D74A7C, &unk_101B12B88, (void *)&_mh_execute_header);
}

void sub_100D78B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  while (1)
  {
    if (*(v10 - 1) < 0) {
      operator delete(*((void **)v10 - 3));
    }
    v10 -= 32;
    if (v10 == &a10) {
      _Unwind_Resume(exception_object);
    }
  }
}

void LASDController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100D7920C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

const char *sub_100D79500(int a1)
{
  uint64_t v1 = "loc.?";
  if (a1 == 2) {
    uint64_t v1 = "loc.2";
  }
  if (a1 == 1) {
    return "loc.1";
  }
  else {
    return v1;
  }
}

void sub_100D7952C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  CFTypeRef v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D7962C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 224);
  uint64_t v3 = (void *)(a1 + 232);
  if (v2 != (void *)(a1 + 232))
  {
    int v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      xpc_object_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          xpc_object_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((BasicSimInfo::operator==() & 1) == 0)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        uint64_t v12 = a1;
        goto LABEL_17;
      }
LABEL_18:
      int v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          int v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          uint64_t v2 = v14;
        }
        while (!v15);
      }
      uint64_t v2 = v14;
      if (v14 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_16:
    uint64_t v12 = a1;
LABEL_17:
    sub_100D806B0(v12, v7);
    goto LABEL_18;
  }
}

uint64_t sub_100D7971C(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 338);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    int v5 = *(NSObject **)(result + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "false";
      if (a2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (v2) {
        uint64_t v6 = "true";
      }
      int v9 = 136315394;
      BOOL v10 = v7;
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cellular data setting changed from %s to %s", (uint8_t *)&v9, 0x16u);
      int v2 = *(unsigned __int8 *)(v4 + 338);
    }
    uint64_t v8 = **(void **)(v4 + 120);
    if (v2) {
      return (*(uint64_t (**)(void))(v8 + 24))();
    }
    else {
      return (*(uint64_t (**)(void))(v8 + 16))();
    }
  }
  return result;
}

uint64_t sub_100D7985C(uint64_t a1, double a2, double a3)
{
  int v6 = sub_10121F67C();
  uint64_t v7 = *(NSObject **)(a1 + 32);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      std::to_string(&v72, a2);
      int v9 = SHIBYTE(v72.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v72.__r_.__value_.__r.__words[0];
      std::to_string(&v65, a3);
      __int16 v11 = &v72;
      if (v9 < 0) {
        __int16 v11 = (std::string *)v10;
      }
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = &v65;
      }
      else {
        uint64_t v12 = (std::string *)v65.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Handling location (%s,%s) available", buf, 0x16u);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v65.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v72.__r_.__value_.__l.__data_);
      }
    }
  }
  else if (v8)
  {
    LOWORD(v72.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Handling location available", (uint8_t *)&v72, 2u);
  }
  std::string::size_type v13 = *(void *)(a1 + 320);
  if (v13)
  {
    int v14 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)
      || (LODWORD(v72.__r_.__value_.__l.__data_) = 134217984,
          *(std::string::size_type *)((char *)v72.__r_.__value_.__r.__words + 4) = v13,
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Sending %zu pending replies", (uint8_t *)&v72, 0xCu), *(void *)(a1 + 320)))
    {
      do
      {
        BOOL v15 = (unsigned __int8 *)(*(void *)(*(void *)(a1 + 288) + 8 * (*(void *)(a1 + 312) / 0xAAuLL))
                                + 24 * (*(void *)(a1 + 312) % 0xAAuLL));
        int v16 = *v15;
        uint64_t v18 = *((void *)v15 + 1);
        unint64_t v17 = (std::__shared_weak_count *)*((void *)v15 + 2);
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_100D7A200((void *)(a1 + 280));
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          sub_100D7A200((void *)(a1 + 280));
        }
        *(_DWORD *)uint64_t v18 = 1;
        if (v16 == 2)
        {
          v72.__r_.__value_.__r.__words[0] = 0;
          uint64_t v22 = *(void *)(a1 + 136);
          int v23 = *(std::__shared_weak_count **)(a1 + 96);
          long long v63 = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(std::string *__return_ptr, double, double))(*(void *)v22 + 16))(&v72, a2, a3);
          xpc_object_t v21 = v63;
          if (v63) {
            goto LABEL_25;
          }
        }
        else
        {
          if (v16 != 3)
          {
            uint64_t v24 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = asString();
              LODWORD(v72.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v72.__r_.__value_.__r.__words + 4) = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Unhandled FetchType: %s", (uint8_t *)&v72, 0xCu);
            }
            std::string::size_type v26 = *(void *)(v18 + 8);
            *(void *)(v18 + 8) = 0;
            v72.__r_.__value_.__r.__words[0] = v26;
            sub_1000577C4((const void **)&v72.__r_.__value_.__l.__data_);
            *(_DWORD *)uint64_t v18 = 2;
            if (!v17) {
              continue;
            }
LABEL_27:
            sub_10004D2C8(v17);
            sub_10004D2C8(v17);
            continue;
          }
          v72.__r_.__value_.__r.__words[0] = 0;
          uint64_t v19 = *(void *)(a1 + 136);
          uint64_t v20 = *(std::__shared_weak_count **)(a1 + 96);
          long long v64 = v20;
          if (v20) {
            atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(std::string *__return_ptr, double, double))(*(void *)v19 + 16))(&v72, a2, a3);
          xpc_object_t v21 = v64;
          if (v64) {
LABEL_25:
          }
            sub_10004D2C8(v21);
        }
        sub_100058470((const void **)(v18 + 8), (const void **)&v72.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v72.__r_.__value_.__l.__data_);
        if (v17) {
          goto LABEL_27;
        }
      }
      while (*(void *)(a1 + 320));
    }
    sub_100D7A284((void **)(a1 + 280));
  }
  subscriber::makeSimSlotRange();
  std::string::size_type size = v65.__r_.__value_.__l.__size_;
  int v27 = (unsigned int *)v65.__r_.__value_.__r.__words[0];
  if (v65.__r_.__value_.__r.__words[0] != v65.__r_.__value_.__l.__size_)
  {
    char v29 = (uint64_t (*)(void))v65.__r_.__value_.__r.__words[2];
    while ((v29(*v27) & 1) == 0)
    {
      if (++v27 == (unsigned int *)size)
      {
        int v27 = (unsigned int *)size;
        break;
      }
    }
    std::string::size_type v62 = v65.__r_.__value_.__l.__size_;
    if (v27 != (unsigned int *)v65.__r_.__value_.__l.__size_)
    {
      uint64_t v30 = (void *)(a1 + 168);
      while (1)
      {
        BOOL v31 = v30;
        int v32 = *v27;
        unsigned __int8 v33 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), *v27);
        uint64_t v34 = v33;
        uint64_t v35 = *(void *)(a1 + 256);
        if (v35)
        {
          uint64_t v36 = a1 + 256;
          do
          {
            int v37 = *(_DWORD *)(v35 + 28);
            BOOL v38 = v37 < v32;
            if (v37 >= v32) {
              char v39 = (uint64_t *)v35;
            }
            else {
              char v39 = (uint64_t *)(v35 + 8);
            }
            if (!v38) {
              uint64_t v36 = v35;
            }
            uint64_t v35 = *v39;
          }
          while (*v39);
          if (v36 != a1 + 256 && *(_DWORD *)(v36 + 28) <= v32) {
            break;
          }
        }
        xpc_object_t v40 = *v33;
        uint64_t v30 = v31;
        if (os_log_type_enabled(*v33, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v72.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Could not find registration status for handling location available", (uint8_t *)&v72, 2u);
        }
LABEL_58:
        uint32_t v41 = v27 + 1;
        int v27 = (unsigned int *)size;
        if (v41 != (unsigned int *)size)
        {
          int v27 = v41;
          while ((v29(*v27) & 1) == 0)
          {
            if (++v27 == (unsigned int *)size)
            {
              int v27 = (unsigned int *)size;
              break;
            }
          }
          uint64_t v30 = v31;
        }
        if (v27 == (unsigned int *)v62) {
          goto LABEL_107;
        }
      }
      unsigned int v42 = *(_DWORD *)(v36 + 32);
      if (v42 > 6 || ((1 << v42) & 0x47) == 0)
      {
        int v53 = *v33;
        uint64_t v30 = v31;
        if (os_log_type_enabled(*v33, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v72.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Device is registered, no need to camping hints", (uint8_t *)&v72, 2u);
        }
        goto LABEL_58;
      }
      long long v44 = *v33;
      if (os_log_type_enabled(*v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v45 = asString();
        LODWORD(v72.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v72.__r_.__value_.__r.__words + 4) = v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Status %s, assuming device is not registered", (uint8_t *)&v72, 0xCu);
      }
      uint64_t v46 = *v31;
      if (!*v31) {
        goto LABEL_82;
      }
      uint64_t v47 = v31;
      do
      {
        int v48 = *(_DWORD *)(v46 + 32);
        BOOL v49 = v48 < v32;
        if (v48 >= v32) {
          char v50 = (uint64_t *)v46;
        }
        else {
          char v50 = (uint64_t *)(v46 + 8);
        }
        if (!v49) {
          uint64_t v47 = (void *)v46;
        }
        uint64_t v46 = *v50;
      }
      while (*v50);
      if (v47 != v31 && *((_DWORD *)v47 + 8) <= v32)
      {
        uint64_t v54 = v47[5];
        int v51 = (std::__shared_weak_count *)v47[6];
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v54)
        {
          uint64_t v61 = v54;
          char v55 = (*(uint64_t (**)(void))(*(void *)v54 + 24))();
          BOOL v56 = *v34;
          BOOL v57 = os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
          if (v55)
          {
            if (v57)
            {
              LOWORD(v72.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Already sent registration status hints, will re-send the next airplane mode toggle or baseband reset", (uint8_t *)&v72, 2u);
            }
            uint64_t v30 = v31;
          }
          else
          {
            if (v57)
            {
              LOWORD(v72.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Device is not registered, sending frequency hints", (uint8_t *)&v72, 2u);
            }
            CFTypeRef cf = 0;
            uint64_t v58 = *(void *)(a1 + 136);
            uint64_t v59 = *(void *)(a1 + 96);
            *(void *)long long buf = *(void *)(a1 + 88);
            *(void *)&uint8_t buf[8] = v59;
            if (v59) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
            }
            (*(void (**)(CFTypeRef *__return_ptr, double, double))(*(void *)v58 + 16))(&cf, a2, a3);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            int v66 = v32;
            CFTypeRef v67 = cf;
            if (cf) {
              CFRetain(cf);
            }
            xpc_object_t v70 = 0;
            lasd::write_rest_value(&v66, &v70);
            uint64_t v30 = v31;
            sub_100058DB0(&v72, "/cc/events/registration_hints");
            xpc_object_t object = v70;
            xpc_object_t v70 = xpc_null_create();
            ctu::RestModule::sendEvent();
            xpc_release(object);
            xpc_object_t object = 0;
            if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v72.__r_.__value_.__l.__data_);
            }
            xpc_release(v70);
            sub_1000577C4(&v67);
            (*(void (**)(uint64_t, uint64_t))(*(void *)v61 + 32))(v61, 1);
            sub_1000577C4(&cf);
          }
          goto LABEL_85;
        }
      }
      else
      {
LABEL_82:
        int v51 = 0;
      }
      int v52 = *v34;
      uint64_t v30 = v31;
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v72.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Could not get model for sending not registered hints", (uint8_t *)&v72, 2u);
      }
LABEL_85:
      if (v51) {
        sub_10004D2C8(v51);
      }
      goto LABEL_58;
    }
  }
LABEL_107:
  (*(void (**)(void))(**(void **)(a1 + 120) + 16))(*(void *)(a1 + 120));
  uint64_t result = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_100D7A100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,xpc_object_t object,xpc_object_t a28,uint64_t a29,uint64_t a30)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7A200(void *a1)
{
  unint64_t v2 = a1[4];
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)(a1[1] + 8 * (v2 / 0xAA)) + 24 * (v2 % 0xAA) + 16);
  if (v3)
  {
    sub_10004D2C8(v3);
    unint64_t v2 = a1[4];
  }
  uint64_t v4 = a1[5] - 1;
  a1[4] = v2 + 1;
  a1[5] = v4;

  sub_100D80814((uint64_t)a1, 1);
}

void sub_100D7A284(void **a1)
{
  if (a1[5])
  {
    sub_100D80814((uint64_t)a1, 0);
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v2 = (uint64_t)a1[2];
    uint64_t v4 = 170 * ((v2 - v3) >> 3) - 1;
    if (v2 == v3) {
      uint64_t v4 = 0;
    }
    if (v4 - ((unint64_t)a1[4] + (unint64_t)a1[5]) >= 0xAA)
    {
      operator delete(*(void **)(v2 - 8));
      uint64_t v3 = (uint64_t)a1[1];
      uint64_t v2 = (uint64_t)a1[2] - 8;
      a1[2] = (void *)v2;
    }
  }
  else
  {
    uint64_t v3 = (uint64_t)a1[2];
    if ((void *)v3 != a1[1])
    {
      do
      {
        operator delete(*(void **)(v3 - 8));
        int v5 = a1[1];
        uint64_t v3 = (uint64_t)a1[2] - 8;
        a1[2] = (void *)v3;
      }
      while ((void *)v3 != v5);
    }
    a1[4] = 0;
    uint64_t v2 = v3;
  }
  unint64_t v6 = (v2 - v3) >> 3;
  if (v6 < ((unsigned char *)a1[3] - (unsigned char *)*a1) >> 3)
  {
    if (v2 == v3)
    {
      std::string::size_type v10 = 0;
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = (char *)sub_100048350(v6);
      BOOL v8 = (char *)a1[1];
      uint64_t v2 = (uint64_t)a1[2];
      std::string::size_type v10 = &v7[8 * v9];
      uint64_t v11 = v2 - (void)v8;
      if ((char *)v2 != v8)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8 * (v11 >> 3);
        do
        {
          *(void *)&v7[v12] = *(void *)&v8[v12];
          v12 += 8;
        }
        while (v13 != v12);
        uint64_t v2 = (uint64_t)a1[1];
        int v14 = a1[2];
LABEL_17:
        uint64_t v15 = (uint64_t)v14 - v2;
        int v16 = *a1;
        *a1 = v7;
        a1[1] = v7;
        a1[2] = &v7[v15];
        a1[3] = v10;
        if (v16)
        {
          operator delete(v16);
        }
        return;
      }
    }
    int v14 = (void *)v2;
    goto LABEL_17;
  }
}

uint64_t sub_100D7A3E4(void **a1, uint64_t a2)
{
  uint64_t v4 = a1[4];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v12 = 136315138;
    *(void *)&void v12[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Location was not available at this time: %s", v12, 0xCu);
    uint64_t v4 = a1[4];
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = a1[40];
    *(_DWORD *)uint64_t v12 = 134217984;
    *(void *)&void v12[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending %zu pending replies", v12, 0xCu);
  }
  while (a1[40])
  {
    unint64_t v6 = *((void *)a1[36] + (unint64_t)a1[39] / 0xAA) + 24 * ((unint64_t)a1[39] % 0xAA);
    uint64_t v8 = *(void *)(v6 + 8);
    uint64_t v7 = *(std::__shared_weak_count **)(v6 + 16);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100D7A200(a1 + 35);
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      *(_DWORD *)uint64_t v8 = 2;
      uint64_t v9 = *(void *)(v8 + 8);
      *(void *)(v8 + 8) = 0;
      *(void *)uint64_t v12 = v9;
      sub_1000577C4((const void **)v12);
      sub_10004D2C8(v7);
      sub_10004D2C8(v7);
    }
    else
    {
      sub_100D7A200(a1 + 35);
      *(_DWORD *)uint64_t v8 = 2;
      uint64_t v10 = *(void *)(v8 + 8);
      *(void *)(v8 + 8) = 0;
      *(void *)uint64_t v12 = v10;
      sub_1000577C4((const void **)v12);
    }
  }
  sub_100D7A284(a1 + 35);
  uint64_t result = (uint64_t)a1[41];
  a1[41] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_100D7A5D8(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 193);
  int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
  int v4 = v3;
  if (!v2)
  {
    *(_WORD *)(a1 + 192) = v3 | 0x100;
    uint64_t v10 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    uint64_t v11 = "not available";
    if (v4) {
      uint64_t v11 = "available";
    }
    int v16 = 136315138;
    unint64_t v17 = v11;
    uint64_t v12 = "#I Location services are %s";
    goto LABEL_15;
  }
  if (*(unsigned __int8 *)(a1 + 192) == v3)
  {
    int v5 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    unint64_t v6 = "not available";
    if (v4) {
      unint64_t v6 = "available";
    }
    int v16 = 136315138;
    unint64_t v17 = v6;
    uint64_t v7 = "#I Location services authorized remains at %s";
    uint64_t v8 = v5;
    uint32_t v9 = 12;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v16, v9);
    return;
  }
  *(_WORD *)(a1 + 192) = v3 | 0x100;
  uint64_t v10 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "not available";
    if (v4) {
      uint64_t v13 = "available";
    }
    int v16 = 136315138;
    unint64_t v17 = v13;
    uint64_t v12 = "#I Location authorization changed, now %s";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, 0xCu);
  }
LABEL_16:
  if (*(unsigned char *)(a1 + 337))
  {
    int v14 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v16) = 0;
    uint64_t v7 = "#I Radio is down, pending location authorization change";
    uint64_t v8 = v14;
    uint32_t v9 = 2;
    goto LABEL_19;
  }
  if (*(unsigned char *)(a1 + 192)) {
    int v15 = 5;
  }
  else {
    int v15 = 6;
  }
  sub_100D7A7F4(a1 + 200, v15);
}

void sub_100D7A7F4(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  int v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/lasd_status_hint");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100D7A898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100D7A8DC(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v6 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Did not find any frequency information for %s fetch type", (uint8_t *)&buf, 0xCu);
  }
  *(_DWORD *)a3 = 4;
  xpc_object_t object = 0;
  char v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t object = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t object = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_11;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_10:
  xpc_object_t object = v9;
LABEL_11:
  xpc_release(v8);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t xarray = 0;
    long long buf = 0uLL;
    int v51 = 0;
    ctu::cf::assign();
    long long __p = buf;
    *(void *)&long long v49 = v51;
    p_p = (long long *)buf;
    if (SHIBYTE(v51) >= 0) {
      p_p = &__p;
    }
    v37[0] = &object;
    v37[1] = p_p;
    sub_10005107C((uint64_t)v37, &xarray);
    if (SBYTE7(v49) < 0) {
      operator delete((void *)__p);
    }
    if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array)
    {
      if (*a2 == 1)
      {
        *(void *)&long long buf = xarray;
        if (xarray) {
          xpc_retain(xarray);
        }
        else {
          *(void *)&long long buf = xpc_null_create();
        }
        sub_100048BF4(&v44, (void **)&buf, 0);
        xpc_release((xpc_object_t)buf);
        *(void *)&long long buf = xarray;
        if (xarray) {
          xpc_retain(xarray);
        }
        else {
          *(void *)&long long buf = xpc_null_create();
        }
        if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array) {
          count = (void *)xpc_array_get_count(xarray);
        }
        else {
          count = 0;
        }
        sub_100048BF4(v43, (void **)&buf, count);
        xpc_release((xpc_object_t)buf);
        int v15 = (void *)(a3 + 16);
        for (uint64_t i = v45; i != v43[1] || v44 != v43[0]; uint64_t i = ++v45)
        {
          v42[0] = &v44;
          v42[1] = i;
          xpc_object_t v41 = 0;
          sub_10003FBDC((uint64_t)v42, &v41);
          xpc_object_t v40 = 0;
          long long buf = 0uLL;
          int v51 = 0;
          ctu::cf::assign();
          long long __p = buf;
          *(void *)&long long v49 = v51;
          unint64_t v17 = (long long *)buf;
          if (SHIBYTE(v51) >= 0) {
            unint64_t v17 = &__p;
          }
          v37[0] = &v41;
          v37[1] = v17;
          sub_100048BAC((uint64_t)v37, &v40);
          if (SBYTE7(v49) < 0) {
            operator delete((void *)__p);
          }
          long long __p = 0u;
          long long v49 = 0u;
          unsigned __int16 v19 = xpc::dyn_cast_or_default((xpc *)&v40, 0, v18);
          MCC::MCC((MCC *)&__p, v19);
          xpc_object_t v39 = 0;
          long long buf = 0uLL;
          int v51 = 0;
          ctu::cf::assign();
          *(_OWORD *)int v37 = buf;
          *(void *)&long long v38 = v51;
          uint64_t v20 = (void **)buf;
          if (SHIBYTE(v51) >= 0) {
            uint64_t v20 = v37;
          }
          v35[0] = &v41;
          v35[1] = v20;
          sub_100048BAC((uint64_t)v35, &v39);
          if (SBYTE7(v38) < 0) {
            operator delete(v37[0]);
          }
          *(_OWORD *)int v37 = 0u;
          long long v38 = 0u;
          unsigned __int16 v22 = xpc::dyn_cast_or_default((xpc *)&v39, 0, v21);
          MNC::MNC((MNC *)v37, v22, (const MCC *)&__p);
          formPLMN((const MCC *)&__p, (const MNC *)v37);
          unint64_t v24 = *(void *)(a3 + 24);
          unint64_t v23 = *(void *)(a3 + 32);
          if (v24 >= v23)
          {
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - *v15) >> 3);
            unint64_t v27 = v26 + 1;
            if (v26 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - *v15) >> 3);
            if (2 * v28 > v27) {
              unint64_t v27 = 2 * v28;
            }
            if (v28 >= 0x555555555555555) {
              unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v29 = v27;
            }
            uint64_t v53 = a3 + 32;
            if (v29) {
              uint64_t v30 = (char *)sub_10004812C(a3 + 32, v29);
            }
            else {
              uint64_t v30 = 0;
            }
            BOOL v31 = &v30[24 * v26];
            *(void *)&long long buf = v30;
            *((void *)&buf + 1) = v31;
            int v52 = &v30[24 * v29];
            long long v32 = *(_OWORD *)v35;
            *((void *)v31 + 2) = v36;
            *(_OWORD *)BOOL v31 = v32;
            v35[1] = 0;
            uint64_t v36 = 0;
            v35[0] = 0;
            int v51 = v31 + 24;
            sub_100048204((uint64_t *)(a3 + 16), &buf);
            uint64_t v33 = *(void *)(a3 + 24);
            sub_100048174((uint64_t)&buf);
            int v34 = SHIBYTE(v36);
            *(void *)(a3 + 24) = v33;
            if (v34 < 0) {
              operator delete(v35[0]);
            }
          }
          else
          {
            long long v25 = *(_OWORD *)v35;
            *(void *)(v24 + 16) = v36;
            *(_OWORD *)unint64_t v24 = v25;
            *(void *)(a3 + 24) = v24 + 24;
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(v37[1]);
          }
          xpc_release(v39);
          if (SHIBYTE(v49) < 0) {
            operator delete(*((void **)&__p + 1));
          }
          xpc_release(v40);
          xpc_release(v41);
        }
        xpc_release(v44);
        xpc_release(v44);
      }
    }
    else
    {
      uint64_t v12 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        sub_100120074(&object, &buf);
        uint64_t v13 = SHIBYTE(v51) >= 0 ? &buf : (long long *)buf;
        LODWORD(__p) = 136315138;
        *(void *)((char *)&__p + 4) = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Could not find fetch parameters in input frequency dictionary: %s", (uint8_t *)&__p, 0xCu);
        if (SHIBYTE(v51) < 0) {
          operator delete((void *)buf);
        }
      }
    }
    xpc_release(xarray);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Could not convert frequency input frequency dictionary to XPC dictionary", (uint8_t *)&buf, 2u);
    }
  }
  xpc_release(object);
}

void sub_100D7AEC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,xpc_object_t a27,xpc_object_t a28,xpc_object_t a29,uint64_t a30,uint64_t a31,xpc_object_t a32,uint64_t a33,xpc_object_t object,uint64_t a35,xpc_object_t a36,xpc_object_t a37,char a38,void *a39,int a40,__int16 a41,char a42,char a43,int a44,__int16 a45,char a46,char a47)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100D7B090(uint64_t a1, size_t a2, xpc_object_t object)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (object)
  {
    xpc_object_t v6 = object;
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v6);
    xpc_object_t v7 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
  }
LABEL_8:
  xpc_release(v6);
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
  {
    size_t count = xpc_array_get_count(v7);
    uint64_t v10 = *(NSObject **)(v5 + 32);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "s";
      int v13 = 134218498;
      size_t v14 = count;
      __int16 v15 = 2080;
      if (count == 1) {
        uint64_t v11 = "";
      }
      uint64_t v16 = v11;
      __int16 v17 = 2080;
      size_t v18 = a2;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Found %zu hint%s for %s", (uint8_t *)&v13, 0x20u);
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += count;
  }
  else
  {
    xpc_object_t v8 = *(NSObject **)(v5 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 136315138;
      size_t v14 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Could not get frequency array for %s", (uint8_t *)&v13, 0xCu);
    }
  }
  xpc_release(v7);
  return 1;
}

void sub_100D7B260(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_100D7B29C(void *a1, uint64_t a2)
{
  int v4 = (char *)operator new(0x58uLL);
  *((void *)v4 + 2) = 0;
  *(void *)int v4 = off_101A57250;
  *((_DWORD *)v4 + 6) = *(_DWORD *)a2;
  long long v5 = *(_OWORD *)(a2 + 24);
  *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 8);
  *((_OWORD *)v4 + 3) = v5;
  *((_DWORD *)v4 + 16) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)(v4 + 72) = *(_OWORD *)(a2 + 48);
  *a1 = v4 + 24;
  a1[1] = v4;
  *((void *)v4 + 1) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);

  sub_10004D2C8((std::__shared_weak_count *)v4);
}

void sub_100D7B340(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 216) == 1)
  {
    if (*(unsigned char *)(a1 + 152))
    {
      if (!*(unsigned char *)(a1 + 188) || *(_DWORD *)(a1 + 184) != 2) {
        return;
      }
      int v2 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WiFi now available and previous update failed, forcing another one", buf, 2u);
      }
      uint64_t v3 = *(void *)(a1 + 88);
      int v4 = *(NSObject **)(a1 + 16);
      uint64_t v10 = v4;
      if (v4) {
        dispatch_retain(v4);
      }
      (*(void (**)(uint64_t, uint64_t, NSObject **))(*(void *)v3 + 24))(v3, 1, &v10);
      long long v5 = v10;
      if (!v10) {
        return;
      }
LABEL_19:
      dispatch_release(v5);
      return;
    }
    xpc_object_t v7 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I WiFi now available, checking for initial update", buf, 2u);
    }
    uint64_t v8 = *(void *)(a1 + 88);
    xpc_object_t v9 = *(NSObject **)(a1 + 16);
    dispatch_object_t object = v9;
    if (v9) {
      dispatch_retain(v9);
    }
    (*(void (**)(uint64_t, void, dispatch_object_t *))(*(void *)v8 + 24))(v8, 0, &object);
    long long v5 = object;
    if (object) {
      goto LABEL_19;
    }
  }
  else if (!*(unsigned char *)(a1 + 152))
  {
    xpc_object_t v6 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Deferring initial update until WiFi is available", buf, 2u);
    }
  }
}

void sub_100D7B4EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7B514(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 4sub_100732068((uint64_t)&a9, 0) = *((_DWORD *)a2 + 4);
  unsigned int v5 = *a2;
  if (v5 - 2 >= 2)
  {
    if (v5 > 1)
    {
      long long v38 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(cf) = 136315138;
        *(void *)((char *)&cf + 4) = asString();
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#N Unhandled fetch type in search request: %s", (uint8_t *)&cf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 136);
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
      uint64_t v143 = *(void *)(a1 + 88);
      uint64_t v144 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v141 = 0;
      sub_100058198(&v145, (const void **)a2 + 1);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t *, const void **))(*(void *)v7 + 24))(&cf, v7, &v143, &v145);
      char v141 = (_DWORD *)cf;
      if ((void)cf) {
        CFRetain((CFTypeRef)cf);
      }
      sub_100057D78((const void **)&cf);
      sub_100057D78(&v145);
      if (v144) {
        sub_10004D2C8(v144);
      }
      if (v141) {
        xpc_object_t v9 = sub_100080934;
      }
      else {
        xpc_object_t v9 = 0;
      }
      if (v9)
      {
        uint64_t v10 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        if (v10 || (uint64_t v10 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v10);
            xpc_object_t v11 = v10;
          }
          else
          {
            xpc_object_t v11 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v11 = xpc_null_create();
          uint64_t v10 = 0;
        }
        xpc_release(v10);
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
        {
          __p[0] = 0;
          __p[1] = __p;
          uint64_t v139 = 0x2000000000;
          uint64_t v140 = 0;
          *(void *)&long long cf = _NSConcreteStackBlock;
          *((void *)&cf + 1) = 0x40000000;
          v149 = sub_100D7B090;
          p_long long cf = (long long *)&unk_101A56BA0;
          v151 = __p;
          uint64_t v152 = a1;
          xpc_dictionary_apply(v11, &cf);
          uint64_t v45 = *((void *)__p[1] + 3);
          if (v45)
          {
            uint64_t v46 = *(NSObject **)(a1 + 32);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v47 = asString();
              int v48 = "s";
              *(_DWORD *)long long buf = 134218498;
              *(void *)&uint8_t buf[4] = v45;
              *(_WORD *)&unsigned char buf[12] = 2080;
              if (v45 == 1) {
                int v48 = "";
              }
              *(void *)&buf[14] = v48;
              *(_WORD *)&unsigned char buf[22] = 2080;
              uint64_t v147 = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Found %zu technology hint%s in LASD database for %s", buf, 0x20u);
            }
            *(_DWORD *)a3 = 1;
            sub_100058470((const void **)(a3 + 8), (const void **)&v141);
          }
          else
          {
            sub_100D7A8DC(a1, a2, a3);
          }
          _Block_object_dispose(__p, 8);
        }
        else
        {
          xpc_object_t v44 = *(NSObject **)(a1 + 32);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(cf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#N Could not convert fetch frequency results into XPC object", (uint8_t *)&cf, 2u);
          }
          sub_100D7A8DC(a1, a2, a3);
        }
        xpc_release(v11);
      }
      else
      {
        xpc_object_t v39 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          LOWORD(cf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "No frequency dictionary found from database", (uint8_t *)&cf, 2u);
        }
      }
      sub_1000577C4((const void **)&v141);
    }
    return;
  }
  char v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
  int v13 = *(NSObject **)(a1 + 32);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if ((v12 & 1) == 0)
  {
    if (v14)
    {
      LOWORD(cf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Border fetch indication: location service authorization is disabled", (uint8_t *)&cf, 2u);
    }
    long long cf = 0uLL;
    sub_100D7B29C(&cf, a3);
    *(_DWORD *)long long cf = 6;
    int v37 = (std::__shared_weak_count *)*((void *)&cf + 1);
    if (*((void *)&cf + 1)) {
      goto LABEL_95;
    }
    return;
  }
  if (v14)
  {
    LODWORD(cf) = 136315138;
    *(void *)((char *)&cf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Handling %s fetch request", (uint8_t *)&cf, 0xCu);
  }
  char v141 = 0;
  v142 = 0;
  sub_100D7B29C(&v141, a3);
  __int16 v15 = *(char **)(a1 + 296);
  uint64_t v16 = *(char **)(a1 + 288);
  unint64_t v17 = (v15 - v16) >> 3;
  size_t v18 = v141;
  *char v141 = 0;
  if (v15 == v16) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = 170 * v17 - 1;
  }
  unint64_t v21 = *(void *)(a1 + 312);
  uint64_t v20 = *(void *)(a1 + 320);
  unint64_t v22 = v20 + v21;
  if (v19 == v20 + v21)
  {
    if (v21 < 0xAA)
    {
      xpc_object_t v40 = *(char **)(a1 + 304);
      xpc_object_t v41 = *(char **)(a1 + 280);
      if (v17 >= (v40 - v41) >> 3)
      {
        if (v40 == v41) {
          unint64_t v49 = 1;
        }
        else {
          unint64_t v49 = (v40 - v41) >> 2;
        }
        char v50 = (char *)sub_100048350(v49);
        uint64_t v52 = v51;
        uint64_t v53 = operator new(0xFF0uLL);
        uint64_t v54 = &v50[8 * v17];
        char v55 = &v50[8 * v52];
        if (v17 == v52)
        {
          uint64_t v56 = 8 * v17;
          if (v15 - v16 < 1)
          {
            xpc_object_t v104 = v53;
            uint64_t v105 = v56 >> 2;
            if (v15 == v16) {
              unint64_t v106 = 1;
            }
            else {
              unint64_t v106 = v105;
            }
            int v107 = (char *)sub_100048350(v106);
            uint64_t v54 = &v107[8 * (v106 >> 2)];
            char v55 = &v107[8 * v108];
            if (v50) {
              operator delete(v50);
            }
            char v50 = v107;
            uint64_t v53 = v104;
          }
          else
          {
            uint64_t v57 = v56 >> 3;
            if (v57 >= -1) {
              unint64_t v58 = v57 + 1;
            }
            else {
              unint64_t v58 = v57 + 2;
            }
            v54 -= 8 * (v58 >> 1);
          }
        }
        *(void *)uint64_t v54 = v53;
        char v109 = v54 + 8;
        for (uint64_t i = *(void *)(a1 + 296); i != *(void *)(a1 + 288); i -= 8)
        {
          if (v54 == v50)
          {
            if (v109 >= v55)
            {
              if (v55 == v50) {
                unint64_t v115 = 1;
              }
              else {
                unint64_t v115 = (v55 - v50) >> 2;
              }
              long long v116 = (char *)sub_100048350(v115);
              xpc_object_t v118 = v116;
              uint64_t v54 = &v116[(2 * v115 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v119 = v109 - v50;
              BOOL v59 = v109 == v50;
              char v109 = v54;
              if (!v59)
              {
                char v109 = &v54[v119 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v120 = 8 * (v119 >> 3);
                xpc_object_t v121 = v54;
                xpc_object_t v122 = (uint64_t *)v50;
                do
                {
                  uint64_t v123 = *v122++;
                  *(void *)xpc_object_t v121 = v123;
                  v121 += 8;
                  v120 -= 8;
                }
                while (v120);
              }
              char v55 = &v116[8 * v117];
              if (v50) {
                operator delete(v50);
              }
              char v50 = v118;
            }
            else
            {
              uint64_t v111 = (v55 - v109) >> 3;
              if (v111 >= -1) {
                uint64_t v112 = v111 + 1;
              }
              else {
                uint64_t v112 = v111 + 2;
              }
              uint64_t v113 = v112 >> 1;
              uint64_t v54 = &v50[8 * (v112 >> 1)];
              xpc_object_t v114 = v50;
              if (v109 != v50)
              {
                memmove(v54, v50, v109 - v50);
                xpc_object_t v114 = v109;
              }
              char v109 = &v114[8 * v113];
            }
          }
          uint64_t v124 = *(void *)(i - 8);
          *((void *)v54 - 1) = v124;
          v54 -= 8;
        }
        xpc_object_t v125 = *(void **)(a1 + 280);
        *(void *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = v50;
        *(void *)(a1 + 288) = v54;
        *(void *)(a1 + 296) = v109;
        *(void *)(a1 + 304) = v55;
        if (v125) {
          operator delete(v125);
        }
        goto LABEL_79;
      }
      unsigned int v42 = operator new(0xFF0uLL);
      uint64_t v43 = v42;
      if (v40 == v15)
      {
        if (v16 == v41)
        {
          if (v15 == v16) {
            unint64_t v82 = 1;
          }
          else {
            unint64_t v82 = (v40 - v16) >> 2;
          }
          int v83 = (char *)sub_100048350(v82);
          uint64_t v16 = &v83[(2 * v82 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v85 = *(uint64_t **)(a1 + 288);
          xpc_object_t v86 = v16;
          uint64_t v87 = *(void *)(a1 + 296) - (void)v85;
          if (v87)
          {
            xpc_object_t v86 = &v16[v87 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v88 = 8 * (v87 >> 3);
            int v89 = v16;
            do
            {
              uint64_t v90 = *v85++;
              *(void *)int v89 = v90;
              v89 += 8;
              v88 -= 8;
            }
            while (v88);
          }
          char v91 = *(void **)(a1 + 280);
          *(void *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = v83;
          *(void *)(a1 + 288) = v16;
          *(void *)(a1 + 296) = v86;
          *(void *)(a1 + 304) = &v83[8 * v84];
          if (v91)
          {
            operator delete(v91);
            uint64_t v16 = *(char **)(a1 + 288);
          }
        }
        *((void *)v16 - 1) = v43;
        BOOL v92 = *(char **)(a1 + 288);
        uint64_t v93 = *(char **)(a1 + 296);
        *(void *)(a1 + 288) = v92 - 8;
        uint64_t v94 = *((void *)v92 - 1);
        *(void *)(a1 + 288) = v92;
        if (v93 == *(char **)(a1 + 304))
        {
          unint64_t v95 = *(void *)(a1 + 280);
          uint64_t v96 = (uint64_t)&v92[-v95];
          if ((unint64_t)v92 <= v95)
          {
            uint64_t v126 = (uint64_t)&v93[-v95];
            BOOL v59 = v126 == 0;
            uint64_t v127 = v126 >> 2;
            if (v59) {
              unint64_t v128 = 1;
            }
            else {
              unint64_t v128 = v127;
            }
            xpc_object_t v129 = (char *)sub_100048350(v128);
            xpc_object_t v131 = &v129[8 * (v128 >> 2)];
            xpc_object_t v132 = *(uint64_t **)(a1 + 288);
            uint64_t v93 = v131;
            uint64_t v133 = *(void *)(a1 + 296) - (void)v132;
            if (v133)
            {
              uint64_t v93 = &v131[v133 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v134 = 8 * (v133 >> 3);
              uint64_t v135 = &v129[8 * (v128 >> 2)];
              do
              {
                uint64_t v136 = *v132++;
                *(void *)uint64_t v135 = v136;
                v135 += 8;
                v134 -= 8;
              }
              while (v134);
            }
            xpc_object_t v137 = *(void **)(a1 + 280);
            *(void *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = v129;
            *(void *)(a1 + 288) = v131;
            *(void *)(a1 + 296) = v93;
            *(void *)(a1 + 304) = &v129[8 * v130];
            if (v137)
            {
              operator delete(v137);
              uint64_t v93 = *(char **)(a1 + 296);
            }
          }
          else
          {
            uint64_t v97 = v96 >> 3;
            BOOL v29 = v96 >> 3 < -1;
            uint64_t v98 = (v96 >> 3) + 2;
            if (v29) {
              uint64_t v99 = v98;
            }
            else {
              uint64_t v99 = v97 + 1;
            }
            uint64_t v100 = -(v99 >> 1);
            uint64_t v101 = v99 >> 1;
            xpc_object_t v102 = &v92[-8 * v101];
            int64_t v103 = v93 - v92;
            if (v93 != v92)
            {
              memmove(&v92[-8 * v101], v92, v93 - v92);
              BOOL v92 = *(char **)(a1 + 288);
            }
            uint64_t v93 = &v102[v103];
            *(void *)(a1 + 288) = &v92[8 * v100];
            *(void *)(a1 + 296) = &v102[v103];
          }
        }
        *(void *)uint64_t v93 = v94;
      }
      else
      {
        *(void *)__int16 v15 = v42;
      }
    }
    else
    {
      *(void *)(a1 + 312) = v21 - 170;
      uint64_t v25 = *(void *)v16;
      unint64_t v23 = v16 + 8;
      uint64_t v24 = v25;
      *(void *)(a1 + 288) = v23;
      if (v15 == *(char **)(a1 + 304))
      {
        unint64_t v26 = *(void *)(a1 + 280);
        uint64_t v27 = (uint64_t)&v23[-v26];
        if ((unint64_t)v23 <= v26)
        {
          uint64_t v60 = (uint64_t)&v15[-v26];
          BOOL v59 = v60 == 0;
          uint64_t v61 = v60 >> 2;
          if (v59) {
            unint64_t v62 = 1;
          }
          else {
            unint64_t v62 = v61;
          }
          long long v63 = (char *)sub_100048350(v62);
          std::string v65 = &v63[8 * (v62 >> 2)];
          int v66 = *(uint64_t **)(a1 + 288);
          __int16 v15 = v65;
          uint64_t v67 = *(void *)(a1 + 296) - (void)v66;
          if (v67)
          {
            __int16 v15 = &v65[v67 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v68 = 8 * (v67 >> 3);
            int v69 = &v63[8 * (v62 >> 2)];
            do
            {
              uint64_t v70 = *v66++;
              *(void *)int v69 = v70;
              v69 += 8;
              v68 -= 8;
            }
            while (v68);
          }
          int v71 = *(void **)(a1 + 280);
          *(void *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = v63;
          *(void *)(a1 + 288) = v65;
          *(void *)(a1 + 296) = v15;
          *(void *)(a1 + 304) = &v63[8 * v64];
          if (v71)
          {
            operator delete(v71);
            __int16 v15 = *(char **)(a1 + 296);
          }
        }
        else
        {
          uint64_t v28 = v27 >> 3;
          BOOL v29 = v27 >> 3 < -1;
          uint64_t v30 = (v27 >> 3) + 2;
          if (v29) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v28 + 1;
          }
          uint64_t v32 = -(v31 >> 1);
          uint64_t v33 = v31 >> 1;
          int v34 = &v23[-8 * v33];
          int64_t v35 = v15 - v23;
          if (v15 != v23)
          {
            memmove(&v23[-8 * v33], v23, v15 - v23);
            __int16 v15 = *(char **)(a1 + 288);
          }
          uint64_t v36 = &v15[8 * v32];
          __int16 v15 = &v34[v35];
          *(void *)(a1 + 288) = v36;
          *(void *)(a1 + 296) = &v34[v35];
        }
      }
      *(void *)__int16 v15 = v24;
    }
    *(void *)(a1 + 296) += 8;
LABEL_79:
    uint64_t v16 = *(char **)(a1 + 288);
    uint64_t v20 = *(void *)(a1 + 320);
    unint64_t v22 = v20 + *(void *)(a1 + 312);
    size_t v18 = v141;
  }
  unint64_t v72 = *(void *)&v16[8 * (v22 / 0xAA)] + 24 * (v22 % 0xAA);
  *(unsigned char *)unint64_t v72 = v5;
  *(void *)(v72 + 8) = v18;
  BOOL v73 = v142;
  *(void *)(v72 + 16) = v142;
  if (v73)
  {
    atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v20 = *(void *)(a1 + 320);
  }
  *(void *)(a1 + 32sub_100732068((uint64_t)&a9, 0) = v20 + 1;
  (*(void (**)(void, const char *))(**(void **)(a1 + 120) + 24))(*(void *)(a1 + 120), "Fetch request");
  Registry::getTimerService(&v143, *(Registry **)(a1 + 72));
  uint64_t v74 = v143;
  sub_100058DB0(buf, "LASD lat/long timer");
  xpc_object_t v75 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v75 || (uint64_t v76 = *(void *)a1, (v77 = std::__shared_weak_count::lock(v75)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v78 = (uint64_t (*)(uint64_t, size_t, xpc_object_t))v77;
  atomic_fetch_add_explicit(&v77->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v77);
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v139 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  *(void *)&long long cf = off_101A572A0;
  *((void *)&cf + 1) = v76;
  v149 = v78;
  p_long long cf = &cf;
  (*(void (**)(const void **__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, long long *))(*(void *)v74 + 40))(&v145, v74, __p, 1, 20000000, 0, &cf);
  sub_10003B34C(&cf);
  if (SHIBYTE(v139) < 0) {
    operator delete(__p[0]);
  }
  long long v79 = v145;
  v145 = 0;
  uint64_t v80 = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = v79;
  if (v80)
  {
    (*(void (**)(uint64_t))(*(void *)v80 + 8))(v80);
    xpc_object_t v81 = v145;
    v145 = 0;
    if (v81) {
      (*(void (**)(const void *))(*(void *)v81 + 8))(v81);
    }
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (v144) {
    sub_10004D2C8(v144);
  }
  if (v73)
  {
    int v37 = v73;
LABEL_95:
    sub_10004D2C8(v37);
  }
}

void sub_100D7C044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char a29)
{
  operator delete(v30);
  if (v29) {
    operator delete(v29);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100D7C150(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 152)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v28 = 136315138;
    uint64_t v29 = (uint64_t)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Initial update completed: %s", (uint8_t *)&v28, 0xCu);
    int v2 = *(NSObject **)(a1 + 32);
  }
  int v4 = *(unsigned __int8 *)(a1 + 188);
  BOOL v5 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v5) {
      goto LABEL_12;
    }
    uint64_t v6 = asString();
    int v28 = 136315138;
    uint64_t v29 = v6;
    uint64_t v7 = "#I Previous update result: %s";
    uint64_t v8 = v2;
    uint32_t v9 = 12;
  }
  else
  {
    if (!v5) {
      goto LABEL_12;
    }
    LOWORD(v28) = 0;
    uint64_t v7 = "#I Previous update result: not set";
    uint64_t v8 = v2;
    uint32_t v9 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v28, v9);
LABEL_12:
  int v10 = *(unsigned __int8 *)(a1 + 193);
  xpc_object_t v11 = *(NSObject **)(a1 + 32);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (!v12) {
      goto LABEL_21;
    }
    if (*(unsigned char *)(a1 + 192)) {
      int v13 = "true";
    }
    else {
      int v13 = "false";
    }
    int v28 = 136315138;
    uint64_t v29 = (uint64_t)v13;
    BOOL v14 = "#I Location services authorization: %s";
    __int16 v15 = v11;
    uint32_t v16 = 12;
  }
  else
  {
    if (!v12) {
      goto LABEL_21;
    }
    LOWORD(v28) = 0;
    BOOL v14 = "#I Location services authorization: not set";
    __int16 v15 = v11;
    uint32_t v16 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v28, v16);
LABEL_21:
  unint64_t v17 = *(NSObject **)(a1 + 32);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v18)
  {
    uint64_t v19 = *(void *)(a1 + 320);
    int v28 = 134217984;
    uint64_t v29 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %zu pending search replies", (uint8_t *)&v28, 0xCu);
  }
  if ((capabilities::ct::supportsVoiceCall((capabilities::ct *)v18) & 1) == 0)
  {
    uint64_t v20 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 338)) {
        unint64_t v21 = "true";
      }
      else {
        unint64_t v21 = "false";
      }
      int v28 = 136315138;
      uint64_t v29 = (uint64_t)v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Cellular data setting: %s", (uint8_t *)&v28, 0xCu);
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 88) + 64))(*(void *)(a1 + 88));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 48))(*(void *)(a1 + 136));
  unint64_t v23 = *(void **)(a1 + 160);
  uint64_t v24 = (void *)(a1 + 168);
  if (v23 != v24)
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v23[5] + 16))(v23[5]);
      uint64_t v25 = (void *)v23[1];
      if (v25)
      {
        do
        {
          unint64_t v26 = v25;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unint64_t v26 = (void *)v23[2];
          BOOL v27 = *v26 == (void)v23;
          unint64_t v23 = v26;
        }
        while (!v27);
      }
      unint64_t v23 = v26;
    }
    while (v26 != v24);
  }
  return result;
}

uint64_t sub_100D7C4A4(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 336);
  if (v2 != a2)
  {
    uint64_t v3 = result;
    int v4 = *(NSObject **)(result + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v5 = "true";
      if (!v2) {
        BOOL v5 = "false";
      }
      int v10 = 136315138;
      xpc_object_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Radio online is now %s", (uint8_t *)&v10, 0xCu);
      int v2 = *(unsigned __int8 *)(v3 + 336);
    }
    if (v2)
    {
      uint64_t v6 = *(void **)(v3 + 160);
      if (v6 != (void *)(v3 + 168))
      {
        do
        {
          (*(void (**)(void, void))(*(void *)v6[5] + 32))(v6[5], 0);
          uint64_t v7 = (void *)v6[1];
          if (v7)
          {
            do
            {
              uint64_t v8 = v7;
              uint64_t v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              uint64_t v8 = (void *)v6[2];
              BOOL v9 = *v8 == (void)v6;
              uint64_t v6 = v8;
            }
            while (!v9);
          }
          uint64_t v6 = v8;
        }
        while (v8 != (void *)(v3 + 168));
      }
      return (*(uint64_t (**)(void, const char *))(**(void **)(v3 + 120) + 24))(*(void *)(v3 + 120), "Radio online");
    }
    else
    {
      return (*(uint64_t (**)(void))(**(void **)(v3 + 120) + 16))(*(void *)(v3 + 120));
    }
  }
  return result;
}

void sub_100D7C644(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 337);
  BOOL v5 = *(NSObject **)(a1 + 32);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 == a2)
  {
    if (!v6) {
      return;
    }
    uint64_t v7 = "false";
    if (a2) {
      uint64_t v7 = "true";
    }
    int v17 = 136315138;
    BOOL v18 = v7;
    uint64_t v8 = "#I Radio is down remains at %s";
    BOOL v9 = v5;
    uint32_t v10 = 12;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v17, v10);
    return;
  }
  if (v6)
  {
    xpc_object_t v11 = "true";
    if (!v4) {
      xpc_object_t v11 = "false";
    }
    int v17 = 136315138;
    BOOL v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Radio is down now %s", (uint8_t *)&v17, 0xCu);
    int v4 = *(unsigned __int8 *)(a1 + 337);
  }
  if (v4)
  {
    BOOL v12 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v17) = 0;
    uint64_t v8 = "#I Radio is down, pending location authorization change";
    BOOL v9 = v12;
    uint32_t v10 = 2;
    goto LABEL_13;
  }
  if (!*(unsigned char *)(a1 + 193))
  {
    int v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
    *(_WORD *)(a1 + 192) = v13 | 0x100;
    BOOL v14 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v15 = "not available";
      if (v13) {
        __int16 v15 = "available";
      }
      int v17 = 136315138;
      BOOL v18 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Location services are %s", (uint8_t *)&v17, 0xCu);
    }
  }
  if (*(unsigned char *)(a1 + 192)) {
    int v16 = 5;
  }
  else {
    int v16 = 6;
  }
  sub_100D7A7F4(a1 + 200, v16);
}

void sub_100D7C860(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D7C898(uint64_t a1)
{
}

uint64_t sub_100D7C8B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100D7C8F8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 328);
    *(void *)(v1 + 328) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *(void ***)(v1 + 288);
    int v4 = *(void ***)(v1 + 296);
    if (v4 == v3)
    {
      BOOL v9 = (void *)(v1 + 320);
      int v4 = *(void ***)(v1 + 288);
    }
    else
    {
      unint64_t v5 = *(void *)(v1 + 312);
      BOOL v6 = &v3[v5 / 0xAA];
      unint64_t v7 = (unint64_t)*v6;
      unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
      BOOL v9 = (void *)(v1 + 320);
      unint64_t v10 = (unint64_t)v3[(*(void *)(v1 + 320) + v5) / 0xAA] + 24 * ((*(void *)(v1 + 320) + v5) % 0xAA);
      if (v8 != v10)
      {
        do
        {
          xpc_object_t v11 = *(std::__shared_weak_count **)(v8 + 16);
          if (v11)
          {
            sub_10004D2C8(v11);
            unint64_t v7 = (unint64_t)*v6;
          }
          v8 += 24;
          if (v8 - v7 == 4080)
          {
            unint64_t v12 = (unint64_t)v6[1];
            ++v6;
            unint64_t v7 = v12;
            unint64_t v8 = v12;
          }
        }
        while (v8 != v10);
        uint64_t v3 = *(void ***)(v1 + 288);
        int v4 = *(void ***)(v1 + 296);
      }
    }
    void *v9 = 0;
    unint64_t v13 = (char *)v4 - (char *)v3;
    if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
    {
      do
      {
        operator delete(*v3);
        int v4 = *(void ***)(v1 + 296);
        uint64_t v3 = (void **)(*(void *)(v1 + 288) + 8);
        *(void *)(v1 + 288) = v3;
        unint64_t v13 = (char *)v4 - (char *)v3;
      }
      while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
    }
    unint64_t v14 = v13 >> 3;
    if (v14 == 1)
    {
      uint64_t v15 = 85;
    }
    else
    {
      if (v14 != 2)
      {
LABEL_21:
        if (v3 != v4)
        {
          do
          {
            int v16 = *v3++;
            operator delete(v16);
          }
          while (v3 != v4);
          uint64_t v18 = *(void *)(v1 + 288);
          uint64_t v17 = *(void *)(v1 + 296);
          if (v17 != v18) {
            *(void *)(v1 + 296) = v17 + ((v18 - v17 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
        }
        uint64_t v19 = *(void **)(v1 + 280);
        if (v19) {
          operator delete(v19);
        }
        sub_1000346F8(v1 + 248, *(void **)(v1 + 256));
        sub_100088048(v1 + 224, *(void **)(v1 + 232));
        uint64_t v20 = *(std::__shared_weak_count **)(v1 + 208);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_10005D0E4(v1 + 160, *(void **)(v1 + 168));
        unint64_t v21 = *(std::__shared_weak_count **)(v1 + 144);
        if (v21) {
          sub_10004D2C8(v21);
        }
        unint64_t v22 = *(std::__shared_weak_count **)(v1 + 128);
        if (v22) {
          sub_10004D2C8(v22);
        }
        unint64_t v23 = *(std::__shared_weak_count **)(v1 + 112);
        if (v23) {
          sub_10004D2C8(v23);
        }
        uint64_t v24 = *(std::__shared_weak_count **)(v1 + 96);
        if (v24) {
          sub_10004D2C8(v24);
        }
        uint64_t v25 = *(std::__shared_weak_count **)(v1 + 80);
        if (v25) {
          sub_10004D2C8(v25);
        }
        sub_100160A84((atomic_uint **)(v1 + 48));
        uint64_t v26 = *(void *)(v1 + 40);
        *(void *)(v1 + 4sub_100732068((uint64_t)&a9, 0) = 0;
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
        }
        ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 32));
        sub_100087E88((void *)v1);
        operator delete();
      }
      uint64_t v15 = 170;
    }
    *(void *)(v1 + 312) = v15;
    goto LABEL_21;
  }
  return result;
}

void sub_100D7CB70(ServiceManager::Service *this)
{
  *(void *)this = off_101A56C30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100D7CBCC(ServiceManager::Service *this)
{
  *(void *)this = off_101A56C30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100D7CC3C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "LASDController");
}

unsigned char *sub_100D7CC4C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100D7CC8C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100D7952C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100D7952C(v4, 0);
}

uint64_t sub_100D7CD10()
{
  return 0;
}

uint64_t sub_100D7CD18()
{
  return 1;
}

uint64_t sub_100D7CD20()
{
  return 0;
}

void sub_100D7CD2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D7CE0C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D7CF24()
{
}

uint64_t sub_100D7CF38(uint64_t a1)
{
  return *(void *)(a1 + 8) + 32;
}

void sub_100D7CF44(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  unint64_t v5 = a1;
  BOOL v6 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100D7D0A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100D7D0D0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(v1 + 120) + 16))(*(void *)(v1 + 120));
  if (capabilities::ct::supportsWidgetMode(v2)) {
    (*(void (**)(void))(**(void **)(v1 + 120) + 48))(*(void *)(v1 + 120));
  }
  uint64_t v3 = *(void *)(v1 + 104);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  operator delete();
}

void sub_100D7D1A4()
{
}

void sub_100D7D1D0(uint64_t ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = **a1;
  uint64_t v2 = (*a1)[1];
  uint64_t v4 = v3[11];
  dispatch_group_t group = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  uint64_t v6 = *v3;
  unint64_t v5 = (std::__shared_weak_count *)v3[1];
  long long v36 = 0u;
  long long v37 = 0u;
  if (v5)
  {
    unint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      unint64_t v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      *(void *)&long long v36 = off_101A571C0;
      *((void *)&v36 + 1) = v6;
      *(void *)&long long v37 = v8;
      *((void *)&v37 + 1) = &v36;
      (*(void (**)(uint64_t, dispatch_group_t *, long long *))(*(void *)v4 + 16))(v4, &group, &v36);
      sub_100D77C9C(&v36);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      uint64_t v9 = v3[13];
      if (v9)
      {
        unint64_t v10 = v1[1];
        dispatch_group_t object = v10;
        if (v10)
        {
          dispatch_retain(v10);
          dispatch_group_enter(v10);
        }
        xpc_object_t v11 = (std::__shared_weak_count *)v3[12];
        uint64_t v24 = v3[11];
        uint64_t v25 = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, dispatch_group_t *, uint64_t *))(*(void *)v9 + 24))(v9, &object, &v24);
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (object)
        {
          dispatch_group_leave(object);
          if (object) {
            dispatch_release(object);
          }
        }
      }
      Registry::createRestModuleOneTimeUseConnection(&v22, (Registry *)v3[9]);
      ctu::RestModule::connect();
      if (v23) {
        sub_10004D2C8(v23);
      }
      sub_100058DB0(__p, "/cc/props/wifi_status");
      unint64_t v12 = operator new(0x28uLL);
      *unint64_t v12 = off_101A56CF0;
      v12[1] = v3 + 27;
      v12[2] = v3;
      void v12[3] = sub_100D7B340;
      void v12[4] = 0;
      *((void *)&v37 + 1) = v12;
      ctu::RestModule::observeProperty();
      sub_10003F600(&v36);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      sub_100058DB0(__p, "/cc/props/sims_in_use");
      unint64_t v13 = operator new(0x28uLL);
      void *v13 = off_101A56D70;
      v13[1] = v3 + 28;
      v13[2] = v3;
      uint64_t v13[3] = sub_100D7962C;
      void v13[4] = 0;
      *((void *)&v37 + 1) = v13;
      ctu::RestModule::observeProperty();
      sub_10003F600(&v36);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      sub_10035B500((uint64_t)(v3 + 31));
      sub_100058DB0(__p, "/cc/events/dump_state");
      unint64_t v14 = operator new(0x20uLL);
      *unint64_t v14 = off_101A56DF0;
      v14[1] = v3;
      void v14[2] = sub_100D7C150;
      void v14[3] = 0;
      *((void *)&v37 + 1) = v14;
      ctu::RestModule::observeEvent();
      sub_10003F600(&v36);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      sub_100058DB0(__p, "/cc/props/radio_mode");
      uint64_t v15 = operator new(0x28uLL);
      *uint64_t v15 = off_101A56E70;
      v15[1] = v3 + 42;
      void v15[2] = v3;
      v15[3] = sub_100D7C4A4;
      void v15[4] = 0;
      *((void *)&v37 + 1) = v15;
      ctu::RestModule::observeProperty();
      sub_10003F600(&v36);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      sub_100058DB0(__p, "/cc/props/radio_state");
      int v16 = operator new(0x28uLL);
      *int v16 = off_101A56EF0;
      v16[1] = (char *)v3 + 337;
      void v16[2] = v3;
      void v16[3] = sub_100D7C644;
      v16[4] = 0;
      *((void *)&v37 + 1) = v16;
      ctu::RestModule::observeProperty();
      uint64_t v17 = (capabilities::ct *)sub_10003F600(&v36);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      if ((capabilities::ct::supportsVoiceCall(v17) & 1) == 0)
      {
        sub_100058DB0(__p, "/cc/props/cellular_data_setting");
        uint64_t v18 = operator new(0x28uLL);
        *uint64_t v18 = off_101A56F70;
        v18[1] = (char *)v3 + 338;
        v18[2] = v3;
        uint64_t v18[3] = sub_100D7971C;
        void v18[4] = 0;
        *((void *)&v37 + 1) = v18;
        ctu::RestModule::observeProperty();
        sub_10003F600(&v36);
        if (SHIBYTE(v29) < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v33 = 0;
      aBlock = 0;
      __p[0] = _NSConcreteStackBlock;
      __p[1] = (void *)0x40000000;
      uint64_t v29 = sub_100D7EA74;
      uint64_t v30 = &unk_101A56FE0;
      uint64_t v31 = v3;
      uint64_t v32 = sub_100D7985C;
      aBlock = _Block_copy(__p);
      uint64_t v19 = (std::__shared_weak_count *)v3[1];
      if (v19)
      {
        uint64_t v20 = std::__shared_weak_count::lock(v19);
        if (v20)
        {
          unint64_t v21 = v20;
          sub_100352B38(v35, &aBlock, (dispatch_object_t)v3[2]);
          sub_100352B80(&v36, v35);
          atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100D7DD44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,dispatch_group_t group,dispatch_group_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38)
{
  if (a2)
  {
    sub_100163BC8(v39 - 112);
    if (a36) {
      (*(void (**)(uint64_t))(*(void *)a36 + 8))(a36);
    }
    std::__shared_weak_count::__release_weak(v38);
    sub_100161C9C((uint64_t)&a37);
    sub_10016578C((uint64_t)&a34);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7E044()
{
}

__n128 sub_100D7E058(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A56CF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D7E0AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56CF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7E0E4(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (char *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (unsigned __int8 *)a2, v6);
    *uint64_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  xpc_object_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100D7E1B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7E1F4()
{
}

void sub_100D7E204()
{
}

__n128 sub_100D7E218(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A56D70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D7E26C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56D70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100D7E2A4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v18 = (void **)v3->__r_.__value_.__r.__words[0];
  uint64_t v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  unint64_t v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    unint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      unint64_t v8 = (void **)v6[1];
      uint64_t v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          unint64_t v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          uint64_t v9 = (void ***)v6;
        }
        while (!v10);
      }
      xpc_object_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          xpc_object_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          unint64_t v7 = v12;
        }
        while (!v10);
      }
      unint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  char v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  uint64_t v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    char v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  uint64_t v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100D7E448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7E490(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7E4D0()
{
}

void sub_100D7E4E0()
{
}

__n128 sub_100D7E4F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A56DF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D7E548(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56DF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7E580(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100D7E5A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7E5E8()
{
}

void sub_100D7E5F8()
{
}

__n128 sub_100D7E60C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A56E70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D7E660(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56E70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7E698(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[1];
  uint64_t result = read_rest_value();
  int v4 = *v2;
  int v5 = ((unint64_t)&_mh_execute_header & 0x101FFFFFFFFLL) == 2;
  *uint64_t v2 = v5;
  if (v4 != v5)
  {
    uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
    uint64_t v7 = a1[4];
    unint64_t v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
    }
    return v6(v8, v4 != 0);
  }
  return result;
}

uint64_t sub_100D7E728(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7E768()
{
}

void sub_100D7E778()
{
}

__n128 sub_100D7E78C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A56EF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D7E7E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56EF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7E818(void *a1, xpc *this, uint64_t a3)
{
  int v4 = (unsigned char *)a1[1];
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  int v6 = *v4;
  unint64_t v7 = 0x10101000000uLL >> (8 * result);
  if (result >= 7) {
    LOBYTE(v7) = 1;
  }
  *int v4 = v7;
  if (v6 != (v7 & 1))
  {
    unint64_t v8 = (uint64_t (*)(void *, BOOL))a1[3];
    uint64_t v9 = a1[4];
    BOOL v10 = (void *)(a1[2] + (v9 >> 1));
    if (v9) {
      unint64_t v8 = *(uint64_t (**)(void *, BOOL))(*v10 + v8);
    }
    return v8(v10, v6 != 0);
  }
  return result;
}

uint64_t sub_100D7E8BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7E8FC()
{
}

void sub_100D7E90C()
{
}

__n128 sub_100D7E920(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A56F70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100D7E974(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A56F70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100D7E9AC(void *a1, xpc *this, BOOL a3)
{
  int v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *int v4 = xpc::dyn_cast_or_default(this, 0, a3);
  int v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  unint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100D7EA28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7EA68()
{
}

uint64_t sub_100D7EA74(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100D7EA9C(void *a1)
{
  *a1 = off_101A57010;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D7EAE8(void *a1)
{
  *a1 = off_101A57010;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100D7EB54(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100D7EC04(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D7EC1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100D7EC3C()
{
}

void *sub_100D7ECA8(void *a1)
{
  *a1 = off_101A57060;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100D7ECF4(void *a1)
{
  *a1 = off_101A57060;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100D7ED60()
{
}

uint64_t sub_100D7EDCC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

dispatch_object_t *sub_100D7EDF4(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  int v4 = *a2;
  if (*a2)
  {
    int v4 = _Block_copy(v4);
    dispatch_group_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_100D7EE3C(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_100D7EE94((uint64_t)a1, a2);
  return a1;
}

void sub_100D7EE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_100A83014((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7EE94(uint64_t a1, NSObject **a2)
{
  sub_100D7EF70(v4, a2);
  sub_100D7EEEC((uint64_t *)(a1 + 24), v4);
  return sub_100D7F80C((uint64_t)v4);
}

void sub_100D7EED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100D7EEEC(uint64_t *a1, NSObject **a2)
{
  sub_100D7EF70(v4, a2);
  sub_100D7EFBC(v5, v4);
  sub_100A82AD0(v5, a1);
  sub_100A83014(v5);
  sub_100D7F80C((uint64_t)v4);
  return a1;
}

void sub_100D7EF4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_100D7EF70(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  int v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    int v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

void *sub_100D7EFBC(void *a1, NSObject **a2)
{
  sub_100D7EF70(v4, a2);
  sub_100D7F01C(a1, v4);
  sub_100D7F80C((uint64_t)v4);
  return a1;
}

void sub_100D7F008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100D7F01C(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_100D7EF70(v4, a2);
  sub_100D7F07C((uint64_t)a1, v4);
  sub_100D7F80C((uint64_t)v4);
  return a1;
}

void sub_100D7F068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100D7F07C(uint64_t a1, NSObject **a2)
{
  sub_100D7EF70(v6, a2);
  int v3 = sub_100D7F1D4((uint64_t)off_101A570B0, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_100D7F80C((uint64_t)v6);
  if (v3) {
    int v5 = off_101A570B0;
  }
  else {
    int v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_100D7F0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100D7F0F8(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100D7EF70((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100D7F80C(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvPKcEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvPKcEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_100D7F1D4(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100D7EF70(v7, a2);
  uint64_t v5 = sub_100D7F7C4(a1, v7, a3);
  sub_100D7F80C((uint64_t)v7);
  return v5;
}

void sub_100D7F228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100D7F23C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlock = v1;
  sub_100D7F44C(&v3, &aBlock);
  operator new();
}

void sub_100D7F374(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, char a11)
{
}

uint64_t sub_100D7F3C8(uint64_t a1)
{
  sub_1006EBD74(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100A83014(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void *sub_100D7F44C(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_100D7F4C8(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_100D7F4AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100D7F4C8(void *a1, void **a2)
{
  *a1 = 0;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_100D7F544((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_100D7F528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7F544(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  int v4 = sub_100D7F60C((uint64_t)off_101A570F0, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_101A570F0;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_100D7F5C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7F5DC(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_100D7F690(a1, a2, a3);
  }
}

uint64_t sub_100D7F5FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100D7F60C(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlock = v5;
  uint64_t v6 = sub_100D7F764(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_100D7F674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D7F690(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      unint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvPKcEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvPKcEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_100D7F764(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (int v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_100D7F7C4(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_100D7EF70(v5, a2);
  sub_100D7EF70(a3, v5);
  sub_100D7F80C((uint64_t)v5);
  return 1;
}

uint64_t sub_100D7F80C(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_100D7F848(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_100D7F874()
{
}

__n128 sub_100D7F888(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A57140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100D7F8DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A57140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

const void **sub_100D7F914(void *a1, void **a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  uint64_t v16 = 0;
  v17[0] = 0;
  v17[1] = 0;
  sub_10014E33C((uint64_t)&v16, a2);
  uint64_t v6 = (void (*)(void *, uint64_t *, int *))a1[2];
  uint64_t v7 = a1[3];
  unint64_t v8 = (void *)(a1[1] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, uint64_t *, int *))(*v8 + v6);
  }
  int v10 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  int v13 = 0;
  uint64_t v14 = v5;
  uint64_t v15 = v4;
  v6(v8, &v16, &v10);
  sub_100D7FA3C((uint64_t)&v10);
  return sub_100057D78(v17);
}

void sub_100D7F9B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100D7FA3C((uint64_t)va);
  sub_100057D78(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7F9F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100D7FA30()
{
}

uint64_t sub_100D7FA3C(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    sub_10014E088((int *)a1, &v6);
    uint64_t v2 = *(void ***)(a1 + 48);
    uint64_t v3 = *v2;
    *uint64_t v2 = v6;
    xpc_object_t v6 = v3;
    xpc_release(v3);
    xpc_object_t v6 = 0;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v7 = (void **)(a1 + 16);
  sub_100047F64(&v7);
  sub_1000577C4((const void **)(a1 + 8));
  return a1;
}

void sub_100D7FAC4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  uint64_t v3 = (capabilities::ct *)(*(uint64_t (**)(void, const char *))(**(void **)(v1 + 120) + 24))(*(void *)(v1 + 120), "Service start");
  if (capabilities::ct::supportsWidgetMode(v3)) {
    (*(void (**)(void, const char *))(**(void **)(v1 + 120) + 56))(*(void *)(v1 + 120), "Service start");
  }
  uint64_t v4 = *(void *)(v1 + 104);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  sub_100D7B340(v1);
  operator delete();
}

void sub_100D7FBF4()
{
}

void *sub_100D7FC20(void *a1)
{
  *a1 = off_101A571C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D7FC6C(void *a1)
{
  *a1 = off_101A571C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100D7FCD8(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A571C0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D7FD34(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A571C0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D7FD6C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D7FD7C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100D7FDBC(uint64_t a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = a2[1];
  uint64_t v9 = (char **)*a2;
  int v10 = (char *)v4;
  if (a2[2])
  {
    *(void *)(v4 + 16) = &v10;
    *a2 = v3;
    void *v3 = 0;
    a2[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    xpc_object_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v12 = *(void *)(a1 + 8);
        int v13 = v6;
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100A0BD40(&v14, (uint64_t)&v9);
        unint64_t v8 = *(std::__shared_weak_count **)(v7 + 8);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
  sub_100A0AF80((uint64_t)&v9, v10);
}

void sub_100D7FF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v13);
  sub_100A0AF80((uint64_t)&a9, a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100D7FFC4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D80004()
{
}

uint64_t *sub_100D80010(uint64_t **a1)
{
  uint64_t v1 = *a1;
  int v28 = a1;
  uint64_t v29 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1 + 2;
  uint64_t v4 = (uint64_t *)v1[2];
  *(unsigned char *)(*v1 + 152) = 1;
  if (v4 == v1 + 3) {
    goto LABEL_57;
  }
  char v5 = 0;
  do
  {
    int v6 = *((_DWORD *)v4 + 10);
    switch(v6)
    {
      case 2:
        long long v11 = *(NSObject **)(v2 + 32);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          sub_100464AE4(v4 + 6, "", __p);
          if (v31 >= 0) {
            uint64_t v12 = __p;
          }
          else {
            uint64_t v12 = (void **)__p[0];
          }
          int v13 = *((_DWORD *)v4 + 8);
          uint64_t v14 = "gsm";
          switch(v13)
          {
            case 1:
              uint64_t v14 = "umts";
              break;
            case 2:
              uint64_t v14 = "cdma";
              break;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_32;
            case 4:
              uint64_t v14 = "lte";
              break;
            case 8:
              break;
            default:
              if (v13 == 16)
              {
                uint64_t v14 = "scdma";
              }
              else if (v13 == 32)
              {
                uint64_t v14 = "nr";
              }
              else
              {
LABEL_32:
                uint64_t v14 = "unknown";
              }
              break;
          }
          uint64_t v18 = asString();
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v33 = 2080;
          int v34 = v14;
          __int16 v35 = 2080;
          uint64_t v36 = v18;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Update to version %{public}s failed for %s db over interface %s", buf, 0x20u);
          if (v31 < 0) {
            operator delete(__p[0]);
          }
        }
        char v5 = 1;
        break;
      case 1:
        uint64_t v15 = *(NSObject **)(v2 + 32);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = "gsm";
          switch(*((_DWORD *)v4 + 8))
          {
            case 1:
              uint64_t v16 = "umts";
              break;
            case 2:
              uint64_t v16 = "cdma";
              break;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_30;
            case 4:
              uint64_t v16 = "lte";
              break;
            case 8:
              break;
            default:
              if ("gsm" == 16)
              {
                uint64_t v16 = "scdma";
              }
              else if ("gsm" == 32)
              {
                uint64_t v16 = "nr";
              }
              else
              {
LABEL_30:
                uint64_t v16 = "unknown";
              }
              break;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Update not required for %s db ", buf, 0xCu);
        }
        break;
      case 0:
        uint64_t v7 = *(NSObject **)(v2 + 32);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          sub_100464AE4(v4 + 6, "", __p);
          if (v31 >= 0) {
            unint64_t v8 = __p;
          }
          else {
            unint64_t v8 = (void **)__p[0];
          }
          int v9 = *((_DWORD *)v4 + 8);
          int v10 = "gsm";
          switch(v9)
          {
            case 1:
              int v10 = "umts";
              break;
            case 2:
              int v10 = "cdma";
              break;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_31;
            case 4:
              int v10 = "lte";
              break;
            case 8:
              break;
            default:
              if (v9 == 16)
              {
                int v10 = "scdma";
              }
              else if (v9 == 32)
              {
                int v10 = "nr";
              }
              else
              {
LABEL_31:
                int v10 = "unknown";
              }
              break;
          }
          uint64_t v17 = asString();
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = v8;
          __int16 v33 = 2080;
          int v34 = v10;
          __int16 v35 = 2080;
          uint64_t v36 = v17;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Update to version %{public}s success for %s db over interface %s", buf, 0x20u);
          if (v31 < 0) {
            operator delete(__p[0]);
          }
        }
        (*(void (**)(void))(**(void **)(v2 + 136) + 40))(*(void *)(v2 + 136));
        (*(void (**)(void, void))(**(void **)(v2 + 88) + 48))(*(void *)(v2 + 88), *((unsigned int *)v4 + 8));
        (*(void (**)(void))(**(void **)(v2 + 136) + 32))(*(void *)(v2 + 136));
        break;
    }
    uint64_t v19 = (uint64_t *)v4[1];
    if (v19)
    {
      do
      {
        std::string::size_type v20 = v19;
        uint64_t v19 = (uint64_t *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        std::string::size_type v20 = (uint64_t *)v4[2];
        BOOL v21 = *v20 == (void)v4;
        uint64_t v4 = v20;
      }
      while (!v21);
    }
    uint64_t v4 = v20;
  }
  while (v20 != v1 + 3);
  uint64_t v3 = v1 + 2;
  if ((v5 & 1) == 0)
  {
LABEL_57:
    uint64_t v23 = 0;
    int v22 = 0;
  }
  else
  {
    int v22 = 2;
    uint64_t v23 = 1;
  }
  *(_DWORD *)(v2 + 184) = v22;
  *(unsigned char *)(v2 + 188) = 1;
  (*(void (**)(void, uint64_t))(**(void **)(v2 + 88) + 40))(*(void *)(v2 + 88), v23);
  uint64_t v24 = *(void *)(v2 + 88);
  uint64_t v25 = *(NSObject **)(v2 + 16);
  *(void *)long long buf = v25;
  if (v25) {
    dispatch_retain(v25);
  }
  (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v24 + 32))(v24, buf, v23);
  if (*(void *)buf) {
    dispatch_release(*(dispatch_object_t *)buf);
  }
  uint64_t v26 = *(void (****)(void, void *))(v2 + 104);
  if (v26) {
    (**v26)(v26, v3);
  }
  LASDController::submitAWDMetricsForUpdate_sync(*v1, v3);
  sub_100D80650((uint64_t *)&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_100D805A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  sub_100D80650(&a17);
  sub_100046B58(&a16);
  _Unwind_Resume(a1);
}

uint64_t *sub_100D80650(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100A0AF80(v1 + 16, *(char **)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100D806B0(uint64_t a1, uint64_t a2)
{
  int isSimReady = subscriber::isSimReady();
  char v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), a2);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (isSimReady)
  {
    if (v6)
    {
      int v7 = 136315138;
      uint64_t v8 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I SIM is ready: %s", (uint8_t *)&v7, 0xCu);
    }
    (*(void (**)(void, const char *))(**(void **)(a1 + 120) + 24))(*(void *)(a1 + 120), "SIM ready");
  }
  else if (v6)
  {
    int v7 = 136315138;
    uint64_t v8 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I SIM is not ready: %s", (uint8_t *)&v7, 0xCu);
  }
}

void sub_100D80814(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < 0xAA) {
    a2 = 1;
  }
  if (v3 > 0x153 || (a2 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 170;
  }
}

void sub_100D80870(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A57250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D80890(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A57250;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D808E4(uint64_t a1)
{
  return sub_100D7FA3C(a1 + 24);
}

void *sub_100D808F0(void *a1)
{
  *a1 = off_101A572A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100D8093C(void *a1)
{
  *a1 = off_101A572A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100D809A8(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A572A0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100D80A04(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A572A0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100D80A3C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100D80A4C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100D80A8C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        char v5 = *(std::__shared_weak_count **)(v4 + 8);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100D80BB4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100D80BF4()
{
}

uint64_t *sub_100D80C00(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = capabilities::ct::LASDLocationTimeout(a1);
  uint64_t v3 = *(void ***)v1;
  uint64_t v4 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v9 = v2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Timed out waiting for CoreLocation after %lld seconds", buf, 0xCu);
    uint64_t v3 = *(void ***)v1;
  }
  sub_100D7A3E4(v3, (uint64_t)"Timed out");
  sub_1000E3958(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100D80CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100D80CFC(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *a1);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v18[0] = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, v18);
  if (v12)
  {
    uint64_t v14 = v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_13;
  }
LABEL_10:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 80))(v14))
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v18, kCtLoggingSystemName, kCALL_TELEPHONY_PROVIDER_LOG_DOMAIN);
    uint64_t v16 = v18[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "NonUI build, not instantiating TelephonyProvider", (uint8_t *)v18, 2u);
    }
    goto LABEL_16;
  }
LABEL_13:
  if (objc_opt_class())
  {
    uint64_t v17 = operator new(0x20uLL);
    v17[1] = 0;
    v17[2] = 0;
    *uint64_t v17 = off_101A57470;
    v17[3] = [[TelephonyProvider alloc] initWithRegistry:a1];
    *a2 = v17 + 3;
    a2[1] = v17;
    if (v15) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_16:
  *a2 = 0;
  a2[1] = 0;
  if ((v15 & 1) == 0) {
LABEL_17:
  }
    sub_10004D2C8(v13);
LABEL_18:
}

void sub_100D80EF8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D80F34(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A57470;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D80F54(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A57470;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100D80FA8(uint64_t a1)
{
}

void sub_100D80FB4(uint64_t a1@<X0>, NSObject **a2@<X1>, std::__shared_weak_count **a3@<X8>)
{
  BOOL v6 = (std::__shared_weak_count *)operator new(0x78uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A57588;
  uint64_t v7 = v6 + 1;
  unint64_t v8 = *a2;
  *a2 = 0;
  dispatch_object_t object = v8;
  sub_100D810E4(&v6[1].__vftable, a1, &object);
  if (object) {
    dispatch_release(object);
  }
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&off_101A575D8;
  shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    goto LABEL_7;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_7:
    sub_10004D2C8(v6);
  }
  *a3 = v7;
  a3[1] = v6;
}

void sub_100D810C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void *sub_100D810E4(void *a1, uint64_t a2, dispatch_object_t *a3)
{
  dispatch_object_t object = *a3;
  *a3 = 0;
  sub_1011DD9C4(a1, a2, &object, (uint64_t)"SuppServicesPreferencesWidget", "set.supp.prefs");
  if (object) {
    dispatch_release(object);
  }
  *a1 = &off_101A574C0;
  return a1;
}

void sub_100D8115C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D8118C(SuppServicesPreferencesInterface *a1)
{
  sub_1011DDB58(a1);

  operator delete();
}

void sub_100D811C4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A57588;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100D811E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A57588;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100D81238(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100D81264(SuppServicesPreferencesInterface *a1)
{
  sub_1011DDB58(a1);

  operator delete();
}

void sub_100D812CC(os_log_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v8 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v9sub_100732068((uint64_t)&a9, 0) = a5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I iRat Changed: appType=%s, dataContextType = %s, reasonCode=%d", buf, 0x1Cu);
  }
  uint64_t v10 = *a2;
  uint64_t v9 = a2[1];
  xpc_object_t v75 = a2;
  if (*a2 != v9)
  {
    uint64_t v78 = a2[1];
    do
    {
      unsigned int v11 = *(const void **)v10;
      uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v11
      {
        uint64_t v14 = v13;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (a4)
        {
          memset(buf, 0, sizeof(buf));
          long long __p = 0;
          uint64_t v85 = 0;
          uint64_t v86 = 0;
          sub_100DA1880(&__p, *((const void **)v13 + 15), *((void *)v13 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v13 + 16) - *((void *)v13 + 15)) >> 3));
          char v15 = (uint8_t *)__p;
          uint64_t v16 = v85;
          if (__p == v85)
          {
            uint64_t v17 = 0;
          }
          else
          {
            uint64_t v17 = 0;
            do
            {
              if (v15[16])
              {
                ++v17;
                if ((*(unsigned int (**)(void, uint64_t, void))(**((void **)v15 + 1) + 400))(*((void *)v15 + 1), a3, a5))
                {
                  uint64_t v18 = *(_OWORD **)&buf[8];
                  if (*(void *)&buf[8] >= *(void *)&buf[16])
                  {
                    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                    unint64_t v22 = v21 + 1;
                    if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      sub_100DA1868();
                    }
                    if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v22) {
                      unint64_t v22 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                      unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
                    }
                    else {
                      unint64_t v23 = v22;
                    }
                    if (v23) {
                      uint64_t v24 = (char *)sub_10004812C((uint64_t)&buf[16], v23);
                    }
                    else {
                      uint64_t v24 = 0;
                    }
                    uint64_t v25 = &v24[24 * v21];
                    long long v26 = *(_OWORD *)v15;
                    *((void *)v25 + 2) = *((void *)v15 + 2);
                    *(_OWORD *)uint64_t v25 = v26;
                    int v28 = *(char **)buf;
                    BOOL v27 = *(char **)&buf[8];
                    uint64_t v29 = v25;
                    if (*(void *)&buf[8] != *(void *)buf)
                    {
                      do
                      {
                        long long v30 = *(_OWORD *)(v27 - 24);
                        *(v29 - 8) = *(v27 - 8);
                        *(_OWORD *)(v29 - 24) = v30;
                        v29 -= 24;
                        v27 -= 24;
                      }
                      while (v27 != v28);
                      BOOL v27 = *(char **)buf;
                    }
                    std::string::size_type v20 = v25 + 24;
                    *(void *)long long buf = v29;
                    *(void *)&uint8_t buf[8] = v25 + 24;
                    *(void *)&uint8_t buf[16] = &v24[24 * v23];
                    if (v27) {
                      operator delete(v27);
                    }
                  }
                  else
                  {
                    long long v19 = *(_OWORD *)v15;
                    *(void *)(*(void *)&buf[8] + 16) = *((void *)v15 + 2);
                    *uint64_t v18 = v19;
                    std::string::size_type v20 = (char *)v18 + 24;
                  }
                  *(void *)&uint8_t buf[8] = v20;
                }
              }
              v15 += 24;
            }
            while (v15 != v16);
          }
          if (*(void *)buf != *(void *)&buf[8])
          {
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3) == v17)
            {
              char v31 = v14[8];
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v87 = 136315138;
                *(void *)&void v87[4] = "checkContextActivationStatusOniRatChange";
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: No other active connection, deactivate context", v87, 0xCu);
              }
              (*(void (**)(void *, void, uint64_t, const char *, const char *))(*v14 + 680))(v14, 0, 27, "All connections deactivated due to iRAT change", "CommCenter");
            }
            else
            {
              char v32 = (*(uint64_t (**)(void *, void))(*v14 + 624))(v14, 0);
              if ((v32 & 1) == 0)
              {
                __int16 v33 = v14[8];
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v34 = v14[14];
                  if (v34) {
                    int v35 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 16))(v34);
                  }
                  else {
                    int v35 = -3;
                  }
                  *(_DWORD *)uint64_t v87 = 67109120;
                  *(_DWORD *)&void v87[4] = v35;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Suspend/Resume context %d due to iRAT change", v87, 8u);
                }
                uint64_t v36 = v14[14];
                (*(void (**)(uint8_t *__return_ptr, void *))(*v14 + 16))(v87, v14);
                (*(void (**)(uint64_t, void, uint8_t *, uint64_t, void))(*(void *)v36 + 272))(v36, 0, v87, 3, 0);
                if (*(void *)&v87[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&v87[8]);
                }
              }
              char v76 = v32;
              uint64_t v37 = *(void *)buf;
              for (uint64_t i = *(void *)&buf[8]; v37 != i; v37 += 24)
              {
                uint64_t v39 = *(void *)(v37 + 8);
                sub_10003E168(&v82, v14 + 4);
                if (v82) {
                  std::string::size_type v40 = v82 + 24;
                }
                else {
                  std::string::size_type v40 = 0;
                }
                v81.__r_.__value_.__r.__words[0] = v40;
                v81.__r_.__value_.__l.__size_ = (std::string::size_type)v83;
                uint64_t v82 = 0;
                int v83 = 0;
                int v41 = (*(uint64_t (**)(uint64_t, void, std::string *))(*(void *)v39 + 64))(v39, 0, &v81);
                if (v81.__r_.__value_.__l.__size_) {
                  sub_10004D2C8((std::__shared_weak_count *)v81.__r_.__value_.__l.__size_);
                }
                if (v83) {
                  sub_10004D2C8(v83);
                }
                if (v41) {
                  sub_100D862A8((uint64_t)v14, 0, *(const DataAPNSettingsObserver **)(v37 + 8), 0);
                }
              }
              if ((v76 & 1) == 0)
              {
                uint64_t v42 = v14[14];
                (*(void (**)(uint64_t *__return_ptr, void *))(*v14 + 16))(&v82, v14);
                (*(void (**)(uint64_t, void, uint64_t *, void))(*(void *)v42 + 280))(v42, 0, &v82, 0);
                if (v83) {
                  sub_10004D2C8(v83);
                }
              }
            }
          }
          if (__p)
          {
            uint64_t v85 = (uint8_t *)__p;
            operator delete(__p);
          }
          uint64_t v9 = v78;
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
        }
        for (uint64_t j = 0; j != 2; ++j)
        {
          uint64_t v44 = dword_1015716C8[j];
          if (v44 != a4) {
            sub_100D9903C(v14, v44, a3, a4);
          }
        }
        if (!v12) {
          goto LABEL_76;
        }
        sub_10004D2C8(v12);
      }
      else if (!v12)
      {
        goto LABEL_76;
      }
      sub_10004D2C8(v12);
LABEL_76:
      v10 += 16;
    }
    while (v10 != v9);
  }
  if (validContextType())
  {
    uint64_t v46 = *v75;
    uint64_t v45 = v75[1];
    if (*v75 != v45)
    {
      int v47 = a5;
      if (a5 < 0) {
        int v47 = -a5;
      }
      int v74 = v47;
      uint64_t v79 = v75[1];
      do
      {
        int v48 = *(const void **)v46;
        unint64_t v49 = *(std::__shared_weak_count **)(v46 + 8);
        if (v49) {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v48
        {
          uint64_t v51 = v50;
          if (v49) {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if ((*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)v50 + 1056))(v50))
          {
            char v52 = 0;
            uint64_t v53 = dword_1015716C8;
            do
            {
              uint64_t v54 = (void *)((char *)v51 + 24 * *v53);
              uint64_t v55 = v54[15];
              uint64_t v56 = v54[16];
              while (v55 != v56)
              {
                if (*(unsigned char *)(v55 + 16))
                {
                  (*(void (**)(void))(**(void **)(v55 + 8) + 200))(*(void *)(v55 + 8));
                  v52 |= DataiRatControllerInterface::getAppType() == a3;
                }
                v55 += 24;
              }
              ++v53;
            }
            while (v53 != dword_1015716D0);
            if (v52)
            {
              memset(v87, 0, sizeof(v87));
              std::string::size_type v88 = 0;
              memset(&v81, 0, sizeof(v81));
              memset(buf, 0, sizeof(buf));
              uint64_t v90 = &buf[2];
              char v91 = &buf[23];
              LODWORD(__p) = v74;
              uint64_t v85 = &buf[23];
              LOBYTE(v86) = 48;
              HIDWORD(v86) = 48;
              uint64_t v57 = sub_100DA1D8C((uint64_t)&__p);
              unint64_t v58 = (std::string::value_type *)v57;
              if (a5 < 0)
              {
                *(unsigned char *)(v57 - 1) = 45;
                unint64_t v58 = (std::string::value_type *)(v57 - 1);
              }
              uint64_t v90 = (uint8_t *)v58;
              char v91 = &buf[23];
              sub_10006E5EC(&v81, v58, (std::string::value_type *)&buf[23], &buf[23] - (uint8_t *)v58);
              BOOL v59 = std::string::insert(&v81, 0, "iRatReasonCode: ", 0x10uLL);
              long long v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
              std::string::size_type v88 = v59->__r_.__value_.__r.__words[2];
              *(_OWORD *)uint64_t v87 = v60;
              v59->__r_.__value_.__l.__size_ = 0;
              v59->__r_.__value_.__r.__words[2] = 0;
              v59->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v81.__r_.__value_.__l.__data_);
              }
              if (((*(uint64_t (**)(PersonalitySpecificImpl *, uint64_t, uint8_t *))(*(void *)v51 + 1216))(v51, a4, v87) & 1) == 0)sub_100D8F454(v51, a4); {
              if (SHIBYTE(v88) < 0)
              }
                operator delete(*(void **)v87);
            }
          }
          else
          {
            uint64_t v61 = dword_1015716C8;
            do
            {
              uint64_t v62 = *v61;
              if (v62 != a4)
              {
                if ((*(unsigned int (**)(PersonalitySpecificImpl *, void))(*(void *)v51 + 624))(v51, *v61))
                {
                  uint64_t v63 = *((void *)v51 + 14);
                  if (v63)
                  {
                    if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v63 + 96))(v63, 2) & 1) == 0)
                    {
                      uint64_t v64 = (void *)((char *)v51 + 24 * (int)v62);
                      uint64_t v66 = v64[15];
                      uint64_t v65 = v64[16];
                      if (v66 == v65) {
                        goto LABEL_122;
                      }
                      uint64_t v67 = 0;
                      while (1)
                      {
                        if (*(unsigned char *)(v66 + 16))
                        {
                          ++v67;
                          if (sub_100D89AB4((uint64_t)v51, *(void *)(v66 + 8), 0) == a4) {
                            break;
                          }
                        }
                        v66 += 24;
                        if (v66 == v65) {
                          goto LABEL_121;
                        }
                      }
                      uint64_t v68 = *a1;
                      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v69 = asString(*(const DataAPNSettingsObserver **)(v66 + 8));
                        uint64_t v73 = asString();
                        uint64_t v70 = asString();
                        *(_DWORD *)long long buf = 136315650;
                        *(void *)&uint8_t buf[4] = v69;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v73;
                        *(_WORD *)&unsigned char buf[22] = 2080;
                        uint64_t v90 = (uint8_t *)v70;
                        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I We hope that the suspended %s, currently on %s, will have a better chance with %s - so we are letting it go...", buf, 0x20u);
                      }
                      (*(void (**)(PersonalitySpecificImpl *, uint64_t, uint64_t, const char *, const char *))(*(void *)v51 + 680))(v51, v62, 27, "unknown", "CommCenter");
LABEL_121:
                      if (!v67)
                      {
LABEL_122:
                        int v71 = *a1;
                        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v72 = (*(uint64_t (**)(PersonalitySpecificImpl *))(*(void *)v51 + 40))(v51);
                          *(_DWORD *)long long buf = 136315138;
                          *(void *)&uint8_t buf[4] = v72;
                          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I Abandoned and suspended settings: %s", buf, 0xCu);
                        }
                        (*(void (**)(PersonalitySpecificImpl *, uint64_t, uint64_t, const char *, const char *))(*(void *)v51 + 680))(v51, v62, 27, "unknown", "CommCenter");
                      }
                    }
                  }
                }
              }
              ++v61;
            }
            while (v61 != dword_1015716D0);
          }
          uint64_t v45 = v79;
          if (!v49) {
            goto LABEL_129;
          }
          sub_10004D2C8(v49);
        }
        else if (!v49)
        {
          goto LABEL_129;
        }
        sub_10004D2C8(v49);
LABEL_129:
        v46 += 16;
      }
      while (v46 != v45);
    }
  }
}

void sub_100D81EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v42 = *(void **)(v40 - 144);
  if (v42)
  {
    *(void *)(v40 - 136) = v42;
    operator delete(v42);
  }
  if (v39)
  {
    sub_10004D2C8(v39);
    sub_10004D2C8(v39);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D81FD0(uint64_t a1, uint64_t *a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6, NSObject **a7, char *a8, int a9)
{
  char v15 = (void *)(PersonalitySpecificImpl::PersonalitySpecificImpl() + 24);
  uint64_t v16 = a2[5];
  *char v15 = v16;
  *(void *)((char *)v15 + *(void *)(v16 - 56)) = a2[6];
  uint64_t v17 = a2[4];
  *(void *)(a1 + 24) = v17;
  *(void *)((char *)v15 + *(void *)(v17 - 56)) = a2[7];
  uint64_t v18 = a2[3];
  *(void *)(a1 + 24) = v18;
  *(void *)((char *)v15 + *(void *)(v18 - 56)) = a2[8];
  uint64_t v19 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v19 - 56)) = a2[9];
  *(void *)(a1 + 24) = a2[10];
  int v20 = *(_DWORD *)(*(void *)a5 + 52);
  unsigned int v21 = a4;
  if ((a4 & 0x80000000) != 0)
  {
    if (a6) {
      unsigned int v21 = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 16))(a6);
    }
    else {
      unsigned int v21 = -1;
    }
  }
  sub_100058DB0(__p, a8);
  unint64_t v22 = sub_100D8282C((void *)a1, v20, v21, (uint64_t)__p);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v51, kCtLoggingSystemName, v22);
  sub_100D82C08((void *)(a1 + 32), a7, &v51);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v51);
  if (v50 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v23 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v23 - 56)) = a2[9];
  *(void *)(a1 + 24) = a2[10];
  *(void *)(a1 + 72) = *a3;
  uint64_t v24 = a3[1];
  *(void *)(a1 + 8sub_100732068((uint64_t)&a9, 0) = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  int v25 = *(_DWORD *)(*(void *)a5 + 52);
  unsigned int v26 = a4;
  if ((a4 & 0x80000000) != 0)
  {
    if (a6) {
      unsigned int v26 = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 16))(a6);
    }
    else {
      unsigned int v26 = -1;
    }
  }
  sub_100058DB0(v45, a8);
  BOOL v27 = (char *)sub_100D8282C((void *)a1, v25, v26, (uint64_t)v45);
  sub_100058DB0(&v47, v27);
  int v28 = *a7;
  dispatch_object_t v44 = v28;
  if (v28) {
    dispatch_retain(v28);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v44) {
    dispatch_release(v44);
  }
  if (v48 < 0) {
    operator delete(v47);
  }
  if (v46 < 0) {
    operator delete(v45[0]);
  }
  *(_DWORD *)(a1 + 104) = a4;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 16sub_100732068((uint64_t)&a9, 0) = 0;
  sub_100058DB0((void *)(a1 + 168), a8);
  *(_WORD *)(a1 + 24sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 244) = a9;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 342) = 0;
  uint64_t v29 = 360;
  *(_WORD *)(a1 + 256) = 0;
  do
  {
    long long v30 = (unsigned char *)(a1 + v29);
    *long long v30 = 0;
    unsigned __int8 v30[8] = 0;
    v29 += 16;
  }
  while (v30 + 16 != (unsigned char *)(a1 + 392));
  for (uint64_t i = 0; i != 48; i += 24)
  {
    char v32 = (void *)(a1 + i);
    v32[50] = 0;
    v32[51] = 0;
    v32[49] = v32 + 50;
  }
  __int16 v33 = (void *)(a1 + 568);
  *(void *)(a1 + 44sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 448) = 0;
  uint64_t v34 = 456;
  do
  {
    uint64_t v35 = a1 + v34;
    *(_DWORD *)uint64_t v35 = 0;
    *(void *)(v35 + 8) = &unk_10165244B;
    *(void *)(v35 + 16) = &unk_10165244B;
    *(_DWORD *)(v35 + 24) = 0;
    *(unsigned char *)(v35 + 28) = 0;
    *(_DWORD *)(v35 + 32) = 2;
    *(void *)(v35 + 44) = 0;
    *(void *)(v35 + 36) = 0;
    v34 += 56;
    *(_DWORD *)(v35 + 52) = 0;
  }
  while ((void *)(v35 + 56) != v33);
  void *v33 = 0;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 592) = 2;
  *(unsigned char *)(a1 + 596) = 0;
  *(unsigned char *)(a1 + 60sub_100732068((uint64_t)&a9, 0) = 0;
  *(unsigned char *)(a1 + 624) = 0;
  *(_WORD *)(a1 + 632) = 0;
  *(unsigned char *)(a1 + 634) = 0;
  *(_OWORD *)(a1 + 64sub_100732068((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  uint64_t v36 = 696;
  *(void *)(a1 + 688) = 0;
  do
  {
    uint64_t v37 = (unsigned char *)(a1 + v36);
    unsigned char *v37 = 0;
    uint8_t v37[8] = 0;
    v36 += 16;
  }
  while (v37 + 16 != (unsigned char *)(a1 + 728));
  *(_DWORD *)(a1 + 728) = 0;
  Registry::createRestModuleOneTimeUseConnection(&v41, *(Registry **)(a1 + 72));
  ctu::RestModule::connect();
  if (v42) {
    sub_10004D2C8(v42);
  }
  sub_100D82C94(a1, a6);
  sub_100D83060(a1);
  return a1;
}

void sub_100D8264C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object, dispatch_object_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_100DA17EC(v36);
  uint64_t v39 = *(std::__shared_weak_count **)(v33 + 584);
  if (v39) {
    sub_10004D2C8(v39);
  }
  uint64_t v40 = 0;
  while (1)
  {
    uint64_t v41 = *(std::__shared_weak_count **)(v33 + 560 + v40);
    if (v41) {
      sub_10004D2C8(v41);
    }
    v40 -= 56;
    if (v40 == -112)
    {
      uint64_t v42 = *v34;
      *uint64_t v34 = 0;
      if (v42) {
        (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
      }
      for (uint64_t i = 0; i != -48; i -= 24)
        sub_100103DF0(v33 + i + 416, *(void **)(v33 + i + 424));
      uint64_t v44 = 0;
      while (1)
      {
        uint64_t v45 = *(std::__shared_weak_count **)(v33 + 336 + v44);
        if (v45) {
          sub_10004D2C8(v45);
        }
        v44 -= 16;
        if (v44 == -32)
        {
          uint64_t v46 = 0;
          while (1)
          {
            int v47 = *(std::__shared_weak_count **)(v33 + 304 + v46);
            if (v47) {
              sub_10004D2C8(v47);
            }
            v46 -= 16;
            if (v46 == -32)
            {
              char v48 = *(std::__shared_weak_count **)(v33 + 272);
              if (v48) {
                sub_10004D2C8(v48);
              }
              if (*(char *)(v33 + 191) < 0) {
                operator delete(*v37);
              }
              uint64_t v49 = 0;
              while (1)
              {
                char v50 = *(void **)(v33 + v49 + 144);
                if (v50)
                {
                  *(void *)(v33 + v49 + 152) = v50;
                  operator delete(v50);
                }
                v49 -= 24;
                if (v49 == -48)
                {
                  OsLogContext v51 = *(std::__shared_weak_count **)(v33 + 96);
                  if (v51) {
                    sub_10004D2C8(v51);
                  }
                  char v52 = *(std::__shared_weak_count **)(v33 + 80);
                  if (v52) {
                    sub_10004D2C8(v52);
                  }
                  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v33 + 64));
                  sub_100087E88(v35);
                  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)v33);
                  _Unwind_Resume(a1);
                }
              }
            }
          }
        }
      }
    }
  }
}

const char *sub_100D8282C(void *a1, int a2, unsigned int a3, uint64_t a4)
{
  if (*(char *)(a4 + 23) < 0)
  {
    unint64_t v8 = *(void *)(a4 + 8);
    if (v8)
    {
      __s1[0] = 0;
      __s1[1] = 0;
      uint64_t v29 = 0;
      goto LABEL_10;
    }
    *(void *)(a4 + 8) = 7;
    uint64_t v7 = *(char **)a4;
  }
  else
  {
    if (*(unsigned char *)(a4 + 23))
    {
LABEL_8:
      *(_OWORD *)long long __s1 = *(_OWORD *)a4;
      uint64_t v29 = *(void *)(a4 + 16);
      goto LABEL_11;
    }
    *(unsigned char *)(a4 + 23) = 7;
    uint64_t v7 = (char *)a4;
  }
  strcpy(v7, "unknown");
  int v9 = *(char *)(a4 + 23);
  __s1[0] = 0;
  __s1[1] = 0;
  uint64_t v29 = 0;
  if ((v9 & 0x80000000) == 0) {
    goto LABEL_8;
  }
  unint64_t v8 = *(void *)(a4 + 8);
LABEL_10:
  sub_10004FC84(__s1, *(void **)a4, v8);
LABEL_11:
  char v10 = HIBYTE(v29);
  if (v29 >= 0) {
    unsigned int v11 = (char *)__s1 + HIBYTE(v29);
  }
  else {
    unsigned int v11 = &__s1[0][(unint64_t)__s1[1]];
  }
  if (v29 >= 0) {
    uint64_t v12 = __s1;
  }
  else {
    uint64_t v12 = (char **)__s1[0];
  }
  if (v12 != (char **)v11)
  {
    do
    {
      *(unsigned char *)uint64_t v12 = __toupper(*(char *)v12);
      uint64_t v12 = (char **)((char *)v12 + 1);
    }
    while (v12 != (char **)v11);
    char v10 = HIBYTE(v29);
  }
  if (a2 == 1)
  {
    if (v10 < 0)
    {
      int v13 = __s1[0];
      uint64_t v14 = __s1[0];
    }
    else
    {
      int v13 = (char *)__s1;
      uint64_t v14 = (char *)__s1;
    }
    if (strstr(v14, "TETHER"))
    {
      if (a3 < 0xB)
      {
        uint64_t v17 = off_101A58E98;
        uint64_t v18 = off_101A58E40;
        uint64_t v19 = off_101A58DE8;
        int v20 = off_101A58D90;
LABEL_68:
        unint64_t v22 = v20[a3];
        uint64_t v23 = v19[a3];
        uint64_t v24 = v18[a3];
        int v25 = v17[a3];
        goto LABEL_71;
      }
      int v25 = "Settings.1:N:tethering:wifi";
      uint64_t v24 = "Settings.1:N:tethering:bb";
      uint64_t v23 = "DATA.Settings.1:N:tethering";
      unint64_t v22 = "Settings.1:N:tethering";
    }
    else
    {
      unsigned int v21 = strstr(v13, "OTA");
      int v20 = off_101A58EF0;
      if (!v21) {
        int v20 = off_101A59050;
      }
      uint64_t v19 = off_101A590A8;
      if (v21) {
        uint64_t v19 = off_101A58F48;
      }
      uint64_t v18 = off_101A59100;
      if (v21) {
        uint64_t v18 = off_101A58FA0;
      }
      uint64_t v17 = off_101A58FF8;
      if (v21)
      {
        unint64_t v22 = "Settings.1:N:ota";
      }
      else
      {
        uint64_t v17 = off_101A59158;
        unint64_t v22 = "Settings.1:N";
      }
      if (v21) {
        uint64_t v23 = "DATA.Settings.1:N:ota";
      }
      else {
        uint64_t v23 = "DATA.Settings.1:N";
      }
      uint64_t v24 = "Settings.1:N:ota:bb";
      if (!v21) {
        uint64_t v24 = "Settings.1:N:bb";
      }
      int v25 = "Settings.1:N:ota:wifi";
      if (!v21) {
        int v25 = "Settings.1:N:wifi";
      }
      if (a3 < 0xB) {
        goto LABEL_68;
      }
    }
  }
  else
  {
    if (v10 < 0)
    {
      char v15 = __s1[0];
      uint64_t v16 = __s1[0];
    }
    else
    {
      char v15 = (char *)__s1;
      uint64_t v16 = (char *)__s1;
    }
    if (strstr(v16, "TETHER"))
    {
      if (a3 < 0xB)
      {
        uint64_t v17 = off_101A592B8;
        uint64_t v18 = off_101A59260;
        uint64_t v19 = off_101A59208;
        int v20 = off_101A591B0;
        goto LABEL_68;
      }
      int v25 = "Settings.2:N:tethering:wifi";
      uint64_t v24 = "Settings.2:N:tethering:bb";
      uint64_t v23 = "DATA.Settings.2:N:tethering";
      unint64_t v22 = "Settings.2:N:tethering";
    }
    else
    {
      unsigned int v26 = strstr(v15, "OTA");
      int v20 = off_101A59310;
      if (!v26) {
        int v20 = off_101A59470;
      }
      uint64_t v19 = off_101A594C8;
      if (v26) {
        uint64_t v19 = off_101A59368;
      }
      uint64_t v18 = off_101A59520;
      if (v26) {
        uint64_t v18 = off_101A593C0;
      }
      uint64_t v17 = off_101A59418;
      if (v26)
      {
        unint64_t v22 = "Settings.2:N:ota";
      }
      else
      {
        uint64_t v17 = off_101A59578;
        unint64_t v22 = "Settings.2:N";
      }
      if (v26) {
        uint64_t v23 = "DATA.Settings.2:N:ota";
      }
      else {
        uint64_t v23 = "DATA.Settings.2:N";
      }
      uint64_t v24 = "Settings.2:N:ota:bb";
      if (!v26) {
        uint64_t v24 = "Settings.2:N:bb";
      }
      int v25 = "Settings.2:N:ota:wifi";
      if (!v26) {
        int v25 = "Settings.2:N:wifi";
      }
      if (a3 <= 0xA) {
        goto LABEL_68;
      }
    }
  }
LABEL_71:
  a1[26] = v22;
  a1[27] = v24;
  a1[28] = v25;
  a1[24] = v22;
  a1[25] = v23;
  if (v10 < 0) {
    operator delete(__s1[0]);
  }
  return v23;
}

void sub_100D82BEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100D82C08(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  char v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100D82C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

BOOL sub_100D82C94(uint64_t a1, uint64_t a2)
{
  if (!a2
    || (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2)
    || !sub_100D83708((Registry **)a1, v4))
  {
    uint64_t v12 = *(NSObject **)(a1 + 64);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v13) {
      return result;
    }
    uint64_t v14 = *(void *)(a1 + 112);
    if (v14) {
      char v15 = "non-empty";
    }
    else {
      char v15 = "empty";
    }
    if (v14) {
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
    }
    else {
      int v16 = -3;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "assignActivator";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v15;
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v26 = v16;
    int v9 = "#I %s: preserve the existing %s activator %d";
    char v10 = v12;
    uint32_t v11 = 28;
    goto LABEL_16;
  }
  if (*(void *)(a1 + 112))
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
    uint64_t v7 = *(NSObject **)(a1 + 64);
    BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v5 != v6)
    {
      if (result)
      {
        int v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
        int v19 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = "assignActivator";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v18;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v19;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: non-empty activator %d to other non-empty %d", buf, 0x18u);
      }
      uint64_t v20 = *(void *)(a1 + 112);
      sub_10003E168(buf, (void *)(a1 + 32));
      if (*(void *)buf) {
        uint64_t v21 = *(void *)buf + 24;
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v23 = v21;
      uint64_t v24 = *(std::__shared_weak_count **)&buf[8];
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      int v22 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v20 + 104))(v20, &v23);
      if (v24) {
        sub_10004D2C8(v24);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v22)
      {
        *(void *)(a1 + 112) = a2;
        return 1;
      }
      return 0;
    }
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "assignActivator";
    int v9 = "#I %s: same non-empty activator";
    char v10 = v7;
    uint32_t v11 = 12;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
    return 0;
  }
  uint64_t v17 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "assignActivator";
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: empty activator to non-empty", buf, 0xCu);
  }
  BOOL result = 0;
  *(void *)(a1 + 112) = a2;
  return result;
}

void sub_100D83034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D83060(uint64_t a1)
{
  int v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  unsigned int v3 = *(_DWORD *)(a1 + 104);
  if (*(char *)(a1 + 191) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 168), *(void *)(a1 + 176));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 168);
    uint64_t v5 = *(void *)(a1 + 184);
  }
  sub_100D8282C((void *)a1, v2, v3, (uint64_t)__p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100D830EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D83108(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, NSObject **a6, char *a7, int a8)
{
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  *(void *)a1 = off_101A576C8;
  *(void *)(a1 + 24) = off_101A57BC8;
  int v14 = *(_DWORD *)(*(void *)a4 + 52);
  unsigned int v15 = a3;
  if ((a3 & 0x80000000) != 0)
  {
    if (a5) {
      unsigned int v15 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 16))(a5);
    }
    else {
      unsigned int v15 = -1;
    }
  }
  sub_100058DB0(__p, a7);
  int v16 = sub_100D8282C((void *)a1, v14, v15, (uint64_t)__p);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v44, kCtLoggingSystemName, v16);
  sub_100D82C08((void *)(a1 + 32), a6, &v44);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v44);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101A576C8;
  *(void *)(a1 + 24) = off_101A57BC8;
  *(void *)(a1 + 72) = *a2;
  uint64_t v17 = a2[1];
  *(void *)(a1 + 8sub_100732068((uint64_t)&a9, 0) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  int v18 = *(_DWORD *)(*(void *)a4 + 52);
  unsigned int v19 = a3;
  if ((a3 & 0x80000000) != 0)
  {
    if (a5) {
      unsigned int v19 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 16))(a5);
    }
    else {
      unsigned int v19 = -1;
    }
  }
  sub_100058DB0(v38, a7);
  uint64_t v20 = (char *)sub_100D8282C((void *)a1, v18, v19, (uint64_t)v38);
  sub_100058DB0(&v40, v20);
  uint64_t v21 = *a6;
  dispatch_object_t v37 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v37) {
    dispatch_release(v37);
  }
  if (v41 < 0) {
    operator delete(v40);
  }
  if (v39 < 0) {
    operator delete(v38[0]);
  }
  *(_DWORD *)(a1 + 104) = a3;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 16sub_100732068((uint64_t)&a9, 0) = 0;
  sub_100058DB0((void *)(a1 + 168), a7);
  *(_WORD *)(a1 + 24sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 244) = a8;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 28sub_100732068((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 342) = 0;
  uint64_t v22 = 360;
  *(_WORD *)(a1 + 256) = 0;
  do
  {
    uint64_t v23 = (unsigned char *)(a1 + v22);
    unsigned char *v23 = 0;
    unsigned char v23[8] = 0;
    v22 += 16;
  }
  while (v23 + 16 != (unsigned char *)(a1 + 392));
  for (uint64_t i = 0; i != 48; i += 24)
  {
    int v25 = (void *)(a1 + i);
    v25[50] = 0;
    v25[51] = 0;
    v25[49] = v25 + 50;
  }
  int v26 = (void *)(a1 + 568);
  *(void *)(a1 + 44sub_100732068((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 448) = 0;
  uint64_t v27 = 456;
  do
  {
    uint64_t v28 = a1 + v27;
    *(_DWORD *)uint64_t v28 = 0;
    *(void *)(v28 + 8) = &unk_10165244B;
    *(void *)(v28 + 16) = &unk_10165244B;
    *(_DWORD *)(v28 + 24) = 0;
    *(unsigned char *)(v28 + 28) = 0;
    *(_DWORD *)(v28 + 32) = 2;
    *(void *)(v28 + 44) = 0;
    *(void *)(v28 + 36) = 0;
    v27 += 56;
    *(_DWORD *)(v28 + 52) = 0;
  }
  while ((void *)(v28 + 56) != v26);
  *int v26 = 0;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 592) = 2;
  *(unsigned char *)(a1 + 596) = 0;
  *(unsigned char *)(a1 + 60sub_100732068((uint64_t)&a9, 0) = 0;
  *(unsigned char *)(a1 + 624) = 0;
  *(_WORD *)(a1 + 632) = 0;
  *(unsigned char *)(a1 + 634) = 0;
  *(_OWORD *)(a1 + 64sub_100732068((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  uint64_t v29 = 696;
  *(void *)(a1 + 688) = 0;
  do
  {
    long long v30 = (unsigned char *)(a1 + v29);
    *long long v30 = 0;
    unsigned __int8 v30[8] = 0;
    v29 += 16;
  }
  while (v30 + 16 != (unsigned char *)(a1 + 728));
  *(_DWORD *)(a1 + 728) = 0;
  Registry::createRestModuleOneTimeUseConnection(&v34, *(Registry **)(a1 + 72));
  ctu::RestModule::connect();
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_100D82C94(a1, a5);
  sub_100D83060(a1);
  return a1;
}

void sub_100D83514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object, dispatch_object_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_100DA17EC(v34);
  long long v38 = *(std::__shared_weak_count **)(v33 + 584);
  if (v38) {
    sub_10004D2C8(v38);
  }
  uint64_t v39 = 0;
  while (1)
  {
    uint64_t v40 = *(std::__shared_weak_count **)(v33 + 560 + v39);
    if (v40) {
      sub_10004D2C8(v40);
    }
    v39 -= 56;
    if (v39 == -112)
    {
      uint64_t v41 = *v36;
      *uint64_t v36 = 0;
      if (v41) {
        (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
      }
      for (uint64_t i = 0; i != -48; i -= 24)
        sub_100103DF0(v33 + i + 416, *(void **)(v33 + i + 424));
      uint64_t v43 = 0;
      while (1)
      {
        OsLogContext v44 = *(std::__shared_weak_count **)(v33 + 336 + v43);
        if (v44) {
          sub_10004D2C8(v44);
        }
        v43 -= 16;
        if (v43 == -32)
        {
          uint64_t v45 = 0;
          while (1)
          {
            uint64_t v46 = *(std::__shared_weak_count **)(v33 + 304 + v45);
            if (v46) {
              sub_10004D2C8(v46);
            }
            v45 -= 16;
            if (v45 == -32)
            {
              int v47 = *(std::__shared_weak_count **)(v33 + 272);
              if (v47) {
                sub_10004D2C8(v47);
              }
              if (*(char *)(v33 + 191) < 0) {
                operator delete(*v35);
              }
              uint64_t v48 = 0;
              while (1)
              {
                uint64_t v49 = *(void **)(v33 + v48 + 144);
                if (v49)
                {
                  *(void *)(v33 + v48 + 152) = v49;
                  operator delete(v49);
                }
                v48 -= 24;
                if (v48 == -48)
                {
                  char v50 = *(std::__shared_weak_count **)(v33 + 96);
                  if (v50) {
                    sub_10004D2C8(v50);
                  }
                  OsLogContext v51 = *(std::__shared_weak_count **)(v33 + 80);
                  if (v51) {
                    sub_10004D2C8(v51);
                  }
                  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v33 + 64));
                  sub_100087E88(a9);
                  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)v33);
                  PersonalitySpecific::~PersonalitySpecific((PersonalitySpecific *)v33);
                  _Unwind_Resume(a1);
                }
              }
            }
          }
        }
      }
    }
  }
}

BOOL sub_100D83708@<W0>(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1[9]);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  char v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    BOOL v13 = 1;
    if (v12) {
      return v13;
    }
    goto LABEL_12;
  }
LABEL_11:
  int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 760))(v11);
  BOOL v13 = v14 == PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
  return v13;
}

void sub_100D83840(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D83858@<W0>(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1[9]);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  char v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    BOOL v13 = 1;
    if (v12) {
      return v13;
    }
    goto LABEL_12;
  }
LABEL_11:
  int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 776))(v11);
  BOOL v13 = v14 == PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
  return v13;
}

void sub_100D83990(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D839A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 112);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 16))();
  }
  else {
    return 4294967293;
  }
}

uint64_t sub_100D839DC(Registry **a1)
{
  unsigned __int8 v3 = 0;
  LODWORD(v4) = 0;
  if (((*((uint64_t (**)(Registry **, void, uint64_t, uint64_t))*a1 + 17))(a1, 0, 1, 1) & 1) == 0) {
    return v3 | (v4 << 8);
  }
  if (!sub_100D83858(a1, v2))
  {
LABEL_11:
    unsigned __int8 v3 = 0;
    LODWORD(v4) = 0;
    return v3 | (v4 << 8);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, a1[9]);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
  if (!v12)
  {
    std::mutex::unlock(v7);
    goto LABEL_11;
  }
  uint64_t v4 = v12[3];
  BOOL v13 = (std::__shared_weak_count *)v12[4];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v7);
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    if (!v4)
    {
      sub_10004D2C8(v13);
LABEL_16:
      unsigned __int8 v3 = 0;
      return v3 | (v4 << 8);
    }
  }
  else
  {
    std::mutex::unlock(v7);
    if (!v4) {
      goto LABEL_16;
    }
  }
  __int16 v15 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
  unsigned __int8 v3 = v15;
  LODWORD(v4) = HIBYTE(v15);
  if (v13) {
    sub_10004D2C8(v13);
  }
  return v3 | (v4 << 8);
}

void sub_100D83B54(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D83B70(uint64_t a1)
{
  return sub_100D839DC((Registry **)(a1 - 24));
}

void sub_100D83B78(uint64_t a1, long long *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    long long v3 = *a2;
    *(_OWORD *)(a1 + 609) = *(long long *)((char *)a2 + 9);
    *(_OWORD *)(a1 + 60sub_100732068((uint64_t)&a9, 0) = v3;
    uint64_t v4 = *(NSObject **)(a1 + 64);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (!*(unsigned char *)(a1 + 624)) {
      sub_10016C840();
    }
    int v5 = *(unsigned __int8 *)(a1 + 600);
    if (*(unsigned char *)(a1 + 608)) {
      int v6 = *(_DWORD *)(a1 + 604);
    }
    else {
      int v6 = -1;
    }
    v11[0] = 67109376;
    v11[1] = v5;
    __int16 v12 = 1024;
    int v13 = v6;
    unint64_t v8 = "#I fNetworkAssignedSnssai = [%d , %d]";
    int v9 = v4;
    uint32_t v10 = 14;
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 624)) {
    *(unsigned char *)(a1 + 624) = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v11[0]) = 0;
    unint64_t v8 = "#I reset fNetworkAssignedSnssai";
    int v9 = v7;
    uint32_t v10 = 2;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)v11, v10);
  }
}

void sub_100D83CA8(uint64_t a1, long long *a2)
{
}

uint64_t sub_100D83CB0(uint64_t a1, const void **a2, std::string *a3)
{
  int v6 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (void *)*a2;
    }
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v8 = (std::string::size_type)a3;
    }
    else {
      std::string::size_type v8 = a3->__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I matching apnSettingDNN=%s with newDNN=%s", (uint8_t *)&buf, 0x16u);
  }
  uint64_t v9 = *((unsigned __int8 *)a2 + 23);
  if ((v9 & 0x80u) == 0) {
    uint32_t v10 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint32_t v10 = a2[1];
  }
  std::string::size_type size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  int v12 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a3->__r_.__value_.__l.__size_;
  }
  if (v10 != (const void *)size) {
    goto LABEL_25;
  }
  if (v12 >= 0) {
    int v13 = a3;
  }
  else {
    int v13 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*a2, v13, (size_t)a2[1])) {
      goto LABEL_25;
    }
    return 1;
  }
  if (!*((unsigned char *)a2 + 23)) {
    return 1;
  }
  for (uint64_t i = a2;
        *(unsigned __int8 *)i == v13->__r_.__value_.__s.__data_[0];
        uint64_t i = (const void **)((char *)i + 1))
  {
    int v13 = (std::string *)((char *)v13 + 1);
    if (!--v9) {
      return 1;
    }
  }
LABEL_25:
  if (std::string::find((const std::string *)a2, 64, 0) == -1 || std::string::find(a3, 64, 0) == -1) {
    return 0;
  }
  memset(&buf, 0, sizeof(buf));
  std::string::size_type v15 = std::string::find((const std::string *)a2, 64, 0);
  std::string::basic_string(&buf, (const std::string *)a2, 0, v15, (std::allocator<char> *)&v41);
  memset(&v41, 0, sizeof(v41));
  std::string::size_type v16 = std::string::find(a3, 64, 0);
  std::string::basic_string(&v41, a3, 0, v16, (std::allocator<char> *)&v39);
  uint64_t v17 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v18 = buf.__r_.__value_.__l.__size_;
  }
  std::string::size_type v19 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v19 = v41.__r_.__value_.__l.__size_;
  }
  if (v18 != v19) {
    goto LABEL_79;
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v20 = &v41;
  }
  else {
    uint64_t v20 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (memcmp(buf.__r_.__value_.__l.__data_, v20, buf.__r_.__value_.__l.__size_))
    {
LABEL_79:
      uint64_t v22 = 0;
      goto LABEL_80;
    }
  }
  else if (*((unsigned char *)&buf.__r_.__value_.__s + 23))
  {
    p_std::string buf = &buf;
    while (p_buf->__r_.__value_.__s.__data_[0] == v20->__r_.__value_.__s.__data_[0])
    {
      p_std::string buf = (std::string *)((char *)p_buf + 1);
      uint64_t v20 = (std::string *)((char *)v20 + 1);
      if (!--v17) {
        goto LABEL_45;
      }
    }
    goto LABEL_79;
  }
LABEL_45:
  if (!sub_100D84198((uint64_t *)a3))
  {
    if (!sub_100D84198((uint64_t *)a2) || !*(unsigned char *)(a1 + 624)) {
      goto LABEL_79;
    }
    sub_10060C178((const void **)&buf.__r_.__value_.__l.__data_, 64, &v36);
    if (!*(unsigned char *)(a1 + 624)) {
      sub_10016C840();
    }
    std::to_string(&v35, *(unsigned __int8 *)(a1 + 600));
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v23 = &v35;
    }
    else {
      uint64_t v23 = (std::string *)v35.__r_.__value_.__r.__words[0];
    }
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v24 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v24 = v35.__r_.__value_.__l.__size_;
    }
    int v25 = std::string::append(&v36, (const std::string::value_type *)v23, v24);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    std::string::push_back(&v37, 58);
    std::string v38 = v37;
    memset(&v37, 0, sizeof(v37));
    if (!*(unsigned char *)(a1 + 624)) {
      sub_10016C840();
    }
    if (*(unsigned char *)(a1 + 608)) {
      unsigned int v27 = *(_DWORD *)(a1 + 604);
    }
    else {
      unsigned int v27 = 0xFFFFFF;
    }
    std::to_string(&v34, v27);
    if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v28 = &v34;
    }
    else {
      uint64_t v28 = (std::string *)v34.__r_.__value_.__r.__words[0];
    }
    if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v29 = HIBYTE(v34.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v29 = v34.__r_.__value_.__l.__size_;
    }
    long long v30 = std::string::append(&v38, (const std::string::value_type *)v28, v29);
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v30->__r_.__value_.__r.__words[2];
    long long v39 = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v37.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    BOOL v32 = sub_10001D294((unsigned __int8 *)&v39, (unsigned __int8 *)a3);
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)v39);
    }
    if (!v32) {
      goto LABEL_79;
    }
  }
  uint64_t v22 = 1;
LABEL_80:
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  return v22;
}

void sub_100D840E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v40 - 81) < 0) {
    operator delete(*(void **)(v40 - 104));
  }
  if (*(char *)(v40 - 57) < 0) {
    operator delete(*(void **)(v40 - 80));
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D84198(uint64_t *a1)
{
  if (*((char *)a1 + 23) < 0)
  {
    char v2 = a1;
    a1 = (uint64_t *)*a1;
    unint64_t v1 = v2[1];
  }
  else
  {
    unint64_t v1 = *((unsigned __int8 *)a1 + 23);
  }
  v4[0] = a1;
  v4[1] = v1;
  return v1 >= 0xD && sub_10023589C(v4, v1 - 13, 0xFFFFFFFFFFFFFFFFLL, "@255:16777215", 0xDuLL) == 0;
}

uint64_t sub_100D84200(uint64_t a1, const void **a2, std::string *a3)
{
  return sub_100D83CB0(a1 - 24, a2, a3);
}

uint64_t sub_100D84208(uint64_t a1, unsigned int a2)
{
  if (((*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, 0, 1, 1) & 1) != 0
    && !sub_100D83858((Registry **)a1, v4)
    && !sub_100D83708((Registry **)a1, v5))
  {
    return a2 + 8999;
  }
  int v6 = &dword_1015716C8;
  do
  {
    uint64_t v7 = (uint64_t *)(a1 + 24 * *v6);
    uint64_t v8 = v7[15];
    uint64_t v9 = v7[16];
    while (v8 != v9)
    {
      uint64_t v7 = (uint64_t *)*(unsigned __int8 *)(v8 + 16);
      if (*(unsigned char *)(v8 + 16))
      {
        unsigned int v10 = (*(uint64_t (**)(void))(**(void **)(v8 + 8) + 384))(*(void *)(v8 + 8));
        if (a2 >= v10) {
          a2 = v10;
        }
      }
      v8 += 24;
    }
    ++v6;
  }
  while (v6 != &dword_1015716D0);
  return a2 + !sub_100D83858((Registry **)a1, v7) + *(_DWORD *)(a1 + 244);
}

uint64_t sub_100D84330(uint64_t a1, unsigned int a2)
{
  return sub_100D84208(a1 - 24, a2);
}

void sub_100D84338(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v3 - 56)) = a2[9];
  *(void *)(a1 + 24) = a2[10];
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
  sub_100DA17EC(a1 + 632);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 584);
  if (v4) {
    sub_10004D2C8(v4);
  }
  for (uint64_t i = 560; i != 448; i -= 56)
  {
    int v6 = *(std::__shared_weak_count **)(a1 + i);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  uint64_t v7 = *(void *)(a1 + 440);
  *(void *)(a1 + 44sub_100732068((uint64_t)&a9, 0) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  for (uint64_t j = 0; j != -48; j -= 24)
    sub_100103DF0(a1 + j + 416, *(void **)(a1 + j + 424));
  for (uint64_t k = 336; k != 304; k -= 16)
  {
    unsigned int v10 = *(std::__shared_weak_count **)(a1 + k);
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  do
  {
    unsigned int v11 = *(std::__shared_weak_count **)(a1 + k);
    if (v11) {
      sub_10004D2C8(v11);
    }
    k -= 16;
  }
  while (k != 272);
  int v12 = *(std::__shared_weak_count **)(a1 + 272);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  for (uint64_t m = 0; m != -48; m -= 24)
  {
    int v14 = *(void **)(a1 + m + 144);
    if (v14)
    {
      *(void *)(a1 + m + 152) = v14;
      operator delete(v14);
    }
  }
  std::string::size_type v15 = *(std::__shared_weak_count **)(a1 + 96);
  if (v15) {
    sub_10004D2C8(v15);
  }
  std::string::size_type v16 = *(std::__shared_weak_count **)(a1 + 80);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 64));
  sub_100087E88((void *)(a1 + 32));

  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)a1);
}

void sub_100D84560(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_101A58058);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100D84590(uint64_t a1)
{
  sub_100D84338(a1 - 24, (uint64_t *)&off_101A58058);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100D845C4(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_101A58058);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100D84608(uint64_t a1)
{
}

uint64_t sub_100D84610(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[14];
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v14, a1);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, void))(*(void *)v3 + 272))(v3, a2, &v14, 3, 0);
    if (v15) {
      sub_10004D2C8(v15);
    }
    int v6 = a1[8];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
      uint64_t v8 = a1[14];
      if (v8) {
        int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
      }
      else {
        int v9 = -3;
      }
      uint64_t v12 = asStringBool(v5);
      *(_DWORD *)std::string buf = 136315906;
      uint64_t v17 = v7;
      __int16 v18 = 2080;
      std::string::size_type v19 = "suspendDataContext";
      __int16 v20 = 1024;
      int v21 = v9;
      __int16 v22 = 2080;
      uint64_t v23 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: Suspend context %d result: %s", buf, 0x26u);
    }
  }
  else
  {
    unsigned int v10 = a1[8];
    uint64_t v5 = 0;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v17 = v11;
      __int16 v18 = 2080;
      std::string::size_type v19 = "suspendDataContext";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: Cannot suspend context: activator is empty", buf, 0x16u);
      return 0;
    }
  }
  return v5;
}

void sub_100D84864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D84884(uint64_t a1, uint64_t a2)
{
  return sub_100D84610((void *)(a1 - 24), a2);
}

void sub_100D8488C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[14];
  uint64_t v5 = a1[8];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
      uint64_t v8 = a1[14];
      if (v8) {
        int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
      }
      else {
        int v9 = -3;
      }
      *(_DWORD *)std::string buf = 136315650;
      uint64_t v14 = v7;
      __int16 v15 = 2080;
      std::string::size_type v16 = "resumeDataContext";
      __int16 v17 = 1024;
      int v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: Resume context %d", buf, 0x1Cu);
      uint64_t v4 = a1[14];
    }
    (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v11, a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t *, void))(*(void *)v4 + 280))(v4, a2, &v11, 0);
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  else if (v6)
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v14 = v10;
    __int16 v15 = 2080;
    std::string::size_type v16 = "resumeDataContext";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: Cannot resume context: activator is empty", buf, 0x16u);
  }
}

void sub_100D84AC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D84AE0(uint64_t a1, uint64_t a2)
{
}

void sub_100D84AE8(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 136315138;
    *(void *)&buf[1] = "refreshDataSettings";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn", (uint8_t *)buf, 0xCu);
  }
  if (validContextType())
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    sub_100BBEBF8();
  }
  uint64_t v3 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asString();
    buf[0] = 136315394;
    *(void *)&buf[1] = "refreshDataSettings";
    __int16 v8 = 2080;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)buf, 0x16u);
  }
}

void sub_100D852BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, int a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D85334(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  char valid = validContextType();
  uint64_t v11 = *(NSObject **)(a1 + 64);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if ((valid & 1) == 0)
  {
    if (v12)
    {
      *(_DWORD *)long long v39 = 136315394;
      *(void *)&uint64_t v39[4] = "resetActivationBlocker";
      *(_WORD *)&v39[12] = 2080;
      uint64_t v40 = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", v39, 0x16u);
    }
    return 0;
  }
  if (v12)
  {
    *(_DWORD *)long long v39 = 67109376;
    *(_DWORD *)&uint64_t v39[4] = a4;
    *(_WORD *)&v39[8] = 1024;
    *(_DWORD *)&v39[10] = a5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I resetActivationBlocker doNoResetIP %d, resetOnlyIP %d", v39, 0xEu);
  }
  if (a4)
  {
    BOOL v13 = 0;
  }
  else
  {
    uint64_t v14 = a1 + a2;
    BOOL v13 = *(unsigned char *)(v14 + 344) != 0;
    if (*(unsigned char *)(v14 + 344))
    {
      __int16 v15 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = asString();
        *(_DWORD *)long long v39 = 136315650;
        *(void *)&uint64_t v39[4] = "resetActivationBlocker";
        *(_WORD *)&v39[12] = 2080;
        uint64_t v40 = a3;
        __int16 v41 = 2080;
        uint64_t v42 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s: %s: fIPv4ActivationBlocker[%s]: set to false", v39, 0x20u);
      }
      *(unsigned char *)(v14 + 344) = 0;
    }
    uint64_t v17 = a1 + a2;
    if (*(unsigned char *)(v17 + 346))
    {
      int v18 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = asString();
        *(_DWORD *)long long v39 = 136315650;
        *(void *)&uint64_t v39[4] = "resetActivationBlocker";
        *(_WORD *)&v39[12] = 2080;
        uint64_t v40 = a3;
        __int16 v41 = 2080;
        uint64_t v42 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s: %s: fIPv6ActivationBlocker[%s]: set to false", v39, 0x20u);
      }
      *(unsigned char *)(v17 + 346) = 0;
      BOOL v13 = 1;
    }
  }
  if (a5) {
    return v13;
  }
  uint64_t v20 = a1 + 16 * a2;
  int v21 = *(uint64_t **)(v20 + 312);
  if (!v21) {
    return v13;
  }
  if (a2)
  {
LABEL_20:
    __int16 v22 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = asString();
      *(_DWORD *)long long v39 = 136315906;
      *(void *)&uint64_t v39[4] = "resetActivationBlocker";
      *(_WORD *)&v39[12] = 2080;
      uint64_t v40 = a3;
      __int16 v41 = 2080;
      uint64_t v42 = v23;
      __int16 v43 = 2080;
      uint64_t v44 = a3;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: %s: ActivationBlocker[%s]: set to false (%s)", v39, 0x2Au);
    }
    std::string::size_type v24 = *(std::__shared_weak_count **)(a1 + 16 * a2 + 320);
    *(void *)(v20 + 312) = 0;
    *(void *)(v20 + 32sub_100732068((uint64_t)&a9, 0) = 0;
    if (v24) {
      sub_10004D2C8(v24);
    }
    return 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)(a1 + 72));
  unsigned int v27 = ServiceMap;
  if (v28 < 0)
  {
    std::string::size_type v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v30 = 5381;
    do
    {
      uint64_t v28 = v30;
      unsigned int v31 = *v29++;
      uint64_t v30 = (33 * v30) ^ v31;
    }
    while (v31);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long v39 = v28;
  BOOL v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)v39);
  if (v32)
  {
    uint64_t v34 = v32[3];
    uint64_t v33 = (std::__shared_weak_count *)v32[4];
    if (v33)
    {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v27);
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v33);
      char v35 = 0;
      goto LABEL_34;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  std::mutex::unlock(v27);
  uint64_t v33 = 0;
  char v35 = 1;
LABEL_34:
  if (!v34
    || (uint64_t v36 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1),
        !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v34 + 1088))(v34, v36)))
  {
    if ((v35 & 1) == 0) {
      sub_10004D2C8(v33);
    }
    goto LABEL_20;
  }
  std::string v37 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v38 = asString();
    *(_DWORD *)long long v39 = 136315650;
    *(void *)&uint64_t v39[4] = "resetActivationBlocker";
    *(_WORD *)&v39[12] = 2080;
    uint64_t v40 = v38;
    __int16 v41 = 2080;
    uint64_t v42 = a3;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#N %s: ActivationBlocker[%s]: cannot be reset on %s, network scan is in progress", v39, 0x20u);
  }
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  return v13;
}

void sub_100D857A8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D857DC(uint64_t a1, int a2)
{
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v2 = *(void *)(a1 + 264);
      if (v2) {
        return *(void *)(v2 + 160);
      }
    }
    else
    {
      uint64_t v5 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315394;
        uint64_t v7 = "getTypeMask";
        __int16 v8 = 2080;
        uint64_t v9 = asString();
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: requested with wrong context type: %s", (uint8_t *)&v6, 0x16u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 264);
    if (v4) {
      return *(void *)(v4 + 152);
    }
  }
  return 0;
}

void sub_100D858C4(uint64_t a1)
{
}

uint64_t sub_100D858CC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 136))(a1, a2, 1, 0);
  if (!result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, const char *))(*(void *)a1 + 680);
    return v5(a1, a2, 27, "abandoned DataSettings detected", "CommCenter");
  }
  return result;
}

uint64_t sub_100D85980(uint64_t a1, uint64_t a2)
{
  return sub_100D858CC(a1 - 24, a2);
}

uint64_t sub_100D85988(uint64_t a1, int a2)
{
  return sub_100D857DC(a1 - 24, a2);
}

uint64_t sub_100D85990(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

const void **sub_100D85998(uint64_t a1, BOOL *a2, BOOL *a3, uint64_t *a4, uint64_t a5)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if (*(char *)(a5 + 23) < 0)
  {
    *(void *)(a5 + 8) = 0;
    uint64_t v10 = *(uint64_t **)a5;
  }
  else
  {
    *(unsigned char *)(a5 + 23) = 0;
    uint64_t v10 = (uint64_t *)a5;
  }
  *(unsigned char *)uint64_t v10 = 0;
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 72));
  BOOL v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    int v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  int v18 = 0;
  char v20 = 1;
LABEL_12:
  uint64_t v21 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v19 + 96))(v48, v19, v21, 1, @"IPv6APNFallback", 0, 0);
  sub_10004EFE4(&theDict, (CFTypeRef *)v48);
  sub_1000577C4((const void **)v48);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (theDict) {
    __int16 v22 = sub_100080778;
  }
  else {
    __int16 v22 = 0;
  }
  if (v22)
  {
    Value = (unsigned int *)CFDictionaryGetValue(theDict, @"ProtocolMask");
    std::string::size_type v24 = Value;
    *(_DWORD *)std::string buf = 0;
    if (Value)
    {
      CFTypeID v25 = CFGetTypeID(Value);
      if (v25 == CFNumberGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v24, v26);
        LOBYTE(v24) = buf[0];
      }
      else
      {
        LOBYTE(v24) = 0;
      }
    }
    if (CFDictionaryContainsKey(theDict, @"ApnName"))
    {
      CFDictionaryGetValue(theDict, @"ApnName");
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      uint64_t v27 = *(void *)buf;
      *(void *)uint64_t v48 = *(void *)&buf[8];
      *(void *)&v48[7] = *(void *)&buf[15];
      uint8_t v28 = buf[23];
      if (*(char *)(a5 + 23) < 0) {
        operator delete(*(void **)a5);
      }
      uint64_t v29 = *(void *)v48;
      *(void *)a5 = v27;
      *(void *)(a5 + 8) = v29;
      *(void *)(a5 + 15) = *(void *)&v48[7];
      *(unsigned char *)(a5 + 23) = v28;
    }
    *a2 = v24 & 1;
    if (v24)
    {
      *a3 = (v24 & 2) != 0;
      uint64_t v30 = (unsigned int *)CFDictionaryGetValue(theDict, @"Timeout");
      unsigned int v31 = v30;
      *(_DWORD *)std::string buf = 0;
      if (v30 && (CFTypeID v32 = CFGetTypeID(v30), v32 == CFNumberGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)buf, v31, v33);
        uint64_t v34 = *(unsigned int *)buf;
      }
      else
      {
        uint64_t v34 = 0;
      }
      *a4 = v34;
    }
  }
  char v35 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = asStringBool(*a2);
    uint64_t v37 = asStringBool(*a3);
    uint64_t v38 = *a4;
    if (*(char *)(a5 + 23) >= 0) {
      long long v39 = (uint64_t *)a5;
    }
    else {
      long long v39 = *(uint64_t **)a5;
    }
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = "readApnFallback";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v36;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v43 = v37;
    __int16 v44 = 2048;
    uint64_t v45 = v38;
    __int16 v46 = 2080;
    int v47 = v39;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s: ipv4 = %s, ipint v6 = %s, timeout = %lu, apn=%s", buf, 0x34u);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100D85D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100D85DA0(uint64_t a1, int a2)
{
  if (validContextType())
  {
    uint64_t v4 = a1 + 24 * a2;
    uint64_t v5 = *(void *)(v4 + 120);
    uint64_t v6 = *(void *)(v4 + 128);
    while (1)
    {
      if (v5 == v6) {
        return 1;
      }
      if (*(unsigned char *)(v5 + 16)
        && ((*(uint64_t (**)(void))(**(void **)(v5 + 8) + 256))(*(void *)(v5 + 8)) & 1) == 0)
      {
        break;
      }
      v5 += 24;
    }
    uint64_t v13 = *(NSObject **)(a1 + 64);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v14)
    {
      (*(void (**)(void))(**(void **)(v5 + 8) + 200))(*(void *)(v5 + 8));
      int v15 = 136315650;
      unsigned int v16 = "connectionsReady";
      __int16 v17 = 2080;
      uint64_t v18 = asString();
      __int16 v19 = 2080;
      uint64_t v20 = asString();
      uint64_t v10 = "#I %s: Observer %s not ready for context type: %s";
      uint64_t v11 = v13;
      uint32_t v12 = 32;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 64);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v8)
    {
      int v15 = 136315394;
      unsigned int v16 = "connectionsReady";
      __int16 v17 = 2080;
      uint64_t v18 = asString();
      uint64_t v10 = "#E %s: wrong context type: %s";
      uint64_t v11 = v7;
      uint32_t v12 = 22;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v15, v12);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100D85F80(uint64_t a1, int a2)
{
  return sub_100D85DA0(a1 - 24, a2);
}

void sub_100D85F88(uint64_t a1, signed int a2, const DataAPNSettingsObserver *a3, char a4)
{
  if (a3)
  {
    if (validContextType())
    {
      uint64_t v8 = a1 + 24 * a2;
      uint64_t v11 = *(void **)(v8 + 120);
      uint64_t v10 = (void **)(v8 + 120);
      uint64_t v9 = v11;
      uint64_t v13 = v10 + 1;
      uint32_t v12 = v10[1];
      if (v11 == v12) {
        goto LABEL_7;
      }
      char v14 = 0;
      int v15 = v9;
      do
      {
        v14 |= v15[1] == (void)a3;
        v15 += 3;
      }
      while (v15 != v12);
      if ((v14 & 1) == 0)
      {
LABEL_7:
        uint64_t v16 = a1 + 24 * a2;
        unint64_t v19 = *(void *)(v16 + 136);
        uint64_t v18 = (char **)(v16 + 136);
        unint64_t v17 = v19;
        if ((unint64_t)v12 >= v19)
        {
          unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (v12 - v9);
          unint64_t v23 = v22 + 1;
          if (v22 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_100DA1868();
          }
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - (void)v9) >> 3);
          if (2 * v24 > v23) {
            unint64_t v23 = 2 * v24;
          }
          if (v24 >= 0x555555555555555) {
            unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v25 = v23;
          }
          if (v25) {
            CFNumberRef v26 = (char *)sub_10004812C((uint64_t)v18, v25);
          }
          else {
            CFNumberRef v26 = 0;
          }
          uint64_t v27 = &v26[24 * v22];
          uint8_t v28 = &v26[24 * v25];
          *(_DWORD *)uint64_t v27 = a2;
          *((void *)v27 + 1) = a3;
          v27[16] = 0;
          uint64_t v20 = v27 + 24;
          uint64_t v29 = (char *)*v13;
          uint64_t v30 = (char *)*v10;
          if (*v13 != *v10)
          {
            do
            {
              long long v31 = *(_OWORD *)(v29 - 24);
              *(v27 - 8) = *(v29 - 8);
              *(_OWORD *)(v27 - 24) = v31;
              v27 -= 24;
              v29 -= 24;
            }
            while (v29 != v30);
            uint64_t v29 = (char *)*v10;
          }
          *uint64_t v10 = v27;
          NSObject *v13 = v20;
          *uint64_t v18 = v28;
          if (v29) {
            operator delete(v29);
          }
        }
        else
        {
          *(_DWORD *)uint32_t v12 = a2;
          v12[1] = a3;
          uint64_t v20 = v12 + 3;
          *((unsigned char *)v12 + 16) = 0;
        }
        NSObject *v13 = v20;
        CFTypeID v32 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = asString(a3);
          uint64_t v34 = asString();
          int v35 = -1431655765 * ((unint64_t)((unsigned char *)*v13 - (unsigned char *)*v10) >> 3);
          int v36 = 136316674;
          uint64_t v37 = "registerObserver";
          __int16 v38 = 2048;
          uint64_t v39 = a1;
          __int16 v40 = 2080;
          uint64_t v41 = v33;
          __int16 v42 = 2080;
          uint64_t v43 = v34;
          __int16 v44 = 2048;
          uint64_t v45 = a3;
          __int16 v46 = 1024;
          int v47 = v35;
          __int16 v48 = 2080;
          uint64_t v49 = asStringBool(a4);
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s: 0x%lx: %s registered with us on %s: 0x%lx, new size=%d, current = %s", (uint8_t *)&v36, 0x44u);
        }
      }
      sub_100D862A8(a1, a2, a3, a4);
    }
    else
    {
      uint64_t v21 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        int v36 = 136315394;
        uint64_t v37 = "registerObserver";
        __int16 v38 = 2080;
        uint64_t v39 = asString();
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)&v36, 0x16u);
      }
    }
  }
}

void sub_100D862A8(uint64_t a1, unsigned int a2, const DataAPNSettingsObserver *a3, char a4)
{
  if (validContextType())
  {
    if (a4)
    {
      uint64_t v39 = 0;
      v40[0] = 0;
      v40[1] = 0;
      (*(void (**)(void ***__return_ptr, const DataAPNSettingsObserver *))(*(void *)a3 + 360))(&v39, a3);
      uint64_t v7 = v39;
      if (v39 != v40)
      {
        do
        {
          uint64_t v8 = v7[4];
          uint64_t v9 = (std::__shared_weak_count *)v7[5];
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v8) {
            uint64_t v10 = v8 - 24;
          }
          else {
            uint64_t v10 = 0;
          }
          if (v10 != a1)
          {
            for (uint64_t i = 0; i != 2; ++i)
            {
              uint64_t v12 = dword_1015716C8[i];
              if (sub_100D86BE4(v10, dword_1015716C8[i], a3))
              {
                uint64_t v13 = *(NSObject **)(a1 + 64);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = "setObserverCurrent";
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E %s: !!! Logic problem: Connection cannot be current on different APNs !!!", buf, 0xCu);
                }
                sub_100D862A8(v10, v12, a3, 0);
              }
            }
          }
          if (v9) {
            sub_10004D2C8(v9);
          }
          char v14 = (void *)v7[1];
          if (v14)
          {
            do
            {
              int v15 = (void **)v14;
              char v14 = (void *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              int v15 = (void **)v7[2];
              BOOL v16 = *v15 == v7;
              uint64_t v7 = v15;
            }
            while (!v16);
          }
          uint64_t v7 = v15;
        }
        while (v15 != v40);
      }
      unint64_t v17 = dword_1015716C8;
      uint64_t v18 = a2;
      do
      {
        int v19 = *v17;
        uint64_t v20 = a1 + 24 * *v17;
        uint64_t v22 = *(void *)(v20 + 120);
        uint64_t v21 = *(void *)(v20 + 128);
        while (v22 != v21)
        {
          if (*(const DataAPNSettingsObserver **)(v22 + 8) == a3)
          {
            int v23 = v19 == v18 && sub_100D86A8C(a1, v18, (uint64_t)a3, 1);
            if (*(unsigned __int8 *)(v22 + 16) != v23)
            {
              *(unsigned char *)(v22 + 16) = v23;
              unint64_t v24 = *(NSObject **)(a1 + 64);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v25 = asString();
                (*(void (**)(const DataAPNSettingsObserver *))(*(void *)a3 + 200))(a3);
                uint64_t v26 = asString();
                uint64_t v27 = asStringBool(v23);
                *(_DWORD *)std::string buf = 136315906;
                *(void *)&uint8_t buf[4] = "setObserverCurrent";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v25;
                __int16 v42 = 2080;
                uint64_t v43 = v26;
                __int16 v44 = 2080;
                uint64_t v45 = v27;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s:  (change states) on %s: connection %s becomes current %s", buf, 0x2Au);
                uint64_t v18 = a2;
              }
            }
          }
          v22 += 24;
        }
        ++v17;
      }
      while (v17 != &dword_1015716D0);
      if (!sub_100D86A8C(a1, v18, (uint64_t)a3, 1))
      {
        sub_10003E168(buf, (void *)(a1 + 32));
        if (*(void *)buf) {
          uint64_t v28 = *(void *)buf + 24;
        }
        else {
          uint64_t v28 = 0;
        }
        uint64_t v37 = v28;
        __int16 v38 = *(std::__shared_weak_count **)&buf[8];
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        (*(void (**)(const DataAPNSettingsObserver *, uint64_t, uint64_t *))(*(void *)a3 + 64))(a3, v18, &v37);
        if (v38) {
          sub_10004D2C8(v38);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      sub_100103DF0((uint64_t)&v39, v40[0]);
    }
    else
    {
      uint64_t v29 = a1 + 24 * (int)a2;
      uint64_t v30 = *(void *)(v29 + 120);
      for (uint64_t j = *(void *)(v29 + 128); v30 != j; v30 += 24)
      {
        if (*(const DataAPNSettingsObserver **)(v30 + 8) == a3)
        {
          if (*(unsigned char *)(v30 + 16))
          {
            *(unsigned char *)(v30 + 16) = a4;
            CFTypeID v32 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v33 = asString();
              (*(void (**)(const DataAPNSettingsObserver *))(*(void *)a3 + 200))(a3);
              uint64_t v34 = asString();
              uint64_t v35 = asStringBool(0);
              *(_DWORD *)std::string buf = 136315906;
              *(void *)&uint8_t buf[4] = "setObserverCurrent";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v33;
              __int16 v42 = 2080;
              uint64_t v43 = v34;
              __int16 v44 = 2080;
              uint64_t v45 = v35;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s:  (change states) on %s: connection %s becomes current %s", buf, 0x2Au);
            }
          }
        }
      }
    }
  }
}

void sub_100D86770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, char a16, void *a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_100103DF0((uint64_t)&a16, a17);
  _Unwind_Resume(a1);
}

void sub_100D867CC(uint64_t a1, signed int a2, const DataAPNSettingsObserver *a3, char a4)
{
}

void sub_100D867D4(void *a1, int a2, const DataAPNSettingsObserver *a3)
{
  uint64_t v6 = dword_1015716C8;
  do
  {
    int v7 = *v6;
    if (*v6 == a2 || anyContextType())
    {
      uint64_t v8 = &a1[3 * v7];
      uint64_t v11 = v8[15];
      uint64_t v10 = v8 + 15;
      uint64_t v9 = v11;
      uint64_t v13 = v10 + 1;
      uint64_t v12 = v10[1];
      if (v11 != v12)
      {
        uint64_t v14 = 0;
        while (1)
        {
          uint64_t v15 = v9 + v14;
          if (*(const DataAPNSettingsObserver **)(v9 + v14 + 8) == a3) {
            break;
          }
          v14 += 24;
          if (v9 + v14 == v12) {
            goto LABEL_13;
          }
        }
        uint64_t v16 = v12 - (v15 + 24);
        if (v12 != v15 + 24) {
          memmove((void *)(v9 + v14), (const void *)(v15 + 24), v16 - 7);
        }
        void *v13 = v15 + v16;
        unint64_t v17 = a1[8];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = asString(a3);
          uint64_t v19 = asString();
          int v20 = -1431655765 * ((*v13 - *v10) >> 3);
          *(_DWORD *)std::string buf = 136316418;
          uint64_t v30 = "unregisterObserver";
          __int16 v31 = 2048;
          CFTypeID v32 = a1;
          __int16 v33 = 2080;
          uint64_t v34 = v18;
          __int16 v35 = 2048;
          int v36 = a3;
          __int16 v37 = 2080;
          uint64_t v38 = v19;
          __int16 v39 = 1024;
          int v40 = v20;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: 0x%lx: %s (0x%lx) unregistered with us (settings) on %s, new size=%d", buf, 0x3Au);
        }
      }
    }
LABEL_13:
    ++v6;
  }
  while (v6 != &dword_1015716D0);
  char v21 = 0;
  uint64_t v22 = dword_1015716C8;
  do
  {
    int v23 = &a1[3 * *v22];
    uint64_t v24 = v23[15];
    uint64_t v25 = v23[16];
    if (v24 == v25) {
      goto LABEL_20;
    }
    char v26 = 0;
    do
    {
      v26 |= *(unsigned char *)(v24 + 16);
      v24 += 24;
    }
    while (v24 != v25);
    if ((v26 & 1) == 0)
    {
LABEL_20:
      (*(void (**)(void *))(*a1 + 680))(a1);
      char v27 = 0;
    }
    else
    {
      char v27 = 1;
    }
    v21 |= v27;
    ++v22;
  }
  while (v22 != &dword_1015716D0);
  if ((v21 & 1) == 0)
  {
    uint64_t v28 = a1[55];
    a1[55] = 0;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
    }
  }
}

void sub_100D86A84(uint64_t a1, int a2, const DataAPNSettingsObserver *a3)
{
}

BOOL sub_100D86A8C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!a3) {
    return 0;
  }
  if ((validContextType() & 1) == 0)
  {
    uint64_t v15 = *(NSObject **)(a1 + 64);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v16) {
      return result;
    }
    int v17 = 136315394;
    uint64_t v18 = "isObserverValid";
    __int16 v19 = 2080;
    uint64_t v20 = asString();
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)&v17, 0x16u);
    return 0;
  }
  if (a4 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 184))(a3, a2) & 1) != 0) {
    return 0;
  }
  uint64_t v8 = a1 + 24 * (int)a2;
  uint64_t v10 = *(void *)(v8 + 120);
  uint64_t v9 = *(void *)(v8 + 128);
  if (v10 == v9) {
    return 0;
  }
  uint64_t v11 = v10 + 24;
  do
  {
    uint64_t v12 = *(void *)(v11 - 16);
    BOOL result = v12 == a3;
    BOOL v14 = v12 == a3 || v11 == v9;
    v11 += 24;
  }
  while (!v14);
  return result;
}

BOOL sub_100D86BDC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return sub_100D86A8C(a1 - 24, a2, a3, a4);
}

BOOL sub_100D86BE4(uint64_t a1, int a2, const DataAPNSettingsObserver *a3)
{
  if (validContextType())
  {
    uint64_t v6 = a1 + 24 * a2;
    uint64_t v7 = *(void *)(v6 + 120);
    uint64_t v8 = *(void *)(v6 + 128);
    while (v7 != v8)
    {
      if (*(const DataAPNSettingsObserver **)(v7 + 8) == a3) {
        return *(unsigned char *)(v7 + 16) != 0;
      }
      v7 += 24;
    }
  }
  uint64_t v9 = *(NSObject **)(a1 + 64);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v10)
  {
    int v12 = 136315650;
    uint64_t v13 = "isObserverCurrent";
    __int16 v14 = 2080;
    uint64_t v15 = asString(a3);
    __int16 v16 = 2080;
    uint64_t v17 = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: %s is not registered with us for %s", (uint8_t *)&v12, 0x20u);
    return 0;
  }
  return result;
}

BOOL sub_100D86D10(uint64_t a1, int a2, const DataAPNSettingsObserver *a3)
{
  return sub_100D86BE4(a1 - 24, a2, a3);
}

uint64_t sub_100D86D18(uint64_t a1, char a2, char a3, const std::string *a4, std::string *__str)
{
  *(unsigned char *)a1 = a2;
  *(unsigned char *)(a1 + 1) = a3;
  std::string::operator=((std::string *)(a1 + 40), __str);
  *(unsigned char *)(a1 + 2) = *(unsigned char *)a1;
  std::string::operator=((std::string *)(a1 + 8), a4);
  uint64_t result = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (result)
  {
    uint64_t v8 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v8();
  }
  return result;
}

uint64_t sub_100D86DAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100D86DBC(PersonalitySpecificImpl *a1, BOOL a2, BOOL a3, uint64_t a4, void **a5)
{
  BOOL v10 = *((void *)a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asStringBool(a2);
    uint64_t v12 = asStringBool(a3);
    uint64_t v13 = a5;
    if (*((char *)a5 + 23) < 0) {
      uint64_t v13 = *a5;
    }
    *(_DWORD *)std::string buf = 136316162;
    uint64_t v17 = "reportIPv6APNFallbackAWDMetrics";
    __int16 v18 = 2080;
    uint64_t v19 = v11;
    __int16 v20 = 2080;
    uint64_t v21 = v12;
    __int16 v22 = 2048;
    uint64_t v23 = a4;
    __int16 v24 = 2080;
    uint64_t v25 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: Reporting IPv6APNFallback metrics: fallbackAPN %s, due to fallback %s, lifetime %lu, app %s", buf, 0x34u);
  }
  PersonalitySpecificImpl::simSlot(a1);
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(__p, *a5, (unint64_t)a5[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a5;
    uint64_t v15 = a5[2];
  }
  sub_10017D3B8();
}

void sub_100D86F80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D86FA4(uint64_t a1, int a2)
{
  if (validContextType()) {
    return *(unsigned int *)(a1 + 4 * a2 + 232);
  }
  uint64_t v5 = *(NSObject **)(a1 + 64);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v6)
  {
    int v7 = 136315394;
    uint64_t v8 = "getDataSettingsState";
    __int16 v9 = 2080;
    uint64_t v10 = asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)&v7, 0x16u);
    return 0;
  }
  return result;
}

void sub_100D87084(uint64_t a1)
{
  sub_100058DB0(&v3, (char *)&unk_10165244B);
  sub_100058DB0(&__p, (char *)&unk_10165244B);
  sub_100D86D18(a1, 0, 0, &v3, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v3.__r_.__value_.__l.__data_);
  }
}

void sub_100D87104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D87138(uint64_t a1, uint64_t a2, int a3)
{
  if (validContextType())
  {
    uint64_t v6 = a1 + 4 * (int)a2;
    int v9 = *(_DWORD *)(v6 + 232);
    int v7 = (_DWORD *)(v6 + 232);
    int v8 = v9;
    BOOL v10 = v9 != a3;
    uint64_t v11 = *(void *)(a1 + 112);
    if (v11) {
      BOOL v12 = v8 == a3;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12) {
      (*(void (**)(uint64_t, void))(*(void *)v11 + 344))(v11, 0);
    }
    BOOL v50 = v10;
    uint64_t v13 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "setDataSettingsState";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asString();
      __int16 v58 = 2080;
      uint64_t v59 = asString();
      __int16 v60 = 2080;
      uint64_t v61 = asString();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: (change states) %s to %s (for %s)", buf, 0x2Au);
    }
    char valid = validContextType();
    uint64_t v15 = *(NSObject **)(a1 + 64);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (valid)
    {
      if (v16)
      {
        uint64_t v49 = asString();
        sub_100D86FA4(a1, a2);
        uint64_t v48 = asString();
        uint64_t v17 = asStringBool(*(unsigned char *)(a1 + 16 * (int)a2 + 368));
        uint64_t v18 = asStringBool(*(unsigned char *)(a1 + 632));
        char v19 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)a1 + 136))(a1, a2, 0, 0);
        uint64_t v20 = asStringBool(v19 & 1);
        uint64_t v21 = asStringBool(*(unsigned char *)(a1 + (int)a2 + 240));
        uint64_t v22 = asStringBool(*(unsigned char *)(a1 + 634));
        *(_DWORD *)std::string buf = 136316930;
        *(void *)&uint8_t buf[4] = "adjustDataSettingsAPNFallback";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v49;
        __int16 v58 = 2080;
        uint64_t v59 = v48;
        __int16 v60 = 2080;
        uint64_t v61 = v17;
        __int16 v62 = 2080;
        uint64_t v63 = v18;
        __int16 v64 = 2080;
        uint64_t v65 = v20;
        __int16 v66 = 2080;
        uint64_t v67 = v21;
        __int16 v68 = 2080;
        uint64_t v69 = v22;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s: newState = %s; old os_activity_scope_state_s state = %s; startTime = %s; isSet = %s; internetMask = %s; ipv6only = %s; tentative = %s",
          buf,
          0x52u);
      }
      if (!a2 && sub_100D86FA4(a1, 0) != a3)
      {
        if (!a3)
        {
          if (*(unsigned char *)(a1 + 368))
          {
            uint64_t v41 = time(0) - *(void *)(a1 + 360);
            __int16 v42 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "adjustDataSettingsAPNFallback";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v41;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s: settings lifetime: %lu", buf, 0x16u);
            }
            if (*(unsigned char *)(a1 + 368)) {
              *(unsigned char *)(a1 + 368) = 0;
            }
          }
          else
          {
            uint64_t v41 = 0;
          }
          if (*(unsigned char *)(a1 + 632)) {
            goto LABEL_69;
          }
          if (((*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a1 + 136))(a1, 0, 0, 0) & 1) != 0
            && *(unsigned char *)(a1 + 240))
          {
            sub_100058DB0(__p, (char *)&unk_10165244B);
            sub_100D86DBC((PersonalitySpecificImpl *)a1, 0, 0, v41, __p);
          }
          if (*(unsigned char *)(a1 + 632))
          {
LABEL_69:
            int v43 = *(unsigned __int8 *)(a1 + 634);
            __int16 v44 = *(NSObject **)(a1 + 64);
            BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
            if (v43)
            {
              if (v45)
              {
                uint64_t v46 = asString();
                *(_DWORD *)std::string buf = 136315394;
                *(void *)&uint8_t buf[4] = "adjustDataSettingsAPNFallback";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v46;
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s: fAPNFallbackState %s set firm", buf, 0x16u);
              }
              *(unsigned char *)(a1 + 634) = 0;
              if (*(char *)(a1 + 695) < 0)
              {
                sub_10004FC84(&__dst, *(void **)(a1 + 672), *(void *)(a1 + 680));
              }
              else
              {
                long long __dst = *(_OWORD *)(a1 + 672);
                uint64_t v55 = *(void *)(a1 + 688);
              }
              sub_100D86DBC((PersonalitySpecificImpl *)a1, 0, 1, v41, (void **)&__dst);
            }
            if (v45)
            {
              uint64_t v47 = asString();
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "adjustDataSettingsAPNFallback";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v47;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s: fAPNFallbackState %s reset after deactivation", buf, 0x16u);
            }
            sub_100D87084(a1 + 632);
            sub_100058DB0(v53, (char *)&unk_10165244B);
            sub_100D86DBC((PersonalitySpecificImpl *)a1, 1, 0, v41, v53);
          }
          *int v7 = 0;
          goto LABEL_26;
        }
        if (a3 == 3)
        {
          time_t v23 = time(0);
          if (!*(unsigned char *)(a1 + 368)) {
            *(unsigned char *)(a1 + 368) = 1;
          }
          *(void *)(a1 + 36sub_100732068((uint64_t)&a9, 0) = v23;
          *int v7 = 3;
          goto LABEL_36;
        }
      }
    }
    else if (v16)
    {
      uint64_t v26 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "adjustDataSettingsAPNFallback";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v26;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", buf, 0x16u);
    }
    *int v7 = a3;
    if (a3 == 3)
    {
LABEL_36:
      *(_DWORD *)(a1 + 456) = 0;
      *(void *)(a1 + 464) = &unk_10165244B;
      *(void *)(a1 + 472) = &unk_10165244B;
      *(_DWORD *)(a1 + 48sub_100732068((uint64_t)&a9, 0) = 0;
      *(unsigned char *)(a1 + 484) = 0;
      *(void *)(a1 + 488) = 0;
      *(void *)(a1 + 496) = 0;
      __int16 v33 = *(std::__shared_weak_count **)(a1 + 504);
      *(void *)(a1 + 504) = 0;
      BOOL v25 = v50;
      if (v33) {
        sub_10004D2C8(v33);
      }
      *(_DWORD *)(a1 + 512) = 0;
      *(void *)(a1 + 52sub_100732068((uint64_t)&a9, 0) = &unk_10165244B;
      *(void *)(a1 + 528) = &unk_10165244B;
      *(_DWORD *)(a1 + 536) = 0;
      *(unsigned char *)(a1 + 54sub_100732068((uint64_t)&a9, 0) = 0;
      *(void *)(a1 + 544) = 1;
      uint64_t v34 = *(std::__shared_weak_count **)(a1 + 560);
      *(void *)(a1 + 552) = 0;
      *(void *)(a1 + 56sub_100732068((uint64_t)&a9, 0) = 0;
      if (v34) {
        sub_10004D2C8(v34);
      }
      *(void *)(a1 + 448) = 0;
      return v25;
    }
    BOOL v25 = v50;
    if (a3 == 2)
    {
      sub_100D87AF8(a1, a2);
      __int16 v35 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v36;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I fLastActivationStart set for %s (initial)", buf, 0xCu);
      }
      return v50;
    }
    if (a3) {
      return v25;
    }
LABEL_26:
    if (v8 != a3)
    {
      if (validContextType())
      {
        uint64_t v27 = a1 + 16 * (int)a2;
        if (*(unsigned char *)(v27 + 704))
        {
          if (validContextType() && *(unsigned char *)(v27 + 704)) {
            *(unsigned char *)(v27 + 704) = 0;
          }
          uint64_t v28 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = asString();
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v29;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I fLastActivationStart reset for %s", buf, 0xCu);
          }
        }
      }
      *(_DWORD *)&uint8_t buf[8] = 0;
      *(void *)std::string buf = 0x1FFFFFFFFLL;
      uint64_t v30 = otherContextType();
      uint64_t v31 = *(void *)(a1 + 112);
      if (v31) {
        uint64_t v32 = (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v31 + 312))(v31, v30) | 0x100;
      }
      else {
        uint64_t v32 = 256;
      }
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, unsigned char *))(*(void *)a1 + 72))(a1, 0, a2, v32, 0, buf);
    }
    uint64_t v37 = *(void *)(a1 + 112);
    if (v37)
    {
      sub_10003E168(buf, (void *)(a1 + 32));
      if (*(void *)buf) {
        uint64_t v38 = *(void *)buf + 24;
      }
      else {
        uint64_t v38 = 0;
      }
      uint64_t v51 = v38;
      char v52 = *(std::__shared_weak_count **)&buf[8];
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      int v39 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v37 + 360))(v37, &v51);
      if (v52) {
        sub_10004D2C8(v52);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v39) {
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 296))(*(void *)(a1 + 112), a2);
      }
    }
    (*(void (**)(uint64_t, const char *, void, void))(*(void *)a1 + 696))(a1, "settings is idle", 0, 0);
    return v50;
  }
  __int16 v24 = *(NSObject **)(a1 + 64);
  BOOL v25 = 0;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "setDataSettingsState";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", buf, 0x16u);
    return 0;
  }
  return v25;
}

void sub_100D87A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35)
{
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D87AF8(uint64_t a1, int a2)
{
  uint64_t result = validContextType();
  if (result)
  {
    uint64_t result = sub_100DA1258(*(Registry **)(a1 + 72));
    uint64_t v5 = a1 + 16 * a2;
    if (!*(unsigned char *)(v5 + 704)) {
      *(unsigned char *)(v5 + 704) = 1;
    }
    *(void *)(v5 + 696) = result;
  }
  return result;
}

uint64_t sub_100D87B4C(uint64_t a1, int a2, char a3, uint64_t a4)
{
  if (validContextType())
  {
    uint64_t v8 = a1 + 24 * a2;
    uint64_t v9 = *(void *)(v8 + 120);
    uint64_t v10 = *(void *)(v8 + 128);
    if (v9 == v10)
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      do
      {
        if ((a3 & 1) != 0 || *(unsigned char *)(v9 + 16)) {
          v11 |= (*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 8) + 24))(*(void *)(v9 + 8), a4);
        }
        v9 += 24;
      }
      while (v9 != v10);
    }
    if ((v11 & 0x10001) == 0x10000) {
      return v11 & 0x18000;
    }
    else {
      return v11;
    }
  }
  else
  {
    BOOL v12 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 136315394;
      uint64_t v15 = "getConnectionMask";
      __int16 v16 = 2080;
      uint64_t v17 = asString();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)&v14, 0x16u);
    }
    return 0;
  }
}

uint64_t sub_100D87CB0(uint64_t a1, int a2, char a3, uint64_t a4)
{
  return sub_100D87B4C(a1 - 24, a2, a3, a4);
}

uint64_t sub_100D87CB8(void *a1, uint64_t a2)
{
  if (validContextType())
  {
    int v4 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 992))(a1, a2);
    uint64_t v5 = &a1[3 * (int)a2];
    uint64_t v6 = v5[15];
    uint64_t v7 = v5[16];
    while (v6 != v7)
    {
      if (*(unsigned char *)(v6 + 16)) {
        v4 |= (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 8) + 32))(*(void *)(v6 + 8), a2);
      }
      v6 += 24;
    }
  }
  else
  {
    uint64_t v8 = a1[8];
    LOBYTE(v4) = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315394;
      uint64_t v11 = "hasDataAssertions";
      __int16 v12 = 2080;
      uint64_t v13 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", (uint8_t *)&v10, 0x16u);
      LOBYTE(v4) = 0;
    }
  }
  return v4 & 1;
}

uint64_t sub_100D87E20(uint64_t a1, uint64_t a2)
{
  return sub_100D87CB8((void *)(a1 - 24), a2);
}

uint64_t sub_100D87E28(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 16))();
  }
  else {
    return 4294967293;
  }
}

uint64_t sub_100D87E5C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t sub_100D87E64(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 112)) {
    return 0;
  }
  uint64_t v4 = 0;
  char v5 = 0;
  uint64_t v6 = (void *)(a1 + 32);
  do
  {
    uint64_t v7 = dword_1015716C8[v4];
    if (v7 == a2 || anyContextType())
    {
      if (v5)
      {
        char v5 = 1;
      }
      else
      {
        uint64_t v8 = *(void *)(a1 + 112);
        sub_10003E168(&v11, v6);
        if (v11) {
          uint64_t v9 = v11 + 24;
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v13 = v9;
        int v14 = v12;
        uint64_t v11 = 0;
        __int16 v12 = 0;
        char v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v8 + 64))(v8, v7, &v13);
        if (v14) {
          sub_10004D2C8(v14);
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
    }
    ++v4;
  }
  while (v4 != 2);
  return v5 & 1;
}

void sub_100D87F74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D87F98(uint64_t a1, int a2)
{
  return sub_100D87E64(a1 - 24, a2);
}

uint64_t sub_100D87FA0(uint64_t a1, int a2, uint64_t a3)
{
  if (*(void *)(a1 + 112))
  {
    uint64_t v6 = (void *)(a1 + 32);
    uint64_t v7 = dword_1015716C8;
    do
    {
      int v8 = *v7;
      if ((anyContextType() & 1) != 0 || v8 == a2)
      {
        uint64_t v9 = a1 + 24 * v8;
        uint64_t v11 = *(void *)(v9 + 120);
        uint64_t v10 = *(void *)(v9 + 128);
        while (v11 != v10)
        {
          if (*(void *)(v11 + 8) == a3 && *(unsigned char *)(v11 + 16) != 0)
          {
            uint64_t v13 = *(void *)(a1 + 112);
            sub_10003E168(&v17, v6);
            if (v17) {
              uint64_t v14 = v17 + 24;
            }
            else {
              uint64_t v14 = 0;
            }
            uint64_t v19 = v14;
            uint64_t v20 = v18;
            uint64_t v17 = 0;
            uint64_t v18 = 0;
            char v15 = (*(uint64_t (**)(uint64_t, void, uint64_t *))(*(void *)v13 + 72))(v13, v8, &v19);
            if (v20) {
              sub_10004D2C8(v20);
            }
            if (v18) {
              sub_10004D2C8(v18);
            }
            if (v15) {
              return 1;
            }
          }
          v11 += 24;
        }
      }
      ++v7;
    }
    while (v7 != &dword_1015716D0);
  }
  return 0;
}

void sub_100D880EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D88110(uint64_t a1, int a2, uint64_t a3)
{
  return sub_100D87FA0(a1 - 24, a2, a3);
}

uint64_t sub_100D88118(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 112))
  {
    uint64_t v4 = (void *)(a1 + 32);
    char v5 = dword_1015716C8;
    while (2)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = a1 + 24 * (int)v6;
      uint64_t v8 = *(void *)(v7 + 120);
      uint64_t v9 = *(void *)(v7 + 128);
      while (v8 != v9)
      {
        if (*(void *)(v8 + 8) == a2 && *(unsigned char *)(v8 + 16) != 0)
        {
          uint64_t v11 = *(void *)(a1 + 112);
          sub_10003E168(&v17, v4);
          if (v17) {
            uint64_t v12 = v17 + 24;
          }
          else {
            uint64_t v12 = 0;
          }
          uint64_t v19 = v12;
          uint64_t v20 = v18;
          uint64_t v17 = 0;
          uint64_t v18 = 0;
          char v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v11 + 72))(v11, v6, &v19);
          if (v20) {
            sub_10004D2C8(v20);
          }
          if (v18) {
            sub_10004D2C8(v18);
          }
          if (v13) {
            return 1;
          }
          uint64_t v14 = otherContextType();
          if (sub_100D86A8C(a1, v14, a2, 1))
          {
            uint64_t v15 = *(void *)(a1 + 112);
            if (v15)
            {
              if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 312))(v15, v6)) {
                return 1;
              }
            }
          }
        }
        v8 += 24;
      }
      if (++v5 != &dword_1015716D0) {
        continue;
      }
      break;
    }
  }
  return 0;
}

void sub_100D882A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D882C4(uint64_t a1, uint64_t a2)
{
  return sub_100D88118(a1 - 24, a2);
}

double sub_100D882CC@<D0>(PersonalitySpecificImpl *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = (char *)a1 + (int)a2;
  if (v7[348])
  {
    uint64_t v8 = *((void *)a1 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asString();
      int v11 = v7[348];
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "canActivateDataSettings";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      __int16 v36 = 1024;
      int v37 = v11;
      __int16 v38 = 2080;
      uint64_t v39 = asString();
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: ActivationBlocker for %s: fFatalActivationBlocker=%d, cause=%s", buf, 0x26u);
    }
    *(_DWORD *)a4 = 63;
    *(void *)(a4 + 8) = "FatalActivationBlocker";
    *(void *)(a4 + 16) = &unk_10165244B;
    goto LABEL_14;
  }
  if (((*(uint64_t (**)(PersonalitySpecificImpl *, uint64_t))(*(void *)a1 + 1160))(a1, a2) & 1) == 0)
  {
    *(_DWORD *)a4 = -3;
    *(void *)(a4 + 8) = "ActivationStatus failed in DataSettings";
    *(void *)(a4 + 16) = &unk_10165244B;
LABEL_14:
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(_DWORD *)(a4 + 32) = a2;
    *(void *)(a4 + 44) = 0;
    *(void *)(a4 + 36) = 0;
    *(_DWORD *)(a4 + 52) = 0;
    return result;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *((Registry **)a1 + 9));
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (!v20)
  {
    uint64_t v22 = 0;
LABEL_17:
    std::mutex::unlock(v15);
    uint64_t v21 = 0;
    char v23 = 1;
    if (!v22) {
      goto LABEL_35;
    }
    goto LABEL_18;
  }
  uint64_t v22 = v20[3];
  uint64_t v21 = (std::__shared_weak_count *)v20[4];
  if (!v21) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v15);
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  char v23 = 0;
  if (!v22) {
    goto LABEL_35;
  }
LABEL_18:
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  uint64_t v24 = PersonalitySpecificImpl::simSlot(a1);
  sub_10003E168(buf, (void *)a1 + 4);
  if (*(void *)buf) {
    uint64_t v25 = *(void *)buf + 24;
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v33 = v25;
  uint64_t v34 = *(std::__shared_weak_count **)&buf[8];
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  std::string __p = 0;
  sub_1008DB9AC(&__p, *(const void **)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
  uint64_t v26 = *((void *)a1 + 14);
  if (v26) {
    uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 16))(v26);
  }
  else {
    uint64_t v27 = 4294967293;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, void **, uint64_t))(*(void *)v22 + 1040))(v22, a2, v24, &v33, &__p, v27);
  if (__p)
  {
    uint64_t v31 = __p;
    operator delete(__p);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!*(_DWORD *)a4)
  {
    uint64_t v29 = *(std::__shared_weak_count **)(a4 + 48);
    if (v29) {
      sub_10004D2C8(v29);
    }
LABEL_35:
    int v28 = 1;
    if (v23) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  int v28 = 0;
  if ((v23 & 1) == 0) {
LABEL_36:
  }
    sub_10004D2C8(v21);
LABEL_37:
  if (v28)
  {
    double result = 0.0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(void *)(a4 + 8) = &unk_10165244B;
    *(void *)(a4 + 16) = &unk_10165244B;
    *(void *)(a4 + 44) = 0;
    *(void *)(a4 + 36) = 0;
    *(_DWORD *)(a4 + 52) = 0;
    *(_DWORD *)(a4 + 32) = a2;
  }
  return result;
}

void sub_100D88680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

double sub_100D886E4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return sub_100D882CC((PersonalitySpecificImpl *)(a1 - 24), a2, a3, a4);
}

double sub_100D886EC@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1[14];
  if (v9) {
    goto LABEL_16;
  }
  uint64_t v11 = (*(unsigned __int8 (**)(void *, void, uint64_t, void))(*a1 + 136))(a1, 0, 1, 0);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v12, (Registry *)a1[9]);
  uint64_t v14 = ServiceMap;
  if ((v15 & 0x8000000000000000) != 0)
  {
    uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v15;
  unsigned int v19 = sub_10004D37C(&v14[1].__m_.__sig, &v26);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_10:
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }
  uint64_t v21 = v19[3];
  uint64_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (!v21)
  {
LABEL_8:
    uint64_t v9 = 0;
    goto LABEL_13;
  }
LABEL_11:
  uint64_t v23 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 224))(a1, a3);
  (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v30, a1);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)v21 + 1048))(v21, v23, a4, &v30, v11 & 1);
  if (v31) {
    sub_10004D2C8(v31);
  }
LABEL_13:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if (!v9)
  {
    double result = 0.0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(void *)(a5 + 8) = &unk_10165244B;
    *(void *)(a5 + 16) = &unk_10165244B;
    *(void *)(a5 + 44) = 0;
    *(void *)(a5 + 36) = 0;
    *(_DWORD *)(a5 + 52) = 0;
    *(_DWORD *)(a5 + 32) = a2;
    return result;
  }
LABEL_16:
  sub_10003E168(&v26, a1 + 4);
  if (v26) {
    uint64_t v24 = v26 + 24;
  }
  else {
    uint64_t v24 = 0;
  }
  uint64_t v28 = v24;
  uint64_t v29 = v27;
  unint64_t v26 = 0;
  uint64_t v27 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)v9 + 32))(v9, a2, &v28, a3);
  if (v29) {
    sub_10004D2C8(v29);
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
  return result;
}

void sub_100D88984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

double sub_100D889D0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return sub_100D886EC((void *)(a1 - 24), a2, a3, a4, a5);
}

uint64_t sub_100D889D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 112);
  if (!v3) {
    return 0x1FFFFFFFFLL;
  }
  sub_10003E168(&v9, (void *)(a1 + 32));
  if (v9) {
    uint64_t v6 = v9 + 24;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  uint64_t v12 = v10;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)v3 + 24))(v3, a2, &v11, a3);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  return v7;
}

void sub_100D88AA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100D88AC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100D889D8(a1 - 24, a2, a3);
}

void sub_100D88AE4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2)
  {
    sub_10003E168(&v5, (void *)(a1 + 32));
    if (v5) {
      uint64_t v4 = v5 + 24;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v7 = v4;
    uint64_t v8 = v6;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v2 + 56))(v2, &v7, a2);
    if (v8) {
      sub_10004D2C8(v8);
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_100D88B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D88BA4(uint64_t a1, uint64_t a2)
{
}

void sub_100D88BAC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[8];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "postDataSettingsGrabRejected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v25 = -9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: ct=%s, errCode=%d", buf, 0x1Cu);
  }
  if (validContextType())
  {
    (*(void (**)(void *, uint64_t, void))(*a1 + 1208))(a1, a2, 0);
    uint64_t v5 = otherContextType();
    memset(buf, 0, sizeof(buf));
    sub_100DA1880(buf, (const void *)a1[3 * (int)a2 + 15], a1[3 * (int)a2 + 16], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[3 * (int)a2 + 16] - a1[3 * (int)a2 + 15]) >> 3));
    uint64_t v6 = a1[14];
    if (v6 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 312))(v6, v5) & 1) != 0)
    {
      uint64_t v7 = a1[8];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v23) = 136315138;
        *(void *)((char *)&v23 + 4) = "postDataSettingsGrabRejected";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: In handover: switch observers to the remaining context", (uint8_t *)&v23, 0xCu);
      }
      uint64_t v9 = *(void *)buf;
      uint64_t v8 = *(void *)&buf[8];
      if (*(void *)buf == *(void *)&buf[8]) {
        goto LABEL_37;
      }
      do
      {
        if (*(unsigned char *)(v9 + 16)) {
          sub_100D862A8((uint64_t)a1, v5, *(const DataAPNSettingsObserver **)(v9 + 8), 1);
        }
        v9 += 24;
      }
      while (v9 != v8);
    }
    else
    {
      uint64_t v12 = a1[8];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v23) = 136315138;
        *(void *)((char *)&v23 + 4) = "postDataSettingsGrabRejected";
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Not in handover:", (uint8_t *)&v23, 0xCu);
      }
      (*(void (**)(void *, uint64_t, uint64_t, void))(*a1 + 856))(a1, a2, 4294967287, 0);
      uint64_t v9 = *(void *)buf;
      uint64_t v13 = *(void *)&buf[8];
      if (*(void *)buf == *(void *)&buf[8]) {
        goto LABEL_37;
      }
      do
      {
        if (*(unsigned char *)(v9 + 16))
        {
          uint64_t v14 = *(void *)(v9 + 8);
          sub_10003E168(&v23, a1 + 4);
          if ((void)v23) {
            uint64_t v15 = v23 + 24;
          }
          else {
            uint64_t v15 = 0;
          }
          uint64_t v21 = v15;
          char v22 = (std::__shared_weak_count *)*((void *)&v23 + 1);
          long long v23 = 0uLL;
          (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, void, void))(*(void *)v14 + 56))(v14, a2, &v21, 4294967287, 0, 0);
          if (v22) {
            sub_10004D2C8(v22);
          }
          if (*((void *)&v23 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v23 + 1));
          }
          uint64_t v16 = *(void *)(v9 + 8);
          sub_10003E168(&v23, a1 + 4);
          if ((void)v23) {
            uint64_t v17 = v23 + 24;
          }
          else {
            uint64_t v17 = 0;
          }
          uint64_t v19 = v17;
          uint64_t v20 = (std::__shared_weak_count *)*((void *)&v23 + 1);
          long long v23 = 0uLL;
          int v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v16 + 64))(v16, a2, &v19);
          if (v20) {
            sub_10004D2C8(v20);
          }
          if (*((void *)&v23 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v23 + 1));
          }
          if (v18) {
            sub_100D862A8((uint64_t)a1, a2, *(const DataAPNSettingsObserver **)(v9 + 8), 0);
          }
        }
        v9 += 24;
      }
      while (v9 != v13);
    }
    uint64_t v9 = *(void *)buf;
LABEL_37:
    if (v9)
    {
      *(void *)&uint8_t buf[8] = v9;
      operator delete((void *)v9);
    }
    return;
  }
  uint64_t v10 = a1[8];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "postDataSettingsGrabRejected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E %s: wrong context type: %s", buf, 0x16u);
  }
}

void sub_100D89000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100D89064(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 264) + 144) == 4;
}

void sub_100D89078(void *a1, const DataAPNSettingsObserver *a2, long long *a3, uint64_t a4)
{
  if (a2)
  {
    uint64_t v6 = 0;
    for (uint64_t i = dword_1015716C8; i != &dword_1015716D0; ++i)
    {
      uint64_t v8 = *i;
      uint64_t v53 = 0;
      uint64_t v54 = 0;
      uint64_t v55 = 0;
      sub_100DA1880(&v53, (const void *)a1[3 * (int)v8 + 15], a1[3 * (int)v8 + 16], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[3 * (int)v8 + 16] - a1[3 * (int)v8 + 15]) >> 3));
      uint64_t v9 = v53;
      uint64_t v10 = v54;
      if (v53 == v54)
      {
        char v13 = 1;
        if (v53) {
          goto LABEL_14;
        }
      }
      else
      {
        while (1)
        {
          uint64_t v11 = v9[1];
          if (v11 != a2)
          {
            (*(void (**)(const DataAPNSettingsObserver *))(*(void *)v11 + 272))(v11);
            if ((v12 & 0x100) != 0) {
              break;
            }
          }
          v9 += 3;
          if (v9 == v10)
          {
            char v13 = 1;
            uint64_t v8 = v6;
            goto LABEL_13;
          }
        }
        uint64_t v14 = a1[8];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = asString(a2);
          uint64_t v16 = asString(v9[1]);
          *(_DWORD *)std::string buf = 136315650;
          uint64_t v57 = "observerFits";
          __int16 v58 = 2080;
          uint64_t v59 = v15;
          __int16 v60 = 2080;
          uint64_t v61 = v16;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Connection %s does not fit Settings that have an exclusive connection %s", buf, 0x20u);
        }
        char v13 = 0;
LABEL_13:
        uint64_t v9 = v53;
        uint64_t v6 = v8;
        if (v53)
        {
LABEL_14:
          uint64_t v54 = v9;
          operator delete(v9);
        }
      }
      if ((v13 & 1) == 0)
      {
        sub_100D897F0(a1, a2, v6, 0xFFFFFFF7FFFFFFFFLL, 0);
        return;
      }
    }
  }
  uint64_t v17 = a1[14];
  if (v17 && (*(unsigned int (**)(uint64_t))(*(void *)v17 + 336))(v17))
  {
    int v18 = a1[8];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v57 = "activateDataSettings";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s: we are in the middle of a retry scheduled activation, drop that activation in favor of this newer one", buf, 0xCu);
    }
    (*(void (**)(void, void))(*(void *)a1[14] + 344))(a1[14], 0);
  }
  uint64_t v19 = sub_100D89AB4((uint64_t)a1, (uint64_t)a2, 0);
  uint64_t v20 = 0;
  while (1)
  {
    uint64_t v21 = dword_1015716C8[v20];
    if (sub_100D86A8C((uint64_t)a1, v21, (uint64_t)a2, 1) && sub_100D86BE4((uint64_t)a1, v21, a2)) {
      break;
    }
    if (++v20 == 2) {
      goto LABEL_33;
    }
  }
  LODWORD(v53) = v21;
  char v22 = a1[8];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = asString();
    uint64_t v24 = asString();
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v57 = "activateDataSettings";
    __int16 v58 = 2080;
    uint64_t v59 = v23;
    __int16 v60 = 2080;
    uint64_t v61 = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: Already activating on %s; choosing that context type when the preferred context type is %s",
      buf,
      0x20u);
  }
  if (v21 == 2)
  {
LABEL_33:
    LODWORD(v53) = v19;
    uint64_t v21 = v19;
  }
  BOOL v25 = v21 <= 1 && sub_100D86A8C((uint64_t)a1, v21, (uint64_t)a2, 1);
  unint64_t v26 = a1[8];
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)a3 + 24)) {
      uint64_t v27 = "handOver ";
    }
    else {
      uint64_t v27 = (const char *)&unk_10165244B;
    }
    uint64_t v28 = asString();
    uint64_t v29 = asStringBool(v25);
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v57 = "activateDataSettings";
    __int16 v58 = 2080;
    uint64_t v59 = (uint64_t)v27;
    __int16 v60 = 2080;
    uint64_t v61 = v28;
    __int16 v62 = 2080;
    uint64_t v63 = v29;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: initially requested %s, for ct=%s, char valid = %s", buf, 0x2Au);
  }
  if (v25 && (sub_100D862A8((uint64_t)a1, v21, a2, 1), sub_100D86BE4((uint64_t)a1, v21, a2)))
  {
    uint64_t v30 = a1[8];
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(const DataAPNSettingsObserver *))(*(void *)a2 + 200))(a2);
      uint64_t v31 = asString();
      uint64_t v32 = *((void *)a3 + 1);
      uint64_t v33 = asString();
      *(_DWORD *)std::string buf = 136315650;
      uint64_t v57 = (const char *)v31;
      __int16 v58 = 2080;
      uint64_t v59 = v32;
      __int16 v60 = 2080;
      uint64_t v61 = v33;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I activate service: %s, reason: %s, context type %s", buf, 0x20u);
    }
    uint64_t v34 = a3;
    long long v35 = a3[1];
    long long v48 = *a3;
    v49[0] = v35;
    *(_OWORD *)((char *)v49 + 1sub_100732068((uint64_t)&a9, 0) = *(long long *)((char *)a3 + 26);
    if (*((char *)a3 + 71) < 0)
    {
      sub_10004FC84(&v50, *((void **)a3 + 6), *((void *)a3 + 7));
      uint64_t v34 = a3;
    }
    else
    {
      long long v50 = a3[3];
      uint64_t v51 = *((void *)a3 + 8);
    }
    char v52 = *((unsigned char *)v34 + 72);
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    std::string __p = 0;
    sub_1008DB9AC(&__p, *(const void **)a4, *(void *)(a4 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2));
    unint64_t v36 = sub_100D8B390((uint64_t)a1, (uint64_t)a2, (int *)&v53, 1, (uint64_t)&v48, (uint64_t)&__p);
    unsigned int v38 = v37;
    if (__p)
    {
      uint64_t v46 = __p;
      operator delete(__p);
    }
    if (SHIBYTE(v51) < 0) {
      operator delete((void *)v50);
    }
    uint64_t v39 = a1[8];
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(const DataAPNSettingsObserver *))(*(void *)a2 + 200))(a2);
      uint64_t v40 = asString();
      int v41 = (int)v53;
      uint64_t v42 = asString();
      *(_DWORD *)std::string buf = 136315650;
      uint64_t v57 = (const char *)v40;
      __int16 v58 = 2080;
      uint64_t v59 = v42;
      __int16 v60 = 1024;
      LODWORD(v61) = v36;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I activate service: %s, ct %s, result %d", buf, 0x1Cu);
    }
    else
    {
      int v41 = (int)v53;
    }
    sub_100D897F0(a1, a2, v41, v36, v38);
  }
  else
  {
    sub_100D897F0(a1, a2, v21, 0xFFFFFFF7FFFFFFFFLL, 0);
  }
}

void sub_100D8979C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100D897F0(void *a1, const DataAPNSettingsObserver *a2, int a3, uint64_t a4, unsigned int a5)
{
  uint64_t v11 = a1[8];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = asString();
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = "handleDataActivateResult_Sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v5;
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v23 = a4;
    __int16 v24 = 2080;
    uint64_t v25 = asStringBool(a2 != 0);
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: (impl): cct=%s, result=%d, observer=%s", buf, 0x26u);
  }
  __int16 v12 = dword_1015716C8;
  do
  {
    int v13 = *v12;
    char valid = validContextType();
    if (v13 == a3) {
      char v15 = 0;
    }
    else {
      char v15 = valid;
    }
    if ((v15 & 1) == 0)
    {
      uint64_t v16 = v13;
      memset(buf, 0, sizeof(buf));
      sub_100DA1880(buf, (const void *)a1[3 * v13 + 15], a1[3 * v13 + 16], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[3 * v13 + 16] - a1[3 * v13 + 15]) >> 3));
      uint64_t v18 = *(void *)buf;
      uint64_t v17 = *(void *)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        do
        {
          if (*(const DataAPNSettingsObserver **)(v18 + 8) == a2)
          {
            uint64_t v19 = a2;
            if (!*(unsigned char *)(v18 + 16))
            {
              sub_100D862A8((uint64_t)a1, v16, a2, 1);
              uint64_t v19 = *(const DataAPNSettingsObserver **)(v18 + 8);
            }
            unint64_t v5 = v5 & 0xFFFFFFFF00000000 | a5;
            (*(void (**)(const DataAPNSettingsObserver *, uint64_t, unint64_t))(*(void *)v19 + 112))(v19, a4, v5);
          }
          v18 += 24;
        }
        while (v18 != v17);
        uint64_t v18 = *(void *)buf;
      }
      if (v18)
      {
        *(void *)&uint8_t buf[8] = v18;
        operator delete((void *)v18);
      }
      if (a4 > 0xFFFFFFFD)
      {
        uint64_t v20 = a1[8];
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = asString();
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "handleDataActivationError_Sync";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: ct=%s", buf, 0x16u);
        }
        sub_100D862A8((uint64_t)a1, v16, a2, 0);
        sub_100D9EB8C(a1, (uint64_t)a2, v16);
      }
    }
    ++v12;
  }
  while (v12 != &dword_1015716D0);
}

void sub_100D89A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
}

uint64_t sub_100D89AB4(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  char v183 = 0;
  v181 = 0;
  uint64_t v182 = 0;
  v180 = (uint64_t *)&v181;
  uint64_t v6 = dword_1015716C8;
  do
  {
    *(_DWORD *)std::string buf = *v6;
    if (sub_100D86A8C(a1, *(unsigned int *)buf, a2, 1))
    {
      uint64_t v7 = a1 + 24 * *(int *)buf;
      uint64_t v8 = *(void *)(v7 + 120);
      uint64_t v9 = *(void *)(v7 + 128);
      while (v8 != v9)
      {
        if (*(void *)(v8 + 8) == a2) {
          sub_10078C71C(&v180, (int *)buf, buf);
        }
        v8 += 24;
      }
    }
    ++v6;
  }
  while (v6 != &dword_1015716D0);
  if (a3) {
    *a3 = 0;
  }
  v169 = a3;
  uint64_t v10 = 0;
  uint64_t v11 = 2;
  do
  {
    if (*(void *)(a1 + 24 * dword_1015716C8[v10] + 128) == *(void *)(a1 + 24 * dword_1015716C8[v10] + 120))
    {
      uint64_t v12 = otherContextType();
      if (*(void *)(a1 + 24 * (int)v12 + 128) != *(void *)(a1 + 24 * (int)v12 + 120))
      {
        int v13 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asString();
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "getPreferredContextType";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: This settings can be activated only on %s", buf, 0x16u);
        }
        uint64_t v11 = v12;
      }
    }
    ++v10;
  }
  while (v10 != 2);
  uint64_t v15 = v11;
  uint64_t v16 = v169;
  if (validContextType())
  {
    BOOL v17 = 0;
    goto LABEL_26;
  }
  uint64_t v18 = sub_100D8FA04(a1, a2, &v183);
  if (v183)
  {
    uint64_t v19 = v18;
    if (v169) {
      unsigned char *v169 = 1;
    }
    uint64_t v20 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: Forced on %s", buf, 0x16u);
    }
    BOOL v17 = 0;
    uint64_t v15 = v19;
    goto LABEL_26;
  }
  if (!a2)
  {
    BOOL v164 = 1;
    goto LABEL_160;
  }
  int v179 = 0;
  uint64_t v178 = 0;
  uint64_t v178 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 272))(a2);
  int v179 = v29;
  v202 = 0;
  long long v201 = 0u;
  memset(v200, 0, sizeof(v200));
  sub_100DA1950((uint64_t)__p, &v178);
  sub_100D882CC((PersonalitySpecificImpl *)a1, 0, (uint64_t)__p, (uint64_t)v200);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v176 = 0;
  *(_OWORD *)v174 = 0u;
  long long v175 = 0u;
  long long v173 = 0u;
  sub_100DA1950((uint64_t)v172, &v178);
  sub_100D882CC((PersonalitySpecificImpl *)a1, 1, (uint64_t)v172, (uint64_t)&v173);
  if (v172[0])
  {
    v172[1] = v172[0];
    operator delete(v172[0]);
  }
  BOOL v164 = *(_DWORD *)v200 == 0;
  if (!*(_DWORD *)v200)
  {
    if (!v173) {
      goto LABEL_156;
    }
    uint64_t v49 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s: cannot activate on IWLAN", buf, 0xCu);
      uint64_t v49 = *(NSObject **)(a1 + 64);
    }
    BOOL v50 = v174[12];
    BOOL v51 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
    if (v50)
    {
      if (v51)
      {
        uint64_t v166 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (v173) {
          char v52 = "f";
        }
        else {
          char v52 = "t";
        }
        if (v173) {
          uint64_t v53 = (const char *)asString();
        }
        else {
          uint64_t v53 = "OK";
        }
        uint64_t v86 = *((void *)&v173 + 1);
        uint64_t v87 = *(void *)v174;
        uint64_t v88 = asStringBool(v174[8]);
        uint64_t v89 = asStringBool(v174[9]);
        uint64_t v90 = asStringBool(v174[10]);
        uint64_t v91 = asStringBool(v174[11]);
        *(_DWORD *)std::string buf = 136317442;
        *(void *)&uint8_t buf[4] = v166;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "getPreferredContextType";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v185 = (uint64_t)v52;
        __int16 v186 = 2080;
        uint64_t v187 = (uint64_t)v53;
        __int16 v188 = 2080;
        uint64_t v189 = v86;
        __int16 v190 = 2080;
        uint64_t v191 = v87;
        __int16 v192 = 2080;
        uint64_t v193 = v88;
        __int16 v194 = 2080;
        uint64_t v195 = v89;
        __int16 v196 = 2080;
        uint64_t v197 = v90;
        __int16 v198 = 2080;
        uint64_t v199 = v91;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x66u);
        uint64_t v15 = 0;
        goto LABEL_139;
      }
LABEL_155:
      uint64_t v15 = 0;
      goto LABEL_156;
    }
    if (!v51) {
      goto LABEL_155;
    }
    uint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if (v173) {
      __int16 v58 = "f";
    }
    else {
      __int16 v58 = "t";
    }
    if (v173) {
      uint64_t v59 = (const char *)asString();
    }
    else {
      uint64_t v59 = "OK";
    }
    if (*((void *)&v173 + 1))
    {
      uint64_t v95 = *(void *)v174;
      if (**((unsigned char **)&v173 + 1))
      {
        uint64_t v96 = "}";
        uint64_t v97 = "{";
LABEL_154:
        *(_DWORD *)std::string buf = 136316930;
        *(void *)&uint8_t buf[4] = v57;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "getPreferredContextType";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v185 = (uint64_t)v58;
        __int16 v186 = 2080;
        uint64_t v187 = (uint64_t)v59;
        __int16 v188 = 2080;
        uint64_t v189 = (uint64_t)v97;
        __int16 v190 = 2080;
        uint64_t v191 = *((void *)&v173 + 1);
        __int16 v192 = 2080;
        uint64_t v193 = v95;
        __int16 v194 = 2080;
        uint64_t v195 = (uint64_t)v96;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: %s(%s%s%s %s%s)", buf, 0x52u);
        goto LABEL_155;
      }
    }
    else
    {
      uint64_t v95 = *(void *)v174;
    }
    uint64_t v97 = (const char *)&unk_10165244B;
    uint64_t v96 = (const char *)&unk_10165244B;
    goto LABEL_154;
  }
  if (!v173)
  {
    uint64_t v30 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s: cannot activate on BB", buf, 0xCu);
      uint64_t v30 = *(NSObject **)(a1 + 64);
    }
    int v31 = v200[28];
    BOOL v32 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    if (v31)
    {
      if (v32)
      {
        uint64_t v165 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (*(_DWORD *)v200) {
          uint64_t v33 = "f";
        }
        else {
          uint64_t v33 = "t";
        }
        if (*(_DWORD *)v200) {
          uint64_t v34 = (const char *)asString();
        }
        else {
          uint64_t v34 = "OK";
        }
        uint64_t v80 = *(void *)&v200[8];
        uint64_t v81 = *(void *)&v200[16];
        uint64_t v82 = asStringBool(v200[24]);
        uint64_t v83 = asStringBool(v200[25]);
        uint64_t v84 = asStringBool(v200[26]);
        uint64_t v85 = asStringBool(v200[27]);
        *(_DWORD *)std::string buf = 136317442;
        *(void *)&uint8_t buf[4] = v165;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "getPreferredContextType";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v185 = (uint64_t)v33;
        __int16 v186 = 2080;
        uint64_t v187 = (uint64_t)v34;
        __int16 v188 = 2080;
        uint64_t v189 = v80;
        __int16 v190 = 2080;
        uint64_t v191 = v81;
        __int16 v192 = 2080;
        uint64_t v193 = v82;
        __int16 v194 = 2080;
        uint64_t v195 = v83;
        __int16 v196 = 2080;
        uint64_t v197 = v84;
        __int16 v198 = 2080;
        uint64_t v199 = v85;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})", buf, 0x66u);
        uint64_t v15 = 1;
LABEL_139:
        uint64_t v16 = v169;
        goto LABEL_156;
      }
LABEL_151:
      uint64_t v15 = 1;
      goto LABEL_156;
    }
    if (!v32) {
      goto LABEL_151;
    }
    uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if (*(_DWORD *)v200) {
      uint64_t v55 = "f";
    }
    else {
      uint64_t v55 = "t";
    }
    if (*(_DWORD *)v200) {
      uint64_t v56 = (const char *)asString();
    }
    else {
      uint64_t v56 = "OK";
    }
    if (*(void *)&v200[8])
    {
      uint64_t v92 = *(void *)&v200[16];
      if (**(unsigned char **)&v200[8])
      {
        uint64_t v93 = "}";
        uint64_t v94 = "{";
LABEL_150:
        *(_DWORD *)std::string buf = 136316930;
        *(void *)&uint8_t buf[4] = v54;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "getPreferredContextType";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v185 = (uint64_t)v55;
        __int16 v186 = 2080;
        uint64_t v187 = (uint64_t)v56;
        __int16 v188 = 2080;
        uint64_t v189 = (uint64_t)v94;
        __int16 v190 = 2080;
        uint64_t v191 = *(void *)&v200[8];
        __int16 v192 = 2080;
        uint64_t v193 = v92;
        __int16 v194 = 2080;
        uint64_t v195 = (uint64_t)v93;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA.%s: %s: %s(%s%s%s %s%s)", buf, 0x52u);
        goto LABEL_151;
      }
    }
    else
    {
      uint64_t v92 = *(void *)&v200[16];
    }
    uint64_t v94 = (const char *)&unk_10165244B;
    uint64_t v93 = (const char *)&unk_10165244B;
    goto LABEL_150;
  }
LABEL_156:
  if (v176) {
    sub_10004D2C8(v176);
  }
  if (v202) {
    sub_10004D2C8(v202);
  }
LABEL_160:
  if (validContextType())
  {
LABEL_169:
    BOOL v17 = 0;
    LODWORD(v106) = 0;
    goto LABEL_229;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v98, *(Registry **)(a1 + 72));
  uint64_t v100 = ServiceMap;
  if (v101 < 0)
  {
    xpc_object_t v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v103 = 5381;
    do
    {
      uint64_t v101 = v103;
      unsigned int v104 = *v102++;
      uint64_t v103 = (33 * v103) ^ v104;
    }
    while (v104);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v101;
  uint64_t v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)buf);
  if (!v105)
  {
    std::mutex::unlock(v100);
    goto LABEL_169;
  }
  uint64_t v106 = v105[3];
  int v107 = (std::__shared_weak_count *)v105[4];
  if (v107)
  {
    atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v100);
    atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v107);
    if (!v106)
    {
      BOOL v17 = 0;
LABEL_228:
      sub_10004D2C8(v107);
      goto LABEL_229;
    }
LABEL_171:
    long long v173 = 0uLL;
    uint64_t v162 = v106;
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v106 + 432))(&v173, v106);
    unsigned int v163 = v15;
    if ((void)v173)
    {
      v161 = v107;
      memset(buf, 0, sizeof(buf));
      uint64_t v108 = dword_1015716C8;
      do
      {
        uint64_t v109 = a1 + 24 * *v108;
        uint64_t v110 = *(void *)(v109 + 120);
        uint64_t v111 = *(void *)(v109 + 128);
        while (v110 != v111)
        {
          if (a2 && *(void *)(v110 + 8) == a2 || sub_100D8FD3C(a1, v110))
          {
            uint64_t v112 = *(_OWORD **)&buf[8];
            if (*(void *)&buf[8] >= *(void *)&buf[16])
            {
              unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
              unint64_t v116 = v115 + 1;
              if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_100DA1868();
              }
              if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v116) {
                unint64_t v116 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                unint64_t v117 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v117 = v116;
              }
              if (v117) {
                xpc_object_t v118 = (char *)sub_10004812C((uint64_t)&buf[16], v117);
              }
              else {
                xpc_object_t v118 = 0;
              }
              uint64_t v119 = &v118[24 * v115];
              long long v120 = *(_OWORD *)v110;
              *((void *)v119 + 2) = *(void *)(v110 + 16);
              *(_OWORD *)uint64_t v119 = v120;
              xpc_object_t v122 = *(char **)buf;
              xpc_object_t v121 = *(char **)&buf[8];
              uint64_t v123 = v119;
              if (*(void *)&buf[8] != *(void *)buf)
              {
                do
                {
                  long long v124 = *(_OWORD *)(v121 - 24);
                  *(v123 - 8) = *(v121 - 8);
                  *(_OWORD *)(v123 - 24) = v124;
                  v123 -= 24;
                  v121 -= 24;
                }
                while (v121 != v122);
                xpc_object_t v121 = *(char **)buf;
              }
              xpc_object_t v114 = v119 + 24;
              *(void *)std::string buf = v123;
              *(void *)&uint8_t buf[8] = v119 + 24;
              *(void *)&uint8_t buf[16] = &v118[24 * v117];
              if (v121) {
                operator delete(v121);
              }
            }
            else
            {
              long long v113 = *(_OWORD *)v110;
              *(void *)(*(void *)&buf[8] + 16) = *(void *)(v110 + 16);
              *uint64_t v112 = v113;
              xpc_object_t v114 = (char *)v112 + 24;
            }
            *(void *)&uint8_t buf[8] = v114;
          }
          v110 += 24;
        }
        ++v108;
      }
      while (v108 != &dword_1015716D0);
      uint64_t v126 = *(void ***)buf;
      xpc_object_t v125 = *(void ***)&buf[8];
      if (*(void *)buf == *(void *)&buf[8])
      {
        char v138 = 0;
        int v128 = 0;
      }
      else
      {
        char v127 = 0;
        int v168 = 0;
        LOBYTE(v128) = 0;
        LODWORD(v129) = 3;
        do
        {
          int v130 = (*(uint64_t (**)(void *))(*v126[1] + 200))(v126[1]);
          if ((_BYTE)v128) {
            int v128 = 1;
          }
          else {
            int v128 = (*(uint64_t (**)(void *))(*v126[1] + 136))(v126[1]);
          }
          if (*(_DWORD *)v126 == 1)
          {
            uint64_t v131 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
            uint64_t v132 = ConnectionTypeToMask();
            int v133 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v162 + 1080))(v162, 1, v131, v132);
            int v134 = v168;
            if (!v133) {
              int v134 = v130;
            }
            int v168 = v134;
            if (!v133) {
              char v127 = 1;
            }
          }
          int AppType = DataiRatControllerInterface::getAppType();
          if ((int)v129 < AppType || v129 == 3) {
            unsigned int v137 = AppType;
          }
          else {
            unsigned int v137 = v129;
          }
          if (AppType == 3) {
            uint64_t v129 = v129;
          }
          else {
            uint64_t v129 = v137;
          }
          v126 += 3;
        }
        while (v126 != v125);
        char v138 = v127;
        int v107 = v161;
        if (v129 < 3)
        {
          uint64_t v139 = v173;
          uint64_t v140 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
          unsigned int v163 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v139 + 88))(v139, v140, v129);
          char v141 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v142 = asString();
            *(_DWORD *)v200 = 136315394;
            *(void *)&v200[4] = "getPreferredContextType";
            *(_WORD *)&v200[12] = 2080;
            *(void *)&v200[14] = v142;
            _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "#I %s: iRAT recommends %s", v200, 0x16u);
          }
        }
        uint64_t v126 = *(void ***)buf;
      }
      uint64_t v16 = v169;
      if (v126)
      {
        *(void *)&uint8_t buf[8] = v126;
        operator delete(v126);
      }
    }
    else
    {
      int v128 = 0;
      char v138 = 0;
    }
    if (*((void *)&v173 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v173 + 1));
    }
    BOOL v17 = v128 != 0;
    LODWORD(v106) = v138 & 1;
    uint64_t v15 = v163;
    if (!v107) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }
  std::mutex::unlock(v100);
  if (v106) {
    goto LABEL_171;
  }
  BOOL v17 = 0;
LABEL_229:
  if ((validContextType() & 1) == 0)
  {
    uint64_t v143 = *(void *)(a1 + 112);
    if (v143)
    {
      sub_10003E168(buf, (void *)(a1 + 32));
      if (*(void *)buf) {
        uint64_t v144 = *(void *)buf + 24;
      }
      else {
        uint64_t v144 = 0;
      }
      uint64_t v170 = v144;
      v171 = *(std::__shared_weak_count **)&buf[8];
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v145 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v143 + 184))(v143, &v170);
      if (v171) {
        sub_10004D2C8(v171);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (validContextType())
      {
        if (a2 && !sub_100D86A8C(a1, v145, a2, 0))
        {
          v151 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v152 = v15;
            uint64_t v153 = asString();
            uint64_t v154 = asString();
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = "getPreferredContextType";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v153;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v185 = v154;
            _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I %s: iRAT recommends %s, there is active %s, but the observer is not valid on that context type, so we ignore the activate context type", buf, 0x20u);
            uint64_t v15 = v152;
          }
        }
        else
        {
          v146 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v147 = asString();
            uint64_t v148 = asString();
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = "getPreferredContextType";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v147;
            *(_WORD *)&unsigned char buf[22] = 2080;
            uint64_t v185 = v148;
            _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I %s: iRAT recommends %s, but there is active %s, so we pick the active context", buf, 0x20u);
          }
          uint64_t v15 = v145;
        }
      }
      else
      {
        v149 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v150 = asString();
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "getPreferredContextType";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v150;
          _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I %s: iRAT recommends %s, and there is no active context", buf, 0x16u);
        }
      }
    }
  }
  int valid = validContextType();
  if (a2 && (v164 & (valid ^ 1)) != 0)
  {
    uint64_t v156 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v157 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v157;
      _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "#I %s: Choosing %s as the last resort fallback", buf, 0x16u);
    }
    uint64_t v15 = 0;
    goto LABEL_27;
  }
  if (v15 == 1) {
    int v158 = v106;
  }
  else {
    int v158 = 0;
  }
  if (v158 == 1)
  {
    char v159 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v160 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v160;
      _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I %s: Policy doesn't allow Tech connection on %s, use BB", buf, 0x16u);
    }
    uint64_t v15 = 0;
  }
LABEL_26:
  if (!a2)
  {
    char v28 = 1;
    goto LABEL_56;
  }
LABEL_27:
  char v22 = validContextType();
  if (v183) {
    char v23 = 1;
  }
  else {
    char v23 = v22;
  }
  if (v23) {
    goto LABEL_55;
  }
  if (v182 != 1)
  {
    if (v182) {
      goto LABEL_55;
    }
    __int16 v24 = *(NSObject **)(a1 + 64);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_55;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "getPreferredContextType";
    uint64_t v25 = "#I %s: Observer is not subscribed to anything (0)";
    unint64_t v26 = v24;
    uint32_t v27 = 12;
    goto LABEL_54;
  }
  uint64_t v15 = *((unsigned int *)v180 + 7);
  long long v35 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "getPreferredContextType";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v36;
    uint64_t v25 = "#I %s: the only valid context type is %s";
    unint64_t v26 = v35;
    uint32_t v27 = 22;
LABEL_54:
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, buf, v27);
  }
LABEL_55:
  char v28 = 0;
LABEL_56:
  char v37 = validContextType();
  unsigned int v38 = *(NSObject **)(a1 + 64);
  BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
  if ((v37 & 1) == 0)
  {
    if (!v39) {
      goto LABEL_108;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "getPreferredContextType";
    BOOL v45 = "#E %s: !!! ContextType not found";
    uint64_t v46 = v38;
    goto LABEL_69;
  }
  if (v39)
  {
    uint64_t v40 = asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "getPreferredContextType";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v40;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s: ContextType: using %s", buf, 0x16u);
  }
  if (v183) {
    BOOL v41 = 0;
  }
  else {
    BOOL v41 = v17;
  }
  if (v41)
  {
    unint64_t v42 = sub_100D90350(a1, 1);
    unint64_t v43 = v42;
    if (v15 != 1 || v42)
    {
      if (v15) {
        goto LABEL_108;
      }
    }
    else
    {
      __int16 v44 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "getPreferredContextType";
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s: IMS: service mask in iTech is 0, going over BB", buf, 0xCu);
      }
    }
    if (sub_100D90350(a1, 0))
    {
      uint64_t v15 = 0;
      goto LABEL_108;
    }
    uint64_t v47 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "getPreferredContextType";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v43;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: IMS: service mask in BB is 0, we have nowhere to go; iWLANmask=%lu",
        buf,
        0x16u);
      uint64_t v47 = *(NSObject **)(a1 + 64);
    }
    BOOL v48 = os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
    if (v16)
    {
      if (v48)
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "getPreferredContextType";
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: IMS: we are forced to stay with 'no context'", buf, 0xCu);
      }
      *uint64_t v16 = 1;
      uint64_t v15 = 2;
      goto LABEL_108;
    }
    if (v43)
    {
      if (v48)
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "getPreferredContextType";
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: IMS: we can try IWLAN", buf, 0xCu);
      }
      uint64_t v15 = 1;
      goto LABEL_108;
    }
    if (!v48) {
      goto LABEL_108;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "getPreferredContextType";
    BOOL v45 = "#I %s: IMS: trye to start something else ?";
    uint64_t v46 = v47;
LABEL_69:
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, buf, 0xCu);
  }
LABEL_108:
  if ((v28 & 1) == 0)
  {
    int v60 = validContextType();
    int v61 = v183 ? 0 : v60;
    if (v61 == 1)
    {
      if (v182 == 1)
      {
        unsigned int v167 = *((_DWORD *)v180 + 7);
        if (v15 != v167)
        {
          (*(void (**)(uint64_t))(*(void *)a2 + 200))(a2);
          int v63 = DataiRatControllerInterface::getAppType();
          uint64_t v64 = a1 + 24 * (int)v15;
          uint64_t v66 = *(void *)(v64 + 120);
          uint64_t v65 = *(void *)(v64 + 128);
          if (v66 != v65)
          {
            int v67 = v63;
            do
            {
              uint64_t v68 = *(void *)(v66 + 8);
              if (v68 != a2 && *(unsigned char *)(v66 + 16) != 0)
              {
                (*(void (**)(uint64_t))(*(void *)v68 + 200))(v68);
                int v70 = DataiRatControllerInterface::getAppType();
                if (v67 == 3 || v70 >= v67)
                {
                  int v71 = *(NSObject **)(a1 + 64);
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                  {
                    (*(void (**)(uint64_t))(*(void *)a2 + 200))(a2);
                    uint64_t v72 = asString();
                    uint64_t v73 = asString();
                    uint64_t v74 = asString();
                    (*(void (**)(void))(**(void **)(v66 + 8) + 200))(*(void *)(v66 + 8));
                    uint64_t v75 = asString();
                    (*(void (**)(uint64_t))(*(void *)a2 + 200))(a2);
                    uint64_t v76 = asString();
                    *(_DWORD *)std::string buf = 136316418;
                    *(void *)&uint8_t buf[4] = "getPreferredContextType";
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v72;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    uint64_t v185 = v73;
                    __int16 v186 = 2080;
                    uint64_t v187 = v74;
                    __int16 v188 = 2080;
                    uint64_t v189 = v75;
                    __int16 v190 = 2080;
                    uint64_t v191 = v76;
                    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I %s: Observer %s is subscribed to %s only but the activation vote goes to %s (because %s is objecting) , so we cannot choose the data context for %s", buf, 0x3Eu);
                  }
                  uint64_t v15 = 2;
                }
              }
              v66 += 24;
            }
            while (v66 != v65);
          }
        }
        if (validContextType())
        {
          unint64_t v77 = *(NSObject **)(a1 + 64);
          uint64_t v15 = v167;
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v78 = asString();
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = "getPreferredContextType";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v78;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I %s: we insist because no other connection needs it, we are good to go on %s", buf, 0x16u);
          }
        }
      }
      else if (!v182)
      {
        __int16 v62 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "getPreferredContextType";
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s: Observer is not subscribed to anything (1)", buf, 0xCu);
        }
        uint64_t v15 = 2;
      }
    }
  }
  sub_1000346F8((uint64_t)&v180, v181);
  return v15;
}