uint64_t *sub_100602C14(uint64_t a1, void **a2, long long **a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  long long *v8;
  uint64_t *v9;
  uint64_t *v10;
  long long v11;
  uint64_t *v13[2];
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v5 = (uint64_t **)sub_100046ED4(a1, &v15, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v8 = *a3;
    v14 = 0;
    v9 = (uint64_t *)operator new(0x198uLL);
    v10 = v9;
    v13[0] = v9;
    v13[1] = (uint64_t *)(a1 + 8);
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84((unsigned char *)v9 + 32, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      v11 = *v8;
      v9[6] = *((void *)v8 + 2);
      *((_OWORD *)v9 + 2) = v11;
    }
    *(_OWORD *)(v10 + 7) = 0u;
    *(_OWORD *)(v10 + 47) = 0u;
    *(_OWORD *)(v10 + 49) = 0u;
    *(_OWORD *)(v10 + 43) = 0u;
    *(_OWORD *)(v10 + 45) = 0u;
    *(_OWORD *)(v10 + 39) = 0u;
    *(_OWORD *)(v10 + 41) = 0u;
    *(_OWORD *)(v10 + 37) = 0u;
    *(_OWORD *)(v10 + 29) = 0u;
    *(_OWORD *)(v10 + 31) = 0u;
    *(_OWORD *)(v10 + 25) = 0u;
    *(_OWORD *)(v10 + 27) = 0u;
    *(_OWORD *)(v10 + 21) = 0u;
    *(_OWORD *)(v10 + 23) = 0u;
    *(_OWORD *)(v10 + 17) = 0u;
    *(_OWORD *)(v10 + 19) = 0u;
    *(_OWORD *)(v10 + 13) = 0u;
    *(_OWORD *)(v10 + 15) = 0u;
    *(_OWORD *)(v10 + 9) = 0u;
    *(_OWORD *)(v10 + 11) = 0u;
    *(_OWORD *)(v10 + 35) = 0u;
    *(_OWORD *)(v10 + 33) = 0u;
    sub_1006015F0((uint64_t)(v10 + 7));
    LOBYTE(v14) = 1;
    sub_100046C38((uint64_t **)a1, v15, v7, v13[0]);
    v6 = v13[0];
    v13[0] = 0;
    sub_100602D60((uint64_t)v13, 0);
  }
  return v6;
}

void sub_100602D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100602D60(uint64_t a1, uint64_t a2)
{
  v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1006024D0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_100602DBC()
{
}

void *sub_100602DD0(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019ED928;
  result[1] = v3;
  return result;
}

uint64_t sub_100602E18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019ED928;
  a2[1] = v2;
  return result;
}

void sub_100602E44(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 40);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100602F24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100602F64()
{
}

void sub_100602F70(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 296);
  *(void *)(v1 + 296) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  memset(&__src, 0, sizeof(__src));
  sub_1005F1284(&__src, v1);
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__src.__r_.__value_.__l.__size_) {
      goto LABEL_26;
    }
    sub_10004FC84(&__p, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((unsigned char *)&__src.__r_.__value_.__s + 23)) {
      goto LABEL_26;
    }
    std::string __p = __src;
  }
  int v3 = sub_1005F1348(v1, (long long *)&__p);
  char v4 = v3;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v4 & 1) == 0) {
      goto LABEL_26;
    }
  }
  else if (!v3)
  {
    goto LABEL_26;
  }
  memset(buf, 0, 24);
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = __src;
  }
  sub_1005F14B8((std::string *)buf, v1, (unsigned __int8 *)&__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if ((buf[23] & 0x80000000) != 0)
  {
    if (!*(void *)&buf[8]) {
      goto LABEL_24;
    }
    sub_10004FC84(v81, *(void **)buf, *(unint64_t *)&buf[8]);
LABEL_22:
    BOOL v5 = sub_1005F15E0(v1, (uint64_t)v81);
    BOOL v6 = v5;
    if (SHIBYTE(v82) < 0)
    {
      operator delete(v81[0]);
      if (v6)
      {
LABEL_24:
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_26;
      }
    }
    else if (v5)
    {
      goto LABEL_24;
    }
    v57 = *(NSObject **)(v1 + 64);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      p_src = &__src;
      if ((__src.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
      }
      LODWORD(v93.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v93.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_src;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Disabling Private Network SIM iccid %s reason: primary SIM out of service", (uint8_t *)&v93, 0xCu);
    }
    if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v93, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
    }
    else {
      std::string v93 = __src;
    }
    sub_1005F09D4(v1, (long long *)&v93, 0);
    if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v93.__r_.__value_.__l.__data_);
    }
    if ((buf[23] & 0x80000000) == 0)
    {
LABEL_213:
      if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__src.__r_.__value_.__l.__data_);
      }
      operator delete();
    }
    v62 = *(void **)buf;
LABEL_212:
    operator delete(v62);
    goto LABEL_213;
  }
  if (buf[23])
  {
    *(_OWORD *)v81 = *(_OWORD *)buf;
    uint64_t v82 = *(void *)&buf[16];
    goto LABEL_22;
  }
LABEL_26:
  uint64_t v7 = *(int *)(v1 + 304);
  if (v7 != 1)
  {
    v12 = *(NSObject **)(v1 + 64);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_213;
    }
    if (v7 > 0xA) {
      v13 = "???";
    }
    else {
      v13 = off_1019EE9B0[v7];
    }
    v18 = (std::string *)__src.__r_.__value_.__r.__words[0];
    if ((__src.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v18 = &__src;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v18;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v13;
    v9 = "#I Do not enable/disable private network SIM %s, controller in dormant state: %s";
    v10 = v12;
    uint32_t v11 = 22;
    goto LABEL_46;
  }
  if (rest::WRMRecommendation::activeCall((rest::WRMRecommendation *)(v1 + 2524)))
  {
    v8 = *(NSObject **)(v1 + 64);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_213;
    }
    *(_WORD *)buf = 0;
    v9 = "#I There is ongoing call, do not enable/disable private network sim at this time";
    v10 = v8;
    uint32_t v11 = 2;
LABEL_46:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
    goto LABEL_213;
  }
  std::string::size_type size = HIBYTE(__src.__r_.__value_.__r.__words[2]);
  int v15 = SHIBYTE(__src.__r_.__value_.__r.__words[2]);
  if ((__src.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __src.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    v16 = *(NSObject **)(v1 + 64);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = (std::string *)__src.__r_.__value_.__r.__words[0];
      if (v15 >= 0) {
        v17 = &__src;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Maybe disable private network SIM iccid %s", buf, 0xCu);
      LOBYTE(v15) = *((unsigned char *)&__src.__r_.__value_.__s + 23);
    }
    if ((v15 & 0x80) != 0) {
      sub_10004FC84(&v88, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
    }
    else {
      std::string v88 = __src;
    }
    v59 = sub_100046F68(v1 + 216, (void **)&v88.__r_.__value_.__l.__data_);
    if ((void **)(v1 + 224) == v59)
    {
      v60 = *(NSObject **)(v1 + 64);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        v61 = &v88;
        if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          v61 = (std::string *)v88.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v61;
        _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "iccid not found: %s", buf, 0xCu);
      }
      goto LABEL_210;
    }
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_100059120((uint64_t)buf, (uint64_t)(v59 + 7));
    if (!BYTE8(v109))
    {
      v63 = *(NSObject **)(v1 + 64);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v93.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Private network optimizations not supported", (uint8_t *)&v93, 2u);
      }
      goto LABEL_209;
    }
    if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(v92, v88.__r_.__value_.__l.__data_, v88.__r_.__value_.__l.__size_);
    }
    else {
      v92[0] = v88;
    }
    unsigned int v64 = sub_1005F06B8(v1, (void **)&v92[0].__r_.__value_.__l.__data_);
    if (SHIBYTE(v92[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92[0].__r_.__value_.__l.__data_);
    }
    if (v64 == 1)
    {
      if (BYTE9(v109))
      {
        std::string v93 = *(std::string *)(v1 + 312);
        if (*(char *)(v1 + 359) < 0)
        {
          sub_10004FC84(&v94, *(void **)(v1 + 336), *(void *)(v1 + 344));
        }
        else
        {
          long long v94 = *(_OWORD *)(v1 + 336);
          uint64_t v95 = *(void *)(v1 + 352);
        }
        if (*(char *)(v1 + 383) < 0)
        {
          sub_10004FC84(&v96, *(void **)(v1 + 360), *(void *)(v1 + 368));
        }
        else
        {
          long long v96 = *(_OWORD *)(v1 + 360);
          uint64_t v97 = *(void *)(v1 + 376);
        }
        int v73 = sub_1005F2068((uint64_t)&v93);
        if (SHIBYTE(v97) < 0) {
          operator delete((void *)v96);
        }
        if (SHIBYTE(v95) < 0) {
          operator delete((void *)v94);
        }
        if (v73 != 2)
        {
          if (BYTE4(v99) && (int)v99 <= 0)
          {
            if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v89, v88.__r_.__value_.__l.__data_, v88.__r_.__value_.__l.__size_);
            }
            else {
              std::string v89 = v88;
            }
            BOOL v74 = sub_1005F15E0(v1, (uint64_t)&v89);
            if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v89.__r_.__value_.__l.__data_);
            }
            if (!v74)
            {
              v75 = *(NSObject **)(v1 + 64);
              if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
              {
                v76 = &v88;
                if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  v76 = (std::string *)v88.__r_.__value_.__r.__words[0];
                }
                LODWORD(v91.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)v91.__r_.__value_.__r.__words + 4) = (std::string::size_type)v76;
                _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I Disabling Private Network SIM iccid: %s", (uint8_t *)&v91, 0xCu);
              }
              if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(&v91, v88.__r_.__value_.__l.__data_, v88.__r_.__value_.__l.__size_);
              }
              else {
                std::string v91 = v88;
              }
              sub_1005F09D4(v1, (long long *)&v91, 0);
              if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v91.__r_.__value_.__l.__data_);
              }
            }
          }
          goto LABEL_209;
        }
        v68 = *(NSObject **)(v1 + 64);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v89.__r_.__value_.__l.__data_) = 0;
          v69 = "#I Bounding geofence in active mode";
          v70 = &v89;
          goto LABEL_207;
        }
      }
      else
      {
        v68 = *(NSObject **)(v1 + 64);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v93.__r_.__value_.__l.__data_) = 0;
          v69 = "#I User disabled private network SIM";
          v70 = &v93;
LABEL_207:
          v71 = v68;
          uint32_t v72 = 2;
LABEL_208:
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v69, (uint8_t *)v70, v72);
        }
      }
    }
    else
    {
      v65 = *(NSObject **)(v1 + 64);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        v66 = &v88;
        if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          v66 = (std::string *)v88.__r_.__value_.__r.__words[0];
        }
        if (v64 > 0xA) {
          v67 = "???";
        }
        else {
          v67 = off_1019EE9B0[v64];
        }
        LODWORD(v93.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v93.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
        WORD2(v93.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v93.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v67;
        v69 = "#I Sim [%s] dormant with reason [%s]";
        v70 = &v93;
        v71 = v65;
        uint32_t v72 = 22;
        goto LABEL_208;
      }
    }
LABEL_209:
    sub_10006544C((uint64_t)buf);
LABEL_210:
    if ((SHIBYTE(v88.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_213;
    }
    v62 = (void *)v88.__r_.__value_.__r.__words[0];
    goto LABEL_212;
  }
  v19 = *(void ***)(v1 + 216);
  v20 = (void **)(v1 + 224);
  if (v19 == (void **)(v1 + 224)) {
    goto LABEL_213;
  }
  v21 = (long long *)(v1 + 312);
  while (1)
  {
    if (*((unsigned char *)v19 + 256))
    {
      v22 = v19 + 4;
      if (*((char *)v19 + 55) < 0)
      {
        sub_10004FC84(v79, v19[4], (unint64_t)v19[5]);
      }
      else
      {
        *(_OWORD *)v79 = *v22;
        v80 = v19[6];
      }
      char v23 = sub_1005F08AC(*(void *)(v1 + 504), *(void *)(v1 + 512), (uint64_t)v79);
      char v24 = v23;
      if (SHIBYTE(v80) < 0)
      {
        operator delete(v79[0]);
        if ((v24 & 1) == 0)
        {
LABEL_57:
          v25 = *(NSObject **)(v1 + 64);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            v26 = v19 + 4;
            if (*((char *)v19 + 55) < 0) {
              v26 = *(void **)v22;
            }
            *(_DWORD *)buf = 136315138;
            *(void *)&buf[4] = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Maybe enable private network SIM iccid %s", buf, 0xCu);
          }
          if (*((char *)v19 + 55) < 0)
          {
            sub_10004FC84(&v78, v19[4], (unint64_t)v19[5]);
          }
          else
          {
            *(_OWORD *)&v78.__r_.__value_.__l.__data_ = *v22;
            v78.__r_.__value_.__r.__words[2] = (std::string::size_type)v19[6];
          }
          v27 = sub_100046F68(v1 + 216, (void **)&v78.__r_.__value_.__l.__data_);
          if (v20 == v27)
          {
            v28 = *(NSObject **)(v1 + 64);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              v29 = &v78;
              if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                v29 = (std::string *)v78.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v29;
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "iccid not found: %s", buf, 0xCu);
            }
            goto LABEL_110;
          }
          long long v117 = 0u;
          long long v118 = 0u;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v111 = 0u;
          long long v112 = 0u;
          long long v109 = 0u;
          long long v110 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_100059120((uint64_t)buf, (uint64_t)(v27 + 7));
          if (!BYTE8(v109))
          {
            v30 = *(NSObject **)(v1 + 64);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v92[0].__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Private network optimizations not supported", (uint8_t *)v92, 2u);
            }
            goto LABEL_109;
          }
          if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v89, v78.__r_.__value_.__l.__data_, v78.__r_.__value_.__l.__size_);
          }
          else {
            std::string v89 = v78;
          }
          unsigned int v31 = sub_1005F06B8(v1, (void **)&v89.__r_.__value_.__l.__data_);
          if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v89.__r_.__value_.__l.__data_);
          }
          if (v31 == 1)
          {
            if (!BYTE9(v109))
            {
              v39 = *(NSObject **)(v1 + 64);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v92[0].__r_.__value_.__l.__data_) = 0;
                v35 = v92;
                v36 = v39;
                v37 = "#I User disabled private network SIM";
                goto LABEL_107;
              }
              goto LABEL_109;
            }
            std::string v93 = *(std::string *)v21;
            if (*(char *)(v1 + 359) < 0)
            {
              sub_10004FC84(&v94, *(void **)(v1 + 336), *(void *)(v1 + 344));
            }
            else
            {
              long long v94 = *(_OWORD *)(v1 + 336);
              uint64_t v95 = *(void *)(v1 + 352);
            }
            if (*(char *)(v1 + 383) < 0)
            {
              sub_10004FC84(&v96, *(void **)(v1 + 360), *(void *)(v1 + 368));
            }
            else
            {
              long long v96 = *(_OWORD *)(v1 + 360);
              uint64_t v97 = *(void *)(v1 + 376);
            }
            int v40 = sub_1005F2068((uint64_t)&v93);
            if (SHIBYTE(v97) < 0) {
              operator delete((void *)v96);
            }
            if (SHIBYTE(v95) < 0) {
              operator delete((void *)v94);
            }
            if (v40 == 3)
            {
              v41 = *(NSObject **)(v1 + 64);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v92[0].__r_.__value_.__l.__data_) = 0;
                v35 = v92;
                v36 = v41;
                v37 = "#I Bounding geofence in inactive mode";
                goto LABEL_107;
              }
LABEL_109:
              sub_10006544C((uint64_t)buf);
LABEL_110:
              if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v78.__r_.__value_.__l.__data_);
              }
              goto LABEL_112;
            }
            if (BYTE4(v99))
            {
              if (v99
                || (sub_1005FCE34((uint64_t)v92, v21),
                    int v42 = sub_1005F2068((uint64_t)v92),
                    sub_1005EB918((uint64_t)v92),
                    v42 == 2))
              {
                memset(&v91, 0, sizeof(v91));
                if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&v88, v78.__r_.__value_.__l.__data_, v78.__r_.__value_.__l.__size_);
                }
                else {
                  std::string v88 = v78;
                }
                sub_1005F14B8(&v91, v1, (unsigned __int8 *)&v88);
                if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v88.__r_.__value_.__l.__data_);
                }
                if ((SHIBYTE(v91.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  if (*((unsigned char *)&v91.__r_.__value_.__s + 23))
                  {
                    std::string v87 = v91;
                    goto LABEL_127;
                  }
                  goto LABEL_130;
                }
                if (!v91.__r_.__value_.__l.__size_) {
                  goto LABEL_130;
                }
                sub_10004FC84(&v87, v91.__r_.__value_.__l.__data_, v91.__r_.__value_.__l.__size_);
LABEL_127:
                BOOL v47 = sub_1005F15E0(v1, (uint64_t)&v87);
                if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v87.__r_.__value_.__l.__data_);
                }
                if (!v47)
                {
                  v53 = *(NSObject **)(v1 + 64);
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v86.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Private network primary SIM out of service", (uint8_t *)&v86, 2u);
                  }
                }
                else
                {
LABEL_130:
                  v48 = v21;
                  memset(&v86, 0, sizeof(v86));
                  sub_1005F1284(&v86, v1);
                  int v49 = SHIBYTE(v86.__r_.__value_.__r.__words[2]);
                  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v50 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v50 = v86.__r_.__value_.__l.__size_;
                  }
                  log = *(NSObject **)(v1 + 64);
                  BOOL v51 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
                  if (v50)
                  {
                    v21 = v48;
                    if (v51)
                    {
                      v52 = (std::string *)v86.__r_.__value_.__r.__words[0];
                      if (v49 >= 0) {
                        v52 = &v86;
                      }
                      LODWORD(v90.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v90.__r_.__value_.__r.__words + 4) = (std::string::size_type)v52;
                      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I Private network SIM with iccid [%s] is already enabled", (uint8_t *)&v90, 0xCu);
                    }
                  }
                  else
                  {
                    if (v51)
                    {
                      v54 = &v78;
                      if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        v54 = (std::string *)v78.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v90.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v90.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
                      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I Enabling Private Network SIM iccid %s", (uint8_t *)&v90, 0xCu);
                    }
                    v21 = v48;
                    if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                      sub_10004FC84(&v90, v78.__r_.__value_.__l.__data_, v78.__r_.__value_.__l.__size_);
                    }
                    else {
                      std::string v90 = v78;
                    }
                    sub_1005F09D4(v1, (long long *)&v90, 1);
                    if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v90.__r_.__value_.__l.__data_);
                    }
                  }
                  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v86.__r_.__value_.__l.__data_);
                  }
                }
                if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v91.__r_.__value_.__l.__data_);
                }
                goto LABEL_109;
              }
              v55 = *(NSObject **)(v1 + 64);
              if (!os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_109;
              }
              v56 = &v78;
              if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                v56 = (std::string *)v78.__r_.__value_.__r.__words[0];
              }
              LODWORD(v91.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v91.__r_.__value_.__r.__words + 4) = (std::string::size_type)v56;
              v35 = &v91;
              v36 = v55;
              v37 = "#I Private network SIM %s not in geofence";
              uint32_t v38 = 12;
            }
            else
            {
              v43 = *(NSObject **)(v1 + 64);
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_109;
              }
              LOWORD(v92[0].__r_.__value_.__l.__data_) = 0;
              v35 = v92;
              v36 = v43;
              v37 = "#I No geofence callback returned yet";
LABEL_107:
              uint32_t v38 = 2;
            }
          }
          else
          {
            v32 = *(NSObject **)(v1 + 64);
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_109;
            }
            v33 = &v78;
            if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              v33 = (std::string *)v78.__r_.__value_.__r.__words[0];
            }
            v34 = "???";
            if (v31 <= 0xA) {
              v34 = off_1019EE9B0[v31];
            }
            LODWORD(v92[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v92[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
            WORD2(v92[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v92[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v34;
            v35 = v92;
            v36 = v32;
            v37 = "#I Sim [%s] dormant with reason [%s]";
            uint32_t v38 = 22;
          }
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)v35, v38);
          goto LABEL_109;
        }
      }
      else if ((v23 & 1) == 0)
      {
        goto LABEL_57;
      }
    }
LABEL_112:
    v44 = (void **)v19[1];
    if (v44)
    {
      do
      {
        v45 = v44;
        v44 = (void **)*v44;
      }
      while (v44);
    }
    else
    {
      do
      {
        v45 = (void **)v19[2];
        BOOL v46 = *v45 == v19;
        v19 = v45;
      }
      while (!v46);
    }
    v19 = v45;
    if (v45 == v20) {
      goto LABEL_213;
    }
  }
}

void sub_100603F18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  if (a73 < 0) {
    operator delete(a72);
  }
  sub_10006544C((uint64_t)&STACK[0x270]);
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  operator delete();
}

uint64_t *sub_100604120(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  result = sub_100046ED4((uint64_t)a1, &v8, a2);
  if (!*result)
  {
    BOOL v6 = (uint64_t **)result;
    memset(v7, 0, sizeof(v7));
    sub_1004ADA0C((uint64_t)a1, a3, v7);
    return sub_100046C38(a1, v8, v6, v7[0]);
  }
  return result;
}

void sub_1006041A0()
{
}

void *sub_1006041B4(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019ED9A8;
  result[1] = v3;
  return result;
}

uint64_t sub_1006041FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019ED9A8;
  a2[1] = v2;
  return result;
}

void sub_100604228(uint64_t a1, long long *a2, uint64_t a3)
{
  long long v24 = *a2;
  uint64_t v25 = *((void *)a2 + 2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(_OWORD *)v21 = *(_OWORD *)a3;
  *(void *)&v21[16] = *(void *)(a3 + 16);
  std::string v22 = *(std::string *)(a3 + 24);
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  long long v3 = *(_OWORD *)(a3 + 48);
  v23.__r_.__value_.__r.__words[2] = *(void *)(a3 + 64);
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v3;
  *(void *)(a3 + 4sub_100602D60((uint64_t)&a9, 0) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 64) = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL v5 = *(void **)(v4 + 216);
  if (v5 != (void *)(v4 + 224))
  {
    do
    {
      sub_10005CD2C((uint64_t)(v5 + 8), (char *)v5[9]);
      v5[8] = v5 + 9;
      v5[9] = 0;
      v5[10] = 0;
      if (*((unsigned char *)v5 + 92)) {
        *((unsigned char *)v5 + 92) = 0;
      }
      BOOL v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          BOOL v5 = v7;
        }
        while (!v8);
      }
      BOOL v5 = v7;
    }
    while (v7 != (void *)(v4 + 224));
  }
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  std::operator+<char>();
  int8x16_t v33 = vextq_s8(*(int8x16_t *)&v21[8], *(int8x16_t *)&v21[8], 8uLL);
  uint64_t v34 = *(void *)v21;
  (*(void (**)(void, int8x16_t *, void **))(**(void **)(v4 + 104) + 24))(*(void *)(v4 + 104), &v33, v35);
  long long v29 = *(_OWORD *)v21;
  uint64_t v30 = *(void *)&v21[16];
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v31, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
  }
  else {
    std::string v31 = v22;
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v23;
  }
  int v9 = sub_1005F2068((uint64_t)&v29);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v31.__r_.__value_.__l.__data_);
    if (v9) {
      goto LABEL_20;
    }
  }
  else if (v9)
  {
LABEL_20:
    if (v9 == 1)
    {
      uint64_t v11 = *((void *)&v24 + 1);
      for (uint64_t i = v24; i != v11; i += 72)
      {
        memset(&buf, 0, sizeof(buf));
        if (*(char *)(i + 71) >= 0) {
          size_t v12 = *(unsigned __int8 *)(i + 71);
        }
        else {
          size_t v12 = *(void *)(i + 56);
        }
        memset(&v28, 0, sizeof(v28));
        sub_1000C140C((uint64_t)&v28, v12 + 1);
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v13 = &v28;
        }
        else {
          v13 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        if (v12)
        {
          if (*(char *)(i + 71) >= 0) {
            v14 = (const void *)(i + 48);
          }
          else {
            v14 = *(const void **)(i + 48);
          }
          memmove(v13, v14, v12);
        }
        *(_WORD *)((char *)&v13->__r_.__value_.__l.__data_ + v12) = 32;
        int v15 = *(char *)(i + 47);
        if (v15 >= 0) {
          v16 = (const std::string::value_type *)(i + 24);
        }
        else {
          v16 = *(const std::string::value_type **)(i + 24);
        }
        if (v15 >= 0) {
          std::string::size_type v17 = *(unsigned __int8 *)(i + 47);
        }
        else {
          std::string::size_type v17 = *(void *)(i + 32);
        }
        v18 = std::string::append(&v28, v16, v17);
        long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v19;
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v28.__r_.__value_.__l.__data_);
        }
        *(int8x16_t *)&v28.__r_.__value_.__l.__data_ = vextq_s8(*(int8x16_t *)(i + 8), *(int8x16_t *)(i + 8), 8uLL);
        v28.__r_.__value_.__r.__words[2] = *(void *)i;
        (*(void (**)(void, std::string *, std::string *))(**(void **)(v4 + 104) + 24))(*(void *)(v4 + 104), &v28, &buf);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
    }
    goto LABEL_48;
  }
  v20 = *(NSObject **)(v4 + 64);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Bounding reason is set to unknown", (uint8_t *)&buf, 2u);
  }
LABEL_48:
  *(void *)(v4 + 328) = *(void *)&v21[16];
  *(_OWORD *)(v4 + 312) = *(_OWORD *)v21;
  std::string::operator=((std::string *)(v4 + 336), &v22);
  std::string::operator=((std::string *)(v4 + 360), &v23);
  sub_100058DB0(&v28, "EvaluateAllIccids");
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
  }
  else {
    std::string buf = v28;
  }
  int v27 = 3;
  sub_100007714(v4, (uint64_t *)&buf);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  *(void *)&long long v29 = &v24;
  sub_100604790((void ***)&v29);
}

void sub_10060468C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v51 - 89) < 0) {
    operator delete(*(void **)(v51 - 112));
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  *(void *)(v51 - 144) = &a25;
  sub_100604790((void ***)(v51 - 144));
  _Unwind_Resume(a1);
}

uint64_t sub_100604744(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100604784()
{
}

void sub_100604790(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    BOOL v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        sub_100604814(v4);
      }
      while ((void *)v4 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100604814(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

void *sub_10060486C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1006048F0(uint64_t a1)
{
  *(void *)a1 = off_1019EDA38;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100604950(uint64_t a1)
{
  *(void *)a1 = off_1019EDA38;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1006049D0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019EDA38;
  sub_100604BF0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100604A24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100604A38(uint64_t a1, void *a2)
{
  *a2 = off_1019EDA38;
  return sub_100604BF0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100604A64(uint64_t a1)
{
}

void sub_100604A6C(void *a1)
{
  sub_10016B57C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100604AA8(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 64);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = a1 + 16;
    uint64_t v5 = v7;
    if (*(char *)(v6 + 23) >= 0) {
      uint64_t v5 = v6;
    }
    int v8 = *(char *)(v6 + 47);
    uint64_t v11 = *(void *)(v6 + 24);
    uint64_t v10 = v6 + 24;
    uint64_t v9 = v11;
    if (v8 >= 0) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = v9;
    }
    v13 = "";
    if (!*a2) {
      v13 = "not ";
    }
    int v14 = 136315650;
    uint64_t v15 = v5;
    __int16 v16 = 2080;
    uint64_t v17 = v12;
    __int16 v18 = 2080;
    long long v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Profile with iccid [%s] and identifier [%s] was %ssuccessfully installed to geofence manager", (uint8_t *)&v14, 0x20u);
  }
}

uint64_t sub_100604BA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100604BE4()
{
}

uint64_t sub_100604BF0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100604C84(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100604CA0(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v18 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4(a1, &v18, a2);
  if (!*v5)
  {
    long long v6 = v5;
    uint64_t v17 = 0;
    uint64_t v7 = (char *)operator new(0xC0uLL);
    v16[0] = (uint64_t *)v7;
    v16[1] = (uint64_t *)(a1 + 8);
    int v8 = v7 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v8, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)int v8 = *(_OWORD *)a3;
      *((void *)v7 + 6) = *(void *)(a3 + 16);
    }
    *((_DWORD *)v7 + 14) = *(_DWORD *)(a3 + 24);
    *((_OWORD *)v7 + 4) = *(_OWORD *)(a3 + 32);
    *((void *)v7 + 1sub_100602D60((uint64_t)&a9, 0) = *(void *)(a3 + 48);
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 4sub_100602D60((uint64_t)&a9, 0) = 0;
    *(_OWORD *)(v7 + 88) = *(_OWORD *)(a3 + 56);
    *((void *)v7 + 13) = *(void *)(a3 + 72);
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)(a3 + 64) = 0;
    *(void *)(a3 + 72) = 0;
    long long v9 = *(_OWORD *)(a3 + 80);
    *((void *)v7 + 16) = *(void *)(a3 + 96);
    *((_OWORD *)v7 + 7) = v9;
    *(void *)(a3 + 8sub_100602D60((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 88) = 0;
    *(_OWORD *)(v7 + 136) = *(_OWORD *)(a3 + 104);
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 104) = 0;
    uint64_t v10 = *(void *)(a3 + 120);
    uint64_t v11 = *(void *)(a3 + 128);
    *(void *)(a3 + 112) = 0;
    *(void *)(a3 + 12sub_100602D60((uint64_t)&a9, 0) = 0;
    *((void *)v7 + 19) = v10;
    *((void *)v7 + 2sub_100602D60((uint64_t)&a9, 0) = v11;
    uint64_t v13 = *(void *)(a3 + 144);
    uint64_t v14 = *(void *)(a3 + 152);
    uint64_t v12 = (void *)(a3 + 144);
    *((void *)v7 + 21) = *(void *)(a3 + 136);
    *((void *)v7 + 22) = v13;
    *((void *)v7 + 23) = v14;
    uint64_t v15 = v7 + 176;
    if (v14)
    {
      *(void *)(v13 + 16) = v15;
      *(void *)(a3 + 136) = v12;
      void *v12 = 0;
      *(void *)(a3 + 152) = 0;
    }
    else
    {
      *((void *)v7 + 21) = v15;
    }
    LOBYTE(v17) = 1;
    sub_100046C38((uint64_t **)a1, v18, v6, v16[0]);
    v16[0] = 0;
    sub_100602860((uint64_t)v16, 0);
  }
}

void sub_100604DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100604E14()
{
}

void *sub_100604E28(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDAB8;
  result[1] = v3;
  return result;
}

uint64_t sub_100604E70(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDAB8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100604E9C(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = *(uint64_t **)a2;
    long long v4 = (void *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 8);
    int v8 = *(uint64_t **)a2;
    uint64_t v9 = v3;
    uint64_t v10 = *(void *)(a2 + 16);
    if (v10)
    {
      *(void *)(v3 + 16) = &v9;
      *(void *)a2 = v4;
      *long long v4 = 0;
      *(void *)(a2 + 16) = 0;
      uint64_t v5 = v10;
    }
    else
    {
      uint64_t v5 = 0;
      int v8 = &v9;
      uint64_t v2 = &v9;
    }
    char v11 = 1;
    uint64_t v6 = *(void *)(result + 8);
    uint64_t v12 = v6;
    uint64_t v13 = v2;
    v14[0] = v3;
    v14[1] = v5;
    if (v5)
    {
      *(void *)(v3 + 16) = v14;
      int v8 = &v9;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v13 = v14;
    }
    char v15 = 1;
    uint64_t v7 = *(std::__shared_weak_count **)(v6 + 40);
    if (v7)
    {
      if (std::__shared_weak_count::lock(v7)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

uint64_t sub_10060507C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006050BC()
{
}

uint64_t *sub_1006050C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v11 = a1;
  uint64_t v12 = v1;
  if (!*(unsigned char *)(v1 + 32)) {
    sub_10016C840();
  }
  uint64_t v2 = *(long long **)(v1 + 8);
  uint64_t v3 = (long long *)(v1 + 16);
  if (v2 != (long long *)(v1 + 16))
  {
    uint64_t v4 = *(void *)v1;
    uint64_t v5 = *(void *)v1 + 240;
    do
    {
      if (*((_DWORD *)v2 + 14))
      {
        sub_100601430(buf, v2 + 2, (uint64_t)v2 + 56);
        sub_100604CA0(v5, (void **)buf, (uint64_t)buf);
        sub_10005CD90((uint64_t)v23, v23[1]);
        if (v22 < 0) {
          operator delete(__p);
        }
        if (v20 < 0) {
          operator delete(v19);
        }
        if (v18 < 0) {
          operator delete(v17);
        }
        if (v16 < 0) {
          operator delete(v15);
        }
        if (v14 < 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        uint64_t v6 = *(NSObject **)(v4 + 64);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I skip profile with type of kUnknown when load profiles", buf, 2u);
        }
      }
      uint64_t v7 = (long long *)*((void *)v2 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = *(long long **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (long long *)*((void *)v2 + 2);
          BOOL v9 = *(void *)v8 == (void)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = v8;
    }
    while (v8 != v3);
  }
  sub_1006052DC(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100605258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
}

uint64_t *sub_1006052DC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 32)) {
      sub_100602520(v1 + 8, *(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void *sub_100605338(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1006053BC(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v24 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4(a1, &v24, a2);
  if (!*v5)
  {
    uint64_t v6 = v5;
    uint64_t v23 = 0;
    uint64_t v7 = (char *)operator new(0x198uLL);
    v22[0] = (uint64_t *)v7;
    v22[1] = (uint64_t *)(a1 + 8);
    int v8 = v7 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v8, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)int v8 = *(_OWORD *)a3;
      *((void *)v7 + 6) = *(void *)(a3 + 16);
    }
    BOOL v9 = (void *)(a3 + 40);
    uint64_t v10 = *(void *)(a3 + 40);
    *((void *)v7 + 9) = v10;
    char v11 = v7 + 72;
    uint64_t v12 = *(void *)(a3 + 32);
    *((void *)v7 + 7) = *(void *)(a3 + 24);
    *((void *)v7 + 8) = v12;
    uint64_t v13 = *(void *)(a3 + 48);
    *((void *)v7 + 1sub_100602860((uint64_t)&a9, 0) = v13;
    if (v13)
    {
      *(void *)(v10 + 16) = v11;
      *(void *)(a3 + 32) = v9;
      void *v9 = 0;
      *(void *)(a3 + 48) = 0;
    }
    else
    {
      *((void *)v7 + 8) = v11;
    }
    *((void *)v7 + 11) = *(void *)(a3 + 56);
    *((_OWORD *)v7 + 6) = *(_OWORD *)(a3 + 64);
    *((void *)v7 + 14) = *(void *)(a3 + 80);
    *(void *)(a3 + 64) = 0;
    *(void *)(a3 + 72) = 0;
    *(_OWORD *)(v7 + 12sub_100602860((uint64_t)&a9, 0) = *(_OWORD *)(a3 + 88);
    *((void *)v7 + 17) = *(void *)(a3 + 104);
    *(void *)(a3 + 8sub_100602860((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 104) = 0;
    long long v14 = *(_OWORD *)(a3 + 112);
    *((void *)v7 + 2sub_100602860((uint64_t)&a9, 0) = *(void *)(a3 + 128);
    *((_OWORD *)v7 + 9) = v14;
    *(void *)(a3 + 112) = 0;
    *(void *)(a3 + 12sub_100602860((uint64_t)&a9, 0) = 0;
    long long v15 = *(_OWORD *)(a3 + 136);
    *((void *)v7 + 23) = *(void *)(a3 + 152);
    *(_OWORD *)(v7 + 168) = v15;
    *(void *)(a3 + 128) = 0;
    *(void *)(a3 + 136) = 0;
    *(void *)(a3 + 144) = 0;
    *(void *)(a3 + 152) = 0;
    v7[192] = 0;
    v7[216] = 0;
    if (*(unsigned char *)(a3 + 184))
    {
      *((_OWORD *)v7 + 12) = *(_OWORD *)(a3 + 160);
      *((void *)v7 + 26) = *(void *)(a3 + 176);
      *(void *)(a3 + 168) = 0;
      *(void *)(a3 + 176) = 0;
      *(void *)(a3 + 16sub_100602860((uint64_t)&a9, 0) = 0;
      v7[216] = 1;
    }
    v7[224] = 0;
    v7[248] = 0;
    if (*(unsigned char *)(a3 + 216))
    {
      *((_OWORD *)v7 + 14) = *(_OWORD *)(a3 + 192);
      *((void *)v7 + 3sub_100602860((uint64_t)&a9, 0) = *(void *)(a3 + 208);
      *(void *)(a3 + 20sub_100602860((uint64_t)&a9, 0) = 0;
      *(void *)(a3 + 208) = 0;
      *(void *)(a3 + 192) = 0;
      v7[248] = 1;
    }
    *((_WORD *)v7 + 128) = *(_WORD *)(a3 + 224);
    *((_DWORD *)v7 + 66) = *(_DWORD *)(a3 + 232);
    *((_OWORD *)v7 + 17) = *(_OWORD *)(a3 + 240);
    *((void *)v7 + 36) = *(void *)(a3 + 256);
    *(void *)(a3 + 24sub_100602860((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 248) = 0;
    *(void *)(a3 + 256) = 0;
    *((void *)v7 + 39) = *(void *)(a3 + 280);
    *(_OWORD *)(v7 + 296) = *(_OWORD *)(a3 + 264);
    *(void *)(a3 + 272) = 0;
    *(void *)(a3 + 28sub_100602860((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 264) = 0;
    long long v16 = *(_OWORD *)(a3 + 288);
    *((void *)v7 + 42) = *(void *)(a3 + 304);
    *((_OWORD *)v7 + 2sub_100602860((uint64_t)&a9, 0) = v16;
    *(void *)(a3 + 288) = 0;
    *(void *)(a3 + 296) = 0;
    *(void *)(a3 + 304) = 0;
    *(_OWORD *)(v7 + 344) = *(_OWORD *)(a3 + 312);
    *(void *)(a3 + 312) = 0;
    uint64_t v17 = *(void *)(a3 + 328);
    uint64_t v18 = *(void *)(a3 + 336);
    *(void *)(a3 + 32sub_100602860((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 328) = 0;
    *((void *)v7 + 45) = v17;
    *((void *)v7 + 46) = v18;
    long long v19 = v7 + 384;
    uint64_t v20 = *(void *)(a3 + 352);
    *((void *)v7 + 47) = *(void *)(a3 + 344);
    *((void *)v7 + 48) = v20;
    uint64_t v21 = *(void *)(a3 + 360);
    *((void *)v7 + 49) = v21;
    if (v21)
    {
      *(void *)(v20 + 16) = v19;
      *(void *)(a3 + 344) = a3 + 352;
      *(void *)(a3 + 352) = 0;
      *(void *)(a3 + 36sub_100602860((uint64_t)&a9, 0) = 0;
    }
    else
    {
      *((void *)v7 + 47) = v19;
    }
    *((void *)v7 + 5sub_100602860((uint64_t)&a9, 0) = *(void *)(a3 + 368);
    LOBYTE(v23) = 1;
    sub_100046C38((uint64_t **)a1, v24, v6, v22[0]);
    v22[0] = 0;
    sub_100602D60((uint64_t)v22, 0);
  }
}

void sub_100605634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10060564C(void ***a1, void **a2)
{
  uint64_t v3 = sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (void ***)v3)
  {
    uint64_t v4 = (uint64_t *)v3;
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = (void **)*v5;
      }
      while (v5);
    }
    else
    {
      uint64_t v7 = v3;
      do
      {
        uint64_t v6 = (void **)v7[2];
        BOOL v8 = *v6 == v7;
        uint64_t v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3) {
      *a1 = v6;
    }
    BOOL v9 = (uint64_t *)a1[1];
    a1[2] = (void **)((char *)a1[2] - 1);
    sub_10005EE6C(v9, v4);
    sub_1006024D0((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t *sub_1006056FC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100605754(a1, *(void ***)a2, (void **)(a2 + 8));
  return a1;
}

void sub_10060573C(_Unwind_Exception *a1)
{
  sub_100602474(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100605754(uint64_t *result, void **a2, void **a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      result = sub_1006057E0(v5, v6, v4 + 4, (long long *)v4 + 2);
      uint64_t v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          uint64_t v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1006057E0(uint64_t **a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000C6D50(a1, a2, &v12, &v11, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    BOOL v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_100605884((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_100602D60((uint64_t)v10, 0);
  }
  return v7;
}

void *sub_100605884@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x198uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  result = sub_100601BE4(v6 + 4, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1006058E0(_Unwind_Exception *a1)
{
  sub_100602D60(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_1006058F8(void *a1)
{
  *a1 = off_1019EDB48;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100605944(void *a1)
{
  *a1 = off_1019EDB48;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006059B0(uint64_t a1)
{
  result = (char *)operator new(0x20uLL);
  *(void *)result = off_1019EDB48;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100605A14(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EDB48;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100605A54(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100605A64(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100605AA4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (!v2) {
    return;
  }
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  uint64_t v5 = v4;
  if (a1[2])
  {
    uint64_t v6 = (std::__shared_weak_count *)v3[12];
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      BOOL v8 = v7;
      if (v7)
      {
        uint64_t v9 = v3[11];
        if (v9)
        {
          v24[0] = 0;
          v24[1] = 0;
          uint64_t v23 = (uint64_t *)v24;
          uint64_t v10 = (void *)v3[73];
          char v22 = v7;
          if (v10 != v3 + 74)
          {
            do
            {
              if ((sub_1005FB4A8((uint64_t)v3, (uint64_t)(v10 + 4)) & 1) == 0) {
                sub_10010E5A0(&v23, (void **)v10 + 4, (long long *)v10 + 2, (long long *)(v10 + 7));
              }
              uint64_t v11 = (void *)v10[1];
              if (v11)
              {
                do
                {
                  uint64_t v12 = v11;
                  uint64_t v11 = (void *)*v11;
                }
                while (v11);
              }
              else
              {
                do
                {
                  uint64_t v12 = (void *)v10[2];
                  BOOL v13 = *v12 == (void)v10;
                  uint64_t v10 = v12;
                }
                while (!v13);
              }
              uint64_t v10 = v12;
            }
            while (v12 != v3 + 74);
          }
          long long v14 = (std::__shared_weak_count *)v3[5];
          if (!v14 || (uint64_t v15 = v3[4], (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v17 = v16;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          uint64_t v18 = v23;
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          if (v18 != (uint64_t *)v24)
          {
            do
            {
              long long __dst = 0uLL;
              uint64_t v41 = 0;
              if (*((char *)v18 + 55) < 0)
              {
                sub_10004FC84(&__dst, (void *)v18[4], v18[5]);
              }
              else
              {
                long long __dst = *((_OWORD *)v18 + 2);
                uint64_t v41 = v18[6];
              }
              long long v38 = 0uLL;
              uint64_t v39 = 0;
              if (*((char *)v18 + 79) < 0)
              {
                sub_10004FC84(&v38, (void *)v18[7], v18[8]);
              }
              else
              {
                long long v38 = *(_OWORD *)(v18 + 7);
                uint64_t v39 = v18[9];
              }
              if (SHIBYTE(v39) < 0)
              {
                sub_10004FC84(__p, (void *)v38, *((unint64_t *)&v38 + 1));
              }
              else
              {
                *(_OWORD *)std::string __p = v38;
                uint64_t v37 = v39;
              }
              *(void *)std::string buf = _NSConcreteStackBlock;
              uint64_t v26 = 1174405120;
              int v27 = sub_100601C5C;
              std::string v28 = &unk_1019ED888;
              long long v29 = v3;
              uint64_t v30 = v15;
              std::string v31 = v17;
              atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              if (SHIBYTE(v41) < 0)
              {
                sub_10004FC84(&v32, (void *)__dst, *((unint64_t *)&__dst + 1));
              }
              else
              {
                long long v32 = __dst;
                uint64_t v33 = v41;
              }
              if (SHIBYTE(v39) < 0)
              {
                sub_10004FC84(&v34, (void *)v38, *((unint64_t *)&v38 + 1));
              }
              else
              {
                long long v34 = v38;
                uint64_t v35 = v39;
              }
              (*(void (**)(uint64_t, void **, uint8_t *))(*(void *)v9 + 16))(v9, __p, buf);
              if (SHIBYTE(v37) < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v35) < 0) {
                operator delete((void *)v34);
              }
              if (SHIBYTE(v33) < 0) {
                operator delete((void *)v32);
              }
              if (v31) {
                std::__shared_weak_count::__release_weak(v31);
              }
              if (SHIBYTE(v39) < 0) {
                operator delete((void *)v38);
              }
              if (SHIBYTE(v41) < 0) {
                operator delete((void *)__dst);
              }
              long long v19 = (uint64_t *)v18[1];
              if (v19)
              {
                do
                {
                  uint64_t v20 = v19;
                  long long v19 = (uint64_t *)*v19;
                }
                while (v19);
              }
              else
              {
                do
                {
                  uint64_t v20 = (uint64_t *)v18[2];
                  BOOL v13 = *v20 == (void)v18;
                  uint64_t v18 = v20;
                }
                while (!v13);
              }
              uint64_t v18 = v20;
            }
            while (v20 != (uint64_t *)v24);
          }
          std::__shared_weak_count::__release_weak(v17);
          BOOL v8 = v22;
          sub_10004D2C8(v22);
          sub_10010C0E0((uint64_t)&v23, v24[0]);
          goto LABEL_57;
        }
      }
    }
    else
    {
      BOOL v8 = 0;
    }
    uint64_t v21 = v3[8];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid delegate to delete hidden sims", buf, 2u);
      if (!v8) {
        goto LABEL_58;
      }
      goto LABEL_57;
    }
    if (v8) {
LABEL_57:
    }
      sub_10004D2C8(v8);
  }
LABEL_58:

  sub_10004D2C8(v5);
}

void sub_100605ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  sub_10010C0E0((uint64_t)&a16, a17);
  sub_10004D2C8(a10);
  sub_10004D2C8(v44);
  _Unwind_Resume(a1);
}

uint64_t sub_100605F8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100605FCC()
{
}

void sub_100605FDC()
{
}

void *sub_100605FF0(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDBC8;
  result[1] = v3;
  return result;
}

uint64_t sub_100606038(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDBC8;
  a2[1] = v2;
  return result;
}

void sub_100606064(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if ((*a2 & 0xFF00000000) != 0)
  {
    uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 64);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 5) {
        uint64_t v4 = "???";
      }
      else {
        uint64_t v4 = off_1019EEA08[(int)v2];
      }
      int v5 = 136315138;
      uint64_t v6 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "delete profile fail error: %s", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_100606134(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100606174()
{
}

uint64_t sub_100606180(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (unsigned __int8 *)v2[4];
      if (v3 == (unsigned __int8 *)(v2 + 5)) {
        goto LABEL_20;
      }
      uint64_t v4 = *(unsigned __int8 **)(a1 + 16);
      while ((sub_1006062C4((uint64_t)&v12, v3 + 32, v4 + 32) & 1) != 0)
      {
        int v5 = (unsigned __int8 *)*((void *)v3 + 1);
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            int v5 = *(unsigned __int8 **)v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (unsigned __int8 *)*((void *)v6 + 2);
            BOOL v7 = *(void *)v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        BOOL v8 = (unsigned __int8 *)*((void *)v4 + 1);
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            BOOL v8 = *(unsigned __int8 **)v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (unsigned __int8 *)*((void *)v4 + 2);
            BOOL v7 = *(void *)v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == (unsigned __int8 *)(v2 + 5)) {
          goto LABEL_20;
        }
      }
    }
    sub_10034654C((uint64_t)(v2 + 4), (void *)(a1 + 16));
    uint64_t v10 = v2[3];
    if (v10) {
      (*(void (**)(uint64_t, void *))(*(void *)v10 + 48))(v10, v2 + 4);
    }
  }
LABEL_20:
  sub_10010C0E0(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_1006062C4(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = a2[23];
  size_t v5 = *((void *)a2 + 1);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = a2[23];
  }
  else {
    uint64_t v6 = *((void *)a2 + 1);
  }
  uint64_t v7 = a3[23];
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *((void *)a3 + 1);
  }
  if (v6 != v7) {
    return 0;
  }
  if (v8 >= 0) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = *(unsigned __int8 **)a3;
  }
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a2, v10, v5)) {
      return 0;
    }
  }
  else if (v4)
  {
    uint64_t v11 = a2;
    while (*v11 == *v10)
    {
      ++v11;
      ++v10;
      if (!--v4) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  uint64_t v12 = a2[47];
  if ((v12 & 0x80u) == 0) {
    uint64_t v13 = a2[47];
  }
  else {
    uint64_t v13 = *((void *)a2 + 4);
  }
  uint64_t v14 = a3[47];
  int v15 = (char)v14;
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *((void *)a3 + 4);
  }
  if (v13 != v14) {
    return 0;
  }
  long long v16 = (const void **)(a2 + 24);
  long long v19 = (unsigned __int8 *)*((void *)a3 + 3);
  uint64_t v18 = a3 + 24;
  uint64_t v17 = v19;
  if (v15 >= 0) {
    uint64_t v20 = v18;
  }
  else {
    uint64_t v20 = v17;
  }
  if ((v12 & 0x80) != 0) {
    return memcmp(*v16, v20, *((void *)a2 + 4)) == 0;
  }
  if (!a2[47]) {
    return 1;
  }
  uint64_t v21 = v12 - 1;
  do
  {
    int v23 = *(unsigned __int8 *)v16;
    long long v16 = (const void **)((char *)v16 + 1);
    int v22 = v23;
    int v25 = *v20++;
    int v24 = v25;
    BOOL v27 = v21-- != 0;
    uint64_t result = v22 == v24;
  }
  while (v22 == v24 && v27);
  return result;
}

void sub_1006063F0(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v12 = 0;
  size_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v12, a2);
  if (!*v5)
  {
    uint64_t v6 = v5;
    uint64_t v11 = 0;
    uint64_t v7 = (char *)operator new(0x50uLL);
    v10[0] = v7;
    v10[1] = a1 + 1;
    int v8 = v7 + 32;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v8, *(void **)a3, *(void *)(a3 + 8));
      uint64_t v9 = (uint64_t *)v10[0];
    }
    else
    {
      *(_OWORD *)int v8 = *(_OWORD *)a3;
      *((void *)v7 + 6) = *(void *)(a3 + 16);
      uint64_t v9 = (uint64_t *)v7;
    }
    *(_OWORD *)(v7 + 56) = *(_OWORD *)(a3 + 24);
    *((void *)v7 + 9) = *(void *)(a3 + 40);
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 4sub_100602D60((uint64_t)&a9, 0) = 0;
    *(void *)(a3 + 24) = 0;
    LOBYTE(v11) = 1;
    sub_100046C38(a1, v12, v6, v9);
    v10[0] = 0;
    sub_10010E764((uint64_t)v10, 0);
  }
}

void sub_1006064D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1006064EC(void *a1)
{
  *a1 = off_1019EDC58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100606538(void *a1)
{
  *a1 = off_1019EDC58;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006065A4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019EDC58;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100606608(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EDC58;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100606648(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100606658(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const void **sub_100606698(void *a1, const void **a2, void **a3)
{
  uint64_t v13 = *a2;
  *a2 = 0;
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7 && a1[2])
    {
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v15 = 0;
      int v8 = *(NSObject **)(v6 + 64);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = __p;
        if (v15 < 0) {
          uint64_t v9 = (void **)__p[0];
        }
        if (*((char *)a3 + 23) >= 0) {
          uint64_t v10 = a3;
        }
        else {
          uint64_t v10 = *a3;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&buf[4] = v9;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I get geofence data udpate topic %s iccid %s", buf, 0x16u);
      }
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(buf, *a3, (unint64_t)a3[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)a3;
        *(void *)&buf[16] = a3[2];
      }
      sub_1005F72F4(v6, (long long *)buf, 0, 1);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v15) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.pnw.ctr");
  uint64_t v11 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (!v7) {
      return sub_1000558F4(&v13);
    }
    goto LABEL_23;
  }
  *(_WORD *)std::string buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid CellularPlanPrivateNetworksController (weak_ptr)", buf, 2u);
  if (v7) {
LABEL_23:
  }
    sub_10004D2C8(v7);
  return sub_1000558F4(&v13);
}

void sub_1006068A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10004D2C8(v23);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100606910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100606950()
{
}

void sub_100606960()
{
}

void *sub_100606974(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDCE8;
  result[1] = v3;
  return result;
}

uint64_t sub_1006069BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDCE8;
  a2[1] = v2;
  return result;
}

void sub_1006069E8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *a2;
    v5[0] = 67109120;
    v5[1] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I subscribe push notification of geofence data update status:%d", (uint8_t *)v5, 8u);
  }
}

uint64_t sub_100606A8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100606ACC()
{
}

char *sub_100606AD8(uint64_t **a1, void **a2, long long *a3, long long *a4)
{
  uint64_t v12 = 0;
  uint64_t v7 = (char **)sub_100046ED4((uint64_t)a1, &v12, a2);
  int v8 = *v7;
  if (!*v7)
  {
    uint64_t v9 = (uint64_t **)v7;
    memset(v11, 0, sizeof(v11));
    sub_100606B88((uint64_t)a1, a3, a4, v11);
    sub_100046C38(a1, v12, v9, (uint64_t *)v11[0]);
    int v8 = v11[0];
    v11[0] = 0;
    sub_10030D770((uint64_t)v11, 0);
  }
  return v8;
}

char *sub_100606B88@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, long long *a3@<X2>, char **a4@<X8>)
{
  uint64_t v7 = (char *)(a1 + 8);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  int v8 = (char *)operator new(0x80uLL);
  *a4 = v8;
  a4[1] = v7;
  *((unsigned char *)a4 + 16) = 0;
  uint64_t result = sub_100606C04(v8 + 32, a2, a3);
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_100606BEC(_Unwind_Exception *a1)
{
  sub_10030D770(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_100606C04(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v5;
  }
  long long v6 = *a3;
  *((void *)__dst + 5) = *((void *)a3 + 2);
  *(_OWORD *)(__dst + 24) = v6;
  if (*((char *)a3 + 47) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a3 + 3), *((void *)a3 + 4));
  }
  else
  {
    long long v7 = *(long long *)((char *)a3 + 24);
    *((void *)__dst + 8) = *((void *)a3 + 5);
    *((_OWORD *)__dst + 3) = v7;
  }
  int v8 = __dst + 72;
  if (*((char *)a3 + 71) < 0)
  {
    sub_10004FC84(v8, *((void **)a3 + 6), *((void *)a3 + 7));
  }
  else
  {
    long long v9 = a3[3];
    *((void *)__dst + 11) = *((void *)a3 + 8);
    *(_OWORD *)int v8 = v9;
  }
  return __dst;
}

void sub_100606CCC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100606D04()
{
}

void *sub_100606D18(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDD68;
  result[1] = v3;
  return result;
}

uint64_t sub_100606D60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDD68;
  a2[1] = v2;
  return result;
}

void sub_100606D8C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if ((*a2 & 0xFF00000000) != 0)
  {
    uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 64);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 5) {
        int v4 = "???";
      }
      else {
        int v4 = off_1019EEA08[(int)v2];
      }
      int v5 = 136315138;
      long long v6 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Entitlement profile failed to load with error [%s]", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_100606E5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100606E9C()
{
}

uint64_t *sub_100606EA8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  int v4 = a1;
  int v5 = v1;
  uint64_t v2 = *v1;
  v8[0] = 1;
  long long v9 = 0u;
  uint64_t v10 = 0;
  v8[1] = v2 + 552;
  sub_100346B40((uint64_t)&v9, v2 + 584);
  std::operator+<char>();
  sub_10010F808((uint64_t **)&v9, &__p);
  if (v7 < 0) {
    operator delete(__p);
  }
  if (!v10) {
    sub_1005F67C8(v2);
  }
  sub_100606180((uint64_t)v8);
  sub_1001102C4((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100606F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
}

void sub_100606FB4()
{
}

void *sub_100606FC8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDDE8;
  result[1] = v3;
  return result;
}

uint64_t sub_100607010(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDDE8;
  a2[1] = v2;
  return result;
}

void sub_10060703C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 40);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10060711C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060715C()
{
}

void sub_100607168(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 64);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I dynamic data switch delay timer expired", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 288);
  *(void *)(v1 + 288) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(v1 + 392);
  *(void *)(v1 + 392) = 0;
  *(void *)std::string buf = v4;
  sub_10007CA64((const void **)buf);
  (*(void (**)(double))(**(void **)(v1 + 136) + 360))(0.0);
  sub_1005EEEF0(v1);
  sub_1005F0CCC(v1);
  operator delete();
}

void sub_100607290()
{
}

void sub_1006072C0()
{
}

void *sub_1006072D4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDE68;
  result[1] = v3;
  return result;
}

uint64_t sub_10060731C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDE68;
  a2[1] = v2;
  return result;
}

void sub_100607348(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 40);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100607428(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100607468()
{
}

void sub_100607474(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (*(_DWORD *)(v1 + 400) <= 4u && *(_DWORD *)(v1 + 304) == 1)
  {
    (*(void (**)(void))(**(void **)(v1 + 104) + 72))(*(void *)(v1 + 104));
    ++*(_DWORD *)(v1 + 400);
  }
  operator delete();
}

void sub_100607510()
{
}

void sub_100607540()
{
}

void *sub_100607554(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDEE8;
  result[1] = v3;
  return result;
}

uint64_t sub_10060759C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDEE8;
  a2[1] = v2;
  return result;
}

void sub_1006075C8(uint64_t a1)
{
  memset(v11, 0, sizeof(v11));
  rest::read_rest_value();
  uint64_t v2 = *(void *)(a1 + 8);
  long long v12 = *(_OWORD *)&v11[1];
  uint64_t v13 = 0;
  memset(&v16, 0, sizeof(v16));
  sub_1000631F4(&v16, *(void *)(v2 + 504), *(void *)(v2 + 512), 0);
  uint64_t v3 = sub_100046F68(v2 + 216, (void **)&v16.__r_.__value_.__l.__data_);
  uint64_t v4 = *(NSObject **)(v2 + 64);
  if ((void **)(v2 + 224) == v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(v2 + 64), OS_LOG_TYPE_ERROR))
    {
      long long v9 = &v16;
      if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v9 = (std::string *)v16.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "iccid [%s] not found from bundleInfo change on slot [%d]", (uint8_t *)&buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(*(os_log_t *)(v2 + 64), OS_LOG_TYPE_DEFAULT))
    {
      int v5 = SHIBYTE(v16.__r_.__value_.__r.__words[2]);
      std::string::size_type v6 = v16.__r_.__value_.__r.__words[0];
      uint64_t v7 = asString();
      int v8 = &v16;
      if (v5 < 0) {
        int v8 = (std::string *)v6;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I re-evaluating carrier bundle for [%s] for bundleInfo change [%s]", (uint8_t *)&buf, 0x16u);
    }
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v16;
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v16;
    uint64_t v10 = sub_100602C14(v2 + 216, (void **)&v16.__r_.__value_.__l.__data_, (long long **)&buf);
    sub_1006000E4(v2, (uint64_t)&__p, (uint64_t)(v10 + 7));
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_1005EDF84(v2);
    sub_1005EE984(v2);
    sub_1005F64A0((void *)v2);
    sub_1005EEEF0(v2);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v16;
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __dst;
    }
    int v18 = 5;
    sub_100007714(v2, (uint64_t *)&buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    sub_1005F1E60(v2);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)v12);
  }
}

void sub_100607948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a42 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v49 - 113) < 0) {
    operator delete(*(void **)(v49 - 136));
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100607A04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100607A44()
{
}

void sub_100607A54()
{
}

__n128 sub_100607A68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EDF68;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100607ABC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EDF68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100607AF4(uint64_t a1, xpc_object_t *a2)
{
  sub_1001F299C(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100607B70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100607BB0()
{
}

void sub_100607BC0()
{
}

void *sub_100607BD4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EDFE8;
  result[1] = v3;
  return result;
}

uint64_t sub_100607C1C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EDFE8;
  a2[1] = v2;
  return result;
}

void sub_100607C48(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  int v5 = a2 + 1;
  std::string::size_type v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      std::string __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          std::string v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          std::string v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          std::string::size_type v6 = v16;
        }
        while (!v17);
      }
      std::string::size_type v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/private_network_sims_active");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100607F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100607FC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100608008()
{
}

void sub_100608018()
{
}

void *sub_10060802C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE078;
  result[1] = v3;
  return result;
}

uint64_t sub_100608074(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE078;
  a2[1] = v2;
  return result;
}

void sub_1006080A0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/in_private_network_mode");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100608150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100608198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006081D8()
{
}

void sub_1006081E4(char **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  sub_100058DB0(&__p, *a1);
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  xpc_object_t v9 = operator new(0x28uLL);
  void *v9 = off_1019EE0F8;
  v9[1] = a1;
  v9[2] = a3;
  v9[3] = v8;
  v9[4] = v7;
  v12[3] = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p);
  }
}

void sub_1006082BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1006082F4()
{
}

__n128 sub_100608308(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_1019EE0F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10060835C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE0F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100608394(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006083D4()
{
}

void sub_1006083E4()
{
}

__n128 sub_1006083F8(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_1019EE178;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10060844C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100608484(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  char v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *uint64_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10031A644((uint64_t)v3, a2);
  std::string::size_type v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    std::string::size_type v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10030AAD0((uint64_t)&v9, v10);
}

void sub_100608544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10060855C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060859C()
{
}

void sub_1006085AC()
{
}

void *sub_1006085C0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE1F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100608608(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE1F8;
  a2[1] = v2;
  return result;
}

void sub_100608634(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10034C2C4(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/bound_sims");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1006086D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10060871C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060875C()
{
}

void sub_10060876C()
{
}

__n128 sub_100608780(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EE288;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006087D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE288;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10060880C(void *a1, xpc_object_t *a2)
{
  char v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *char v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *char v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  xpc_object_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    xpc_object_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100608904(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100608944()
{
}

void sub_100608954()
{
}

void *sub_100608968(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE308;
  result[1] = v3;
  return result;
}

uint64_t sub_1006089B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE308;
  a2[1] = v2;
  return result;
}

void sub_1006089DC(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1006089E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100608A24()
{
}

void sub_100608A34()
{
}

void *sub_100608A48(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE388;
  result[1] = v3;
  return result;
}

uint64_t sub_100608A90(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE388;
  a2[1] = v2;
  return result;
}

void sub_100608ABC()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/enable_5gsa_for_private_network");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100608B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100608BA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100608BE4()
{
}

void *sub_100608BF0(void *a1)
{
  *a1 = off_1019EE418;
  char v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100608C3C(void *a1)
{
  *a1 = off_1019EE418;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100608CA8(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019EE418;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100608D0C(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019EE418;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100608D4C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100608D5C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100608D9C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[1])
      {
        std::string::size_type v6 = *(NSObject **)(v3 + 64);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received Geo MCC request from modem", v7, 2u);
        }
        if (sub_1005F5A04(v3)) {
          sub_1005F5BD0(v3);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100608E44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100608E58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100608E98()
{
}

void sub_100608EA8()
{
}

__n128 sub_100608EBC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EE498;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100608F10(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE498;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100608F48(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_100608FD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100609010()
{
}

void sub_100609020()
{
}

__n128 sub_100609034(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EE518;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100609088(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE518;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006090C0(void *a1, rest::WRMRecommendation *a2, const xpc::object *a3)
{
  uint64_t v4 = (rest *)a1[1];
  uint64_t v5 = *(void *)v4;
  int v11 = *((_DWORD *)v4 + 2);
  uint64_t v10 = v5;
  rest::read_rest_value(v4, a2, a3);
  uint64_t v6 = (uint64_t (*)(void *, uint64_t *))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, uint64_t *))(*v8 + v6);
  }
  return v6(v8, &v10);
}

uint64_t sub_10060914C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060918C()
{
}

void sub_10060919C()
{
}

void *sub_1006091B0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE598;
  result[1] = v3;
  return result;
}

uint64_t sub_1006091F8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE598;
  a2[1] = v2;
  return result;
}

void sub_100609224(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/pnw_sub_preference");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_1006092D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10060931C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060935C()
{
}

void *sub_100609368(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1006095D0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1006095E0()
{
}

__n128 sub_1006095F4(uint64_t a1)
{
  int v2 = (char *)operator new(0x20uLL);
  *(void *)int v2 = off_1019EE628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100609648(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EE628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100609680(void *a1)
{
  uint64_t v5 = 0x2800000000;
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  rest::read_rest_value();
  int v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    int v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_100609718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100609734(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100609774()
{
}

uint64_t sub_100609780(uint64_t a1)
{
  *(void *)a1 = off_1019EE6A8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1006097D0(uint64_t a1)
{
  *(void *)a1 = off_1019EE6A8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100609840(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019EE6A8;
  v2[1] = v3;
  uint64_t v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)uint64_t v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_1006098B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1006098CC(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_1019EE6A8;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_10060991C(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100609930(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_100609974(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 64);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v5 = a1 + 16;
      uint64_t v4 = v6;
      if (*(char *)(v5 + 23) < 0) {
        uint64_t v5 = v4;
      }
      int v7 = 136315394;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      uint64_t v10 = asString();
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "permanent slot switch %s failed with error %s", (uint8_t *)&v7, 0x16u);
    }
  }
}

uint64_t sub_100609A50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100609A90()
{
}

uint64_t sub_100609A9C(uint64_t a1)
{
  *(void *)a1 = off_1019EE728;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100609AEC(uint64_t a1)
{
  *(void *)a1 = off_1019EE728;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100609B5C(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019EE728;
  v2[1] = v3;
  uint64_t v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)uint64_t v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_100609BD4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100609BE8(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_1019EE728;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_100609C38(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100609C4C(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_100609C90(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!*a2)
  {
    uint64_t v8 = *(NSObject **)(v3 + 64);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v10 = a1 + 16;
    uint64_t v9 = v11;
    if (*(char *)(v10 + 23) < 0) {
      uint64_t v10 = v9;
    }
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v10;
    __int16 v20 = 2080;
    uint64_t v21 = asString();
    uint64_t v12 = "permanent slot switch %s failed with error %s";
    uint64_t v13 = v8;
    uint32_t v14 = 22;
    goto LABEL_18;
  }
  if ((void **)(v3 + 224) == sub_100046F68(v3 + 216, (void **)(a1 + 16)))
  {
    uint64_t v15 = *(NSObject **)(v3 + 64);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a1 + 39) >= 0) {
      uint64_t v16 = a1 + 16;
    }
    else {
      uint64_t v16 = *(void *)(a1 + 16);
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v16;
    uint64_t v12 = "Couldn't find %s.";
    uint64_t v13 = v15;
    uint32_t v14 = 12;
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, __p, v14);
    return;
  }
  uint64_t v4 = sub_10005DDEC(v3 + 216, (void **)(a1 + 16));
  if (*(unsigned char *)(v4 + 200))
  {
    uint64_t v5 = (unsigned int *)v4;
    uint64_t v6 = *(void *)(v3 + 152);
    sub_100058DB0(__p, "");
    uint64_t v18 = 0;
    char v17 = 0;
    (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t *, char *, void))(*(void *)v6 + 40))(v6, 5, __p, &v18, &v17, *v5);
    if (v22 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v7 = *(void *)(v3 + 152);
    sub_100058DB0(__p, "");
    uint64_t v18 = 0;
    char v17 = 0;
    (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t *, char *, void))(*(void *)v7 + 40))(v7, 3, __p, &v18, &v17, *v5);
    if (v22 < 0) {
      operator delete(*(void **)__p);
    }
  }
}

void sub_100609ED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100609EF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100609F38()
{
}

void sub_100609F48()
{
}

void *sub_100609F5C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE7A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100609FA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE7A8;
  a2[1] = v2;
  return result;
}

void sub_100609FD0(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *(void **)a2;
  uint64_t v2 = v16;
  long long v17 = *(_OWORD *)(a2 + 8);
  uint64_t v3 = (void *)v17;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v2 != v3)
  {
    (***(void (****)(uint8_t *__return_ptr))(v4 + 72))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v20 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v13 + 504))(v13, 3, &v16);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        if (v19) {
          sub_10004D2C8(v19);
        }
        uint64_t v2 = v16;
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  uint64_t v15 = *(NSObject **)(v4 + 64);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "getIntMccsForIso failed", buf, 2u);
  }
LABEL_17:
  if (v2)
  {
    *(void *)&long long v17 = v2;
    operator delete(v2);
  }
}

void sub_10060A194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060A1E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060A220()
{
}

void *sub_10060A22C(void *a1)
{
  *a1 = off_1019EE838;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10041A970(a1 + 4);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10060A28C(void *a1)
{
  *a1 = off_1019EE838;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10041A970(a1 + 4);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_10060A30C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_1019EE838;
  sub_10060A814((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10060A360(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10060A374(uint64_t a1, void *a2)
{
  *a2 = off_1019EE838;
  return sub_10060A814((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10060A3A0(uint64_t a1)
{
}

void sub_10060A3A8(void *a1)
{
  sub_10060A8A0(a1 + 1);

  operator delete(a1);
}

void sub_10060A3E4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  memset(__p, 0, 24);
  xpc::dyn_cast_or_default();
  locale = v28.__locale_;
  *(void *)xpc_object_t v26 = v29;
  *(void *)&v26[7] = *(void *)((char *)&v29 + 7);
  unsigned __int8 v27 = HIBYTE(v29);
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    p_locale = &locale;
    if (v29 < 0) {
      p_locale = v28.__locale_;
    }
    uint64_t v5 = *(void **)(a1 + 80);
    uint64_t v6 = *(void **)(a1 + 88);
    LODWORD(__p[0]) = 136315651;
    *(void **)((char *)__p + 4) = p_locale;
    WORD2(__p[1]) = 2049;
    *(void **)((char *)&__p[1] + 6) = v5;
    HIWORD(__p[2]) = 2049;
    __p[3] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CTLocationBasedCountryDetermination: Receiving ISO '%s' for %{private}f.%{private}f", (uint8_t *)__p, 0x20u);
  }
  std::locale::locale(&v28);
  uint64_t v7 = v27;
  uint64_t v8 = (char *)&locale;
  if ((v27 & 0x80u) != 0)
  {
    uint64_t v8 = (char *)locale;
    uint64_t v7 = *(void *)v26;
  }
  __p[0] = v8;
  __p[1] = &v8[v7];
  sub_1003563F0((char **)__p, &v28);
  std::locale::~locale(&v28);
  (*(void (**)(std::locale *__return_ptr))(**(void **)(a1 + 64) + 96))(&v28);
  memset(__p, 0, 24);
  uint64_t v9 = v28.__locale_;
  for (i = (std::locale::__imp *)v29; v9 != i; uint64_t v9 = (std::locale::__imp *)((char *)v9 + 24))
  {
    __int16 v11 = std::stoi((const std::string *)v9, 0, 10);
    __int16 v12 = v11;
    uint64_t v13 = (char *)__p[1];
    if (__p[1] >= __p[2])
    {
      uint64_t v15 = (char *)__p[0];
      int64_t v16 = (char *)__p[1] - (char *)__p[0];
      if ((char *)__p[1] - (char *)__p[0] <= -3) {
        sub_10006A748();
      }
      uint64_t v17 = v16 >> 1;
      if ((void *)((char *)__p[2] - (char *)__p[0]) <= (void *)((v16 >> 1) + 1)) {
        int64_t v18 = v17 + 1;
      }
      else {
        int64_t v18 = (char *)__p[2] - (char *)__p[0];
      }
      if ((void *)((char *)__p[2] - (char *)__p[0]) >= (void *)0x7FFFFFFFFFFFFFFELL) {
        uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v19 = v18;
      }
      if (v19)
      {
        unint64_t v20 = (char *)sub_10006E5B8((uint64_t)&__p[2], v19);
        uint64_t v15 = (char *)__p[0];
        uint64_t v13 = (char *)__p[1];
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[2 * v17];
      *(_WORD *)uint64_t v21 = v12;
      char v14 = v21 + 2;
      while (v13 != v15)
      {
        __int16 v22 = *((_WORD *)v13 - 1);
        v13 -= 2;
        *((_WORD *)v21 - 1) = v22;
        v21 -= 2;
      }
      __p[0] = v21;
      __p[1] = v14;
      __p[2] = &v20[2 * v19];
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_WORD *)__p[1] = v11;
      char v14 = v13 + 2;
    }
    __p[1] = v14;
  }
  uint64_t v30 = &v28;
  sub_100047F64((void ***)&v30);
  long long v29 = 0uLL;
  v28.__locale_ = 0;
  sub_1003A10E0(&v28, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 1);
  uint64_t v23 = *(void *)(a1 + 56);
  if (!v23) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, std::locale *))(*(void *)v23 + 48))(v23, &v28);
  if (v28.__locale_)
  {
    *(std::locale *)&long long v29 = v28;
    operator delete(v28.__locale_);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((char)v27 < 0) {
    operator delete(locale);
  }
  xpc_release(object);
}

void sub_10060A708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::locale a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10060A7C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060A808()
{
}

uint64_t sub_10060A814(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10041F6B4(a1 + 24, a2 + 24);
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  return a1;
}

void sub_10060A888(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10060A8A0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10041A970(a1 + 3);
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_10060A8FC()
{
}

void *sub_10060A910(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EE8B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10060A958(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EE8B8;
  a2[1] = v2;
  return result;
}

void sub_10060A984(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)a2;
  uint64_t v5 = (void *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v9 = *(uint64_t **)a2;
  uint64_t v10 = v4;
  uint64_t v11 = *(void *)(a2 + 16);
  if (v11)
  {
    *(void *)(v4 + 16) = &v10;
    *(void *)a2 = v5;
    *uint64_t v5 = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    uint64_t v9 = &v10;
    uint64_t v3 = &v10;
  }
  LOBYTE(v12) = 0;
  char v25 = 0;
  int v6 = *(unsigned __int8 *)(a2 + 160);
  if (*(unsigned char *)(a2 + 160))
  {
    sub_10060B034((uint64_t)&v12, a2 + 24);
    char v25 = 1;
    uint64_t v3 = v9;
    uint64_t v4 = v10;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v26 = v7;
  unsigned __int8 v27 = v3;
  v28[0] = v4;
  v28[1] = v11;
  if (v11)
  {
    *(void *)(v4 + 16) = v28;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    unsigned __int8 v27 = v28;
  }
  LOBYTE(v29) = 0;
  char v41 = 0;
  if (v6)
  {
    int v29 = v12;
    long long v30 = v13;
    long long v13 = 0uLL;
    long long v32 = v15;
    uint64_t v31 = v14;
    uint64_t v33 = v16;
    uint64_t v14 = 0;
    long long v15 = 0uLL;
    uint64_t v16 = 0;
    long long v34 = v17;
    long long v17 = 0uLL;
    uint64_t v35 = v18;
    uint64_t v37 = v20;
    uint64_t v38 = v21;
    long long v36 = v19;
    uint64_t v18 = 0;
    long long v19 = 0uLL;
    uint64_t v20 = 0;
    uint64_t v39 = v22;
    v40[0] = v23;
    v40[1] = v24;
    if (v24)
    {
      *(void *)(v23 + 16) = v40;
      __int16 v22 = &v23;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
    }
    else
    {
      uint64_t v39 = v40;
    }
    char v41 = 1;
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 40);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10060AC48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10060AC88()
{
}

uint64_t *sub_10060AC94(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(long long **)(v1 + 8);
  if (v3 != (long long *)(v1 + 16))
  {
    do
    {
      sub_1006021B0(__p, v3 + 2, (uint64_t)v3 + 56);
      sub_1006053BC(v2 + 216, __p, (uint64_t)__p);
      sub_10006544C((uint64_t)&v16);
      if (SHIBYTE(v15) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v4 = (long long *)*((void *)v3 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = *(long long **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (long long *)*((void *)v3 + 2);
          BOOL v6 = *(void *)v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
    }
    while (v5 != (long long *)(v1 + 16));
  }
  if (*(unsigned char *)(v1 + 168))
  {
    if (*(_DWORD *)(v1 + 32))
    {
      v12[0] = 0;
      v12[1] = 0;
      uint64_t v13 = 0;
      sub_100058DB0(v12, "NoPnwIdentifier");
      if (!*(unsigned char *)(v1 + 168)) {
        sub_10016C840();
      }
      if (*(_DWORD *)(v1 + 32) == 2)
      {
        if (SHIBYTE(v13) < 0)
        {
          v12[1] = (void *)17;
          uint64_t v7 = (char *)v12[0];
        }
        else
        {
          HIBYTE(v13) = 17;
          uint64_t v7 = (char *)v12;
        }
        strcpy(v7, "OffloadIdentifier");
        if (!*(unsigned char *)(v1 + 168)) {
          sub_10016C840();
        }
      }
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(__p, v12[0], (unint64_t)v12[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v12;
        uint64_t v15 = v13;
      }
      sub_10006891C((uint64_t)&v16, v1 + 32);
      sub_100604CA0(v2 + 240, __p, (uint64_t)__p);
      sub_10005CD90((uint64_t)v25, v25[1]);
      if (v24 < 0) {
        operator delete(v23);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(v19);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
      if (SHIBYTE(v15) < 0) {
        operator delete(__p[0]);
      }
      sub_1005EF3A4(v2);
      if (SHIBYTE(v13) < 0) {
        operator delete(v12[0]);
      }
    }
    else
    {
      uint64_t v8 = *(NSObject **)(v2 + 64);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I discard profile with type of kUnknown from migration", (uint8_t *)__p, 2u);
      }
    }
  }
  sub_10060AFCC(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_10060AF08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10060AFCC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10060AFCC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10060222C(v1 + 32);
    sub_100602474(v1 + 8, *(void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_10060B034(uint64_t result, uint64_t a2)
{
  *(_DWORD *)__n128 result = *(_DWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(result + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(result + 32) = v3;
  *(void *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  long long v4 = *(_OWORD *)(a2 + 56);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(result + 56) = v4;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  long long v5 = *(_OWORD *)(a2 + 80);
  *(void *)(result + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(result + 8sub_10010E764((uint64_t)&a9, 0) = v5;
  *(void *)(a2 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(result + 104) = *(void *)(a2 + 104);
  *(void *)(result + 112) = *(void *)(a2 + 112);
  BOOL v6 = (void *)(a2 + 120);
  uint64_t v7 = *(void *)(a2 + 120);
  *(void *)(result + 12sub_10010E764((uint64_t)&a9, 0) = v7;
  uint64_t v8 = result + 120;
  uint64_t v9 = *(void *)(a2 + 128);
  *(void *)(result + 128) = v9;
  if (v9)
  {
    *(void *)(v7 + 16) = v8;
    *(void *)(a2 + 112) = v6;
    *BOOL v6 = 0;
    *(void *)(a2 + 128) = 0;
  }
  else
  {
    *(void *)(result + 112) = v8;
  }
  return result;
}

void *sub_10060B0E0(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_10060B164(uint64_t *result, uint64_t *a2, int a3, uint64_t *a4)
{
  long long v5 = (uint64_t **)a2;
  BOOL v6 = (uint64_t **)result;
  uint64_t v7 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (int v8 = *((_DWORD *)a2 + 7), v8 > a3))
  {
    uint64_t v9 = (uint64_t *)*a2;
    if ((uint64_t *)*result == a2)
    {
      uint64_t v11 = a2;
LABEL_16:
      if (v9) {
        long long v17 = (uint64_t **)v11;
      }
      else {
        long long v17 = (uint64_t **)a2;
      }
      if (v9) {
        uint64_t v13 = (uint64_t **)(v11 + 1);
      }
      else {
        uint64_t v13 = (uint64_t **)a2;
      }
      if (*v13) {
        return result;
      }
      long long v5 = v17;
LABEL_43:
      uint64_t v23 = (uint64_t *)operator new(0x28uLL);
      *(uint64_t *)((char *)v23 + 28) = *a4;
      return sub_100046C38(v6, (uint64_t)v5, v13, v23);
    }
    if (v9)
    {
      uint64_t v10 = (uint64_t *)*a2;
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        uint64_t v11 = (uint64_t *)v15[2];
        BOOL v16 = *v11 == (void)v15;
        uint64_t v15 = v11;
      }
      while (v16);
    }
    if (*((_DWORD *)v11 + 7) < a3) {
      goto LABEL_16;
    }
    char v18 = *v7;
    uint64_t v13 = (uint64_t **)(result + 1);
    long long v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_43;
    }
    while (1)
    {
      while (1)
      {
        long long v5 = (uint64_t **)v18;
        int v19 = *((_DWORD *)v18 + 7);
        if (v19 <= a3) {
          break;
        }
        char v18 = (uint64_t *)*v18;
        uint64_t v13 = v5;
        if (!*v5) {
          goto LABEL_43;
        }
      }
      if (v19 >= a3) {
        break;
      }
      char v18 = (uint64_t *)v18[1];
      if (!v18) {
        goto LABEL_30;
      }
    }
  }
  else
  {
    if (v8 >= a3) {
      return result;
    }
    uint64_t v13 = (uint64_t **)(a2 + 1);
    int v12 = (uint64_t *)a2[1];
    if (v12)
    {
      do
      {
        uint64_t v13 = (uint64_t **)v12;
        int v12 = (uint64_t *)*v12;
        long long v5 = v13;
        uint64_t v14 = v13;
      }
      while (v12);
    }
    else
    {
      uint64_t v14 = (uint64_t **)a2;
      do
      {
        char v20 = (uint64_t *)v14;
        uint64_t v14 = (uint64_t **)v14[2];
      }
      while (*v14 != v20);
    }
    if (v14 == v7) {
      goto LABEL_43;
    }
    if (*((_DWORD *)v14 + 7) > a3) {
      goto LABEL_43;
    }
    uint64_t v21 = *v7;
    uint64_t v13 = (uint64_t **)(result + 1);
    long long v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_43;
    }
    while (1)
    {
      while (1)
      {
        long long v5 = (uint64_t **)v21;
        int v22 = *((_DWORD *)v21 + 7);
        if (v22 <= a3) {
          break;
        }
        uint64_t v21 = (uint64_t *)*v21;
        uint64_t v13 = v5;
        if (!*v5) {
          goto LABEL_43;
        }
      }
      if (v22 >= a3) {
        break;
      }
      uint64_t v21 = (uint64_t *)v21[1];
      if (!v21)
      {
LABEL_30:
        uint64_t v13 = v5 + 1;
        goto LABEL_43;
      }
    }
  }
  return result;
}

uint64_t **sub_10060B338(uint64_t **a1, int a2, _DWORD *a3)
{
  BOOL v6 = a1 + 1;
  long long v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        long long v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      long long v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x28uLL);
    v9[7] = *a3;
    *((_WORD *)v9 + 16) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_10060B3E4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    long long v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      long long v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_25;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7)
           && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v4 + 32)
           && *((unsigned __int8 *)v3 + 33) == *((unsigned __int8 *)v4 + 33))
      {
        long long v5 = (void *)v3[1];
        BOOL v6 = v3;
        if (v5)
        {
          do
          {
            long long v3 = v5;
            long long v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            long long v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            BOOL v6 = v3;
          }
          while (!v7);
        }
        int v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            int v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_25;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_1000346F8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    uint64_t v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      *uint64_t v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_25:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t **sub_10060B564(uint64_t **result, void *a2, void *a3)
{
  long long v5 = result;
  if (result[2])
  {
    BOOL v6 = *result;
    BOOL v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    uint64_t v14 = result;
    uint64_t v15 = v8;
    BOOL v16 = v8;
    if (v8)
    {
      uint64_t v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          *((_DWORD *)v8 + 7) = *((_DWORD *)v9 + 7);
          *((_WORD *)v8 + 16) = *((_WORD *)v9 + 16);
          sub_1001A0944(v5, (uint64_t)v8);
          int v8 = v15;
          BOOL v16 = v15;
          if (v15) {
            uint64_t v15 = sub_1000EA590((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_1001A0A0C(v5, (void *)((char *)a2 + 28));
      uint64_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_10060B6BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10060B6E0(uint64_t a1)
{
  return a1;
}

void sub_10060B70C()
{
}

void sub_10060B768()
{
}

void *sub_10060B78C(void *a1)
{
  *a1 = off_1019F0770;
  long long v2 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "pnw.geo.manager");
  sub_10060B854(v2, "PrivateNetworkGeofenceManager", QOS_CLASS_USER_INITIATED, &v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = off_1019EEAA8;
  a1[8] = 0;
  a1[7] = 0;
  a1[6] = a1 + 7;
  return a1;
}

void sub_10060B840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10060B854(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_10060B8BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10060B8F4(uint64_t a1)
{
  *(void *)a1 = off_1019EEAA8;
  sub_10060C954(*(void **)(a1 + 56));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10060B954(uint64_t a1)
{
  sub_10060B8F4(a1);

  operator delete();
}

void sub_10060B98C(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  OsLogContext v4 = (uint64_t **)a2;
  if (*(void *)(a4 + 24))
  {
    *(void *)std::string buf = a1;
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&buf[8], (void *)*a2, a2[1]);
    }
    else
    {
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a2;
      uint64_t v13 = a2[2];
    }
    uint64_t v9 = a3 + 1;
    uint64_t v10 = a3[1];
    uint64_t v14 = (uint64_t *)*a3;
    uint64_t v15 = v10;
    if (a3[2])
    {
      *(void *)(v10 + 16) = &v15;
      *a3 = v9;
      void *v9 = 0;
      a3[2] = 0;
    }
    else
    {
      uint64_t v14 = &v15;
    }
    sub_100023950((uint64_t)&v17, a4);
    BOOL v11 = *(std::__shared_weak_count **)(a1 + 16);
    if (v11)
    {
      if (std::__shared_weak_count::lock(v11)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)v4 + 23) < 0) {
      OsLogContext v4 = (uint64_t **)*v4;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&buf[4] = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid callback for installNewGeofencesForIccid %s", buf, 0xCu);
  }
}

void sub_10060BC1C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10060BC2C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10060BD84(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (*(void *)(a2 + 24))
  {
    *(void *)std::string buf = a1;
    *(double *)&uint8_t buf[8] = a3;
    double v8 = a4;
    sub_10060DCE4((uint64_t)&v9, a2);
    long long v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid callback for getBestGeofencesForIccid", buf, 2u);
  }
}

void sub_10060BF14(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10060BF24(uint64_t a1, uint64_t a2, double *a3, double *a4)
{
  double v6 = *a3;
  double v7 = -90.0;
  if (*a3 < -90.0 || (double v8 = 90.0, v6 > 90.0) || (v9 = -180.0, *a4 < -180.0) || (v10 = 180.0, *a4 > 180.0))
  {
    uint64_t v23 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      double v24 = *a4;
      *(_DWORD *)char v25 = 134218240;
      *(double *)&v25[4] = v6;
      *(_WORD *)&v25[12] = 2048;
      *(double *)&v25[14] = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Invalid (latitude, longitude): (%f, %f)", v25, 0x16u);
    }
    sub_100058DB0((void *)a1, "");
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100058DB0((void *)a1, "");
    unint64_t v12 = *(unsigned __int8 *)(a1 + 23);
    unint64_t v13 = *(void *)(a1 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v14 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      unint64_t v14 = *(void *)(a1 + 8);
    }
    if (v14 <= 3)
    {
      int v15 = 0;
      int v16 = 0;
      char v17 = 1;
      do
      {
        if (v17)
        {
          double v18 = (v10 + v9) * 0.5;
          BOOL v19 = *a4 >= v18;
          if (*a4 < v18) {
            double v10 = (v10 + v9) * 0.5;
          }
          else {
            double v9 = (v10 + v9) * 0.5;
          }
        }
        else
        {
          double v20 = (v8 + v7) * 0.5;
          BOOL v19 = *a3 >= v20;
          if (*a3 < v20) {
            double v8 = (v8 + v7) * 0.5;
          }
          else {
            double v7 = (v8 + v7) * 0.5;
          }
        }
        int v16 = (2 * v16) | v19;
        if (++v15 == 5)
        {
          sub_10060C178((const void **)a1, a0123456789bcde[v16], v25);
          if (*(char *)(a1 + 23) < 0) {
            operator delete(*(void **)a1);
          }
          int v16 = 0;
          int v15 = 0;
          *(_OWORD *)a1 = *(_OWORD *)v25;
          unint64_t v21 = *(void *)&v25[16];
          *(void *)(a1 + 16) = *(void *)&v25[16];
          unint64_t v12 = HIBYTE(v21);
          unint64_t v13 = *(void *)(a1 + 8);
        }
        v17 ^= 1u;
        if ((v12 & 0x80u) == 0) {
          unint64_t v22 = v12;
        }
        else {
          unint64_t v22 = v13;
        }
      }
      while (v22 < 4);
    }
  }
}

void sub_10060C154(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10060C178@<X0>(const void **a1@<X0>, char a2@<W1>, void *a3@<X8>)
{
  size_t v6 = *((unsigned __int8 *)a1 + 23);
  size_t v7 = (size_t)a1[1];
  a3[1] = 0;
  a3[2] = 0;
  if ((v6 & 0x80u) == 0) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = v7;
  }
  *a3 = 0;
  uint64_t result = sub_1000C140C((uint64_t)a3, v8 + 1);
  if (*(char *)(result + 23) >= 0) {
    double v10 = (char *)result;
  }
  else {
    double v10 = *(char **)result;
  }
  if (v8)
  {
    if (*((char *)a1 + 23) >= 0) {
      BOOL v11 = a1;
    }
    else {
      BOOL v11 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v8);
  }
  unint64_t v12 = &v10[v8];
  char *v12 = a2;
  v12[1] = 0;
  return result;
}

void sub_10060C214(void *a1, const std::string *a2, uint64_t a3)
{
  if ((SHIBYTE(a2->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    if (!*((unsigned char *)&a2->__r_.__value_.__s + 23))
    {
      *(_OWORD *)a1 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      a1[2] = *((void *)&a2->__r_.__value_.__l + 2);
      return;
    }
    size_t v6 = a2;
    goto LABEL_5;
  }
  size_t v6 = (const std::string *)a2->__r_.__value_.__r.__words[0];
  std::string::size_type size = a2->__r_.__value_.__l.__size_;
  if (size)
  {
LABEL_5:
    std::string::value_type v7 = v6->__r_.__value_.__s.__data_[size - 1];
    memset(&v13, 0, sizeof(v13));
    std::string::basic_string(&v13, a2, 0, size - 1, (std::allocator<char> *)&__dst);
    size_t v8 = sub_1000389F8((uint64_t *)qword_101B0D1C0, a3);
    if (std::string::find((const std::string *)(*v8 + 24 * (size & 1)), v7, 0) != -1)
    {
      sub_10060C214(&__dst, &v13, a3);
      if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v13.__r_.__value_.__l.__data_);
      }
      std::string v13 = __dst;
    }
    double v9 = sub_1000389F8((uint64_t *)qword_101B0D1A8, a3);
    std::string::size_type v10 = std::string::find((const std::string *)(*v9 + 24 * (size & 1)), v7, 0);
    sub_10060C178((const void **)&v13.__r_.__value_.__l.__data_, a0123456789bcde[v10], a1);
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v13.__r_.__value_.__l.__data_);
    }
    return;
  }
  BOOL v11 = (void *)a2->__r_.__value_.__r.__words[0];

  sub_10004FC84(a1, v11, 0);
}

void sub_10060C394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10060C3B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 48);
  std::string v13 = (void *)(a1 + 56);
  if (v1 != (void *)(a1 + 56))
  {
    do
    {
      long long v3 = (void *)v1[7];
      if (v3 != v1 + 8)
      {
        do
        {
          OsLogContext v4 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
          {
            long long v5 = v1 + 4;
            if (*((char *)v1 + 55) < 0) {
              long long v5 = (void *)v1[4];
            }
            size_t v6 = v3 + 4;
            if (*((char *)v3 + 55) < 0) {
              size_t v6 = (void *)*v6;
            }
            unint64_t v7 = 0x8E38E38E38E38E39 * ((uint64_t)(v3[8] - v3[7]) >> 3);
            *(_DWORD *)std::string buf = 136315650;
            int v15 = v5;
            __int16 v16 = 2048;
            unint64_t v17 = v7;
            __int16 v18 = 2080;
            BOOL v19 = v6;
            _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Private network iccid %s has %lu geofences in geohash %s", buf, 0x20u);
          }
          size_t v8 = (void *)v3[1];
          if (v8)
          {
            do
            {
              double v9 = v8;
              size_t v8 = (void *)*v8;
            }
            while (v8);
          }
          else
          {
            do
            {
              double v9 = (void *)v3[2];
              BOOL v10 = *v9 == (void)v3;
              long long v3 = v9;
            }
            while (!v10);
          }
          long long v3 = v9;
        }
        while (v9 != v1 + 8);
      }
      BOOL v11 = (void *)v1[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v12 = (void *)v1[2];
          BOOL v10 = *v12 == (void)v1;
          uint64_t v1 = v12;
        }
        while (!v10);
      }
      uint64_t v1 = v12;
    }
    while (v12 != v13);
  }
}

uint64_t **sub_10060C574(uint64_t **a1, long long **a2, uint64_t a3)
{
  a1[1] = 0;
  OsLogContext v4 = (void **)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    long long v5 = a2;
    size_t v6 = 0;
    unint64_t v7 = (void **)(a1 + 1);
    size_t v8 = (int *)&a2[4 * a3];
    while (1)
    {
      int v9 = *(_DWORD *)v5;
      BOOL v10 = v4;
      if (v7 == v4) {
        break;
      }
      BOOL v11 = (void **)v6;
      unint64_t v12 = v4;
      if (v6)
      {
        do
        {
          BOOL v10 = v11;
          BOOL v11 = (void **)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v10 = (void **)v12[2];
          BOOL v13 = *v10 == v12;
          unint64_t v12 = v10;
        }
        while (v13);
      }
      if (*((_DWORD *)v10 + 8) < v9) {
        break;
      }
      int v15 = v4;
      unint64_t v14 = v4;
      if (!v6) {
        goto LABEL_25;
      }
      __int16 v16 = (void **)v6;
      while (1)
      {
        while (1)
        {
          unint64_t v14 = v16;
          int v17 = *((_DWORD *)v16 + 8);
          if (v17 <= v9) {
            break;
          }
          __int16 v16 = (void **)*v14;
          int v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v9) {
          break;
        }
        __int16 v16 = (void **)v14[1];
        if (!v16)
        {
          int v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_28:
      v5 += 4;
      if (v5 == (long long **)v8) {
        return a1;
      }
      unint64_t v7 = (void **)*a1;
      size_t v6 = a1[1];
    }
    if (v6) {
      unint64_t v14 = v10;
    }
    else {
      unint64_t v14 = v4;
    }
    if (v6) {
      int v15 = v10 + 1;
    }
    else {
      int v15 = v4;
    }
    if (*v15) {
      goto LABEL_28;
    }
LABEL_25:
    __int16 v18 = operator new(0x40uLL);
    *((void *)v18 + 5) = 0;
    *((_DWORD *)v18 + 8) = v9;
    *((void *)v18 + 6) = 0;
    *((void *)v18 + 7) = 0;
    sub_1000302C0((char *)v18 + 40, v5[1], v5[2], 0xAAAAAAAAAAAAAAABLL * (((char *)v5[2] - (char *)v5[1]) >> 3));
    *(void *)__int16 v18 = 0;
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = v14;
    *int v15 = v18;
    BOOL v19 = (uint64_t *)**a1;
    if (v19)
    {
      *a1 = v19;
      __int16 v18 = *v15;
    }
    sub_100046C90(a1[1], (uint64_t *)v18);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_28;
  }
  return a1;
}

void sub_10060C704(_Unwind_Exception *a1)
{
  operator delete(v1);
  sub_10060C72C(*v2);
  _Unwind_Resume(a1);
}

void sub_10060C72C(char *a1)
{
  if (a1)
  {
    sub_10060C72C(*(void *)a1);
    sub_10060C72C(*((void *)a1 + 1));
    long long v2 = (void **)(a1 + 40);
    sub_100047F64(&v2);
    operator delete(a1);
  }
}

void sub_10060C784(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10060C850(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10060C928);
  __cxa_rethrow();
}

void sub_10060C878(_Unwind_Exception *a1)
{
}

void sub_10060C890(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10060C8C8(uint64_t a1)
{
}

uint64_t sub_10060C8E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10060C928(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10060C954(void *a1)
{
  if (a1)
  {
    sub_10060C954(*a1);
    sub_10060C954(a1[1]);
    sub_10060C9A8((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10060C9A8(uint64_t a1)
{
  sub_10060C9F8(*(void **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
  {
    long long v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_10060C9F8(void *a1)
{
  if (a1)
  {
    sub_10060C9F8(*a1);
    sub_10060C9F8(a1[1]);
    sub_10060CA4C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10060CA4C(uint64_t a1)
{
  long long v2 = (void **)(a1 + 24);
  sub_100604790(&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t *sub_10060CA94(uint64_t **a1)
{
  uint64_t v1 = *a1;
  v92 = a1;
  std::string v93 = v1;
  uint64_t v2 = *v1;
  v98 = 0;
  uint64_t v99 = 0;
  uint64_t v97 = (uint64_t *)&v98;
  long long v3 = (uint64_t *)v1[4];
  std::string v91 = v1;
  OsLogContext v4 = v1 + 5;
  if (v3 == v1 + 5)
  {
LABEL_50:
    int v42 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = v91 + 1;
      if (*((char *)v91 + 31) < 0) {
        v43 = (void *)*v43;
      }
      *(_DWORD *)std::string buf = 134218242;
      *(void *)&uint8_t buf[4] = v99;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Installed %zu geohashes for iccid %s", buf, 0x16u);
    }
    v44 = (void **)(v91 + 1);
    v45 = *(uint64_t **)(v2 + 56);
    BOOL v46 = (uint64_t **)(v2 + 56);
    BOOL v47 = (uint64_t **)(v2 + 56);
    if (!v45) {
      goto LABEL_66;
    }
    BOOL v46 = (uint64_t **)(v2 + 56);
    while (1)
    {
      while (1)
      {
        BOOL v47 = (uint64_t **)v45;
        v48 = v45 + 4;
        if ((sub_100046FE8(v44, (void **)v45 + 4) & 0x80) == 0) {
          break;
        }
        v45 = *v47;
        BOOL v46 = v47;
        if (!*v47) {
          goto LABEL_66;
        }
      }
      if ((sub_100046FE8(v48, v44) & 0x80) == 0) {
        break;
      }
      BOOL v46 = v47 + 1;
      v45 = v47[1];
      if (!v45) {
        goto LABEL_66;
      }
    }
    uint64_t v51 = *v46;
    if (!*v46)
    {
LABEL_66:
      *(void *)&uint8_t buf[16] = 0;
      v52 = (uint64_t *)operator new(0x50uLL);
      *(void *)std::string buf = v52;
      *(void *)&uint8_t buf[8] = v2 + 56;
      v53 = v52 + 4;
      if (*((char *)v91 + 31) < 0)
      {
        sub_10004FC84(v53, (void *)v91[1], v91[2]);
      }
      else
      {
        long long v54 = *(_OWORD *)v44;
        v52[6] = v91[3];
        *(_OWORD *)v53 = v54;
      }
      v52[9] = 0;
      v52[8] = 0;
      v52[7] = (uint64_t)(v52 + 8);
      uint8_t buf[16] = 1;
      uint64_t *v52 = 0;
      v52[1] = 0;
      v52[2] = (uint64_t)v47;
      *BOOL v46 = v52;
      uint64_t v55 = **(void **)(v2 + 48);
      if (v55)
      {
        *(void *)(v2 + 48) = v55;
        v52 = *v46;
      }
      sub_100046C90(*(uint64_t **)(v2 + 56), v52);
      ++*(void *)(v2 + 64);
      uint64_t v51 = *(uint64_t **)buf;
      *(void *)std::string buf = 0;
      sub_10060D89C((uint64_t)buf);
    }
    v56 = (uint64_t **)(v51 + 7);
    if (v51 + 7 != (uint64_t *)&v97)
    {
      v57 = v97;
      if (v51[9])
      {
        uint64_t v58 = v51[8];
        uint64_t v59 = v51[7];
        v51[7] = (uint64_t)(v51 + 8);
        *(void *)(v58 + 16) = 0;
        v51[8] = 0;
        v51[9] = 0;
        if (*(void *)(v59 + 8)) {
          uint64_t v60 = *(void *)(v59 + 8);
        }
        else {
          uint64_t v60 = v59;
        }
        *(void *)std::string buf = v51 + 7;
        *(void *)&uint8_t buf[8] = v60;
        *(void *)&uint8_t buf[16] = v60;
        std::string v90 = v51;
        if (v60)
        {
          *(void *)&uint8_t buf[8] = sub_1000EA590(v60);
          if (v57 != (uint64_t *)&v98)
          {
            while (1)
            {
              std::string::operator=((std::string *)(v60 + 32), (const std::string *)(v57 + 4));
              if ((uint64_t *)v60 != v57)
              {
                uint64_t v62 = v57[7];
                uint64_t v61 = v57[8];
                unint64_t v63 = 0x8E38E38E38E38E39 * ((v61 - v62) >> 3);
                uint64_t v64 = *(void *)(v60 + 72);
                uint64_t v65 = *(void *)(v60 + 56);
                if (0x8E38E38E38E38E39 * ((v64 - v65) >> 3) >= v63)
                {
                  if (0x8E38E38E38E38E39 * ((*(void *)(v60 + 64) - v65) >> 3) >= v63)
                  {
                    uint64_t v74 = sub_10060DA30((long long *)v57[7], (long long *)v57[8], *(void *)(v60 + 56));
                    for (uint64_t i = *(void *)(v60 + 64); i != v74; sub_100604814(i))
                      i -= 72;
                    *(void *)(v60 + 64) = v74;
                    goto LABEL_100;
                  }
                  int v73 = (long long *)(v62 + 8 * ((*(void *)(v60 + 64) - v65) >> 3));
                  sub_10060DA30((long long *)v57[7], v73, *(void *)(v60 + 56));
                  uint64_t v72 = sub_10060D8F4((uint64_t)v73, v61, *(void *)(v60 + 64));
                }
                else
                {
                  v66 = (void **)(v60 + 56);
                  if (v65)
                  {
                    uint64_t v67 = *(void *)(v60 + 64);
                    v68 = *(void **)(v60 + 56);
                    if (v67 != v65)
                    {
                      do
                      {
                        v67 -= 72;
                        sub_100604814(v67);
                      }
                      while (v67 != v65);
                      v68 = *v66;
                    }
                    *(void *)(v60 + 64) = v65;
                    operator delete(v68);
                    uint64_t v64 = 0;
                    std::string *v66 = 0;
                    *(void *)(v60 + 64) = 0;
                    *(void *)(v60 + 72) = 0;
                  }
                  if (v63 > 0x38E38E38E38E38ELL) {
                    sub_10006A748();
                  }
                  unint64_t v69 = 0x8E38E38E38E38E39 * (v64 >> 3);
                  uint64_t v70 = 2 * v69;
                  if (2 * v69 <= v63) {
                    uint64_t v70 = 0x8E38E38E38E38E39 * ((v61 - v62) >> 3);
                  }
                  if (v69 >= 0x1C71C71C71C71C7) {
                    unint64_t v71 = 0x38E38E38E38E38ELL;
                  }
                  else {
                    unint64_t v71 = v70;
                  }
                  sub_10060D740((void *)(v60 + 56), v71);
                  uint64_t v72 = sub_10060D8F4(v62, v61, *(void *)(v60 + 64));
                }
                *(void *)(v60 + 64) = v72;
              }
LABEL_100:
              v76 = *(uint64_t **)&buf[16];
              std::string __p = 0;
              v77 = (uint64_t **)sub_1000EA518((uint64_t)v56, &__p, (void *)(*(void *)&buf[16] + 32));
              sub_100046C38(v56, (uint64_t)__p, v77, v76);
              uint64_t v60 = *(void *)&buf[8];
              *(void *)&uint8_t buf[16] = *(void *)&buf[8];
              if (*(void *)&buf[8]) {
                *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
              }
              std::string v78 = (uint64_t *)v57[1];
              if (v78)
              {
                do
                {
                  v79 = v78;
                  std::string v78 = (uint64_t *)*v78;
                }
                while (v78);
              }
              else
              {
                do
                {
                  v79 = (uint64_t *)v57[2];
                  BOOL v37 = *v79 == (void)v57;
                  v57 = v79;
                }
                while (!v37);
              }
              if (v60)
              {
                v57 = v79;
                if (v79 != (uint64_t *)&v98) {
                  continue;
                }
              }
              goto LABEL_112;
            }
          }
          v79 = (uint64_t *)&v98;
        }
        else
        {
          v79 = v57;
        }
LABEL_112:
        sub_10060DAA4((uint64_t)buf);
        v57 = v79;
        uint64_t v51 = v90;
      }
      if (v57 != (uint64_t *)&v98)
      {
        v80 = v51 + 8;
        do
        {
          *(void *)&uint8_t buf[16] = 0;
          v81 = (uint64_t *)operator new(0x50uLL);
          uint64_t v82 = v81;
          *(void *)std::string buf = v81;
          *(void *)&uint8_t buf[8] = v80;
          v83 = v81 + 4;
          if (*((char *)v57 + 55) < 0)
          {
            sub_10004FC84((unsigned char *)v81 + 32, (void *)v57[4], v57[5]);
          }
          else
          {
            long long v84 = *((_OWORD *)v57 + 2);
            v81[6] = v57[6];
            *(_OWORD *)v83 = v84;
          }
          v82[7] = 0;
          v82[8] = 0;
          v82[9] = 0;
          sub_10060DAF4(v82 + 7, v57[7], v57[8], 0x8E38E38E38E38E39 * ((v57[8] - v57[7]) >> 3));
          uint8_t buf[16] = 1;
          std::string __p = 0;
          v85 = (uint64_t **)sub_1000EA518((uint64_t)v56, &__p, v83);
          sub_100046C38(v56, (uint64_t)__p, v85, v82);
          *(void *)std::string buf = 0;
          sub_10060D6E8((uint64_t)buf);
          std::string v86 = (uint64_t *)v57[1];
          if (v86)
          {
            do
            {
              std::string v87 = v86;
              std::string v86 = (uint64_t *)*v86;
            }
            while (v86);
          }
          else
          {
            do
            {
              std::string v87 = (uint64_t *)v57[2];
              BOOL v37 = *v87 == (void)v57;
              v57 = v87;
            }
            while (!v37);
          }
          v57 = v87;
        }
        while (v87 != (uint64_t *)&v98);
      }
    }
    sub_1000607A8((uint64_t)(v91 + 7), 1);
    goto LABEL_125;
  }
  std::string v89 = v1 + 1;
  uint64_t v5 = (uint64_t)(v1 + 7);
  while (1)
  {
    double v6 = *((double *)v3 + 9);
    unint64_t v7 = (double *)(v3 + 8);
    if (v6 < -90.0 || v6 > 90.0 || *v7 < -180.0 || *v7 > 180.0) {
      break;
    }
    std::string __p = 0;
    uint64_t v95 = 0;
    uint64_t v96 = 0;
    sub_10060BF24((uint64_t)&__p, v2, (double *)v3 + 9, (double *)v3 + 8);
    if (v96 >= 0) {
      uint64_t v8 = HIBYTE(v96);
    }
    else {
      uint64_t v8 = v95;
    }
    if (v8)
    {
      if (&v98 == (void **)sub_100046F68((uint64_t)&v97, &__p))
      {
        *(void *)std::string buf = &__p;
        int v9 = sub_10060D5AC(&v97, &__p, (long long **)buf);
        uint64_t v11 = v9[7];
        for (uint64_t j = v9[8]; j != v11; sub_100604814(j))
          j -= 72;
        v9[8] = v11;
      }
      *(void *)std::string buf = &__p;
      BOOL v13 = sub_10060D5AC(&v97, &__p, (long long **)buf);
      unint64_t v14 = v13;
      int v15 = (long long *)(v3 + 7);
      __int16 v16 = v13 + 9;
      unint64_t v17 = v13[9];
      unint64_t v18 = v13[8];
      if (v18 >= v17)
      {
        uint64_t v20 = v13[7];
        unint64_t v21 = 0x8E38E38E38E38E39 * ((uint64_t)(v18 - v20) >> 3);
        unint64_t v22 = v21 + 1;
        if (v21 + 1 > 0x38E38E38E38E38ELL) {
          sub_10006A748();
        }
        unint64_t v23 = 0x8E38E38E38E38E39 * ((uint64_t)(v17 - v20) >> 3);
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x1C71C71C71C71C7) {
          unint64_t v24 = 0x38E38E38E38E38ELL;
        }
        else {
          unint64_t v24 = v22;
        }
        v102[0] = v16;
        if (v24) {
          unint64_t v24 = (unint64_t)sub_1003DD510(v24);
        }
        else {
          uint64_t v25 = 0;
        }
        *(void *)std::string buf = v24;
        *(void *)&uint8_t buf[8] = v24 + 72 * v21;
        *(void *)&uint8_t buf[16] = *(void *)&buf[8];
        *(void *)&double v101 = v24 + 72 * v25;
        sub_10060D794(*(uint64_t *)&buf[8], v15);
        uint64_t v27 = v14[7];
        unint64_t v26 = v14[8];
        uint64_t v28 = *(void *)&buf[16];
        uint64_t v29 = *(void *)&buf[8];
        if (v26 == v27)
        {
          int64x2_t v33 = vdupq_n_s64(v26);
        }
        else
        {
          do
          {
            long long v30 = *(_OWORD *)(v26 - 72);
            *(void *)(v29 - 56) = *(void *)(v26 - 56);
            *(_OWORD *)(v29 - 72) = v30;
            long long v31 = *(_OWORD *)(v26 - 48);
            *(void *)(v29 - 32) = *(void *)(v26 - 32);
            *(_OWORD *)(v29 - 48) = v31;
            *(void *)(v26 - 4sub_10010E764((uint64_t)&a9, 0) = 0;
            *(void *)(v26 - 32) = 0;
            *(void *)(v26 - 48) = 0;
            long long v32 = *(_OWORD *)(v26 - 24);
            *(void *)(v29 - 8) = *(void *)(v26 - 8);
            *(_OWORD *)(v29 - 24) = v32;
            v29 -= 72;
            *(void *)(v26 - 16) = 0;
            *(void *)(v26 - 8) = 0;
            *(void *)(v26 - 24) = 0;
            v26 -= 72;
          }
          while (v26 != v27);
          int64x2_t v33 = *(int64x2_t *)(v14 + 7);
        }
        unint64_t v19 = v28 + 72;
        v14[7] = v29;
        v14[8] = v28 + 72;
        *(int64x2_t *)&uint8_t buf[8] = v33;
        double v34 = *((double *)v14 + 9);
        *((double *)v14 + 9) = v101;
        double v101 = v34;
        *(void *)std::string buf = v33.i64[0];
        sub_10060D84C((uint64_t)buf);
      }
      else
      {
        sub_10060D794(v13[8], v15);
        unint64_t v19 = v18 + 72;
        v14[8] = v18 + 72;
      }
      v14[8] = v19;
    }
    else
    {
      unint64_t v12 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = v3 + 10;
        if (*((char *)v3 + 103) < 0) {
          uint64_t v38 = (void *)*v38;
        }
        uint64_t v39 = v89;
        if (*((char *)v91 + 31) < 0) {
          uint64_t v39 = (void *)*v89;
        }
        uint64_t v40 = v3[9];
        double v41 = *v7;
        *(_DWORD *)std::string buf = 136315906;
        *(void *)&uint8_t buf[4] = v38;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v40;
        *(_WORD *)&buf[22] = 2048;
        double v101 = v41;
        LOWORD(v102[0]) = 2080;
        *(void *)((char *)v102 + 2) = v39;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Geohash is null for geofence [%s] (lat, long): (%f, %f) for iccid %s", buf, 0x2Au);
      }
      sub_1000607A8(v5, 0);
    }
    if (SHIBYTE(v96) < 0) {
      operator delete(__p);
    }
    if (!v8) {
      goto LABEL_125;
    }
    uint64_t v35 = (uint64_t *)v3[1];
    if (v35)
    {
      do
      {
        long long v36 = v35;
        uint64_t v35 = (uint64_t *)*v35;
      }
      while (v35);
    }
    else
    {
      do
      {
        long long v36 = (uint64_t *)v3[2];
        BOOL v37 = *v36 == (void)v3;
        long long v3 = v36;
      }
      while (!v37);
    }
    long long v3 = v36;
    if (v36 == v4) {
      goto LABEL_50;
    }
  }
  uint64_t v49 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    double v50 = *v7;
    *(_DWORD *)std::string buf = 134218240;
    *(double *)&uint8_t buf[4] = v6;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = v50;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Invalid (latitude, longitude): (%f, %f)", buf, 0x16u);
  }
  sub_1000607A8(v5, 0);
LABEL_125:
  sub_10060C9F8(v98);
  sub_10060D540((uint64_t *)&v93);
  return sub_100046B58((uint64_t *)&v92);
}

void sub_10060D474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,char a24)
{
}

uint64_t *sub_10060D540(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 56));
    sub_10005CD90(v1 + 32, *(void **)(v1 + 40));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10060D5AC(uint64_t **a1, void **a2, long long **a3)
{
  double v6 = a1 + 1;
  uint64_t v5 = a1[1];
  unint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  unint64_t v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      BOOL v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      unint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    unint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    unint64_t v12 = *a3;
    uint64_t v17 = 0;
    uint64_t v11 = (uint64_t *)operator new(0x50uLL);
    v16[0] = v11;
    v16[1] = v6;
    BOOL v13 = v11 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v13, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v14 = *v12;
      v11[6] = *((void *)v12 + 2);
      *(_OWORD *)BOOL v13 = v14;
    }
    v11[7] = 0;
    v11[8] = 0;
    v11[9] = 0;
    LOBYTE(v17) = 1;
    sub_100046C38(a1, (uint64_t)v8, v7, v11);
    v16[0] = 0;
    sub_10060D6E8((uint64_t)v16);
  }
  return v11;
}

void sub_10060D6D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10060D6E8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10060D6E8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10060CA4C((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

char *sub_10060D740(void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1003DD510(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

uint64_t sub_10060D794(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }
  double v6 = (unsigned char *)(a1 + 48);
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)double v6 = v7;
  }
  return a1;
}

void sub_10060D830(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060D84C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    sub_100604814(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10060D89C(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10060C9A8((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t sub_10060D8F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_10060D978(a3 + v6, (long long *)(a1 + v6));
      v6 += 72;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_10060D954(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 72;
    do
    {
      sub_100604814(v4 + v2);
      v2 -= 72;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060D978(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 48);
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)uint64_t v6 = v7;
  }
  return a1;
}

void sub_10060DA14(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060DA30(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    long long v5 = a1;
    do
    {
      long long v6 = *v5;
      *(void *)(a3 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a3 = v6;
      std::string::operator=((std::string *)(a3 + 24), (const std::string *)v5 + 1);
      std::string::operator=((std::string *)(a3 + 48), (const std::string *)v5 + 2);
      a3 += 72;
      long long v5 = (long long *)((char *)v5 + 72);
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_10060DAA4(uint64_t a1)
{
  sub_10060C9F8(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10060C9F8(v2);
  }
  return a1;
}

void *sub_10060DAF4(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_10060D740(result, a4);
    uint64_t result = (void *)sub_10060D8F4(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10060DB58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100604790(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10060DB78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = (void *)(v1 + 8);
  uint64_t v3 = *(void *)v1;
  long long v4 = (void ***)(*(void *)v1 + 48);
  if ((void **)(v3 + 56) != sub_100046F68((uint64_t)v4, (void **)(v1 + 8)))
  {
    long long v5 = sub_100046F68((uint64_t)v4, (void **)(v1 + 8));
    if ((void **)(v3 + 56) != v5)
    {
      long long v6 = (uint64_t *)v5;
      long long v7 = (void **)v5[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          long long v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        uint64_t v9 = v5;
        do
        {
          uint64_t v8 = (void **)v9[2];
          BOOL v10 = *v8 == v9;
          uint64_t v9 = v8;
        }
        while (!v10);
      }
      if (*v4 == v5) {
        *long long v4 = v8;
      }
      uint64_t v11 = *(uint64_t **)(v3 + 56);
      --*(void *)(v3 + 64);
      sub_10005EE6C(v11, v6);
      sub_10060C9A8((uint64_t)(v6 + 4));
      operator delete(v6);
    }
    unint64_t v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v1 + 31) < 0) {
        uint64_t v2 = (void *)*v2;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v17 = v2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Uninstalled geofences for iccid %s", buf, 0xCu);
    }
  }
  sub_1001102C4(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

uint64_t sub_10060DCE4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_10060DD64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v181 = a1;
  uint64_t v182 = v1;
  uint64_t v178 = *(void *)v1;
  v177 = (double *)(v1 + 16);
  double v2 = *(double *)(v1 + 8);
  if (v2 < -90.0 || v2 > 90.0 || *v177 < -180.0 || *v177 > 180.0)
  {
    uint64_t v4 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      double v5 = *v177;
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 134218240;
      *(double *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v2;
      WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2048;
      *(double *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Invalid (latitude, longitude): (%f, %f)", (uint8_t *)buf, 0x16u);
    }
    memset(&v202, 0, sizeof(v202));
    std::string::pointer v208 = 0;
    memset(buf, 0, sizeof(buf));
    long long __p = 0u;
    uint64_t v6 = *(void *)(v1 + 48);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v6 + 48))(v6, &v202, buf);
    if (SHIBYTE(v208) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[1].__r_.__value_.__l.__data_);
    }
    v199.__r_.__value_.__r.__words[0] = (std::string::size_type)&v202;
    sub_100604790((void ***)&v199);
    goto LABEL_18;
  }
  memset(&v186, 0, sizeof(v186));
  sub_10060BF24((uint64_t)&v186, v178, (double *)(v1 + 8), v177);
  std::string::size_type size = HIBYTE(v186.__r_.__value_.__r.__words[2]);
  if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v186.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    uint64_t v8 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v146 = *(void *)(v1 + 8);
      double v147 = *v177;
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 134218240;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v146;
      WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2048;
      *(double *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v147;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Geohash is null for (lat, long): (%f, %f)", (uint8_t *)buf, 0x16u);
    }
    memset(&v202, 0, sizeof(v202));
    std::string::pointer v208 = 0;
    memset(buf, 0, sizeof(buf));
    long long __p = 0u;
    uint64_t v9 = *(void *)(v1 + 48);
    if (!v9) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v9 + 48))(v9, &v202, buf);
    if (SHIBYTE(v208) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[1].__r_.__value_.__l.__data_);
    }
    v199.__r_.__value_.__r.__words[0] = (std::string::size_type)&v202;
    sub_100604790((void ***)&v199);
    goto LABEL_353;
  }
  memset(&v202, 0, sizeof(v202));
  sub_10060C214(&v202, &v186, 0);
  memset(&v199, 0, sizeof(v199));
  sub_10060C214(&v199, &v186, 1);
  long long v197 = 0uLL;
  std::string::pointer data = 0;
  sub_10060C214(&v197, &v186, 2);
  long long v195 = 0uLL;
  uint64_t v196 = 0;
  sub_10060C214(&v195, &v186, 3);
  int64x2_t v193 = 0uLL;
  unint64_t v194 = 0;
  sub_10060C214(&v193, &v202, 2);
  v191[0] = 0;
  v191[1] = 0;
  uint64_t v192 = 0;
  sub_10060C214(v191, &v202, 3);
  v189[0] = 0;
  v189[1] = 0;
  uint64_t v190 = 0;
  sub_10060C214(v189, &v199, 2);
  v187[0] = 0;
  v187[1] = 0;
  uint64_t v188 = 0;
  sub_10060C214(v187, &v199, 3);
  __str = 0;
  v184 = 0;
  v185 = 0;
  uint64_t v175 = v1;
  v176 = (int8x16_t *)(v1 + 8);
  if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(buf, v202.__r_.__value_.__l.__data_, v202.__r_.__value_.__l.__size_);
  }
  else {
    buf[0] = v202;
  }
  if (SHIBYTE(v199.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&buf[1], v199.__r_.__value_.__l.__data_, v199.__r_.__value_.__l.__size_);
  }
  else {
    buf[1] = v199;
  }
  if (SHIBYTE(data) < 0)
  {
    sub_10004FC84(&__p, (void *)v197, *((unint64_t *)&v197 + 1));
  }
  else
  {
    long long __p = v197;
    std::string::pointer v208 = data;
  }
  if (SHIBYTE(v196) < 0)
  {
    sub_10004FC84(&v209, (void *)v195, *((unint64_t *)&v195 + 1));
  }
  else
  {
    long long v209 = v195;
    uint64_t v210 = v196;
  }
  if (SHIBYTE(v194) < 0)
  {
    sub_10004FC84(&v211, (void *)v193.i64[0], v193.u64[1]);
  }
  else
  {
    int64x2_t v211 = v193;
    unint64_t v212 = v194;
  }
  if (SHIBYTE(v192) < 0)
  {
    sub_10004FC84(&v213, v191[0], (unint64_t)v191[1]);
  }
  else
  {
    long long v213 = *(_OWORD *)v191;
    uint64_t v214 = v192;
  }
  if (SHIBYTE(v190) < 0)
  {
    sub_10004FC84(&v215, v189[0], (unint64_t)v189[1]);
  }
  else
  {
    long long v215 = *(_OWORD *)v189;
    uint64_t v216 = v190;
  }
  if (SHIBYTE(v188) < 0)
  {
    sub_10004FC84(&v217, v187[0], (unint64_t)v187[1]);
  }
  else
  {
    long long v217 = *(_OWORD *)v187;
    v218[0] = v188;
  }
  __str = 0;
  v184 = 0;
  v185 = 0;
  p_str = &__str;
  uint64_t v201 = 0;
  __str = (std::string *)operator new(0xC0uLL);
  v184 = __str;
  v185 = __str + 8;
  uint64_t v10 = 0;
  v184 = (std::string *)sub_1000D8A18((uint64_t)&v185, (long long *)buf, &v219, (char *)__str);
  do
  {
    if (SHIBYTE(v218[v10]) < 0) {
      operator delete((void *)v218[v10 - 2]);
    }
    v10 -= 3;
  }
  while (v10 != -24);
  if (SHIBYTE(v188) < 0) {
    operator delete(v187[0]);
  }
  if (SHIBYTE(v190) < 0) {
    operator delete(v189[0]);
  }
  if (SHIBYTE(v192) < 0) {
    operator delete(v191[0]);
  }
  if (SHIBYTE(v194) < 0) {
    operator delete((void *)v193.i64[0]);
  }
  if (SHIBYTE(v196) < 0) {
    operator delete((void *)v195);
  }
  if (SHIBYTE(data) < 0) {
    operator delete((void *)v197);
  }
  if (SHIBYTE(v199.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v199.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v202.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = v184;
  if (v184 >= v185)
  {
    BOOL v13 = (std::string *)sub_100048008((uint64_t *)&__str, (long long *)&v186);
  }
  else
  {
    if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(v184, v186.__r_.__value_.__l.__data_, v186.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v12 = *(_OWORD *)&v186.__r_.__value_.__l.__data_;
      v184->__r_.__value_.__r.__words[2] = v186.__r_.__value_.__r.__words[2];
      *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
    }
    BOOL v13 = v11 + 1;
  }
  v184 = v13;
  long long v14 = *(NSObject **)(v178 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = SHIBYTE(v186.__r_.__value_.__r.__words[2]);
    std::string::size_type v16 = v186.__r_.__value_.__r.__words[0];
    sub_100062B40(__str, v13, ", ", 2uLL, buf);
    uint64_t v17 = &v186;
    if (v15 < 0) {
      uint64_t v17 = (std::string *)v16;
    }
    if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v18 = buf;
    }
    else {
      unint64_t v18 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    LODWORD(v202.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v202.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    WORD2(v202.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v202.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Geohash [%s], its neighbor geohashes are [%s]", (uint8_t *)&v202, 0x16u);
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
  }
  *(_OWORD *)&v199.__r_.__value_.__r.__words[1] = 0uLL;
  v199.__r_.__value_.__r.__words[0] = (std::string::size_type)&v199.__r_.__value_.__l.__size_;
  unint64_t v19 = *(void **)(v178 + 48);
  if (v19 != (void *)(v178 + 56))
  {
    while (1)
    {
      uint64_t v20 = (void **)v19[7];
      v179 = v19;
      v180 = (void **)(v19 + 8);
      if (v20 != v19 + 8) {
        break;
      }
LABEL_120:
      double v50 = v179;
      uint64_t v51 = (void *)v179[1];
      if (v51)
      {
        do
        {
          v52 = v51;
          uint64_t v51 = (void *)*v51;
        }
        while (v51);
      }
      else
      {
        do
        {
          v52 = (void *)v50[2];
          BOOL v161 = *v52 == (void)v50;
          double v50 = v52;
        }
        while (!v161);
      }
      unint64_t v19 = v52;
      if (v52 == (void *)(v178 + 56)) {
        goto LABEL_126;
      }
    }
    while (1)
    {
      if (&v199.__r_.__value_.__r.__words[1] == (std::string::size_type *)sub_100046F68((uint64_t)&v199, v20 + 4))
      {
        buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v20 + 4);
        unint64_t v21 = sub_10060D5AC((uint64_t **)&v199, v20 + 4, (long long **)buf);
        uint64_t v22 = v21[7];
        for (uint64_t i = v21[8]; i != v22; sub_100604814(i))
          i -= 72;
        v21[8] = v22;
      }
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v20 + 4);
      unint64_t v24 = sub_10060D5AC((uint64_t **)&v199, v20 + 4, (long long **)buf);
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v20 + 4);
      uint64_t v25 = sub_10060D5AC((uint64_t **)&v199, v20 + 4, (long long **)buf);
      unint64_t v26 = (std::string *)v20[7];
      uint64_t v27 = (std::string *)v20[8];
      if ((char *)v27 - (char *)v26 < 1) {
        goto LABEL_114;
      }
      uint64_t v29 = (long long **)(v24 + 7);
      uint64_t v28 = v24[7];
      uint64_t v30 = v25[8];
      uint64_t v31 = v24[9];
      uint64_t v32 = ((char *)v27 - (char *)v26) / 72;
      unint64_t v33 = v24[8];
      if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v31 - v33) >> 3)) >= v32)
      {
        uint64_t v38 = v33 - v30;
        if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v33 - v30) >> 3)) >= v32)
        {
          uint64_t v39 = &v26[3 * v32];
LABEL_112:
          sub_10060FE48((uint64_t)(v24 + 7), v30, v33, v30 + 72 * v32);
          for (; v26 != v39; uint64_t v30 = (uint64_t)&v46[1])
          {
            long long v45 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
            *(void *)(v30 + 16) = *((void *)&v26->__r_.__value_.__l + 2);
            *(_OWORD *)uint64_t v30 = v45;
            BOOL v46 = (std::string *)(v30 + 24);
            BOOL v47 = v26 + 1;
            std::string::operator=(v46++, v47);
            std::string::operator=(v46, ++v47);
            unint64_t v26 = (std::string *)&v47[1];
          }
          goto LABEL_114;
        }
        uint64_t v39 = (std::string *)((char *)v26 + 8 * ((uint64_t)(v33 - v30) >> 3));
        if (v39 == v27)
        {
          uint64_t v41 = v24[8];
        }
        else
        {
          uint64_t v40 = 0;
          do
          {
            sub_10060D794(v33 + v40 * 24, (long long *)&v39[v40]);
            v40 += 3;
          }
          while (&v39[v40] != v27);
          uint64_t v41 = v33 + v40 * 24;
          uint64_t v38 = v33 - v30;
        }
        v24[8] = v41;
        if (v38 >= 1) {
          goto LABEL_112;
        }
      }
      else
      {
        unint64_t v34 = v32 - 0x71C71C71C71C71C7 * ((uint64_t)(v33 - v28) >> 3);
        if (v34 > 0x38E38E38E38E38ELL) {
          sub_10006A748();
        }
        unint64_t v35 = 0x8E38E38E38E38E39 * ((v31 - v28) >> 3);
        if (2 * v35 > v34) {
          unint64_t v34 = 2 * v35;
        }
        if (v35 >= 0x1C71C71C71C71C7) {
          unint64_t v36 = 0x38E38E38E38E38ELL;
        }
        else {
          unint64_t v36 = v34;
        }
        buf[1].__r_.__value_.__l.__size_ = (std::string::size_type)(v24 + 9);
        if (v36) {
          unint64_t v36 = (unint64_t)sub_1003DD510(v36);
        }
        else {
          uint64_t v37 = 0;
        }
        std::string::size_type v42 = v36 + 8 * ((v30 - v28) >> 3);
        buf[0].__r_.__value_.__r.__words[0] = v36;
        buf[0].__r_.__value_.__l.__size_ = v42;
        buf[0].__r_.__value_.__r.__words[2] = v42;
        buf[1].__r_.__value_.__r.__words[0] = v36 + 72 * v37;
        std::string::size_type v43 = v42 + 72 * v32;
        uint64_t v44 = 72 * v32;
        do
        {
          sub_10060D794(v42, (long long *)v26);
          v42 += 72;
          v26 += 3;
          v44 -= 72;
        }
        while (v44);
        buf[0].__r_.__value_.__r.__words[2] = v43;
        sub_10060FFA4(v29, buf, (long long *)v30);
        sub_10060D84C((uint64_t)buf);
      }
LABEL_114:
      v48 = (void **)v20[1];
      if (v48)
      {
        do
        {
          uint64_t v49 = v48;
          v48 = (void **)*v48;
        }
        while (v48);
      }
      else
      {
        do
        {
          uint64_t v49 = (void **)v20[2];
          BOOL v161 = *v49 == v20;
          uint64_t v20 = v49;
        }
        while (!v161);
      }
      uint64_t v20 = v49;
      if (v49 == v180) {
        goto LABEL_120;
      }
    }
  }
LABEL_126:
  long long v197 = 0uLL;
  std::string::pointer data = 0;
  long long v54 = __str;
  v53 = v184;
  if (__str == v184)
  {
    *((void *)&v195 + 1) = 0;
    uint64_t v196 = 0;
    *(void *)&long long v195 = (char *)&v195 + 8;
    goto LABEL_224;
  }
  do
  {
    if (SHIBYTE(v54->__r_.__value_.__r.__words[2]) < 0)
    {
      if (!v54->__r_.__value_.__l.__size_)
      {
LABEL_246:
        v137 = *(NSObject **)(v178 + 40);
        if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
        {
          v153 = &v186;
          if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            v153 = (std::string *)v186.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v153;
          _os_log_error_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_ERROR, "Null Neighbor for geohash [%s]", (uint8_t *)buf, 0xCu);
        }
        memset(&v202, 0, sizeof(v202));
        std::string::pointer v208 = 0;
        memset(buf, 0, sizeof(buf));
        long long __p = 0u;
        uint64_t v138 = *(void *)(v175 + 48);
        if (!v138) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v138 + 48))(v138, &v202, buf);
        if (SHIBYTE(v208) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[1].__r_.__value_.__l.__data_);
        }
        *(void *)&long long v195 = &v202;
        sub_100604790((void ***)&v195);
        goto LABEL_352;
      }
    }
    else if (!*((unsigned char *)&v54->__r_.__value_.__s + 23))
    {
      goto LABEL_246;
    }
    if (&v199.__r_.__value_.__r.__words[1] != (std::string::size_type *)sub_100046F68((uint64_t)&v199, (void **)&v54->__r_.__value_.__l.__data_))
    {
      uint64_t v55 = *((void *)&v197 + 1);
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
      v56 = (long long *)sub_10060D5AC((uint64_t **)&v199, (void **)&v54->__r_.__value_.__l.__data_, (long long **)buf)[7];
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
      uint64_t v57 = sub_10060D5AC((uint64_t **)&v199, (void **)&v54->__r_.__value_.__l.__data_, (long long **)buf)[8];
      if (v57 - (uint64_t)v56 >= 1)
      {
        uint64_t v58 = (v57 - (uint64_t)v56) / 72;
        unint64_t v59 = *((void *)&v197 + 1);
        if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)&data[-*((void *)&v197 + 1)] >> 3)) >= v58)
        {
          uint64_t v64 = *((void *)&v197 + 1) - v55;
          if ((uint64_t)(0x8E38E38E38E38E39 * ((*((void *)&v197 + 1) - v55) >> 3)) >= v58)
          {
            uint64_t v65 = (long long *)((char *)v56 + 72 * v58);
LABEL_146:
            sub_10060FE48((uint64_t)&v197, v55, v59, v55 + 72 * v58);
            sub_10060DA30(v56, v65, v55);
            goto LABEL_158;
          }
          uint64_t v65 = (long long *)((char *)v56 + 8 * ((*((void *)&v197 + 1) - v55) >> 3));
          *((void *)&v197 + 1) = sub_10060D8F4((uint64_t)v65, v57, *((uint64_t *)&v197 + 1));
          if (v64 >= 1) {
            goto LABEL_146;
          }
        }
        else
        {
          uint64_t v60 = v197;
          unint64_t v61 = v58 - 0x71C71C71C71C71C7 * ((uint64_t)(*((void *)&v197 + 1) - v197) >> 3);
          if (v61 > 0x38E38E38E38E38ELL) {
            sub_10006A748();
          }
          if (0x1C71C71C71C71C72 * ((uint64_t)&data[-v197] >> 3) > v61) {
            unint64_t v61 = 0x1C71C71C71C71C72 * ((uint64_t)&data[-v197] >> 3);
          }
          if (0x8E38E38E38E38E39 * ((uint64_t)&data[-v197] >> 3) >= 0x1C71C71C71C71C7) {
            unint64_t v62 = 0x38E38E38E38E38ELL;
          }
          else {
            unint64_t v62 = v61;
          }
          buf[1].__r_.__value_.__l.__size_ = (std::string::size_type)&data;
          if (v62) {
            unint64_t v62 = (unint64_t)sub_1003DD510(v62);
          }
          else {
            uint64_t v63 = 0;
          }
          std::string::size_type v66 = v62 + 8 * ((v55 - v60) >> 3);
          buf[0].__r_.__value_.__r.__words[0] = v62;
          buf[0].__r_.__value_.__l.__size_ = v66;
          buf[0].__r_.__value_.__r.__words[2] = v66;
          buf[1].__r_.__value_.__r.__words[0] = v62 + 72 * v63;
          std::string::size_type v67 = v66 + 72 * v58;
          uint64_t v68 = 72 * v58;
          do
          {
            sub_10060D978(v66, v56);
            v66 += 72;
            v56 = (long long *)((char *)v56 + 72);
            v68 -= 72;
          }
          while (v68);
          buf[0].__r_.__value_.__r.__words[2] = v67;
          std::string::size_type v69 = buf[0].__r_.__value_.__l.__size_;
          uint64_t v70 = v197;
          if ((void)v197 != v55)
          {
            uint64_t v71 = v55;
            do
            {
              long long v72 = *(_OWORD *)(v71 - 72);
              *(void *)(v69 - 56) = *(void *)(v71 - 56);
              *(_OWORD *)(v69 - 72) = v72;
              long long v73 = *(_OWORD *)(v71 - 48);
              *(void *)(v69 - 32) = *(void *)(v71 - 32);
              *(_OWORD *)(v69 - 48) = v73;
              *(void *)(v71 - 4sub_10010E764((uint64_t)&a9, 0) = 0;
              *(void *)(v71 - 32) = 0;
              *(void *)(v71 - 48) = 0;
              long long v74 = *(_OWORD *)(v71 - 24);
              *(void *)(v69 - 8) = *(void *)(v71 - 8);
              *(_OWORD *)(v69 - 24) = v74;
              v69 -= 72;
              *(void *)(v71 - 16) = 0;
              *(void *)(v71 - 8) = 0;
              *(void *)(v71 - 24) = 0;
              v71 -= 72;
            }
            while (v71 != v70);
            std::string::size_type v67 = buf[0].__r_.__value_.__r.__words[2];
          }
          buf[0].__r_.__value_.__l.__size_ = v69;
          uint64_t v75 = *((void *)&v197 + 1);
          if (*((void *)&v197 + 1) != v55)
          {
            do
            {
              long long v76 = *(_OWORD *)v55;
              *(void *)(v67 + 16) = *(void *)(v55 + 16);
              *(_OWORD *)std::string::size_type v67 = v76;
              long long v77 = *(_OWORD *)(v55 + 24);
              *(void *)(v67 + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(v55 + 40);
              *(_OWORD *)(v67 + 24) = v77;
              *(void *)(v55 + 32) = 0;
              *(void *)(v55 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
              *(void *)(v55 + 24) = 0;
              long long v78 = *(_OWORD *)(v55 + 48);
              *(void *)(v67 + 64) = *(void *)(v55 + 64);
              *(_OWORD *)(v67 + 48) = v78;
              *(void *)(v55 + 56) = 0;
              *(void *)(v55 + 64) = 0;
              *(void *)(v55 + 48) = 0;
              v67 += 72;
              v55 += 72;
            }
            while (v55 != v75);
            std::string::size_type v69 = buf[0].__r_.__value_.__l.__size_;
            uint64_t v55 = *((void *)&v197 + 1);
          }
          std::string::size_type v79 = v197;
          std::string::size_type v80 = (std::string::size_type)data;
          *(void *)&long long v197 = v69;
          *((void *)&v197 + 1) = v67;
          std::string::pointer data = buf[1].__r_.__value_.__l.__data_;
          buf[0].__r_.__value_.__r.__words[2] = v55;
          buf[1].__r_.__value_.__r.__words[0] = v80;
          buf[0].__r_.__value_.__r.__words[0] = v79;
          buf[0].__r_.__value_.__l.__size_ = v79;
          sub_10060D84C((uint64_t)buf);
        }
      }
    }
LABEL_158:
    ++v54;
  }
  while (v54 != v53);
  uint64_t v81 = *((void *)&v197 + 1);
  uint64_t v82 = v197;
  *((void *)&v195 + 1) = 0;
  uint64_t v196 = 0;
  *(void *)&long long v195 = (char *)&v195 + 8;
  if ((void)v197 != *((void *)&v197 + 1))
  {
    do
    {
      double v83 = *(double *)v176->i64;
      if (*(double *)v176->i64 < -90.0
        || v83 > 90.0
        || (double v84 = *v177, *v177 < -180.0)
        || v84 > 180.0
        || (double v85 = *(double *)(v82 + 16), v85 < -90.0)
        || v85 > 90.0
        || (double v86 = *(double *)(v82 + 8), v86 < -180.0)
        || v86 > 180.0)
      {
        long long v94 = *(NSObject **)(v178 + 40);
        BOOL v95 = os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT);
        double v93 = 4294967300.0;
        if (v95)
        {
          double v96 = *v177;
          std::string::size_type v98 = *(void *)(v82 + 8);
          std::string::size_type v97 = *(void *)(v82 + 16);
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 134218752;
          *(double *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v83;
          WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2048;
          *(double *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v96;
          HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2048;
          buf[1].__r_.__value_.__r.__words[0] = v97;
          LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = v98;
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I Invalid (latitude, longitude): (%f, %f), (%f, %f)", (uint8_t *)buf, 0x2Au);
          double v93 = 4294967300.0;
        }
      }
      else
      {
        double v87 = v83 * 3.14159265 / 180.0;
        double v88 = v85 * 3.14159265 / 180.0;
        long double v89 = (v86 - v84) * 3.14159265 / 180.0;
        __double2 v90 = __sincos_stret(v87);
        __double2 v91 = __sincos_stret(v88);
        long double v92 = v90.__cosval * v91.__cosval * cos(v89);
        double v93 = acos(v92 + v90.__sinval * v91.__sinval) * 6371000.0 - *(double *)v82;
      }
      double v99 = (double)(uint64_t)v93;
      long long v100 = (_OWORD *)*((void *)&v195 + 1);
      if (!*((void *)&v195 + 1)) {
        goto LABEL_180;
      }
      double v101 = (long long *)((char *)&v195 + 8);
      do
      {
        long long v102 = v100;
        long long v103 = v101;
        double v104 = *((double *)v100 + 4);
        long long v105 = (void *)v100 + 1;
        if (v104 >= v99)
        {
          long long v105 = v102;
          double v101 = v102;
        }
        long long v100 = (_OWORD *)*v105;
      }
      while (v100);
      if (v101 == (long long *)((char *)&v195 + 8)) {
        goto LABEL_180;
      }
      if (v104 < v99) {
        long long v102 = v103;
      }
      if (*((double *)v102 + 4) > v99)
      {
LABEL_180:
        *(double *)&buf[0].__r_.__value_.__l.__data_ = v99;
        long long v106 = sub_1006100BC((uint64_t **)&v195, (uint64_t **)buf, v99);
        long long v108 = v106[5];
        for (uint64_t j = (uint64_t)v106[6]; (uint64_t *)j != v108; sub_100604814(j))
          j -= 72;
        v106[6] = v108;
      }
      *(double *)&buf[0].__r_.__value_.__l.__data_ = v99;
      long long v109 = sub_1006100BC((uint64_t **)&v195, (uint64_t **)buf, v99);
      long long v110 = v109;
      long long v111 = v109[6];
      if (v111 >= v109[7])
      {
        uint64_t v112 = sub_100610190((int64x2_t *)(v109 + 5), (long long *)v82);
      }
      else
      {
        sub_10060D794((uint64_t)v109[6], (long long *)v82);
        uint64_t v112 = (uint64_t)(v111 + 9);
        v110[6] = v111 + 9;
      }
      v110[6] = (uint64_t *)v112;
      v82 += 72;
    }
    while (v82 != v81);
    long long v113 = (_OWORD *)v195;
    if ((long long *)v195 != (long long *)((char *)&v195 + 8))
    {
      do
      {
        uint64_t v115 = *((void *)v113 + 5);
        uint64_t v114 = *((void *)v113 + 6);
        memset(&v202, 0, sizeof(v202));
        if (v115 != v114)
        {
          if (*(char *)(v115 + 47) < 0) {
            sub_10004FC84(buf, *(void **)(v115 + 24), *(void *)(v115 + 32));
          }
          else {
            buf[0] = *(std::string *)(v115 + 24);
          }
          std::string v202 = buf[0];
          while (1)
          {
            v115 += 72;
            if (v115 == v114) {
              break;
            }
            *((unsigned char *)&buf[0].__r_.__value_.__s + 23) = 2;
            strcpy((char *)buf, ", ");
            std::string::append(&v202, (const std::string::value_type *)buf, 2uLL);
            if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf[0].__r_.__value_.__l.__data_);
            }
            if (*(char *)(v115 + 47) < 0)
            {
              sub_10004FC84(buf, *(void **)(v115 + 24), *(void *)(v115 + 32));
            }
            else
            {
              long long v116 = *(_OWORD *)(v115 + 24);
              buf[0].__r_.__value_.__r.__words[2] = *(void *)(v115 + 40);
              *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v116;
            }
            if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v117 = buf;
            }
            else {
              long long v117 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
            }
            if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v118 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v118 = buf[0].__r_.__value_.__l.__size_;
            }
            std::string::append(&v202, (const std::string::value_type *)v117, v118);
            if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf[0].__r_.__value_.__l.__data_);
            }
          }
        }
        v119 = *(NSObject **)(v178 + 40);
        BOOL v120 = os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT);
        char v121 = HIBYTE(v202.__r_.__value_.__r.__words[2]);
        if (v120)
        {
          v122 = &v186;
          if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            v122 = (std::string *)v186.__r_.__value_.__r.__words[0];
          }
          int v123 = (int)*((double *)v113 + 4);
          v124 = &v202;
          if ((v202.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            v124 = (std::string *)v202.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v122;
          WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v123;
          WORD1(buf[0].__r_.__value_.__r.__words[2]) = 2080;
          *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v124;
          _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#I Geohash [%s]: User is %d meters distance from geofence [%s]", (uint8_t *)buf, 0x1Cu);
          char v121 = HIBYTE(v202.__r_.__value_.__r.__words[2]);
        }
        if (v121 < 0) {
          operator delete(v202.__r_.__value_.__l.__data_);
        }
        v125 = (void *)*((void *)v113 + 1);
        if (v125)
        {
          do
          {
            v126 = v125;
            v125 = (void *)*v125;
          }
          while (v125);
        }
        else
        {
          do
          {
            v126 = (_OWORD *)*((void *)v113 + 2);
            BOOL v161 = *(void *)v126 == (void)v113;
            long long v113 = v126;
          }
          while (!v161);
        }
        long long v113 = v126;
      }
      while (v126 != (long long *)((char *)&v195 + 8));
    }
  }
LABEL_224:
  std::string::pointer v208 = 0;
  long long __p = 0u;
  memset(buf, 0, sizeof(buf));
  *(int8x16_t *)&buf[0].__r_.__value_.__r.__words[1] = vextq_s8(*v176, *v176, 8uLL);
  if (!v196)
  {
    *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 12;
    qmemcpy(&buf[1], "InactiveMode", 12);
    buf[0].__r_.__value_.__r.__words[0] = 0x40B9640000000000;
    v139 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v202.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "#I No nearby geofences, setting bounding geofence as inactive", (uint8_t *)&v202, 2u);
      unint64_t v194 = 0;
      int64x2_t v193 = 0uLL;
      std::string v202 = buf[0];
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(&v203, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
LABEL_262:
        if (SHIBYTE(v208) < 0)
        {
          sub_10004FC84(&v204, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long v204 = __p;
          std::string::pointer v205 = v208;
        }
        uint64_t v142 = *(void *)(v175 + 48);
        if (!v142) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, int64x2_t *, std::string *))(*(void *)v142 + 48))(v142, &v193, &v202);
        if (SHIBYTE(v205) < 0) {
          operator delete((void *)v204);
        }
        if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v203.__r_.__value_.__l.__data_);
        }
        v191[0] = &v193;
        v143 = v191;
        goto LABEL_347;
      }
    }
    else
    {
      int64x2_t v193 = 0uLL;
      unint64_t v194 = 0;
      std::string v202 = buf[0];
    }
    std::string v203 = buf[1];
    goto LABEL_262;
  }
  int64x2_t v193 = 0uLL;
  unint64_t v194 = 0;
  v127 = (_OWORD *)v195;
  if ((long long *)v195 == (long long *)((char *)&v195 + 8)) {
    goto LABEL_244;
  }
  unint64_t v128 = 0;
  unsigned int v129 = 0;
  while (1)
  {
    v130 = (long long *)*((void *)v127 + 5);
    v131 = (long long *)*((void *)v127 + 6);
    if (v130 != v131) {
      break;
    }
LABEL_237:
    v134 = (void *)*((void *)v127 + 1);
    if (v134)
    {
      do
      {
        v135 = v134;
        v134 = (void *)*v134;
      }
      while (v134);
    }
    else
    {
      do
      {
        v135 = (_OWORD *)*((void *)v127 + 2);
        BOOL v161 = *(void *)v135 == (void)v127;
        v127 = v135;
      }
      while (!v161);
    }
    v127 = v135;
    if (v135 == (long long *)((char *)&v195 + 8))
    {
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
      {
        buf[1].__r_.__value_.__l.__size_ = 12;
        v136 = (std::string *)buf[1].__r_.__value_.__l.__data_;
      }
      else
      {
LABEL_244:
        *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 12;
        v136 = &buf[1];
      }
      strcpy((char *)v136, "BoundingMode");
LABEL_295:
      buf[0].__r_.__value_.__r.__words[0] = 0x40B9640000000000;
      goto LABEL_296;
    }
  }
  if (v129 <= 0x13) {
    int v132 = 19;
  }
  else {
    int v132 = v129;
  }
  while (1)
  {
    double v133 = *((double *)v127 + 4);
    if (v133 > 6500.0)
    {
      if (v129)
      {
        if (v129 > 0x13) {
          goto LABEL_295;
        }
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
        {
          buf[1].__r_.__value_.__l.__size_ = 12;
          v140 = (std::string *)buf[1].__r_.__value_.__l.__data_;
        }
        else
        {
          *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 12;
          v140 = &buf[1];
        }
        strcpy((char *)v140, "BoundingMode");
        v158 = *(NSObject **)(v178 + 40);
        if (!os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_295;
        }
        LODWORD(v202.__r_.__value_.__l.__data_) = 67109376;
        HIDWORD(v202.__r_.__value_.__r.__words[0]) = v129;
        LOWORD(v202.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&v202.__r_.__value_.__r.__words[1] + 2) = 6500;
        v155 = "#I Found %d nearby geofences within %d meters radius";
        v156 = v158;
        uint32_t v157 = 14;
      }
      else
      {
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
        {
          buf[1].__r_.__value_.__l.__size_ = 12;
          v145 = (std::string *)buf[1].__r_.__value_.__l.__data_;
        }
        else
        {
          *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 12;
          v145 = &buf[1];
        }
        strcpy((char *)v145, "InactiveMode");
        v154 = *(NSObject **)(v178 + 40);
        if (!os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_295;
        }
        v202.__r_.__value_.__r.__words[0] = 0x196404000100;
        v155 = "#I No nearby geofences within %d meters radius";
        v156 = v154;
        uint32_t v157 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, v155, (uint8_t *)&v202, v157);
      goto LABEL_295;
    }
    if (v132 == v129) {
      break;
    }
    if (v128 >= v194)
    {
      unint64_t v128 = sub_100610190(&v193, v130);
    }
    else
    {
      sub_10060D794(v128, v130);
      v128 += 72;
    }
    v193.i64[1] = v128;
    ++v129;
    v130 = (long long *)((char *)v130 + 72);
    if (v130 == v131) {
      goto LABEL_237;
    }
  }
  if (v133 >= 400.0)
  {
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
    {
      buf[1].__r_.__value_.__l.__size_ = 12;
      v144 = (std::string *)buf[1].__r_.__value_.__l.__data_;
    }
    else
    {
      *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 12;
      v144 = &buf[1];
    }
    strcpy((char *)v144, "BoundingMode");
    buf[0].__r_.__value_.__r.__words[0] = *((void *)v127 + 4);
    v152 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v202.__r_.__value_.__l.__data_) = 67109632;
      HIDWORD(v202.__r_.__value_.__r.__words[0]) = v132;
      v202.__r_.__value_.__l.__size_ = 0x400000001900400;
      LODWORD(v202.__r_.__value_.__r.__words[2]) = 6500;
      v149 = "#I Found %d nearby geofences between %d and %d meters radius";
      v150 = v152;
      uint32_t v151 = 20;
      goto LABEL_284;
    }
  }
  else
  {
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
    {
      buf[1].__r_.__value_.__l.__size_ = 10;
      v141 = (std::string *)buf[1].__r_.__value_.__l.__data_;
    }
    else
    {
      *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 10;
      v141 = &buf[1];
    }
    strcpy((char *)v141, "ActiveMode");
    buf[0].__r_.__value_.__r.__words[0] = 0x4079000000000000;
    v148 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
    {
      v202.__r_.__value_.__r.__words[0] = 0x19004000100;
      v149 = "#I Too many geofences within %d meters radius";
      v150 = v148;
      uint32_t v151 = 8;
LABEL_284:
      _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, v149, (uint8_t *)&v202, v151);
    }
  }
LABEL_296:
  std::string::size_type v159 = HIBYTE(buf[1].__r_.__value_.__r.__words[2]);
  if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v159 = buf[1].__r_.__value_.__l.__size_;
  }
  if (v159 == 10)
  {
    v166 = (std::string *)buf[1].__r_.__value_.__l.__data_;
    if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v166 = &buf[1];
    }
    std::string::size_type v167 = v166->__r_.__value_.__r.__words[0];
    int v168 = LOWORD(v166->__r_.__value_.__r.__words[1]);
    BOOL v169 = v167 == 0x6F4D657669746341 && v168 == 25956;
    v165 = *(NSObject **)(v178 + 40);
    if (v169)
    {
      if (os_log_type_enabled(*(os_log_t *)(v178 + 40), OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v202.__r_.__value_.__l.__data_) = 134217984;
        *(std::string::size_type *)((char *)v202.__r_.__value_.__r.__words + 4) = buf[0].__r_.__value_.__r.__words[0];
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "#I Setting active geofence with radius %f meters", (uint8_t *)&v202, 0xCu);
      }
      uint64_t v170 = v193.i64[1];
      uint64_t v171 = v193.i64[0];
      while (v170 != v171)
      {
        v170 -= 72;
        sub_100604814(v170);
      }
      goto LABEL_334;
    }
LABEL_327:
    if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v202.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_ERROR, "Setting unknown geofence", (uint8_t *)&v202, 2u);
    }
    goto LABEL_335;
  }
  if (v159 != 12)
  {
    v165 = *(NSObject **)(v178 + 40);
    goto LABEL_327;
  }
  if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v160 = &buf[1];
  }
  else {
    v160 = (std::string *)buf[1].__r_.__value_.__l.__data_;
  }
  BOOL v161 = v160->__r_.__value_.__r.__words[0] == 0x6576697463616E49
      && LODWORD(v160->__r_.__value_.__r.__words[1]) == 1701080909;
  if (v161)
  {
    v172 = *(NSObject **)(v178 + 40);
    if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v202.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)v202.__r_.__value_.__r.__words + 4) = buf[0].__r_.__value_.__r.__words[0];
      _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "#I Setting inactive geofence with radius %f meters", (uint8_t *)&v202, 0xCu);
    }
    uint64_t v173 = v193.i64[1];
    uint64_t v171 = v193.i64[0];
    while (v173 != v171)
    {
      v173 -= 72;
      sub_100604814(v173);
    }
LABEL_334:
    v193.i64[1] = v171;
    goto LABEL_335;
  }
  std::string::size_type v162 = v160->__r_.__value_.__r.__words[0];
  uint64_t v163 = LODWORD(v160->__r_.__value_.__r.__words[1]);
  BOOL v164 = v162 == 0x676E69646E756F42 && v163 == 1701080909;
  v165 = *(NSObject **)(v178 + 40);
  if (!v164) {
    goto LABEL_327;
  }
  if (os_log_type_enabled(*(os_log_t *)(v178 + 40), OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v202.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v202.__r_.__value_.__r.__words + 4) = buf[0].__r_.__value_.__r.__words[0];
    _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "#I Setting bounding geofence with radius %f meters", (uint8_t *)&v202, 0xCu);
  }
LABEL_335:
  v191[0] = 0;
  v191[1] = 0;
  uint64_t v192 = 0;
  sub_10060DAF4(v191, v193.i64[0], v193.i64[1], 0x8E38E38E38E38E39 * ((v193.i64[1] - v193.i64[0]) >> 3));
  std::string v202 = buf[0];
  if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v203, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
  }
  else {
    std::string v203 = buf[1];
  }
  if (SHIBYTE(v208) < 0)
  {
    sub_10004FC84(&v204, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    long long v204 = __p;
    std::string::pointer v205 = v208;
  }
  uint64_t v174 = *(void *)(v175 + 48);
  if (!v174) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **, std::string *))(*(void *)v174 + 48))(v174, v191, &v202);
  if (SHIBYTE(v205) < 0) {
    operator delete((void *)v204);
  }
  if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v203.__r_.__value_.__l.__data_);
  }
  v189[0] = v191;
  sub_100604790((void ***)v189);
  v189[0] = &v193;
  v143 = v189;
LABEL_347:
  sub_100604790((void ***)v143);
  if (SHIBYTE(v208) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf[1].__r_.__value_.__l.__data_);
  }
  sub_100610320(*((char **)&v195 + 1));
LABEL_352:
  *(void *)&long long v195 = &v197;
  sub_100604790((void ***)&v195);
  sub_10060C9F8((void *)v199.__r_.__value_.__l.__size_);
  v199.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
  sub_100047F64((void ***)&v199);
LABEL_353:
  if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v186.__r_.__value_.__l.__data_);
  }
LABEL_18:
  sub_10060FDF8(&v182);
  return sub_100046B58((uint64_t *)&v181);
}

void sub_10060FA10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,__int16 a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  a39 = &a42;
  sub_100604790((void ***)&a39);
  if (a74 < 0) {
    operator delete(__p);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  sub_100610320((char *)a46);
  a45 = &a48;
  sub_100604790((void ***)&a45);
  sub_10060C9F8((void *)a52);
  a51 = &a24;
  sub_100047F64((void ***)&a51);
  if (a32 < 0) {
    operator delete(a27);
  }
  sub_10060FDF8(&a23);
  sub_100046B58(&a22);
  _Unwind_Resume(a1);
}

uint64_t *sub_10060FDF8(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10060486C((void *)(v1 + 24));
    operator delete();
  }
  return result;
}

__n128 sub_10060FE48(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = a2 + v4 - a4;
  if (v5 >= a3)
  {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v6 = (long long *)(a2 + v4 - a4);
    uint64_t v7 = *(void *)(a1 + 8);
    do
    {
      long long v8 = *v6;
      *(void *)(v7 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      long long v9 = *(long long *)((char *)v6 + 24);
      *(void *)(v7 + 4sub_10010E764((uint64_t)&a9, 0) = *((void *)v6 + 5);
      *(_OWORD *)(v7 + 24) = v9;
      *((void *)v6 + 4) = 0;
      *((void *)v6 + 5) = 0;
      *((void *)v6 + 3) = 0;
      __n128 result = (__n128)v6[3];
      *(void *)(v7 + 64) = *((void *)v6 + 8);
      *(__n128 *)(v7 + 48) = result;
      *((void *)v6 + 7) = 0;
      *((void *)v6 + 8) = 0;
      *((void *)v6 + 6) = 0;
      v7 += 72;
      uint64_t v6 = (long long *)((char *)v6 + 72);
    }
    while ((unint64_t)v6 < a3);
  }
  *(void *)(a1 + 8) = v7;
  if (v4 != a4)
  {
    uint64_t v11 = 0;
    uint64_t v12 = -8 * ((v4 - a4) >> 3);
    do
    {
      uint64_t v13 = v5 + v11;
      uint64_t v14 = v4 + v11;
      long long v15 = *(_OWORD *)(v5 + v11 - 72);
      *(void *)(v14 - 56) = *(void *)(v5 + v11 - 56);
      *(_OWORD *)(v14 - 72) = v15;
      std::string::size_type v16 = (void **)(v4 + v11 - 48);
      if (*(char *)(v4 + v11 - 25) < 0) {
        operator delete(*v16);
      }
      long long v17 = *(_OWORD *)(v13 - 48);
      *(void *)(v4 + v11 - 32) = *(void *)(v13 - 32);
      *(_OWORD *)std::string::size_type v16 = v17;
      *(unsigned char *)(v13 - 25) = 0;
      *(unsigned char *)(v13 - 48) = 0;
      unint64_t v18 = (void **)(v14 - 24);
      if (*(char *)(v14 - 1) < 0) {
        operator delete(*v18);
      }
      uint64_t v19 = v5 + v11;
      __n128 result = *(__n128 *)(v5 + v11 - 24);
      *(void *)(v14 - 8) = *(void *)(v5 + v11 - 8);
      *(__n128 *)unint64_t v18 = result;
      *(unsigned char *)(v19 - 1) = 0;
      *(unsigned char *)(v19 - 24) = 0;
      v11 -= 72;
    }
    while (v12 != v11);
  }
  return result;
}

long long **sub_10060FFA4(long long **result, void *a2, long long *a3)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = *result;
  if (*result == a3)
  {
    uint64_t v6 = (long long *)a2[1];
  }
  else
  {
    unint64_t v5 = a3;
    do
    {
      uint64_t v6 = (long long *)(v3 - 72);
      long long v7 = *(long long *)((char *)v5 - 72);
      *(void *)(v3 - 56) = *((void *)v5 - 7);
      *(_OWORD *)(v3 - 72) = v7;
      long long v8 = *(v5 - 3);
      *(void *)(v3 - 32) = *((void *)v5 - 4);
      *(_OWORD *)(v3 - 48) = v8;
      *((void *)v5 - 5) = 0;
      *((void *)v5 - 4) = 0;
      *((void *)v5 - 6) = 0;
      long long v9 = *(long long *)((char *)v5 - 24);
      *(void *)(v3 - 8) = *((void *)v5 - 1);
      *(_OWORD *)(v3 - 24) = v9;
      *((void *)v5 - 2) = 0;
      *((void *)v5 - 1) = 0;
      *((void *)v5 - 3) = 0;
      unint64_t v5 = (long long *)((char *)v5 - 72);
      v3 -= 72;
    }
    while (v5 != v4);
  }
  a2[1] = v6;
  uint64_t v10 = result[1];
  uint64_t v11 = a2[2];
  if (v10 != a3)
  {
    do
    {
      long long v12 = *a3;
      *(void *)(v11 + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v11 = v12;
      long long v13 = *(long long *)((char *)a3 + 24);
      *(void *)(v11 + 4sub_10010E764((uint64_t)&a9, 0) = *((void *)a3 + 5);
      *(_OWORD *)(v11 + 24) = v13;
      *((void *)a3 + 4) = 0;
      *((void *)a3 + 5) = 0;
      *((void *)a3 + 3) = 0;
      long long v14 = a3[3];
      *(void *)(v11 + 64) = *((void *)a3 + 8);
      *(_OWORD *)(v11 + 48) = v14;
      *((void *)a3 + 7) = 0;
      *((void *)a3 + 8) = 0;
      *((void *)a3 + 6) = 0;
      v11 += 72;
      a3 = (long long *)((char *)a3 + 72);
    }
    while (a3 != v10);
    uint64_t v6 = (long long *)a2[1];
  }
  a2[2] = v11;
  long long v15 = *result;
  char *result = v6;
  a2[1] = v15;
  std::string::size_type v16 = result[1];
  result[1] = (long long *)a2[2];
  a2[2] = v16;
  long long v17 = result[2];
  result[2] = (long long *)a2[3];
  a2[3] = v17;
  *a2 = a2[1];
  return result;
}

uint64_t **sub_1006100BC(uint64_t **a1, uint64_t **a2, double a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        double v8 = *((double *)v5 + 4);
        if (v8 <= a3) {
          break;
        }
        unint64_t v5 = (uint64_t *)*v5;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a3) {
        break;
      }
      unint64_t v5 = (uint64_t *)v5[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    long long v9 = (uint64_t *)v7;
    long long v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = *a2;
    v7[6] = 0;
    v7[7] = 0;
    v7[5] = 0;
    *long long v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_100610190(int64x2_t *a1, long long *a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL) {
    sub_10006A748();
  }
  uint64_t v6 = a1 + 1;
  if (0x1C71C71C71C71C72 * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0x1C71C71C71C71C72 * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[1].i64[0] - a1->i64[0]) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v7 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v7 = v3;
  }
  unint64_t v23 = (uint64_t *)v6;
  if (v7) {
    unint64_t v7 = (unint64_t)sub_1003DD510(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v20 = v7;
  v21.i64[0] = v7 + 72 * v2;
  v21.i64[1] = v21.i64[0];
  unint64_t v22 = v7 + 72 * v8;
  sub_10060D794(v21.i64[0], a2);
  uint64_t v10 = a1->i64[0];
  unint64_t v9 = a1->u64[1];
  uint64_t v11 = v21.i64[0];
  uint64_t v12 = v21.i64[0];
  if (v9 == a1->i64[0])
  {
    int64x2_t v16 = vdupq_n_s64(v9);
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v9 - 72);
      *(void *)(v12 - 56) = *(void *)(v9 - 56);
      *(_OWORD *)(v12 - 72) = v13;
      long long v14 = *(_OWORD *)(v9 - 48);
      *(void *)(v12 - 32) = *(void *)(v9 - 32);
      *(_OWORD *)(v12 - 48) = v14;
      *(void *)(v9 - 4sub_10010E764((uint64_t)&a9, 0) = 0;
      *(void *)(v9 - 32) = 0;
      *(void *)(v9 - 48) = 0;
      long long v15 = *(_OWORD *)(v9 - 24);
      *(void *)(v12 - 8) = *(void *)(v9 - 8);
      *(_OWORD *)(v12 - 24) = v15;
      v12 -= 72;
      *(void *)(v9 - 16) = 0;
      *(void *)(v9 - 8) = 0;
      *(void *)(v9 - 24) = 0;
      v9 -= 72;
    }
    while (v9 != v10);
    int64x2_t v16 = *a1;
  }
  uint64_t v17 = v11 + 72;
  a1->i64[0] = v12;
  a1->i64[1] = v11 + 72;
  int64x2_t v21 = v16;
  unint64_t v18 = a1[1].u64[0];
  a1[1].i64[0] = v22;
  unint64_t v22 = v18;
  unint64_t v20 = v16.i64[0];
  sub_10060D84C((uint64_t)&v20);
  return v17;
}

void sub_10061030C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10060D84C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100610320(char *a1)
{
  if (a1)
  {
    sub_100610320(*(void *)a1);
    sub_100610320(*((void *)a1 + 1));
    unint64_t v2 = (void **)(a1 + 40);
    sub_100604790(&v2);
    operator delete(a1);
  }
}

uint64_t sub_100610378()
{
  sub_100058DB0(&v31, "p0r21436x8zb9dcf5h7kjnmqesgutwvy");
  sub_100058DB0(v32, "bc01fg45238967deuvhjyznpkmstqrwx");
  unint64_t v20 = 0;
  int64x2_t v21 = 0;
  unint64_t v22 = 0;
  *(void *)&long long v29 = &v20;
  *((void *)&v29 + 1) = 0;
  unint64_t v20 = (long long *)operator new(0x30uLL);
  int64x2_t v21 = v20;
  unint64_t v22 = v20 + 3;
  int64x2_t v21 = (long long *)sub_1000D8A18((uint64_t)&v22, &v31, &v33, (char *)v20);
  LODWORD(v33) = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  *((void *)&v33 + 1) = 0;
  sub_1000302C0((char *)&v33 + 8, v20, v21, 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - (char *)v20) >> 3));
  sub_100058DB0(&v29, "14365h7k9dcfesgujnmqp0r2twvyx8zb");
  sub_100058DB0(v30, "238967debc01fg45kmstqrwxuvhjyznp");
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)&long long v27 = &v17;
  *((void *)&v27 + 1) = 0;
  uint64_t v17 = (long long *)operator new(0x30uLL);
  unint64_t v18 = v17;
  uint64_t v19 = v17 + 3;
  unint64_t v18 = (long long *)sub_1000D8A18((uint64_t)&v19, &v29, &v31, (char *)v17);
  int v36 = 1;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v37 = 0;
  sub_1000302C0((char *)&v37, v17, v18, 0xAAAAAAAAAAAAAAABLL * (((char *)v18 - (char *)v17) >> 3));
  sub_100058DB0(&v27, "bc01fg45238967deuvhjyznpkmstqrwx");
  sub_100058DB0(v28, "p0r21436x8zb9dcf5h7kjnmqesgutwvy");
  long long v14 = 0;
  long long v15 = 0;
  int64x2_t v16 = 0;
  *(void *)&long long v25 = &v14;
  *((void *)&v25 + 1) = 0;
  long long v14 = (long long *)operator new(0x30uLL);
  long long v15 = v14;
  int64x2_t v16 = v14 + 3;
  long long v15 = (long long *)sub_1000D8A18((uint64_t)&v16, &v27, &v29, (char *)v14);
  int v40 = 2;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  sub_1000302C0((char *)&v41, v14, v15, 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - (char *)v14) >> 3));
  sub_100058DB0(&v25, "238967debc01fg45kmstqrwxuvhjyznp");
  sub_100058DB0(v26, "14365h7k9dcfesgujnmqp0r2twvyx8zb");
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  long long v13 = 0;
  unint64_t v23 = &v11;
  uint64_t v24 = 0;
  uint64_t v11 = (long long *)operator new(0x30uLL);
  uint64_t v12 = v11;
  long long v13 = v11 + 3;
  uint64_t v12 = (long long *)sub_1000D8A18((uint64_t)&v13, &v25, &v27, (char *)v11);
  int v44 = 3;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = 0;
  sub_1000302C0((char *)&v45, v11, v12, 0xAAAAAAAAAAAAAAABLL * (((char *)v12 - (char *)v11) >> 3));
  sub_10060C574(&qword_101B0D1A0, (long long **)&v33, 4);
  for (uint64_t i = 104; i != -24; i -= 32)
  {
    unint64_t v23 = (long long **)((char *)&v33 + i);
    sub_100047F64((void ***)&v23);
  }
  unint64_t v23 = &v11;
  sub_100047F64((void ***)&v23);
  for (uint64_t j = 0; j != -6; j -= 3)
  {
    if (SHIBYTE(v26[j + 2]) < 0) {
      operator delete((void *)v26[j]);
    }
  }
  *(void *)&long long v25 = &v14;
  sub_100047F64((void ***)&v25);
  for (uint64_t k = 0; k != -6; k -= 3)
  {
    if (SHIBYTE(v28[k + 2]) < 0) {
      operator delete((void *)v28[k]);
    }
  }
  *(void *)&long long v27 = &v17;
  sub_100047F64((void ***)&v27);
  for (uint64_t m = 0; m != -6; m -= 3)
  {
    if (SHIBYTE(v30[m + 2]) < 0) {
      operator delete((void *)v30[m]);
    }
  }
  *(void *)&long long v29 = &v20;
  sub_100047F64((void ***)&v29);
  for (uint64_t n = 0; n != -6; n -= 3)
  {
    if (SHIBYTE(v32[n + 2]) < 0) {
      operator delete((void *)v32[n]);
    }
  }
  __cxa_atexit((void (*)(void *))sub_10060B6E0, &qword_101B0D1A0, (void *)&_mh_execute_header);
  sub_100058DB0(&v31, "prxz");
  sub_100058DB0(v32, "bcfguvyz");
  unint64_t v20 = 0;
  int64x2_t v21 = 0;
  unint64_t v22 = 0;
  *(void *)&long long v29 = &v20;
  *((void *)&v29 + 1) = 0;
  unint64_t v20 = (long long *)operator new(0x30uLL);
  int64x2_t v21 = v20;
  unint64_t v22 = v20 + 3;
  int64x2_t v21 = (long long *)sub_1000D8A18((uint64_t)&v22, &v31, &v33, (char *)v20);
  LODWORD(v33) = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  *((void *)&v33 + 1) = 0;
  sub_1000302C0((char *)&v33 + 8, v20, v21, 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - (char *)v20) >> 3));
  sub_100058DB0(&v29, "028b");
  sub_100058DB0(v30, "0145hjnp");
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)&long long v27 = &v17;
  *((void *)&v27 + 1) = 0;
  uint64_t v17 = (long long *)operator new(0x30uLL);
  unint64_t v18 = v17;
  uint64_t v19 = v17 + 3;
  unint64_t v18 = (long long *)sub_1000D8A18((uint64_t)&v19, &v29, &v31, (char *)v17);
  int v36 = 1;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v37 = 0;
  sub_1000302C0((char *)&v37, v17, v18, 0xAAAAAAAAAAAAAAABLL * (((char *)v18 - (char *)v17) >> 3));
  sub_100058DB0(&v27, "bcfguvyz");
  sub_100058DB0(v28, "prxz");
  long long v14 = 0;
  long long v15 = 0;
  int64x2_t v16 = 0;
  *(void *)&long long v25 = &v14;
  *((void *)&v25 + 1) = 0;
  long long v14 = (long long *)operator new(0x30uLL);
  long long v15 = v14;
  int64x2_t v16 = v14 + 3;
  long long v15 = (long long *)sub_1000D8A18((uint64_t)&v16, &v27, &v29, (char *)v14);
  int v40 = 2;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  sub_1000302C0((char *)&v41, v14, v15, 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - (char *)v14) >> 3));
  sub_100058DB0(&v25, "0145hjnp");
  sub_100058DB0(v26, "028b");
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  long long v13 = 0;
  unint64_t v23 = &v11;
  uint64_t v24 = 0;
  uint64_t v11 = (long long *)operator new(0x30uLL);
  uint64_t v12 = v11;
  long long v13 = v11 + 3;
  uint64_t v12 = (long long *)sub_1000D8A18((uint64_t)&v13, &v25, &v27, (char *)v11);
  int v44 = 3;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = 0;
  sub_1000302C0((char *)&v45, v11, v12, 0xAAAAAAAAAAAAAAABLL * (((char *)v12 - (char *)v11) >> 3));
  sub_10060C574(&qword_101B0D1B8, (long long **)&v33, 4);
  for (iuint64_t i = 104; ii != -24; ii -= 32)
  {
    unint64_t v23 = (long long **)((char *)&v33 + ii);
    sub_100047F64((void ***)&v23);
  }
  unint64_t v23 = &v11;
  sub_100047F64((void ***)&v23);
  for (juint64_t j = 0; jj != -6; jj -= 3)
  {
    if (SHIBYTE(v26[jj + 2]) < 0) {
      operator delete((void *)v26[jj]);
    }
  }
  *(void *)&long long v25 = &v14;
  sub_100047F64((void ***)&v25);
  for (kuint64_t k = 0; kk != -6; kk -= 3)
  {
    if (SHIBYTE(v28[kk + 2]) < 0) {
      operator delete((void *)v28[kk]);
    }
  }
  *(void *)&long long v27 = &v17;
  sub_100047F64((void ***)&v27);
  for (muint64_t m = 0; mm != -6; mm -= 3)
  {
    if (SHIBYTE(v30[mm + 2]) < 0) {
      operator delete((void *)v30[mm]);
    }
  }
  *(void *)&long long v29 = &v20;
  sub_100047F64((void ***)&v29);
  for (nuint64_t n = 0; nn != -6; nn -= 3)
  {
    if (SHIBYTE(v32[nn + 2]) < 0) {
      operator delete((void *)v32[nn]);
    }
  }
  return __cxa_atexit((void (*)(void *))sub_10060B6E0, &qword_101B0D1B8, (void *)&_mh_execute_header);
}

void sub_100610B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char *a22,uint64_t a23,char *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,char *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  for (uint64_t i = 104; i != -24; i -= 32)
  {
    a22 = (char *)(v53 + i);
    sub_100047F64((void ***)&a22);
  }
  a22 = &a10;
  sub_100047F64((void ***)&a22);
  uint64_t v57 = 0;
  while (1)
  {
    if (*((char *)&a32 + v57 + 7) < 0) {
      operator delete(*(void **)((char *)&a30 + v57));
    }
    v57 -= 24;
    if (v57 == -48)
    {
      long long __p = &a13;
      sub_100047F64((void ***)&__p);
      uint64_t v58 = 0;
      while (1)
      {
        if (*((char *)&a41 + v58 + 7) < 0) {
          operator delete(*(void **)((char *)&a39 + v58));
        }
        v58 -= 24;
        if (v58 == -48)
        {
          a33 = &a16;
          sub_100047F64((void ***)&a33);
          uint64_t v59 = 0;
          while (1)
          {
            if (*(&a53 + v59) < 0) {
              operator delete(*(void **)((char *)&a48 + v59));
            }
            v59 -= 24;
            if (v59 == -48)
            {
              a42 = &a19;
              sub_100047F64((void ***)&a42);
              uint64_t v60 = 0;
              uint64_t v61 = v54 - 232;
              while (1)
              {
                if (*(char *)(v61 + v60 + 47) < 0) {
                  operator delete(*(void **)(v61 + v60 + 24));
                }
                v60 -= 24;
                if (v60 == -48) {
                  _Unwind_Resume(a1);
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_100610FC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void **a30)
{
}

void sub_100610FE8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100610F50);
}

void sub_10061100C()
{
}

void sub_10061101C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void **a36)
{
}

uint64_t DataModel::DataModel(uint64_t a1, long long **a2)
{
  *(_OWORD *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 128) = -1;
  *(void *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 182) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 196));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 220));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 244));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 268));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 292));
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)(a1 + 320));
  *(_DWORD *)(a1 + 384) = 11;
  *(_WORD *)(a1 + 388) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  *(void *)(a1 + 40sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 408) = 0;
  sub_100612480(*a2, (void *)(a1 + 416));
  return a1;
}

void sub_10061113C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  long long v14 = *(std::__shared_weak_count **)(v10 + 408);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10013C44C(v11);
  if (*(char *)(v10 + 183) < 0) {
    operator delete(*v12);
  }
  long long v15 = *(std::__shared_weak_count **)(v10 + 144);
  if (v15) {
    sub_10004D2C8(v15);
  }
  a10 = (void **)(v10 + 104);
  sub_10011FF94(&a10);
  sub_1002C0864(&a10);
  a10 = (void **)(v10 + 56);
  sub_10005CBF0(&a10);
  int64x2_t v16 = *(std::__shared_weak_count **)(v10 + 48);
  if (v16) {
    sub_10004D2C8(v16);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(v10 + 32);
  if (v17) {
    sub_10004D2C8(v17);
  }
  a10 = (void **)v10;
  sub_10005CBF0(&a10);
  _Unwind_Resume(a1);
}

void DataModel::~DataModel(DataModel *this)
{
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 53);
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 51);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*((char *)this + 383) < 0) {
    operator delete(*((void **)this + 45));
  }
  if (*((char *)this + 351) < 0) {
    operator delete(*((void **)this + 41));
  }
  if (*((char *)this + 183) < 0) {
    operator delete(*((void **)this + 20));
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v4) {
    sub_10004D2C8(v4);
  }
  unint64_t v7 = (void **)((char *)this + 104);
  sub_10011FF94(&v7);
  unint64_t v7 = (void **)((char *)this + 80);
  sub_1002C0864(&v7);
  unint64_t v7 = (void **)((char *)this + 56);
  sub_10005CBF0(&v7);
  unint64_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = (void **)this;
  sub_10005CBF0(&v7);
}

std::string *DataModel::update(std::string *result, const std::string **a2)
{
  unint64_t v2 = *a2;
  if (*a2)
  {
    std::string::size_type size = result[17].__r_.__value_.__l.__size_;
    std::string::operator=((std::string *)size, *a2);
    std::string::operator=((std::string *)(size + 24), v2 + 1);
    int v4 = *(_DWORD *)((char *)&v2[2].__r_.__value_.__r.__words[1] + 7);
    *(_OWORD *)(size + 48) = *(_OWORD *)&v2[2].__r_.__value_.__l.__data_;
    *(_DWORD *)(size + 63) = v4;
    __n128 result = std::string::operator=((std::string *)(size + 72), v2 + 3);
    *(unsigned char *)(size + 96) = v2[4].__r_.__value_.__s.__data_[0];
  }
  return result;
}

uint64_t sub_10061130C(uint64_t a1)
{
  *(void *)a1 = off_1019EEC38;
  unint64_t v3 = (void **)(a1 + 8);
  sub_1006117BC(&v3);
  return a1;
}

void sub_100611364(uint64_t a1)
{
  *(void *)a1 = off_1019EEC38;
  uint64_t v1 = (void **)(a1 + 8);
  sub_1006117BC(&v1);
  operator delete();
}

void *DataServiceModels::DataServiceModels(void *a1)
{
  a1[1] = 0;
  unint64_t v2 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_1019EEBF0;
  DataServiceModels::makeInitialDataModelsContainer((uint64_t *)&v4);
  sub_10061175C(v2);
  *(_OWORD *)(a1 + 1) = v4;
  a1[3] = v5;
  uint64_t v5 = 0;
  long long v4 = 0uLL;
  uint64_t v6 = (void **)&v4;
  sub_1006117BC(&v6);
  return a1;
}

void sub_100611464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  void *v9 = off_1019EEC38;
  sub_1006117BC(&a9);
  _Unwind_Resume(a1);
}

void DataServiceModels::makeInitialDataModelsContainer(uint64_t *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  subscriber::makeSimSlotRange();
  unint64_t v3 = v13;
  unint64_t v2 = v14;
  if (v13 != v14)
  {
    long long v4 = v15;
    while ((v15(*v3) & 1) == 0)
    {
      if (++v3 == v14)
      {
        unint64_t v3 = v14;
        break;
      }
    }
    uint64_t v5 = v14;
    while (v3 != v5)
    {
      unsigned int v6 = *v3;
      unint64_t v7 = (char *)operator new(0x80uLL);
      *((void *)v7 + 2) = 0;
      *((void *)v7 + 1) = 0;
      *(void *)unint64_t v7 = off_1019C7410;
      *(_OWORD *)(v7 + 72) = 0u;
      *(_OWORD *)(v7 + 88) = 0u;
      *(_OWORD *)(v7 + 104) = 0u;
      *((void *)v7 + 14) = 0;
      *((void *)v7 + 15) = 0;
      *(_OWORD *)(v7 + 4sub_10010E764((uint64_t)&a9, 0) = 0u;
      *(_OWORD *)(v7 + 56) = 0u;
      *(_OWORD *)(v7 + 24) = 0u;
      v7[88] = 1;
      *((void *)v7 + 12) = 0;
      *((void *)v7 + 13) = 0;
      v7[120] = 0;
      *((_DWORD *)v7 + 19) = v6;
      *((_DWORD *)v7 + 2sub_10010E764((uint64_t)&a9, 0) = -1;
      v11[0] = (long long *)(v7 + 24);
      v11[1] = (long long *)v7;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
      DataModel::DataModel((uint64_t)v12, v11);
      unint64_t v8 = a1[1];
      if (v8 >= a1[2])
      {
        uint64_t v9 = sub_100611840(a1, (uint64_t)v12);
      }
      else
      {
        sub_100611960(a1[1], (uint64_t)v12);
        uint64_t v9 = v8 + 432;
        a1[1] = v8 + 432;
      }
      a1[1] = v9;
      DataModel::~DataModel((DataModel *)v12);
      sub_10004D2C8((std::__shared_weak_count *)v7);
      sub_10004D2C8((std::__shared_weak_count *)v7);
      uint64_t v10 = v3 + 1;
      unint64_t v3 = v2;
      if (v10 != v2)
      {
        unint64_t v3 = v10;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            unint64_t v3 = v2;
            break;
          }
        }
      }
    }
  }
}

void sub_10061163C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1006117BC((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100611698(uint64_t a1)
{
  *(void *)a1 = off_1019EEC38;
  unint64_t v3 = (void **)(a1 + 8);
  sub_1006117BC(&v3);
  return a1;
}

void sub_1006116F0(uint64_t a1)
{
  *(void *)a1 = off_1019EEC38;
  uint64_t v1 = (void **)(a1 + 8);
  sub_1006117BC(&v1);
  operator delete();
}

void sub_10061175C(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    long long v4 = v1;
    if (v3 != v1)
    {
      do
        DataModel::~DataModel((DataModel *)(v3 - 432));
      while (v3 != v1);
      long long v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1006117BC(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        DataModel::~DataModel((DataModel *)(v4 - 432));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100611840(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x84BDA12F684BDA13 * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x97B425ED097B42) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x84BDA12F684BDA13 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x4BDA12F684BDA1) {
    unint64_t v9 = 0x97B425ED097B42;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100612350(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[432 * v4];
  int64x2_t v16 = &v10[432 * v9];
  sub_100611960((uint64_t)v14, a2);
  long long v15 = v14 + 432;
  sub_1006122D8(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100612430((uint64_t)&v13);
  return v11;
}

void sub_10061194C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100612430((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100611960(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_100611C30((void *)a1, *(void **)a2, *(void **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_100611D7C((void *)(a1 + 56), *(void **)(a2 + 56), *(void **)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4);
  *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  sub_100611EC8((void *)(a1 + 80), *(void *)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 5);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = 0;
  sub_10061209C((void *)(a1 + 104), *(void *)(a2 + 104), *(void *)(a2 + 112), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 3));
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 128);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  uint64_t v6 = *(void *)(a2 + 144);
  *(void *)(a1 + 144) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  if (*(char *)(a2 + 183) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 160), *(void **)(a2 + 160), *(void *)(a2 + 168));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 160);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(_OWORD *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = v7;
  }
  uint64_t v8 = *(void *)(a2 + 184);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  *(void *)(a1 + 184) = v8;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 196), (const CSIPacketAddress *)(a2 + 196));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 220), (const CSIPacketAddress *)(a2 + 220));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 244), (const CSIPacketAddress *)(a2 + 244));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 268), (const CSIPacketAddress *)(a2 + 268));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 292), (const CSIPacketAddress *)(a2 + 292));
  MCC::MCC((MCC *)(a1 + 320), (const MCC *)(a2 + 320));
  MCC::MCC((MCC *)(a1 + 352), (const MCC *)(a2 + 352));
  int v9 = *(_DWORD *)(a2 + 384);
  *(_WORD *)(a1 + 388) = *(_WORD *)(a2 + 388);
  *(_DWORD *)(a1 + 384) = v9;
  *(unsigned char *)(a1 + 392) = *(unsigned char *)(a2 + 392);
  *(void *)(a1 + 40sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 400);
  uint64_t v10 = *(void *)(a2 + 408);
  *(void *)(a1 + 408) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 416) = *(void *)(a2 + 416);
  uint64_t v11 = *(void *)(a2 + 424);
  *(void *)(a1 + 424) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100611B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 144);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10011FF94(&a10);
  sub_1002C0864(&a10);
  sub_10005CBF0(&a10);
  long long v13 = *(std::__shared_weak_count **)(v10 + 48);
  if (v13) {
    sub_10004D2C8(v13);
  }
  long long v14 = *(std::__shared_weak_count **)(v10 + 32);
  if (v14) {
    sub_10004D2C8(v14);
  }
  a10 = (void **)v10;
  sub_10005CBF0(&a10);
  _Unwind_Resume(a1);
}

void *sub_100611C30(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001577CC(result, a4);
    __n128 result = sub_100611CB8((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100611C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void *sub_100611CB8(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  v7[3] = 1;
  uint64_t v8 = a4;
  v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_100611D44((uint64_t)v7);
  return v4;
}

uint64_t sub_100611D44(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void *sub_100611D7C(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001577CC(result, a4);
    __n128 result = sub_100611E04((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100611DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void *sub_100611E04(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  v7[3] = 1;
  uint64_t v8 = a4;
  v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_100611E90((uint64_t)v7);
  return v4;
}

uint64_t sub_100611E90(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void *sub_100611EC8(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002B2810(result, a4);
    __n128 result = (void *)sub_100611F50((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100611F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1002C0864(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100611F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v13 = a4;
  uint64_t v14 = a4;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  uint64_t v12 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = (long long *)(a2 + 8);
    do
    {
      uint64_t v7 = (uint64_t)v6 - 8;
      *(unsigned char *)uint64_t v4 = *((unsigned char *)v6 - 8);
      uint64_t v8 = (unsigned char *)(v4 + 8);
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v8, *(void **)v6, *((void *)v6 + 1));
        uint64_t v4 = v14;
      }
      else
      {
        long long v9 = *v6;
        *(void *)(v4 + 24) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v8 = v9;
      }
      v4 += 32;
      uint64_t v14 = v4;
      v6 += 2;
    }
    while (v7 + 32 != a3);
  }
  LOBYTE(v12) = 1;
  sub_10061201C((uint64_t)v11);
  return v4;
}

void sub_100612008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10061201C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100612054(a1);
  }
  return a1;
}

void sub_100612054(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0) {
      operator delete(*(void **)(v1 - 24));
    }
    v1 -= 32;
  }
}

void *sub_10061209C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100157704(result, a4);
    __n128 result = sub_100612124((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100612104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10011FF94(&a9);
  _Unwind_Resume(a1);
}

void *sub_100612124(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  void v8[2] = &v11;
  uint64_t v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      sub_1006121D4(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  sub_100612250((uint64_t)v8);
  return v4;
}

void sub_1006121C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1006121D4(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_10004EF30(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_100612234(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100612250(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100612288(a1);
  }
  return a1;
}

void sub_100612288(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      uint64_t v5 = *(void **)(v3 - 24);
      v3 -= 24;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t sub_1006122D8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10061239C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100612350(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x97B425ED097B43) {
    sub_10006A7CC();
  }
  return operator new(432 * a2);
}

uint64_t sub_10061239C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 432;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 432;
    sub_100611960(v12, v10 + a3);
  }
  return a6;
}

uint64_t sub_100612430(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 432;
    DataModel::~DataModel((DataModel *)(i - 432));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100612480@<X0>(long long *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x80uLL);
  uint64_t result = sub_1006124DC((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1006124C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006124DC(uint64_t a1, long long *a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_1019C7410;
  sub_100612538((char *)(a1 + 24), a2);
  return a1;
}

void sub_100612524(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

char *sub_100612538(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  long long v6 = a2[3];
  *(_DWORD *)(__dst + 63) = *(_DWORD *)((char *)a2 + 63);
  *((_OWORD *)__dst + 3) = v6;
  uint64_t v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)uint64_t v7 = v8;
  }
  __dst[96] = *((unsigned char *)a2 + 96);
  return __dst;
}

void sub_100612604(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100612638(void *a1)
{
  *a1 = off_101A16660;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "dev.id.fw");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 1), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_1019EEC58;
  a1[2] = 0;
  a1[3] = 0;
  return a1;
}

void sub_1006126E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

id sub_100612708(void *a1, const char *a2)
{
  id v3 = a1;
  long long v4 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  *(_OWORD *)__str = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __src = 0u;
  long long v15 = 0u;
  uint64_t v5 = 0;
  if (v3 && a2)
  {
    uint64_t v5 = [v3 base64EncodedDataWithOptions:1];
    uint64_t v7 = (char *)[v5 length];
    if (v7
      && (int v8 = snprintf(__str, 0x50uLL, "-----BEGIN %s-----\n", a2),
          uint64_t v9 = &v7[v8 + snprintf(__src, 0x50uLL, "\n-----END %s-----", a2)],
          uint64_t v10 = (char *)malloc_type_malloc((size_t)(v9 + 1), 0x80231F9DuLL),
          (uint64_t v11 = v10) != 0))
    {
      strcpy(v10, __str);
      uint64_t v12 = &v11[v8];
      objc_msgSend(v5, "getBytes:range:", v12, 0, v7);
      strcpy(&v7[(void)v12], __src);
      long long v4 = +[NSData dataWithBytesNoCopy:v11 length:v9];
      if (!v4) {
        free(v11);
      }
    }
    else
    {
      long long v4 = 0;
    }
  }

  return v4;
}

void sub_1006128B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1006128DC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  if (&_DeviceIdentityIssueClientCertificateWithCompletion)
  {
    uint64_t v10 = _NSConcreteStackBlock;
    uint64_t v11 = 3321888768;
    uint64_t v12 = sub_100612B34;
    uint64_t v13 = &unk_1019EEC70;
    uint64_t v14 = a1;
    sub_1006131D8((uint64_t)v15, a4);
    DeviceIdentityIssueClientCertificateWithCompletion();
    sub_100613154(v15);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No Device Identity support in framework", buf, 2u);
    }
    int v8 = 0;
    sub_100612A70(a4, 0, (uint64_t)&v8, 0, 0, 0);
    sub_100030068(&v8);
  }
}

void sub_100612A38(_Unwind_Exception *a1)
{
  sub_100613154(v2);

  _Unwind_Resume(a1);
}

void sub_100612A70(uint64_t a1, char a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  char v13 = a2;
  uint64_t v12 = a4;
  id v11 = a5;
  id v10 = a6;
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t *, id *, id *))(*(void *)v9 + 48))(v9, &v13, a3, &v12, &v11, &v10);
}

void sub_100612B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100612B34(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = *(void *)(a1 + 32);
  if (v8)
  {
    id v11 = *(NSObject **)(v9 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138543362;
      id v34 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Getting DeviceIdentityCertificate failed w/ %{public}@", buf, 0xCu);
    }
    uint64_t v32 = 0;
    sub_100612A70(a1 + 40, 0, (uint64_t)&v32, a2, v7, v8);
    uint64_t v12 = (const void **)&v32;
LABEL_17:
    sub_100030068(v12);
    goto LABEL_18;
  }
  if (!v7 || [v7 count] != (id)2)
  {
    long long v22 = *(NSObject **)(v9 + 8);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "DeviceIdentityCertificate has unsupported certificate count", buf, 2u);
    }
    uint64_t v31 = 0;
    sub_100612A70(a1 + 40, 0, (uint64_t)&v31, a2, v7, 0);
    uint64_t v12 = (const void **)&v31;
    goto LABEL_17;
  }
  char v13 = *(NSObject **)(v9 + 8);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Getting DeviceIdentityCertificate success", buf, 2u);
  }
  id v25 = v7;
  id v27 = objc_alloc_init((Class)NSMutableData);
  uint64_t v14 = [v25 objectAtIndexedSubscript:0];

  CFDataRef v26 = SecCertificateCopyData((SecCertificateRef)v14);
  long long v15 = sub_100612708(v26, "CERTIFICATE");
  long long v16 = *(NSObject **)(v9 + 8);
  BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  if (v15)
  {
    if (v17)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Converted BIK cert to PEM format", buf, 2u);
    }
    [v27 appendData:v15];
    long long v18 = [@"\n" dataUsingEncoding:4];
    [v27 appendData:v18];

    uint64_t v19 = [v25 objectAtIndexedSubscript:1];

    CFDataRef v24 = SecCertificateCopyData((SecCertificateRef)v19);
    uint64_t v20 = sub_100612708(v24, "CERTIFICATE");
    long long v21 = (void *)v20;
    if (v20)
    {
      [v27 appendData:v20];
      id v28 = v27;
      sub_100612A70(a1 + 40, 1, (uint64_t)&v28, a2, v25, 0);
      sub_100030068((const void **)&v28);
    }
    else
    {
      long long v23 = *(NSObject **)(v9 + 8);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Failed converting intermediate cert to PEM", buf, 2u);
      }
      long long v29 = 0;
      sub_100612A70(a1 + 40, 0, (uint64_t)&v29, a2, v25, 0);
      sub_100030068(&v29);
    }
  }
  else
  {
    if (v17)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed converting BIK cert to PEM", buf, 2u);
    }
    uint64_t v30 = 0;
    sub_100612A70(a1 + 40, 0, (uint64_t)&v30, a2, v25, 0);
    sub_100030068(&v30);
  }

LABEL_18:
}

void sub_100612FB8(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100030068((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t sub_100613078(uint64_t a1, uint64_t a2)
{
  return sub_1006131D8(a1 + 40, a2 + 40);
}

void *sub_100613084(uint64_t a1)
{
  return sub_100613154((void *)(a1 + 40));
}

void *sub_10061308C(void *a1)
{
  *a1 = off_1019EEC58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_1006130E0(void *a1)
{
  *a1 = off_1019EEC58;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void *sub_100613154(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1006131D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100613278(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1006132AC(capabilities::ct *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  int v6 = capabilities::ct::supportsCarrierSpace(a1);
  *a3 = 0;
  a3[1] = 0;
  if (!v6) {
    return;
  }
  id v7 = (char *)operator new(0x260uLL);
  *((void *)v7 + 1) = 0;
  *(void *)id v7 = off_1019EF068;
  id v8 = v7 + 24;
  uint64_t v10 = *a2;
  uint64_t v9 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *((void *)v7 + 2) = 0;
  uint64_t v21 = v9;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "carrier.space.ctr");
  id v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v12 = dispatch_queue_create("CarrierSpaceController", v11);
  *((void *)v7 + 8) = 0;
  *((void *)v7 + 9) = 0;
  *((void *)v7 + 1sub_10010E764((uint64_t)&a9, 0) = v12;
  if (v12)
  {
    char v13 = v12;
    dispatch_retain(v12);
    *((void *)v7 + 11) = 0;
    dispatch_release(v13);
  }
  else
  {
    *((void *)v7 + 11) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v23, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v7 + 96), (const ctu::OsLogLogger *)v23);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v23);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  v23[0] = off_1019AF850;
  v23[1] = sub_100613BE4;
  v23[3] = v23;
  *((void *)v7 + 13) = 0;
  if ((capabilities::ct::supportsGemini(v14) & 1) == 0) {
    operator new();
  }
  if (!*((void *)v7 + 13)) {
    operator new();
  }
  sub_10008863C(v23);
  *((void *)v7 + 3) = off_1019EED48;
  *((void *)v7 + 4) = off_1019EEE40;
  *((void *)v7 + 5) = off_1019EEE80;
  *((void *)v7 + 6) = off_1019EEEB0;
  *((void *)v7 + 7) = off_1019EEEE8;
  long long v15 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UNSPECIFIED, 0);
  dispatch_queue_t v16 = dispatch_queue_create_with_target_V2("CarrierSpaceController", v15, *((dispatch_queue_t *)v7 + 10));
  *((void *)v7 + 3) = off_1019EED48;
  *((void *)v7 + 4) = off_1019EEE40;
  *((void *)v7 + 5) = off_1019EEE80;
  *((void *)v7 + 6) = off_1019EEEB0;
  *((void *)v7 + 7) = off_1019EEEE8;
  long long v18 = *(Registry **)a1;
  uint64_t v17 = *((void *)a1 + 1);
  *((void *)v7 + 14) = v16;
  *((void *)v7 + 15) = v18;
  *((void *)v7 + 16) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CarrierSpaceController");
  uint64_t v19 = *((void *)v7 + 10);
  long long v22 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  ctu::RestModule::RestModule();
  if (v22) {
    dispatch_release(v22);
  }
  if (v25 < 0) {
    operator delete(__p.var0);
  }
  *((void *)v7 + 19) = v10;
  *((void *)v7 + 2sub_10010E764((uint64_t)&a9, 0) = v21;
  (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
  (*(void (**)(void))(**((void **)v7 + 19) + 24))(*((void *)v7 + 19));
  *(_OWORD *)(v7 + 248) = 0u;
  *(_OWORD *)(v7 + 232) = 0u;
  *(_OWORD *)(v7 + 216) = 0u;
  *(_OWORD *)(v7 + 20sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(v7 + 264) = 0u;
  *(_OWORD *)(v7 + 28sub_10010E764((uint64_t)&a9, 0) = 0u;
  *((void *)v7 + 37) = v7 + 296;
  *((void *)v7 + 38) = v7 + 296;
  *(_OWORD *)(v7 + 312) = 0u;
  *(_OWORD *)(v7 + 328) = 0u;
  *(_OWORD *)(v7 + 344) = 0u;
  *(_OWORD *)(v7 + 36sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(v7 + 376) = 0u;
  *(_OWORD *)(v7 + 385) = 0u;
  *(void *)(v7 + 404) = 0;
  *(void *)(v7 + 412) = 0;
  *((_DWORD *)v7 + 107) = 0;
  *(void *)(v7 + 42sub_10010E764((uint64_t)&a9, 0) = 0;
  *((void *)v7 + 51) = v7 + 416;
  *((void *)v7 + 54) = xpc_null_create();
  *((_OWORD *)v7 + 29) = 0u;
  *((_OWORD *)v7 + 3sub_10010E764((uint64_t)&a9, 0) = 0u;
  *((void *)v7 + 62) = 0;
  v7[504] = 1;
  *((_DWORD *)v7 + 15sub_10010E764((uint64_t)&a9, 0) = 0;
  v7[509] = 0;
  *(_DWORD *)(v7 + 505) = 0;
  *((void *)v7 + 65) = 0;
  *((void *)v7 + 64) = 0;
  v7[528] = 0;
  *(_OWORD *)(v7 + 536) = 0u;
  *(_OWORD *)(v7 + 552) = 0u;
  *(_OWORD *)(v7 + 568) = 0u;
  *(_OWORD *)(v7 + 577) = 0u;
  *((void *)v7 + 3) = off_1019EF0B8;
  *((void *)v7 + 4) = off_1019EF1B0;
  *((void *)v7 + 5) = off_1019EF1F0;
  *((void *)v7 + 6) = off_1019EF220;
  *((void *)v7 + 7) = off_1019EF258;
  uint64_t v20 = (std::__shared_weak_count *)*((void *)v7 + 9);
  if (!v20)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 2, 1uLL, memory_order_relaxed);
    *((void *)v7 + 8) = v8;
    *((void *)v7 + 9) = v7;
    goto LABEL_21;
  }
  if (v20->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 2, 1uLL, memory_order_relaxed);
    *((void *)v7 + 8) = v8;
    *((void *)v7 + 9) = v7;
    std::__shared_weak_count::__release_weak(v20);
LABEL_21:
    sub_10004D2C8((std::__shared_weak_count *)v7);
  }
  *a3 = v8;
  a3[1] = v7;
  __p.var0 = 0;
  __p.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a1);
  if (__p.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (__p.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)__p.var1.fRef);
  }
}

void sub_1006139C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, CarrierSpacePlanProvisioningDelegateInterface *a12, CarrierSpaceAuthFlowManagerDelegateInterface *a13, CarrierSpaceEntitlementsHandlerDelegateInterface *a14, uint64_t a15, CarrierSpaceDataPlanMetricsProviderDelegateInterface *a16, dispatch_object_t object, dispatch_object_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

const char *sub_100613BE4(int a1)
{
  uint64_t v1 = "carrier.space.ctr.?";
  if (a1 == 2) {
    uint64_t v1 = "carrier.space.ctr.2";
  }
  if (a1 == 1) {
    return "carrier.space.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_100613C10(uint64_t a1)
{
  *(void *)a1 = off_1019EED48;
  uint64_t v2 = (CarrierSpaceEntitlementsHandlerDelegateInterface *)(a1 + 8);
  *(void *)(a1 + 8) = off_1019EEE40;
  uint64_t v3 = (CarrierSpaceAuthFlowManagerDelegateInterface *)(a1 + 16);
  *(void *)(a1 + 16) = off_1019EEE80;
  long long v4 = (CarrierSpacePlanProvisioningDelegateInterface *)(a1 + 24);
  *(void *)(a1 + 24) = off_1019EEEB0;
  uint64_t v5 = (CarrierSpaceDataPlanMetricsProviderDelegateInterface *)(a1 + 32);
  *(void *)(a1 + 32) = off_1019EEEE8;
  for (uint64_t i = 560; i != 520; i -= 8)
    sub_10007CA64((const void **)(a1 + i));
  uint64_t v7 = *(void *)(a1 + 520);
  *(void *)(a1 + 52sub_10010E764((uint64_t)&a9, 0) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 512);
  *(void *)(a1 + 512) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  sub_10007CA64((const void **)(a1 + 472));
  long long v22 = (void **)(a1 + 448);
  sub_10061B228(&v22);
  sub_10061B120((void *)(a1 + 416));
  xpc_release(*(xpc_object_t *)(a1 + 408));
  *(void *)(a1 + 408) = 0;
  sub_100087F94(a1 + 384, *(void **)(a1 + 392));
  if (*(char *)(a1 + 375) < 0) {
    operator delete(*(void **)(a1 + 352));
  }
  sub_10061B1A4((void *)(a1 + 296));
  sub_100160A84((atomic_uint **)(a1 + 272));
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 264);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 248);
  if (v10) {
    sub_10004D2C8(v10);
  }
  id v11 = *(std::__shared_weak_count **)(a1 + 232);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 216);
  if (v12) {
    sub_10004D2C8(v12);
  }
  char v13 = *(std::__shared_weak_count **)(a1 + 200);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 184);
  if (v14) {
    sub_10004D2C8(v14);
  }
  long long v15 = *(std::__shared_weak_count **)(a1 + 168);
  if (v15) {
    sub_10004D2C8(v15);
  }
  dispatch_queue_t v16 = *(std::__shared_weak_count **)(a1 + 152);
  if (v16) {
    sub_10004D2C8(v16);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 136);
  if (v17) {
    sub_10004D2C8(v17);
  }
  long long v18 = *(std::__shared_weak_count **)(a1 + 120);
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 104);
  if (v19) {
    sub_10004D2C8(v19);
  }
  uint64_t v20 = *(NSObject **)(a1 + 88);
  if (v20) {
    dispatch_release(v20);
  }
  uint64_t v21 = *(void *)(a1 + 80);
  *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_100087E88((void *)(a1 + 40));
  CarrierSpaceDataPlanMetricsProviderDelegateInterface::~CarrierSpaceDataPlanMetricsProviderDelegateInterface(v5);
  CarrierSpacePlanProvisioningDelegateInterface::~CarrierSpacePlanProvisioningDelegateInterface(v4);
  CarrierSpaceAuthFlowManagerDelegateInterface::~CarrierSpaceAuthFlowManagerDelegateInterface(v3);
  CarrierSpaceEntitlementsHandlerDelegateInterface::~CarrierSpaceEntitlementsHandlerDelegateInterface(v2);

  CarrierSpaceControllerInterface::~CarrierSpaceControllerInterface((CarrierSpaceControllerInterface *)a1);
}

void sub_100613ED0(uint64_t a1)
{
}

void sub_100613ED8(uint64_t a1)
{
}

void sub_100613EE0(uint64_t a1)
{
}

void sub_100613EE8(uint64_t a1)
{
}

void sub_100613EF0(uint64_t a1)
{
  sub_100613C10(a1);

  operator delete();
}

void sub_100613F28(uint64_t a1)
{
  sub_100613C10(a1 - 8);

  operator delete();
}

void sub_100613F64(uint64_t a1)
{
  sub_100613C10(a1 - 16);

  operator delete();
}

void sub_100613FA0(uint64_t a1)
{
  sub_100613C10(a1 - 24);

  operator delete();
}

void sub_100613FDC(uint64_t a1)
{
  sub_100613C10(a1 - 32);

  operator delete();
}

void sub_100614018(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100614118(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006141E4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 481)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fCarrierSpaceSupported = %s", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 481))
  {
    long long v4 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 482)) {
        uint64_t v5 = "true";
      }
      else {
        uint64_t v5 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fServicesSupported = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 483)) {
        int v6 = "true";
      }
      else {
        int v6 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fUsageSupported = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 484)) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fPlansSupported = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 485)) {
        uint64_t v8 = "true";
      }
      else {
        uint64_t v8 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fAppsSupported = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 488);
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fAutoRefreshMinIntervalMins = %ld", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 496);
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fManualRefreshMinIntervalMins = %ld", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 504)) {
        id v11 = "true";
      }
      else {
        id v11 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fDataOptimizationAllowed = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v12 = *(char *)(a1 + 568);
      if (v12 > 7) {
        char v13 = "???";
      }
      else {
        char v13 = off_1019F0450[v12];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fRefreshInProgressTypeMasuint64_t k = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = sub_100FB56F4(*(_DWORD *)(a1 + 572));
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fLastRefreshStatus = %s", buf, 0xCu);
      long long v4 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(int *)(a1 + 576);
      if (v15 > 3) {
        dispatch_queue_t v16 = "???";
      }
      else {
        dispatch_queue_t v16 = off_1019F0320[v15];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fSuspensionCause = %s", buf, 0xCu);
    }
    CFLocaleRef v37 = CFLocaleCopyCurrent();
    CFStringRef theString = 0;
    CFDateFormatterRef formatter = CFDateFormatterCreate(kCFAllocatorDefault, v37, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
    CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, formatter, *(CFDateRef *)(a1 + 536));
    CFStringRef theString = StringWithDate;
    long long v18 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(StringWithDate, 0x8000100u);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "kInfoTypeUsage";
      __int16 v39 = 2080;
      int v40 = CStringPtr;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I fLastRefreshTimestamps[%s] = %s", buf, 0x16u);
    }
    CFStringRef v20 = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, formatter, *(CFDateRef *)(a1 + 544));
    CFStringRef v21 = theString;
    CFStringRef theString = v20;
    *(void *)std::string buf = v21;
    sub_1000558F4((const void **)buf);
    long long v22 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      long long v23 = CFStringGetCStringPtr(theString, 0x8000100u);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "kInfoTypePlans";
      __int16 v39 = 2080;
      int v40 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I fLastRefreshTimestamps[%s] = %s", buf, 0x16u);
    }
    CFStringRef v24 = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, formatter, *(CFDateRef *)(a1 + 552));
    CFStringRef v25 = theString;
    CFStringRef theString = v24;
    *(void *)std::string buf = v25;
    sub_1000558F4((const void **)buf);
    CFDataRef v26 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      id v27 = CFStringGetCStringPtr(theString, 0x8000100u);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "kInfoTypeApps";
      __int16 v39 = 2080;
      int v40 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I fLastRefreshTimestamps[%s] = %s", buf, 0x16u);
    }
    CFStringRef v28 = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, formatter, *(CFDateRef *)(a1 + 560));
    CFStringRef v29 = theString;
    CFStringRef theString = v28;
    *(void *)std::string buf = v29;
    sub_1000558F4((const void **)buf);
    uint64_t v30 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = CFStringGetCStringPtr(theString, 0x8000100u);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "kInfoTypeAll";
      __int16 v39 = 2080;
      int v40 = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I fLastRefreshTimestamps[%s] = %s", buf, 0x16u);
    }
    uint64_t v32 = *(void *)(a1 + 176);
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
    }
    uint64_t v33 = *(void *)(a1 + 224);
    if (v33) {
      (*(void (**)(uint64_t))(*(void *)v33 + 64))(v33);
    }
    uint64_t v34 = *(void *)(a1 + 192);
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 96))(v34);
    }
    sub_1000558F4((const void **)&theString);
    sub_100201E7C((const void **)&formatter);
    sub_100201EB0((const void **)&v37);
  }
}

void sub_1006148F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100201E7C((const void **)va1);
  sub_100201EB0((const void **)va2);
  _Unwind_Resume(a1);
}

void sub_10061494C(uint64_t a1, uint64_t a2)
{
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  sub_100614DA0(a1, a2);
  if (*(unsigned char *)(a1 + 481)) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  *(_DWORD *)(a1 + 328) = v4;
  *(void *)(a1 + 34sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 332) = 0;
  *(_DWORD *)(a1 + 348) = 0;
  uint64_t v5 = *(void *)(a1 + 320);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, a1 + 328);
  }
  int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
  uint64_t v7 = v6;
  if (*(unsigned char *)(a1 + 481))
  {
    uint64_t v8 = (int *)(a1 + 572);
    *(void *)(a1 + 572) = 6000;
    CFStringRef v21 = 0;
    CFPreferencesCopyValueForCurrentUserAnyHost();
    sub_1000842D0(&v21, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v21) {
      uint64_t v10 = sub_100081E58;
    }
    else {
      uint64_t v10 = 0;
    }
    if (v10)
    {
      *(_DWORD *)std::string buf = 0;
      ctu::cf::assign((ctu::cf *)buf, v21, v9);
      int v11 = *(_DWORD *)buf;
      int *v8 = *(_DWORD *)buf;
    }
    else
    {
      int v11 = *v8;
    }
    if (v11 == 6002)
    {
      int v13 = 1;
      *(_DWORD *)(a1 + 576) = 1;
    }
    else
    {
      int v13 = *(_DWORD *)(a1 + 576);
      if (!v13)
      {
LABEL_24:
        sub_1000570E8((const void **)&v21);
        (*(void (**)(void))(**(void **)(a1 + 208) + 24))(*(void *)(a1 + 208));
        if (*(unsigned char *)(a1 + 504)) {
          (*(void (**)(void))(**(void **)(a1 + 240) + 32))(*(void *)(a1 + 240));
        }
        if (!*(_DWORD *)(a1 + 576)) {
          (*(void (**)(void, void, void, void, void))(**(void **)(a1 + 208) + 40))(*(void *)(a1 + 208), *(unsigned __int8 *)(a1 + 482), *(unsigned __int8 *)(a1 + 483), *(unsigned __int8 *)(a1 + 484), *(unsigned __int8 *)(a1 + 485));
        }
        uint64_t v16 = *(void *)(a1 + 176);
        unsigned __int8 v17 = *(unsigned char *)(a1 + 483);
        if (*(unsigned char *)(a1 + 484)) {
          v17 |= 2u;
        }
        if (*(unsigned char *)(a1 + 485)) {
          v17 |= 4u;
        }
        v22[0] = off_1019EF3D8;
        v22[1] = a1;
        v22[2] = v7;
        v22[3] = v22;
        (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v16 + 24))(v16, a2, v17, v22);
        sub_10061DB8C(v22);
        uint64_t v18 = *(void *)(a1 + 144);
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 208) + 88))(&v19);
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v18 + 40))(v18, &v19);
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_1006150D0((const void **)a1);
        sub_10061873C(a1, *(unsigned int *)(a1 + 380), 7, 2);
        return;
      }
    }
    uint64_t v14 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if ((v13 - 1) > 2) {
        uint64_t v15 = "???";
      }
      else {
        uint64_t v15 = off_1019F0308[v13 - 1];
      }
      *(_DWORD *)std::string buf = 136315138;
      CFStringRef v24 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I fSuspensionCause = %s", buf, 0xCu);
    }
    goto LABEL_24;
  }
  unint64_t v12 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I CarrierSpace is not supported", buf, 2u);
  }
}

void sub_100614D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100614DA0(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = 0;
  CFStringRef v25 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    int v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v24 = v12;
  CFStringRef v25 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
  if (v12)
  {
    uint64_t isCarrierSpaceFeatureEnabled = carrier_space::isCarrierSpaceFeatureEnabled();
    *(unsigned char *)(a1 + 481) = isCarrierSpaceFeatureEnabled;
    *(unsigned char *)(a1 + 482) = isCarrierSpaceFeatureEnabled;
    *(unsigned char *)(a1 + 483) = sub_100527BA0(a2, (uint64_t)&v24, carrier_space::kCBSupportsUsageKey, isCarrierSpaceFeatureEnabled);
    *(unsigned char *)(a1 + 484) = sub_100527BA0(a2, (uint64_t)&v24, carrier_space::kCBSupportsPlansKey, *(unsigned __int8 *)(a1 + 481));
    *(unsigned char *)(a1 + 485) = sub_100527BA0(a2, (uint64_t)&v24, carrier_space::kCBSupportsAppsKey, *(unsigned __int8 *)(a1 + 481));
    *(void *)(a1 + 488) = (int)sub_100615B48(a2, (uint64_t)&v24, carrier_space::kCBAutoRefreshMinimumIntervalMinsKey, 1440);
    *(void *)(a1 + 496) = (int)sub_100615B48(a2, (uint64_t)&v24, carrier_space::kCBManualRefreshMinimumIntervalMinsKey, 30);
    int v14 = sub_100527BA0(a2, (uint64_t)&v24, carrier_space::kCBDataOptimizationAllowedKey, *(unsigned __int8 *)(a1 + 481));
    *(unsigned char *)(a1 + 504) = v14;
    uint64_t v15 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "true";
      if (*(unsigned char *)(a1 + 481)) {
        unsigned __int8 v17 = "true";
      }
      else {
        unsigned __int8 v17 = "false";
      }
      if (*(unsigned char *)(a1 + 483)) {
        uint64_t v18 = "true";
      }
      else {
        uint64_t v18 = "false";
      }
      int v19 = *(unsigned __int8 *)(a1 + 485);
      if (*(unsigned char *)(a1 + 484)) {
        CFStringRef v20 = "true";
      }
      else {
        CFStringRef v20 = "false";
      }
      *(_DWORD *)std::string buf = 136316162;
      if (v19) {
        CFStringRef v21 = "true";
      }
      else {
        CFStringRef v21 = "false";
      }
      *(void *)&uint8_t buf[4] = v17;
      __int16 v27 = 2080;
      if (!v14) {
        uint64_t v16 = "false";
      }
      CFStringRef v28 = v18;
      __int16 v29 = 2080;
      uint64_t v30 = v20;
      __int16 v31 = 2080;
      uint64_t v32 = v21;
      __int16 v33 = 2080;
      uint64_t v34 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I CarrierSpace feature supported %s, usageSupported %s, plansSupported %s, appsSupported %s, dataOpt %s", buf, 0x34u);
      uint64_t v15 = *(NSObject **)(a1 + 72);
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = *(void *)(a1 + 488);
      long long v23 = *(const char **)(a1 + 496);
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v22;
      __int16 v27 = 2048;
      CFStringRef v28 = v23;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Auto refresh interval: %ld mins, Manual refresh interval: %ld mins", buf, 0x16u);
    }
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_1006150A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1006150D0(const void **result)
{
  uint64_t v1 = result[61];
  if (v1)
  {
    uint64_t v2 = (uint64_t)result;
    uint64_t v3 = result[64];
    if (v3)
    {
      *(void *)(v2 + 512) = 0;
      (*(void (**)(const void *))(*(void *)v3 + 8))(v3);
      uint64_t v1 = *(const void **)(v2 + 488);
    }
    CFDateRef theDate = 0;
    sub_100615BF4(&theDate, v2);
    CFDateRef otherDate = 0;
    sub_100617F90((const void **)&otherDate, (const void **)v2, 7u);
    if (theDate) {
      int v4 = sub_1001908E4;
    }
    else {
      int v4 = 0;
    }
    if (!v4) {
      goto LABEL_33;
    }
    if (!(otherDate ? sub_1001908E4 : 0)) {
      goto LABEL_33;
    }
    uint64_t v6 = 60 * (void)v1;
    uint64_t TimeIntervalSinceDate = (uint64_t)CFDateGetTimeIntervalSinceDate(theDate, otherDate);
    uint64_t v8 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      uint64_t v31 = TimeIntervalSinceDate;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I time since last update: %lld secs", buf, 0xCu);
    }
    uint64_t v9 = v6 - TimeIntervalSinceDate;
    if (TimeIntervalSinceDate < 0
      || (v6 >= TimeIntervalSinceDate ? (BOOL v10 = v6 == TimeIntervalSinceDate) : (BOOL v10 = 1), v10))
    {
LABEL_33:
      sub_100618050(v2);
    }
    else
    {
      int v11 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134218240;
        uint64_t v31 = v6 - TimeIntervalSinceDate;
        __int16 v32 = 2048;
        uint64_t v33 = v9 / 3600;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Scheduling an update check in secs: %lld, in hours: %ld", buf, 0x16u);
      }
      uint64_t v12 = *(std::__shared_weak_count **)(v2 + 48);
      if (!v12 || (v13 = *(void *)(v2 + 40), (int v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v15 = v14;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      Registry::getTimerService(&v23, *(Registry **)(v2 + 96));
      uint64_t v16 = v23;
      sub_100058DB0(v21, "Carrier Space Auto update timer");
      *(_OWORD *)OsLogContext __p = *(_OWORD *)v21;
      uint64_t v29 = v22;
      v21[0] = 0;
      v21[1] = 0;
      uint64_t v22 = 0;
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v34 = 0;
      unsigned __int8 v17 = operator new(0x20uLL);
      void *v17 = off_1019EFCC8;
      v17[1] = v2;
      v17[2] = v13;
      v17[3] = v15;
      uint64_t v34 = v17;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, uint8_t *))(*(void *)v16 + 40))(&v25, v16, __p, 1, 1000000 * v9, 0, buf);
      sub_10003B34C(buf);
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v18 = v25;
      uint64_t v25 = 0;
      uint64_t v19 = *(void *)(v2 + 512);
      *(void *)(v2 + 512) = v18;
      if (v19)
      {
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        uint64_t v20 = v25;
        uint64_t v25 = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
        }
      }
      if (SHIBYTE(v22) < 0) {
        operator delete(v21[0]);
      }
      if (v24) {
        sub_10004D2C8(v24);
      }
      std::__shared_weak_count::__release_weak(v15);
    }
    sub_10007CA64((const void **)&otherDate);
    return sub_10007CA64((const void **)&theDate);
  }
  return result;
}

void sub_100615458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27)
{
  sub_10003B34C(&a27);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  std::__shared_weak_count::__release_weak(v27);
  sub_10007CA64(&a18);
  sub_10007CA64(&a19);
  _Unwind_Resume(a1);
}

const void **sub_1006154E8(uint64_t a1)
{
  sub_1006155EC(a1);
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 192);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 80))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 224);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  }
  long long v6 = 0u;
  long long v7 = 0u;
  sub_100615898(a1 + 416, (uint64_t)&v6);
  sub_10007CA64((const void **)&v7 + 1);
  uint64_t v8 = (void **)&v6;
  sub_10061B228(&v8);
  *(unsigned char *)(a1 + 481) = 0;
  *(_DWORD *)(a1 + 576) = 0;
  return sub_1006159A0(a1, 6000);
}

void sub_1006155D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1006155EC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 576);
    if (v3 > 3) {
      uint64_t v4 = "???";
    }
    else {
      uint64_t v4 = off_1019F0320[v3];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I suspend with cause %s", buf, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 208);
  if (v5) {
    (*(void (**)(uint64_t, void, void, void, void))(*(void *)v5 + 40))(v5, 0, 0, 0, 0);
  }
  uint64_t v6 = *(void *)(a1 + 240);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 176);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v13 = 0;
  sub_100615A24(a1, 7u, &v13);
  sub_10007CA64(&v13);
  *(unsigned char *)(a1 + 568) = 0;
  uint64_t v8 = *(void *)(a1 + 520);
  if (v8)
  {
    *(void *)(a1 + 52sub_10010E764((uint64_t)&a9, 0) = 0;
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 144);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 208) + 88))(&v11);
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 40))(v9, &v11);
  if (v12) {
    sub_10004D2C8(v12);
  }
  (*(void (**)(void))(**(void **)(a1 + 144) + 80))(*(void *)(a1 + 144));
  *(_DWORD *)(a1 + 328) = 1;
  *(_DWORD *)(a1 + 348) = 0;
  *(void *)(a1 + 34sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 332) = 0;
  uint64_t result = *(void *)(a1 + 320);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a1 + 328);
  }
  return result;
}

void sub_100615868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100615898(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 32;
  uint64_t v4 = *(const void ***)(a1 + 32);
  if (v4)
  {
    sub_10061B27C((const void **)(a1 + 32), v4);
    operator delete(*(void **)v5);
    *(void *)uint64_t v5 = 0;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
  }
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
  *(void *)(a1 + 48) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (v5 != a2)
  {
    uint64_t v6 = *(const void **)(a1 + 56);
    *(void *)(a1 + 56) = 0;
    uint64_t v8 = v6;
    *(void *)(a1 + 56) = *(void *)(a2 + 24);
    *(void *)(a2 + 24) = 0;
    sub_10007CA64(&v8);
  }
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v5);
  }
  return result;
}

uint64_t sub_100615960(uint64_t a1)
{
  sub_10007CA64((const void **)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_10061B228(&v3);
  return a1;
}

const void **sub_1006159A0(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 572) = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 572));
  CFPreferencesPersistValueForCurrentUserAnyHost();
  return sub_1000570E8((const void **)&v3);
}

void sub_100615A10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100615A24(uint64_t result, unsigned int a2, const void **a3)
{
  unsigned int v4 = a2;
  uint64_t v5 = (const void **)result;
  if ((a2 & 1) == 0)
  {
    if ((a2 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_13:
    sub_100602120(v5 + 68, a3);
    uint64_t result = CFPreferencesPersistValueForCurrentUserAnyHost();
    if ((v4 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  sub_100602120((const void **)(result + 536), a3);
  uint64_t result = CFPreferencesPersistValueForCurrentUserAnyHost();
  if ((v4 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_3:
  if ((v4 & 4) != 0)
  {
LABEL_4:
    sub_100602120(v5 + 69, a3);
    uint64_t result = CFPreferencesPersistValueForCurrentUserAnyHost();
  }
LABEL_5:
  unsigned int v6 = 0;
  do
  {
    v6 += v4 & 1;
    if (v4 < 2) {
      break;
    }
    v4 >>= 1;
  }
  while (v6 < 2);
  if (v6 >= 2)
  {
    sub_100602120(v5 + 70, a3);
    return CFPreferencesPersistValueForCurrentUserAnyHost();
  }
  return result;
}

uint64_t sub_100615B48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  carrier_space::getCarrierSpaceValueForKey();
  sub_1000577C4(&cf);
  return a4;
}

void sub_100615BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100615BF4(CFDateRef *a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 96));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, &v17);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_7;
    }
LABEL_12:
    double Current = (*(double (**)(uint64_t))(*(void *)v12 + 96))(v12);
    goto LABEL_13;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
    goto LABEL_12;
  }
LABEL_7:
  int v14 = *(NSObject **)(a2 + 72);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v16 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "failed to get TimeHandlerInterface", v16, 2u);
  }
  double Current = CFAbsoluteTimeGetCurrent();
LABEL_13:
  *a1 = CFDateCreate(kCFAllocatorDefault, Current);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100615D64(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100615D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_10061DC10;
  aBlock[3] = &unk_1019EF458;
  aBlock[4] = a2;
  aBlock[5] = a4;
  aBlock[6] = a5;
  unint64_t v6 = _Block_copy(aBlock);
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      unsigned int v9 = v8;
      BOOL v10 = *(NSObject **)(a2 + 16);
      dispatch_object_t object = v10;
      if (v6)
      {
        uint64_t v11 = _Block_copy(v6);
        BOOL v10 = object;
      }
      else
      {
        uint64_t v11 = 0;
      }
      int v14 = v11;
      dispatch_retain(v10);
      long long v15 = 0u;
      long long v16 = 0u;
      sub_10061E120(v17, v10, v11);
      sub_10061E120(v18, v17[0], v17[1]);
      sub_10061E120(v21, v18[0], v18[1]);
      uint64_t v19 = 0;
      sub_10061E120(v22, v21[0], v21[1]);
      sub_10061E120(v23, v22[0], v22[1]);
      sub_10061E120(v24, v23[0], v23[1]);
      sub_10061E120(v25, v24[0], v24[1]);
      sub_10061E120(&v20, v25[0], v25[1]);
      sub_10061ECB0((uint64_t)v25);
      sub_10061ECB0((uint64_t)v24);
      sub_10061ECB0((uint64_t)v23);
      uint64_t v19 = &off_1019EF590;
      sub_10061ECB0((uint64_t)v22);
      sub_10061ECB0((uint64_t)v21);
      memset(v25, 0, 32);
      sub_10061E86C((uint64_t)v25, (uint64_t *)&v19);
      sub_10061E86C((uint64_t)&v19, (uint64_t *)&v16 + 1);
      sub_10061E86C((uint64_t)&v16 + 8, (uint64_t *)v25);
      sub_10061E92C((uint64_t *)v25);
      sub_10061E92C((uint64_t *)&v19);
      sub_10061ECB0((uint64_t)v18);
      sub_10061ECB0((uint64_t)v17);
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100616598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a2)
  {
    sub_100163C60((void ***)&a35);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_1006165B0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a47);
    if (a35) {
      (*(void (**)(uint64_t))(*(void *)a35 + 8))(a35);
    }
    std::__shared_weak_count::__release_weak(v47);
    JUMPOUT(0x1006167E4);
  }
  _Unwind_Resume(a1);
}

void sub_1006165DC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1006166F8);
}

void sub_100616604(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100616644(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint **a13)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(a13);
    JUMPOUT(0x1006167DCLL);
  }
  _Unwind_Resume(a1);
}

void sub_100616658(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_10061DF6C(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100616678(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v3);
    *(void *)uint64_t v2 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v2 + 16));
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100616694(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061669CLL);
  }
  _Unwind_Resume(a1);
}

void sub_1006166B8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1006166C0);
  }
  _Unwind_Resume(a1);
}

void sub_100616700(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1006167E4);
}

void sub_10061670C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100616714);
  }
  _Unwind_Resume(a1);
}

void sub_100616744(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061674CLL);
  }
  _Unwind_Resume(a1);
}

void sub_10061675C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1006167F4);
}

void sub_100616768(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10000A740(a13);
  sub_100161F10((uint64_t)&a47);
  sub_10061DCC0((uint64_t)&a23);
  sub_10061ECB0((uint64_t)&a21);
  sub_10006A6AC(a1);
}

void sub_1006167FC(uint64_t a1, uint64_t a2, int a3, int **a4)
{
  uint64_t v7 = (Registry **)(a1 + 96);
  uint64_t v8 = SlotIdFromPersonalityId();
  unsigned int v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v8);
  if (v8 == *(_DWORD *)(a1 + 380))
  {
    if (a3 == 3) {
      int v10 = **a4;
    }
    else {
      int v10 = 6000;
    }
    uint64_t v12 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      if ((a3 - 1) > 2) {
        char v13 = "RequestCanceled";
      }
      else {
        char v13 = off_1019F0340[a3 - 1];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = sub_100FB56F4(v10);
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I getCarrierSpaceUpdates response. EventCause %s, Status %s", buf, 0x16u);
    }
    if (a3 == 3)
    {
      sub_1006159A0(a1, v10);
      int v14 = *(_DWORD *)(a1 + 576);
      *(_DWORD *)(a1 + 576) = 0;
      switch(v10)
      {
        case 6001:
        case 6003:
        case 6004:
        case 6010:
          *(unsigned char *)(a1 + 568) = 0;
          uint64_t v15 = *(void *)(a1 + 520);
          if (!v15) {
            goto LABEL_23;
          }
          long long v16 = (void *)(a1 + 520);
          int v17 = 1;
          goto LABEL_22;
        case 6002:
          *(_DWORD *)(a1 + 576) = 1;
          sub_1006155EC(a1);
          uint64_t v18 = *(void *)(a1 + 512);
          if (v18)
          {
            *(void *)(a1 + 512) = 0;
            (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
          }
          break;
        case 6005:
          goto LABEL_23;
        case 6012:
          *(unsigned char *)(a1 + 568) = 0;
          uint64_t v15 = *(void *)(a1 + 520);
          if (v15)
          {
            int v17 = 0;
            long long v16 = (void *)(a1 + 520);
LABEL_22:
            void *v16 = 0;
            (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
            if (v17)
            {
LABEL_23:
              if (*(unsigned char *)(a1 + 483))
              {
                (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 208) + 104))(buf);
                uint64_t v19 = *(void *)buf;
                if (*(void *)&buf[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                }
                if (!v19)
                {
                  *(void *)std::string buf = 0;
                  *(void *)&uint8_t buf[8] = 0;
                  ServiceMap = (std::mutex *)Registry::getServiceMap(*v7);
                  CFStringRef v21 = ServiceMap;
                  if ((v22 & 0x8000000000000000) != 0)
                  {
                    uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
                    uint64_t v24 = 5381;
                    do
                    {
                      unint64_t v22 = v24;
                      unsigned int v25 = *v23++;
                      uint64_t v24 = (33 * v24) ^ v25;
                    }
                    while (v25);
                  }
                  std::mutex::lock(ServiceMap);
                  unint64_t v36 = v22;
                  CFDataRef v26 = sub_10004D37C(&v21[1].__m_.__sig, &v36);
                  if (v26)
                  {
                    uint64_t v28 = v26[3];
                    __int16 v27 = (std::__shared_weak_count *)v26[4];
                    if (v27) {
                      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                  }
                  else
                  {
                    uint64_t v28 = 0;
                    __int16 v27 = 0;
                  }
                  std::mutex::unlock(v21);
                  *(void *)std::string buf = v28;
                  *(void *)&uint8_t buf[8] = v27;
                  if (v27)
                  {
                    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v27);
                  }
                  if (v28
                    && (sub_100527BA0(1, (uint64_t)buf, carrier_space::kCBAllowFallbackToLegacyUIKey, 0) & 1) != 0)
                  {
                    *(_DWORD *)(a1 + 576) = 2;
                    sub_1006155EC(a1);
                  }
                  if (*(void *)&buf[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                  }
                }
              }
            }
          }
          break;
        default:
          break;
      }
      if (v14 && !*(_DWORD *)(a1 + 576)) {
        sub_10061494C(a1, v8);
      }
      uint64_t v29 = *a4;
      if (*a4)
      {
        uint64_t v30 = *((void *)v29 + 1);
        if (v30)
        {
          uint64_t v31 = *(void *)(a1 + 176);
          __int16 v32 = (std::__shared_weak_count *)*((void *)v29 + 2);
          uint64_t v33 = v30;
          uint64_t v34 = v32;
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v31 + 48))(v31, v8, &v33);
          if (v34) {
            sub_10004D2C8(v34);
          }
        }
      }
    }
    else if (!a3)
    {
      uint64_t v35 = 0;
      sub_100615A24(a1, 7u, &v35);
      sub_10007CA64(&v35);
      sub_10061873C(a1, *(unsigned int *)(a1 + 380), 7, 2);
    }
  }
  else
  {
    uint64_t v11 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Ignoring update result", buf, 2u);
    }
  }
}

void sub_100616C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100616CCC(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5 = SlotIdFromPersonalityId();
  if (v5 == *(_DWORD *)(a1 + 380))
  {
    if (*(_DWORD *)(a1 + 576))
    {
      sub_1006159A0(a1, 6000);
      sub_10061494C(a1, v5);
    }
    uint64_t v6 = *(void *)(a1 + 176);
    sub_100058198(&v8, a3);
    (*(void (**)(uint64_t, const void **))(*(void *)v6 + 56))(v6, &v8);
    sub_100057D78(&v8);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Ignoring push notification", buf, 2u);
    }
  }
}

void sub_100616DE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100616DFC(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v6 = SlotIdFromPersonalityId();
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v6);
  if (v6 == *(_DWORD *)(a1 + 380))
  {
    long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v8 = *(void *)(a1 + 176);
    long long v34 = *a4;
    *(void *)a4 = 0;
    *((void *)a4 + 1) = 0;
    (*(void (**)(long long *__return_ptr))(*(void *)v8 + 72))(&v35);
    if (*((void *)&v34 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v34 + 1));
    }
    if (v35 == 1)
    {
      uint64_t v29 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#N Update account access token was invalid", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 192) + 80))(*(void *)(a1 + 192));
      uint64_t v30 = 3;
    }
    else
    {
      if (!(_BYTE)v35)
      {
        unsigned int v9 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Successfully updated account", buf, 2u);
        }
        int v10 = (unsigned __int8 *)*((void *)&v35 + 1);
        uint64_t v11 = (unsigned __int8 *)v36;
        if (*((void *)&v35 + 1) != (void)v36)
        {
          while (1)
          {
            __s1 = 0;
            __uint64_t n = 0;
            uint64_t v40 = 0;
            (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 224) + 56))(buf);
            sub_100ED1320((id **)buf, &__s1);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            uint64_t v12 = HIBYTE(v40);
            int v13 = SHIBYTE(v40);
            if (v40 >= 0) {
              size_t v14 = HIBYTE(v40);
            }
            else {
              size_t v14 = __n;
            }
            uint64_t v15 = v10[23];
            int v16 = (char)v15;
            if ((v15 & 0x80u) != 0) {
              uint64_t v15 = *((void *)v10 + 1);
            }
            if (v14 == v15)
            {
              if (v16 >= 0) {
                int v17 = v10;
              }
              else {
                int v17 = *(unsigned __int8 **)v10;
              }
              if (SHIBYTE(v40) < 0)
              {
                uint64_t v19 = __s1;
                if (memcmp(__s1, v17, __n)) {
                  goto LABEL_44;
                }
LABEL_27:
                int v20 = v10[24];
                unsigned __int8 v37 = v10[24];
                CFStringRef v21 = *(NSObject **)(a1 + 72);
                if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                {
                  unint64_t v22 = "???";
                  if ((v20 - 1) <= 3u) {
                    unint64_t v22 = off_1019F0430[(char)(v20 - 1)];
                  }
                  p_s1 = __s1;
                  if (v13 >= 0) {
                    p_s1 = &__s1;
                  }
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v22;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = p_s1;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Received plan purchase status %s, for plan %s", buf, 0x16u);
                }
                if (v20 == 3)
                {
                  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 224) + 56))(buf);
                  sub_100618400((void *)a1, 2, (uint64_t)buf);
                }
                uint64_t v24 = *(void *)(a1 + 208);
                int v44 = 0;
                unsigned int v25 = operator new(0x20uLL);
                void *v25 = off_1019EFDC8;
                v25[1] = &v37;
                v25[2] = a1;
                v25[3] = &__s1;
                int v44 = v25;
                LOBYTE(v24) = (*(uint64_t (**)(uint64_t, void **, unsigned char *))(*(void *)v24 + 136))(v24, &__s1, buf);
                sub_100621E50(buf);
                if ((v24 & 1) == 0)
                {
                  CFDataRef v26 = *(NSObject **)(a1 + 72);
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                  {
                    if (v40 >= 0) {
                      __int16 v27 = &__s1;
                    }
                    else {
                      __int16 v27 = __s1;
                    }
                    *(_DWORD *)uint64_t v41 = 136315138;
                    uint64_t v42 = v27;
                    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#N Could not modify plan subscription status for plan '%s'", v41, 0xCu);
                  }
                }
                LOBYTE(v13) = HIBYTE(v40);
                goto LABEL_42;
              }
              if (!HIBYTE(v40)) {
                goto LABEL_27;
              }
              uint64_t v18 = &__s1;
              while (*(unsigned __int8 *)v18 == *v17)
              {
                uint64_t v18 = (void **)((char *)v18 + 1);
                ++v17;
                if (!--v12) {
                  goto LABEL_27;
                }
              }
            }
LABEL_42:
            if ((v13 & 0x80) != 0)
            {
              uint64_t v19 = __s1;
LABEL_44:
              operator delete(v19);
            }
            v10 += 32;
            if (v10 == v11) {
              goto LABEL_65;
            }
          }
        }
        goto LABEL_65;
      }
      uint64_t v30 = 2;
    }
    uint64_t v31 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if ((unint64_t)(char)v35 > 5) {
        __int16 v32 = "???";
      }
      else {
        __int16 v32 = off_1019F0358[(char)v35];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v32;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N Failed to update account, result: %s", buf, 0xCu);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 224) + 56))(buf);
    if (*(void *)buf)
    {
      v33[0] = *(void *)buf;
      v33[1] = *(void *)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      sub_100618400((void *)a1, v30, (uint64_t)v33);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    (*(void (**)(void))(**(void **)(a1 + 224) + 48))(*(void *)(a1 + 224));
LABEL_65:
    *(void *)std::string buf = (char *)&v35 + 8;
    sub_1000D82FC((void ***)buf);
    return;
  }
  uint64_t v28 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Ignoring update account response", buf, 2u);
  }
}

void sub_100617418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t *a28)
{
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v29 - 120);
  if (v31) {
    sub_10004D2C8(v31);
  }
  a28 = &a18;
  sub_1000D82FC((void ***)&a28);
  _Unwind_Resume(a1);
}

void sub_1006174BC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a1 + 375) < 0)
  {
    if (!*(void *)(a1 + 360)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 375))
  {
    return;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    if (!*(void *)(a2 + 8)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a2 + 23))
  {
    return;
  }
  CFNumberRef v3 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Iccid changed, reset", v4, 2u);
  }
  sub_1006154E8(a1);
  sub_10061494C(a1, *(unsigned int *)(a1 + 380));
}

void sub_10061756C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 376) == a2)
  {
    unsigned int v4 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "false";
      if (a2) {
        uint64_t v5 = "true";
      }
      int v8 = 136315138;
      unsigned int v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I no change in airplane mode state : %s", (uint8_t *)&v8, 0xCu);
    }
  }
  else if (*(unsigned char *)(a1 + 376))
  {
    uint64_t v6 = *(void *)(a1 + 512);
    if (v6)
    {
      *(void *)(a1 + 512) = 0;
      uint64_t v7 = *(void (**)(void))(*(void *)v6 + 8);
      v7();
    }
  }
  else
  {
    sub_10061873C(a1, *(unsigned int *)(a1 + 380), 7, 2);
    sub_1006150D0((const void **)a1);
  }
}

void sub_1006176EC(uint64_t a1, int a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 380);
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (v4 != a2 && isValidSimSlot != 0)
  {
    uint64_t v7 = *(void *)(a1 + 392);
    if (v7)
    {
      uint64_t v8 = a1 + 392;
      do
      {
        int v9 = *(_DWORD *)(v7 + 32);
        BOOL v10 = v9 < (int)v4;
        if (v9 >= (int)v4) {
          uint64_t v11 = (uint64_t *)v7;
        }
        else {
          uint64_t v11 = (uint64_t *)(v7 + 8);
        }
        if (!v10) {
          uint64_t v8 = v7;
        }
        uint64_t v7 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 392 && *(_DWORD *)(v8 + 32) <= (int)v4)
      {
        if (a2 || *(unsigned char *)(v8 + 40))
        {
          if (*(unsigned __int8 *)(v8 + 40) != 255)
          {
            int v13 = *(NSObject **)(a1 + 72);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              int v14 = 136315650;
              uint64_t v15 = subscriber::asString();
              __int16 v16 = 2080;
              uint64_t v17 = subscriber::asString();
              __int16 v18 = 2080;
              uint64_t v19 = asString();
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I User data SIM has changed from %s to %s, re-evaluating state (change type: %s)", (uint8_t *)&v14, 0x20u);
            }
            sub_100617D08(a1, v4, 2);
          }
        }
        else
        {
          uint64_t v12 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v14) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Slot became known, initializing state", (uint8_t *)&v14, 2u);
          }
          sub_10061494C(a1, v4);
        }
      }
    }
  }
}

void sub_10061789C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 400))
  {
    uint64_t v4 = *(unsigned int *)(a1 + 380);
    if (subscriber::isValidSimSlot())
    {
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v6 = a2 + 8;
      uint64_t v5 = v7;
      if (!v7) {
        goto LABEL_13;
      }
      uint64_t v8 = v6;
      do
      {
        int v9 = *(_DWORD *)(v5 + 32);
        BOOL v10 = v9 < (int)v4;
        if (v9 >= (int)v4) {
          uint64_t v11 = (uint64_t *)v5;
        }
        else {
          uint64_t v11 = (uint64_t *)(v5 + 8);
        }
        if (!v10) {
          uint64_t v8 = v5;
        }
        uint64_t v5 = *v11;
      }
      while (*v11);
      if (v8 != v6 && *(_DWORD *)(v8 + 32) <= (int)v4) {
        int v12 = *(unsigned __int8 *)(v8 + 40);
      }
      else {
LABEL_13:
      }
        int v12 = 255;
      uint64_t v13 = *(void *)(a1 + 392);
      if (v13)
      {
        uint64_t v14 = a1 + 392;
        do
        {
          int v15 = *(_DWORD *)(v13 + 32);
          BOOL v16 = v15 < (int)v4;
          if (v15 >= (int)v4) {
            uint64_t v17 = (uint64_t *)v13;
          }
          else {
            uint64_t v17 = (uint64_t *)(v13 + 8);
          }
          if (!v16) {
            uint64_t v14 = v13;
          }
          uint64_t v13 = *v17;
        }
        while (*v17);
        if (v14 != a1 + 392 && *(_DWORD *)(v14 + 32) <= (int)v4)
        {
          int v18 = *(unsigned __int8 *)(v14 + 40);
          if (v12 != v18 && v18 != 255)
          {
            uint64_t v19 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v4);
            if (v12 != 255 || v18)
            {
              sub_100617D08(a1, v4, (char)v18);
            }
            else
            {
              int v20 = *v19;
              if (os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
              {
                v21[0] = 0;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle became known, initializing state", (uint8_t *)v21, 2u);
              }
              sub_10061494C(a1, v4);
            }
          }
        }
      }
    }
  }
}

void sub_100617A38(uint64_t a1)
{
  xpc_object_t v2 = *(xpc_object_t *)(a1 + 408);
  if (v2) {
    xpc_retain(*(xpc_object_t *)(a1 + 408));
  }
  else {
    xpc_object_t v2 = xpc_null_create();
  }
  if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    CFNumberRef v3 = (std::__shared_weak_count *)operator new(0x20uLL);
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    v3[1].__vftable = 0;
    uint64_t v13 = (long long *)&v3[1];
    uint64_t v14 = v3;
    xpc_object_t object = v2;
    if (v2) {
      xpc_retain(v2);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc::bridge((uint64_t *)&v12, (xpc *)&object, v4);
    sub_10004EFE4(&v10, &v12);
    uint64_t v5 = v13;
    if (v13 != &v10)
    {
      uint64_t v6 = *(void **)v13;
      *(void *)uint64_t v13 = 0;
      __p[0] = v6;
      *(void *)uint64_t v5 = v10;
      *(void *)&long long v10 = 0;
      sub_100057D78((const void **)__p);
    }
    sub_100057D78((const void **)&v10);
    sub_1000577C4(&v12);
    xpc_release(object);
    long long v10 = 0uLL;
    LODWORD(__p[0]) = 6000;
    sub_100625330((int *)__p, (uint64_t *)&v13, &v10);
    PersonalityIdFromSlotId();
    long long v7 = v10;
    if (*((void *)&v10 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v10 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100616DFC(a1, (uint64_t)__p, 3, &v7);
    if (*((void *)&v7 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v7 + 1));
    }
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    if (*((void *)&v10 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  xpc_release(v2);
}

void sub_100617BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, xpc_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v21 - 40);
  if (v23) {
    sub_10004D2C8(v23);
  }
  xpc_release(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100617C80(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 480);
  if (v2 != a2 && v2 != 0)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(NSObject **)(result + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I cellular data enabled, refresh all info", v6, 2u);
    }
    return sub_10061873C(v4, *(unsigned int *)(v4 + 380), 7, 2);
  }
  return result;
}

void sub_100617D08(uint64_t a1, uint64_t a2, int a3)
{
  if (subscriber::isValidSimSlot())
  {
    switch(a3)
    {
      case -1:
      case 5:
        uint64_t v6 = *(NSObject **)(a1 + 72);
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_6;
        }
        int v17 = 136315138;
        uint64_t v18 = asString();
        long long v7 = "#I deinitialize on carrier bundle change event %s";
        uint64_t v8 = v6;
        uint32_t v9 = 12;
        goto LABEL_5;
      case 1:
        uint64_t v11 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 136315138;
          uint64_t v18 = asString();
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I re-evaluate on carrier bundle change event %s", (uint8_t *)&v17, 0xCu);
        }
        int v12 = *(unsigned __int8 *)(a1 + 481);
        sub_100614DA0(a1, a2);
        uint64_t v13 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        int v14 = *(unsigned __int8 *)(a1 + 481);
        if (v12 == v14 && *(_DWORD *)(a1 + 328)) {
          return;
        }
        int v15 = *v13;
        BOOL v16 = os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT);
        if (v14)
        {
          if (v16)
          {
            LOWORD(v17) = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I CarrierSpace is now enabled", (uint8_t *)&v17, 2u);
          }
LABEL_10:
          sub_10061494C(a1, a2);
        }
        else
        {
          if (v16)
          {
            LOWORD(v17) = 0;
            long long v7 = "#I CarrierSpace is now disabled";
            uint64_t v8 = v15;
            uint32_t v9 = 2;
LABEL_5:
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v17, v9);
          }
LABEL_6:
          sub_1006154E8(a1);
        }
        break;
      case 2:
      case 3:
        long long v10 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 136315138;
          uint64_t v18 = asString();
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I reset on carrier bundle change event %s", (uint8_t *)&v17, 0xCu);
        }
        sub_1006154E8(a1);
        goto LABEL_10;
      default:
        return;
    }
  }
}

const void **sub_100617F90(const void **result, const void **a2, unsigned int a3)
{
  unsigned int v3 = a3;
  uint64_t v5 = result;
  char *result = 0;
  if ((a3 & 1) == 0)
  {
    if ((a3 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_13:
    uint64_t result = sub_100602120(v5, a2 + 68);
    if ((v3 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t result = sub_100602120(result, a2 + 67);
  if ((v3 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_3:
  if ((v3 & 4) != 0) {
LABEL_4:
  }
    uint64_t result = sub_100602120(v5, a2 + 69);
LABEL_5:
  unsigned int v6 = 0;
  do
  {
    v6 += v3 & 1;
    if (v3 < 2) {
      break;
    }
    v3 >>= 1;
  }
  while (v6 < 2);
  if (v6 >= 2)
  {
    return sub_100602120(v5, a2 + 70);
  }
  return result;
}

void sub_100618050(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 488);
  unsigned int v3 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134218240;
    uint64_t v25 = 60 * v2;
    __int16 v26 = 2048;
    uint64_t v27 = v2 / 60;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Scheduling periodic update check every secs: %lld, in hours: %ld", buf, 0x16u);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v4 || (uint64_t v5 = *(void *)(a1 + 40), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  long long v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  Registry::getTimerService(&v17, *(Registry **)(a1 + 96));
  uint64_t v8 = v17;
  sub_100058DB0(v15, "Carrier Space Auto update timer");
  uint64_t v22 = 1;
  uint64_t v23 = 60000000 * v2;
  ctu::TimerService::throwIfPeriodIsZero();
  *(_OWORD *)OsLogContext __p = *(_OWORD *)v15;
  uint64_t v21 = v16;
  v15[1] = 0;
  uint64_t v16 = 0;
  v15[0] = 0;
  uint64_t v9 = v22;
  uint64_t v10 = v23;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v28 = 0;
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = off_1019EFD48;
  v11[1] = a1;
  v11[2] = v5;
  void v11[3] = v7;
  uint64_t v28 = v11;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, uint8_t *))(*(void *)v8 + 48))(&v19, v8, __p, v9, v10, 0, buf);
  sub_10003B34C(buf);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v12 = v19;
  uint64_t v19 = 0;
  uint64_t v13 = *(void *)(a1 + 512);
  *(void *)(a1 + 512) = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    uint64_t v14 = v19;
    uint64_t v19 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void sub_1006182D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  sub_10003B34C(&a27);
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  std::__shared_weak_count::__release_weak(v27);
  _Unwind_Resume(a1);
}

const void **sub_100618350(uint64_t a1)
{
  sub_1006159A0(a1, 6000);
  uint64_t v2 = *(void *)(a1 + 208);
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v4 = 0;
  sub_100615A24(a1, 7u, &v4);
  return sub_10007CA64(&v4);
}

void sub_1006183D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100618400(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[18];
  unsigned int v6 = *(std::__shared_weak_count **)(a3 + 8);
  uint64_t v13 = *(id **)a3;
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, id **))(*(void *)v5 + 88))(v5, a2, &v13);
  if (v14) {
    sub_10004D2C8(v14);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v12 = 0;
  sub_100ED1190((id **)a3, __p);
  long long v7 = a1[9];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = __p;
    if (v12 < 0) {
      uint64_t v8 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Provisioning failed for plan '%s'", buf, 0xCu);
  }
  *(_OWORD *)std::string buf = 0uLL;
  uint64_t v9 = a1[16];
  sub_100ED1264((id **)a3, &v10);
  (*(void (**)(uint8_t *__return_ptr, uint64_t, const void **))(*(void *)v9 + 80))(buf, v9, &v10);
  sub_1000558F4(&v10);
  dispatch_get_global_queue(0, 0);
  if (*(void *)&buf[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_1006185F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100618650(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        unsigned int v6 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Carrier Space refresh retry timer has fired", v7, 2u);
        }
        if (*(unsigned char *)(v3 + 568)) {
          sub_10061873C(v3, *(unsigned int *)(v3 + 380));
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1006186FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100618710(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10061872C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_10061873C(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  uint64_t v9 = v8;
  if (!*(unsigned char *)(a1 + 481))
  {
    uint64_t v11 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "refresh request failed as feature not supported", buf, 2u);
    }
    return 1;
  }
  if (a3)
  {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 483);
    if ((a3 & 2) == 0) {
      goto LABEL_12;
    }
LABEL_9:
    if (*(unsigned char *)(a1 + 484)) {
      uint64_t v10 = v10 | 2;
    }
    else {
      uint64_t v10 = v10;
    }
    goto LABEL_12;
  }
  uint64_t v10 = 0;
  if ((a3 & 2) != 0) {
    goto LABEL_9;
  }
LABEL_12:
  if ((a3 & 4) != 0 && *(unsigned char *)(a1 + 485))
  {
    uint64_t v10 = v10 | 4;
    uint64_t v13 = *v8;
    goto LABEL_16;
  }
  uint64_t v13 = *v8;
  if (v10)
  {
LABEL_16:
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if ((v10 - 1) > 6) {
        uint64_t v14 = "???";
      }
      else {
        uint64_t v14 = off_1019F03F8[(char)(v10 - 1)];
      }
      if (a4 > 7) {
        int v15 = "???";
      }
      else {
        int v15 = off_1019F0388[(int)a4];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I refresh requested for derived type %s, event %s", buf, 0x16u);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 224) + 40))(*(void *)(a1 + 224))
      && (a4 - 3) >= 5
      && a4)
    {
      v10 &= 5u;
      uint64_t v30 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = off_1019F03C8[v10];
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Removing plans from request because provisioning polling is in progress, resulting mask %s", buf, 0xCu);
      }
      if (!v10)
      {
        __int16 v32 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N Refresh request is invalid", buf, 2u);
        }
        return 8;
      }
    }
    if (a4 == 1)
    {
      uint64_t v17 = (void *)(a1 + 496);
    }
    else
    {
      double v16 = 0.0;
      if (a4 != 2) {
        goto LABEL_34;
      }
      uint64_t v17 = (void *)(a1 + 488);
    }
    double v16 = (double)(60 * *v17);
LABEL_34:
    CFDateRef theDate = 0;
    sub_100615BF4(&theDate, a1);
    CFDateRef otherDate = 0;
    sub_100617F90((const void **)&otherDate, (const void **)a1, v10);
    if (theDate) {
      uint64_t v18 = sub_1001908E4;
    }
    else {
      uint64_t v18 = 0;
    }
    if (v18)
    {
      uint64_t v19 = otherDate ? sub_1001908E4 : 0;
      if (v19 && CFDateGetTimeIntervalSinceDate(theDate, otherDate) < v16)
      {
        int v20 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = (int)v16;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I last refresh was within %d seconds, rejecting this request", buf, 8u);
        }
        uint64_t v12 = 5;
        goto LABEL_92;
      }
    }
    (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 176) + 40))(*(void *)(a1 + 176), a2, v10, a4);
    uint64_t v21 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      if ((v10 - 1) > 6) {
        uint64_t v22 = "???";
      }
      else {
        uint64_t v22 = off_1019F03F8[(char)(v10 - 1)];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I refresh request sent for type %s", buf, 0xCu);
    }
    CFDateRef v44 = theDate;
    if (theDate) {
      CFRetain(theDate);
    }
    sub_100615A24(a1, v10, (const void **)&v44);
    sub_10007CA64((const void **)&v44);
    if (a4 != 3)
    {
      unsigned __int8 v23 = *(unsigned char *)(a1 + 568) | v10;
      *(unsigned char *)(a1 + 568) = v23;
      if (a4 == 4)
      {
        unsigned int v24 = dword_101B0D1D4;
        uint64_t v25 = qword_101B0D1D8;
        if (dword_101B0D1D4 == (qword_101B0D1E0 - qword_101B0D1D8) >> 3)
        {
          __int16 v26 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Max refresh retries attempted", buf, 2u);
          }
          goto LABEL_91;
        }
      }
      else
      {
        unsigned int v24 = 0;
        dword_101B0D1D4 = 0;
        uint64_t v25 = qword_101B0D1D8;
      }
      dword_101B0D1D4 = v24 + 1;
      uint64_t v27 = *(void *)(v25 + 8 * v24);
      uint64_t v28 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if (v23 > 7u) {
          uint64_t v29 = "???";
        }
        else {
          uint64_t v29 = off_1019F0450[(char)v23];
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v29;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = 60 * v27;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Pending refresh %s, retry in secs: %lld", buf, 0x16u);
      }
      uint64_t v33 = *(void *)(a1 + 520);
      if (v33)
      {
        *(void *)(a1 + 52sub_10010E764((uint64_t)&a9, 0) = 0;
        (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
      }
      long long v34 = *(std::__shared_weak_count **)(a1 + 48);
      if (!v34 || (v35 = *(void *)(a1 + 40), (long long v36 = std::__shared_weak_count::lock(v34)) == 0)) {
        sub_100088B9C();
      }
      unsigned __int8 v37 = v36;
      atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v36);
      Registry::getTimerService(&v51, *(Registry **)(a1 + 96));
      uint64_t v38 = v51;
      sub_100058DB0(__p, "Carrier Space refresh retry timer");
      __int16 v39 = *(NSObject **)(a1 + 56);
      dispatch_object_t object = v39;
      if (v39) {
        dispatch_retain(v39);
      }
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_100618650;
      uint64_t v55 = &unk_1019EEF00;
      uint64_t v56 = a1;
      uint64_t v57 = v35;
      uint64_t v58 = v37;
      atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlocuint64_t k = _Block_copy(buf);
      sub_100118A44(v38, (uint64_t)__p, 1, 60000000 * v27, &object, &aBlock);
      uint64_t v40 = v53;
      uint64_t v53 = 0;
      uint64_t v41 = *(void *)(a1 + 520);
      *(void *)(a1 + 52sub_10010E764((uint64_t)&a9, 0) = v40;
      if (v41)
      {
        (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
        uint64_t v42 = v53;
        uint64_t v53 = 0;
        if (v42) {
          (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v50 < 0) {
        operator delete(__p[0]);
      }
      if (v52) {
        sub_10004D2C8(v52);
      }
      if (v58) {
        std::__shared_weak_count::__release_weak(v58);
      }
      std::__shared_weak_count::__release_weak(v37);
    }
LABEL_91:
    uint64_t v12 = 0;
LABEL_92:
    sub_10007CA64((const void **)&otherDate);
    sub_10007CA64((const void **)&theDate);
    return v12;
  }
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "refresh request failed as no supported info type", buf, 2u);
  }
  return 7;
}

void sub_100618EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, void *aBlock, dispatch_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100618FA4(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 7) {
      uint64_t v5 = "???";
    }
    else {
      uint64_t v5 = off_1019F0450[(char)a2];
    }
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Forcing a refresh for type(s): %s", (uint8_t *)&v7, 0xCu);
  }
  return sub_10061873C(a1, *(unsigned int *)(a1 + 380), a2, 3);
}

uint64_t sub_100619084(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 572) != 6012) {
    return 1;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v13 = v10;
  uint64_t v14 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
  }
  if (!v10)
  {
    uint64_t v11 = 0;
    if (!v9) {
      return v11;
    }
    goto LABEL_14;
  }
  uint64_t v11 = sub_100527BA0(*(unsigned int *)(a1 + 380), (uint64_t)&v13, carrier_space::kCBSupportsUserConsentRefreshKey, 0);
  uint64_t v9 = v14;
  if (v14) {
LABEL_14:
  }
    sub_10004D2C8(v9);
  return v11;
}

void sub_1006191AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1006191C8(const void **a1, unsigned int a2)
{
  CFDateRef v8 = 0;
  sub_100617F90((const void **)&v8, a1, a2);
  if (v8) {
    uint64_t v3 = sub_1001908E4;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    sub_100615BF4(&v7, (uint64_t)a1);
    unint64_t TimeIntervalSinceDate = (unint64_t)CFDateGetTimeIntervalSinceDate(v7, v8);
    sub_10007CA64((const void **)&v7);
    BOOL v5 = TimeIntervalSinceDate > 0x13C680;
  }
  else
  {
    BOOL v5 = 1;
  }
  sub_10007CA64((const void **)&v8);
  return v5;
}

void sub_100619268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_10061928C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v4 = *(void *)(v3 + 24);
    if (v4)
    {
      if (*(void *)(v3 + 56))
      {
        BOOL v5 = (char *)operator new(0x58uLL);
        *((void *)v5 + 2) = 0;
        *((void *)v5 + 1) = 0;
        *(void *)BOOL v5 = off_1019EFE58;
        *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
        *(void *)uint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
        *((_DWORD *)v5 + 1sub_10010E764((uint64_t)&a9, 0) = *(_DWORD *)(v3 + 16);
        *((void *)v5 + 6) = v4;
        *(void *)(v3 + 24) = 0;
        sub_10007B6E4((uint64_t)(v5 + 56), v3 + 32);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
        sub_10004D2C8((std::__shared_weak_count *)v5);
      }
    }
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 48);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061940C(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006194FC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006195EC(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006196E4(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006197DC(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006198D4(uint64_t a1, uint64_t *a2)
{
  sub_1006199D4((void *)&v4 + 1, *a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006199D4(void *a1, uint64_t a2)
{
  if (a2 && (uint64_t v4 = *(void *)(a2 + 8)) != 0 && *(void *)(a2 + 40))
  {
    BOOL v5 = (std::__shared_weak_count *)operator new(0x48uLL);
    v5->__shared_weak_owners_ = 0;
    v5->__shared_owners_ = 0;
    v5->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFFE8;
    LODWORD(v5[1].__vftable) = *(_DWORD *)a2;
    v5[1].__shared_owners_ = v4;
    *(void *)(a2 + 8) = 0;
    sub_10007C90C((uint64_t)&v5[1].__shared_weak_owners_, a2 + 16);
    *a1 = v5 + 1;
    a1[1] = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_100619AA8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100619B98(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 48))();
}

void sub_100619BC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)(a2 + 64) = 0;
  }
  sub_10007CB50(v4, a2 + 96);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100619E24(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  sub_10007C6F8((uint64_t *)(a1 + 8), 0);
  return a1;
}

void sub_100619E94(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061A024(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061A124(uint64_t a1, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061A214(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061A314(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10061A31C(uint64_t a1, char a2)
{
  return sub_10061873C(a1, *(unsigned int *)(a1 + 380), a2, 5);
}

uint64_t sub_10061A32C(uint64_t a1, char a2)
{
  return sub_10061873C(a1 - 8, *(unsigned int *)(a1 + 372), a2, 5);
}

void sub_10061A344(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((a3 - 1) > 3u) {
      CFDateRef v7 = "???";
    }
    else {
      CFDateRef v7 = off_1019F0430[(char)(a3 - 1)];
    }
    if (*((char *)a2 + 23) >= 0) {
      CFDateRef v8 = a2;
    }
    else {
      CFDateRef v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received plan purchase status '%s' for plan '%s' from APNS", buf, 0x16u);
  }
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 208) + 128))(buf);
  if (*(void *)buf)
  {
    (*(void (**)(void, unsigned char *, uint64_t))(**(void **)(a1 + 224) + 32))(*(void *)(a1 + 224), buf, a3);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = (uint64_t *)*a2;
      }
      int v11 = 136315138;
      uint64_t v12 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Plan '%s' in purchase status is invalid", (uint8_t *)&v11, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10061A50C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061A52C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

uint64_t sub_10061A534(uint64_t a1, uint64_t a2)
{
  return sub_100615898(a1 + 416, a2);
}

uint64_t sub_10061A53C(uint64_t a1, uint64_t a2)
{
  return sub_100615898(a1 + 408, a2);
}

void sub_10061A544(uint64_t a1, uint64_t a2, uint64_t a3, void **a4)
{
  CFDateRef v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a4;
    if (*((char *)a4 + 23) < 0) {
      uint64_t v9 = *a4;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I User successfully authorized to purchase plan: %s", buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 176);
  *(_OWORD *)uint64_t v13 = *(_OWORD *)a3;
  uint64_t v14 = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(__p, *a4, (unint64_t)a4[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a4;
    uint64_t v12 = a4[2];
  }
  (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v10 + 64))(v10, a2, v13, __p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }
  *(_OWORD *)std::string buf = 0uLL;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 208) + 128))(buf);
  if (*(void *)buf) {
    (*(void (**)(void, uint64_t, uint8_t *))(**(void **)(a1 + 224) + 16))(*(void *)(a1 + 224), a2, buf);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10061A744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061A794(uint64_t a1, uint64_t a2, uint64_t a3, void **a4)
{
}

void sub_10061A79C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v22 = 0;
  unsigned __int8 v23 = 0;
  (*(void (**)(id **__return_ptr))(**(void **)(a1 + 224) + 56))(&v22);
  if (!v22) {
    goto LABEL_34;
  }
  sub_100ED1320(&v22, &__p);
  uint64_t v6 = a3[23];
  if ((v6 & 0x80u) == 0) {
    uint64_t v7 = a3[23];
  }
  else {
    uint64_t v7 = *((void *)a3 + 1);
  }
  uint64_t v8 = v25;
  int v9 = (char)v25;
  if ((v25 & 0x80u) != 0) {
    uint64_t v8 = *((void *)&__p + 1);
  }
  if (v7 != v8)
  {
    BOOL v19 = 0;
    if (((char)v25 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_27;
  }
  if ((v25 & 0x80u) == 0) {
    p_p = (unsigned __int8 *)&__p;
  }
  else {
    p_p = (unsigned __int8 *)__p;
  }
  if ((v6 & 0x80) != 0)
  {
    BOOL v19 = memcmp(*(const void **)a3, p_p, *((void *)a3 + 1)) == 0;
    goto LABEL_23;
  }
  if (a3[23])
  {
    uint64_t v11 = v6 - 1;
    uint64_t v12 = a3;
    do
    {
      int v14 = *v12++;
      int v13 = v14;
      int v16 = *p_p++;
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v19 = v13 == v15;
    }
    while (v13 == v15 && v18);
LABEL_23:
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_27;
  }
  BOOL v19 = 1;
  if (((char)v25 & 0x80000000) == 0)
  {
LABEL_24:
    if (!v19) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }
LABEL_27:
  operator delete((void *)__p);
  if (!v19) {
    goto LABEL_34;
  }
LABEL_28:
  int v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if ((a3[23] & 0x80u) == 0) {
      uint64_t v21 = a3;
    }
    else {
      uint64_t v21 = *(const void **)a3;
    }
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I User authentication failed for plan '%s'", (uint8_t *)&__p, 0xCu);
  }
  (*(void (**)(void))(**(void **)(a1 + 224) + 48))(*(void *)(a1 + 224));
LABEL_34:
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_10061A9B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061A9DC(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
}

void sub_10061A9E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061AB10(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10061AB18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061AC44(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10061AC4C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061AD2C(uint64_t a1)
{
}

void sub_10061AD34(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061AE14(uint64_t a1)
{
}

void sub_10061AE20(uint64_t a1, uint64_t *a2)
{
  sub_1006199D4((void *)&v4 + 1, *a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061AF20(uint64_t a1, uint64_t *a2)
{
  sub_1006199D4((void *)&v4 + 1, *a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10061B020(uint64_t a1, uint64_t *a2)
{
  sub_1006199D4((void *)&v4 + 1, *a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void *sub_10061B120(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10061B1A4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10061B228(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10061B27C((const void **)v2, (const void **)*v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

const void **sub_10061B27C(const void **result, const void **a2)
{
  uint64_t v3 = result;
  for (uint64_t i = (const void **)result[1]; i != a2; i -= 4)
  {
    sub_10007CA64(i - 2);
    uint64_t result = sub_10007CA64(i - 3);
  }
  v3[1] = a2;
  return result;
}

void sub_10061B2D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EF068;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10061B2F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EF068;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10061B34C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10061B378(uint64_t a1)
{
  sub_100613C10(a1);

  operator delete();
}

void sub_10061B3B0(uint64_t a1)
{
}

void sub_10061B3B8(uint64_t a1)
{
  sub_100613C10(a1 - 8);

  operator delete();
}

void sub_10061B3F4(uint64_t a1)
{
}

void sub_10061B3FC(uint64_t a1)
{
  sub_100613C10(a1 - 16);

  operator delete();
}

void sub_10061B438(uint64_t a1)
{
}

void sub_10061B440(uint64_t a1)
{
  sub_100613C10(a1 - 24);

  operator delete();
}

void sub_10061B47C(uint64_t a1)
{
}

void sub_10061B484(uint64_t a1)
{
  sub_100613C10(a1 - 32);

  operator delete();
}

void sub_10061B4C0(ServiceManager::Service *this)
{
  *(void *)this = off_1019EF330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10061B51C(ServiceManager::Service *this)
{
  *(void *)this = off_1019EF330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10061B58C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CarrierSpaceController");
}

unsigned char *sub_10061B59C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10061B5DC(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    sub_100614018(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100614018(v4, 0);
}

uint64_t sub_10061B650()
{
  return 1;
}

uint64_t sub_10061B658()
{
  return 1;
}

uint64_t sub_10061B660()
{
  return 2;
}

void sub_10061B668(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  BOOL v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    sub_100614118(v4, v5);
  }
  sub_100614118(v4, 0);
}

void sub_10061B6F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 48);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10061B7D4(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 2)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 48);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_10061B8F0(ServiceManager::Service *this)
{
  *(void *)this = off_1019EF330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10061B94C(ServiceManager::Service *this)
{
  *(void *)this = off_1019EF330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10061B9BC()
{
  return 0;
}

uint64_t sub_10061B9C4()
{
  return 0;
}

void sub_10061B9D4()
{
}

uint64_t sub_10061B9E8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 72;
}

uint64_t *sub_10061B9F4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 144);
  BOOL v5 = v1[1];
  *(void *)std::string buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  uint64_t v6 = *(void *)(v2 + 192);
  uint64_t v7 = v1[1];
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 32))(v6, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 112));
  for (uint64_t i = *(void *)(v2 + 280); i != v2 + 272; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 272));
  sub_100088C88((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_10061BB70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, dispatch_group_t a13)
{
}

void sub_10061BBCC(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v4 = a1;
  BOOL v5 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100615D84((uint64_t)buf, v2 + 40, (uint64_t)&event::entitlements::get_carrier_space_updates_result, (uint64_t)sub_1006167FC, 0);
}

void sub_10061D1B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a2)
  {
    sub_100163C60((void ***)&a35);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_10061D1D0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a55);
    if (a35) {
      (*(void (**)(uint64_t))(*(void *)a35 + 8))(a35);
    }
    std::__shared_weak_count::__release_weak(v55);
    JUMPOUT(0x10061D5C4);
  }
  _Unwind_Resume(a1);
}

void sub_10061D1FC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x10061D448);
}

void sub_10061D21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_group_t group, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a36) {
    std::__shared_weak_count::__release_weak(a36);
  }
  sub_10004D2C8(v36);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  _Unwind_Resume(a1);
}

void sub_10061D23C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D258(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,NSObject *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44)
{
  if (a44) {
    std::__shared_weak_count::__release_weak(a44);
  }
  if (a29) {
    dispatch_release(a29);
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D26C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,NSObject *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,std::__shared_weak_count *a46)
{
  if (a46) {
    std::__shared_weak_count::__release_weak(a46);
  }
  if (a31) {
    dispatch_release(a31);
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D280(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,dispatch_group_t group,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,std::__shared_weak_count *a48)
{
  if (a48) {
    std::__shared_weak_count::__release_weak(a48);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D294(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D2B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  if (a23) {
    std::__shared_weak_count::__release_weak(a23);
  }
  if (a41) {
    JUMPOUT(0x10061D520);
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D2C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,std::__shared_weak_count *a56)
{
  if (a56) {
    sub_10004D2C8(a56);
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D2D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  if (a52 < 0) {
    operator delete(a47);
  }
  sub_100088C88(&a18);
  sub_100046B58(&a17);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  sub_100160AF8((atomic_uint **)(v8 + 8));
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  JUMPOUT(0x10061D5ACLL);
}

void sub_10061D340()
{
  sub_100160AF8(v0);
  JUMPOUT(0x10061D590);
}

void sub_10061D354(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_10061D394(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, atomic_uint **a15)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(a15);
    JUMPOUT(0x10061D5BCLL);
  }
  _Unwind_Resume(a1);
}

void sub_10061D3A8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_10061FAA4(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_10061D3C8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v3);
    *(void *)uint64_t v2 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v2 + 16));
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_10061D3E4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061D3ECLL);
  }
  _Unwind_Resume(a1);
}

void sub_10061D408(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061D410);
  }
  _Unwind_Resume(a1);
}

void sub_10061D450(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x10061D5C4);
}

void sub_10061D45C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061D464);
  }
  _Unwind_Resume(a1);
}

void sub_10061D494(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10061D49CLL);
  }
  _Unwind_Resume(a1);
}

void sub_10061D4AC()
{
}

void sub_10061D528(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x10061D5D4);
}

void sub_10061D538(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void **a55)
{
  if (a2)
  {
    sub_1006204D8((uint64_t *)&a55);
    sub_1006204D8(&a35);
    sub_10062052C((uint64_t)&a33);
    sub_10062052C((uint64_t)&a31);
    sub_1006204D8(v55);
    a55 = (void **)&a47;
    sub_100163C60(&a55);
    JUMPOUT(0x10061D5CCLL);
  }
  _Unwind_Resume(a1);
}

void sub_10061D57C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100161F10(&a55);
  sub_10061ED9C(&a47);
  sub_10062052C(&a29);
  sub_10006A6AC(a1);
}

void sub_10061D5A4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a2) {
    JUMPOUT(0x10061D5ACLL);
  }
  sub_10000A740(a15);
  JUMPOUT(0x10061D5BCLL);
}

uint64_t *sub_10061D5DC(uint64_t a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void))(**(void **)(*(void *)a1 + 192) + 40))(*(void *)(*(void *)a1 + 192));
  return sub_1003C2130(&v2);
}

void sub_10061D638(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003C2130((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10061D64C(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 144) + 16))(*(void *)(v1 + 144));
  (*(void (**)(void))(**(void **)(v1 + 192) + 16))(*(void *)(v1 + 192));
  (*(void (**)(void))(**(void **)(v1 + 240) + 24))(*(void *)(v1 + 240));
  operator delete();
}

void sub_10061D758()
{
}

void sub_10061D788()
{
}

__n128 sub_10061D79C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019EF3D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10061D7E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EF3D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

const void **sub_10061D818(uint64_t a1, char *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = **(NSObject ***)(a1 + 16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (v2 > 7) {
      BOOL v5 = "???";
    }
    else {
      BOOL v5 = off_1019F0450[v2];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Restore timestamps for %s", buf, 0xCu);
  }
  if ((v2 & 1) == 0)
  {
    uint64_t v6 = *(void *)(v3 + 536);
    *(void *)(v3 + 536) = 0;
    *(void *)std::string buf = v6;
    sub_10007CA64((const void **)buf);
    int v7 = 0;
    if ((v2 & 2) == 0) {
      goto LABEL_8;
    }
LABEL_13:
    CFPreferencesCopyValueForCurrentUserAnyHost();
    sub_100201EE4(&v23, &v22);
    int v14 = (uint64_t *)(v3 + 544);
    if ((uint64_t *)(v3 + 544) != &v23)
    {
      uint64_t v15 = *v14;
      uint64_t *v14 = v23;
      uint64_t v23 = 0;
      *(void *)std::string buf = v15;
      sub_10007CA64((const void **)buf);
    }
    sub_10007CA64((const void **)&v23);
    sub_1000577C4(&v22);
    int v9 = 1;
    if ((v2 & 4) == 0) {
      goto LABEL_9;
    }
    goto LABEL_16;
  }
  CFPreferencesCopyValueForCurrentUserAnyHost();
  sub_100201EE4(&v23, &v22);
  uint64_t v12 = (uint64_t *)(v3 + 536);
  if ((uint64_t *)(v3 + 536) != &v23)
  {
    uint64_t v13 = *v12;
    uint64_t *v12 = v23;
    uint64_t v23 = 0;
    *(void *)std::string buf = v13;
    sub_10007CA64((const void **)buf);
  }
  sub_10007CA64((const void **)&v23);
  sub_1000577C4(&v22);
  int v7 = 1;
  if ((v2 & 2) != 0) {
    goto LABEL_13;
  }
LABEL_8:
  uint64_t v8 = *(void *)(v3 + 544);
  *(void *)(v3 + 544) = 0;
  *(void *)std::string buf = v8;
  sub_10007CA64((const void **)buf);
  int v9 = 0;
  if ((v2 & 4) == 0)
  {
LABEL_9:
    uint64_t v10 = *(void *)(v3 + 552);
    *(void *)(v3 + 552) = 0;
    *(void *)std::string buf = v10;
    sub_10007CA64((const void **)buf);
    int v11 = 0;
    goto LABEL_19;
  }
LABEL_16:
  CFPreferencesCopyValueForCurrentUserAnyHost();
  sub_100201EE4(&v23, &v22);
  int v16 = (uint64_t *)(v3 + 552);
  if ((uint64_t *)(v3 + 552) != &v23)
  {
    uint64_t v17 = *v16;
    uint64_t *v16 = v23;
    uint64_t v23 = 0;
    *(void *)std::string buf = v17;
    sub_10007CA64((const void **)buf);
  }
  sub_10007CA64((const void **)&v23);
  sub_1000577C4(&v22);
  int v11 = 1;
LABEL_19:
  if (v7 == *(unsigned __int8 *)(v3 + 483)
    && v9 == *(unsigned __int8 *)(v3 + 484)
    && v11 == *(unsigned __int8 *)(v3 + 485))
  {
    CFPreferencesCopyValueForCurrentUserAnyHost();
    sub_100201EE4(&v23, &v22);
    BOOL v18 = (uint64_t *)(v3 + 560);
    if ((uint64_t *)(v3 + 560) != &v23)
    {
      uint64_t v19 = *v18;
      uint64_t *v18 = v23;
      uint64_t v23 = 0;
      *(void *)std::string buf = v19;
      sub_10007CA64((const void **)buf);
    }
    sub_10007CA64((const void **)&v23);
    return sub_1000577C4(&v22);
  }
  else
  {
    uint64_t v21 = *(void *)(v3 + 560);
    *(void *)(v3 + 56sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)std::string buf = v21;
    return sub_10007CA64((const void **)buf);
  }
}

void sub_10061DB18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_10061DB40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10061DB80()
{
}

void *sub_10061DB8C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10061DC10(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = (void (*)(void *, uint64_t, uint64_t, uint64_t *))a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = (void *)(a1[4] + (v5 >> 1) - 40);
  if (v5) {
    uint64_t v4 = *(void (**)(void *, uint64_t, uint64_t, uint64_t *))(*v6 + v4);
  }
  int v7 = (std::__shared_weak_count *)a4[1];
  uint64_t v8 = *a4;
  int v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v4(v6, a2, a3, &v8);
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_10061DCA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10061DCC0(uint64_t a1)
{
  sub_10061E92C((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_10061DD04(uint64_t a1)
{
  sub_10061E050(a1);

  operator delete();
}

BOOL sub_10061DD3C(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_1001C5978((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_1001C5978((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_10061DE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10061DEB8(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10061DEE4(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_10061DF10@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_10061DF6C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_10061E92C((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_10061DFCC()
{
}

uint64_t sub_10061DFE0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10061E92C((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_10061E038()
{
  return 0;
}

uint64_t sub_10061E040()
{
  return 0;
}

uint64_t sub_10061E048()
{
  return 0;
}

uint64_t sub_10061E050(uint64_t a1)
{
  *(void *)a1 = off_1019EF488;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_10061E0C4()
{
}

uint64_t sub_10061E0D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10061E108()
{
  return 0;
}

uint64_t sub_10061E110()
{
  return 0;
}

uint64_t sub_10061E118()
{
  return 0;
}

NSObject **sub_10061E120(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_10061E170(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10061E120((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_10061ECB0(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitleme"
                                    "nts10EventCauseENSt3__110shared_ptrIKNS6_17EntActionResponseINS6_15GenericResponseEEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10EventCauseENSt3__110shared_ptrIKNS6_17EntActionResponseINS6_15GenericResponseEEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_10061E248(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v20 = *(void *)(a2 + 16);
  }
  uint64_t v6 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  long long v7 = *(const void **)(a1 + 8);
  if (v7 && (uint64_t v8 = _Block_copy(v7)) != 0 && (v9 = _Block_copy(v8), (v10 = v9) != 0))
  {
    int v11 = _Block_copy(v9);
    uint64_t v12 = v11;
    if (v11)
    {
      uint64_t v13 = _Block_copy(v11);
      int v14 = v13;
      if (v13)
      {
        uint64_t v15 = _Block_copy(v13);
        int v16 = v15;
        if (v15)
        {
          uint64_t v17 = _Block_copy(v15);
          BOOL v18 = v17;
          if (v17)
          {
            *(void *)&long long v22 = _Block_copy(v17);
            _Block_release(v18);
          }
          else
          {
            *(void *)&long long v22 = 0;
          }
          _Block_release(v16);
        }
        else
        {
          *(void *)&long long v22 = 0;
        }
        _Block_release(v14);
      }
      else
      {
        *(void *)&long long v22 = 0;
      }
      uint64_t v21 = off_1019EF5D0;
      _Block_release(v12);
    }
    else
    {
      uint64_t v21 = off_1019EF5D0;
      *(void *)&long long v22 = 0;
    }
    _Block_release(v10);
    if (!v6) {
LABEL_14:
    }
      operator new();
  }
  else
  {
    uint64_t v21 = off_1019EF5D0;
    *(void *)&long long v22 = 0;
    if (!v6) {
      goto LABEL_14;
    }
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  goto LABEL_14;
}

void sub_10061E580(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

uint64_t sub_10061E614(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void **)(a1 + 56);
  uint64_t v5 = **(unsigned int **)(a1 + 48);
  uint64_t v6 = v4[1];
  *(void *)&long long v12 = *v4;
  *((void *)&v12 + 1) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1001C5C04(v2, v3, v5, &v12);
  if (*((void *)&v12 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
  }
  long long v7 = *(uint64_t **)(a1 + 32);
  if (v7)
  {
    sub_10061E92C(v7);
    operator delete();
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    if (*(char *)(v8 + 23) < 0) {
      operator delete(*(void **)v8);
    }
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    operator delete();
  }
  uint64_t v10 = *(void *)(a1 + 56);
  if (v10)
  {
    int v11 = *(std::__shared_weak_count **)(v10 + 8);
    if (v11) {
      sub_10004D2C8(v11);
    }
    operator delete();
  }
  return result;
}

void sub_10061E710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10061E728(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10E"
                                                  "ventCauseENSt3__110shared_ptrIKNS4_17EntActionResponseINS4_15GenericResponseEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10EventCauseENSt3__110shared_ptrIKNS4_17EntActionResponseINS4_15GenericResponseEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

void sub_10061E804(uint64_t *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v4 = *a1;
  long long v5 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  (*(void (**)(uint64_t))(v4 + 16))(v4);
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_10061E854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10061E86C(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_10061E908(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_10061E918(_Unwind_Exception *a1)
{
}

uint64_t *sub_10061E92C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_10061E980(void *a1)
{
  *a1 = off_1019EF600;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10061E9CC(void *a1)
{
  *a1 = off_1019EF600;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_10061EA38(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_10061EAE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10061EB00(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_10061EB20()
{
}

void *sub_10061EB8C(void *a1)
{
  *a1 = off_1019EF650;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10061EBD8(void *a1)
{
  *a1 = off_1019EF650;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_10061EC44()
{
}

uint64_t sub_10061ECB0(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

const void **sub_10061ECEC(void *a1, uint64_t a2, const void **a3)
{
  uint64_t v5 = (void (*)(void *, uint64_t, const void **))a1[5];
  uint64_t v4 = a1[6];
  uint64_t v6 = (void *)(a1[4] + (v4 >> 1) - 40);
  if (v4) {
    uint64_t v5 = *(void (**)(void *, uint64_t, const void **))(*v6 + v5);
  }
  sub_100058198(&v8, a3);
  v5(v6, a2, &v8);
  return sub_100057D78(&v8);
}

void sub_10061ED88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10061ED9C(uint64_t a1)
{
  sub_1006204D8((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_10061EDDC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_10061EE20(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_10061EE64(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

void sub_10061EEA8(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_10061F158(&v2, a2);
}

uint64_t sub_10061EF24(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_10061EF68(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_10061EE20(a1);
  uint64_t result = (uint64_t *)sub_10061FC58(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_10061EE64(result + 2);
        sub_10061F78C(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_10061EE64(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        int v16 = (uint64_t *)sub_10061EE20(a1);
        uint64_t v17 = sub_10061FC58(v16);
        uint64_t v18 = sub_10061EE64(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_10061EE20(a1);
      uint64_t v20 = (uint64_t *)sub_10061FC58(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_10061F0A4(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  int v9 = (uint64_t *)sub_10061EE20(a1);
  uint64_t v10 = sub_10061FC58(v9);
  int v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_10061EE20(a1);
    int v11 = *(uint64_t **)(sub_10061FC58(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_10061EF68(a1, a2, a3, &v14, a4);
}

void sub_10061F158(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10061F1C4(&v2);
}

void sub_10061F1B0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10061F1C4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10061F234(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_10061F248(_Unwind_Exception *a1)
{
}

void sub_10061F260()
{
}

uint64_t sub_10061F274(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10061F2D8()
{
  return 0;
}

uint64_t sub_10061F2E0()
{
  return 0;
}

uint64_t sub_10061F2E8()
{
  return 0;
}

void sub_10061F2F0()
{
}

void sub_10061F36C()
{
}

uint64_t sub_10061F390(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10061F51C((uint64_t *)a1, a2);
  sub_10061F588((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    long long v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      int v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          int v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          long long v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      long long v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_10061F4F4(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10061F51C(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_10061F574(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10061F588(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10061F5D8(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10061F5F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10061F65C(&v2);
}

void sub_10061F648(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10061F65C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10061F6CC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_10061F6E0(_Unwind_Exception *a1)
{
}

void sub_10061F6F8()
{
}

uint64_t sub_10061F70C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10061F774()
{
  return 0;
}

uint64_t sub_10061F77C()
{
  return 0;
}

uint64_t sub_10061F784()
{
  return 0;
}

uint64_t *sub_10061F78C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_10061F7F4(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_10061F7F4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10061F83C(uint64_t a1)
{
  sub_10061FB88(a1);

  operator delete();
}

BOOL sub_10061F874(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_10061F7F4((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_10061F7F4((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_10061F9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10061F9F0(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10061FA1C(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_10061FA48@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_10061FAA4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_1006204D8((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_10061FB04()
{
}

uint64_t sub_10061FB18(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1006204D8((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_10061FB70()
{
  return 0;
}

uint64_t sub_10061FB78()
{
  return 0;
}

uint64_t sub_10061FB80()
{
  return 0;
}

uint64_t sub_10061FB88(uint64_t a1)
{
  *(void *)a1 = off_1019EF6B0;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_10061FBFC()
{
}

uint64_t sub_10061FC10(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10061FC40()
{
  return 0;
}

uint64_t sub_10061FC48()
{
  return 0;
}

uint64_t sub_10061FC50()
{
  return 0;
}

uint64_t sub_10061FC58(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

NSObject **sub_10061FC9C(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_10061FCEC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10061FC9C((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_10062052C(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDNS_2cf11CFSh"
                                    "aredRefIK14__CFDictionaryEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDNS_2cf11CFSharedRefIK14__CFDictionaryEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_10061FDC4(uint64_t a1, uint64_t a2, const void **a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v20 = *(void *)(a2 + 16);
  }
  uint64_t v5 = *a3;
  uint64_t v18 = *a3;
  *a3 = 0;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 && (long long v7 = _Block_copy(v6)) != 0 && (v8 = _Block_copy(v7), (v9 = v8) != 0))
  {
    uint64_t v10 = _Block_copy(v8);
    int v11 = v10;
    if (v10)
    {
      unsigned int v12 = _Block_copy(v10);
      unsigned int v13 = v12;
      if (v12)
      {
        BOOL v14 = _Block_copy(v12);
        uint64_t v15 = v14;
        if (v14)
        {
          int v16 = _Block_copy(v14);
          uint64_t v17 = v16;
          if (v16)
          {
            *(void *)&long long v23 = _Block_copy(v16);
            _Block_release(v17);
          }
          else
          {
            *(void *)&long long v23 = 0;
          }
          _Block_release(v15);
        }
        else
        {
          *(void *)&long long v23 = 0;
        }
        _Block_release(v13);
      }
      else
      {
        *(void *)&long long v23 = 0;
      }
      long long v22 = off_1019EF7F8;
      _Block_release(v11);
    }
    else
    {
      long long v22 = off_1019EF7F8;
      *(void *)&long long v23 = 0;
    }
    _Block_release(v9);
  }
  else
  {
    long long v22 = off_1019EF7F8;
    *(void *)&long long v23 = 0;
  }
  uint64_t v21 = v5;
  if (v5) {
    CFRetain(v5);
  }
  operator new();
}

void sub_1006200BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22)
{
}

const void **sub_10062014C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  sub_100058198(&v7, *(const void ***)(a1 + 48));
  sub_100620228(v2, v3, &v7);
  sub_100057D78(&v7);
  uint64_t v4 = *(uint64_t **)(a1 + 32);
  if (v4)
  {
    sub_1006204D8(v4);
    operator delete();
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    operator delete();
  }
  uint64_t result = *(const void ***)(a1 + 48);
  if (result)
  {
    sub_100057D78(result);
    operator delete();
  }
  return result;
}

void sub_100620214(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100620228(void *a1, uint64_t a2, const void **a3)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v6, "call to empty boost::function");
    v6.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v6);
  }
  uint64_t v3 = *(void (**)(void *, uint64_t, const void **))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v5 = *a3;
  *a3 = 0;
  v3(a1 + 1, a2, &v5);
  return sub_100057D78(&v5);
}

void sub_1006202B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, std::runtime_error a11)
{
}

void sub_1006202DC(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN3ctu2cf11CFShared"
                                                  "RefIK14__CFDictionaryEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN3ctu2cf11CFSharedRefIK14__CFDictionaryEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    std::runtime_error v6 = *a1;
    if (*a1) {
      std::runtime_error v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

const void **sub_1006203B8(uint64_t *a1, uint64_t a2, const void **a3)
{
  uint64_t v3 = *a1;
  uint64_t v5 = *a3;
  *a3 = 0;
  (*(void (**)(void))(v3 + 16))();
  return sub_100057D78(&v5);
}

void sub_100620404(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100620418(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        std::runtime_error v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_1006204B4(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_1006204C4(_Unwind_Exception *a1)
{
}

uint64_t *sub_1006204D8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_10062052C(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10062056C()
{
}

void *sub_100620580(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EF828;
  result[1] = v3;
  return result;
}

uint64_t sub_1006205C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EF828;
  a2[1] = v2;
  return result;
}

void sub_1006205F4()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/carrier_space_info");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100620698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1006206DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10062071C()
{
}

void sub_10062072C()
{
}

void *sub_100620740(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EF8B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100620788(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EF8B8;
  a2[1] = v2;
  return result;
}

void sub_1006207B4()
{
  xpc_object_t v3 = 0;
  rest::carrier_space::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/managed_hours");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100620858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10062089C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006208DC()
{
}

void sub_1006208EC()
{
}

__n128 sub_100620900(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_1019EF948;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100620954(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EF948;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10062098C(void *a1)
{
  uint64_t v2 = a1[1];
  xpc_object_t v3 = *(void **)v2;
  v11[0] = *(void *)(v2 + 8);
  *(void *)((char *)v11 + 7) = *(void *)(v2 + 15);
  char v4 = *(unsigned char *)(v2 + 23);
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = 0;
  *(void *)uint64_t v2 = 0;
  rest::read_rest_value();
  uint64_t v5 = (void (*)(void *, void **))a1[3];
  uint64_t v6 = a1[4];
  long long v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, void **))(*v7 + v5);
  }
  long long __p = v3;
  *(void *)uint64_t v9 = v11[0];
  *(void *)&v9[7] = *(void *)((char *)v11 + 7);
  char v10 = v4;
  v5(v7, &__p);
  if (v10 < 0) {
    operator delete(__p);
  }
}

void sub_100620A7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100620AA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100620AE8()
{
}

void sub_100620AF8()
{
}

__n128 sub_100620B0C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EF9C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100620B60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EF9C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100620B98(void *a1, xpc *this, BOOL a3)
{
  char v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *char v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100620C34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100620C74()
{
}

void sub_100620C84()
{
}

__n128 sub_100620C98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EFA48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100620CEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFA48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100620D24(void *a1, xpc_object_t *a2)
{
  char v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *char v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *char v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  char v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    char v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100620E1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100620E5C()
{
}

void sub_100620E6C()
{
}

__n128 sub_100620E80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EFAC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100620ED4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFAC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100620F0C(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  char v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *xpc_object_t v3 = v4;
    *char v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100620FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100620FE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100621024()
{
}

void sub_100621034()
{
}

__n128 sub_100621048(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EFB48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10062109C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFB48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006210D4(uint64_t a1, xpc_object_t *a2)
{
  sub_10014EF04(*(void ***)(a1 + 8), a2);
  xpc_object_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100621150(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100621190()
{
}

void sub_1006211A0()
{
}

__n128 sub_1006211B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EFBC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100621208(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFBC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100621240(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1006212DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10062131C()
{
}

void sub_10062132C()
{
}

__n128 sub_100621340(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019EFC48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100621394(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFC48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006213CC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  xpc_object_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100621414(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100621454()
{
}

void *sub_100621460(void *a1)
{
  *a1 = off_1019EFCC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1006214AC(void *a1)
{
  *a1 = off_1019EFCC8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100621518(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019EFCC8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10062157C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EFCC8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006215BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006215CC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10062160C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        int v5 = *(std::__shared_weak_count **)(v4 + 48);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10062171C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10062175C()
{
}

void sub_100621768(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier space auto update one-shot timer has fired", buf, 2u);
  }
  sub_10061873C(v1, *(unsigned int *)(v1 + 380), 7, 2);
  sub_100618050(v1);
  operator delete();
}

void sub_100621818()
{
}

void *sub_100621844(void *a1)
{
  *a1 = off_1019EFD48;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100621890(void *a1)
{
  *a1 = off_1019EFD48;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1006218FC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019EFD48;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100621960(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EFD48;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006219A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006219B0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1006219F0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        int v5 = *(std::__shared_weak_count **)(v4 + 48);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100621B00(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100621B40()
{
}

void sub_100621B4C(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier space auto update periodic timer has fired", buf, 2u);
  }
  sub_10061873C(v1, *(unsigned int *)(v1 + 380), 7, 2);
  operator delete();
}

void sub_100621BF4()
{
}

void sub_100621C24()
{
}

__n128 sub_100621C38(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019EFDC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100621C8C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EFDC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100621CC4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  int v5 = **(unsigned __int8 **)(a1 + 8);
  if (v5 == 2) {
    char v6 = 2;
  }
  else {
    char v6 = 3;
  }
  if (v5 == 1) {
    unsigned __int8 v7 = 0;
  }
  else {
    unsigned __int8 v7 = v6;
  }
  uint64_t v8 = *(NSObject **)(*(void *)(a1 + 16) + 72);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(uint64_t **)(a1 + 24);
    if (*((char *)v9 + 23) < 0) {
      uint64_t v9 = (uint64_t *)*v9;
    }
    char v10 = off_1019F0490[v7];
    int v14 = 136315394;
    uint64_t v15 = v9;
    __int16 v16 = 2080;
    uint64_t v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting subscription status for plan '%s' to %s", (uint8_t *)&v14, 0x16u);
  }
  if (v4)
  {
    uint64_t v11 = *v4;
    if (v7 != 3 && v11 != 0) {
      objc_msgSend(v11, "setPlanSubscriptionStatus:");
    }
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  return 1;
}

void sub_100621DEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100621E04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100621E44()
{
}

void *sub_100621E50(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100621ED4(void *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  return sub_1000E3958((uint64_t *)&v3);
}

void sub_100621F30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100621F44(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFE58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100621F64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFE58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100621FB8(uint64_t a1)
{
  return sub_10007B3EC(a1 + 24);
}

uint64_t *sub_100621FC4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  char v10 = v1;
  uint64_t v2 = *v1;
  *(_DWORD *)(v1[1] + 16) = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 208) + 88))(buf);
  uint64_t v3 = (uint64_t *)v1[1];
  long long v4 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  int v5 = (std::__shared_weak_count *)v3[1];
  *(_OWORD *)uint64_t v3 = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    uint64_t v6 = *v3;
  }
  else
  {
    uint64_t v6 = v4;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!v6)
  {
    unsigned __int8 v7 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I capabilities not available", buf, 2u);
    }
    *(_DWORD *)(v1[1] + 16) = 6;
  }
  sub_1000E1A60((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1006220BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1006220D8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && *(void *)(v3 + 56))
  {
    int v5 = (char *)operator new(0x58uLL);
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 1) = 0;
    *(void *)int v5 = off_1019EFEA8;
    *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
    uint64_t v6 = v5 + 24;
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *((_DWORD *)v5 + 1sub_10010E764((uint64_t)&a9, 0) = *(_DWORD *)(v3 + 16);
    *((void *)v5 + 6) = v4;
    *(void *)(v3 + 24) = 0;
    sub_10007BAA8((uint64_t)(v5 + 56), v3 + 32);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  else
  {
    uint64_t v6 = 0;
    int v5 = 0;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 208) + 96))(&v17);
  if (*(_DWORD *)(v2 + 572) != 6012)
  {
    uint64_t v11 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      int v10 = 2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I user consent procedure not really required", buf, 2u);
    }
    else
    {
      int v10 = 2;
    }
LABEL_16:
    *((_DWORD *)v6 + 4) = v10;
    goto LABEL_17;
  }
  uint64_t v7 = v17;
  if (v17)
  {
    uint64_t v8 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (std::__shared_weak_count *)*((void *)v6 + 1);
    *(void *)uint64_t v6 = v7;
    *((void *)v6 + 1) = v8;
    if (v9) {
      sub_10004D2C8(v9);
    }
    int v10 = 0;
    goto LABEL_16;
  }
  unsigned int v13 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "user consent flow info not available", buf, 2u);
  }
  *((_DWORD *)v6 + 4) = 6;
  sub_100618350(v2);
  sub_10061873C(v2, *(unsigned int *)(v2 + 380), 7, 2);
LABEL_17:
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v5) {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  sub_10062233C((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_1006222F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10062233C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10007B7E8((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100622390(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFEA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006223B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFEA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100622404(uint64_t a1)
{
  return sub_10007B838(a1 + 24);
}

void sub_100622410(uint64_t **a1)
{
  int v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v1 + 8)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I user consented: %s", buf, 0xCu);
  }
  if (*((unsigned char *)v1 + 8))
  {
    sub_100618350(v2);
    sub_10061873C(v2, *(unsigned int *)(v2 + 380), 7, 2);
  }
  operator delete();
}

void sub_10062251C()
{
}

uint64_t *sub_100622548(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && *(void *)(v3 + 56))
  {
    int v5 = (char *)operator new(0x58uLL);
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 1) = 0;
    *(void *)int v5 = off_1019EFEF8;
    *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
    uint64_t v6 = v5 + 24;
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *((_DWORD *)v5 + 1sub_10010E764((uint64_t)&a9, 0) = *(_DWORD *)(v3 + 16);
    *((void *)v5 + 6) = v4;
    *(void *)(v3 + 24) = 0;
    sub_10007BE6C((uint64_t)(v5 + 56), v3 + 32);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  else
  {
    uint64_t v6 = 0;
    int v5 = 0;
  }
  int v7 = *(_DWORD *)(v2 + 572);
  BOOL v8 = sub_1006191C8((const void **)v2, 1u);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 208) + 104))(&v16);
  if (v7 == 6012)
  {
    int v9 = 3;
  }
  else
  {
    uint64_t v10 = v16;
    if (v16)
    {
      uint64_t v11 = v17;
      if (v8)
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
        int v9 = 9;
      }
      else
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v9 = 0;
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
      }
      *(void *)uint64_t v6 = v10;
      *((void *)v6 + 1) = v11;
      if (v12) {
        sub_10004D2C8(v12);
      }
    }
    else
    {
      int v9 = 6;
    }
  }
  *((_DWORD *)v6 + 4) = v9;
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (*(unsigned char *)(v1 + 16) && sub_100619084(v2)) {
    sub_10061873C(v2, *(unsigned int *)(v2 + 380), 1, 1);
  }
  if (v5) {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  sub_100622754(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100622720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100622754(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10007BBAC((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_1006227A8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFEF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1006227C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFEF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10062281C(uint64_t a1)
{
  return sub_10007BBFC(a1 + 24);
}

uint64_t *sub_100622828(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && *(void *)(v3 + 56))
  {
    int v5 = (char *)operator new(0x58uLL);
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 1) = 0;
    *(void *)int v5 = off_1019EFF48;
    *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
    uint64_t v6 = v5 + 24;
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *((_DWORD *)v5 + 1sub_10010E764((uint64_t)&a9, 0) = *(_DWORD *)(v3 + 16);
    *((void *)v5 + 6) = v4;
    *(void *)(v3 + 24) = 0;
    sub_10007C230((uint64_t)(v5 + 56), v3 + 32);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  else
  {
    uint64_t v6 = 0;
    int v5 = 0;
  }
  int v7 = *(_DWORD *)(v2 + 572);
  BOOL v8 = sub_1006191C8((const void **)v2, 2u);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 208) + 112))(&v16);
  if (v7 == 6012)
  {
    int v9 = 3;
  }
  else
  {
    uint64_t v10 = v16;
    if (v16)
    {
      uint64_t v11 = v17;
      if (v8)
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
        int v9 = 9;
      }
      else
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v9 = 0;
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
      }
      *(void *)uint64_t v6 = v10;
      *((void *)v6 + 1) = v11;
      if (v12) {
        sub_10004D2C8(v12);
      }
    }
    else
    {
      int v9 = 6;
    }
  }
  *((_DWORD *)v6 + 4) = v9;
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (*(unsigned char *)(v1 + 16) && sub_100619084(v2)) {
    sub_10061873C(v2, *(unsigned int *)(v2 + 380), 2, 1);
  }
  if (v5) {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  sub_100622A34(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100622A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100622A34(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10007BF70((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100622A88(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFF48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100622AA8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFF48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100622AFC(uint64_t a1)
{
  return sub_10007BFC0(a1 + 24);
}

uint64_t *sub_100622B08(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && *(void *)(v3 + 56))
  {
    int v5 = (char *)operator new(0x58uLL);
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 1) = 0;
    *(void *)int v5 = off_1019EFF98;
    *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
    uint64_t v6 = v5 + 24;
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *((_DWORD *)v5 + 1sub_10010E764((uint64_t)&a9, 0) = *(_DWORD *)(v3 + 16);
    *((void *)v5 + 6) = v4;
    *(void *)(v3 + 24) = 0;
    sub_10007C5F4((uint64_t)(v5 + 56), v3 + 32);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  else
  {
    uint64_t v6 = 0;
    int v5 = 0;
  }
  int v7 = *(_DWORD *)(v2 + 572);
  BOOL v8 = sub_1006191C8((const void **)v2, 4u);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 208) + 120))(&v16);
  if (v7 == 6012)
  {
    int v9 = 3;
  }
  else
  {
    uint64_t v10 = v16;
    if (v16)
    {
      uint64_t v11 = v17;
      if (v8)
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
        int v9 = 9;
      }
      else
      {
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v9 = 0;
        unsigned int v12 = (std::__shared_weak_count *)*((void *)v6 + 1);
      }
      *(void *)uint64_t v6 = v10;
      *((void *)v6 + 1) = v11;
      if (v12) {
        sub_10004D2C8(v12);
      }
    }
    else
    {
      int v9 = 6;
    }
  }
  *((_DWORD *)v6 + 4) = v9;
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (*(unsigned char *)(v1 + 16) && sub_100619084(v2)) {
    sub_10061873C(v2, *(unsigned int *)(v2 + 380), 4, 1);
  }
  if (v5) {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  sub_100622D14(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100622CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100622D14(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10007C334((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100622D68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFF98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100622D88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFF98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100622DDC(uint64_t a1)
{
  return sub_10007C384(a1 + 24);
}

void sub_100622DE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFFE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100622E08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EFFE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100622E5C(uint64_t a1)
{
  return sub_10007C748(a1 + 24);
}

uint64_t *sub_100622E68(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100619084(*(void *)v1)) {
    int v3 = sub_10061873C(v2, *(unsigned int *)(v2 + 380), 7, 1);
  }
  else {
    int v3 = 13;
  }
  if (*(_DWORD *)(v2 + 572) == 6012) {
    int v4 = 3;
  }
  else {
    int v4 = v3;
  }
  **(_DWORD **)(v1 + 8) = v4;
  sub_100622F08(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100622EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100622F08(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100622F5C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  char v2 = *((unsigned char *)*a1 + 8);
  if (v2)
  {
    (*(void (**)(void))(**(void **)(v1 + 144) + 56))(*(void *)(v1 + 144));
    int v3 = *(_DWORD *)(v1 + 345);
    __int16 v4 = *(_WORD *)(v1 + 333);
    int v5 = *(_DWORD *)(v1 + 328);
    BYTE2(v13) = *(unsigned char *)(v1 + 335);
    LOWORD(v13) = v4;
    LODWORD(v18) = v3;
    *(_DWORD *)((char *)&v18 + 3) = *(_DWORD *)(v1 + 348);
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v1 + 208) + 80))(*(void *)(v1 + 208));
    *(_DWORD *)(v1 + 328) = v5;
    *(unsigned char *)(v1 + 332) = 1;
    *(_WORD *)(v1 + 333) = v13;
    *(unsigned char *)(v1 + 335) = BYTE2(v13);
    *(void *)(v1 + 336) = v6;
    *(unsigned char *)(v1 + 344) = v7;
    *(_DWORD *)(v1 + 345) = v18;
    *(_DWORD *)(v1 + 348) = *(_DWORD *)((char *)&v18 + 3);
    uint64_t v8 = *(void *)(v1 + 320);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v1 + 328);
    }
    if (*(unsigned char *)(v1 + 504))
    {
      uint64_t v9 = *(void *)(v1 + 240);
      (*(void (**)(void **__return_ptr))(**(void **)(v1 + 208) + 104))(&__p);
      int v10 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v9 + 48))(v9, &__p);
      if (v16) {
        sub_10004D2C8(v16);
      }
      if (v10) {
        (*(void (**)(void))(**(void **)(v1 + 144) + 80))(*(void *)(v1 + 144));
      }
    }
  }
  if ((v2 & 2) != 0)
  {
    (*(void (**)(void))(**(void **)(v1 + 144) + 64))(*(void *)(v1 + 144));
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    (*(void (**)(id **__return_ptr))(**(void **)(v1 + 224) + 56))(&v18);
    if (v18)
    {
      long long __p = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      sub_100ED1320(&v18, &__p);
      uint64_t v13 = 0;
      int v14 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(v1 + 208) + 128))(&v13);
      if (v13)
      {
        (*(void (**)(void, uint64_t *))(**(void **)(v1 + 224) + 24))(*(void *)(v1 + 224), &v13);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(v1 + 72);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          p_p = &__p;
          if (v17 < 0) {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v21 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Received plans update, but it did not contain provisioning plan '%s'", buf, 0xCu);
        }
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(__p);
      }
    }
    if (v19) {
      sub_10004D2C8(v19);
    }
  }
  if ((v2 & 4) != 0) {
    (*(void (**)(void))(**(void **)(v1 + 144) + 72))(*(void *)(v1 + 144));
  }
  *(unsigned char *)(v1 + 568) &= v2 ^ 7;
  operator delete();
}

void sub_100623314(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  operator delete();
}

uint64_t *sub_100623390(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  memset(v38, 0, sizeof(v38));
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 224) + 56))(v38);
  uint64_t v3 = *(void *)v38;
  if (*(void *)v38)
  {
    __int16 v4 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (void *)(v1 + 24);
      if (*(char *)(v1 + 47) < 0) {
        int v5 = (void *)*v5;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Rejecting request to purchase plan '%s', since already have one in progress", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v6 = *(_DWORD **)(v1 + 8);
    if (v6) {
      *uint64_t v6 = 2;
    }
  }
  if (*(void *)&v38[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v38[8]);
  }
  if (!v3)
  {
    if (subscriber::isValidSimSlot())
    {
      *(_DWORD *)(v1 + 16) = *(_DWORD *)(v2 + 380);
      uint64_t v33 = 0;
      long long v34 = 0;
      uint64_t v8 = (_OWORD *)(v1 + 24);
      (*(void (**)(id **__return_ptr))(**(void **)(v2 + 208) + 128))(&v33);
      if (v33)
      {
        *(_OWORD *)uint64_t v40 = 0u;
        memset(__p, 0, 112);
        memset(v39, 0, sizeof(v39));
        uint64_t v9 = *(void *)(v1 + 8);
        *(void *)(v1 + 8) = 0;
        *(void *)uint64_t v38 = v2;
        *(void *)&v38[8] = v9;
        LODWORD(v39[0]) = *(_DWORD *)(v1 + 16);
        int v10 = *(void **)(v1 + 40);
        *(_OWORD *)&v39[1] = *v8;
        v39[3] = v10;
        *(void *)(v1 + 32) = 0;
        *(void *)(v1 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
        *(void *)uint64_t v8 = 0;
        long long v11 = *(_OWORD *)(v1 + 48);
        __p[0] = *(void **)(v1 + 64);
        *(_OWORD *)uint64_t v40 = v11;
        *(void *)(v1 + 48) = 0;
        *(void *)(v1 + 56) = 0;
        *(void *)(v1 + 64) = 0;
        if (*(unsigned char *)(v1 + 96))
        {
          long long v12 = *(_OWORD *)(v1 + 72);
          __p[3] = *(void **)(v1 + 88);
          *(_OWORD *)&__p[1] = v12;
          *(void *)(v1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
          *(void *)(v1 + 88) = 0;
          *(void *)(v1 + 72) = 0;
          LOBYTE(__p[4]) = 1;
        }
        sub_10007CB50(&__p[5], v1 + 104);
        uint64_t v13 = (char *)operator new(0xC8uLL);
        int v14 = (atomic_ullong *)v13;
        *((void *)v13 + 1) = 0;
        *((void *)v13 + 2) = 0;
        *(void *)uint64_t v13 = off_1019F0038;
        *(_OWORD *)(v13 + 24) = *(_OWORD *)v38;
        uint64_t v15 = v13 + 24;
        *(void *)&v38[8] = 0;
        *((_DWORD *)v13 + 1sub_10010E764((uint64_t)&a9, 0) = v39[0];
        *((_OWORD *)v13 + 3) = *(_OWORD *)&v39[1];
        *((void **)v13 + 8) = v39[3];
        memset(&v39[1], 0, 24);
        *((void **)v13 + 11) = __p[0];
        *(_OWORD *)(v13 + 72) = *(_OWORD *)v40;
        v40[0] = 0;
        v40[1] = 0;
        __p[0] = 0;
        v13[96] = 0;
        v13[120] = 0;
        if (LOBYTE(__p[4]))
        {
          *((_OWORD *)v13 + 6) = *(_OWORD *)&__p[1];
          *((void **)v13 + 14) = __p[3];
          memset(&__p[1], 0, 24);
          v13[120] = 1;
        }
        sub_10007CB50(v13 + 128, (uint64_t)&__p[5]);
        CFTypeRef cf = 0;
        sub_100ED1264(&v33, &cf);
        uint64_t v16 = *(unsigned int *)(v1 + 16);
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        uint64_t v17 = *(void *)(v2 + 128);
        uint64_t v18 = *(NSObject **)(v2 + 56);
        dispatch_object_t object = v18;
        if (v18) {
          dispatch_retain(v18);
        }
        CFTypeRef v28 = cf;
        if (cf) {
          CFRetain(cf);
        }
        sub_100BE88AC((Registry **)(v2 + 96), v16, &v27);
        atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
        *(void *)&long long buf = off_1019F0088;
        *((void *)&buf + 1) = v15;
        long long v36 = v14;
        p_long long buf = &buf;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, dispatch_object_t *, CFTypeRef *, const void **, long long *))(*(void *)v17 + 88))(&v30, v17, &object, &v28, &v27, &buf);
        sub_1000DA3EC(&buf);
        sub_1000558F4(&v27);
        sub_1000558F4(&v28);
        if (object) {
          dispatch_release(object);
        }
        dispatch_get_global_queue(0, 0);
        if (v31) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
        }
        operator new();
      }
      uint64_t v21 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v1 + 47) >= 0) {
          uint64_t v22 = v1 + 24;
        }
        else {
          uint64_t v22 = *(void *)(v1 + 24);
        }
        *(_DWORD *)uint64_t v38 = 136315138;
        *(void *)&v38[4] = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N User requested to purchase plan '%s', but it was not found", v38, 0xCu);
      }
      long long v23 = *(_DWORD **)(v1 + 8);
      if (v23) {
        *long long v23 = 8;
      }
      if (v34) {
        sub_10004D2C8(v34);
      }
    }
    else
    {
      uint64_t v19 = *(NSObject **)(v2 + 72);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        unsigned int v24 = (void *)(v1 + 24);
        if (*(char *)(v1 + 47) < 0) {
          unsigned int v24 = (void *)*v24;
        }
        *(_DWORD *)uint64_t v38 = 136315138;
        *(void *)&v38[4] = v24;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Rejecting request to purchase plan '%s', since the data SIM preference is invalid", v38, 0xCu);
      }
      uint64_t v20 = *(_DWORD **)(v1 + 8);
      if (v20) {
        _DWORD *v20 = 2;
      }
    }
  }
  sub_1006239CC(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100623934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, dispatch_object_t object, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1006239CC(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10007CAFC(v1 + 104);
    if (*(unsigned char *)(v1 + 96) && *(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    sub_10007C6F8((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100623A60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F0038;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100623A80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F0038;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100623AD4(uint64_t a1)
{
  sub_10007CAFC(a1 + 128);
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }

  return sub_10007C6F8((uint64_t *)(a1 + 32), 0);
}

void *sub_100623B50(void *a1)
{
  *a1 = off_1019F0088;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100623B9C(void *a1)
{
  *a1 = off_1019F0088;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_100623C08(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019F0088;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100623C64(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019F0088;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100623C9C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100623CAC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100623CEC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (v2)
  {
    int v3 = *a2;
    uint64_t v4 = *v2;
    int v5 = *(NSObject **)(*v2 + 72);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v3 == 1)
    {
      if (v6)
      {
        char v7 = v2 + 3;
        if (*((char *)v2 + 47) < 0) {
          char v7 = (void *)*v7;
        }
        int v10 = 136315138;
        long long v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User requesting to purchase plan '%s'", (uint8_t *)&v10, 0xCu);
      }
      (*(void (**)(void, uint64_t *))(**(void **)(v4 + 192) + 48))(*(void *)(v4 + 192), v2 + 1);
    }
    else
    {
      if (v6)
      {
        uint64_t v8 = v2 + 3;
        if (*((char *)v2 + 47) < 0) {
          uint64_t v8 = (void *)*v8;
        }
        int v10 = 136315138;
        long long v11 = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User canceled request to purchase plan '%s'", (uint8_t *)&v10, 0xCu);
      }
      uint64_t v9 = (_DWORD *)v2[1];
      if (v9) {
        _DWORD *v9 = 11;
      }
    }
  }
}

uint64_t sub_100623E3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100623E7C()
{
}

uint64_t *sub_100623E88(void *a1)
{
  int v3 = a1;
  uint64_t v1 = *a1;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  return sub_1000E3958((uint64_t *)&v3);
}

void sub_100623EE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100623EF8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 192);
  char v7 = 0;
  uint64_t v8 = 0;
  BOOL v6 = 0;
  sub_10005C928(&v6, *(const void **)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 16) - *(void *)(v1 + 8));
  int v10 = 0;
  uint64_t v11 = 0;
  long long __p = 0;
  sub_10005C928(&__p, *(const void **)(v1 + 32), *(void *)(v1 + 40), *(void *)(v1 + 40) - *(void *)(v1 + 32));
  sub_100602178(&v12, (const void **)(v1 + 56));
  __int16 v13 = *(_WORD *)(v1 + 64);
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 56))(v2, &v6);
  sub_10007CA64(&v12);
  if (__p)
  {
    int v10 = __p;
    operator delete(__p);
  }
  if (v6)
  {
    char v7 = v6;
    operator delete(v6);
  }
  sub_10062403C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100623FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  sub_10007CA64(v15);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a11)
  {
    a12 = (uint64_t)a11;
    operator delete(a11);
  }
  sub_10062403C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10062403C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10007CA64((const void **)(v1 + 56));
    uint64_t v2 = *(void **)(v1 + 32);
    if (v2)
    {
      *(void *)(v1 + 4sub_10010E764((uint64_t)&a9, 0) = v2;
      operator delete(v2);
    }
    int v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(void *)(v1 + 16) = v3;
      operator delete(v3);
    }
    operator delete();
  }
  return result;
}

void sub_1006240AC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = 1;
  switch(*((unsigned char *)*a1 + 8))
  {
    case 0:
      int v3 = *(NSObject **)(v1 + 72);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Client exited auth flow in unclean manner, clearing state in authentication flow", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(v1 + 192) + 88))(*(void *)(v1 + 192));
      break;
    case 1:
      (*(void (**)(void, void))(**(void **)(v1 + 192) + 64))(*(void *)(v1 + 192), *(uint64_t *)((char *)*a1 + 12));
      break;
    case 2:
      goto LABEL_6;
    case 3:
      uint64_t v2 = 0;
LABEL_6:
      (*(void (**)(void, uint64_t))(**(void **)(v1 + 192) + 72))(*(void *)(v1 + 192), v2);
      break;
    default:
      break;
  }
  operator delete();
}

void sub_1006241F8()
{
}

uint64_t *sub_100624234(void **a1)
{
  uint64_t v1 = *a1;
  long long v12 = a1;
  __int16 v13 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && *(void *)(v3 + 56))
  {
    uint64_t v5 = (char *)operator new(0x58uLL);
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 1) = 0;
    *(void *)uint64_t v5 = off_1019F0108;
    *(_OWORD *)(v5 + 24) = *(_OWORD *)v3;
    BOOL v6 = v5 + 24;
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *((void *)v5 + 5) = *(void *)(v3 + 16);
    *((void *)v5 + 6) = v4;
    *(void *)(v3 + 24) = 0;
    sub_10007CE4C((uint64_t)(v5 + 56), v3 + 32);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
  else
  {
    BOOL v6 = 0;
    uint64_t v5 = 0;
  }
  if (*(unsigned char *)(v2 + 504))
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 240) + 56))(&v14);
    uint64_t v8 = v14;
    char v7 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (std::__shared_weak_count *)*((void *)v6 + 1);
    *(void *)BOOL v6 = v8;
    *((void *)v6 + 1) = v7;
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
    if (*(void *)v6)
    {
      if (!sub_1006191C8((const void **)v2, 1u))
      {
        *((_DWORD *)v6 + 4) = 0;
        if (!v5) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      int v10 = 9;
    }
    else
    {
      int v10 = 6;
    }
  }
  else
  {
    int v10 = 7;
  }
  *((_DWORD *)v6 + 4) = v10;
  if (v5) {
LABEL_19:
  }
    sub_10004D2C8((std::__shared_weak_count *)v5);
LABEL_20:
  sub_1006243F4((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_1006243C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1006243F4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10007CB90((uint64_t *)(v1 + 8), 0);
    operator delete();
  }
  return result;
}

void sub_100624448(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F0108;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100624468(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F0108;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006244BC(uint64_t a1)
{
  return sub_10007CBE0(a1 + 24);
}

uint64_t *sub_1006244C8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (uint64_t *)v1[1];
  uint64_t v4 = (std::__shared_weak_count *)v1[2];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
    if (*(_DWORD *)(v2 + 572) == 6012)
    {
      if (*v3)
      {
        uint64_t v5 = *(void *)(v2 + 208);
        BOOL v6 = (std::__shared_weak_count *)v3[1];
        uint64_t v24 = *v3;
        unsigned __int8 v25 = v6;
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 48))(v5, &v24);
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
      else
      {
        sub_100618350(v2);
      }
    }
    uint64_t v7 = v3[2];
    if (v7)
    {
      uint64_t v8 = 60 * v7;
      if (v8 != *(void *)(v2 + 488))
      {
        *(void *)(v2 + 488) = v8;
        sub_1006150D0((const void **)v2);
      }
    }
    if (v3[3])
    {
      uint64_t v9 = *(void *)(v2 + 208);
      int v10 = (std::__shared_weak_count *)v3[4];
      uint64_t v22 = v3[3];
      long long v23 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 56))(v9, &v22);
      if (v23) {
        sub_10004D2C8(v23);
      }
    }
    if (v3[5])
    {
      uint64_t v11 = *(void *)(v2 + 208);
      long long v12 = (std::__shared_weak_count *)v3[6];
      uint64_t v20 = v3[5];
      uint64_t v21 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 64))(v11, &v20);
      if (v21) {
        sub_10004D2C8(v21);
      }
    }
    if (v3[7])
    {
      uint64_t v13 = *(void *)(v2 + 208);
      uint64_t v14 = (std::__shared_weak_count *)v3[8];
      uint64_t v18 = v3[7];
      uint64_t v19 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v13 + 72))(v13, &v18);
      if (v19) {
        sub_10004D2C8(v19);
      }
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000E1A60((uint64_t *)&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_1006246D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v13 = *(std::__shared_weak_count **)(v11 - 40);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1000E1A60(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100624744(id ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  id v3 = v2[18];
  uint64_t v4 = (std::__shared_weak_count *)v1[3];
  uint64_t v16 = v1[2];
  uint64_t v17 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(id, void, id **))(*(void *)v3 + 88))(v3, 0, &v16);
  if (v17) {
    sub_10004D2C8(v17);
  }
  char v15 = 1;
  rest::carrier_space::write_rest_value();
  sub_100058DB0(buf, "/cc/events/carrier_space_plan_purchased");
  __p[0] = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(0);
  if (v19 < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(__p[0]);
  uint64_t v5 = (NSObject **)(*(uint64_t (**)(id, void))(*(void *)v2[10] + 16))(v2[10], *((unsigned int *)v1 + 2));
  uint64_t v13 = 0;
  uint64_t v14 = v5;
  __p[0] = 0;
  __p[1] = 0;
  sub_100ED1320(v1 + 2, __p);
  BOOL v6 = *v5;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = __p;
    if (v13 < 0) {
      uint64_t v7 = (xpc_object_t *)__p[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Plan '%s' has been provisioned", buf, 0xCu);
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  id v8 = v2[16];
  sub_100BE88AC((Registry **)v2 + 12, *((unsigned int *)v1 + 2), &v9);
  (*(void (**)(uint64_t *__return_ptr, id, const void **))(*(void *)v8 + 72))(&v10, v8, &v9);
  sub_1000558F4(&v9);
  dispatch_get_global_queue(0, 0);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100624A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  sub_10013A778(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100624B84(void *a1)
{
  id v3 = a1;
  uint64_t v1 = *a1;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  return sub_1000E3958((uint64_t *)&v3);
}

void sub_100624BE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100624BF8()
{
}

__n128 sub_100624C0C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F0158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100624C58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F0158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100624C88(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(id **)a2;
  id v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = ***(NSObject ****)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v6 = *(uint64_t **)(a1 + 16);
    if (*((char *)v6 + 23) < 0) {
      BOOL v6 = (uint64_t *)*v6;
    }
    int v8 = 136315394;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = "kSubscribed";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting subscription status for plan '%s' to %s", (uint8_t *)&v8, 0x16u);
  }
  if (v4 && *v4) {
    [*v4 setPlanSubscriptionStatus:0];
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  return 1;
}

void sub_100624D84(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100624D9C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019F01B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100624DDC()
{
  return &off_1019F01B8;
}

void sub_100624DE8(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(void *)(v1 + 24);
  v6[0] = *(void *)(v1 + 16);
  v6[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100618400(v2, 2, (uint64_t)v6);
}

void sub_100624F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100624F90()
{
}

__n128 sub_100624FA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F01D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100624FF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F01D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100625030(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(id **)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  BOOL v6 = **(id ***)(a1 + 8);
  if (v6 && *v6) {
    uint64_t v7 = (uint64_t)[*v6 planSubscriptionStatus];
  }
  else {
    uint64_t v7 = 3;
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 80) + 16))(*(void *)(v5 + 80), **(unsigned int **)(a1 + 24));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(uint64_t **)(a1 + 32);
    if (*((char *)v9 + 23) < 0) {
      uint64_t v9 = (uint64_t *)*v9;
    }
    if (v7 > 3) {
      __int16 v10 = "???";
    }
    else {
      __int16 v10 = off_1019F0490[(char)v7];
    }
    int v12 = 136315394;
    uint64_t v13 = v9;
    __int16 v14 = 2080;
    char v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Restoring subscription status for plan '%s' to %s", (uint8_t *)&v12, 0x16u);
  }
  if (v4 && v7 != 3 && *v4) {
    [*v4 setPlanSubscriptionStatus:v7];
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  return 1;
}

void sub_1006251A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006251BC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019F0238)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006251FC()
{
  return &off_1019F0238;
}

void sub_100625208(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100618FA4(**a1, 2u);
  operator delete();
}

void sub_100625260()
{
}

void sub_10062528C(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 144) + 80))(*(void *)(**(void **)a1 + 144));
  operator delete();
}

void sub_100625304()
{
}

void *sub_100625330@<X0>(int *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  BOOL v6 = operator new(0x30uLL);
  __n128 result = sub_100625394(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100625380(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100625394(void *a1, int *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019C4290;
  sub_1003B16D8((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1006253DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006253F0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100619084(*(void *)v1)) {
    int v3 = sub_10061873C(v2, *(unsigned int *)(v2 + 380), 1, 1);
  }
  else {
    int v3 = 13;
  }
  if (*(_DWORD *)(v2 + 572) == 6012) {
    int v4 = 3;
  }
  else {
    int v4 = v3;
  }
  **(_DWORD **)(v1 + 8) = v4;
  sub_100622F08(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100625474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100625490(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100619084(*(void *)v1)) {
    int v3 = sub_10061873C(v2, *(unsigned int *)(v2 + 380), 2, 1);
  }
  else {
    int v3 = 13;
  }
  if (*(_DWORD *)(v2 + 572) == 6012) {
    int v4 = 3;
  }
  else {
    int v4 = v3;
  }
  **(_DWORD **)(v1 + 8) = v4;
  sub_100622F08(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100625514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100625530(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100619084(*(void *)v1)) {
    int v3 = sub_10061873C(v2, *(unsigned int *)(v2 + 380), 4, 1);
  }
  else {
    int v3 = 13;
  }
  if (*(_DWORD *)(v2 + 572) == 6012) {
    int v4 = 3;
  }
  else {
    int v4 = v3;
  }
  **(_DWORD **)(v1 + 8) = v4;
  sub_100622F08(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1006255B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1006255D0()
{
  qword_101B0D1D8 = 0;
  qword_101B0D1E0 = 0;
  qword_101B0D1E8 = 0;
  v0 = operator new(0x18uLL);
  v0[2] = 10;
  qword_101B0D1E0 = (uint64_t)(v0 + 3);
  qword_101B0D1E8 = (uint64_t)(v0 + 3);
  *(_OWORD *)v0 = xmmword_1014CA9A8;
  qword_101B0D1D8 = (uint64_t)v0;

  return __cxa_atexit((void (*)(void *))sub_100613278, &qword_101B0D1D8, (void *)&_mh_execute_header);
}

void sub_100625654(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1006258F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void *sub_100625A08(void *a1)
{
  *a1 = off_1019F04C0;
  uint64_t v2 = (id *)a1[8];
  a1[8] = 0;
  if (v2)
  {

    operator delete();
  }
  int v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100625A98(void *a1)
{
  sub_100625A08(a1);

  operator delete();
}

void sub_100625AD0(void *a1, void *a2)
{
  id v3 = a2;
  int v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v5 = a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        int v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Trial carrier bundle namespace updated. Check factors.", buf, 2u);
        }
        uint64_t v9 = **(void ***)(v5 + 64);
        CFStringRef v14 = @"TrialCarrierBundle";
        __int16 v10 = +[NSArray arrayWithObjects:&v14 count:1];
        uint64_t v11 = *(void *)(v5 + 24);
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472;
        v12[2] = sub_100625C70;
        v12[3] = &unk_1019F04D0;
        void v12[4] = v5;
        [v9 downloadLevelsForFactors:v10 withNamespace:@"WIRELESS_DATA_ANALYTICS_CELLULAR_PRODUCT_EXPERIMENTATION" queue:v11 options:0 progress:0 completion:v12];
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100625C44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100625C70(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Trial config is updated.", (uint8_t *)&buf, 2u);
    }
    [**(id **)(v6 + 64) refresh];
    int v8 = [**(id **)(v6 + 64) levelForFactor:@"TrialCarrierBundle" withNamespaceName:@"WIRELESS_DATA_ANALYTICS_CELLULAR_PRODUCT_EXPERIMENTATION"];
    uint64_t v9 = v8;
    if (!v8)
    {
      char v19 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid trial level.", (uint8_t *)&buf, 2u);
      }
      goto LABEL_51;
    }
    __int16 v10 = [v8 fileValue];
    uint64_t v11 = [v10 path];
    if (v11)
    {
      int v12 = [v9 fileValue];
      uint64_t v13 = [v12 path];
      BOOL v14 = [v13 length] == 0;

      if (!v14)
      {
        char v15 = [v9 fileValue];
        uint64_t v16 = [v15 path];
        uint64_t v17 = +[NSURL fileURLWithPath:v16];
        CFTypeRef cf = v17;
        if (v17)
        {
          CFRetain(v17);
          CFTypeRef v18 = cf;
        }
        else
        {
          CFTypeRef v18 = 0;
        }

        if (v18) {
          uint64_t v31 = sub_1000FCC20;
        }
        else {
          uint64_t v31 = 0;
        }
        __int16 v32 = *(NSObject **)(v6 + 40);
        if (!v31)
        {
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid bundle path in trial", (uint8_t *)&buf, 2u);
          }
          goto LABEL_50;
        }
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = [v9 fileValue];
          long long v34 = [v33 path];
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v34;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Trial Carrier bundle Asset path %{public}@", (uint8_t *)&buf, 0xCu);
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v6 + 48));
        long long v36 = ServiceMap;
        if (v37 < 0)
        {
          uint64_t v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v39 = 5381;
          do
          {
            uint64_t v37 = v39;
            unsigned int v40 = *v38++;
            uint64_t v39 = (33 * v39) ^ v40;
          }
          while (v40);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long buf = v37;
        uint64_t v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)&buf);
        if (v41)
        {
          uint64_t v43 = v41[3];
          uint64_t v42 = (std::__shared_weak_count *)v41[4];
          if (v42)
          {
            atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v36);
            atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v42);
            char v44 = 0;
            if (!v43) {
              goto LABEL_39;
            }
            goto LABEL_45;
          }
        }
        else
        {
          uint64_t v43 = 0;
        }
        std::mutex::unlock(v36);
        uint64_t v42 = 0;
        char v44 = 1;
        if (!v43)
        {
LABEL_39:
          uint64_t v45 = *(NSObject **)(v6 + 40);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to get carrier bundle interface. Not installing trial bundle.", (uint8_t *)&buf, 2u);
          }
LABEL_48:
          if ((v44 & 1) == 0) {
            sub_10004D2C8(v42);
          }
LABEL_50:
          sub_1000FE824(&cf);
LABEL_51:

          goto LABEL_52;
        }
LABEL_45:
        CFTypeRef v46 = cf;
        if (cf) {
          CFRetain(cf);
        }
        *(void *)&long long buf = off_1019F06A8;
        *((void *)&buf + 1) = v6;
        p_long long buf = &buf;
        (*(void (**)(uint64_t, CFTypeRef *, long long *))(*(void *)v43 + 80))(v43, &v46, &buf);
        sub_100060644(&buf);
        sub_1000FE824(&v46);
        goto LABEL_48;
      }
    }
    else
    {
    }
    uint64_t v20 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Asset path not valid. Treatment ended. Clear trial bundles", (uint8_t *)&buf, 2u);
    }
    uint64_t v21 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v6 + 48));
    uint64_t v22 = v21;
    if (v23 < 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    *(void *)&long long buf = v23;
    uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)&buf);
    if (v27)
    {
      uint64_t v29 = v27[3];
      CFTypeRef v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        if (!v29)
        {
LABEL_24:
          if ((v30 & 1) == 0) {
            sub_10004D2C8(v28);
          }
          goto LABEL_51;
        }
LABEL_23:
        (*(void (**)(uint64_t))(*(void *)v29 + 352))(v29);
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    CFTypeRef v28 = 0;
    char v30 = 1;
    if (!v29) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
LABEL_52:
}

void sub_10062619C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100626288(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1006262A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1006262B8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006262F0(uint64_t a1)
{
}

uint64_t sub_10062630C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100626350(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10062637C(ServiceManager::Service *this)
{
  *(void *)this = off_1019F0628;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1006263D8(ServiceManager::Service *this)
{
  *(void *)this = off_1019F0628;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100626448@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CarrierBundleTrialHandler");
}

unsigned char *sub_100626458@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100626498(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_1006264F4()
{
  return 0;
}

uint64_t sub_1006264FC()
{
  return 1;
}

uint64_t sub_100626504()
{
  return 0;
}

void sub_100626510(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006265F4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (**(void **)(v1 + 64))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (!v2 || (uint64_t v3 = *(void *)(v1 + 8), (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
      sub_100088B9C();
    }
    id v5 = v4;
    p_shared_weak_owners = &v4->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
    uint64_t v7 = **(void ***)(v1 + 64);
    uint64_t v8 = *(void *)(v1 + 24);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v12 = 3321888768;
    uint64_t v13 = sub_100625AD0;
    BOOL v14 = &unk_1019F04F0;
    uint64_t v15 = v1;
    uint64_t v16 = v3;
    uint64_t v17 = v5;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    id v9 = [v7 addUpdateHandlerForNamespaceName:@"WIRELESS_DATA_ANALYTICS_CELLULAR_PRODUCT_EXPERIMENTATION" queue:v8 usingBlock:buf];
    if (v17) {
      std::__shared_weak_count::__release_weak(v17);
    }
    std::__shared_weak_count::__release_weak(v5);
  }
  else
  {
    __int16 v10 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid Trial client", buf, 2u);
    }
  }
  operator delete();
}

void sub_10062675C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  std::__shared_weak_count::__release_weak(v17);
  operator delete();
}

void sub_1006267A8()
{
}

void *sub_1006267BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F06A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100626804(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F06A8;
  a2[1] = v2;
  return result;
}

void sub_100626830(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v2 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Trial bundle failed to install.", v3, 2u);
    }
  }
}

uint64_t sub_10062689C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006268DC()
{
}

uint64_t sub_1006268E8(uint64_t a1, unsigned int a2, unint64_t *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v3 = a1 + 16;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        id v9 = (uint64_t *)v4;
      }
      else {
        id v9 = (uint64_t *)(v4 + 8);
      }
      if (v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v3 && *(_DWORD *)(v6 + 32) <= a2)
    {
      uint64_t v11 = *(unint64_t **)(v6 + 40);
      __int16 v10 = *(unint64_t **)(v6 + 48);
      if (v11 != v10)
      {
        unint64_t v12 = *a3;
        while (v12 >= *v11)
        {
          if (v12 <= v11[1]) {
            return 0;
          }
          v11 += 2;
          if (v11 == v10) {
            return 1;
          }
        }
      }
    }
  }
  return 1;
}

void sub_100626968(uint64_t a1, os_log_t *a2)
{
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [d] serviceSchedule {", buf, 2u);
  }
  uint64_t v5 = *(void **)(a1 + 8);
  if (v5 != (void *)(a1 + 16))
  {
    do
    {
      uint64_t v6 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *((_DWORD *)v5 + 8);
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v19) = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d]   FMID: %u [", buf, 8u);
      }
      BOOL v8 = (void *)v5[5];
      id v9 = (void *)v5[6];
      while (v8 != v9)
      {
        __int16 v10 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v11 = v8[1];
          unint64_t v12 = *v8 / 0x3B9ACA00uLL;
          *(_DWORD *)long long buf = 134218240;
          unint64_t v19 = v12;
          __int16 v20 = 2048;
          unint64_t v21 = v11 / 0x3B9ACA00;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [d]     {%llu - %llu}", buf, 0x16u);
        }
        v8 += 2;
      }
      uint64_t v13 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [d]   ]", buf, 2u);
      }
      BOOL v14 = (void *)v5[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          BOOL v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v5[2];
          BOOL v16 = *v15 == (void)v5;
          uint64_t v5 = v15;
        }
        while (!v16);
      }
      uint64_t v5 = v15;
    }
    while (v15 != (void *)(a1 + 16));
  }
  uint64_t v17 = *a2;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] }", buf, 2u);
  }
}

uint64_t stewie::operator==(void *a1, uint64_t a2)
{
  if (a1[3] != *(void *)(a2 + 24)) {
    return 0;
  }
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = a1 + 2;
  if (v2 == a1 + 2) {
    return 1;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  do
  {
    uint64_t result = sub_100626D40((uint64_t)&v11, (uint64_t)(v2 + 4), (uint64_t)(v4 + 4));
    if (!result) {
      break;
    }
    uint64_t v6 = (void *)v2[1];
    int v7 = v2;
    if (v6)
    {
      do
      {
        uint64_t v2 = v6;
        uint64_t v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        uint64_t v2 = (void *)v7[2];
        BOOL v8 = *v2 == (void)v7;
        int v7 = v2;
      }
      while (!v8);
    }
    id v9 = (void *)v4[1];
    if (v9)
    {
      do
      {
        __int16 v10 = v9;
        id v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        __int16 v10 = (void *)v4[2];
        BOOL v8 = *v10 == (void)v4;
        uint64_t v4 = v10;
      }
      while (!v8);
    }
    uint64_t v4 = v10;
  }
  while (v2 != v3);
  return result;
}

uint64_t sub_100626C90(uint64_t a1)
{
  *(void *)a1 = off_1019F0728;
  sub_10026CF54(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void sub_100626CD8(uint64_t a1)
{
  *(void *)a1 = off_1019F0728;
  sub_10026CF54(a1 + 8, *(void **)(a1 + 16));

  operator delete();
}

uint64_t sub_100626D40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a2 != *(_DWORD *)a3) {
    return 0;
  }
  uint64_t v4 = *(char **)(a2 + 8);
  uint64_t v3 = *(char **)(a2 + 16);
  uint64_t v5 = *(void **)(a3 + 8);
  if (v3 - v4 != *(void *)(a3 + 16) - (void)v5) {
    return 0;
  }
  while (v4 != v3)
  {
    if (*(void *)v4 != *v5 || *((void *)v4 + 1) != v5[1]) {
      return 0;
    }
    v4 += 16;
    v5 += 2;
  }
  return 1;
}

uint64_t sub_100626DB4@<X0>(capabilities::ct *a1@<X0>, char a2@<W1>, void *a3@<X8>)
{
  if ((a2 & 1) != 0
    || (uint64_t v4 = (capabilities::ct *)capabilities::ct::supportsEMBMS(a1), (v4 & 1) != 0)
    || (uint64_t result = capabilities::ct::emulatedEMBMS(v4), (result & 1) != 0))
  {
    *a3 = 0;
    a3[1] = 0;
    operator new();
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void sub_1006270E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, dispatch_object_t object)
{
  if (object) {
    (*((void (**)(dispatch_object_t))object->isa + 1))(object);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_100627268(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "notifyServiceBootstrap";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: bootstrap 1...", buf, 0xCu);
  }
  uint64_t v5 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1006273E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1006273F0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "notifyServiceStart";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: start 1...", buf, 0xCu);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100627544(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100627554(void *a1, int a2, ServiceStage *this)
{
  dispatch_object_t object = 0;
  ServiceStage::holdOffStage((uint64_t *)&object, this);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_100627B08;
  v9[3] = &unk_1019F0840;
  v9[4] = a1;
  dispatch_group_t group = object;
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(group);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (uint64_t v5 = a1[1], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  BOOL v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10062B0E0;
  block[3] = &unk_1019F0A30;
  block[5] = v5;
  uint64_t v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
}

void sub_1006276C4(capabilities::ct *a1)
{
  if (capabilities::ct::emulatedEMBMS(a1))
  {
    sub_1006277A8((uint64_t)a1);
  }
  else
  {
    uint64_t v2 = *((void *)a1 + 10);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    }
  }
  uint64_t v3 = *((void *)a1 + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "startEMBMSController_sync";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController started", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1006277A8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 8), (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v5);
  Registry::getTimerService(&v18, *(Registry **)(a1 + 48));
  uint64_t v7 = v18;
  sub_100058DB0(__p, "EMBMS: SigInfo update");
  BOOL v8 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_100629A50;
  aBlock[3] = &unk_1019F0870;
  aBlock[4] = a1;
  aBlock[5] = v4;
  uint64_t v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  BOOL v14 = _Block_copy(aBlock);
  sub_100118A44(v7, (uint64_t)__p, 0, 15000000, &object, &v14);
  uint64_t v9 = v20;
  uint64_t v20 = 0;
  uint64_t v10 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    uint64_t v11 = v20;
    uint64_t v20 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
  }
  if (v14) {
    _Block_release(v14);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  std::__shared_weak_count::__release_weak(v6);
}

void sub_1006279A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v25 - 48);
  if (v27) {
    sub_10004D2C8(v27);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

EMBMSControllerInterface *sub_100627A0C(EMBMSControllerInterface *this)
{
  *(void *)this = off_1019F07C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4) {
    sub_10004D2C8(v4);
  }
  EMBMSControllerInterface::~EMBMSControllerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((EMBMSControllerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_100627AB4(EMBMSControllerInterface *a1)
{
  sub_100627A0C(a1);

  operator delete();
}

uint64_t sub_100627AEC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 88);
  *a2 = *(void *)(result + 80);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100627B08(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (v1)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 40));
    dispatch_group_enter(v1);
  }
  uint64_t v3 = v2[9];
  v2[9] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = v2[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v9 = "shutDownEMBMS";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Shutting down EMBMS...", buf, 0xCu);
  }
  uint64_t v5 = v2[10];
  if (v5)
  {
    dispatch_group_t group = v1;
    if (v1)
    {
      dispatch_retain(v1);
      dispatch_group_enter(v1);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v5 + 32))(v5, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  uint64_t v6 = v2[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v9 = "shutDownEMBMS";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: DataShutdown: Shutting down EMBMS: done", buf, 0xCu);
  }
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
}

void sub_100627CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100627D30(uint64_t a1, char a2)
{
  uint64_t result = capabilities::ct::emulatedEMBMS((capabilities::ct *)a1);
  if (result)
  {
    *(unsigned char *)(a1 + 64) = a2;
  }
  else
  {
    uint64_t result = *(void *)(a1 + 80);
    if (result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 40);
      return v5();
    }
  }
  return result;
}

void *sub_100627DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)&long long v24 = a1;
  *((void *)&v24 + 1) = v6;
  if (!v5 || (uint64_t v25 = std::__shared_weak_count::lock(v5)) == 0) {
    sub_100088B9C();
  }
  memset(v27, 0, sizeof(v27));
  sub_10062B11C((uint64_t)v26, a4);
  uint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v10 = off_1019F0A70;
  *(_OWORD *)(v10 + 8) = v24;
  *((void *)v10 + 3) = v25;
  *((void *)&v24 + 1) = 0;
  uint64_t v25 = 0;
  sub_10010DFA0((uint64_t)(v10 + 32), (uint64_t)v26);
  CFTypeRef v28 = v10;
  sub_10010E020(v26);
  if (!capabilities::ct::emulatedEMBMS(0))
  {
    uint64_t v11 = *(void *)(a1 + 80);
    if (!v11)
    {
      uint64_t v17 = 0;
      uint64_t v15 = *(void *)(a4 + 24);
      if (!v15) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v15 + 48))(v15, &v17);
      BOOL v14 = (const void **)&v17;
      goto LABEL_16;
    }
    uint64_t v12 = (uint64_t)v28;
    if (v28)
    {
      if (v28 == v27)
      {
        uint64_t v23 = v22;
        (*(void (**)(void *, void *))(v27[0] + 24))(v27, v22);
        goto LABEL_18;
      }
      uint64_t v12 = (*(uint64_t (**)(void *))(*v28 + 16))(v28);
    }
    uint64_t v23 = (void *)v12;
LABEL_18:
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v11 + 48))(v11, a2, a3, v22);
    sub_10062B5E0(v22);
    return sub_10062B5E0(v27);
  }
  if (!*(unsigned char *)(a1 + 64))
  {
    uint64_t v19 = 0;
    uint64_t v13 = *(void *)(a4 + 24);
    if (!v13) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v13 + 48))(v13, &v19);
    BOOL v14 = (const void **)&v19;
LABEL_16:
    sub_100057D78(v14);
    return sub_10062B5E0(v27);
  }
  memset(v18, 0, sizeof(v18));
  sub_100628150((uint64_t)v18, a2, a3);
  char v21 = 1;
  if (!v28) {
    sub_10007B600();
  }
  (*(void (**)(void *, char *, _OWORD *))(*v28 + 48))(v28, &v21, v18);
  uint64_t v20 = (void **)v18 + 1;
  sub_10062A480(&v20);
  return sub_10062B5E0(v27);
}

void sub_100628094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10062B5E0(va);
  sub_10062B5E0((void *)(v11 - 104));
  _Unwind_Resume(a1);
}

uint64_t sub_100628118(uint64_t a1)
{
  sub_10010E020((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100628150(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (int64x2_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v5 = operator new(8uLL);
  uint64_t v9 = 17;
  uint64_t v10 = v5;
  *uint64_t v5 = 0x301060504030201;
  uint64_t v11 = v5 + 1;
  uint64_t v12 = v5 + 1;
  *(void *)(a1 + 16) = sub_10062A50C(v4, (char *)&v9);
  operator delete(v5);
  uint64_t v9 = 13;
  uint64_t v6 = operator new(0x10uLL);
  *uint64_t v6 = xmmword_1014CD5E0;
  uint64_t v11 = v6 + 1;
  uint64_t v12 = v6 + 1;
  uint64_t v10 = v6;
  unint64_t v7 = *(void *)(a1 + 16);
  if (v7 >= *(void *)(a1 + 24))
  {
    uint64_t v8 = sub_10062A50C(v4, (char *)&v9);
  }
  else
  {
    *(unsigned char *)unint64_t v7 = 13;
    *(void *)(v7 + 16) = 0;
    *(void *)(v7 + 24) = 0;
    *(void *)(v7 + 8) = 0;
    sub_10062A688((void *)(v7 + 8), v6, (uint64_t)(v6 + 1), 2uLL);
    uint64_t v8 = v7 + 32;
    *(void *)(a1 + 16) = v7 + 32;
  }
  *(void *)(a1 + 16) = v8;

  operator delete(v6);
}

void sub_100628260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  operator delete(v9);
  sub_10062A480((void ***)&a9);
  _Unwind_Resume(a1);
}

void *sub_1006282A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)&long long v26 = a1;
  *((void *)&v26 + 1) = v5;
  if (!v4 || (uint64_t v27 = std::__shared_weak_count::lock(v4)) == 0) {
    sub_100088B9C();
  }
  long long v29 = 0u;
  long long v30 = 0u;
  sub_10062B11C((uint64_t)v28, a3);
  *((void *)&v30 + 1) = 0;
  uint64_t v8 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v8 = off_1019F0B00;
  *(_OWORD *)(v8 + 8) = v26;
  *((void *)v8 + 3) = v27;
  *((void *)&v26 + 1) = 0;
  uint64_t v27 = 0;
  sub_10010DFA0((uint64_t)(v8 + 32), (uint64_t)v28);
  *((void *)&v30 + 1) = v8;
  sub_10010E020(v28);
  if (!capabilities::ct::emulatedEMBMS(0))
  {
    uint64_t v9 = *(void *)(a1 + 80);
    if (!v9)
    {
      uint64_t v15 = 0;
      uint64_t v13 = *(void *)(a3 + 24);
      if (!v13) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v13 + 48))(v13, &v15);
      uint64_t v12 = (const void **)&v15;
      goto LABEL_22;
    }
    uint64_t v10 = *((void *)&v30 + 1);
    if (*((void *)&v30 + 1))
    {
      if (*((long long **)&v30 + 1) == &v29)
      {
        uint64_t v25 = v24;
        (*(void (**)(long long *, void *))(v29 + 24))(&v29, v24);
        goto LABEL_24;
      }
      uint64_t v10 = (*(uint64_t (**)(void))(**((void **)&v30 + 1) + 16))(*((void *)&v30 + 1));
    }
    uint64_t v25 = (void *)v10;
LABEL_24:
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v9 + 64))(v9, a2, v24);
    sub_10062BA44(v24);
    return sub_10062BA44(&v29);
  }
  if (!*(unsigned char *)(a1 + 64))
  {
    uint64_t v22 = 0;
    uint64_t v11 = *(void *)(a3 + 24);
    if (!v11) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 48))(v11, &v22);
    uint64_t v12 = (const void **)&v22;
LABEL_22:
    sub_100057D78(v12);
    return sub_10062BA44(&v29);
  }
  *(_OWORD *)long long __p = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  *(_OWORD *)uint64_t v19 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_100628634((uint64_t)v16, a2);
  LOBYTE(v23) = 1;
  if (!*((void *)&v30 + 1)) {
    sub_10007B600();
  }
  (*(void (**)(void, void ***, _OWORD *))(**((void **)&v30 + 1) + 48))(*((void *)&v30 + 1), &v23, v16);
  if (__p[1])
  {
    *(void **)&long long v21 = __p[1];
    operator delete(__p[1]);
  }
  if (v19[0])
  {
    v19[1] = v19[0];
    operator delete(v19[0]);
  }
  if (v17[0])
  {
    v17[1] = v17[0];
    operator delete(v17[0]);
  }
  uint64_t v23 = (void **)v16 + 1;
  sub_10062A480(&v23);
  return sub_10062BA44(&v29);
}

void sub_1006285BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  sub_10062BA44(&a27);
  sub_10062BA44((void *)(v27 - 112));
  _Unwind_Resume(a1);
}

void sub_100628634(uint64_t a1, int a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v3 = (void **)(a1 + 32);
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = (int64x2_t *)(a1 + 8);
  *(_OWORD *)(a1 + 64) = 0u;
  uint64_t v5 = (void **)(a1 + 64);
  *(_DWORD *)a1 = a2;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_WORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  uint64_t v6 = operator new(0x12uLL);
  v122[2] = v6 + 9;
  v122[3] = v6 + 9;
  v6[8] = 9;
  *(_OWORD *)uint64_t v6 = xmmword_1014CD5F0;
  v122[1] = v6;
  v121[0] = 25;
  unint64_t v7 = operator new(0x12uLL);
  v121[3] = v7 + 9;
  v122[0] = 15;
  v7[8] = 9;
  *(_OWORD *)unint64_t v7 = xmmword_1014CD602;
  v121[1] = v7;
  v121[2] = v7 + 9;
  unint64_t v8 = sub_10062A790(v4, (uint64_t)v122);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = v8;
  if (v8 >= v10)
  {
    uint64_t v11 = sub_10062A790(v4, (uint64_t)v121);
  }
  else
  {
    *(_DWORD *)unint64_t v8 = 25;
    *(void *)(v8 + 16) = 0;
    *(void *)(v8 + 24) = 0;
    *(void *)(v8 + 8) = 0;
    sub_1003A10E0((void *)(v8 + 8), v7, (uint64_t)(v7 + 9), 9);
    uint64_t v11 = v9 + 32;
    *(void *)(a1 + 16) = v9 + 32;
  }
  *(void *)(a1 + 16) = v11;
  operator delete(v7);
  operator delete(v6);
  uint64_t v13 = (char **)(a1 + 48);
  uint64_t v12 = *(char **)(a1 + 48);
  BOOL v14 = *(char **)(a1 + 40);
  if (v14 >= v12)
  {
    BOOL v16 = (char *)*v3;
    uint64_t v17 = v14 - (unsigned char *)*v3;
    if (v17 <= -3) {
      sub_10006A748();
    }
    uint64_t v18 = v17 >> 1;
    unint64_t v19 = v12 - v16;
    if (v19 <= (v17 >> 1) + 1) {
      unint64_t v20 = v18 + 1;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v19 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v21 = v20;
    }
    if (v21)
    {
      uint64_t v22 = (char *)sub_10006E5B8(a1 + 48, v21);
      BOOL v16 = *(char **)(a1 + 32);
      BOOL v14 = *(char **)(a1 + 40);
    }
    else
    {
      uint64_t v22 = 0;
    }
    uint64_t v23 = &v22[2 * v18];
    uint64_t v12 = &v22[2 * v21];
    *(_WORD *)uint64_t v23 = 77;
    uint64_t v15 = v23 + 2;
    while (v14 != v16)
    {
      __int16 v24 = *((_WORD *)v14 - 1);
      v14 -= 2;
      *((_WORD *)v23 - 1) = v24;
      v23 -= 2;
    }
    *(void *)(a1 + 32) = v23;
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v15;
    *(void *)(a1 + 48) = v12;
    if (v16)
    {
      operator delete(v16);
      uint64_t v12 = *v13;
    }
  }
  else
  {
    *(_WORD *)BOOL v14 = 77;
    uint64_t v15 = v14 + 2;
  }
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v15;
  if (v15 >= v12)
  {
    long long v26 = (char *)*v3;
    uint64_t v27 = v15 - (unsigned char *)*v3;
    if (v27 <= -3) {
      sub_10006A748();
    }
    uint64_t v28 = v27 >> 1;
    unint64_t v29 = v12 - v26;
    if (v29 <= (v27 >> 1) + 1) {
      unint64_t v30 = v28 + 1;
    }
    else {
      unint64_t v30 = v29;
    }
    if (v29 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v31 = v30;
    }
    if (v31)
    {
      __int16 v32 = (char *)sub_10006E5B8(a1 + 48, v31);
      long long v26 = *(char **)(a1 + 32);
      uint64_t v15 = *(char **)(a1 + 40);
    }
    else
    {
      __int16 v32 = 0;
    }
    uint64_t v33 = &v32[2 * v28];
    uint64_t v12 = &v32[2 * v31];
    *(_WORD *)uint64_t v33 = 88;
    uint64_t v25 = v33 + 2;
    while (v15 != v26)
    {
      __int16 v34 = *((_WORD *)v15 - 1);
      v15 -= 2;
      *((_WORD *)v33 - 1) = v34;
      v33 -= 2;
    }
    *(void *)(a1 + 32) = v33;
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v25;
    *(void *)(a1 + 48) = v12;
    if (v26)
    {
      operator delete(v26);
      uint64_t v12 = *v13;
    }
  }
  else
  {
    *(_WORD *)uint64_t v15 = 88;
    uint64_t v25 = v15 + 2;
  }
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v25;
  if (v25 >= v12)
  {
    long long v36 = (char *)*v3;
    uint64_t v37 = v25 - (unsigned char *)*v3;
    if (v37 <= -3) {
      sub_10006A748();
    }
    uint64_t v38 = v37 >> 1;
    unint64_t v39 = v12 - v36;
    if (v39 <= (v37 >> 1) + 1) {
      unint64_t v40 = v38 + 1;
    }
    else {
      unint64_t v40 = v39;
    }
    if (v39 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v41 = v40;
    }
    if (v41)
    {
      uint64_t v42 = (char *)sub_10006E5B8(a1 + 48, v41);
      long long v36 = *(char **)(a1 + 32);
      uint64_t v25 = *(char **)(a1 + 40);
    }
    else
    {
      uint64_t v42 = 0;
    }
    uint64_t v43 = &v42[2 * v38];
    char v44 = &v42[2 * v41];
    *(_WORD *)uint64_t v43 = 99;
    uint64_t v35 = v43 + 2;
    while (v25 != v36)
    {
      __int16 v45 = *((_WORD *)v25 - 1);
      v25 -= 2;
      *((_WORD *)v43 - 1) = v45;
      v43 -= 2;
    }
    *(void *)(a1 + 32) = v43;
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v35;
    *(void *)(a1 + 48) = v44;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *(_WORD *)uint64_t v25 = 99;
    uint64_t v35 = v25 + 2;
  }
  uint64_t v47 = (char **)(a1 + 80);
  CFTypeRef v46 = *(char **)(a1 + 80);
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v35;
  *(_WORD *)(a1 + 56) = 257;
  v48 = *(char **)(a1 + 72);
  if (v48 >= v46)
  {
    char v50 = (char *)*v5;
    uint64_t v51 = (v48 - (unsigned char *)*v5) >> 2;
    unint64_t v52 = v51 + 1;
    if ((unint64_t)(v51 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v53 = v46 - v50;
    if (v53 >> 1 > v52) {
      unint64_t v52 = v53 >> 1;
    }
    if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v54 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v54 = v52;
    }
    if (v54)
    {
      uint64_t v55 = (char *)sub_10005ECD8(a1 + 80, v54);
      char v50 = *(char **)(a1 + 64);
      v48 = *(char **)(a1 + 72);
    }
    else
    {
      uint64_t v55 = 0;
    }
    uint64_t v56 = &v55[4 * v51];
    CFTypeRef v46 = &v55[4 * v54];
    *(_DWORD *)uint64_t v56 = 33;
    uint64_t v49 = v56 + 4;
    while (v48 != v50)
    {
      int v57 = *((_DWORD *)v48 - 1);
      v48 -= 4;
      *((_DWORD *)v56 - 1) = v57;
      v56 -= 4;
    }
    *(void *)(a1 + 64) = v56;
    *(void *)(a1 + 72) = v49;
    *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = v46;
    if (v50)
    {
      operator delete(v50);
      CFTypeRef v46 = *v47;
    }
  }
  else
  {
    *(_DWORD *)v48 = 33;
    uint64_t v49 = v48 + 4;
  }
  *(void *)(a1 + 72) = v49;
  if (v49 >= v46)
  {
    uint64_t v59 = (char *)*v5;
    uint64_t v60 = (v49 - (unsigned char *)*v5) >> 2;
    unint64_t v61 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v62 = v46 - v59;
    if (v62 >> 1 > v61) {
      unint64_t v61 = v62 >> 1;
    }
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v63 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v63 = v61;
    }
    if (v63)
    {
      uint64_t v64 = (char *)sub_10005ECD8(a1 + 80, v63);
      uint64_t v59 = *(char **)(a1 + 64);
      uint64_t v49 = *(char **)(a1 + 72);
    }
    else
    {
      uint64_t v64 = 0;
    }
    uint64_t v65 = &v64[4 * v60];
    CFTypeRef v46 = &v64[4 * v63];
    *(_DWORD *)uint64_t v65 = 44;
    uint64_t v58 = v65 + 4;
    while (v49 != v59)
    {
      int v66 = *((_DWORD *)v49 - 1);
      v49 -= 4;
      *((_DWORD *)v65 - 1) = v66;
      v65 -= 4;
    }
    *(void *)(a1 + 64) = v65;
    *(void *)(a1 + 72) = v58;
    *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = v46;
    if (v59)
    {
      operator delete(v59);
      CFTypeRef v46 = *v47;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v49 = 44;
    uint64_t v58 = v49 + 4;
  }
  *(void *)(a1 + 72) = v58;
  if (v58 >= v46)
  {
    uint64_t v68 = (char *)*v5;
    uint64_t v69 = (v58 - (unsigned char *)*v5) >> 2;
    unint64_t v70 = v69 + 1;
    if ((unint64_t)(v69 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v71 = v46 - v68;
    if (v71 >> 1 > v70) {
      unint64_t v70 = v71 >> 1;
    }
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v72 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v72 = v70;
    }
    if (v72)
    {
      long long v73 = (char *)sub_10005ECD8(a1 + 80, v72);
      uint64_t v68 = *(char **)(a1 + 64);
      uint64_t v58 = *(char **)(a1 + 72);
    }
    else
    {
      long long v73 = 0;
    }
    long long v74 = &v73[4 * v69];
    CFTypeRef v46 = &v73[4 * v72];
    *(_DWORD *)long long v74 = 55;
    std::string::size_type v67 = v74 + 4;
    while (v58 != v68)
    {
      int v75 = *((_DWORD *)v58 - 1);
      v58 -= 4;
      *((_DWORD *)v74 - 1) = v75;
      v74 -= 4;
    }
    *(void *)(a1 + 64) = v74;
    *(void *)(a1 + 72) = v67;
    *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = v46;
    if (v68)
    {
      operator delete(v68);
      CFTypeRef v46 = *v47;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v58 = 55;
    std::string::size_type v67 = v58 + 4;
  }
  *(void *)(a1 + 72) = v67;
  if (v67 >= v46)
  {
    long long v77 = (char *)*v5;
    uint64_t v78 = (v67 - (unsigned char *)*v5) >> 2;
    unint64_t v79 = v78 + 1;
    if ((unint64_t)(v78 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v80 = v46 - v77;
    if (v80 >> 1 > v79) {
      unint64_t v79 = v80 >> 1;
    }
    if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v81 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v81 = v79;
    }
    if (v81)
    {
      uint64_t v82 = (char *)sub_10005ECD8(a1 + 80, v81);
      long long v77 = *(char **)(a1 + 64);
      std::string::size_type v67 = *(char **)(a1 + 72);
    }
    else
    {
      uint64_t v82 = 0;
    }
    double v83 = &v82[4 * v78];
    double v84 = &v82[4 * v81];
    *(_DWORD *)double v83 = 66;
    long long v76 = v83 + 4;
    while (v67 != v77)
    {
      int v85 = *((_DWORD *)v67 - 1);
      v67 -= 4;
      *((_DWORD *)v83 - 1) = v85;
      v83 -= 4;
    }
    *(void *)(a1 + 64) = v83;
    *(void *)(a1 + 72) = v76;
    *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = v84;
    if (v77) {
      operator delete(v77);
    }
  }
  else
  {
    *(_DWORD *)std::string::size_type v67 = 66;
    long long v76 = v67 + 4;
  }
  double v86 = (void **)(a1 + 88);
  double v88 = (char **)(a1 + 104);
  double v87 = *(char **)(a1 + 104);
  *(void *)(a1 + 72) = v76;
  long double v89 = *(char **)(a1 + 96);
  if (v89 >= v87)
  {
    __double2 v91 = (char *)*v86;
    uint64_t v92 = v89 - (unsigned char *)*v86;
    if (v92 <= -3) {
      sub_10006A748();
    }
    uint64_t v93 = v92 >> 1;
    unint64_t v94 = v87 - v91;
    if (v94 <= (v92 >> 1) + 1) {
      unint64_t v95 = v93 + 1;
    }
    else {
      unint64_t v95 = v94;
    }
    if (v94 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v96 = v95;
    }
    if (v96)
    {
      std::string::size_type v97 = (char *)sub_10006E5B8(a1 + 104, v96);
      __double2 v91 = *(char **)(a1 + 88);
      long double v89 = *(char **)(a1 + 96);
    }
    else
    {
      std::string::size_type v97 = 0;
    }
    std::string::size_type v98 = &v97[2 * v93];
    double v87 = &v97[2 * v96];
    *(_WORD *)std::string::size_type v98 = 12;
    __double2 v90 = v98 + 2;
    while (v89 != v91)
    {
      __int16 v99 = *((_WORD *)v89 - 1);
      v89 -= 2;
      *((_WORD *)v98 - 1) = v99;
      v98 -= 2;
    }
    *(void *)(a1 + 88) = v98;
    *(void *)(a1 + 96) = v90;
    *(void *)(a1 + 104) = v87;
    if (v91)
    {
      operator delete(v91);
      double v87 = *v88;
    }
  }
  else
  {
    *(_WORD *)long double v89 = 12;
    __double2 v90 = v89 + 2;
  }
  *(void *)(a1 + 96) = v90;
  if (v90 >= v87)
  {
    double v101 = (char *)*v86;
    uint64_t v102 = v90 - (unsigned char *)*v86;
    if (v102 <= -3) {
      sub_10006A748();
    }
    uint64_t v103 = v102 >> 1;
    unint64_t v104 = v87 - v101;
    if (v104 <= (v102 >> 1) + 1) {
      unint64_t v105 = v103 + 1;
    }
    else {
      unint64_t v105 = v104;
    }
    if (v104 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v106 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v106 = v105;
    }
    if (v106)
    {
      long long v107 = (char *)sub_10006E5B8(a1 + 104, v106);
      double v101 = *(char **)(a1 + 88);
      __double2 v90 = *(char **)(a1 + 96);
    }
    else
    {
      long long v107 = 0;
    }
    long long v108 = &v107[2 * v103];
    double v87 = &v107[2 * v106];
    *(_WORD *)long long v108 = 13;
    long long v100 = v108 + 2;
    while (v90 != v101)
    {
      __int16 v109 = *((_WORD *)v90 - 1);
      v90 -= 2;
      *((_WORD *)v108 - 1) = v109;
      v108 -= 2;
    }
    *(void *)(a1 + 88) = v108;
    *(void *)(a1 + 96) = v100;
    *(void *)(a1 + 104) = v87;
    if (v101)
    {
      operator delete(v101);
      double v87 = *v88;
    }
  }
  else
  {
    *(_WORD *)__double2 v90 = 13;
    long long v100 = v90 + 2;
  }
  *(void *)(a1 + 96) = v100;
  if (v100 >= v87)
  {
    long long v111 = (char *)*v86;
    uint64_t v112 = v100 - (unsigned char *)*v86;
    if (v112 <= -3) {
      sub_10006A748();
    }
    uint64_t v113 = v112 >> 1;
    unint64_t v114 = v87 - v111;
    if (v114 <= (v112 >> 1) + 1) {
      unint64_t v115 = v113 + 1;
    }
    else {
      unint64_t v115 = v114;
    }
    if (v114 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v116 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v116 = v115;
    }
    if (v116)
    {
      long long v117 = (char *)sub_10006E5B8(a1 + 104, v116);
      long long v111 = *(char **)(a1 + 88);
      long long v100 = *(char **)(a1 + 96);
    }
    else
    {
      long long v117 = 0;
    }
    std::string::size_type v118 = &v117[2 * v113];
    v119 = &v117[2 * v116];
    *(_WORD *)std::string::size_type v118 = 14;
    long long v110 = v118 + 2;
    while (v100 != v111)
    {
      __int16 v120 = *((_WORD *)v100 - 1);
      v100 -= 2;
      *((_WORD *)v118 - 1) = v120;
      v118 -= 2;
    }
    *(void *)(a1 + 88) = v118;
    *(void *)(a1 + 96) = v110;
    *(void *)(a1 + 104) = v119;
    if (v111) {
      operator delete(v111);
    }
  }
  else
  {
    *(_WORD *)long long v100 = 14;
    long long v110 = v100 + 2;
  }
  *(void *)(a1 + 96) = v110;
}

void sub_100628EC0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v4;
  operator delete(v3);
  operator delete(v2);
  sub_100628F28(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100628F28(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 72) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v4;
    operator delete(v4);
  }
  uint64_t v6 = (void **)(a1 + 8);
  sub_10062A480(&v6);
  return a1;
}

void sub_100628F94(uint64_t a1, const void **a2, uint64_t a3)
{
  if (capabilities::ct::emulatedEMBMS((capabilities::ct *)a1))
  {
    if (*(unsigned char *)(a1 + 64))
    {
      uint64_t v6 = a3;
      char v7 = 1;
LABEL_11:
      sub_1000607A8(v6, v7);
      return;
    }
LABEL_10:
    uint64_t v6 = a3;
    char v7 = 0;
    goto LABEL_11;
  }
  if (!*(void *)(a1 + 80)) {
    goto LABEL_10;
  }
  uint64_t v13 = 0;
  long long v11 = 0u;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)unint64_t v10 = 0u;
  sub_100058198(&v9, a2);
  sub_100057D78(&v9);
  uint64_t v8 = *(void *)(a1 + 80);
  sub_1000DFC90((uint64_t)v14, a3);
  (*(void (**)(uint64_t, void **, void *))(*(void *)v8 + 72))(v8, v10, v14);
  sub_100060644(v14);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v10[1])
  {
    *(void **)&long long v11 = v10[1];
    operator delete(v10[1]);
  }
}

void sub_100629104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_100060644((uint64_t *)va1);
  sub_10049E260((uint64_t *)va);
  _Unwind_Resume(a1);
}

const void **sub_100629128(void *a1, uint64_t a2)
{
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFNumberRef v33 = v5;
    sub_10005717C((const void **)&v33);
  }
  int valuePtr = *(_DWORD *)(a2 + 4);
  CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(theDict, @"kCFEMBMSServiceType", v30);
  CFNumberRef v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (const void *)a2);
  CFDictionarySetValue(theDict, @"kCFEMBMSEarfcn", v29);
  uint64_t v28 = 0;
  CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v21 = a1;
  if (v6)
  {
    CFNumberRef v7 = (const __CFNumber *)v28;
    uint64_t v28 = v6;
    CFNumberRef v33 = v7;
    sub_1000440D4((const void **)&v33);
  }
  uint64_t v8 = *(void **)(a2 + 8);
  for (uint64_t i = *(void **)(a2 + 16); v8 != i; v8 += 4)
  {
    CFMutableDictionaryRef v27 = 0;
    uint64_t v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v9)
    {
      CFMutableDictionaryRef v10 = v27;
      CFMutableDictionaryRef v27 = v9;
      CFNumberRef v33 = v10;
      sub_10005717C((const void **)&v33);
    }
    CFNumberRef v26 = 0;
    CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, v8);
    CFDictionarySetValue(v27, @"kCFEMBMSAreaId", v26);
    value = 0;
    CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v11)
    {
      CFNumberRef v12 = (const __CFNumber *)value;
      value = v11;
      CFNumberRef v33 = v12;
      sub_1000440D4((const void **)&v33);
    }
    uint64_t v13 = v8[1];
    uint64_t v14 = v8[2];
    while (v13 != v14)
    {
      CFMutableDictionaryRef v24 = 0;
      uint64_t v15 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v15)
      {
        CFMutableDictionaryRef v16 = v24;
        CFMutableDictionaryRef v24 = v15;
        CFNumberRef v33 = v16;
        sub_10005717C((const void **)&v33);
      }
      if (*(unsigned char *)(v13 + 6))
      {
        CFNumberRef v33 = 0;
        CFNumberRef v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(v13 + 7));
        CFDictionarySetValue(v24, @"kCFEMBMSSigInfoAreaTMGISessionId", v33);
        sub_1000570E8((const void **)&v33);
      }
      CFMutableArrayRef theArray = 0;
      uint64_t v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v17)
      {
        CFMutableArrayRef v18 = theArray;
        CFMutableArrayRef theArray = v17;
        CFNumberRef v33 = v18;
        sub_1000440D4((const void **)&v33);
      }
      for (uint64_t j = 0; j != 6; ++j)
      {
        CFNumberRef v33 = 0;
        CFNumberRef v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, (const void *)(v13 + j));
        CFArrayAppendValue(theArray, v33);
        sub_1000570E8((const void **)&v33);
      }
      CFDictionarySetValue(v24, @"kCFEMBMSSigInfoAreaTMGIId", theArray);
      CFArrayAppendValue((CFMutableArrayRef)value, v24);
      sub_1000440D4((const void **)&theArray);
      sub_10005717C((const void **)&v24);
      v13 += 8;
    }
    CFDictionarySetValue(v27, @"kCFEMBMSSigInfoAreaTMGIS", value);
    CFArrayAppendValue((CFMutableArrayRef)v28, v27);
    sub_1000440D4((const void **)&value);
    sub_1000570E8((const void **)&v26);
    sub_10005717C((const void **)&v27);
  }
  CFDictionarySetValue(theDict, @"kCFEMBMSSigInfoAreas", v28);
  sub_10004EFE4(v21, (CFTypeRef *)&theDict);
  sub_1000440D4((const void **)&v28);
  sub_1000570E8((const void **)&v29);
  sub_1000570E8((const void **)&v30);
  return sub_10005717C((const void **)&theDict);
}

void sub_100629498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  CFMutableArrayRef v11 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, const void *);
  uint64_t v15 = va_arg(va2, void);
  sub_1000570E8((const void **)va);
  sub_1000570E8((const void **)va1);
  sub_10005717C((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_100629560(void *a1, int *a2)
{
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v4 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFNumberRef v38 = v4;
    sub_10005717C((const void **)&v38);
  }
  int valuePtr = *a2;
  CFNumberRef v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(theDict, @"kCFEMBMSSAIType", v35);
  if (*((unsigned char *)a2 + 57))
  {
    CFMutableDictionaryRef v5 = (const void **)&kCFBooleanTrue;
    if (!*((unsigned char *)a2 + 56)) {
      CFMutableDictionaryRef v5 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(theDict, @"kCFEMBMSPriorityFlag", *v5);
  }
  value = 0;
  CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v6)
  {
    CFNumberRef v7 = (const __CFNumber *)value;
    value = v6;
    CFNumberRef v38 = v7;
    sub_1000440D4((const void **)&v38);
  }
  CFNumberRef v30 = a2;
  uint64_t v9 = (void *)*((void *)a2 + 1);
  for (uint64_t i = (void *)*((void *)a2 + 2); v9 != i; v9 += 4)
  {
    CFMutableDictionaryRef v33 = 0;
    CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v10)
    {
      CFMutableDictionaryRef v11 = v33;
      CFMutableDictionaryRef v33 = v10;
      CFNumberRef v38 = v11;
      sub_10005717C((const void **)&v38);
    }
    CFNumberRef v32 = 0;
    CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v9);
    CFDictionarySetValue(v33, @"kCFEMBMSDLCarrierFreq", v32);
    CFMutableArrayRef theArray = 0;
    CFNumberRef v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v12)
    {
      CFMutableArrayRef v13 = theArray;
      CFMutableArrayRef theArray = v12;
      CFNumberRef v38 = v13;
      sub_1000440D4((const void **)&v38);
    }
    uint64_t v15 = (char *)v9[1];
    uint64_t v14 = (char *)v9[2];
    while (v15 != v14)
    {
      CFNumberRef v38 = 0;
      CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, v15);
      CFArrayAppendValue(theArray, v38);
      sub_1000570E8((const void **)&v38);
      v15 += 2;
    }
    CFDictionarySetValue(v33, @"kCFEMBMSSAIList", theArray);
    CFArrayAppendValue((CFMutableArrayRef)value, v33);
    sub_1000440D4((const void **)&theArray);
    sub_1000570E8((const void **)&v32);
    sub_10005717C((const void **)&v33);
  }
  CFDictionarySetValue(theDict, @"kCFEMBMSInterFreqInfoArray", value);
  sub_1000440D4((const void **)&value);
  value = 0;
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v16)
  {
    CFNumberRef v17 = (const __CFNumber *)value;
    value = v16;
    CFNumberRef v38 = v17;
    sub_1000440D4((const void **)&v38);
  }
  unint64_t v19 = (char *)v30[4];
  CFMutableArrayRef v18 = (char *)v30[5];
  while (v19 != v18)
  {
    CFNumberRef v38 = 0;
    CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, v19);
    CFArrayAppendValue((CFMutableArrayRef)value, v38);
    sub_1000570E8((const void **)&v38);
    v19 += 2;
  }
  CFDictionarySetValue(theDict, @"kCFEMBMSSAIList", value);
  sub_1000440D4((const void **)&value);
  value = 0;
  CFMutableArrayRef v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v20)
  {
    CFNumberRef v21 = (const __CFNumber *)value;
    value = v20;
    CFNumberRef v38 = v21;
    sub_1000440D4((const void **)&v38);
  }
  uint64_t v23 = (char *)v30[11];
  uint64_t v22 = (char *)v30[12];
  while (v23 != v22)
  {
    CFNumberRef v38 = 0;
    CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, v23);
    CFArrayAppendValue((CFMutableArrayRef)value, v38);
    sub_1000570E8((const void **)&v38);
    v23 += 2;
  }
  CFDictionarySetValue(theDict, @"kCFEMBMSInterestedSAIList", value);
  sub_1000440D4((const void **)&value);
  value = 0;
  CFMutableArrayRef v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (v24)
  {
    CFNumberRef v25 = (const __CFNumber *)value;
    value = v24;
    CFNumberRef v38 = v25;
    sub_1000440D4((const void **)&v38);
  }
  CFMutableDictionaryRef v27 = (char *)v30[8];
  CFNumberRef v26 = (char *)v30[9];
  while (v27 != v26)
  {
    CFNumberRef v38 = 0;
    CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v27);
    CFArrayAppendValue((CFMutableArrayRef)value, v38);
    sub_1000570E8((const void **)&v38);
    v27 += 4;
  }
  CFDictionarySetValue(theDict, @"kCFEMBMSInterestedEarfcnList", value);
  sub_1000440D4((const void **)&value);
  sub_10004EFE4(a1, (CFTypeRef *)&theDict);
  sub_1000570E8((const void **)&v35);
  return sub_10005717C((const void **)&theDict);
}

void sub_1006299A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100629A50(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (unsigned char *)a1[4];
    CFMutableDictionaryRef v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFMutableDictionaryRef v5 = v4;
      if (a1[5])
      {
        CFMutableArrayRef v6 = *((void *)v3 + 5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v8[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I EMBMS: SigInfo update timer fired", (uint8_t *)v8, 2u);
        }
        if (v3[64])
        {
          memset(v14, 0, sizeof(v14));
          sub_100628150((uint64_t)v14, 0, 37);
          (*(void (**)(unsigned char *, _OWORD *))(*(void *)v3 + 56))(v3, v14);
          *(_OWORD *)long long __p = 0u;
          long long v13 = 0u;
          long long v10 = 0u;
          *(_OWORD *)CFMutableDictionaryRef v11 = 0u;
          *(_OWORD *)uint64_t v9 = 0u;
          memset(v8, 0, sizeof(v8));
          sub_100628634((uint64_t)v8, 1);
          (*(void (**)(unsigned char *, _OWORD *))(*(void *)v3 + 64))(v3, v8);
          (*(void (**)(unsigned char *, uint64_t, uint64_t))(*(void *)v3 + 48))(v3, 33, 2);
          if (__p[1])
          {
            *(void **)&long long v13 = __p[1];
            operator delete(__p[1]);
          }
          if (v11[0])
          {
            v11[1] = v11[0];
            operator delete(v11[0]);
          }
          if (v9[0])
          {
            v9[1] = v9[0];
            operator delete(v9[0]);
          }
          uint64_t v15 = (void **)v8 + 1;
          sub_10062A480(&v15);
          *(void *)&v8[0] = (char *)v14 + 8;
          sub_10062A480((void ***)v8);
          BOOL v7 = v3[64] != 0;
        }
        else
        {
          BOOL v7 = 0;
        }
        (*(void (**)(unsigned char *, BOOL))(*(void *)v3 + 40))(v3, v7);
        sub_1006277A8(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100629C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  a9 = (void **)((v10 - 80) | 8);
  sub_10062A480(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_100629C94(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100629CB0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100629CC0(uint64_t a1)
{
  if (capabilities::ct::emulatedEMBMS((capabilities::ct *)a1)) {
    return *(unsigned char *)(a1 + 64) != 0;
  }
  uint64_t result = *(void *)(a1 + 80);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v3();
  }
  return result;
}

void sub_100629D3C(uint64_t a1, BOOL a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v12 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v12 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v12 = v5;
LABEL_9:
  xpc_release(v4);
  xpc_object_t v10 = xpc_BOOL_create(a2);
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  v9[0] = &v12;
  v9[1] = "kEMBMSStatus";
  sub_100035E70((uint64_t)v9, &v10, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_object_t v6 = v12;
  v9[0] = v12;
  if (v12)
  {
    xpc_retain(v12);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    v9[0] = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  xpc_object_t v8 = v7;
  sub_1000452AC(171, v9, &v8);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(v12);
}

void sub_100629E90(_Unwind_Exception *a1)
{
  xpc_object_t v4 = v2;
  xpc_release(v4);
  xpc_release(v1);
  xpc_release(*(xpc_object_t *)(v3 - 24));
  _Unwind_Resume(a1);
}

void sub_100629EE4(uint64_t a1, unsigned int a2, unsigned int a3)
{
  CFNumberRef v17 = 0;
  xpc_object_t v5 = (xpc_object_t *)xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    CFNumberRef v17 = v5;
  }
  else
  {
    xpc_object_t v6 = (xpc_object_t *)xpc_null_create();
    CFNumberRef v17 = v6;
    if (!v6)
    {
      xpc_object_t v7 = (xpc_object_t *)xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = (xpc_object_t *)xpc_null_create();
LABEL_8:
  CFNumberRef v17 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v15 = xpc_int64_create(a2);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  long long v13 = (xpc_object_t *)&v17;
  uint64_t v14 = "kEMBMSEarfcnServiceLoss";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v11 = xpc_int64_create(a3);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  long long v13 = (xpc_object_t *)&v17;
  uint64_t v14 = "kEMBMSEarfcnServiceLossReason";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v8 = v17;
  long long v13 = v17;
  if (v17)
  {
    xpc_retain(v17);
  }
  else
  {
    xpc_object_t v8 = (xpc_object_t *)xpc_null_create();
    long long v13 = v8;
  }
  xpc_object_t v9 = xpc_null_create();
  xpc_object_t v10 = v9;
  sub_1000452AC(171, (xpc_object_t *)&v13, &v10);
  xpc_release(v9);
  xpc_release(v8);
  xpc_release(v17);
}

void sub_10062A09C(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  xpc_release(*(xpc_object_t *)(v3 - 40));
  _Unwind_Resume(a1);
}

void sub_10062A0F8(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v14 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v14 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v5;
LABEL_9:
  xpc_release(v4);
  long long v13 = 0;
  sub_100629128(&v13, a2);
  ctu::cf_to_xpc((uint64_t *)&v11, v13, v6);
  v10[0] = &v14;
  v10[1] = "kEMBMSSigInfo";
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v14;
  v10[0] = v14;
  if (v14)
  {
    xpc_retain(v14);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(171, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  sub_100057D78((const void **)&v13);
  xpc_release(v14);
}

void sub_10062A254(_Unwind_Exception *a1)
{
  xpc_object_t v4 = v2;
  xpc_release(v4);
  xpc_release(v1);
  sub_100057D78((const void **)(v3 - 32));
  xpc_release(*(xpc_object_t *)(v3 - 24));
  _Unwind_Resume(a1);
}

void sub_10062A2BC(uint64_t a1, int *a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v14 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v14 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v5;
LABEL_9:
  xpc_release(v4);
  long long v13 = 0;
  sub_100629560(&v13, a2);
  ctu::cf_to_xpc((uint64_t *)&v11, v13, v6);
  v10[0] = &v14;
  v10[1] = "kEMBMSSAIListInfo";
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v14;
  v10[0] = v14;
  if (v14)
  {
    xpc_retain(v14);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(171, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  sub_100057D78((const void **)&v13);
  xpc_release(v14);
}

void sub_10062A418(_Unwind_Exception *a1)
{
  xpc_object_t v4 = v2;
  xpc_release(v4);
  xpc_release(v1);
  sub_100057D78((const void **)(v3 - 32));
  xpc_release(*(xpc_object_t *)(v3 - 24));
  _Unwind_Resume(a1);
}

void sub_10062A480(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    xpc_object_t v4 = (char *)v1[1];
    xpc_object_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        xpc_object_t v6 = (void *)*((void *)v4 - 3);
        if (v6)
        {
          *((void *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      xpc_object_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10062A50C(int64x2_t *a1, char *a2)
{
  uint64_t v2 = (a1->i64[1] - a1->i64[0]) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    sub_10006A748();
  }
  uint64_t v6 = a1[1].i64[0] - a1->i64[0];
  if (v6 >> 4 > v3) {
    unint64_t v3 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v23 = a1 + 1;
  if (v7)
  {
    if (v7 >> 59) {
      sub_10006A7CC();
    }
    xpc_object_t v8 = (char *)operator new(32 * v7);
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  xpc_object_t v9 = &v8[32 * v2];
  CFMutableArrayRef v20 = v8;
  v21.i64[0] = (uint64_t)v9;
  v21.i64[1] = (uint64_t)v9;
  uint64_t v22 = &v8[32 * v7];
  char *v9 = *a2;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = 0;
  *((void *)v9 + 1) = 0;
  sub_10062A688((void *)v9 + 1, *((const void **)a2 + 1), *((void *)a2 + 2), (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3);
  uint64_t v10 = v21.i64[0];
  uint64_t v11 = v21.i64[1] + 32;
  v21.i64[1] += 32;
  uint64_t v13 = a1->i64[0];
  unint64_t v12 = a1->u64[1];
  if (v12 == a1->i64[0])
  {
    int64x2_t v17 = vdupq_n_s64(v12);
  }
  else
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = v10 + v14;
      uint64_t v16 = v12 + v14;
      *(unsigned char *)(v15 - 32) = *(unsigned char *)(v12 + v14 - 32);
      *(void *)(v15 - 16) = 0;
      *(void *)(v15 - 8) = 0;
      *(void *)(v15 - 24) = 0;
      *(_OWORD *)(v15 - 24) = *(_OWORD *)(v12 + v14 - 24);
      *(void *)(v15 - 8) = *(void *)(v12 + v14 - 8);
      *(void *)(v16 - 24) = 0;
      *(void *)(v16 - 16) = 0;
      *(void *)(v16 - 8) = 0;
      v14 -= 32;
    }
    while (v12 + v14 != v13);
    int64x2_t v17 = *a1;
    uint64_t v11 = v21.i64[1];
    v10 += v14;
  }
  a1->i64[0] = v10;
  a1->i64[1] = v11;
  int64x2_t v21 = v17;
  CFMutableArrayRef v18 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v22;
  uint64_t v22 = v18;
  CFMutableArrayRef v20 = (char *)v17.i64[0];
  sub_10062A72C((uint64_t)&v20);
  return v11;
}

void sub_10062A674(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10062A72C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_10062A688(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    xpc_object_t v5 = result;
    if (a4 >> 61) {
      sub_10006A748();
    }
    uint64_t result = operator new(8 * a4);
    xpc_object_t v8 = result;
    *xpc_object_t v5 = result;
    v5[1] = result;
    _DWORD v5[2] = &result[a4];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_10062A710(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062A72C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 32;
    xpc_object_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10062A790(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = (a1->i64[1] - a1->i64[0]) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    sub_10006A748();
  }
  uint64_t v6 = a1[1].i64[0] - a1->i64[0];
  if (v6 >> 4 > v3) {
    unint64_t v3 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v23 = a1 + 1;
  if (v7)
  {
    if (v7 >> 59) {
      sub_10006A7CC();
    }
    xpc_object_t v8 = (char *)operator new(32 * v7);
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  size_t v9 = &v8[32 * v2];
  CFMutableArrayRef v20 = v8;
  v21.i64[0] = (uint64_t)v9;
  v21.i64[1] = (uint64_t)v9;
  uint64_t v22 = &v8[32 * v7];
  *(_DWORD *)size_t v9 = *(_DWORD *)a2;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = 0;
  *((void *)v9 + 1) = 0;
  sub_1003A10E0((void *)v9 + 1, *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 1);
  uint64_t v10 = v21.i64[0];
  uint64_t v11 = v21.i64[1] + 32;
  v21.i64[1] += 32;
  uint64_t v13 = a1->i64[0];
  unint64_t v12 = a1->u64[1];
  if (v12 == a1->i64[0])
  {
    int64x2_t v17 = vdupq_n_s64(v12);
  }
  else
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = v10 + v14;
      uint64_t v16 = v12 + v14;
      *(_DWORD *)(v15 - 32) = *(_DWORD *)(v12 + v14 - 32);
      *(void *)(v15 - 16) = 0;
      *(void *)(v15 - 8) = 0;
      *(void *)(v15 - 24) = 0;
      *(_OWORD *)(v15 - 24) = *(_OWORD *)(v12 + v14 - 24);
      *(void *)(v15 - 8) = *(void *)(v12 + v14 - 8);
      *(void *)(v16 - 24) = 0;
      *(void *)(v16 - 16) = 0;
      *(void *)(v16 - 8) = 0;
      v14 -= 32;
    }
    while (v12 + v14 != v13);
    int64x2_t v17 = *a1;
    uint64_t v11 = v21.i64[1];
    v10 += v14;
  }
  a1->i64[0] = v10;
  a1->i64[1] = v11;
  int64x2_t v21 = v17;
  CFMutableArrayRef v18 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v22;
  uint64_t v22 = v18;
  CFMutableArrayRef v20 = (char *)v17.i64[0];
  sub_10062A72C((uint64_t)&v20);
  return v11;
}

void sub_10062A8F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10062A72C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10062A910(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10062A948(uint64_t a1)
{
}

uint64_t sub_10062A964(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10062A9A8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

void sub_10062A9D4(ServiceManager::Service *this)
{
  *(void *)this = off_1019F09B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10062AA30(ServiceManager::Service *this)
{
  *(void *)this = off_1019F09B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10062AAA0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DATA.EMBMSController");
}

unsigned char *sub_10062AAB0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10062AAF0(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *a2;
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v2 + 96))(v2, &object);
  if (object) {
    dispatch_release(object);
  }
}

void sub_10062AB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062AB78()
{
  return 0;
}

uint64_t sub_10062AB80()
{
  return 1;
}

uint64_t sub_10062AB88()
{
  return 0;
}

uint64_t sub_10062AB94(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 104))();
}

uint64_t sub_10062ABBC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 112))();
}

uint64_t *sub_10062ABE4(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = (dispatch_group_t *)v1;
  uint64_t v2 = *(void **)(v1 + 8);
  unint64_t v3 = v2[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: bootstrap 2...", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v4 = *(NSObject **)v1;
  if (*(void *)v1)
  {
    dispatch_retain(*(dispatch_object_t *)v1);
    dispatch_group_enter(v4);
    uint64_t v5 = v2[10];
    if (!v5) {
      goto LABEL_18;
    }
    dispatch_group_t group = v4;
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  else
  {
    uint64_t v5 = v2[10];
    if (!v5) {
      goto LABEL_18;
    }
    dispatch_group_t group = 0;
  }
  xpc_object_t object = xpc_null_create();
  uint64_t v6 = (std::__shared_weak_count *)v2[2];
  if (!v6 || (uint64_t v7 = v2[1], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  size_t v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  uint64_t v10 = std::__shared_weak_count::lock(v9);
  uint64_t v11 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v9);
    sub_10004D2C8(v11);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v7 = 0;
  }
  *(void *)&long long buf = v7;
  *((void *)&buf + 1) = v11;
  (*(void (**)(uint64_t, dispatch_group_t *, xpc_object_t *, long long *))(*(void *)v5 + 16))(v5, &group, &object, &buf);
  if (*((void *)&buf + 1)) {
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&buf + 1));
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
LABEL_18:
  unint64_t v12 = v2[5];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v19 = 136315138;
    CFMutableArrayRef v20 = "bootstrapEMBMSController_sync";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController bootstrapped", v19, 0xCu);
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  uint64_t v13 = v2[5];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: bootstrapped !", (uint8_t *)&buf, 0xCu);
  }
  sub_10062AF08(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_10062AE84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, xpc_object_t object, dispatch_group_t group, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

dispatch_group_t **sub_10062AF08(dispatch_group_t **result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    if (*v1)
    {
      dispatch_group_leave(*v1);
      if (*v1) {
        dispatch_release(*v1);
      }
    }
    operator delete();
  }
  return result;
}

void sub_10062AF68(void **a1)
{
  xpc_object_t v4 = a1;
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v6 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: start 2...", buf, 0xCu);
  }
  (*(void (**)(void *))(*v1 + 120))(v1);
  unint64_t v3 = v1[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v6 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: EMBMSController: started !", buf, 0xCu);
  }
  operator delete();
}

void sub_10062B0B4()
{
}

uint64_t sub_10062B0E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10062B0F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10062B10C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_10062B11C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10062B1B4(void *a1)
{
  *a1 = off_1019F0A70;
  sub_10010E020(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10062B204(void *a1)
{
  *a1 = off_1019F0A70;
  sub_10010E020(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10062B274(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019F0A70;
  sub_10062B52C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10062B2C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10062B2DC(uint64_t a1, void *a2)
{
  *a2 = off_1019F0A70;
  return sub_10062B52C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10062B308(uint64_t a1)
{
}

void sub_10062B310(void *a1)
{
  sub_10062B594((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_10062B34C(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (*a2)
  {
    *(void *)CFTypeRef cf = 0;
    sub_100629128(cf, a3);
    xpc_object_t v8 = *(const void **)cf;
    if (*(void *)cf) {
      CFRetain(*(CFTypeRef *)cf);
    }
    uint64_t v4 = *(void *)(a1 + 56);
    if (!v4) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v4 + 48))(v4, &v8);
    sub_100057D78(&v8);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFTypeRef cf = 136315138;
      *(void *)&cf[4] = "operator()";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: kGetEMBMSSigInfo failure", cf, 0xCu);
    }
    *(void *)CFTypeRef cf = 0;
    uint64_t v6 = *(void *)(a1 + 56);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v6 + 48))(v6, cf);
  }
  return sub_100057D78((const void **)cf);
}

void sub_10062B4A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062B4E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10062B520()
{
}

uint64_t sub_10062B52C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10062B11C(a1 + 24, a2 + 24);
  return a1;
}

void sub_10062B57C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10062B594(uint64_t a1)
{
  sub_10010E020((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_10062B5E0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10062B664(void *a1)
{
  *a1 = off_1019F0B00;
  sub_10010E020(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10062B6B4(void *a1)
{
  *a1 = off_1019F0B00;
  sub_10010E020(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10062B724(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019F0B00;
  sub_10062B9DC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10062B778(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10062B78C(uint64_t a1, void *a2)
{
  *a2 = off_1019F0B00;
  return sub_10062B9DC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10062B7B8(uint64_t a1)
{
}

void sub_10062B7C0(void *a1)
{
  sub_10062B594((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_10062B7FC(uint64_t a1, unsigned char *a2, int *a3)
{
  if (*a2)
  {
    *(void *)CFTypeRef cf = 0;
    sub_100629560(cf, a3);
    xpc_object_t v8 = *(const void **)cf;
    if (*(void *)cf) {
      CFRetain(*(CFTypeRef *)cf);
    }
    uint64_t v4 = *(void *)(a1 + 56);
    if (!v4) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v4 + 48))(v4, &v8);
    sub_100057D78(&v8);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFTypeRef cf = 136315138;
      *(void *)&cf[4] = "operator()";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E %s: kGetEMBMSSAIListInfo failure", cf, 0xCu);
    }
    *(void *)CFTypeRef cf = 0;
    uint64_t v6 = *(void *)(a1 + 56);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v6 + 48))(v6, cf);
  }
  return sub_100057D78((const void **)cf);
}

void sub_10062B954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062B990(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10062B9D0()
{
}

uint64_t sub_10062B9DC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10062B11C(a1 + 24, a2 + 24);
  return a1;
}

void sub_10062BA2C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10062BA44(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void BasebandSettingsDeviceStateModel::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10062BB90(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandSettingsDeviceStateModel::BasebandSettingsDeviceStateModel(uint64_t a1, void *a2, dispatch_object_t *a3)
{
  uint64_t v6 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "set.bb.mdl");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v13, &v12);
  ctu::OsLogLogger::OsLogLogger(v6, (const ctu::OsLogLogger *)v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019F0B90;
  *(void *)(a1 + 32) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "BasebandSettingsDeviceStateModel");
  size_t v9 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v9) {
    dispatch_release(v9);
  }
  if (v11 < 0) {
    operator delete(__p);
  }
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
  return a1;
}

void sub_10062BD14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  CFMutableArrayRef v20 = (std::__shared_weak_count *)*((void *)v17 + 5);
  if (v20) {
    sub_10004D2C8(v20);
  }
  int64x2_t v21 = (std::__shared_weak_count *)*((void *)v17 + 3);
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  ctu::OsLogLogger::~OsLogLogger(v18);
  BasebandSettingsDeviceStateInterface::~BasebandSettingsDeviceStateInterface(v17);
  _Unwind_Resume(a1);
}

void sub_10062BDA0(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(Registry **)(a1 + 32));
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_10062BDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062BE04(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 48));
}

void sub_10062BE0C(uint64_t a1, unsigned int a2, char *__s)
{
  uint64_t v3 = *(void *)(a1 + 112);
  if (v3)
  {
    int v5 = *(unsigned __int8 *)(v3 + 49);
    if (v5 != a2)
    {
      if (a2 == 128)
      {
        uint64_t v7 = *(NSObject **)v3;
        if (os_log_type_enabled(*(os_log_t *)v3, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I File transfer completed. File transfer monitoring timer destroyed", (uint8_t *)&buf, 2u);
        }
        uint64_t v8 = *(void *)(v3 + 80);
        *(void *)(v3 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
        int v5 = *(unsigned __int8 *)(v3 + 49);
      }
      if (!v5)
      {
        uint64_t v23 = 0;
        CFMutableArrayRef v24 = 0;
        Registry::getTimerService(&v23, *(Registry **)(v3 + 24));
        size_t v9 = *(NSObject **)v3;
        uint64_t v10 = *(NSObject **)v3;
        if (v23)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = 10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I File transfer monitoring timer started for %ld seconds", (uint8_t *)&buf, 0xCu);
          }
          uint64_t v12 = *(void *)(v3 + 8);
          char v11 = *(std::__shared_weak_count **)(v3 + 16);
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v13 = v23;
          sub_100058DB0(__p, "File transfer monitoring");
          uint64_t v14 = *(NSObject **)(v3 + 40);
          dispatch_object_t object = v14;
          if (v14) {
            dispatch_retain(v14);
          }
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 1174405120;
          CFNumberRef v26 = sub_10062CF68;
          CFMutableDictionaryRef v27 = &unk_1019F0C48;
          uint64_t v28 = v3;
          uint64_t v29 = v12;
          CFNumberRef v30 = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          aBlocuint64_t k = _Block_copy(&buf);
          sub_100118A44(v13, (uint64_t)__p, 2, 600000000, &object, &aBlock);
          uint64_t v15 = v22;
          uint64_t v22 = 0;
          uint64_t v16 = *(void *)(v3 + 80);
          *(void *)(v3 + 8sub_10010E764((uint64_t)&a9, 0) = v15;
          if (v16)
          {
            (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
            uint64_t v17 = v22;
            uint64_t v22 = 0;
            if (v17) {
              (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
            }
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v21 < 0) {
            operator delete(__p[0]);
          }
          if (v30) {
            std::__shared_weak_count::__release_weak(v30);
          }
          if (v11) {
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        else if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Fail to find timer service for file transfer monitoring", (uint8_t *)&buf, 2u);
        }
        if (v24) {
          sub_10004D2C8(v24);
        }
      }
      *(unsigned char *)(v3 + 49) = a2;
      if (__s)
      {
        sub_10003ED78((std::string *)(v3 + 56), __s);
      }
      else if (*(char *)(v3 + 79) < 0)
      {
        **(unsigned char **)(v3 + 56) = 0;
        *(void *)(v3 + 64) = 0;
      }
      else
      {
        *(unsigned char *)(v3 + 56) = 0;
        *(unsigned char *)(v3 + 79) = 0;
      }
      if (a2 <= 8 && ((1 << a2) & 0x116) != 0) {
        *(unsigned char *)(v3 + 48) |= a2;
      }
    }
  }
}

void sub_10062C17C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10062C1FC(void *a1, int a2)
{
  uint64_t v2 = a1[8];
  if ((v2 != 0) != a2)
  {
    int v5 = a1[1];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "false";
      if (v2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (a2) {
        uint64_t v6 = "true";
      }
      buf[0] = 136315394;
      *(void *)&buf[1] = v7;
      LOWORD(buf[3]) = 2080;
      *(void *)((char *)&buf[3] + 2) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I File transfer in progress changing from %s to %s", (uint8_t *)buf, 0x16u);
    }
    if (a2)
    {
      uint64_t v8 = a1[14];
      if (v8) {
        sub_10062C8E4(v8);
      }
      ctu::RestModule::getQueue((uint64_t *)&object, (ctu::RestModule *)(a1 + 6));
      operator new();
    }
    size_t v9 = (std::__shared_weak_count *)a1[11];
    a1[10] = 0;
    a1[11] = 0;
    if (v9) {
      sub_10004D2C8(v9);
    }
    uint64_t v10 = (std::__shared_weak_count *)a1[9];
    a1[8] = 0;
    a1[9] = 0;
    if (v10) {
      sub_10004D2C8(v10);
    }
    (*(void (**)(void *))(*a1 + 72))(a1);
    uint64_t v11 = a1[14];
    if (v11)
    {
      sub_10062C8E4(v11);
      uint64_t v12 = (std::__shared_weak_count *)a1[15];
      a1[14] = 0;
      a1[15] = 0;
      if (v12) {
        sub_10004D2C8(v12);
      }
    }
  }
}

void sub_10062C7F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  sub_1000339DC(&a26);
  _Unwind_Resume(a1);
}

void sub_10062C8E4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 49))
  {
    if (*(unsigned __int8 *)(a1 + 49) == 128)
    {
      os_log_t v2 = *(os_log_t *)a1;
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      uint64_t v3 = "#I File transfer progress: Completed";
      uint64_t v4 = v2;
      uint32_t v5 = 2;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, (uint8_t *)&__p, v5);
      return;
    }
    uint64_t v6 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I File transfer progress:", (uint8_t *)&__p, 2u);
      uint64_t v6 = *(NSObject **)a1;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_10062D418(&__p, *(unsigned char *)(a1 + 48));
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v14 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I   Acquired resources: %s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      uint64_t v6 = *(NSObject **)a1;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I   Current task: %s", (uint8_t *)&__p, 0xCu);
    }
    char v9 = *(unsigned char *)(a1 + 79);
    if (v9 < 0)
    {
      if (!*(void *)(a1 + 64)) {
        return;
      }
    }
    else if (!*(unsigned char *)(a1 + 79))
    {
      return;
    }
    os_log_t v10 = *(os_log_t *)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v11 = (void *)(a1 + 56);
    if (v9 < 0) {
      uint64_t v11 = (void *)*v11;
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    uint64_t v3 = "#I   Details: %{public}s";
    uint64_t v4 = v10;
    uint32_t v5 = 12;
    goto LABEL_24;
  }
}

BOOL sub_10062CB08(uint64_t a1)
{
  return *(void *)(a1 + 64) != 0;
}

void *sub_10062CB18(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 96))
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Already have booted assertion held", buf, 2u);
    }
    return (void *)sub_1000607A8(a2, 1);
  }
  else
  {
    sub_100058DB0(buf, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v12 < 0) {
      operator delete(*(void **)buf);
    }
    long long v6 = v10[0];
    v10[0] = 0uLL;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
    *(_OWORD *)(a1 + 96) = v6;
    if (v7)
    {
      sub_10004D2C8(v7);
      if (*((void *)&v10[0] + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v10[0] + 1));
      }
    }
    sub_1000DFC90((uint64_t)v9, a2);
    sub_100023950((uint64_t)v10, (uint64_t)v9);
    uint64_t v13 = 0;
    uint64_t v8 = operator new(0x28uLL);
    void *v8 = off_1019F0E78;
    sub_100023950((uint64_t)(v8 + 1), (uint64_t)v10);
    uint64_t v13 = v8;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(buf);
    sub_100060644(v10);
    return sub_100060644(v9);
  }
}

void sub_10062CC94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
}

void sub_10062CCE0(void *a1)
{
  os_log_t v2 = a1[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Releasing baseband booted assertion", v4, 2u);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[13];
  a1[12] = 0;
  a1[13] = 0;
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_10062CD54(void *a1)
{
  os_log_t v2 = a1[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "true";
    if (!a1[8]) {
      uint64_t v3 = "false";
    }
    int v14 = 136315138;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I File Transfer In Progress: %s", (uint8_t *)&v14, 0xCu);
    os_log_t v2 = a1[1];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "is";
    if (!a1[10]) {
      uint64_t v4 = "is not";
    }
    int v14 = 136315138;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Power assertion %s held", (uint8_t *)&v14, 0xCu);
    os_log_t v2 = a1[1];
  }
  uint64_t v5 = a1[12];
  BOOL v6 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v6) {
      goto LABEL_20;
    }
    uint64_t v7 = "false";
    int v8 = *(_DWORD *)(v5 + 68);
    if (v8 == 2) {
      char v9 = "true";
    }
    else {
      char v9 = "false";
    }
    if (!v8) {
      uint64_t v7 = "true";
    }
    int v14 = 136315394;
    uint64_t v15 = v9;
    __int16 v16 = 2080;
    uint64_t v17 = v7;
    os_log_t v10 = "#I Baseband booted assertion: acquired (%s) revoked (%s)";
    uint64_t v11 = v2;
    uint32_t v12 = 22;
  }
  else
  {
    if (!v6) {
      goto LABEL_20;
    }
    LOWORD(v14) = 0;
    os_log_t v10 = "#I Baseband booted assertion not held";
    uint64_t v11 = v2;
    uint32_t v12 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v14, v12);
LABEL_20:
  uint64_t v13 = a1[14];
  if (v13) {
    sub_10062C8E4(v13);
  }
}

void sub_10062CF30(void *a1)
{
  sub_10062D760(a1);

  operator delete();
}

void sub_10062CF68(void *a1)
{
  os_log_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_48:
        sub_10004D2C8(v5);
        return;
      }
      BOOL v6 = *(NSObject **)v3;
      if (os_log_type_enabled(*(os_log_t *)v3, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 10;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I File transfer monitoring timer has fired after %ld seconds", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v7 = *(void *)(v3 + 80);
      *(void *)(v3 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      sub_10062C8E4(v3);
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 24));
      char v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          std::string::size_type v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v10;
      int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          if (!v16)
          {
LABEL_46:
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            goto LABEL_48;
          }
LABEL_17:
          xpc_object_t v30 = 0;
          xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v19 = v18;
          if (v18)
          {
            xpc_object_t v30 = v18;
          }
          else
          {
            xpc_object_t v19 = xpc_null_create();
            xpc_object_t v30 = v19;
            if (!v19)
            {
              xpc_object_t v20 = xpc_null_create();
              xpc_object_t v19 = 0;
              goto LABEL_24;
            }
          }
          if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v19);
            goto LABEL_25;
          }
          xpc_object_t v20 = xpc_null_create();
LABEL_24:
          xpc_object_t v30 = v20;
LABEL_25:
          xpc_release(v19);
          sub_10062D418(&buf, *(unsigned char *)(v3 + 48));
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string buf = &buf;
          }
          else {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          xpc_object_t v28 = xpc_string_create((const char *)p_buf);
          if (!v28) {
            xpc_object_t v28 = xpc_null_create();
          }
          v27[0] = &v30;
          v27[1] = "acquiredResources";
          sub_100035E70((uint64_t)v27, &v28, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v28);
          xpc_object_t v28 = 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          uint64_t v22 = (const char *)asString();
          xpc_object_t v26 = xpc_string_create(v22);
          if (!v26) {
            xpc_object_t v26 = xpc_null_create();
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
          buf.__r_.__value_.__l.__size_ = (std::string::size_type)"currentTask";
          sub_100035E70((uint64_t)&buf, &v26, v27);
          xpc_release(v27[0]);
          v27[0] = 0;
          xpc_release(v26);
          xpc_object_t v26 = 0;
          uint64_t v23 = (const char *)(v3 + 56);
          if (*(char *)(v3 + 79) < 0)
          {
            if (!*(void *)(v3 + 64))
            {
LABEL_42:
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
              if (v30) {
                xpc_retain(v30);
              }
              else {
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
              }
              (*(void (**)(uint64_t, const char *, std::string *))(*(void *)v16 + 16))(v16, "commCenterFileTransferState", &buf);
              xpc_release(buf.__r_.__value_.__l.__data_);
              buf.__r_.__value_.__r.__words[0] = 0;
              xpc_release(v30);
              goto LABEL_46;
            }
            uint64_t v23 = *(const char **)v23;
          }
          else if (!*(unsigned char *)(v3 + 79))
          {
            goto LABEL_42;
          }
          xpc_object_t v24 = xpc_string_create(v23);
          if (!v24) {
            xpc_object_t v24 = xpc_null_create();
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
          buf.__r_.__value_.__l.__size_ = (std::string::size_type)"details";
          sub_100035E70((uint64_t)&buf, &v24, &v25);
          xpc_release(v25);
          xpc_object_t v25 = 0;
          xpc_release(v24);
          xpc_object_t v24 = 0;
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      if (!v16) {
        goto LABEL_46;
      }
      goto LABEL_17;
    }
  }
}

void sub_10062D340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10062D3EC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10062D408(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10062D418(std::string *a1, unsigned __int8 a2)
{
  unsigned int v3 = a2;
  if (a2)
  {
    xpc_object_t v18 = 0;
    xpc_object_t v19 = 0;
    unint64_t v20 = 0;
    int v4 = 1;
    do
    {
      if (v3)
      {
        uint64_t v5 = (char *)asString();
        sub_100058DB0(__p, v5);
        BOOL v6 = v19;
        if ((unint64_t)v19 >= v20)
        {
          unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v19 - (char *)v18) >> 3);
          unint64_t v9 = v8 + 1;
          if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v20 - (void)v18) >> 3) > v9) {
            unint64_t v9 = 0x5555555555555556 * ((uint64_t)(v20 - (void)v18) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)v18) >> 3) >= 0x555555555555555) {
            unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v10 = v9;
          }
          v21[4] = (void **)&v20;
          if (v10) {
            uint64_t v11 = (void **)sub_10004812C((uint64_t)&v20, v10);
          }
          else {
            uint64_t v11 = 0;
          }
          uint64_t v12 = &v11[3 * v8];
          v21[0] = v11;
          v21[1] = v12;
          v21[3] = &v11[3 * v10];
          long long v13 = *(_OWORD *)__p;
          v12[2] = (void *)v17;
          *(_OWORD *)uint64_t v12 = v13;
          __p[1] = 0;
          std::string::size_type v17 = 0;
          __p[0] = 0;
          v21[2] = v12 + 3;
          sub_100048204((uint64_t *)&v18, v21);
          int v14 = v19;
          sub_100048174((uint64_t)v21);
          xpc_object_t v19 = v14;
          if (SHIBYTE(v17) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v7 = *(_OWORD *)__p;
          v19->__r_.__value_.__r.__words[2] = v17;
          *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
          xpc_object_t v19 = v6 + 1;
        }
      }
      v4 *= 2;
      BOOL v15 = v3 > 1;
      v3 >>= 1;
    }
    while (v15);
    sub_100062B40(v18, v19, ", ", 2uLL, a1);
    v21[0] = (void **)&v18;
    sub_100047F64(v21);
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
  }
}

void sub_10062D5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  std::string __p = &a16;
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_10062D628(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10062D660(uint64_t a1)
{
  return sub_10062D6AC(*(void *)(a1 + 24));
}

uint64_t sub_10062D668(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10062D6AC(uint64_t this)
{
  if (this)
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 80);
    *(void *)(v1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    unsigned int v3 = *(NSObject **)(v1 + 40);
    if (v3) {
      dispatch_release(v3);
    }
    int v4 = *(std::__shared_weak_count **)(v1 + 32);
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v1);
    operator delete();
  }
  return this;
}

void sub_10062D760(void *a1)
{
  *a1 = off_1019F0B90;
  uint64_t v2 = (std::__shared_weak_count *)a1[15];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[13];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[11];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[9];
  if (v5) {
    sub_10004D2C8(v5);
  }
  BOOL v6 = (std::__shared_weak_count *)a1[7];
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = (std::__shared_weak_count *)a1[5];
  if (v7) {
    sub_10004D2C8(v7);
  }
  unint64_t v8 = (std::__shared_weak_count *)a1[3];
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  BasebandSettingsDeviceStateInterface::~BasebandSettingsDeviceStateInterface((BasebandSettingsDeviceStateInterface *)a1);
}

void sub_10062D80C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10062D88C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10062D8C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10062D900(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10062D930(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10062D978()
{
}

void *sub_10062D98C()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019F0D78;
  return result;
}

void sub_10062D9C4(uint64_t a1, void *a2)
{
  *a2 = off_1019F0D78;
}

void sub_10062D9EC(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "BundleFilePush", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_10062DA64(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10062DAA4()
{
}

void sub_10062DAB4()
{
}

void *sub_10062DAC8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F0DF8;
  result[1] = v3;
  return result;
}

uint64_t sub_10062DB10(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F0DF8;
  a2[1] = v2;
  return result;
}

void sub_10062DB3C(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void **)(a1 + 8);
  int v4 = v3[1];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "is";
    if (!v2) {
      uint64_t v5 = "is NOT";
    }
    int v6 = 136315138;
    long long v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband booted assertion %s held", (uint8_t *)&v6, 0xCu);
  }
  if (v2) {
    (*(void (**)(void *, uint64_t, const char *))(*v3 + 40))(v3, 2, "Baseband booted assertion acquired");
  }
}

uint64_t sub_10062DC34(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10062DC74()
{
}

void *sub_10062DC80(void *a1)
{
  *a1 = off_1019F0E78;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_10062DCC4(void *a1)
{
  *a1 = off_1019F0E78;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_10062DD28(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x28uLL);
  void *v2 = off_1019F0E78;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10062DD7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10062DD90(uint64_t a1, void *a2)
{
  *a2 = off_1019F0E78;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10062DDBC(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_10062DDC4(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10062DE00(uint64_t a1, char *a2)
{
  return sub_1000607A8(a1 + 8, *a2);
}

uint64_t sub_10062DE0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10062DE4C()
{
}

uint64_t sub_10062DE58(uint64_t a1, void *a2, int a3)
{
  sub_100058DB0(__p, "RCSMessageProvisioning");
  AnalyticsEvent::AnalyticsEvent((void *)a1, (long long *)__p, a2);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, "lazuli.prov.metric");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v15);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 56), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  v14[0] = off_101999E18;
  v14[1] = sub_10062E208;
  v14[3] = v14;
  *(void *)(a1 + 64) = 0;
  if ((capabilities::ct::supportsGemini(v6) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 64)) {
    operator new();
  }
  sub_10008863C(v14);
  *(void *)a1 = off_1019F0F50;
  *(_DWORD *)(a1 + 72) = a3;
  if (a3 && a3 != 3)
  {
    unsigned int v7 = analytics::simSlotAsSubsId();
    xpc_object_t v9 = xpc_int64_create(v7);
    if (!v9) {
      xpc_object_t v9 = xpc_null_create();
    }
    v15.var0 = (char *)(a1 + 32);
    v15.var1.fRef = (os_log_s *)"subs_id";
    sub_100035E70((uint64_t)&v15, &v9, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v9);
  }
  return a1;
}

void sub_10062E0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10062E1E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x10062E1E0);
}

void sub_10062E200()
{
}

const char *sub_10062E208(int a1)
{
  uint64_t v1 = "lazuli.prov.metric.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.prov.metric.2";
  }
  if (a1 == 1) {
    return "lazuli.prov.metric.1";
  }
  else {
    return v1;
  }
}

void sub_10062E234(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));

  AnalyticsEvent::~AnalyticsEvent((void **)a1);
}

void sub_10062E2A4(uint64_t a1)
{
  sub_10062E234(a1);

  operator delete();
}

void sub_10062E2DC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v3 = (const char *)a2;
  }
  else {
    uint64_t v3 = *(const char **)a2;
  }
  xpc_object_t v5 = xpc_string_create(v3);
  if (!v5) {
    xpc_object_t v5 = xpc_null_create();
  }
  v4[0] = a1 + 32;
  v4[1] = "PhoneNumberSource";
  sub_100035E70((uint64_t)v4, &v5, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
}

void sub_10062E36C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 176))
  {
    xpc_object_t v24 = xpc_int64_create(*(void *)(a2 + 168));
    if (!v24) {
      xpc_object_t v24 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Timer_T1";
    sub_100035E70((uint64_t)&v22, &v24, &v25);
    xpc_release(v25);
    xpc_object_t v25 = 0;
    xpc_release(v24);
    xpc_object_t v24 = 0;
  }
  if (*(unsigned char *)(a2 + 192))
  {
    xpc_object_t v20 = xpc_int64_create(*(void *)(a2 + 184));
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Timer_T2";
    sub_100035E70((uint64_t)&v22, &v20, &v21);
    xpc_release(v21);
    xpc_object_t v21 = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 208))
  {
    xpc_object_t v18 = xpc_int64_create(*(void *)(a2 + 200));
    if (!v18) {
      xpc_object_t v18 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Timer_T4";
    sub_100035E70((uint64_t)&v22, &v18, &v19);
    xpc_release(v19);
    xpc_object_t v19 = 0;
    xpc_release(v18);
    xpc_object_t v18 = 0;
  }
  if (*(unsigned char *)(a2 + 224))
  {
    xpc_object_t object = xpc_int64_create(*(void *)(a2 + 216));
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "StandaloneMsgSwitchoverSize";
    sub_100035E70((uint64_t)&v22, &object, &v17);
    xpc_release(v17);
    xpc_object_t v17 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
  }
  if (*(unsigned char *)(a2 + 233))
  {
    xpc_object_t v14 = xpc_BOOL_create(*(unsigned char *)(a2 + 232));
    if (!v14) {
      xpc_object_t v14 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_psSignallingSIPoTLS";
    sub_100035E70((uint64_t)&v22, &v14, &v15);
    xpc_release(v15);
    xpc_object_t v15 = 0;
    xpc_release(v14);
    xpc_object_t v14 = 0;
  }
  if (*(unsigned char *)(a2 + 237))
  {
    xpc_object_t v12 = xpc_BOOL_create(*(unsigned char *)(a2 + 236));
    if (!v12) {
      xpc_object_t v12 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_psSignallingRoamingSIPoTLS";
    sub_100035E70((uint64_t)&v22, &v12, &v13);
    xpc_release(v13);
    xpc_object_t v13 = 0;
    xpc_release(v12);
    xpc_object_t v12 = 0;
  }
  if (*(unsigned char *)(a2 + 235))
  {
    xpc_object_t v10 = xpc_BOOL_create(*(unsigned char *)(a2 + 234));
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_psMediaMSRPoTLS";
    sub_100035E70((uint64_t)&v22, &v10, &v11);
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_release(v10);
    xpc_object_t v10 = 0;
  }
  if (*(unsigned char *)(a2 + 239))
  {
    xpc_object_t v8 = xpc_BOOL_create(*(unsigned char *)(a2 + 238));
    if (!v8) {
      xpc_object_t v8 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_psMediaRoamingMSRPoTLS";
    sub_100035E70((uint64_t)&v22, &v8, &v9);
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_release(v8);
    xpc_object_t v8 = 0;
  }
  if (*(unsigned char *)(a2 + 241))
  {
    xpc_object_t v6 = xpc_BOOL_create(*(unsigned char *)(a2 + 240));
    if (!v6) {
      xpc_object_t v6 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_WiFiMediaMSRPoTLS";
    sub_100035E70((uint64_t)&v22, &v6, &v7);
    xpc_release(v7);
    xpc_object_t v7 = 0;
    xpc_release(v6);
    xpc_object_t v6 = 0;
  }
  if (*(unsigned char *)(a2 + 243))
  {
    xpc_object_t v4 = xpc_BOOL_create(*(unsigned char *)(a2 + 242));
    if (!v4) {
      xpc_object_t v4 = xpc_null_create();
    }
    uint64_t v22 = a1 + 32;
    uint64_t v23 = "Is_WiFiSignallingSIPoTLS";
    sub_100035E70((uint64_t)&v22, &v4, &v5);
    xpc_release(v5);
    xpc_object_t v5 = 0;
    xpc_release(v4);
  }
}

void sub_10062E7A4(uint64_t a1, uint64_t a2)
{
  xpc_object_t v11 = xpc_int64_create(*(void *)(a2 + 72));
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  uint64_t v4 = a1 + 32;
  uint64_t v9 = v4;
  xpc_object_t v10 = "ChatbotMsgTech";
  sub_100035E70((uint64_t)&v9, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = xpc_BOOL_create(*(unsigned char *)(a2 + 80));
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  uint64_t v9 = v4;
  xpc_object_t v10 = "ChatbotPrivacyDisable";
  sub_100035E70((uint64_t)&v9, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  xpc_object_t v7 = 0;
  xpc_object_t v5 = xpc_BOOL_create(*(unsigned char *)(a2 + 81));
  if (!v5) {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v9 = v4;
  xpc_object_t v10 = "ChatbotIdentityInEnrichedSearch";
  sub_100035E70((uint64_t)&v9, &v5, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(v5);
}

uint64_t sub_10062E8E4(uint64_t a1, int *a2)
{
  sub_100995F94(a2, (char *)object);
  xpc_object_t v4 = object[0];
  object[0] = xpc_null_create();
  xpc_object_t v5 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v4;
  xpc_release(v5);
  xpc_release(object[0]);
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)xpc_object_t v14 = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  *(_OWORD *)xpc_object_t object = 0u;
  sub_10004BD84((uint64_t)object);
  sub_1009958AC(v13, a2);
  xpc_object_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), *(unsigned int *)(a1 + 72));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)v13 + 8, __p);
    xpc_object_t v7 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136446210;
    xpc_object_t v28 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting metric: %{public}s", buf, 0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  *(xpc_object_t *)((char *)object
  *(void *)&v13[0] = v8;
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10062EB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10062EBB4()
{
}

uint64_t sub_10062EBC8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 56;
}

uint64_t sub_10062EBD4@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t result = capabilities::ct::supportsDataSubscriptionController(a1);
  if (result) {
    operator new();
  }
  return result;
}

void sub_10062F084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t a18, uint64_t a19)
{
  if (a19) {
    (*(void (**)(uint64_t))(*(void *)a19 + 8))(a19);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

const char *sub_10062F340()
{
  return "DataSubscriptionController";
}

uint64_t sub_10062F34C(uint64_t a1)
{
  *(void *)a1 = off_1019F1018;
  uint64_t v2 = (DataSubscriptionCommandDriverDelegateInterface *)(a1 + 48);
  *(void *)(a1 + 48) = off_1019F1098;
  sub_10030AC1C((void *)(a1 + 560));
  sub_100600F40((void *)(a1 + 520));
  sub_100600F40((void *)(a1 + 480));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 460));
  sub_100087F94(a1 + 432, *(void **)(a1 + 440));
  xpc_object_t v13 = (void **)(a1 + 408);
  sub_1000C56F4(&v13);
  xpc_object_t v13 = (void **)(a1 + 384);
  sub_10008A88C(&v13);
  sub_1000886C0(a1 + 360, *(char **)(a1 + 368));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 344);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 320);
  *(void *)(a1 + 32sub_10010E764((uint64_t)&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  if (*(unsigned char *)(a1 + 312)) {
    sub_100060644((void *)(a1 + 280));
  }
  if (*(unsigned char *)(a1 + 248)) {
    sub_10005CD2C(a1 + 224, *(char **)(a1 + 232));
  }
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  xpc_object_t v5 = *(std::__shared_weak_count **)(a1 + 168);
  if (v5) {
    sub_10004D2C8(v5);
  }
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6) {
    sub_10004D2C8(v6);
  }
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 136);
  if (v7) {
    sub_10004D2C8(v7);
  }
  xpc_object_t v8 = *(std::__shared_weak_count **)(a1 + 120);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 96);
  if (v9) {
    sub_10004D2C8(v9);
  }
  xpc_object_t v10 = *(std::__shared_weak_count **)(a1 + 80);
  if (v10) {
    sub_10004D2C8(v10);
  }
  char v11 = *(std::__shared_weak_count **)(a1 + 64);
  if (v11) {
    sub_10004D2C8(v11);
  }
  DataSubscriptionCommandDriverDelegateInterface::~DataSubscriptionCommandDriverDelegateInterface(v2);
  DataSubscriptionControllerInterface::~DataSubscriptionControllerInterface((DataSubscriptionControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_10062F4F8(uint64_t a1)
{
  return sub_10062F34C(a1 - 48);
}

void sub_10062F500(uint64_t a1)
{
  sub_10062F34C(a1);

  operator delete();
}

void sub_10062F538(uint64_t a1)
{
  sub_10062F34C(a1 - 48);

  operator delete();
}

void sub_10062F574(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10062F674(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

unsigned char *sub_10062F754@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10062F794(uint64_t a1, int a2, ServiceStage *this)
{
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10062F8A8(uint64_t a1)
{
  uint64_t v2 = (const ctu::OsLogLogger *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 248))
    {
      sub_1000E8F34(*(std::string **)(a1 + 224), (std::string *)(a1 + 232), ",", 1uLL, &__p);
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      xpc_object_t v5 = (void *)(a1 + 200);
      if (*(char *)(a1 + 223) < 0) {
        xpc_object_t v5 = (void *)*v5;
      }
      *(_DWORD *)std::string buf = 136315394;
      long long v20 = (const char *)p_p;
      __int16 v21 = 2080;
      long long v22 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Requested ICCIDs (%s) - Data (%s)", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      xpc_object_t v6 = (void *)(a1 + 200);
      if (*(char *)(a1 + 223) < 0) {
        xpc_object_t v6 = (void *)*v6;
      }
      *(_DWORD *)std::string buf = 136315394;
      long long v20 = "uninitialized";
      __int16 v21 = 2080;
      long long v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Requested ICCIDs (%s) - Data (%s)", buf, 0x16u);
    }
  }
  SubscriptionSlotConfiguration::log((SubscriptionSlotConfiguration *)(a1 + 184), v2, "Requested config");
  SubscriptionSlotConfiguration::log((SubscriptionSlotConfiguration *)(a1 + 192), v2, "Last known config");
  xpc_object_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 256) - 1;
    if (v8 > 4) {
      uint64_t v9 = "kIdle";
    }
    else {
      uint64_t v9 = off_1019F1A60[(char)v8];
    }
    xpc_object_t v10 = "true";
    if (!*(unsigned char *)(a1 + 332)) {
      xpc_object_t v10 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Operation State: %s | Reset recovery %s", (uint8_t *)&__p, 0x16u);
    xpc_object_t v7 = *(NSObject **)(a1 + 40);
  }
  if (*(unsigned char *)(a1 + 312) && os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 268)) {
      char v11 = (const char *)subscriber::asString();
    }
    else {
      char v11 = "[-]";
    }
    uint64_t v12 = asString();
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Temporary Instance: %s (%s)", (uint8_t *)&__p, 0x16u);
    xpc_object_t v7 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v14 = printers::asString((printers *)(a1 + 333), v13);
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v14;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I IsInitialConfig:%s", (uint8_t *)&__p, 0xCu);
  }
  uint64_t v15 = *(void *)(a1 + 72);
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 72))(v15);
  }
  else
  {
    long long v16 = *(NSObject **)v2;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No driver present", (uint8_t *)&__p, 2u);
    }
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 56))(*(void *)(a1 + 88));
}

void sub_10062FC40(uint64_t a1)
{
  if ((*(void *)(a1 + 352) & 0x1FFFFFFFFLL) == 0)
  {
    int v1 = *(unsigned __int8 *)(a1 + 256);
    if (v1 == 1)
    {
      *(unsigned char *)(a1 + 256) = 2;
      uint64_t v2 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        int v3 = 136315906;
        uint64_t v4 = "kWaitingForAssertions";
        __int16 v5 = 2080;
        uint64_t v6 = subscriber::asString();
        __int16 v7 = 2080;
        uint64_t v8 = subscriber::asString();
        __int16 v9 = 2080;
        uint64_t v10 = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [3a] Switch State %s for Primary (%s) Secondary (%s) - Data (%s)", (uint8_t *)&v3, 0x2Au);
      }
    }
    else if (v1 == 3)
    {
      sub_100631F28(a1);
    }
  }
}

void sub_10062FD94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 384);
  uint64_t v3 = *(void *)(a1 + 392);
  while (v2 != v3)
  {
    if (subscriber::isSimInTransientState())
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      __int16 v12 = 0;
      __int16 v9 = "#I SIM in an unknown state - wait";
      uint64_t v10 = (uint8_t *)&v12;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
      return;
    }
    v2 += 168;
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88), a1 + 384);
  if (!*(unsigned char *)(a1 + 248))
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v11 = 0;
    __int16 v9 = "#I No requested ICCID set - wait";
    uint64_t v10 = (uint8_t *)&v11;
    goto LABEL_22;
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72)))
  {
    uint64_t v4 = *(int **)(a1 + 384);
    __int16 v5 = *(int **)(a1 + 392);
    while (v4 != v5)
    {
      if (subscriber::isSimInserted() && subscriber::isSimSettled())
      {
        int v7 = *v4;
        int v6 = v4[1];
        if (v4[2] == 8) {
          int v6 = 0;
        }
        if (v7 == 2)
        {
          *(_DWORD *)(a1 + 196) = v6;
        }
        else if (v7 == 1)
        {
          *(_DWORD *)(a1 + 192) = v6;
        }
      }
      v4 += 42;
    }
    SubscriptionSlotConfiguration::log((SubscriptionSlotConfiguration *)(a1 + 192), (const ctu::OsLogLogger *)(a1 + 40), "Updated last known config based on sim states");
  }

  sub_100630B60(a1);
}

void sub_10062FF44(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), a1 + 360);
  if (*(void *)(a2 + 16) != *(void *)(a1 + 376))
  {
    sub_100630B60(a1);
  }
}

void sub_10062FFC4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 456) == 4)
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Eos error detected", buf, 2u);
    }
    SubscriptionSlotConfiguration::SubscriptionSlotConfiguration((SubscriptionSlotConfiguration *)&v3);
    *(void *)(a1 + 192) = v3;
  }
}

uint64_t sub_10063004C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 432);
  uint64_t v3 = (void *)(result + 440);
  if (v2 != (void *)(result + 440))
  {
    uint64_t v4 = result;
    __int16 v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        goto LABEL_13;
      }
      int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          __int16 v11 = (uint64_t *)v6;
        }
        else {
          __int16 v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != v5 && v7 >= *((_DWORD *)v8 + 8))
      {
        std::string::size_type v14 = v2 + 5;
        uint64_t result = rest::operator==();
        if ((result & 1) == 0)
        {
          int v12 = *v14;
          if (*v14)
          {
            if (v12 != 5) {
              goto LABEL_17;
            }
          }
        }
      }
      else
      {
LABEL_13:
        int v12 = *((unsigned __int8 *)v2 + 40);
        if (*((unsigned char *)v2 + 40)) {
          BOOL v13 = v12 == 5;
        }
        else {
          BOOL v13 = 1;
        }
        if (!v13)
        {
LABEL_17:
          if (v12 != 255) {
            uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v4 + 88) + 48))(*(void *)(v4 + 88), *((unsigned int *)v2 + 8));
          }
        }
      }
      uint64_t v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v2[2];
          BOOL v13 = *v16 == (void)v2;
          uint64_t v2 = v16;
        }
        while (!v13);
      }
      uint64_t v2 = v16;
    }
    while (v16 != v3);
  }
  return result;
}

uint64_t sub_100630174(void *a1, uint64_t a2)
{
  v4[0] = off_1019F1670;
  v4[1] = a2;
  v4[3] = v4;
  sub_100609368(v4, a1);
  sub_100600F40(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

uint64_t sub_100630234(void *a1, uint64_t a2)
{
  v4[0] = off_1019F16F0;
  v4[1] = a2;
  v4[3] = v4;
  sub_100609368(v4, a1);
  sub_100600F40(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

void sub_1006302F4(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(void *)(a4 + 24))
  {
    if ((a3 - 2) >= 3)
    {
      if (a3 == 1)
      {
        if (BYTE4(a2))
        {
          int v9 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = asString();
            __int16 buf_12 = 2080;
            uint64_t buf_14 = subscriber::asString();
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid reason (%s) wtih instance %s", buf, 0x16u);
          }
          goto LABEL_17;
        }
      }
      else if (!a3)
      {
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = asString();
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid reason %s for temporary instance switch", buf, 0xCu);
        }
        goto LABEL_17;
      }
    }
    else if (!BYTE4(a2))
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid reason (%s) without instance", buf, 0xCu);
      }
LABEL_17:
      sub_1000607A8(a4, 0);
      return;
    }
    *(void *)std::string buf = a1;
    *(_DWORD *)&uint8_t buf[8] = a2;
    LOBYTE(buf_12) = BYTE4(a2);
    *(_DWORD *)((char *)&buf_14 + 2) = a3;
    sub_1000DFC90((uint64_t)&v14, a4);
    BOOL v10 = *(std::__shared_weak_count **)(a1 + 16);
    if (v10 && std::__shared_weak_count::lock(v10)) {
      operator new();
    }
    sub_100088B9C();
  }
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Callback not found", buf, 2u);
  }
}

void sub_100630604(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10063061C(std::string::size_type a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned __int8 *)(a3 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(a3 + 8);
  if ((v6 & 0x80u) == 0) {
    uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  uint64_t v10 = *(void *)(a2 + 16);
  if (!(v9 | v10))
  {
    __int16 v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    LOWORD(v17.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Nothing set - disabling everything!", (uint8_t *)&v17, 2u);
    uint64_t v6 = *(unsigned __int8 *)(a3 + 23);
    uint64_t v8 = *(void *)(a3 + 8);
    uint64_t v10 = *(void *)(a2 + 16);
    char v7 = *(unsigned char *)(a3 + 23);
  }
  if (v7 < 0) {
    uint64_t v6 = v8;
  }
  if (v6) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || sub_10010E128(a2, (void **)a3))
  {
LABEL_14:
    v17.__r_.__value_.__r.__words[0] = a1;
    sub_1000C6BDC((uint64_t *)&v17.__r_.__value_.__l.__size_, a2);
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      xpc_object_t __p[2] = *(void **)(a3 + 16);
    }
    BOOL v13 = *(std::__shared_weak_count **)(a1 + 16);
    if (v13)
    {
      if (std::__shared_weak_count::lock(v13)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  uint64_t v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    sub_1000E8F34(*(std::string **)a2, (std::string *)(a2 + 8), ",", 1uLL, &v17);
    uint64_t v15 = (v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v17
        : (std::string *)v17.__r_.__value_.__r.__words[0];
    uint64_t v16 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
    buf[0] = 136315394;
    *(void *)&buf[1] = v15;
    __int16 v20 = 2080;
    uint64_t v21 = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid args, default data not found in config (%s) - Data: %s", (uint8_t *)buf, 0x16u);
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100630910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a2)
  {
    sub_10005CD2C(v12, *(char **)(v11 + 16));
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100630960(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (*(char *)(a2 + 23) < 0)
  {
    unint64_t v3 = *(void *)(a2 + 8);
    if (v3)
    {
      sub_10004FC84(__p, *(void **)a2, v3);
LABEL_6:
      uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
      if (v4)
      {
        if (std::__shared_weak_count::lock(v4)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else if (*(unsigned char *)(a2 + 23))
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
    goto LABEL_6;
  }
  return result;
}

void sub_100630ACC(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 104);
  *(unsigned char *)(a1 + 104) = a2;
  if (v3) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a2 == 0;
  }
  if (v4)
  {
    if ((a2 & 1) == 0)
    {
      if (*(unsigned char *)(a1 + 312))
      {
        if (!*(void *)(a1 + 304) || (sub_1000607A8(a1 + 280, 0), *(unsigned char *)(a1 + 312)))
        {
          sub_100060644((void *)(a1 + 280));
          *(unsigned char *)(a1 + 312) = 0;
        }
      }
    }
  }
  else
  {
    *(void *)(a1 + 192) = 0;
    *(unsigned char *)(a1 + 333) = 1;
    sub_100630B60(a1);
  }
}

void sub_100630B60(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 248)) {
    return;
  }
  uint64_t v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 40))(*(void *)(a1 + 88), a1 + 224);
  if (!v3)
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)uint64_t v58 = 0;
    uint64_t v11 = "Evaluated slot config is invalid";
LABEL_21:
    uint64_t v12 = v10;
    uint32_t v13 = 2;
LABEL_114:
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v11, v58, v13);
    return;
  }
  *(void *)(a1 + 184) = v2;
  BOOL v4 = (_DWORD *)(a1 + 184);
  uint64_t v5 = *(void *)(a1 + 384);
  uint64_t v6 = *(void *)(a1 + 392);
  if (v5 != v6)
  {
    while (1)
    {
      sub_10002E664((uint64_t)v58, v5);
      char isSimInTransientState = subscriber::isSimInTransientState();
      if (SBYTE7(v65) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v63) < 0) {
        operator delete(*((void **)&v62 + 1));
      }
      if (SBYTE7(v62) < 0) {
        operator delete(v61[0]);
      }
      if (SHIBYTE(v60) < 0) {
        operator delete(*((void **)&v59 + 1));
      }
      *(void *)std::string buf = &v58[40];
      sub_10002E39C((void ***)buf);
      if (*(void *)&v58[16])
      {
        *(void *)&v58[24] = *(void *)&v58[16];
        operator delete(*(void **)&v58[16]);
      }
      if (isSimInTransientState) {
        break;
      }
      v5 += 168;
      if (v5 == v6) {
        goto LABEL_16;
      }
    }
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v58 = 0;
      uint64_t v15 = "#I Aborting requested configuration - a SIM is in transient state";
LABEL_42:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, v58, 2u);
      return;
    }
    return;
  }
LABEL_16:
  *(_OWORD *)std::string __p = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  *(_OWORD *)unint64_t v61 = 0u;
  long long v59 = 0u;
  uint64_t v8 = (void *)(a1 + 200);
  memset(v58, 0, sizeof(v58));
  sub_100631B68(v58, a1, a1 + 200);
  if (BYTE8(v65))
  {
    if (*v4 == *(_DWORD *)&v58[4])
    {
      int v9 = 1;
LABEL_30:
      *(_DWORD *)(a1 + 176) = v9;
      goto LABEL_34;
    }
    if (*(_DWORD *)(a1 + 188) == *(_DWORD *)&v58[4])
    {
      int v9 = 2;
      goto LABEL_30;
    }
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    *(_WORD *)std::string buf = 0;
    long long v18 = "#I Requested data instance physical slot not found - no change";
    long long v19 = v21;
    uint32_t v20 = 2;
LABEL_33:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
    goto LABEL_34;
  }
  *(_DWORD *)(a1 + 176) = *(_DWORD *)(a1 + 180);
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 223) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    uint64_t v17 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    long long v18 = "#I [-] ICCID not found: (%s) - leaving requested instance (%s)";
    long long v19 = v16;
    uint32_t v20 = 22;
    goto LABEL_33;
  }
LABEL_34:
  sub_100397998((uint64_t)v58);
  if (isActive() && !*(unsigned char *)(a1 + 333))
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t v58 = 0;
    uint64_t v15 = "#I Aborting requested configuration - Emergency Mode active";
    goto LABEL_42;
  }
  if (*(unsigned char *)(a1 + 312))
  {
    long long v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 268)) {
        long long v23 = (const char *)subscriber::asString();
      }
      else {
        long long v23 = "-";
      }
      *(_DWORD *)uint64_t v58 = 136315138;
      *(void *)&v58[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Temporary instance set (%s), clearing", v58, 0xCu);
    }
    if (*(void *)(a1 + 304)) {
      sub_1000607A8(a1 + 280, 0);
    }
    if (*(unsigned char *)(a1 + 312))
    {
      sub_100060644((void *)(a1 + 280));
      *(unsigned char *)(a1 + 312) = 0;
    }
  }
  int v24 = *(unsigned __int8 *)(a1 + 256);
  if (!*(unsigned char *)(a1 + 256))
  {
    long long v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = subscriber::asString();
      uint64_t v27 = subscriber::asString();
      uint64_t v28 = subscriber::asString();
      *(_DWORD *)uint64_t v58 = 136315650;
      *(void *)&v58[4] = v26;
      *(_WORD *)&v58[12] = 2080;
      *(void *)&v58[14] = v27;
      *(_WORD *)&v58[22] = 2080;
      *(void *)&v58[24] = v28;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I [1a] Requested Config - Primary (%s) Secondary (%s) - Data (%s)", v58, 0x20u);
    }
    uint64_t isValid = SubscriptionSlotConfiguration::isValid();
    if ((isValid & 1) == 0)
    {
      if (capabilities::ct::supportsDynamicSID((capabilities::ct *)isValid))
      {
        uint64_t v10 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)uint64_t v58 = 0;
        uint64_t v11 = "[-] No valid configuration";
        goto LABEL_21;
      }
      if (!*(_DWORD *)(a1 + 176))
      {
        uint64_t v10 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)uint64_t v58 = 0;
        uint64_t v11 = "[-] No valid configuration";
        goto LABEL_21;
      }
    }
    if (*(unsigned char *)(a1 + 333)
      || !SubscriptionSlotConfiguration::operator==()
      || (int v32 = *(_DWORD *)(a1 + 176)) != 0 && v32 != *(_DWORD *)(a1 + 180))
    {
      CFMutableDictionaryRef v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v34 = *(unsigned __int8 *)(a1 + 256) - 1;
        if (v34 > 4) {
          CFNumberRef v35 = "kIdle";
        }
        else {
          CFNumberRef v35 = off_1019F1A60[(char)v34];
        }
        uint64_t v36 = subscriber::asString();
        uint64_t v37 = subscriber::asString();
        uint64_t v38 = subscriber::asString();
        *(_DWORD *)uint64_t v58 = 136315906;
        *(void *)&v58[4] = v35;
        *(_WORD *)&v58[12] = 2080;
        *(void *)&v58[14] = v36;
        *(_WORD *)&v58[22] = 2080;
        *(void *)&v58[24] = v37;
        *(_WORD *)&v58[32] = 2080;
        *(void *)&v58[34] = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [2] Switch State %s for Primary (%s) Secondary (%s) - Data (%s)", v58, 0x2Au);
      }
      *(unsigned char *)(a1 + 256) = 1;
      unint64_t v39 = dispatch_group_create();
      unint64_t v40 = v39;
      if (v39)
      {
        dispatch_retain(v39);
        dispatch_group_enter(v40);
        dispatch_release(v40);
      }
      sub_100058DB0(v58, "/cc/assertions/prevent_baseband_reset");
      ctu::rest::AssertionHandle::create();
      if ((char)v58[23] < 0) {
        operator delete(*(void **)v58);
      }
      long long v41 = *(_OWORD *)buf;
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v42 = *(std::__shared_weak_count **)(a1 + 152);
      *(_OWORD *)(a1 + 144) = v41;
      if (v42)
      {
        sub_10004D2C8(v42);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      if (v40)
      {
        dispatch_retain(v40);
        dispatch_group_enter(v40);
      }
      *(void *)std::string buf = a1;
      *(void *)uint64_t v58 = off_1019F17F0;
      *(void *)&v58[8] = a1;
      *(void *)&uint8_t buf[8] = 0;
      *(void *)&v58[16] = v40;
      *(void *)&v58[24] = v58;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(v58);
      if (!*(void *)(a1 + 112))
      {
        sub_100058DB0(v58, "/cc/exclusive_assertions/baseband_operation");
        ctu::rest::AssertionHandle::create();
        if ((char)v58[23] < 0) {
          operator delete(*(void **)v58);
        }
        long long v43 = *(_OWORD *)buf;
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        char v44 = *(std::__shared_weak_count **)(a1 + 120);
        *(_OWORD *)(a1 + 112) = v43;
        if (v44)
        {
          sub_10004D2C8(v44);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        if (v40)
        {
          dispatch_retain(v40);
          dispatch_group_enter(v40);
        }
        *(void *)std::string buf = a1;
        *(void *)uint64_t v58 = off_1019F1870;
        *(void *)&v58[8] = a1;
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&v58[16] = v40;
        *(void *)&v58[24] = v58;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(v58);
      }
      if (*v4 && *(_DWORD *)(a1 + 196) == *v4
        || (int v45 = *(_DWORD *)(a1 + 188)) != 0 && *(_DWORD *)(a1 + 192) == v45
        || (int v46 = (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72)), v46 == 1)
        || v46 == 2 && *(_DWORD *)(a1 + 192))
      {
        sub_100058DB0(v58, "/cc/assertions/airplane_mode");
        ctu::rest::AssertionHandle::create();
        if ((char)v58[23] < 0) {
          operator delete(*(void **)v58);
        }
        long long v47 = *(_OWORD *)buf;
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        v48 = *(std::__shared_weak_count **)(a1 + 136);
        *(_OWORD *)(a1 + 128) = v47;
        if (v48)
        {
          sub_10004D2C8(v48);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        if (v40)
        {
          dispatch_retain(v40);
          dispatch_group_enter(v40);
        }
        *(void *)std::string buf = a1;
        *(void *)uint64_t v58 = off_1019F18F0;
        *(void *)&v58[8] = a1;
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&v58[16] = v40;
        *(void *)&v58[24] = v58;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(v58);
      }
      else
      {
        *(unsigned char *)(a1 + 256) = 2;
        uint64_t v49 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v50 = subscriber::asString();
          uint64_t v51 = subscriber::asString();
          uint64_t v52 = subscriber::asString();
          *(_DWORD *)uint64_t v58 = 136315906;
          *(void *)&v58[4] = "kWaitingForAssertions";
          *(_WORD *)&v58[12] = 2080;
          *(void *)&v58[14] = v50;
          *(_WORD *)&v58[22] = 2080;
          *(void *)&v58[24] = v51;
          *(_WORD *)&v58[32] = 2080;
          *(void *)&v58[34] = v52;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I [3b] Switch State %s for Primary (%s) Secondary (%s) - Data (%s)", v58, 0x2Au);
        }
      }
      operator new();
    }
    uint64_t v53 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v58 = 0;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I [-] Requested Configuration already set", v58, 2u);
    }
    sub_100631CBC(a1);
    return;
  }
  if (v24 == 5)
  {
    sub_100631F28(a1);
    return;
  }
  xpc_object_t v30 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    if ((v24 - 1) > 4) {
      uint64_t v31 = "kIdle";
    }
    else {
      uint64_t v31 = off_1019F1A60[(char)(v24 - 1)];
    }
    uint64_t v54 = subscriber::asString();
    uint64_t v55 = subscriber::asString();
    uint64_t v56 = subscriber::asString();
    *(_DWORD *)uint64_t v58 = 136315906;
    *(void *)&v58[4] = v31;
    *(_WORD *)&v58[12] = 2080;
    *(void *)&v58[14] = v54;
    *(_WORD *)&v58[22] = 2080;
    *(void *)&v58[24] = v55;
    *(_WORD *)&v58[32] = 2080;
    *(void *)&v58[34] = v56;
    uint64_t v11 = "[-] Operation running (%s) - Primary (%s) Secondary (%s) - Data (%s)";
    uint64_t v12 = v30;
    uint32_t v13 = 42;
    goto LABEL_114;
  }
}

void sub_1006315A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (v20)
  {
    dispatch_group_leave(v20);
    dispatch_release(v20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100631680(uint64_t a1, int a2)
{
}

void sub_100631688(uint64_t a1, int a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136315138;
    uint64_t v12 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received updated slot (%s)", (uint8_t *)&v11, 0xCu);
  }
  if (subscriber::isValidSimSlot())
  {
    *(_DWORD *)(a1 + 18sub_10010E764((uint64_t)&a9, 0) = a2;
    if (*(unsigned char *)(a1 + 312))
    {
      if (*(void *)(a1 + 304))
      {
        if (*(unsigned char *)(a1 + 268))
        {
          sub_1000607A8(a1 + 280, *(_DWORD *)(a1 + 264) == a2);
          sub_100555F38((void *)(a1 + 280));
        }
        else
        {
          sub_1000607A8(a1 + 280, *(_DWORD *)(a1 + 176) == a2);
          if (*(unsigned char *)(a1 + 312))
          {
            sub_100060644((void *)(a1 + 280));
            *(unsigned char *)(a1 + 312) = 0;
          }
        }
      }
    }
  }
  int isValidSimSlot = (capabilities::ct *)subscriber::isValidSimSlot();
  if (isValidSimSlot)
  {
    int v6 = *(_DWORD *)(a1 + 176);
    if (v6 == *(_DWORD *)(a1 + 180))
    {
      if (*(_DWORD *)(a1 + 512) != v6)
      {
        *(_DWORD *)(a1 + 512) = v6;
        int isValidSimSlot = *(capabilities::ct **)(a1 + 504);
        if (isValidSimSlot) {
          int isValidSimSlot = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)isValidSimSlot + 48))(isValidSimSlot, a1 + 512);
        }
      }
      if (capabilities::ct::supportsGemini(isValidSimSlot))
      {
        int v7 = *(_DWORD *)(a1 + 180);
        if (*(_DWORD *)(a1 + 552) != v7)
        {
          *(_DWORD *)(a1 + 552) = v7;
          uint64_t v8 = *(void *)(a1 + 544);
          if (v8) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a1 + 552);
          }
        }
      }
    }
    else if (!*(unsigned char *)(a1 + 256))
    {
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = subscriber::asString();
        int v11 = 136315138;
        uint64_t v12 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [1] Slot update mismatch (%s)", (uint8_t *)&v11, 0xCu);
      }
      sub_100630B60(a1);
    }
  }
}

void sub_1006318C8(uint64_t a1, int a2)
{
}

void sub_1006318D0(uint64_t a1, uint64_t a2)
{
  BOOL v4 = (SubscriptionSlotConfiguration *)(a1 + 192);
  if (!SubscriptionSlotConfiguration::isValid())
  {
LABEL_25:
    int v9 = (os_log_t *)(a1 + 40);
    SubscriptionSlotConfiguration::log(v4, (const ctu::OsLogLogger *)(a1 + 40), "last known config based on disabled iccid");
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v11 = a2;
      }
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Publishing disable physical SIM ICCID (%s)", buf, 0xCu);
    }
    if (SubscriptionSlotConfiguration::operator!=())
    {
      if (!*(unsigned char *)(a1 + 256))
      {
        uint64_t v12 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [1] Slot configuration mismatched", buf, 2u);
        }
        sub_100630B60(a1);
      }
    }
    else
    {
      sub_1002F965C(a1 + 560, (uint64_t *)(a1 + 184));
    }
    return;
  }
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (!v5)
  {
    uint64_t v6 = *(void *)(a1 + 384);
    uint64_t v7 = *(void *)(a1 + 392);
    while (1)
    {
      if (v6 == v7) {
        goto LABEL_25;
      }
      if (*(char *)(v6 + 95) < 0)
      {
        if (!*(void *)(v6 + 80)) {
          goto LABEL_19;
        }
      }
      else if (!*(unsigned char *)(v6 + 95))
      {
        goto LABEL_19;
      }
      if (*(_DWORD *)v6 == 2)
      {
        *(_DWORD *)(a1 + 196) = *(_DWORD *)(v6 + 4);
      }
      else if (*(_DWORD *)v6 == 1)
      {
        *(_DWORD *)BOOL v4 = *(_DWORD *)(v6 + 4);
      }
LABEL_19:
      v6 += 168;
    }
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_100631B68(buf, a1, a2);
  if (BYTE8(v24))
  {
    if (*(_DWORD *)buf == 2)
    {
      *(_DWORD *)(a1 + 196) = 0;
    }
    else if (*(_DWORD *)buf == 1)
    {
      *(_DWORD *)BOOL v4 = 0;
    }
    sub_100397998((uint64_t)buf);
    goto LABEL_25;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint32_t v13 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find disabled ICCID, just complete it", v13, 2u);
  }
  sub_100631CBC(a1);
  sub_100397998((uint64_t)buf);
}

void sub_100631B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100397998((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100631B68(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    if (!*(void *)(a3 + 8)) {
      goto LABEL_31;
    }
    BOOL v4 = (void *)(a2 + 392);
    uint64_t v6 = *(void *)(a2 + 384);
    uint64_t v5 = *(void *)(a2 + 392);
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    if (!*(unsigned char *)(a3 + 23)) {
      goto LABEL_31;
    }
    BOOL v4 = (void *)(a2 + 392);
    uint64_t v6 = *(void *)(a2 + 384);
    uint64_t v5 = *(void *)(a2 + 392);
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v14 = *(void *)(a3 + 16);
  }
  char v7 = HIBYTE(v14);
  if (v6 == v5) {
    goto LABEL_27;
  }
  if (v14 >= 0) {
    uint64_t v8 = (void *)HIBYTE(v14);
  }
  else {
    uint64_t v8 = __p[1];
  }
  if (v14 >= 0) {
    int v9 = __p;
  }
  else {
    int v9 = (void **)__p[0];
  }
  while (1)
  {
    uint64_t v10 = *(unsigned __int8 *)(v6 + 95);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = (void *)*(unsigned __int8 *)(v6 + 95);
    }
    else {
      uint64_t v11 = *(void **)(v6 + 80);
    }
    if (v11 != v8) {
      goto LABEL_24;
    }
    if ((v10 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v6 + 95)) {
      goto LABEL_26;
    }
    uint64_t v12 = 0;
    while (*(unsigned __int8 *)(v6 + v12 + 72) == *((unsigned __int8 *)v9 + v12))
    {
      if (v10 == ++v12) {
        goto LABEL_26;
      }
    }
LABEL_24:
    v6 += 168;
    if (v6 == v5) {
      goto LABEL_27;
    }
  }
  if (memcmp(*(const void **)(v6 + 72), v9, *(void *)(v6 + 80))) {
    goto LABEL_24;
  }
LABEL_26:
  uint64_t v5 = v6;
LABEL_27:
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v5 != *v4)
  {
    sub_10002E664((uint64_t)a1, v5);
    a1[168] = 1;
    return;
  }
LABEL_31:
  *a1 = 0;
  a1[168] = 0;
}

void sub_100631CBC(uint64_t a1)
{
  if (capabilities::ct::supportsGemini((capabilities::ct *)a1))
  {
    int v2 = *(_DWORD *)(a1 + 552);
    int v3 = *(_DWORD *)(a1 + 180);
    if (v2 != v3)
    {
      *(_DWORD *)(a1 + 552) = v3;
      uint64_t v4 = *(void *)(a1 + 544);
      int v2 = v3;
      if (v4)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, a1 + 552);
        int v2 = *(_DWORD *)(a1 + 180);
      }
    }
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 192);
    if (v5 == 1) {
      int v2 = 1;
    }
    else {
      int v2 = 2 * (v5 == 2);
    }
  }
  if (*(_DWORD *)(a1 + 512) != v2)
  {
    *(_DWORD *)(a1 + 512) = v2;
    uint64_t v6 = *(void *)(a1 + 504);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 512);
    }
  }
  sub_1002F965C(a1 + 560, (uint64_t *)(a1 + 184));
  if (!*(unsigned char *)(a1 + 600)) {
    sub_10016C840();
  }
  SubscriptionSlotConfiguration::log((SubscriptionSlotConfiguration *)(a1 + 592), (const ctu::OsLogLogger *)(a1 + 40), "Updated subscription configuration");
  char v7 = *(std::__shared_weak_count **)(a1 + 152);
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 168) = 0;
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136315650;
    uint64_t v13 = subscriber::asString();
    __int16 v14 = 2080;
    uint64_t v15 = subscriber::asString();
    __int16 v16 = 2080;
    uint64_t v17 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [5] Configuration completed for Primary (%s) Secondary (%s) - Data (%s)", (uint8_t *)&v12, 0x20u);
  }
  *(unsigned char *)(a1 + 256) = 0;
  *(unsigned char *)(a1 + 333) = 0;
}

void sub_100631EBC(uint64_t a1, uint64_t a2)
{
}

void sub_100631EC4(uint64_t a1, void *a2)
{
  if (SubscriptionSlotConfiguration::isValid())
  {
    *(void *)(a1 + 192) = *a2;
    sub_100630B60(a1);
  }
}

void sub_100631F20(uint64_t a1, void *a2)
{
}

void sub_100631F28(uint64_t a1)
{
  if (*(void *)(a1 + 320))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "[X] Attempting to switch while backoff timer active", buf, 2u);
    }
    return;
  }
  if (*(unsigned char *)(a1 + 104))
  {
    int v3 = (capabilities::ct *)capabilities::ct::supportsDynamicSID((capabilities::ct *)a1);
    if (v3)
    {
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v4 = *(unsigned int *)(a1 + 176);
      if (v4 == *(_DWORD *)(a1 + 180))
      {
        if (capabilities::ct::supportsDataQMIExtensions(v3)) {
          uint64_t v4 = 0;
        }
        else {
          uint64_t v4 = *(unsigned int *)(a1 + 176);
        }
      }
    }
    *(unsigned char *)(a1 + 256) = 4;
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "kSwitching";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v17 = subscriber::asString();
      __int16 v18 = 2080;
      uint64_t v19 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [4] Switch State %s for Primary (%s) Secondary (%s) - Data (%s)", buf, 0x2Au);
    }
    uint64_t v7 = *(void *)(a1 + 72);
    uint64_t v8 = *(void *)(a1 + 384);
    uint64_t v9 = *(void *)(a1 + 392);
    if (v8 != v9)
    {
      uint64_t v10 = v8 + 64;
      do
      {
        if ((subscriber::isEsimCapable() & 1) == 0)
        {
          if (*(char *)(v10 + 31) < 0)
          {
            if (!*(void *)(v10 + 16)) {
              goto LABEL_25;
            }
          }
          else if (!*(unsigned char *)(v10 + 31))
          {
            goto LABEL_25;
          }
          if (!sub_10010E128(a1 + 224, (void **)(v10 + 8)))
          {
            if (*(char *)(v10 + 31) < 0)
            {
              sub_10004FC84(buf, *(void **)(v10 + 8), *(void *)(v10 + 16));
            }
            else
            {
              long long v14 = *(_OWORD *)(v10 + 8);
              *(void *)&uint8_t buf[16] = *(void *)(v10 + 24);
              *(_OWORD *)std::string buf = v14;
            }
            goto LABEL_27;
          }
        }
LABEL_25:
        uint64_t v11 = v10 + 104;
        v10 += 168;
      }
      while (v11 != v9);
    }
    sub_100058DB0(buf, "");
LABEL_27:
    uint64_t v12 = *(void *)(a1 + 184);
    uint64_t v13 = operator new(0x20uLL);
    void *v13 = off_1019F1970;
    v13[1] = a1;
    *((_DWORD *)v13 + 4) = v4;
    *(void *)((char *)v13 + 2sub_10010E764((uint64_t)&a9, 0) = v12;
    v15[3] = v13;
    (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t, void *))(*(void *)v7 + 56))(v7, a1 + 184, buf, v4, v15);
    sub_10035D6A8(v15);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [4] Driver not ready - wait", buf, 2u);
    }
    *(unsigned char *)(a1 + 256) = 5;
  }
}

void sub_100632218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100632250(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100632288(uint64_t a1)
{
}

uint64_t sub_1006322A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006322E8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100632314(ServiceManager::Service *this)
{
  *(void *)this = off_1019F11F0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100632370(ServiceManager::Service *this)
{
  *(void *)this = off_1019F11F0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1006323E0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v3 = (char *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8));

  return sub_100058DB0(a2, v3);
}

uint64_t sub_100632440(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

void sub_100632468(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 32))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_1006324F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100632514()
{
  return 0;
}

uint64_t sub_10063251C()
{
  return 1;
}

uint64_t sub_100632524()
{
  return 0;
}

uint64_t sub_100632530(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))();
}

uint64_t sub_100632558(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

uint64_t *sub_100632580(void **a1)
{
  int v1 = *a1;
  __int16 v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 72);
  if (v3)
  {
    uint64_t v4 = v1[1];
    dispatch_group_t group = v4;
    if (v4)
    {
      dispatch_retain(v4);
      dispatch_group_enter(v4);
    }
    int v5 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v5 || (uint64_t v6 = *(void *)(v2 + 8), (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v8 = v7;
    uint64_t v9 = v6 + 48;
    if (!v6) {
      uint64_t v9 = 0;
    }
    uint64_t v20 = v9;
    long long v21 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    (*(void (**)(uint64_t, dispatch_group_t *, uint64_t *))(*(void *)v3 + 16))(v3, &group, &v20);
    if (v21) {
      std::__shared_weak_count::__release_weak(v21);
    }
    sub_10004D2C8(v8);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v23, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v10 = operator new(0x20uLL);
  void *v10 = off_1019F1270;
  v10[1] = v2;
  _OWORD v10[2] = sub_10062F8A8;
  v10[3] = 0;
  uint64_t v28 = v10;
  ctu::RestModule::observeEvent();
  sub_10003F600(v27);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)(v2 + 72))
  {
    sub_100058DB0(__p, "/cc/props/radio_mode");
    uint64_t v11 = operator new(0x28uLL);
    *uint64_t v11 = off_1019F12F0;
    v11[1] = v2 + 352;
    void v11[2] = v2;
    void v11[3] = sub_10062FC40;
    v11[4] = 0;
    uint64_t v28 = v11;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/sims_on_device");
    uint64_t v12 = operator new(0x28uLL);
    void *v12 = off_1019F1370;
    v12[1] = v2 + 384;
    v12[2] = v2;
    v12[3] = sub_10062FD94;
    void v12[4] = 0;
    uint64_t v28 = v12;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/prefs-nb/imeis");
    uint64_t v13 = operator new(0x28uLL);
    void *v13 = off_1019F13F0;
    v13[1] = v2 + 360;
    v13[2] = v2;
    v13[3] = sub_10062FF44;
    _OWORD v13[4] = 0;
    uint64_t v28 = v13;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/eos_state");
    long long v14 = operator new(0x28uLL);
    void *v14 = off_1019F1470;
    v14[1] = v2 + 456;
    _OWORD v14[2] = v2;
    v14[3] = sub_10062FFC4;
    void v14[4] = 0;
    uint64_t v28 = v14;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/emergency_mode");
    uint64_t v15 = operator new(0x28uLL);
    *uint64_t v15 = off_1019F14F0;
    v15[1] = v2 + 460;
    v15[2] = v2;
    v15[3] = sub_100630048;
    void v15[4] = 0;
    uint64_t v28 = v15;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/vinyl_info");
    v27[0] = off_1019F1570;
    v27[1] = v2 + 408;
    xpc_object_t v27[2] = v2;
    uint64_t v28 = v27;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/carrier_bundles");
    __int16 v16 = operator new(0x28uLL);
    void *v16 = off_1019F15F0;
    v16[1] = v2 + 432;
    _OWORD v16[2] = v2;
    v16[3] = sub_10063004C;
    v16[4] = 0;
    uint64_t v28 = v16;
    ctu::RestModule::observeProperty();
    sub_10003F600(v27);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    sub_100630174((void *)(v2 + 480), v2 + 336);
    sub_100630234((void *)(v2 + 520), v2 + 336);
    sub_1002D7FE0((void *)(v2 + 560), v2 + 336);
  }
  sub_100088C88((uint64_t *)&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100632AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_group_t group, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_10003F600((void *)(v22 - 72));
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100632B88(capabilities::ct *a1)
{
  uint64_t v1 = **(void **)a1;
  if (capabilities::ct::supportsGemini(a1)) {
    *(_DWORD *)(v1 + 552) = 0;
  }
  else {
    *(_DWORD *)(v1 + 552) = 1;
  }
  uint64_t v2 = *(void *)(v1 + 544);
  if (v2) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 48))(v2, v1 + 552);
  }
  uint64_t v3 = *(void *)(v1 + 72);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  operator delete();
}

void sub_100632C4C()
{
}

uint64_t *sub_100632C78(void **a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(*v1 + 72);
  if (v2)
  {
    uint64_t v3 = v1[1];
    dispatch_group_t group = v3;
    if (v3)
    {
      dispatch_retain(v3);
      dispatch_group_enter(v3);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 32))(v2, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  sub_100088C88((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100632D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100632D58()
{
}

__n128 sub_100632D6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019F1270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100632DC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100632DF8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100632E40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100632E80()
{
}

void sub_100632E90()
{
}

__n128 sub_100632EA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F12F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100632EF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F12F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100632F30(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_100632FAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100632FEC()
{
}

void sub_100632FFC()
{
}

__n128 sub_100633010(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F1370;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100633064(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10063309C(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100633118(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100633158()
{
}

void sub_100633168()
{
}

__n128 sub_10063317C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F13F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006331D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F13F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100633208(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1000FF5C4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_1006332C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1006332E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100633320()
{
}

void sub_100633330()
{
}

__n128 sub_100633344(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F1470;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100633398(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006333D0(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_10063344C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10063348C()
{
}

void sub_10063349C()
{
}

__n128 sub_1006334B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F14F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100633504(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F14F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10063353C(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(EmergencyMode **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1006335B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006335F8()
{
}

void sub_100633608()
{
}

__n128 sub_10063361C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F1570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100633668(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100633698(uint64_t a1, xpc_object_t *a2)
{
  sub_10010C4E0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 16) + 88) + 32);

  return v3();
}

uint64_t sub_1006336FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10063373C()
{
}

void sub_10063374C()
{
}

__n128 sub_100633760(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F15F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006337B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F15F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1006337EC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_1006338AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1006338C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100633904()
{
}

void sub_100633914()
{
}

void *sub_100633928(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F1670;
  result[1] = v3;
  return result;
}

uint64_t sub_100633970(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F1670;
  a2[1] = v2;
  return result;
}

void sub_10063399C(uint64_t a1, int *a2)
{
}

uint64_t sub_1006339A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006339E4()
{
}

void sub_1006339F0(uint64_t a1, int *a2)
{
  xpc_object_t v8 = 0;
  uint64_t v2 = (ctu::rest::detail *)*a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/baseband_data_slot");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100633AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100633AEC()
{
}

void *sub_100633B00(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F16F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100633B48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F16F0;
  a2[1] = v2;
  return result;
}

void sub_100633B74(uint64_t a1, int *a2)
{
}

uint64_t sub_100633B7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100633BBC()
{
}

void sub_100633BC8(uint64_t a1, int *a2)
{
  xpc_object_t v8 = 0;
  uint64_t v2 = (ctu::rest::detail *)*a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/props/user_preferred_data_slot");
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100633C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t *sub_100633CC0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v23 = a1;
  uint64_t v24 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 72))
  {
    if (*(_DWORD *)(v1 + 16) == 1)
    {
      if (*(unsigned char *)(v1 + 12))
      {
        uint64_t v3 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = subscriber::asString();
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Ignoring instance %s - restoring user selection to %s", buf, 0x16u);
        }
      }
    }
    if (*(unsigned char *)(v2 + 312))
    {
      if (*(void *)(v2 + 304))
      {
        uint64_t v4 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::string buf = 0;
          uint64_t v5 = "Running temporary switch already - failing";
LABEL_41:
          _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, v5, buf, 2u);
          goto LABEL_11;
        }
        goto LABEL_11;
      }
      int v8 = *(unsigned __int8 *)(v1 + 12);
      int v11 = *(unsigned __int8 *)(v2 + 268);
      if (*(unsigned char *)(v1 + 12)) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12)
      {
        uint64_t v9 = (unsigned int *)(v1 + 8);
        uint64_t v10 = *(unsigned int *)(v1 + 8);
        if (v10 == *(_DWORD *)(v2 + 264)) {
          goto LABEL_37;
        }
        goto LABEL_17;
      }
      if ((v8 != 0) == (v11 != 0))
      {
LABEL_37:
        uint64_t v22 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Requested temporary instance already set to temporary instance", buf, 2u);
        }
        goto LABEL_39;
      }
    }
    else
    {
      int v8 = *(unsigned __int8 *)(v1 + 12);
    }
    uint64_t v9 = (unsigned int *)(v1 + 8);
    if (!v8)
    {
      uint64_t v10 = *(unsigned int *)(v2 + 176);
      if (v10 == *(_DWORD *)(v2 + 180))
      {
LABEL_39:
        char v6 = 1;
        goto LABEL_12;
      }
      goto LABEL_27;
    }
    uint64_t v10 = *v9;
LABEL_17:
    if (*(_DWORD *)(v2 + 180) == v10)
    {
      memset(&buf[5], 0, 43);
      *(_DWORD *)std::string buf = *v9;
      uint8_t buf[4] = *((unsigned char *)v9 + 4);
      *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(v1 + 16);
      sub_100634178(v2 + 264, (uint64_t *)buf);
      sub_1000607A8(v1 + 24, 1);
      goto LABEL_33;
    }
LABEL_27:
    if ((subscriber::isValidSimSlot() & 1) == 0)
    {
      uint64_t v20 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid instance (%s)", buf, 0xCu);
      }
      goto LABEL_11;
    }
    memset(buf, 0, 48);
    int v13 = *v9;
    uint8_t buf[4] = *((unsigned char *)v9 + 4);
    *(_DWORD *)std::string buf = v13;
    *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(v1 + 16);
    sub_10033A644(&buf[16], v1 + 24);
    sub_100634178(v2 + 264, (uint64_t *)buf);
    long long v14 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(v1 + 16);
      uint64_t v16 = subscriber::asString();
      uint64_t v17 = "Requesting";
      if (v15 == 1) {
        uint64_t v17 = "Restoring";
      }
      *(_DWORD *)long long v25 = 136315394;
      *(void *)&v25[4] = v17;
      *(_WORD *)&v25[12] = 2080;
      *(void *)&v25[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s temporary data subscription to %s", v25, 0x16u);
    }
    uint64_t v18 = *(void *)(v2 + 72);
    uint64_t v19 = *(unsigned int *)(v1 + 16);
    *(void *)long long v25 = off_1019F1770;
    *(void *)&v25[8] = v2;
    *(void *)&v25[16] = v10;
    char v26 = v25;
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)v18 + 64))(v18, v10, v19, v25);
    sub_10035D6A8(v25);
LABEL_33:
    sub_100060644(&buf[16]);
    goto LABEL_13;
  }
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v5 = "No driver present";
    goto LABEL_41;
  }
LABEL_11:
  char v6 = 0;
LABEL_12:
  sub_1000607A8(v1 + 24, v6);
LABEL_13:
  sub_100634128(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_1006340DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100060644(v10);
  sub_100634128(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100634128(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 24));
    operator delete();
  }
  return result;
}

uint64_t sub_100634178(uint64_t a1, uint64_t *a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 48);
  int v4 = *((_DWORD *)a2 + 2);
  uint64_t v6 = *a2;
  uint64_t v5 = (uint64_t)(a2 + 2);
  *(void *)a1 = v6;
  *(_DWORD *)(a1 + 8) = v4;
  char v7 = (void *)(a1 + 16);
  if (v3)
  {
    sub_10033A644(v7, v5);
  }
  else
  {
    sub_1000DFC90((uint64_t)v7, v5);
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1;
}

void sub_1006341D0()
{
}

__n128 sub_1006341E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F1770;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100634230(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1770;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *sub_100634260(uint64_t a1, uint64_t a2, int *a3)
{
  int v3 = *a3;
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5 != *a3)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      uint64_t v9 = subscriber::asString();
      __int16 v10 = 2080;
      uint64_t v11 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Temporary Data Switch failed, attempted to set (%s), received (%s)", (uint8_t *)&v8, 0x16u);
    }
  }
  __n128 result = (void *)subscriber::isValidSimSlot();
  if (result) {
    *(_DWORD *)(v4 + 18sub_10010E764((uint64_t)&a9, 0) = v3;
  }
  if (*(unsigned char *)(v4 + 312))
  {
    if (*(void *)(v4 + 304))
    {
      sub_1000607A8(v4 + 280, v5 == v3);
      return sub_100555F38((void *)(v4 + 280));
    }
  }
  return result;
}

uint64_t sub_100634388(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006343C8()
{
}

uint64_t *sub_1006343D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 72))
  {
    if (*(char *)(v1 + 55) < 0)
    {
      if (!*(void *)(v1 + 40))
      {
LABEL_9:
        sub_100634518(v2 + 224, v1 + 8);
        sub_100630B60(v2);
        goto LABEL_10;
      }
    }
    else if (!*(unsigned char *)(v1 + 55))
    {
      goto LABEL_9;
    }
    std::string::operator=((std::string *)(v2 + 200), (const std::string *)(v1 + 32));
    goto LABEL_9;
  }
  int v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "No driver present", buf, 2u);
  }
LABEL_10:
  sub_1006344B4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100634498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1006344B4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    sub_10005CD2C(v1 + 8, *(char **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100634518(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if (a1 != a2) {
      sub_1000EA390((uint64_t **)a1, *(void **)a2, (void *)(a2 + 8));
    }
  }
  else
  {
    sub_1000C6BDC((uint64_t *)a1, a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t *sub_100634574(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  int v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 72))
  {
    if (capabilities::ct::supportsDynamicSID(a1))
    {
      if (*(char *)(v1 + 31) < 0)
      {
        sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
      }
      else
      {
        long long v3 = *(_OWORD *)(v1 + 8);
        uint64_t v11 = *(void *)(v1 + 24);
        *(_OWORD *)std::string __p = v3;
      }
      sub_1000EA30C((uint64_t)buf, __p, 1);
      sub_100634768(v2 + 224, buf);
      sub_10005CD2C((uint64_t)buf, *(char **)((char *)v13 + 4));
      if (SHIBYTE(v11) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_16;
    }
    if (*(unsigned char *)(v2 + 248) && sub_10010E128(v2 + 224, (void **)(v1 + 8)))
    {
LABEL_16:
      std::string::operator=((std::string *)(v2 + 200), (const std::string *)(v1 + 8));
      sub_100630B60(v2);
      goto LABEL_17;
    }
    int v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = (void *)(v1 + 8);
      if (*(char *)(v1 + 31) < 0) {
        uint64_t v6 = (void *)*v6;
      }
      *(_DWORD *)std::string buf = 136315138;
      v13[0] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Attempting to set data to (%s) but its not configured", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "No driver present", buf, 2u);
    }
  }
LABEL_17:
  sub_1001102C4(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100634720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_10005CD2C(v18 - 48, *(char **)(v18 - 40));
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1001102C4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100634768(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_1006347E0(a1, a2);
  }
  else
  {
    *(void *)a1 = *a2;
    long long v3 = a2 + 1;
    uint64_t v4 = a2[1];
    *(void *)(a1 + 8) = v4;
    uint64_t v5 = a1 + 8;
    uint64_t v6 = a2[2];
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      *(void *)(v4 + 16) = v5;
      *a2 = v3;
      *long long v3 = 0;
      a2[2] = 0;
    }
    else
    {
      *(void *)a1 = v5;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_1006347E0(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  *uint64_t v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    *uint64_t v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

void *sub_10063484C(void *a1)
{
  *a1 = off_1019F17F0;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_1006348A4(void *a1)
{
  *a1 = off_1019F17F0;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_10063491C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F17F0;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100634970(uint64_t a1, void *a2)
{
  *a2 = off_1019F17F0;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_10063499C(uint64_t a1)
{
}

void sub_1006349A4(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void *sub_1006349E0(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    v3[3] = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(v3);
  }
  return result;
}

void sub_100634A54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100634A68(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100634AA8()
{
}

void *sub_100634AB4(void *a1)
{
  *a1 = off_1019F1870;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100634B0C(void *a1)
{
  *a1 = off_1019F1870;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100634B84(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F1870;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100634BD8(uint64_t a1, void *a2)
{
  *a2 = off_1019F1870;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100634C04(uint64_t a1)
{
}

void sub_100634C0C(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100634C48(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  long long v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "true";
    if (!v2) {
      uint64_t v4 = "false";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband exclusive operation assertion, granted (%s)", (uint8_t *)&v5, 0xCu);
  }
  if (v2)
  {
    uint64_t v7 = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&v5);
  }
}

void sub_100634D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100634D38(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100634D78()
{
}

void *sub_100634D84(void *a1)
{
  *a1 = off_1019F18F0;
  int v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100634DDC(void *a1)
{
  *a1 = off_1019F18F0;
  int v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    long long v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100634E54(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  int v2 = operator new(0x18uLL);
  void *v2 = off_1019F18F0;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100634EA8(uint64_t a1, void *a2)
{
  *a2 = off_1019F18F0;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100634ED4(uint64_t a1)
{
}

void sub_100634EDC(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void *sub_100634F18(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    v3[3] = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(v3);
  }
  return result;
}

void sub_100634F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100634FA0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100634FE0()
{
}

void sub_100634FEC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = *(unsigned __int8 *)(*a1 + 256);
  if (v2 != 2)
  {
    if (v2 != 1)
    {
      uint64_t v4 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((v2 - 3) > 2) {
          int v5 = "kIdle";
        }
        else {
          int v5 = off_1019F1A88[(char)(v2 - 3)];
        }
        int v6 = 136315138;
        uint64_t v7 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid state: %s", (uint8_t *)&v6, 0xCu);
      }
LABEL_8:
      operator delete();
    }
    if ((*(void *)(v1 + 352) & 0x1FFFFFFFFLL) != 0)
    {
      *(unsigned char *)(v1 + 256) = 3;
      long long v3 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315906;
        uint64_t v7 = "kWaitingForRadioOffline";
        __int16 v8 = 2080;
        uint64_t v9 = subscriber::asString();
        __int16 v10 = 2080;
        uint64_t v11 = subscriber::asString();
        __int16 v12 = 2080;
        uint64_t v13 = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [3c] Switch State %s for Primary (%s) Secondary (%s) - Data (%s)", (uint8_t *)&v6, 0x2Au);
      }
      goto LABEL_8;
    }
  }
  sub_100631F28(*a1);
  goto LABEL_8;
}

void sub_1006351A4()
{
}

void sub_1006351CC()
{
}

__n128 sub_1006351E0(uint64_t a1)
{
  int v2 = (char *)operator new(0x20uLL);
  *(void *)int v2 = off_1019F1970;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100635234(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F1970;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10063526C(uint64_t a1, unsigned char *a2, int *a3)
{
  int v4 = *a3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (*a2)
  {
    int v6 = (void *)(a1 + 20);
    if (SubscriptionSlotConfiguration::isValid()) {
      *(void *)(v5 + 192) = *v6;
    }
    if (subscriber::isValidSimSlot())
    {
      *(_DWORD *)(v5 + 328) = 0;
      *(_DWORD *)(v5 + 18sub_10010E764((uint64_t)&a9, 0) = v4;
    }
    if (SubscriptionSlotConfiguration::operator==())
    {
      if (!*(_DWORD *)(v5 + 184) && !*(_DWORD *)(v5 + 188)
        || (v8 = *(_DWORD *)(v5 + 176), int v7 = *(_DWORD *)(v5 + 180), v7 == v8))
      {
        *(unsigned char *)(v5 + 332) = 0;
        sub_100631CBC(v5);
        return;
      }
    }
    else
    {
      int v8 = *(_DWORD *)(v5 + 176);
      int v7 = *(_DWORD *)(v5 + 180);
    }
    if (v7 != v8)
    {
      long long v14 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Data instance changed while running an operation, re-attempt immediately", buf, 2u);
      }
      sub_100631F28(v5);
      return;
    }
  }
  if (*(_DWORD *)(a1 + 16) == v4)
  {
    if (!SubscriptionSlotConfiguration::operator!=())
    {
      if (*(_DWORD *)(v5 + 180) != *(_DWORD *)(v5 + 176))
      {
        int v15 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = subscriber::asString();
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [X] The default data instance changed to %s while setting data to %s", buf, 0x16u);
        }
      }
      goto LABEL_28;
    }
    uint64_t v9 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      __int16 v10 = "[X] the requested config mismatched - configuration changed during operation";
      uint64_t v11 = v9;
      uint32_t v12 = 2;
LABEL_21:
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      __int16 v10 = "[X] Switch to (%s) failed received instance (%s) instead";
      uint64_t v11 = v13;
      uint32_t v12 = 22;
      goto LABEL_21;
    }
  }
LABEL_28:
  unsigned int v16 = *(_DWORD *)(v5 + 328);
  if (v16 >= 5)
  {
    uint64_t v17 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v34;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "[!] Maximum retries attempted. Could not switch to (%s)", buf, 0xCu);
    }
    *(_DWORD *)(v5 + 328) = 0;
    sub_100631CBC(v5);
    if (*(unsigned char *)(v5 + 332))
    {
      uint64_t v18 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "[!!] Failed to switch data instance", buf, 2u);
      }
      return;
    }
    *(unsigned char *)(v5 + 332) = 1;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 56));
    long long v25 = ServiceMap;
    if (v26 < 0)
    {
      uint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v26;
    xpc_object_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
    if (v30)
    {
      uint64_t v32 = v30[3];
      uint64_t v31 = (std::__shared_weak_count *)v30[4];
      if (v31)
      {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v25);
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v31);
        char v33 = 0;
        if (!v32) {
          goto LABEL_54;
        }
        goto LABEL_52;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    std::mutex::unlock(v25);
    uint64_t v31 = 0;
    char v33 = 1;
    if (!v32)
    {
LABEL_54:
      if (v33) {
        return;
      }
      uint64_t v23 = v31;
      goto LABEL_56;
    }
LABEL_52:
    sub_100058DB0(__p, "Data Subscription failure.");
    long long v43 = 0;
    (*(void (**)(uint64_t, void **, void, unsigned char *))(*(void *)v32 + 32))(v32, __p, 0, buf);
    sub_1000595E4(buf);
    if (SHIBYTE(v41) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_54;
  }
  *(_DWORD *)(v5 + 328) = v16 + 1;
  Registry::getTimerService(&v37, *(Registry **)(v5 + 56));
  uint64_t v19 = v37;
  sub_100058DB0(v35, "Subscription Configuration Retry");
  *(_OWORD *)std::string __p = *(_OWORD *)v35;
  uint64_t v41 = v36;
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  *(void *)std::string buf = off_1019F19E0;
  *(void *)&uint8_t buf[8] = v5;
  long long v43 = buf;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, unsigned char *))(*(void *)v19 + 40))(&v39, v19, __p, 1, 5000000, 0, buf);
  sub_10003B34C(buf);
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v20 = v39;
  uint64_t v39 = 0;
  uint64_t v21 = *(void *)(v5 + 320);
  *(void *)(v5 + 32sub_10010E764((uint64_t)&a9, 0) = v20;
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    uint64_t v22 = v39;
    uint64_t v39 = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
  uint64_t v23 = v38;
  if (v38) {
LABEL_56:
  }
    sub_10004D2C8(v23);
}

void sub_100635828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  sub_1000595E4(&a25);
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006358B8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006358F8()
{
}

void sub_100635908()
{
}

void *sub_10063591C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F19E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100635964(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F19E0;
  a2[1] = v2;
  return result;
}

void sub_100635990(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100635A70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100635AB0()
{
}

void sub_100635ABC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 320);
  *(void *)(v1 + 32sub_10010E764((uint64_t)&a9, 0) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(_DWORD *)(v1 + 176) == *(_DWORD *)(v1 + 180) && SubscriptionSlotConfiguration::operator==())
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v5 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I {-] Requested data instance matches last known instance (%s)", buf, 0xCu);
    }
    sub_100631CBC(v1);
  }
  else
  {
    sub_100631F28(v1);
  }
  operator delete();
}

void sub_100635BF0()
{
}

uint64_t sub_100635C1C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  *(void *)a1 = off_1019C4A10;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "euicc.attest.cli");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v12, &v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  *(void *)a1 = off_1019F1AB0;
  *(void *)(a1 + 16) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 24) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 32) = a3;
  *(_OWORD *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = *a4;
  uint64_t v9 = a4[1];
  *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100635D28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100635D4C(uint64_t a1, void *a2, uint64_t a3)
{
  sub_100637B4C(a2, &v8);
  int v6 = v9;
  v10[0] = v8;
  v10[1] = v9;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_100635C1C(a1, a2, a3, v10);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return a1;
}

void sub_100635DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100635DF0(void *a1)
{
  *a1 = off_1019F1AB0;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_100635E6C(void *a1)
{
  sub_100635DF0(a1);

  operator delete();
}

void sub_100635EA4(uint64_t a1, _OWORD *a2, const void **a3, const void **a4, uint64_t a5, xpc_object_t *a6)
{
  __int16 v51 = 0;
  v49[0] = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 72) + 16))(v49);
  uint32_t v12 = (void *)HIBYTE(v50);
  if (v50 < 0) {
    uint32_t v12 = v49[1];
  }
  if (v12)
  {
    sub_1002D1364((Registry **)(a1 + 16), a6);
    if (SHIBYTE(v50) < 0)
    {
      sub_10004FC84(__p, v49[0], (unint64_t)v49[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v49;
      uint64_t v48 = v50;
    }
    sub_10033F214(a5, 1);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_109;
  }
  sub_1002D0DCC((uint64_t)a6, v51);
  *(void *)long long v76 = a1;
  *(_OWORD *)&v76[8] = *a2;
  sub_10002FD9C(&v77, a3);
  sub_100637AC0(&v78, a4);
  sub_10033ECA0((uint64_t)v79, a5);
  xpc_object_t v13 = *a6;
  xpc_object_t object = v13;
  if (v13) {
    xpc_retain(v13);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v82 = 0;
  long long v14 = (char *)operator new(0x58uLL);
  *(void *)long long v14 = off_1019F1BD0;
  *(_OWORD *)(v14 + 8) = *(_OWORD *)v76;
  int v15 = v77;
  *((void *)v14 + 3) = *(void *)&v76[16];
  *((void *)v14 + 4) = v15;
  long long v77 = 0;
  sub_100637AC0((const void **)v14 + 5, &v78);
  sub_10033F0E0((uint64_t)(v14 + 48), (uint64_t)v79);
  xpc_object_t v16 = object;
  *((void *)v14 + 1sub_10010E764((uint64_t)&a9, 0) = object;
  if (v16) {
    xpc_retain(v16);
  }
  else {
    *((void *)v14 + 1sub_10010E764((uint64_t)&a9, 0) = xpc_null_create();
  }
  uint64_t v82 = v14;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  uint64_t v18 = ServiceMap;
  if (v19 < 0)
  {
    uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_23:
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)int v75 = 0u;
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v25 + 200))(&v72, v25);
  if (SHIBYTE(v73) < 0)
  {
    sub_10004FC84(__dst, (void *)v72, *((unint64_t *)&v72 + 1));
  }
  else
  {
    *(_OWORD *)std::string __dst = v72;
    *(void *)&long long v67 = v73;
  }
  *(void *)&long long v68 = 0;
  if (SBYTE7(v67) < 0)
  {
    sub_10004FC84(buf, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__dst;
    double v84 = (void (*)(uint64_t, void *))v67;
  }
  v70[0] = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v27 = (void *)v68;
    *(void **)&long long v68 = v70[0];
    long long v62 = v27;
    sub_1000558F4((const void **)&v62);
  }
  if (SHIBYTE(v84) < 0) {
    operator delete(*(void **)buf);
  }
  cf[0] = (CFTypeRef)v68;
  *(void *)&long long v68 = 0;
  sub_1000558F4((const void **)&v68);
  if (SBYTE7(v67) < 0) {
    operator delete(__dst[0]);
  }
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v25 + 112))(&cf[1], v25);
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v25 + 208))(v70, v25);
  if (SHIBYTE(v71) < 0)
  {
    sub_10004FC84(__dst, v70[0], (unint64_t)v70[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v70;
    *(void *)&long long v67 = v71;
  }
  *(void *)long long v59 = 0;
  if (SBYTE7(v67) < 0)
  {
    sub_10004FC84(buf, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__dst;
    double v84 = (void (*)(uint64_t, void *))v67;
  }
  *(void *)&long long v68 = 0;
  if (ctu::cf::convert_copy())
  {
    CFTypeRef v28 = *(CFTypeRef *)v59;
    *(void *)long long v59 = v68;
    long long v62 = (void *)v28;
    sub_1000558F4((const void **)&v62);
  }
  if (SHIBYTE(v84) < 0) {
    operator delete(*(void **)buf);
  }
  v75[0] = *(CFTypeRef *)v59;
  *(void *)long long v59 = 0;
  sub_1000558F4((const void **)v59);
  if (SBYTE7(v67) < 0) {
    operator delete(__dst[0]);
  }
  unsigned int v29 = (CodingUtility *)(*(void *(**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v25 + 184))(&v75[1], v25);
  if (SHIBYTE(v71) < 0) {
    operator delete(v70[0]);
  }
  if (SHIBYTE(v73) < 0) {
    operator delete((void *)v72);
  }
  long long v68 = 0uLL;
  uint64_t v69 = 0;
  CodingUtility::generateUUID((uint64_t *)&v68, v29);
  *(_OWORD *)std::string __dst = 0u;
  long long v67 = 0u;
  long long v62 = (void *)cf[0];
  if (cf[0]) {
    CFRetain(cf[0]);
  }
  long long v63 = (void *)cf[1];
  if (cf[1]) {
    CFRetain(cf[1]);
  }
  uint64_t v64 = (void *)v75[0];
  if (v75[0]) {
    CFRetain(v75[0]);
  }
  CFTypeRef v65 = v75[1];
  if (v75[1])
  {
    CFRetain(v75[1]);
    xpc_object_t v30 = (void *)v65;
  }
  else
  {
    xpc_object_t v30 = 0;
  }
  sub_1002D0814(v62, v63, v64, v30, (uint64_t)__dst);
  sub_1000558F4(&v65);
  sub_1000558F4((const void **)&v64);
  sub_1000558F4((const void **)&v63);
  sub_1000558F4((const void **)&v62);
  if (!BYTE8(v67))
  {
    buf[0] = 0;
    LOBYTE(v88[0]) = 0;
    sub_100058DB0(v59, "Malformed request");
    if (!v82) {
      sub_10007B600();
    }
    (*(void (**)(char *, uint8_t *, long long *, uint8_t *))(*(void *)v82 + 48))(v82, buf, &v68, v59);
    if (SHIBYTE(v61) < 0) {
      operator delete(*(void **)v59);
    }
    sub_10013E528((uint64_t)buf);
    char v33 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v59 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Cannot form discovery request", v59, 2u);
    }
    goto LABEL_104;
  }
  *(void *)long long v59 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  sub_10012CD04(v59, (char *)__dst[0], (char *)__dst[1], (char *)__dst[1] - (char *)__dst[0]);
  uint64_t v31 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = v59;
    if (v61 < 0) {
      uint64_t v32 = *(uint8_t **)v59;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I discovery service request. %s", buf, 0xCu);
  }
  uint64_t v56 = 0;
  int v57 = 0;
  uint64_t v58 = 0;
  sub_100637AF8(buf, "Content-Type", "application/json");
  sub_100058DB0(v88, "X-Client-Request-ID");
  if (SHIBYTE(v69) < 0)
  {
    sub_10004FC84(&v89, (void *)v68, *((unint64_t *)&v68 + 1));
  }
  else
  {
    long long v89 = v68;
    v90[0] = v69;
  }
  sub_1002369E0((uint64_t)&v56, (long long *)buf, 2);
  for (uint64_t i = 0; i != -12; i -= 6)
  {
    CFNumberRef v35 = &buf[i * 8];
    if (SHIBYTE(v90[i]) < 0) {
      operator delete(*((void **)v35 + 9));
    }
    if ((char)v35[71] < 0) {
      operator delete(*((void **)v35 + 6));
    }
  }
  uint64_t v36 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  uint64_t v37 = v36;
  if (v38 < 0)
  {
    uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(v36);
  *(void *)std::string buf = v38;
  uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)buf);
  if (v42)
  {
    uint64_t v44 = v42[3];
    long long v43 = (std::__shared_weak_count *)v42[4];
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v37);
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v43);
      char v45 = 0;
      goto LABEL_87;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v37);
  long long v43 = 0;
  char v45 = 1;
LABEL_87:
  sub_100636C78(&v52, a1, @"kEuiccDiscoveryOverrideUrl", @"https://deviceactivations.apple.com/activation/session");
  memset(buf, 0, sizeof(buf));
  double v84 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v53 = *(_OWORD *)buf;
  uint64_t v54 = v84;
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, void **, uint64_t *))(*(void *)v44 + 16))(&v55, v44, 3, v53, &v56);
  int v46 = *(std::__shared_weak_count **)(a1 + 48);
  *(_OWORD *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v55;
  long long v55 = 0uLL;
  if (v46)
  {
    sub_10004D2C8(v46);
    if (*((void *)&v55 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v55 + 1));
    }
  }
  if (SHIBYTE(v54) < 0) {
    operator delete(v53[0]);
  }
  sub_1000558F4(&v52);
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v43);
  }
  *(void *)std::string buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  double v84 = sub_100637144;
  int v85 = &unk_1019F1AC8;
  uint64_t v86 = a1;
  sub_10063950C((uint64_t)&v87, (uint64_t)v81);
  if (SHIBYTE(v69) < 0)
  {
    sub_10004FC84(&v89, (void *)v68, *((unint64_t *)&v68 + 1));
  }
  else
  {
    long long v89 = v68;
    v90[0] = v69;
  }
  sub_100636FA4(*(void *)(a1 + 32), (void *)(a1 + 40), (uint64_t)__dst, (uint64_t)buf);
  if (SHIBYTE(v90[0]) < 0) {
    operator delete((void *)v89);
  }
  sub_100639488(&v87);
  sub_10010C0E0((uint64_t)&v56, v57);
  if (SHIBYTE(v61) < 0) {
    operator delete(*(void **)v59);
  }
  if (BYTE8(v67) && __dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }
LABEL_104:
  if (SHIBYTE(v69) < 0) {
    operator delete((void *)v68);
  }
  sub_1000558F4(&v75[1]);
  sub_1000558F4(v75);
  sub_1000558F4(&cf[1]);
  sub_1000558F4(cf);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  sub_100639488(v81);
  xpc_release(object);
  xpc_object_t object = 0;
  sub_1000DBADC(v79);
  sub_100127DDC(&v78);
  sub_100030068(&v77);
LABEL_109:
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[0]);
  }
}

void sub_100636938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, int a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,void *a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62,const void *a63)
{
  sub_100639488(v67);
  sub_10010C0E0((uint64_t)&a32, (void *)a33);
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a49 && a46)
  {
    a47 = (uint64_t)a46;
    operator delete(a46);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  sub_1001A2238(&a63);
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  sub_100639488((void *)(v68 - 240));
  sub_100636C2C((uint64_t)&a67);
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(a1);
}

void sub_100636BFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100636BE4);
}

void sub_100636C14()
{
}

void sub_100636C1C()
{
}

void sub_100636C24()
{
}

uint64_t sub_100636C2C(uint64_t a1)
{
  *(void *)(a1 + 72) = 0;
  sub_1000DBADC((void *)(a1 + 40));
  sub_100127DDC((const void **)(a1 + 32));
  sub_100030068((const void **)(a1 + 24));
  return a1;
}

void sub_100636C78(const void **a1, uint64_t a2, uint64_t a3, const void *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 16));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    OsLogContext v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v31 = v10;
  long long v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v31);
  if (v14)
  {
    uint64_t v16 = v14[3];
    int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_31;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  int v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_31:
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    *a1 = a4;
    return;
  }
LABEL_10:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v16 + 32))(v16)) {
    goto LABEL_31;
  }
  uint64_t v18 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 16));
  uint64_t v19 = v18;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v18);
  uint64_t v31 = v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)&v31);
  if (!v24)
  {
    uint64_t v26 = 0;
LABEL_19:
    std::mutex::unlock(v19);
    uint64_t v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  uint64_t v26 = v24[3];
  uint64_t v25 = (std::__shared_weak_count *)v24[4];
  if (!v25) {
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v19);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
  if (!v26)
  {
LABEL_29:
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v25);
    }
    goto LABEL_31;
  }
LABEL_20:
  char v30 = v27;
  uint64_t v28 = kCommCenterPreferencesNoBackupAppID;
  (*(void (**)(uint64_t, void, const CFStringRef, const CFStringRef))(*(void *)v26 + 48))(v26, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  *a1 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v26 + 40))(&v31, v26, a3, v28, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100056248(a1, (CFTypeRef *)&v31);
  sub_1000577C4((const void **)&v31);
  if (*a1) {
    unsigned int v29 = sub_1000810B8;
  }
  else {
    unsigned int v29 = 0;
  }
  if (!v29)
  {
    sub_1000558F4(a1);
    char v27 = v30;
    goto LABEL_29;
  }
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100636F54(_Unwind_Exception *a1, int a2, char a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  if ((a3 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100636FA4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  (*(void (**)(void, uint64_t))(*(void *)*a2 + 8))(*a2, a1);
  (*(void (**)(void, uint64_t))(*(void *)*a2 + 56))(*a2, a3);
  (*(void (**)(void, uint64_t))(*(void *)*a2 + 208))(*a2, 1);
  (*(void (**)(void, uint64_t))(*(void *)*a2 + 120))(*a2, 1);
  (*(void (**)(double))(*(void *)*a2 + 96))(10.0);
  (*(void (**)(void, uint64_t))(*(void *)*a2 + 16))(*a2, a4);
  uint64_t v7 = *a2;
  __p[1] = 0;
  uint64_t v9 = 0;
  __p[0] = 0;
  (*(void (**)(uint64_t, void **))(*(void *)v7 + 40))(v7, __p);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100637128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100637144(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (!*a2)
  {
    uint64_t v7 = a1 + 40;
    v24[0] = 0;
    char v25 = 0;
    uint64_t v8 = a1 + 72;
LABEL_12:
    sub_100058DB0(buf, "no response");
    goto LABEL_13;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))(*a2) == 200)
  {
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v23 = 0;
    (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(v22);
    char v5 = v3[1];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = v22;
      if (v23 < 0) {
        int v6 = (void **)v22[0];
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I discovery service response. %s", (uint8_t *)buf, 0xCu);
    }
    uint64_t v27 = 0;
    memset(buf, 0, sizeof(buf));
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(__p, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v22;
      uint64_t v21 = v23;
    }
    sub_1002D0980((uint64_t *)__p, (uint64_t)buf);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    __dst.__r_.__value_.__s.__data_[0] = 0;
    char v19 = 0;
    if ((_BYTE)v27)
    {
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = buf[0];
      }
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v18, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
      }
      else {
        std::string v18 = buf[1];
      }
      char v19 = 1;
    }
    sub_100058DB0(v15, "");
    uint64_t v13 = *(void *)(a1 + 64);
    if (!v13) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, std::string *, uint64_t, void **))(*(void *)v13 + 48))(v13, &__dst, a1 + 72, v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    sub_10013E528((uint64_t)&__dst);
    long long v14 = (std::__shared_weak_count *)v3[6];
    v3[5] = 0;
    v3[6] = 0;
    if (v14) {
      sub_10004D2C8(v14);
    }
    sub_10013E528((uint64_t)buf);
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    return;
  }
  uint64_t v9 = *a2;
  uint64_t v7 = a1 + 40;
  v24[0] = 0;
  uint64_t v8 = a1 + 72;
  char v25 = 0;
  if (!v9) {
    goto LABEL_12;
  }
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  std::to_string(buf, v10);
LABEL_13:
  uint64_t v11 = *(void *)(v7 + 24);
  if (!v11) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *, uint64_t, std::string *))(*(void *)v11 + 48))(v11, v24, v8, buf);
  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf[0].__r_.__value_.__l.__data_);
  }
  sub_10013E528((uint64_t)v24);
  uint64_t v12 = (std::__shared_weak_count *)v3[6];
  v3[5] = 0;
  v3[6] = 0;
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_1006374A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10013E528((uint64_t)&__p);
  sub_10013E528(v40 - 112);
  if (a39 < 0) {
    operator delete(a34);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100637550(uint64_t a1, uint64_t a2)
{
  sub_10063950C(a1 + 40, a2 + 40);
  __n128 result = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)__n128 result = v5;
  return result;
}

void sub_1006375B8(_Unwind_Exception *a1)
{
  sub_100639488(v1);
  _Unwind_Resume(a1);
}

void *sub_1006375CC(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }

  return sub_100639488((void *)(a1 + 40));
}

void sub_100637610(uint64_t a1, void *a2)
{
  int v4 = *(void **)(a1 + 32);
  if (!*a2)
  {
    uint64_t v9 = v4[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v26[0] = 0;
      char v27 = 0;
LABEL_18:
      sub_100058DB0(&buf, "no response");
      goto LABEL_19;
    }
    goto LABEL_14;
  }
  int v5 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
  uint64_t v6 = *a2;
  if (v5 == 200)
  {
    v24[0] = 0;
    v24[1] = 0;
    uint64_t v25 = 0;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v6 + 48))(v24, v6);
    uint64_t v7 = v4[1];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = v24;
      if (v25 < 0) {
        uint64_t v8 = (void **)v24[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I attestation service response. %s", (uint8_t *)&buf, 0xCu);
    }
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long buf = 0u;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(__p, v24[0], (unint64_t)v24[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v24;
      uint64_t v23 = v25;
    }
    sub_1002D0554((uint64_t *)__p, (uint64_t)&buf);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    LOBYTE(v18[0]) = 0;
    char v21 = 0;
    if (BYTE8(v32))
    {
      memset(v18, 0, sizeof(v18));
      sub_10005C928(v18, (const void *)buf, *((uint64_t *)&buf + 1), *((void *)&buf + 1) - buf);
      memset(v19, 0, sizeof(v19));
      sub_10005C928(v19, *((const void **)&v29 + 1), v30, v30 - *((void *)&v29 + 1));
      memset(v20, 0, sizeof(v20));
      sub_10005C928(v20, (const void *)v31, *((uint64_t *)&v31 + 1), *((void *)&v31 + 1) - v31);
      char v21 = 1;
    }
    sub_100058DB0(v16, "");
    uint64_t v14 = *(void *)(a1 + 64);
    if (!v14) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void *, void **))(*(void *)v14 + 48))(v14, v18, v16);
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    sub_100273EC4((uint64_t)v18);
    int v15 = (std::__shared_weak_count *)v4[8];
    v4[7] = 0;
    unsigned char v4[8] = 0;
    if (v15) {
      sub_10004D2C8(v15);
    }
    sub_100273EC4((uint64_t)&buf);
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    return;
  }
  uint64_t v9 = v4[1];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (v6)
    {
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
LABEL_15:
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I attestation service response failure: %d", (uint8_t *)&buf, 8u);
      uint64_t v6 = *a2;
      goto LABEL_16;
    }
LABEL_14:
    int v10 = 0;
    goto LABEL_15;
  }
LABEL_16:
  v26[0] = 0;
  char v27 = 0;
  if (!v6) {
    goto LABEL_18;
  }
  int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
  std::to_string((std::string *)&buf, v11);
LABEL_19:
  uint64_t v12 = *(void *)(a1 + 64);
  if (!v12) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *, long long *))(*(void *)v12 + 48))(v12, v26, &buf);
  if (SBYTE7(v29) < 0) {
    operator delete((void *)buf);
  }
  sub_100273EC4((uint64_t)v26);
  uint64_t v13 = (std::__shared_weak_count *)v4[8];
  v4[7] = 0;
  unsigned char v4[8] = 0;
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_1006379E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100637AAC(uint64_t a1, uint64_t a2)
{
  return sub_1006395A4(a1 + 40, a2 + 40);
}

void *sub_100637AB8(uint64_t a1)
{
  return sub_100637CA0((void *)(a1 + 40));
}

const void **sub_100637AC0(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void *sub_100637AF8(void *a1, char *a2, char *a3)
{
  int v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100637B30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100637B4C@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x38uLL);
  __n128 result = sub_100637BA8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100637B94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100637BA8(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019F1B80;
  sub_100E0EAA8(a1 + 3, a2);
  return a1;
}

void sub_100637BF0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100637C04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F1B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100637C24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F1B80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100637C78(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100637CA0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100637D24(uint64_t a1)
{
  *(void *)a1 = off_1019F1BD0;
  xpc_release(*(xpc_object_t *)(a1 + 80));
  *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
  sub_1000DBADC((void *)(a1 + 48));
  sub_100127DDC((const void **)(a1 + 40));
  sub_100030068((const void **)(a1 + 32));
  return a1;
}

void sub_100637D8C(uint64_t a1)
{
  *(void *)a1 = off_1019F1BD0;
  xpc_release(*(xpc_object_t *)(a1 + 80));
  *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
  sub_1000DBADC((void *)(a1 + 48));
  sub_100127DDC((const void **)(a1 + 40));
  sub_100030068((const void **)(a1 + 32));

  operator delete();
}

void *sub_100637E14(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = off_1019F1BD0;
  sub_100638B30((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100637E68(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100637E7C(uint64_t a1, void *a2)
{
  *a2 = off_1019F1BD0;
  return sub_100638B30((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

const void **sub_100637EA8(uint64_t a1)
{
  return sub_100638BD8(a1 + 8);
}

void sub_100637EB0(void *a1)
{
  sub_100638BD8((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100637EEC(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  __str.__r_.__value_.__s.__data_[0] = 0;
  char v42 = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    std::string __str = *(std::string *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v7 = *(_OWORD *)(a2 + 24);
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v7;
    v41.__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
    char v42 = 1;
  }
  std::string::size_type v8 = *(void *)(a1 + 8);
  memset(v47, 0, sizeof(v47));
  sub_100058DB0(v47, "");
  sub_100636C78((const void **)v62, v8, @"kEuiccAttestationOverrideUrl", @"https://deviceactivations.apple.com/activation/drm/sign/euicc/sep");
  memset(&v68, 0, sizeof(v68));
  ctu::cf::assign();
  v47[1] = v68;
  sub_1000558F4((const void **)v62);
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v46 = *(void *)(a4 + 16);
  }
  sub_1002D0EC0(a1 + 80, (const char *)__p);
  if (SHIBYTE(v46) < 0) {
    operator delete(__p[0]);
  }
  if (v42)
  {
    std::string::operator=(v47, &__str);
    std::string::operator=(&v47[1], &v41);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(v8 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v68.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "no discovery response. will use default", (uint8_t *)&v68, 2u);
    }
  }
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(a1 + 24);
  sub_10002FD9C(&cf, (const void **)(a1 + 32));
  sub_100637AC0(&v43, (const void **)(a1 + 40));
  *(void *)long long v62 = v8;
  *(_OWORD *)&v62[8] = *(_OWORD *)(a1 + 16);
  sub_100637AC0(&v63, (const void **)(a1 + 40));
  sub_10033ECA0((uint64_t)v64, a1 + 48);
  uint64_t v12 = *(void **)(a1 + 80);
  xpc_object_t object = v12;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v13 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v13 = off_1019F1C50;
  *(_OWORD *)(v13 + 8) = *(_OWORD *)v62;
  *((void *)v13 + 3) = *(void *)&v62[16];
  sub_100637AC0((const void **)v13 + 4, &v63);
  sub_10033F0E0((uint64_t)(v13 + 40), (uint64_t)v64);
  xpc_object_t v14 = object;
  *((void *)v13 + 9) = object;
  if (v14) {
    xpc_retain(v14);
  }
  else {
    *((void *)v13 + 9) = xpc_null_create();
  }
  long long v67 = v13;
  v73[0] = v10;
  v73[1] = v11;
  v72[2] = 0;
  v72[3] = 0;
  if (v10 | v11)
  {
    long long v58 = 0uLL;
    uint64_t v59 = 0;
    ctu::hex((uint64_t *)&v58, (ctu *)v73, (const void *)0x10, v15);
    *(_OWORD *)long long buf = 0u;
    long long v57 = 0u;
    if (SHIBYTE(v59) < 0)
    {
      sub_10004FC84(__dst, (void *)v58, *((unint64_t *)&v58 + 1));
    }
    else
    {
      *(_OWORD *)std::string __dst = v58;
      uint64_t v55 = v59;
    }
    CFTypeRef v53 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_1002D01CC((uint64_t *)__dst, (id *)&v53, buf);
    sub_100030068(&v53);
    if (SHIBYTE(v55) < 0) {
      operator delete(__dst[0]);
    }
    if (!BYTE8(v57))
    {
      v68.__r_.__value_.__s.__data_[0] = 0;
      LOBYTE(v71) = 0;
      sub_100058DB0(&v60, "Malformed Request");
      if (!v67) {
        sub_10007B600();
      }
      (*(void (**)(char *, std::string *, std::string *))(*(void *)v67 + 48))(v67, &v68, &v60);
      if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v60.__r_.__value_.__l.__data_);
      }
      sub_100273EC4((uint64_t)&v68);
      char v19 = *(NSObject **)(v8 + 8);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v60.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Cannot form attestation request", (uint8_t *)&v60, 2u);
      }
      goto LABEL_86;
    }
    v51[0] = 0;
    v51[1] = 0;
    uint64_t v52 = 0;
    sub_10012CD04(v51, *(char **)buf, *(char **)&buf[8], *(void *)&buf[8] - *(void *)buf);
    char v17 = *(NSObject **)(v8 + 8);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      std::string v18 = v51;
      if (v52 < 0) {
        std::string v18 = (void **)v51[0];
      }
      LODWORD(v68.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v68.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I attestation service request. %s", (uint8_t *)&v68, 0xCu);
    }
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    sub_100637AF8(&v68, "Content-Type", "application/json");
    sub_100058DB0(v70, "X-Client-Request-ID");
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(&v71, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long v71 = *a3;
      v72[0] = *((void *)a3 + 2);
    }
    sub_1002369E0((uint64_t)&v48, (long long *)&v68, 2);
    for (uint64_t i = 0; i != -12; i -= 6)
    {
      char v21 = (void **)((char *)&v68.__r_.__value_.__l.__data_ + i * 8);
      if (SHIBYTE(v72[i]) < 0) {
        operator delete(v21[9]);
      }
      if (*((char *)v21 + 71) < 0) {
        operator delete(v21[6]);
      }
    }
    std::string::size_type size = HIBYTE(v47[0].__r_.__value_.__r.__words[2]);
    if ((v47[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v47[0].__r_.__value_.__l.__size_;
    }
    if (size)
    {
      sub_100058DB0(&v68, "X-DS-Token");
      if (SHIBYTE(v47[0].__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v69, v47[0].__r_.__value_.__l.__data_, v47[0].__r_.__value_.__l.__size_);
      }
      else {
        std::string v69 = v47[0];
      }
      uint64_t v61 = 0;
      uint64_t v23 = (uint64_t **)sub_10014BF98((uint64_t)&v48, &v61, (uint64_t)&v68);
      if (!*v23)
      {
        v60.__r_.__value_.__r.__words[2] = 0;
        uint64_t v24 = (char *)operator new(0x50uLL);
        v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
        v60.__r_.__value_.__l.__size_ = (std::string::size_type)&v49;
        v60.__r_.__value_.__s.__data_[16] = 0;
        uint64_t v25 = v24 + 32;
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(v25, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
          uint64_t v26 = (uint64_t *)v60.__r_.__value_.__r.__words[0];
        }
        else
        {
          *(_OWORD *)uint64_t v25 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
          *((void *)v24 + 6) = *((void *)&v68.__r_.__value_.__l + 2);
          uint64_t v26 = (uint64_t *)v24;
        }
        *(std::string *)(v24 + 56) = v69;
        memset(&v69, 0, sizeof(v69));
        v60.__r_.__value_.__s.__data_[16] = 1;
        uint64_t v27 = v61;
        uint64_t *v26 = 0;
        v26[1] = 0;
        v26[2] = v27;
        *uint64_t v23 = v26;
        if (*v48)
        {
          uint64_t v48 = (void *)*v48;
          uint64_t v26 = *v23;
        }
        sub_100046C90(v49, v26);
        ++v50;
        v60.__r_.__value_.__r.__words[0] = 0;
        sub_10010E764((uint64_t)&v60, 0);
      }
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v69.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v68.__r_.__value_.__l.__data_);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v8 + 16));
    long long v29 = ServiceMap;
    if ((v30 & 0x8000000000000000) != 0)
    {
      long long v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        std::string::size_type v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(ServiceMap);
    v60.__r_.__value_.__r.__words[0] = v30;
    uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&v60);
    if (v34)
    {
      uint64_t v36 = v34[3];
      CFNumberRef v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v29);
    CFNumberRef v35 = 0;
    char v37 = 1;
LABEL_75:
    if (SHIBYTE(v47[1].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v60, v47[1].__r_.__value_.__l.__data_, v47[1].__r_.__value_.__l.__size_);
    }
    else {
      std::string v60 = v47[1];
    }
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, std::string *, void **))(*(void *)v36 + 16))(&v68, v36, 3, &v60, &v48);
    uint64_t v38 = *(std::__shared_weak_count **)(v8 + 64);
    *(_OWORD *)(v8 + 56) = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    memset(&v68, 0, 16);
    if (v38)
    {
      sub_10004D2C8(v38);
      if (v68.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)v68.__r_.__value_.__l.__size_);
      }
    }
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v60.__r_.__value_.__l.__data_);
      if (v37)
      {
LABEL_84:
        v68.__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
        v68.__r_.__value_.__l.__size_ = 1174405120;
        v68.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_100637610;
        v69.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1019F1AF8;
        v69.__r_.__value_.__l.__size_ = v8;
        sub_1006395A4((uint64_t)&v69.__r_.__value_.__r.__words[2], (uint64_t)v66);
        sub_100636FA4(*(void *)(v8 + 32), (void *)(v8 + 56), (uint64_t)buf, (uint64_t)&v68);
        sub_100637CA0(&v69.__r_.__value_.__r.__words[2]);
        sub_10010C0E0((uint64_t)&v48, v49);
        if (SHIBYTE(v52) < 0) {
          operator delete(v51[0]);
        }
LABEL_86:
        if (BYTE8(v57) && *(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        if (SHIBYTE(v59) < 0) {
          operator delete((void *)v58);
        }
        goto LABEL_91;
      }
    }
    else if (v37)
    {
      goto LABEL_84;
    }
    sub_10004D2C8(v35);
    goto LABEL_84;
  }
  v68.__r_.__value_.__s.__data_[0] = 0;
  LOBYTE(v71) = 0;
  sub_100058DB0(buf, "Empty CSN");
  if (!v67) {
    sub_10007B600();
  }
  (*(void (**)(char *, std::string *, uint8_t *))(*(void *)v67 + 48))(v67, &v68, buf);
  if (SBYTE7(v57) < 0) {
    operator delete(*(void **)buf);
  }
  sub_100273EC4((uint64_t)&v68);
  char v16 = *(NSObject **)(v8 + 8);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Empty CSN", buf, 2u);
  }
LABEL_91:
  sub_100637CA0(v66);
  xpc_release(object);
  xpc_object_t object = 0;
  sub_1000DBADC(v64);
  sub_100127DDC(&v63);
  sub_100127DDC(&v43);
  sub_100030068(&cf);
  if (SHIBYTE(v47[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v47[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47[0].__r_.__value_.__l.__data_);
  }
  return sub_10013E528((uint64_t)&__str);
}

void sub_100638874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, const void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,void *a63)
{
  sub_10010E764((uint64_t)&a63, 0);
  sub_1001085D8(v74 - 240);
  sub_10010C0E0((uint64_t)&a38, (void *)a39);
  if (a46 < 0) {
    operator delete(__p);
  }
  if (a55 && a52)
  {
    a53 = (uint64_t)a52;
    operator delete(a52);
  }
  if (a62 < 0) {
    operator delete(a57);
  }
  sub_100637CA0(&a73);
  xpc_release(object);
  xpc_object_t object = 0;
  sub_1000DBADC(v73);
  sub_100127DDC(a10);
  sub_100127DDC(&a19);
  sub_100030068(&a20);
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_10013E528((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100638AE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100638B24()
{
}

uint64_t sub_100638B30(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  sub_10002FD9C((const void **)(a1 + 24), (const void **)a2 + 3);
  sub_100637AC0((const void **)(a1 + 32), (const void **)a2 + 4);
  sub_10033ECA0(a1 + 40, (uint64_t)a2 + 40);
  int v5 = (void *)*((void *)a2 + 9);
  *(void *)(a1 + 72) = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *(void *)(a1 + 72) = xpc_null_create();
  }
  return a1;
}

void sub_100638BBC(_Unwind_Exception *a1)
{
  sub_100127DDC(v2);
  sub_100030068(v1);
  _Unwind_Resume(a1);
}

const void **sub_100638BD8(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;
  sub_1000DBADC((void *)(a1 + 40));
  sub_100127DDC((const void **)(a1 + 32));

  return sub_100030068((const void **)(a1 + 24));
}

uint64_t sub_100638C2C(uint64_t a1)
{
  *(void *)a1 = off_1019F1C50;
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;
  sub_1000DBADC((void *)(a1 + 40));
  sub_100127DDC((const void **)(a1 + 32));
  return a1;
}

void sub_100638C8C(uint64_t a1)
{
  *(void *)a1 = off_1019F1C50;
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;
  sub_1000DBADC((void *)(a1 + 40));
  sub_100127DDC((const void **)(a1 + 32));

  operator delete();
}

void *sub_100638D0C(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_1019F1C50;
  sub_1006393AC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100638D60(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100638D74(uint64_t a1, void *a2)
{
  *a2 = off_1019F1C50;
  return sub_1006393AC((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

const void **sub_100638DA0(uint64_t a1)
{
  return sub_10063943C(a1 + 8);
}

void sub_100638DA8(void *a1)
{
  sub_10063943C((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100638DE4(uint64_t a1, long long *a2, uint64_t a3)
{
  LOBYTE(v12) = 0;
  char v18 = 0;
  if (*((unsigned char *)a2 + 72))
  {
    long long v12 = *a2;
    uint64_t v13 = *((void *)a2 + 2);
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    long long v14 = *(long long *)((char *)a2 + 24);
    uint64_t v15 = *((void *)a2 + 5);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    long long v16 = a2[3];
    uint64_t v17 = *((void *)a2 + 8);
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    char v18 = 1;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v31 = *(void *)(a3 + 16);
  }
  sub_1002D0FD0(a1 + 72, (const char *)__p);
  if (SHIBYTE(v31) < 0) {
    operator delete(__p[0]);
  }
  if (v18)
  {
    long long v28 = 0uLL;
    uint64_t v29 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    *(void *)char v19 = 0;
    sub_10005C928(v19, (const void *)v12, *((uint64_t *)&v12 + 1), *((void *)&v12 + 1) - v12);
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    sub_10005C928(&v22, (const void *)v14, *((uint64_t *)&v14 + 1), *((void *)&v14 + 1) - v14);
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    sub_10005C928(&v25, (const void *)v16, *((uint64_t *)&v16 + 1), *((void *)&v16 + 1) - v16);
    long long __dst = 0uLL;
    uint64_t v41 = 0;
    v38[0] = 0;
    v38[1] = 0;
    uint64_t v39 = 0;
    sub_10012CD04(v38, *(char **)v19, v20, (unint64_t)&v20[-*(void *)v19]);
    v36[0] = 0;
    v36[1] = 0;
    uint64_t v37 = 0;
    sub_10012CD04(v36, (char *)v22, v23, v23 - (unsigned char *)v22);
    v34[0] = 0;
    v34[1] = 0;
    uint64_t v35 = 0;
    sub_10012CD04(v34, (char *)v25, v26, v26 - (unsigned char *)v25);
    int v5 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = v34;
      if (v35 < 0) {
        uint64_t v6 = (void **)v34[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I signature: %s", (uint8_t *)&buf, 0xCu);
    }
    ctu::base64::decode();
    ctu::base64::decode();
    ctu::base64::decode();
    char v7 = sub_1003F144C((uint64_t)&buf, (uint64_t)v33, (uint64_t)v32, &__dst);
    if (v32[0])
    {
      v32[1] = v32[0];
      operator delete(v32[0]);
    }
    if (v33[0])
    {
      v33[1] = v33[0];
      operator delete(v33[0]);
    }
    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }
    if (v7) {
      ctu::base64::encode();
    }
    else {
      sub_100058DB0(&v28, "");
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[0]);
    }
    if (SHIBYTE(v37) < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[0]);
    }
    if ((void)__dst)
    {
      *((void *)&__dst + 1) = __dst;
      operator delete((void *)__dst);
    }
    if (v25)
    {
      uint64_t v26 = (char *)v25;
      operator delete(v25);
    }
    if (v22)
    {
      uint64_t v23 = (char *)v22;
      operator delete(v22);
    }
    if (*(void *)v19)
    {
      uint64_t v20 = *(char **)v19;
      operator delete(*(void **)v19);
    }
    char v10 = (*(uint64_t (**)(void, uint64_t, uint64_t, long long *))(**(void **)(v4 + 72) + 24))(*(void *)(v4 + 72), a1 + 16, a1 + 32, &v28);
    sub_1002D1458((Registry **)(v4 + 16), (xpc_object_t *)(a1 + 72), v10);
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&__dst, (void *)v28, *((unint64_t *)&v28 + 1));
    }
    else
    {
      long long __dst = v28;
      uint64_t v41 = v29;
    }
    sub_10033F214(a1 + 40, 1);
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)__dst);
    }
    if (SHIBYTE(v29) < 0)
    {
      uint64_t v9 = (char *)v28;
      goto LABEL_47;
    }
  }
  else
  {
    std::string::size_type v8 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v19 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "no attestation response", v19, 2u);
    }
    sub_1002D10E0((Registry **)(v4 + 16), (xpc_object_t *)(a1 + 72));
    sub_100058DB0(v19, "");
    sub_10033F214(a1 + 40, 0);
    if (SHIBYTE(v21) < 0)
    {
      uint64_t v9 = *(char **)v19;
LABEL_47:
      operator delete(v9);
    }
  }
  return sub_100273EC4((uint64_t)&v12);
}

void sub_100639220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_100273EC4((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100639360(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006393A0()
{
}

uint64_t sub_1006393AC(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  sub_100637AC0((const void **)(a1 + 24), (const void **)a2 + 3);
  sub_10033ECA0(a1 + 32, (uint64_t)(a2 + 2));
  int v5 = (void *)*((void *)a2 + 8);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *(void *)(a1 + 64) = xpc_null_create();
  }
  return a1;
}

void sub_100639428(_Unwind_Exception *a1)
{
  sub_100127DDC(v1);
  _Unwind_Resume(a1);
}

const void **sub_10063943C(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  sub_1000DBADC((void *)(a1 + 32));

  return sub_100127DDC((const void **)(a1 + 24));
}

void *sub_100639488(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10063950C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1006395A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

BOOL sub_10063963C(const void *a1, CFArrayRef theArray)
{
  BOOL result = 0;
  if (a1 && theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v6 = Count;
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
      if (CFEqual(a1, ValueAtIndex))
      {
        return 1;
      }
      else
      {
        CFIndex v8 = 1;
        do
        {
          CFIndex v9 = v8;
          if (v6 == v8) {
            break;
          }
          char v10 = CFArrayGetValueAtIndex(theArray, v8);
          int v11 = CFEqual(a1, v10);
          CFIndex v8 = v9 + 1;
        }
        while (!v11);
        return v9 < v6;
      }
    }
  }
  return result;
}

uint64_t sub_1006396EC(CBSignUtilityLogger *a1, const __CFDictionary *a2, int a3)
{
  MyInstance = (CBSignUtilityLogger *)CBSignUtilityLogger::getMyInstance(a1);
  CBSignUtilityLogger::setLogFunction(MyInstance, (void (*)(const char *))sub_100639A0C);
  uint64_t v7 = 1;
  uint64_t v8 = VerifyCarrierBundleSignature();
  if ((v8 & 1) == 0)
  {
    if (!sub_10121F6B4())
    {
      uint64_t v8 = sub_10121F67C();
      if (!v8) {
        goto LABEL_13;
      }
    }
    uint64_t v8 = VerifyCarrierBundleSignature();
    uint64_t v7 = v8;
  }
  if (!a3 || !v7) {
    goto LABEL_40;
  }
  if (!a2)
  {
LABEL_13:
    uint64_t v7 = 0;
    goto LABEL_40;
  }
  uint64_t v25 = 0;
  uint64_t v26 = &off_101A0BD40;
  v24[0] = 0;
  v24[1] = 0;
  sub_1007ED50C((uint64_t)a1, v24);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"SupportedSIMs");
  CFArrayRef v10 = Value;
  if (Value)
  {
    CFTypeID v11 = CFGetTypeID(Value);
    if (v11 != CFArrayGetTypeID()) {
      CFArrayRef v10 = 0;
    }
  }
  if (SHIBYTE(v25) < 0)
  {
    sub_10004FC84(v21, v24[0], (unint64_t)v24[1]);
  }
  else
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)v24;
    uint64_t v22 = v25;
  }
  if (SHIBYTE(v22) < 0)
  {
    sub_10004FC84(__p, v21[0], (unint64_t)v21[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v21;
    uint64_t v29 = v22;
  }
  uint64_t v27 = 0;
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v31 = v29;
  }
  uint64_t v32 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v12 = v27;
    uint64_t v27 = v32;
    unsigned int v33 = v12;
    sub_1000558F4(&v33);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v13 = v27;
  *(void *)uint64_t v23 = v27;
  uint64_t v27 = 0;
  sub_1000558F4(&v27);
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0)
  {
    operator delete(v21[0]);
    if (v10) {
      goto LABEL_29;
    }
  }
  else if (v10)
  {
LABEL_29:
    BOOL v14 = sub_10063963C(v13, v10);
    goto LABEL_37;
  }
  CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(a2, @"SupportedCountryIds");
  CFArrayRef v16 = v15;
  if (v15)
  {
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 == CFArrayGetTypeID()) {
      CFArrayRef v18 = v16;
    }
    else {
      CFArrayRef v18 = 0;
    }
  }
  else
  {
    CFArrayRef v18 = 0;
  }
  BOOL v14 = sub_10063963C(*(const void **)v23, v18);
LABEL_37:
  uint64_t v7 = v14;
  sub_1000558F4((const void **)v23);
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v26);
LABEL_40:
  char v19 = (CBSignUtilityLogger *)CBSignUtilityLogger::getMyInstance((CBSignUtilityLogger *)v8);
  CBSignUtilityLogger::destroyMyInstance(v19);
  return v7;
}

void sub_100639978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,int a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a23);
  _Unwind_Resume(a1);
}

void sub_100639A0C(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "cb.verification");
  uint64_t v2 = *(NSObject **)&v4[4];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v3 = 136315138;
    *(void *)long long v4 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100639AD0(const void **a1)
{
  md = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  char v5 = 0;
  sub_10063BE34(&md, 0x14uLL, &v5);
  int v2 = *((char *)a1 + 23);
  if (v2 >= 0) {
    int v3 = a1;
  }
  else {
    int v3 = *a1;
  }
  if (v2 >= 0) {
    CC_LONG v4 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    CC_LONG v4 = *((_DWORD *)a1 + 2);
  }
  CC_SHA1(v3, v4, md);
  ctu::hex();
  if (md)
  {
    uint64_t v7 = md;
    operator delete(md);
  }
}

void sub_100639B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100639B74@<X0>(CFPropertyListRef propertyList@<X0>, uint64_t a2@<X1>, void **a3@<X8>)
{
  *a3 = 0;
  CFDataRef Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  CFDataRef v15 = Data;
  if (Data) {
    CFIndex v6 = sub_10008324C;
  }
  else {
    CFIndex v6 = 0;
  }
  if (v6)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    long long v12 = 0;
    sub_10005C928(&v12, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    memset(__p, 0, 24);
    sub_10005C928(__p, v12, (uint64_t)v13, v13 - (unsigned char *)v12);
    sub_10063BEB4(v10, 0, Data, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v10 != a3)
    {
      __p[0] = *a3;
      *a3 = v10[0];
      v10[0] = 0;
      sub_100030068((const void **)__p);
    }
    sub_100030068((const void **)v10);
    if (v12)
    {
      uint64_t v13 = v12;
      operator delete(v12);
    }
  }
  else
  {
    sub_100058DB0(v10, "ps.key");
    sCTLogServer();
    ctu::StaticLogger::StaticLogger();
    uint64_t v7 = __p[4];
    ctu::StaticLogger::~StaticLogger((ctu::StaticLogger *)__p);
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (v11 < 0) {
      operator delete(v10[0]);
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = "";
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#W %s%sfailed to serialize propertylist", (uint8_t *)__p, 0x16u);
    }
  }
  return sub_100030068((const void **)&v15);
}

void sub_100639D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,const void *a21,void *a22,uint64_t a23)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100030068(&a21);
  sub_100030068(v23);
  _Unwind_Resume(a1);
}

const void **sub_100639DDC@<X0>(const __CFData *a1@<X0>, uint64_t a2@<X1>, CFPropertyListRef *a3@<X8>)
{
  *a3 = 0;
  uint64_t v9 = 0;
  CFDataRef data = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_10005C928(&v7, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  std::string __p = 0;
  long long v12 = 0;
  uint64_t v13 = 0;
  sub_10005C928(&__p, v7, (uint64_t)v8, v8 - (unsigned char *)v7);
  sub_10063BEB4(&data, 1, a1, &__p);
  if (__p)
  {
    long long v12 = __p;
    operator delete(__p);
  }
  if (v7)
  {
    uint64_t v8 = v7;
    operator delete(v7);
  }
  if (data) {
    char v5 = sub_10008324C;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    *a3 = CFPropertyListCreateWithData(0, data, 0, 0, 0);
    std::string __p = 0;
    sub_1000577C4((const void **)&__p);
  }
  return sub_100030068((const void **)&data);
}

void sub_100639EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15)
{
  sub_100030068(&a13);
  sub_1000577C4(v15);
  _Unwind_Resume(a1);
}

void sub_100639F14(size_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  buf[0] = 0;
  sub_10063BE34(a2, a1, buf);
  if (SecRandomCopyBytes(kSecRandomDefault, a1, (void *)*a2))
  {
    sub_100058DB0(&__p, "ps.key");
    sCTLogServer();
    ctu::StaticLogger::StaticLogger();
    CC_LONG v4 = v15;
    ctu::StaticLogger::~StaticLogger((ctu::StaticLogger *)buf);
    if (v6) {
      sub_10004D2C8(v6);
    }
    if (v8 < 0) {
      operator delete(__p);
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *__error();
      *(_DWORD *)long long buf = 136315650;
      CFArrayRef v10 = "";
      __int16 v11 = 2080;
      long long v12 = "";
      __int16 v13 = 1024;
      int v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sSecRandomCopyBytes failed, errno %d", buf, 0x1Cu);
    }
    a2[1] = *a2;
  }
}

void sub_10063A068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  char v19 = *(void **)v17;
  if (*(void *)v17)
  {
    *(void *)(v17 + 8) = v19;
    operator delete(v19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10063A0C0(uint64_t a1)
{
  *(void *)a1 = off_1019F1CF0;
  uint64_t v2 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_10063DA94(*(void **)(a1 + 40));
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_10063A150(uint64_t a1)
{
  sub_10063A0C0(a1);

  operator delete();
}

void sub_10063A188()
{
}

void sub_10063A228(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  operator delete();
}

uint64_t sub_10063A27C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10063C7B0(a1);
  if (capabilities::ct::supportsThumperSourcing(v6))
  {
    uint64_t v7 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I set bootstrap dictionary for security key exchange", buf, 2u);
    }
    uint64_t v8 = *(void *)(a1 + 56);
    sub_10063CAE0(buf, a1);
    (*(void (**)(uint64_t, void))(*(void *)v8 + 40))(v8, *(void *)buf);
    sub_100057D78((const void **)buf);
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_10063CD48;
  void v11[3] = &unk_1019F1DA0;
  v11[4] = a3;
  v11[5] = a1;
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v9 + 64))(v9, a2, v11);
}

void sub_10063A3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10063A3CC(uint64_t a1, std::string::value_type *a2)
{
  CC_LONG v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      int v5 = a2;
    }
    else {
      int v5 = *(std::string::value_type **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I activating secret %s", buf, 0xCu);
  }
  if ((void **)(a1 + 40) == sub_100046F68(a1 + 32, (void **)a2))
  {
    long long v34 = 0uLL;
    unsigned int v33 = 0;
    CFIndex v6 = (std::string *)sub_100058DB0(buf, "com.apple.thumper.");
    int v7 = a2[23];
    if (v7 >= 0) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = *(const std::string::value_type **)a2;
    }
    if (v7 >= 0) {
      std::string::size_type v9 = a2[23];
    }
    else {
      std::string::size_type v9 = *((void *)a2 + 1);
    }
    CFArrayRef v10 = std::string::append(v6, v8, v9);
    __int16 v11 = (void *)v10->__r_.__value_.__r.__words[0];
    std::string::size_type size = (void *)v10->__r_.__value_.__l.__size_;
    v44[0] = v10->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v44 + 3) = *(_DWORD *)((char *)&v10->__r_.__value_.__r.__words[2] + 3);
    int v13 = SHIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    if (v13 < 0)
    {
      sub_10004FC84(__dst, v11, (unint64_t)size);
      if (SHIBYTE(v36) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_19:
        char v45 = 0;
        if (SHIBYTE(v47) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v47;
        }
        uint64_t v48 = 0;
        if (ctu::cf::convert_copy())
        {
          int v14 = v45;
          char v45 = v48;
          uint64_t v49 = v14;
          sub_1000558F4(&v49);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v37 = (void *)v45;
        char v45 = 0;
        sub_1000558F4(&v45);
        if (SHIBYTE(v47) < 0) {
          operator delete(__p[0]);
        }
        int v15 = sub_1000BF7B4(a1 + 16, v37);
        CFArrayRef v16 = sub_1000558F4((const void **)&v37);
        if (SHIBYTE(v36) < 0)
        {
          operator delete(__dst[0]);
          if (v15)
          {
LABEL_30:
            if (v15 == 1)
            {
              uint64_t v25 = *(NSObject **)(a1 + 8);
              CFArrayRef v16 = (const void **)os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
              if (!v16)
              {
LABEL_47:
                uint64_t v21 = 0;
                uint64_t v22 = 0;
                goto LABEL_48;
              }
              if (a2[23] >= 0) {
                uint64_t v26 = a2;
              }
              else {
                uint64_t v26 = *(std::string::value_type **)a2;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v26;
              CFArrayRef v18 = "#I No secret %s in keychain";
              char v19 = v25;
              uint32_t v20 = 12;
            }
            else
            {
              if (v15 != 2) {
                goto LABEL_47;
              }
              uint64_t v17 = *(NSObject **)(a1 + 8);
              CFArrayRef v16 = (const void **)os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
              if (!v16) {
                goto LABEL_47;
              }
              *(_WORD *)long long buf = 0;
              CFArrayRef v18 = "#E KeyChain is locked - fatal problem";
              char v19 = v17;
              uint32_t v20 = 2;
            }
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
            goto LABEL_47;
          }
        }
        else if (v15)
        {
          goto LABEL_30;
        }
        ctu::base64::decode();
        uint64_t v21 = *(void **)buf;
        unsigned int v33 = *(void **)buf;
        long long v34 = *(_OWORD *)&buf[8];
        uint64_t v22 = *(void *)&buf[8];
        uint64_t v23 = *(NSObject **)(a1 + 8);
        CFArrayRef v16 = (const void **)os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
        if (v21 == (void *)v22)
        {
          if (v16)
          {
            if (a2[23] >= 0) {
              uint64_t v31 = a2;
            }
            else {
              uint64_t v31 = *(std::string::value_type **)a2;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v31;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E Secret %s is not of valid format", buf, 0xCu);
          }
          uint64_t v21 = (void *)v22;
        }
        else if (v16)
        {
          if (a2[23] >= 0) {
            uint64_t v24 = a2;
          }
          else {
            uint64_t v24 = *(std::string::value_type **)a2;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Secret %s was successfully restored from keychain", buf, 0xCu);
        }
LABEL_48:
        if (SHIBYTE(v40) < 0) {
          operator delete(v38);
        }
        if (SHIBYTE(v43) < 0)
        {
          operator delete(v41);
          if ((v13 & 0x80000000) == 0) {
            goto LABEL_52;
          }
        }
        else if ((v13 & 0x80000000) == 0)
        {
          goto LABEL_52;
        }
        operator delete(v11);
LABEL_52:
        if ((void *)v22 == v21)
        {
          if (!capabilities::ct::supportsThumperSourcing((capabilities::ct *)v16))
          {
LABEL_74:
            if (v21)
            {
              *(void *)&long long v34 = v21;
              operator delete(v21);
            }
            return;
          }
          memset(buf, 0, sizeof(buf));
          sub_100639F14(0x20uLL, buf);
          if (v21) {
            operator delete(v21);
          }
          uint64_t v21 = *(void **)buf;
          unsigned int v33 = *(void **)buf;
          long long v34 = *(_OWORD *)&buf[8];
          uint64_t v27 = *(void **)&buf[8];
          long long v28 = *(NSObject **)(a1 + 8);
          BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
          if (v27 == v21)
          {
            if (v29)
            {
              if (a2[23] >= 0) {
                uint64_t v32 = a2;
              }
              else {
                uint64_t v32 = *(std::string::value_type **)a2;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v32;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#E failed to create secret %s", buf, 0xCu);
            }
            goto LABEL_74;
          }
          if (v29)
          {
            if (a2[23] >= 0) {
              std::string::size_type v30 = a2;
            }
            else {
              std::string::size_type v30 = *(std::string::value_type **)a2;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v30;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I created secret %s", buf, 0xCu);
          }
          sub_10063D4B8(a1, a2);
          uint64_t v21 = v33;
          uint64_t v22 = v34;
        }
        if ((void *)v22 != v21)
        {
          if (a2[23] < 0)
          {
            sub_10004FC84(buf, *(void **)a2, *((void *)a2 + 1));
            uint64_t v21 = v33;
            uint64_t v22 = v34;
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)a2;
            *(void *)&uint8_t buf[16] = *((void *)a2 + 2);
          }
          __int16 v51 = 0;
          uint64_t v52 = 0;
          uint64_t v53 = 0;
          sub_10005C928(&v51, v21, v22, v22 - (void)v21);
          sub_10063D17C((uint64_t **)(a1 + 32), (void **)buf, (uint64_t)buf);
          if (v51)
          {
            uint64_t v52 = v51;
            operator delete(v51);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          sub_10063D818((capabilities::ct *)a1, (uint64_t *)a2, (uint64_t)&v33);
          uint64_t v21 = v33;
        }
        goto LABEL_74;
      }
    }
    else
    {
      __dst[0] = v11;
      __dst[1] = size;
      LODWORD(v36) = v44[0];
      *(_DWORD *)((char *)&v36 + 3) = *(_DWORD *)((char *)v44 + 3);
      HIBYTE(v36) = v13;
    }
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v47 = v36;
    goto LABEL_19;
  }
}

void sub_10063A9C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (v40 < 0) {
    operator delete(v39);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063AAC4(uint64_t a1, std::string::value_type *a2, uint64_t a3)
{
  CFIndex v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = *(std::string::value_type **)a2;
    }
    *(_DWORD *)CFArrayRef v16 = 136315138;
    *(void *)&v16[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I imported secret %s", v16, 0xCu);
  }
  sub_10063D4B8(a1, a2);
  uint64_t v8 = (void ***)(a1 + 32);
  std::string::size_type v9 = sub_100046F68(a1 + 32, (void **)a2);
  if ((void **)(a1 + 40) != v9)
  {
    CFArrayRef v10 = (uint64_t *)v9;
    __int16 v11 = (void **)v9[1];
    if (v11)
    {
      do
      {
        long long v12 = v11;
        __int16 v11 = (void **)*v11;
      }
      while (v11);
    }
    else
    {
      int v13 = v9;
      do
      {
        long long v12 = (void **)v13[2];
        BOOL v14 = *v12 == v13;
        int v13 = v12;
      }
      while (!v14);
    }
    if (*v8 == v9) {
      const std::string::value_type *v8 = v12;
    }
    int v15 = *(uint64_t **)(a1 + 40);
    --*(void *)(a1 + 48);
    sub_10005EE6C(v15, v10);
    sub_1003424C4((uint64_t)(v10 + 4));
    operator delete(v10);
  }
  sub_10063D288(v16, (long long *)a2, a3);
  sub_10063D17C((uint64_t **)(a1 + 32), (void **)v16, (uint64_t)v16);
  if (__p)
  {
    char v19 = __p;
    operator delete(__p);
  }
  if (v17 < 0) {
    operator delete(*(void **)v16);
  }
}

void sub_10063AC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10063AC78(capabilities::ct *a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (!v3)
  {
    CFIndex v6 = *((void *)a1 + 1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v12) = 0;
    int v7 = "#I forceResyncSecret, no active account";
    uint64_t v8 = v6;
    uint32_t v9 = 2;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v12, v9);
    return;
  }
  int v5 = sub_100046F68((uint64_t)a1 + 32, (void **)a2);
  if ((void **)((char *)a1 + 40) == v5)
  {
    CFArrayRef v10 = *((void *)a1 + 1);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      __int16 v11 = (void *)a2;
    }
    else {
      __int16 v11 = *(void **)a2;
    }
    int v12 = 136315138;
    int v13 = v11;
    int v7 = "#I forceResyncSecret, no secret %s found";
    uint64_t v8 = v10;
    uint32_t v9 = 12;
    goto LABEL_15;
  }

  sub_10063D818(a1, (uint64_t *)v5 + 4, (uint64_t)(v5 + 7));
}

uint64_t sub_10063ADD4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 80))();
}

void sub_10063ADFC(uint64_t a1@<X0>, const void *a2@<X2>, uint64_t a3@<X3>, void **a4@<X8>)
{
  sub_10063D9FC(a1);
  *a4 = 0;
  if (a2)
  {
    uint64_t v8 = sub_100046F68(a1 + 32, (void **)a3);
    if ((void **)(a1 + 40) == v8)
    {
      __int16 v11 = *(NSObject **)(a1 + 8);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      long long v21 = 0uLL;
      uint64_t v22 = 0;
      ctu::cf::assign();
      *(_OWORD *)CFArrayRef v16 = 0uLL;
      uint64_t v17 = 0;
      int v15 = *(void **)a3;
      if (*(char *)(a3 + 23) >= 0) {
        int v15 = (void *)a3;
      }
      *(_DWORD *)CFTypeRef cf = 136315394;
      *(void *)&cf[4] = v16;
      __int16 v24 = 2080;
      uint64_t v25 = v15;
      BOOL v14 = "#I encrypt %s, no secret %s found";
      goto LABEL_23;
    }
    char v19 = 0;
    uint64_t v20 = 0;
    std::string __p = 0;
    sub_10005C928(&__p, v8[7], (uint64_t)v8[8], (unsigned char *)v8[8] - (unsigned char *)v8[7]);
    sub_100639B74(a2, (uint64_t)&__p, (void **)cf);
    uint32_t v9 = *(void **)cf;
    v16[0] = *(void **)cf;
    if (*(void *)cf) {
      CFRetain(*(CFTypeRef *)cf);
    }
    if (v16 != a4)
    {
      *(void *)&long long v21 = *a4;
      *a4 = v9;
      v16[0] = 0;
      sub_1000577C4((const void **)&v21);
    }
    sub_1000577C4((const void **)v16);
    sub_100030068((const void **)cf);
    if (__p)
    {
      char v19 = __p;
      operator delete(__p);
    }
    if (*a4) {
      CFArrayRef v10 = sub_100080934;
    }
    else {
      CFArrayRef v10 = 0;
    }
    if (!v10)
    {
      __int16 v11 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        long long v21 = 0uLL;
        uint64_t v22 = 0;
        ctu::cf::assign();
        *(_OWORD *)CFArrayRef v16 = v21;
        uint64_t v17 = v22;
        int v12 = *(void **)a3;
        int v13 = v16;
        if (v22 < 0) {
          int v13 = (void **)v21;
        }
        if (*(char *)(a3 + 23) >= 0) {
          int v12 = (void *)a3;
        }
        *(_DWORD *)CFTypeRef cf = 136315394;
        *(void *)&cf[4] = v13;
        __int16 v24 = 2080;
        uint64_t v25 = v12;
        BOOL v14 = "#E encrypt %s, invalid secret: %s";
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v14, cf, 0x16u);
        if (SHIBYTE(v17) < 0) {
          operator delete(v16[0]);
        }
      }
    }
  }
}

void sub_10063B06C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(v21);
  _Unwind_Resume(a1);
}

void sub_10063B0C0(uint64_t a1@<X0>, const void *a2@<X2>, char *a3@<X3>, void **a4@<X8>)
{
  sub_10063D9FC(a1);
  *a4 = 0;
  if (a2)
  {
    CFTypeID v8 = CFGetTypeID(a2);
    if (v8 == CFDataGetTypeID())
    {
      if (a3)
      {
        sub_100058DB0(__p, a3);
        uint32_t v9 = sub_100046F68(a1 + 32, __p);
        if (SHIBYTE(v38) < 0) {
          operator delete(__p[0]);
        }
        if ((void **)(a1 + 40) == v9)
        {
          __int16 v11 = *(NSObject **)(a1 + 8);
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v38 = 0;
          ctu::cf::assign();
          *(_OWORD *)uint64_t v32 = *(_OWORD *)__p;
          uint64_t v33 = v38;
          uint64_t v22 = v32;
          if (v38 < 0) {
            uint64_t v22 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v39 = 136315394;
          *(void *)&v39[4] = v22;
          *(_WORD *)&v39[12] = 2080;
          *(void *)&v39[14] = a3;
          int v13 = "#I decrypt %s, no secret %s found";
          goto LABEL_46;
        }
        uint64_t v35 = 0;
        uint64_t v36 = 0;
        long long v34 = 0;
        sub_10005C928(&v34, v9[7], (uint64_t)v9[8], (unsigned char *)v9[8] - (unsigned char *)v9[7]);
        sub_100639DDC((const __CFData *)a2, (uint64_t)&v34, (CFPropertyListRef *)v32);
        if (v32 != a4)
        {
          __p[0] = *a4;
          *a4 = v32[0];
          v32[0] = 0;
          sub_1000577C4((const void **)__p);
        }
        sub_1000577C4((const void **)v32);
        if (v34)
        {
          uint64_t v35 = v34;
          operator delete(v34);
        }
        if (*a4) {
          CFArrayRef v10 = sub_100080934;
        }
        else {
          CFArrayRef v10 = 0;
        }
        if (!v10)
        {
          __int16 v11 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v38 = 0;
            ctu::cf::assign();
            *(_OWORD *)uint64_t v32 = *(_OWORD *)__p;
            uint64_t v33 = v38;
            int v12 = v32;
            if (v38 < 0) {
              int v12 = (void **)__p[0];
            }
            *(_DWORD *)uint64_t v39 = 136315394;
            *(void *)&v39[4] = v12;
            *(_WORD *)&v39[12] = 2080;
            *(void *)&v39[14] = a3;
            int v13 = "#I decrypt %s, incompatible with secret %s";
LABEL_46:
            uint64_t v23 = v11;
            uint32_t v24 = 22;
LABEL_56:
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v13, v39, v24);
            if (SHIBYTE(v33) < 0) {
              operator delete(v32[0]);
            }
          }
        }
      }
      else
      {
        CFArrayRef v16 = *(void **)(a1 + 32);
        if (v16 == (void *)(a1 + 40))
        {
          uint64_t v17 = *a4;
        }
        else
        {
          do
          {
            std::string::size_type v30 = 0;
            uint64_t v31 = 0;
            BOOL v29 = 0;
            sub_10005C928(&v29, (const void *)v16[7], v16[8], v16[8] - v16[7]);
            sub_100639DDC((const __CFData *)a2, (uint64_t)&v29, (CFPropertyListRef *)v32);
            if (v32 != a4)
            {
              __p[0] = *a4;
              *a4 = v32[0];
              v32[0] = 0;
              sub_1000577C4((const void **)__p);
            }
            sub_1000577C4((const void **)v32);
            if (v29)
            {
              std::string::size_type v30 = v29;
              operator delete(v29);
            }
            uint64_t v17 = *a4;
            if (*a4) {
              CFArrayRef v18 = sub_100080934;
            }
            else {
              CFArrayRef v18 = 0;
            }
            if (v18) {
              break;
            }
            char v19 = (void *)v16[1];
            if (v19)
            {
              do
              {
                uint64_t v20 = v19;
                char v19 = (void *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                uint64_t v20 = (void *)v16[2];
                BOOL v21 = *v20 == (void)v16;
                CFArrayRef v16 = v20;
              }
              while (!v21);
            }
            CFArrayRef v16 = v20;
          }
          while (v20 != (void *)(a1 + 40));
        }
        if (v17) {
          uint64_t v25 = sub_100080934;
        }
        else {
          uint64_t v25 = 0;
        }
        if (!v25)
        {
          uint64_t v26 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v38 = 0;
            ctu::cf::assign();
            *(_OWORD *)uint64_t v32 = *(_OWORD *)__p;
            uint64_t v33 = v38;
            uint64_t v27 = v32;
            if (v38 < 0) {
              uint64_t v27 = (void **)__p[0];
            }
            *(_DWORD *)uint64_t v39 = 136315138;
            *(void *)&v39[4] = v27;
            int v13 = "#I decrypt %s, do not have a key to decrypt";
            uint64_t v23 = v26;
            uint32_t v24 = 12;
            goto LABEL_56;
          }
        }
      }
    }
    else
    {
      CFTypeID v14 = CFGetTypeID(a2);
      CFStringRef v28 = CFCopyTypeIDDescription(v14);
      int v15 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        ctu::cf::assign();
        uint64_t v33 = 0;
        *(_OWORD *)uint64_t v32 = 0u;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v38 = 0;
        ctu::cf::assign();
        *(_OWORD *)uint64_t v39 = *(_OWORD *)__p;
        *(void *)&v39[16] = 0;
        *(_DWORD *)long long buf = 136315394;
        uint64_t v41 = v32;
        __int16 v42 = 2080;
        uint64_t v43 = v39;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E decrypt %s, incorrect object type %s", buf, 0x16u);
        if ((v39[23] & 0x80000000) != 0) {
          operator delete(*(void **)v39);
        }
        if (SHIBYTE(v33) < 0) {
          operator delete(v32[0]);
        }
      }
      sub_1000558F4((const void **)&v28);
    }
  }
}

void sub_10063B5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(v25);
  _Unwind_Resume(a1);
}

void sub_10063B65C(uint64_t a1, uint64_t *a2)
{
  sub_10063C7B0(a1);
  if (!*(unsigned char *)(a1 + 64)) {
    return;
  }
  CC_LONG v4 = *(void **)(a1 + 32);
  int v5 = (void *)(a1 + 40);
  if (v4 == (void *)(a1 + 40)) {
    return;
  }
  char v45 = 0;
  uint64_t v46 = a1;
  uint64_t v47 = a1 + 16;
  do
  {
    uint64_t v6 = *a2;
    uint64_t v7 = a2[1];
    if (*a2 == v7)
    {
LABEL_24:
      if (v6 != v7) {
        goto LABEL_88;
      }
    }
    else
    {
      int v8 = *((char *)v4 + 55);
      if (v8 >= 0) {
        uint64_t v9 = *((unsigned __int8 *)v4 + 55);
      }
      else {
        uint64_t v9 = v4[5];
      }
      do
      {
        uint64_t v10 = *(unsigned __int8 *)(v6 + 23);
        if ((v10 & 0x80u) == 0) {
          uint64_t v11 = *(unsigned __int8 *)(v6 + 23);
        }
        else {
          uint64_t v11 = *(void *)(v6 + 8);
        }
        if (v11 == v9)
        {
          if (v8 >= 0) {
            int v12 = (unsigned __int8 *)(v4 + 4);
          }
          else {
            int v12 = (unsigned __int8 *)v4[4];
          }
          if ((v10 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v6, v12, *(void *)(v6 + 8))) {
              goto LABEL_24;
            }
          }
          else
          {
            if (!*(unsigned char *)(v6 + 23)) {
              goto LABEL_24;
            }
            uint64_t v13 = 0;
            while (*(unsigned __int8 *)(v6 + v13) == v12[v13])
            {
              if (v10 == ++v13) {
                goto LABEL_24;
              }
            }
          }
        }
        v6 += 24;
      }
      while (v6 != v7);
    }
    memset(&otherDate[1], 0, 7);
    CFTypeID v14 = (std::string *)sub_100058DB0(buf, "com.apple.thumper.");
    int v15 = *((char *)v4 + 55);
    if (v15 >= 0) {
      CFArrayRef v16 = (const std::string::value_type *)(v4 + 4);
    }
    else {
      CFArrayRef v16 = (const std::string::value_type *)v4[4];
    }
    if (v15 >= 0) {
      std::string::size_type v17 = *((unsigned __int8 *)v4 + 55);
    }
    else {
      std::string::size_type v17 = v4[5];
    }
    CFArrayRef v18 = std::string::append(v14, v16, v17);
    char v19 = (void *)v18->__r_.__value_.__r.__words[0];
    std::string::size_type size = (void *)v18->__r_.__value_.__l.__size_;
    LODWORD(otherDate[1]) = v18->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)&otherDate[1] + 3) = *(_DWORD *)((char *)&v18->__r_.__value_.__r.__words[2] + 3);
    int v21 = SHIBYTE(v18->__r_.__value_.__r.__words[2]);
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v62) < 0) {
      operator delete(*(void **)buf);
    }
    otherDate[0] = 0;
    if ((v21 & 0x80000000) == 0)
    {
      __dst[0] = v19;
      __dst[1] = size;
      LODWORD(v5sub_10010E764((uint64_t)&a9, 0) = otherDate[1];
      *(_DWORD *)((char *)&v50 + 3) = *(_DWORD *)((char *)&otherDate[1] + 3);
      HIBYTE(v5sub_10010E764((uint64_t)&a9, 0) = v21;
LABEL_36:
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v58 = v50;
      goto LABEL_37;
    }
    sub_10004FC84(__dst, v19, (unint64_t)size);
    if ((SHIBYTE(v50) & 0x80000000) == 0) {
      goto LABEL_36;
    }
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_37:
    uint64_t v59 = 0;
    if (SHIBYTE(v58) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      uint64_t v62 = v58;
    }
    std::string v60 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v22 = v59;
      uint64_t v59 = v60;
      v52[0] = v22;
      sub_1000558F4((const void **)v52);
    }
    if (SHIBYTE(v62) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v56 = v59;
    uint64_t v59 = 0;
    sub_1000558F4((const void **)&v59);
    if (SHIBYTE(v58) < 0) {
      operator delete(__p[0]);
    }
    int v23 = sub_1000BF42C(v47, v56, (uint64_t *)otherDate);
    sub_1000558F4((const void **)&v56);
    if (SHIBYTE(v50) < 0)
    {
      operator delete(__dst[0]);
      if (v23) {
        goto LABEL_86;
      }
    }
    else if (v23)
    {
      goto LABEL_86;
    }
    if (otherDate[0]) {
      uint32_t v24 = sub_1001908E4;
    }
    else {
      uint32_t v24 = 0;
    }
    if (v24)
    {
      CFDateRef v48 = 0;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v48 = CFDateCreate(kCFAllocatorDefault, Current);
      if ((int)CFDateGetTimeIntervalSinceDate(v48, otherDate[0]) >= 2678400)
      {
        uint64_t v26 = *(NSObject **)(v46 + 8);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v4 + 55) >= 0) {
            uint64_t v27 = v4 + 4;
          }
          else {
            uint64_t v27 = (void *)v4[4];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I erasing secret %s", buf, 0xCu);
        }
        CFStringRef v28 = (std::string *)sub_100058DB0(buf, "com.apple.thumper.");
        int v29 = *((char *)v4 + 55);
        if (v29 >= 0) {
          std::string::size_type v30 = (const std::string::value_type *)(v4 + 4);
        }
        else {
          std::string::size_type v30 = (const std::string::value_type *)v4[4];
        }
        if (v29 >= 0) {
          std::string::size_type v31 = *((unsigned __int8 *)v4 + 55);
        }
        else {
          std::string::size_type v31 = v4[5];
        }
        uint64_t v32 = std::string::append(v28, v30, v31);
        uint64_t v33 = (void *)v32->__r_.__value_.__r.__words[0];
        long long v34 = (void *)v32->__r_.__value_.__l.__size_;
        v55[0] = v32->__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v55 + 3) = *(_DWORD *)((char *)&v32->__r_.__value_.__r.__words[2] + 3);
        int v35 = SHIBYTE(v32->__r_.__value_.__r.__words[2]);
        v32->__r_.__value_.__l.__size_ = 0;
        v32->__r_.__value_.__r.__words[2] = 0;
        v32->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v62) < 0)
        {
          operator delete(*(void **)buf);
          if (v35 < 0) {
            goto LABEL_71;
          }
LABEL_68:
          v52[0] = v33;
          v52[1] = v34;
          LODWORD(v53) = v55[0];
          *(_DWORD *)((char *)&v53 + 3) = *(_DWORD *)((char *)v55 + 3);
          HIBYTE(v53) = v35;
LABEL_72:
          *(_OWORD *)std::string __p = *(_OWORD *)v52;
          uint64_t v58 = v53;
        }
        else
        {
          if ((v35 & 0x80000000) == 0) {
            goto LABEL_68;
          }
LABEL_71:
          sub_10004FC84(v52, v33, (unint64_t)v34);
          if ((SHIBYTE(v53) & 0x80000000) == 0) {
            goto LABEL_72;
          }
          sub_10004FC84(__p, v52[0], (unint64_t)v52[1]);
        }
        uint64_t v56 = 0;
        if (SHIBYTE(v58) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v62 = v58;
        }
        uint64_t v59 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v36 = v56;
          uint64_t v56 = v59;
          std::string v60 = v36;
          sub_1000558F4((const void **)&v60);
        }
        if (SHIBYTE(v62) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v37 = v56;
        uint64_t v54 = v56;
        uint64_t v56 = 0;
        sub_1000558F4((const void **)&v56);
        if (SHIBYTE(v58) < 0) {
          operator delete(__p[0]);
        }
        sub_1000C0E74(v47, v37);
        sub_1000558F4(&v54);
        if (SHIBYTE(v53) < 0)
        {
          operator delete(v52[0]);
          if (v35 < 0) {
            goto LABEL_96;
          }
        }
        else
        {
          if ((v35 & 0x80000000) == 0) {
            goto LABEL_84;
          }
LABEL_96:
          operator delete(v33);
        }
LABEL_84:
        char v45 = 1;
      }
      sub_10007CA64((const void **)&v48);
    }
LABEL_86:
    sub_10007CA64((const void **)otherDate);
    if (v21 < 0) {
      operator delete(v19);
    }
LABEL_88:
    uint64_t v38 = (void *)v4[1];
    if (v38)
    {
      do
      {
        uint64_t v39 = v38;
        uint64_t v38 = (void *)*v38;
      }
      while (v38);
    }
    else
    {
      do
      {
        uint64_t v39 = (void *)v4[2];
        BOOL v40 = *v39 == (void)v4;
        CC_LONG v4 = v39;
      }
      while (!v40);
    }
    CC_LONG v4 = v39;
  }
  while (v39 != v5);
  if (v45)
  {
    uint64_t v41 = *(NSObject **)(v46 + 8);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I set of secrets was cleaned up", buf, 2u);
    }
    *(unsigned char *)(v46 + 64) = 0;
    sub_10063DA94(*(void **)(v46 + 40));
    *(void *)(v46 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)(v46 + 48) = 0;
    *(void *)(v46 + 32) = v5;
    sub_10063C7B0(v46);
    if (capabilities::ct::supportsThumperSourcing(v42))
    {
      uint64_t v43 = *(NSObject **)(v46 + 8);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I re-set bootstrap dictionary for security key exchange", buf, 2u);
      }
      uint64_t v44 = *(void *)(v46 + 56);
      sub_10063CAE0(buf, v46);
      (*(void (**)(uint64_t, void))(*(void *)v44 + 40))(v44, *(void *)buf);
      sub_100057D78((const void **)buf);
    }
  }
}

void sub_10063BCD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_100057D78((const void **)(v38 - 128));
  _Unwind_Resume(a1);
}

void *sub_10063BE34(void *a1, size_t a2, unsigned char *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    size_t v5 = a2;
    sub_10005C9F8(a1, a2);
    uint64_t v6 = (unsigned char *)a1[1];
    uint64_t v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_10063BE98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063BEB4(void *a1, int a2, CFDataRef theData, void *a4)
{
  *a1 = 0;
  CFDataGetBytePtr(theData);
  unint64_t Length = CFDataGetLength(theData);
  int v8 = operator new(9uLL);
  *(void *)int v8 = 0x6F632E656C707061;
  v8[8] = 109;
  if (!a2) {
    operator new[]();
  }
  if (Length > 0x1B)
  {
    if (a4[1] - *a4 > 0xFuLL)
    {
      std::string::size_type v17 = 0;
      CFArrayRef v18 = 0;
      operator new[]();
    }
    sub_100058DB0(&__p, "ps.key");
    sCTLogServer();
    ctu::StaticLogger::StaticLogger();
    uint64_t v13 = v24;
    ctu::StaticLogger::~StaticLogger((ctu::StaticLogger *)buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v16 < 0) {
      operator delete(__p);
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = a4[1] - *a4;
      buf[0] = 136315650;
      *(void *)&buf[1] = "";
      __int16 v20 = 2080;
      int v21 = "";
      __int16 v22 = 2048;
      uint64_t v23 = v14;
      uint64_t v10 = "#W %s%sCCUpdateCFData, too short key (%zu bytes)";
      uint64_t v11 = v13;
      uint32_t v12 = 32;
      goto LABEL_17;
    }
  }
  else
  {
    sub_100058DB0(&__p, "ps.key");
    sCTLogServer();
    ctu::StaticLogger::StaticLogger();
    uint64_t v9 = v24;
    ctu::StaticLogger::~StaticLogger((ctu::StaticLogger *)buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v16 < 0) {
      operator delete(__p);
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 136315650;
      *(void *)&buf[1] = "";
      __int16 v20 = 2080;
      int v21 = "";
      __int16 v22 = 1024;
      LODWORD(v23) = Length;
      uint64_t v10 = "#W %s%sCCUpdateCFData, input data has wrong length: %d";
      uint64_t v11 = v9;
      uint32_t v12 = 28;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)buf, v12);
    }
  }
  operator delete(v8);
}

void sub_10063C5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  operator delete(v28);
  sub_100030068(v29);
  _Unwind_Resume(a1);
}

uint64_t sub_10063C6B0(uint64_t a1, void *a2, uint64_t *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "ps.key");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)a1 = off_1019F1CF0;
  *(void *)(a1 + 16) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 24) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 32) = a1 + 40;
  uint64_t v7 = *a3;
  *a3 = 0;
  *(void *)(a1 + 56) = v7;
  *(unsigned char *)(a1 + 64) = 0;
  return a1;
}

void sub_10063C78C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_10063C7B0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 64))
  {
    int v15 = 0;
    char v16 = 0;
    uint64_t v17 = 0;
    if (!sub_1000BF93C((int)a1 + 16, "thumper", &v15))
    {
      uint64_t v2 = v15;
      for (uint64_t i = v16; v2 != i; v2 += 32)
      {
        memset(v14, 0, 32);
        sub_100083DA4((const void **)v14, (const void **)v2);
        if (v2[31] < 0)
        {
          sub_10004FC84(&v14[1], *((void **)v2 + 1), *((void *)v2 + 2));
        }
        else
        {
          long long v4 = *(_OWORD *)(v2 + 8);
          v14[3] = *((void **)v2 + 3);
          *(_OWORD *)&v14[1] = v4;
        }
        uint64_t v11 = 0;
        uint32_t v12 = 0;
        uint64_t v13 = 0;
        ctu::base64::decode();
        memset(&__str, 0, sizeof(__str));
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string __str = buf;
        std::string::size_type size = buf.__r_.__value_.__l.__size_;
        char v6 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        if (size >= 0x13)
        {
          memset(&v9, 0, sizeof(v9));
          std::string::basic_string(&v9, &__str, 0x12uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&buf);
          sub_10063D288(&buf, (long long *)&v9, (uint64_t)&v11);
          sub_10063D17C((uint64_t **)(a1 + 32), (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
          if (__p)
          {
            __int16 v20 = __p;
            operator delete(__p);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          uint64_t v7 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v8 = &v9;
            }
            else {
              int v8 = (std::string *)v9.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I found secret for account %s", (uint8_t *)&buf, 0xCu);
          }
          if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v9.__r_.__value_.__l.__data_);
          }
          char v6 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        }
        if (v6 < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (v11)
        {
          uint32_t v12 = v11;
          operator delete(v11);
        }
        if (SHIBYTE(v14[3]) < 0) {
          operator delete(v14[1]);
        }
        sub_1000558F4((const void **)v14);
      }
      *(unsigned char *)(a1 + 64) = 1;
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v15;
    sub_10063D310((void ***)&buf);
  }
}

void sub_10063CA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,uint64_t a26,char *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  a27 = &a32;
  sub_10063D310((void ***)&a27);
  _Unwind_Resume(a1);
}

const void **sub_10063CAE0(void *a1, uint64_t a2)
{
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_10063C7B0(a2);
  long long v4 = *(void **)(a2 + 32);
  if (v4 != (void *)(a2 + 40))
  {
    do
    {
      uint64_t v5 = v4 + 4;
      CFStringRef v16 = 0;
      if (*((char *)v4 + 55) < 0) {
        uint64_t v5 = (void *)*v5;
      }
      CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"secret.", v5);
      value = 0;
      CFStringRef v16 = v6;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint32_t v12 = 0;
      sub_10005C928(&v12, (const void *)v4[7], v4[8], v4[8] - v4[7]);
      __int16 v20 = 0;
      uint64_t v21 = 0;
      std::string __p = 0;
      sub_10005C928(&__p, v12, (uint64_t)v13, v13 - (unsigned char *)v12);
      CFArrayRef v18 = 0;
      __int16 v22 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      sub_10005C928(&v22, __p, (uint64_t)v20, v20 - (unsigned char *)__p);
      uint64_t v25 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v7 = v18;
        CFArrayRef v18 = v25;
        uint64_t v26 = v7;
        sub_100030068(&v26);
      }
      if (v22)
      {
        uint64_t v23 = v22;
        operator delete(v22);
      }
      value = v18;
      CFArrayRef v18 = 0;
      sub_100030068((const void **)&v18);
      if (__p)
      {
        __int16 v20 = __p;
        operator delete(__p);
      }
      if (v12)
      {
        uint64_t v13 = v12;
        operator delete(v12);
      }
      CFDictionaryAddValue(Mutable, v16, value);
      sub_100030068((const void **)&value);
      sub_1000558F4((const void **)&v16);
      int v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          std::string v9 = v8;
          int v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          std::string v9 = (void *)v4[2];
          BOOL v10 = *v9 == (void)v4;
          long long v4 = v9;
        }
        while (!v10);
      }
      long long v4 = v9;
    }
    while (v9 != (void *)(a2 + 40));
  }
  sub_10004EFE4(a1, (CFTypeRef *)&Mutable);
  return sub_10005717C((const void **)&Mutable);
}

void sub_10063CCC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, int a20,const void *a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26)
{
}

void sub_10063CD48()
{
}

void sub_10063D0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  *(void *)(v35 + 8) = v36;
  if (__p) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_10004D2C8(v34);
  _Unwind_Resume(a1);
}

uint64_t sub_10063D17C(uint64_t **a1, void **a2, uint64_t a3)
{
  CFStringRef v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    int v8 = a1 + 1;
LABEL_9:
    uint64_t v11 = operator new(0x50uLL);
    void v11[2] = *(_OWORD *)a3;
    *((void *)v11 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_OWORD *)((char *)v11 + 56) = *(_OWORD *)(a3 + 24);
    *((void *)v11 + 9) = *(void *)(a3 + 40);
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    *CFStringRef v6 = (uint64_t *)v11;
    uint32_t v12 = (uint64_t *)**a1;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v6;
    }
    else
    {
      uint64_t v13 = (uint64_t *)v11;
    }
    uint64_t result = (uint64_t)sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return result;
  }
  while (1)
  {
    while (1)
    {
      int v8 = (uint64_t **)v5;
      std::string v9 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      CFStringRef v6 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    uint64_t result = sub_100046FE8(v9, a2);
    if ((result & 0x80) == 0) {
      break;
    }
    CFStringRef v6 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_9;
    }
  }
  if (!*v6) {
    goto LABEL_9;
  }
  return result;
}

void *sub_10063D288(void *__dst, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v5;
  }
  __dst[3] = 0;
  __dst[4] = 0;
  __dst[5] = 0;
  sub_10005C928(__dst + 3, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  return __dst;
}

void sub_10063D2F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063D310(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 32;
        sub_1000C1494(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10063D398(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10063D3D0(uint64_t result)
{
  if (*(void *)(result + 24))
  {
    uint64_t v1 = *(void ***)(result + 24);
    sub_100047F64(&v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10063D420(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void ***sub_10063D464(void ***result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = v1;
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

void sub_10063D4B8(uint64_t a1, const std::string::value_type *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      long long v5 = a2;
    }
    else {
      long long v5 = *(const std::string::value_type **)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I saved secret %s", buf, 0xCu);
  }
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v21 = 0;
  ctu::base64::encode();
  CFStringRef v6 = (std::string *)sub_100058DB0(buf, "com.apple.thumper.");
  int v7 = a2[23];
  if (v7 >= 0) {
    int v8 = a2;
  }
  else {
    int v8 = *(const std::string::value_type **)a2;
  }
  if (v7 >= 0) {
    std::string::size_type v9 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    std::string::size_type v9 = *((void *)a2 + 1);
  }
  BOOL v10 = std::string::append(v6, v8, v9);
  uint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
  std::string::size_type size = (void *)v10->__r_.__value_.__l.__size_;
  v19[0] = v10->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v19 + 3) = *(_DWORD *)((char *)&v10->__r_.__value_.__r.__words[2] + 3);
  int v13 = SHIBYTE(v10->__r_.__value_.__r.__words[2]);
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v28) < 0)
  {
    operator delete(*(void **)buf);
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v13 & 0x80000000) == 0)
  {
LABEL_14:
    __dst[0] = v11;
    __dst[1] = size;
    LODWORD(v17) = v19[0];
    *(_DWORD *)((char *)&v17 + 3) = *(_DWORD *)((char *)v19 + 3);
    HIBYTE(v17) = v13;
LABEL_17:
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v24 = v17;
    goto LABEL_18;
  }
  sub_10004FC84(__dst, v11, (unint64_t)size);
  if ((SHIBYTE(v17) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_18:
  __int16 v22 = 0;
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v28 = v24;
  }
  uint64_t v25 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v14 = v22;
    __int16 v22 = v25;
    uint64_t v26 = v14;
    sub_1000558F4(&v26);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
  int v15 = (void *)v22;
  CFArrayRef v18 = v22;
  __int16 v22 = 0;
  sub_1000558F4(&v22);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(buf, "thumper");
  sub_1000C119C(a1 + 16, v15, (uint64_t)buf, (uint64_t)v20, 0);
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
  sub_1000558F4(&v18);
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__dst[0]);
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_31;
    }
  }
  else if ((v13 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v11);
LABEL_31:
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
}

void sub_10063D754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10063D818(capabilities::ct *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = (const void **)capabilities::ct::supportsThumperSourcing(a1);
  if (result)
  {
    if (*((char *)a2 + 23) >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = (uint64_t *)*a2;
    }
    CFStringRef v14 = CFStringCreateWithFormat(0, 0, @"%@%s", @"secret.", v7);
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    BOOL v10 = 0;
    sub_10005C928(&v10, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    std::string __p = 0;
    sub_10005C928(&__p, v10, (uint64_t)v11, v11 - (unsigned char *)v10);
    int v15 = 0;
    char v19 = 0;
    __int16 v20 = 0;
    uint64_t v21 = 0;
    sub_10005C928(&v19, __p, (uint64_t)v17, v17 - (unsigned char *)__p);
    __int16 v22 = 0;
    if (ctu::cf::convert_copy())
    {
      int v8 = v15;
      int v15 = v22;
      uint64_t v23 = v8;
      sub_100030068(&v23);
    }
    if (v19)
    {
      __int16 v20 = v19;
      operator delete(v19);
    }
    std::string::size_type v9 = v15;
    int v13 = v15;
    int v15 = 0;
    sub_100030068(&v15);
    if (__p)
    {
      uint64_t v17 = __p;
      operator delete(__p);
    }
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }
    (*(void (**)(void *, CFStringRef, const void *))(**((void **)a1 + 7) + 16))(*((void **)a1 + 7), v14, v9);
    sub_100030068(&v13);
    return sub_1000558F4((const void **)&v14);
  }
  return result;
}

void sub_10063D988(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, const void *a14, const void *a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20)
{
}

void sub_10063D9FC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 64))
  {
    sub_10063C7B0(a1);
    if (*(unsigned char *)(a1 + 64))
    {
      uint64_t v2 = *(void **)(a1 + 32);
      if (v2 != (void *)(a1 + 40))
      {
        do
        {
          sub_10063D818((capabilities::ct *)a1, v2 + 4, (uint64_t)(v2 + 7));
          uint64_t v3 = (void *)v2[1];
          if (v3)
          {
            do
            {
              uint64_t v4 = v3;
              uint64_t v3 = (void *)*v3;
            }
            while (v3);
          }
          else
          {
            do
            {
              uint64_t v4 = (void *)v2[2];
              BOOL v5 = *v4 == (void)v2;
              uint64_t v2 = v4;
            }
            while (!v5);
          }
          uint64_t v2 = v4;
        }
        while (v4 != (void *)(a1 + 40));
      }
    }
  }
}

void sub_10063DA94(void *a1)
{
  if (a1)
  {
    sub_10063DA94(*a1);
    sub_10063DA94(a1[1]);
    sub_1003424C4((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

unint64_t sub_10063DAE8(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  uint64_t v5 = a2;
  CFStringRef v6 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v3 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 120))(a1, &v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v3 | ((unint64_t)(v3 != -1) << 32);
}

void sub_10063DB68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10063DB80(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_10063DBD8(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t *sub_10063DC30(uint64_t a1)
{
  sub_100C62700(a1, "kSmsSendMessage", (unint64_t)sub_10063DDE4, 7u);
  sub_100C62700(a1, "kSmsRetrieveMessage", (unint64_t)sub_10063E6E4, 3u);
  sub_100C62700(a1, "kSmsGetRecievedMessageIds", (unint64_t)sub_10063EDAC, 3u);
  sub_100C62700(a1, "kSmsGetIncomingMessageCount", (unint64_t)sub_10063F24C, 3u);
  sub_100C62700(a1, "kSmsIsMmsConfigured", (unint64_t)sub_1000562AC, 1u);
  sub_100C62700(a1, "kSmsAcknowledgeMessage", (unint64_t)sub_10063F464, 3u);
  sub_100C62700(a1, "kSmsIsPhoneNumberRegistrationSupported", (unint64_t)sub_10063F6EC, 3u);
  sub_100C62700(a1, "kSmsGetCharacterCountAndThresholdForMessage", (unint64_t)sub_10063FC08, 3u);
  sub_100C62700(a1, "kSimulateSmsReceived", (unint64_t)sub_1006400F8, 7u);
  sub_100C62700(a1, "kSimulateDeferredMessage", (unint64_t)sub_1006404B0, 7u);

  return sub_100C62700(a1, "kSmsEmergencyUISession", (unint64_t)sub_1006407B8, 7u);
}

void sub_10063DDE4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, xpc_object_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  std::string::size_type v9 = ServiceMap;
  BOOL v10 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      BOOL v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  CFStringRef v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  int v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_7:
    sub_100640AF8();
    uint64_t v18 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Messaging not configured", buf, 2u);
    }
    goto LABEL_50;
  }
LABEL_11:
  if (MessageCenterModel::isMessagesInstalled(a1))
  {
    *(void *)std::string buf = a4;
    long long v63 = "kSmsMessageType";
    sub_100048BAC((uint64_t)buf, object);
    int v20 = xpc::dyn_cast_or_default((xpc *)object, 0, v19);
    xpc_release(object[0]);
    *(void *)std::string buf = a4;
    long long v63 = "kSmsMessageID";
    sub_100048BAC((uint64_t)buf, object);
    unsigned int v54 = xpc::dyn_cast_or_default((xpc *)object, (const object *)0xFFFFFFFFLL, v21);
    xpc_release(object[0]);
    *(void *)std::string buf = 0;
    long long v63 = 0;
    uint64_t v64 = 0;
    __int16 v22 = "Unknown";
    if (v20 == 1) {
      __int16 v22 = "SMS";
    }
    if (v20 == 2) {
      uint64_t v23 = "MMS";
    }
    else {
      uint64_t v23 = (char *)v22;
    }
    sub_100058DB0(buf, v23);
    sub_100640AF8();
    uint64_t v24 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = buf;
      if (v64 < 0) {
        uint64_t v25 = *(uint8_t **)buf;
      }
      LODWORD(object[0]) = 136315394;
      *(xpc_object_t *)((char *)object + 4) = v25;
      WORD2(object[1]) = 1024;
      *(_DWORD *)((char *)&object[1] + 6) = v54;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s message send requested [%u]...", (uint8_t *)object, 0x12u);
    }
    uint64_t v26 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v27 = v26;
    if (v28 < 0)
    {
      int v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v30 = 5381;
      do
      {
        uint64_t v28 = v30;
        unsigned int v31 = *v29++;
        uint64_t v30 = (33 * v30) ^ v31;
      }
      while (v31);
    }
    std::mutex::lock(v26);
    int v53 = v20;
    object[0] = (xpc_object_t)v28;
    uint64_t v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)object);
    if (v32)
    {
      uint64_t v33 = v32[3];
      long long v34 = (std::__shared_weak_count *)v32[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v27);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        sub_10004D2C8(v34);
        if (!v33) {
          goto LABEL_31;
        }
LABEL_54:
        int v40 = v53;
        if (v53 == 1)
        {
          uint64_t v51 = sub_1006416F4(a1, a4);
          unsigned int v39 = v51;
          uint64_t v38 = 0;
          int v37 = BYTE4(v51);
        }
        else if (v53 == 2)
        {
          CFTypeRef cf = 0;
          object[0] = a4;
          object[1] = "kSmsMessageBody";
          sub_100048BAC((uint64_t)object, &v60);
          xpc::bridge((uint64_t *)&v65, (xpc *)&v60, v43);
          sub_1000C15D8(&cf, (CFTypeRef *)&v65);
          sub_1000577C4((const void **)&v65);
          xpc_release(v60);
          memset(object, 0, 24);
          CFTypeRef v59 = cf;
          if (cf) {
            CFRetain(cf);
          }
          sub_100640B90(object, (CFDataRef *)&v59);
          sub_100030068(&v59);
          *(void *)&long long v65 = a4;
          *((void *)&v65 + 1) = "kSmsSubInstance";
          sub_100048BAC((uint64_t)&v65, &v60);
          uint64_t v45 = xpc::dyn_cast_or_default((xpc *)&v60, 0, v44);
          xpc_release(v60);
          if (v45 == 2) {
            uint64_t v38 = 2;
          }
          else {
            uint64_t v38 = v45 == 1;
          }
          if (!v38)
          {
            sub_100640AF8();
            uint64_t v46 = qword_101B0D208;
            if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v47 = subscriber::asString();
              LODWORD(v65) = 136315138;
              *(void *)((char *)&v65 + 4) = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I MMS on invalid slot (subscriber::SimSlot::kUnknown). Forcing to %s", (uint8_t *)&v65, 0xCu);
            }
            uint64_t v38 = 1;
          }
          if (SHIBYTE(object[2]) >= 0) {
            CFDateRef v48 = (char *)object;
          }
          else {
            CFDateRef v48 = (char *)object[0];
          }
          if (SHIBYTE(object[2]) >= 0) {
            signed int v49 = HIBYTE(object[2]);
          }
          else {
            signed int v49 = (signed int)object[1];
          }
          uint64_t v50 = sub_100640C20(v38, a1, v48, v49, v54);
          unsigned int v39 = v50;
          int v37 = BYTE4(v50);
          if (SHIBYTE(object[2]) < 0) {
            operator delete(object[0]);
          }
          sub_100030068(&cf);
        }
        else
        {
          sub_100640AF8();
          uint64_t v52 = qword_101B0D208;
          if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
          {
            LODWORD(object[0]) = 67109120;
            HIDWORD(object[0]) = v53;
            _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "can't queue unknown message type %u", (uint8_t *)object, 8u);
          }
          int v37 = 0;
          uint64_t v38 = 0;
          unsigned int v39 = -1;
        }
        goto LABEL_34;
      }
      std::mutex::unlock(v27);
      if (v33) {
        goto LABEL_54;
      }
    }
    else
    {
      std::mutex::unlock(v27);
    }
LABEL_31:
    sub_100640AF8();
    uint64_t v36 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      LOWORD(object[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "unable to send message when telephony isn't up", (uint8_t *)object, 2u);
    }
    int v37 = 0;
    uint64_t v38 = 0;
    unsigned int v39 = -1;
    int v40 = v53;
LABEL_34:
    if (!v37 && v54 != -1)
    {
      if (v40 == 1)
      {
        sub_100640AF8();
        uint64_t v41 = qword_101B0D208;
        if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(object[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Notifying clients of failed sms..", (uint8_t *)object, 2u);
        }
        object[0] = 0;
        object[1] = 0;
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, xpc_object_t *))(*(void *)v16 + 160))(v16, v38, 1, v54, object);
      }
      else if (v40 == 2)
      {
        sub_100640AF8();
        __int16 v42 = qword_101B0D208;
        if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(object[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Notifying clients of failed mms..", (uint8_t *)object, 2u);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v16 + 192))(v16, v38, 1, v54);
      }
    }
    xpc_object_t v57 = xpc_int64_create(v39);
    if (!v57) {
      xpc_object_t v57 = xpc_null_create();
    }
    object[0] = *a5;
    object[1] = "kSmsMessageID";
    sub_100035E70((uint64_t)object, &v57, &v58);
    xpc_release(v58);
    xpc_object_t v58 = 0;
    xpc_release(v57);
    xpc_object_t v57 = 0;
    xpc_object_t v55 = xpc_BOOL_create(v37 != 0);
    if (!v55) {
      xpc_object_t v55 = xpc_null_create();
    }
    object[0] = *a5;
    object[1] = "kSmsMessageResult";
    sub_100035E70((uint64_t)object, &v55, &v56);
    xpc_release(v56);
    xpc_object_t v56 = 0;
    xpc_release(v55);
    xpc_object_t v55 = 0;
    if (SHIBYTE(v64) < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_50;
  }
  sub_100640AF8();
  uint64_t v35 = qword_101B0D208;
  if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed, dropping MO message.", buf, 2u);
  }
LABEL_50:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_10063E594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, xpc_object_t object, const void *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_100030068(&a16);
  if (a22 < 0) {
    operator delete(a17);
  }
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(a1);
}

void sub_10063E6E4(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kSmsMessageID";
  sub_100048BAC((uint64_t)buf, object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)object, 0, v7);
  xpc_release(object[0]);
  object[0] = 0;
  object[1] = 0;
  uint64_t v54 = 0;
  if (v8 == -1) {
    goto LABEL_57;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v10 = ServiceMap;
  uint64_t v11 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = (const char *)v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_8;
      }
LABEL_12:
      int v20 = (std::mutex *)Registry::getServiceMap(*a1);
      unsigned int v21 = v20;
      if ((v22 & 0x8000000000000000) != 0)
      {
        uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          unint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(v20);
      unint64_t v51 = v22;
      uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, &v51);
      if (v26)
      {
        uint64_t v28 = (SubscriberUtilityInterface *)v26[3];
        uint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
LABEL_20:
          SubscriberUtilityInterface::getSubscriberMcc((uint64_t *)buf, v28);
          if (SHIBYTE(v54) < 0) {
            operator delete(object[0]);
          }
          *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
          uint64_t v54 = v56;
          BYTE7(v56) = 0;
          buf[0] = 0;
          if ((v29 & 1) == 0) {
            sub_10004D2C8(v27);
          }
          unint64_t v51 = 0;
          uint64_t v52 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 208))(&v51, v17, v8);
          if (v51)
          {
            unsigned int v30 = (*(uint64_t (**)(unint64_t))(*(void *)v51 + 64))(v51);
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_DWORD *)std::string buf = 1;
            uint64_t v57 = 0;
            *(void *)&uint8_t buf[8] = 0;
            long long v56 = 0uLL;
            if ((*(uint64_t (**)(unint64_t, uint8_t *, uint64_t))(*(void *)v51 + 200))(v51, buf, 1))
            {
              CFDataRef v50 = 0;
              if (v56 >= 0) {
                unsigned int v31 = &buf[8];
              }
              else {
                unsigned int v31 = *(const UInt8 **)&buf[8];
              }
              if (v56 >= 0) {
                CFIndex v32 = HIBYTE(v56);
              }
              else {
                CFIndex v32 = v56;
              }
              CFDataRef v33 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v31, v32, kCFAllocatorNull);
              CFDataRef v50 = v33;
              if (v33) {
                uint64_t v35 = sub_10008324C;
              }
              else {
                uint64_t v35 = 0;
              }
              if (v35)
              {
                ctu::cf_to_xpc((uint64_t *)&v48, v33, v34);
                *(void *)uint64_t v46 = *a5;
                uint64_t v47 = "kSmsMessageBody";
                sub_100035E70((uint64_t)v46, &v48, &v49);
                xpc_release(v49);
                xpc_object_t v49 = 0;
                xpc_release(v48);
                xpc_object_t v48 = 0;
                if (v54 >= 0) {
                  uint64_t v36 = object;
                }
                else {
                  uint64_t v36 = (xpc_object_t *)object[0];
                }
                xpc_object_t v44 = xpc_string_create((const char *)v36);
                if (!v44) {
                  xpc_object_t v44 = xpc_null_create();
                }
                *(void *)uint64_t v46 = *a5;
                uint64_t v47 = "kSmsMobileCountryCode";
                sub_100035E70((uint64_t)v46, &v44, &v45);
                xpc_release(v45);
                xpc_object_t v45 = 0;
                xpc_release(v44);
                xpc_object_t v44 = 0;
                xpc_object_t v42 = xpc_int64_create(v30);
                if (!v42) {
                  xpc_object_t v42 = xpc_null_create();
                }
                *(void *)uint64_t v46 = *a5;
                uint64_t v47 = "kSmsMessageType";
                sub_100035E70((uint64_t)v46, &v42, &v43);
                xpc_release(v43);
                xpc_object_t v43 = 0;
                xpc_release(v42);
                xpc_object_t v42 = 0;
                char v37 = (*(uint64_t (**)(unint64_t))(*(void *)v51 + 248))(v51);
                xpc_object_t v40 = xpc_BOOL_create(v37);
                if (!v40) {
                  xpc_object_t v40 = xpc_null_create();
                }
                *(void *)uint64_t v46 = *a5;
                uint64_t v47 = "kSmsReplyEnabled";
                sub_100035E70((uint64_t)v46, &v40, &v41);
                xpc_release(v41);
                xpc_object_t v41 = 0;
                xpc_release(v40);
                xpc_object_t v40 = 0;
              }
              sub_100030068((const void **)&v50);
            }
            else
            {
              sub_100640AF8();
              unsigned int v39 = qword_101B0D208;
              if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t v46 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "unable to encode message for rpc", v46, 2u);
              }
            }
            if (SHIBYTE(v56) < 0) {
              operator delete(*(void **)&buf[8]);
            }
          }
          else
          {
            sub_100640AF8();
            uint64_t v38 = qword_101B0D208;
            if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v8;
              _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "CTRetrieveMessage: no message with id %u", buf, 8u);
            }
          }
          if (v52) {
            sub_10004D2C8(v52);
          }
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      uint64_t v27 = 0;
      char v29 = 1;
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_12;
  }
LABEL_8:
  sub_100640AF8();
  unsigned int v19 = qword_101B0D208;
  if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Messaging not configured", buf, 2u);
  }
LABEL_55:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
LABEL_57:
  if (SHIBYTE(v54) < 0) {
    operator delete(object[0]);
  }
}

void sub_10063ECB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,xpc_object_t object,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063EDAC(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v7 = ServiceMap;
  uint64_t v8 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    std::string::size_type v9 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = (const char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    sub_100640AF8();
    uint64_t v16 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Messaging not configured", buf, 2u);
    }
    goto LABEL_47;
  }
LABEL_11:
  *(void *)std::string buf = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  std::string __p = 0;
  CFDataRef v33 = 0;
  uint64_t v34 = 0;
  (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v14 + 256))(v14, buf, &__p);
  if (v36 != *(unsigned int **)buf)
  {
    xpc_object_t v17 = xpc_array_create(0, 0);
    if (v17 || (xpc_object_t v17 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v17);
        xpc_object_t v18 = v17;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v18 = xpc_null_create();
      xpc_object_t v17 = 0;
    }
    xpc_release(v17);
    for (uint64_t i = *(unsigned int **)buf; i != v36; ++i)
    {
      xpc_object_t v20 = xpc_int64_create(*i);
      if (!v20) {
        xpc_object_t v20 = xpc_null_create();
      }
      xpc_array_append_value(v18, v20);
      xpc_release(v20);
    }
    xpc_object_t v30 = v18;
    if (v18) {
      xpc_retain(v18);
    }
    else {
      xpc_object_t v30 = xpc_null_create();
    }
    uint64_t v28 = *a5;
    char v29 = "kSmsRecievedSmsMessageIds";
    sub_10017AC14((uint64_t)&v28, &v30, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_release(v18);
  }
  unsigned int v21 = v33;
  if (v33 != __p)
  {
    xpc_object_t v22 = xpc_array_create(0, 0);
    if (v22 || (xpc_object_t v22 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v22);
        xpc_object_t v23 = v22;
      }
      else
      {
        xpc_object_t v23 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v23 = xpc_null_create();
      xpc_object_t v22 = 0;
    }
    xpc_release(v22);
    for (uint64_t j = (unsigned int *)__p; j != v33; ++j)
    {
      xpc_object_t v25 = xpc_int64_create(*j);
      if (!v25) {
        xpc_object_t v25 = xpc_null_create();
      }
      xpc_array_append_value(v23, v25);
      xpc_release(v25);
    }
    xpc_object_t v26 = v23;
    if (v23) {
      xpc_retain(v23);
    }
    else {
      xpc_object_t v26 = xpc_null_create();
    }
    uint64_t v28 = *a5;
    char v29 = "kSmsRecievedMmsMessageIds";
    sub_10017AC14((uint64_t)&v28, &v26, &v27);
    xpc_release(v27);
    xpc_object_t v27 = 0;
    xpc_release(v26);
    xpc_object_t v26 = 0;
    xpc_release(v23);
    unsigned int v21 = (unsigned int *)__p;
  }
  if (v21)
  {
    CFDataRef v33 = v21;
    operator delete(v21);
  }
  if (*(void *)buf)
  {
    uint64_t v36 = *(unsigned int **)buf;
    operator delete(*(void **)buf);
  }
LABEL_47:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_10063F178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063F24C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v7 = ServiceMap;
  uint64_t v8 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    std::string::size_type v9 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = (const char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = (unint64_t)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, v20);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    sub_100640AF8();
    uint64_t v16 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Messaging not configured", (uint8_t *)v20, 2u);
    }
    goto LABEL_16;
  }
LABEL_11:
  int64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 216))(v14);
  xpc_object_t v21 = xpc_int64_create(v17);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  int v19 = xpc::dyn_cast_or_default((xpc *)&v21, 0, v18);
  xpc_object_t v22 = xpc_int64_create(v19);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  v20[0] = *a5;
  v20[1] = (unint64_t)"kSmsIncomingMessageCount";
  sub_100035E70((uint64_t)v20, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
LABEL_16:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_10063F41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063F464(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  std::string::size_type v9 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = (const char *)v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    sub_100640AF8();
    int64_t v17 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Messaging not configured", buf, 2u);
    }
    goto LABEL_20;
  }
LABEL_11:
  *(void *)std::string buf = a4;
  xpc_object_t v27 = "kSmsMessageID";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)0xFFFFFFFFLL, v18);
  xpc_release(object);
  *(void *)std::string buf = a4;
  xpc_object_t v27 = "kSmsMessageIsMobileOriginated";
  sub_100048BAC((uint64_t)buf, &object);
  char v21 = xpc::dyn_cast_or_default((xpc *)&object, 0, v20);
  xpc_release(object);
  if (v19 == -1) {
    char v22 = 1;
  }
  else {
    char v22 = v21;
  }
  if (v22) {
    char v23 = 0;
  }
  else {
    char v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 224))(v15, v19);
  }
  xpc_object_t v24 = xpc_BOOL_create(v23);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v27 = "kSmsMessageWasAcknowledged";
  sub_100035E70((uint64_t)buf, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
LABEL_20:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_10063F688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10063F6EC(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)std::string buf = 0;
  xpc_object_t v42 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)xpc_object_t v43 = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v43);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_9:
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 8))(buf, v15, 1);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (!*(void *)buf)
  {
    if (v42) {
      sub_10004D2C8(v42);
    }
LABEL_20:
    BOOL v20 = (std::mutex *)Registry::getServiceMap(*a1);
    char v21 = v20;
    char v22 = "27MessageCenterModelInterface";
    if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
    {
      char v23 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        char v22 = (const char *)v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(v20);
    *(void *)std::string buf = v22;
    xpc_object_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
    if (v26)
    {
      uint64_t v28 = v26[3];
      xpc_object_t v27 = (std::__shared_weak_count *)v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v21);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v30 = 0;
        if (!v28) {
          goto LABEL_26;
        }
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    std::mutex::unlock(v21);
    xpc_object_t v27 = 0;
    char v30 = 1;
    if (!v28)
    {
LABEL_26:
      sub_100643D50();
      unsigned int v31 = qword_101B0D218;
      if (os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        int v32 = 2;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Message center is invalid?", buf, 2u);
        goto LABEL_39;
      }
      goto LABEL_41;
    }
LABEL_30:
    if ((capabilities::ct::supportsPhoneNumberRegistration(v29) & 1) == 0)
    {
      sub_100643D50();
      uint64_t v35 = qword_101B0D218;
      if (os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        int v32 = 2;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Device does not support PNR", buf, 2u);
LABEL_39:
        BOOL v19 = 0;
        if (v30) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
LABEL_41:
      BOOL v19 = 0;
      int v32 = 2;
      if (v30) {
        goto LABEL_43;
      }
      goto LABEL_42;
    }
    *(void *)std::string buf = 0;
    sub_100643D50();
    CFStringRef v33 = (const __CFString *)sub_100794BC4((NSObject **)&qword_101B0D218, a1, 1);
    *(void *)std::string buf = v33;
    if (v33) {
      uint64_t v34 = sub_1000810B8;
    }
    else {
      uint64_t v34 = 0;
    }
    if (v34)
    {
      if (CFStringGetLength(v33) > 0)
      {
        int v32 = 0;
        BOOL v19 = 1;
        goto LABEL_54;
      }
      sub_100643D50();
      uint64_t v37 = qword_101B0D218;
      if (!os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_ERROR)) {
        goto LABEL_53;
      }
      *(_WORD *)xpc_object_t v43 = 0;
      uint64_t v38 = "Gateway address is not valid?";
    }
    else
    {
      sub_100643D50();
      uint64_t v37 = qword_101B0D218;
      if (!os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_ERROR))
      {
LABEL_53:
        BOOL v19 = 0;
        int v32 = 2;
        goto LABEL_54;
      }
      *(_WORD *)xpc_object_t v43 = 0;
      uint64_t v38 = "Failed to find gateway address";
    }
    int v32 = 2;
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v38, v43, 2u);
    BOOL v19 = 0;
LABEL_54:
    sub_1000558F4((const void **)buf);
    if (v30)
    {
LABEL_43:
      if (v32) {
        goto LABEL_47;
      }
      goto LABEL_44;
    }
LABEL_42:
    sub_10004D2C8(v27);
    goto LABEL_43;
  }
  int v17 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 72))(*(void *)buf, 1);
  if (v42) {
    sub_10004D2C8(v42);
  }
  if (!v17) {
    goto LABEL_20;
  }
  sub_100643D50();
  unsigned int v18 = qword_101B0D218;
  if (os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Carrier Supports PNR over entitlements", buf, 2u);
  }
  BOOL v19 = 1;
LABEL_44:
  *(void *)std::string buf = 2048;
  if (!IsTelephonyRunningExtended(buf))
  {
    sub_100643D50();
    uint64_t v36 = qword_101B0D218;
    BOOL v19 = 0;
    if (os_log_type_enabled((os_log_t)qword_101B0D218, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Radio Module is not present, Phone number registration is not supported", buf, 2u);
      BOOL v19 = 0;
    }
  }
LABEL_47:
  xpc_object_t v39 = xpc_BOOL_create(v19);
  if (!v39) {
    xpc_object_t v39 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v42 = (std::__shared_weak_count *)"kSmsPhoneNumberRegistrationIsSupported";
  sub_100035E70((uint64_t)buf, &v39, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v39);
}

void sub_10063FB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_10063FC08(Registry **a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v9 = ServiceMap;
  uint64_t v10 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long __p = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&__p);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_9:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_37;
    }
    goto LABEL_10;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_37;
  }
LABEL_10:
  unsigned int v18 = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v19 = v18;
  if (v20 < 0)
  {
    char v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v18);
  *(void *)&long long __p = v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)&__p);
  if (!v24)
  {
    uint64_t v26 = 0;
LABEL_18:
    std::mutex::unlock(v19);
    unsigned int v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_35;
    }
    goto LABEL_19;
  }
  uint64_t v26 = v24[3];
  unsigned int v25 = (std::__shared_weak_count *)v24[4];
  if (!v25) {
    goto LABEL_18;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v19);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
  if (!v26) {
    goto LABEL_35;
  }
LABEL_19:
  v43[0] = 0;
  v43[1] = 0;
  uint64_t v44 = 0;
  value_4[0] = a4;
  value_4[1] = "kSmsMessageBody";
  sub_100048BAC((uint64_t)value_4, &object);
  long long __p = 0uLL;
  uint64_t v46 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v46) < 0) {
    operator delete((void *)__p);
  }
  xpc_release(object);
  LODWORD(object) = 0;
  int value = 0;
  *(void *)&long long __p = a4;
  *((void *)&__p + 1) = "kSmsSubInstance";
  sub_100048BAC((uint64_t)&__p, value_4);
  uint64_t v29 = xpc::dyn_cast_or_default((xpc *)value_4, 0, v28);
  xpc_release(value_4[0]);
  if (v29 == 2) {
    uint64_t v30 = 2;
  }
  else {
    uint64_t v30 = v29 == 1;
  }
  if (!v30)
  {
    sub_100640AF8();
    unsigned int v31 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = subscriber::asString();
      LODWORD(__p) = 136315138;
      *(void *)((char *)&__p + 4) = v33;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "get character count forced for slot: %s", (uint8_t *)&__p, 0xCu);
    }
    uint64_t v30 = 1;
  }
  char v32 = (*(uint64_t (**)(uint64_t, uint64_t, void **, xpc_object_t *, int *))(*(void *)v16 + 264))(v16, v30, v43, &object, &value);
  xpc_object_t v38 = xpc_int64_create((int)object);
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  *(void *)&long long __p = *a5;
  *((void *)&__p + 1) = "kSmsCharacterCount";
  sub_100035E70((uint64_t)&__p, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_object_t v36 = xpc_int64_create(value);
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  *(void *)&long long __p = *a5;
  *((void *)&__p + 1) = "kSmsThreshold";
  sub_100035E70((uint64_t)&__p, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_object_t v34 = xpc_BOOL_create(v32);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  *(void *)&long long __p = *a5;
  *((void *)&__p + 1) = "kDidSucceed";
  sub_100035E70((uint64_t)&__p, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  if ((SHIBYTE(v44) & 0x80000000) == 0)
  {
LABEL_35:
    if (v27) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  operator delete(v43[0]);
  if ((v27 & 1) == 0) {
LABEL_36:
  }
    sub_10004D2C8(v25);
LABEL_37:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100640024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object, uint64_t a18, xpc_object_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006400F8(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_29;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15) {
    goto LABEL_29;
  }
LABEL_10:
  pthread_mutex_lock(&stru_101B0A598);
  uint64_t v17 = off_101B0A5D8;
  if (!off_101B0A5D8) {
    sub_100159824(__p);
  }
  unsigned int v18 = (std::__shared_weak_count *)*(&off_101B0A5D8 + 1);
  if (*(&off_101B0A5D8 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B0A5D8 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A598);
  BOOL v19 = *(void (**)(uint64_t *, void **))(v17 + 8);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (!v19)
  {
LABEL_29:
    BOOL v22 = 0;
    if (v16) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  v27[0] = a4;
  v27[1] = "kCTSmsPdu";
  sub_100048BAC((uint64_t)v27, &object);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v32 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  pthread_mutex_lock(&stru_101B0A5E8);
  uint64_t v20 = xmmword_101B0A628;
  if (!(void)xmmword_101B0A628) {
    operator new();
  }
  char v21 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A628 + 1);
  if (*((void *)&xmmword_101B0A628 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0A628 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A5E8);
  uint64_t v25 = v20;
  uint64_t v26 = v21;
  v19(&v25, v29);
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  BOOL v22 = 1;
  if ((v16 & 1) == 0) {
LABEL_30:
  }
    sub_10004D2C8(v14);
LABEL_31:
  xpc_object_t v23 = xpc_BOOL_create(v22);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  __p[0] = *a5;
  __p[1] = "kDidSucceed";
  sub_100035E70((uint64_t)__p, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
}

void sub_1006403F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  pthread_mutex_unlock(&stru_101B0A598);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  _Unwind_Resume(a1);
}

void sub_1006404B0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v26[0] = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, v26);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  unsigned int v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14) {
    goto LABEL_25;
  }
LABEL_10:
  pthread_mutex_lock(&stru_101B0A598);
  uint64_t v16 = off_101B0A5D8;
  if (!off_101B0A5D8) {
    sub_100159824(v26);
  }
  uint64_t v17 = (std::__shared_weak_count *)*(&off_101B0A5D8 + 1);
  if (*(&off_101B0A5D8 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B0A5D8 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A598);
  unsigned int v18 = *(void (**)(uint64_t *))(v16 + 16);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (!v18)
  {
LABEL_25:
    BOOL v21 = 0;
    if (v15) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  pthread_mutex_lock(&stru_101B0A5E8);
  uint64_t v19 = xmmword_101B0A628;
  if (!(void)xmmword_101B0A628) {
    operator new();
  }
  uint64_t v20 = (std::__shared_weak_count *)*((void *)&xmmword_101B0A628 + 1);
  if (*((void *)&xmmword_101B0A628 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0A628 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B0A5E8);
  uint64_t v24 = v19;
  uint64_t v25 = v20;
  v18(&v24);
  if (v25) {
    sub_10004D2C8(v25);
  }
  BOOL v21 = 1;
  if ((v15 & 1) == 0) {
LABEL_26:
  }
    sub_10004D2C8(v13);
LABEL_27:
  xpc_object_t v22 = xpc_BOOL_create(v21);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  v26[0] = *a5;
  v26[1] = (unint64_t)"kDidSucceed";
  sub_100035E70((uint64_t)v26, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
}

void sub_10064073C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&stru_101B0A598);
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1006407B8(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    sub_100640AF8();
    uint64_t v17 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to get SMS Service", (uint8_t *)&buf, 2u);
    }
    goto LABEL_19;
  }
LABEL_11:
  *(void *)&long long buf = a4;
  *((void *)&buf + 1) = "kSmsSubInstance";
  sub_100048BAC((uint64_t)&buf, &object);
  uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
  xpc_release(object);
  if (v19 == 2) {
    uint64_t v20 = 2;
  }
  else {
    uint64_t v20 = v19 == 1;
  }
  if (!v20)
  {
    sub_100640AF8();
    BOOL v21 = qword_101B0D208;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v24;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Emergency Session Status forcing to %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v20 = 1;
  }
  *(void *)&long long buf = a4;
  *((void *)&buf + 1) = "kEmergencySessionStatus";
  sub_100048BAC((uint64_t)&buf, &object);
  uint64_t v23 = xpc::dyn_cast_or_default((xpc *)&object, 0, v22);
  xpc_release(object);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 416))(v15, v20, v23);
LABEL_19:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  xpc_object_t v25 = xpc_BOOL_create(v15 != 0);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)&long long buf = *a5;
  *((void *)&buf + 1) = "kDidSucceed";
  sub_100035E70((uint64_t)&buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
}

void sub_100640A78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100640AF8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D210, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D210))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D208, kCtLoggingSystemName, "msg.model");
    __cxa_guard_release(&qword_101B0D210);
  }
}

void sub_100640B78(_Unwind_Exception *a1)
{
}

CFDataRef sub_100640B90(void *a1, CFDataRef *a2)
{
  CFDataRef result = *a2;
  if (*a2) {
    char v4 = sub_10008324C;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BytePtr = (UInt8 *)CFDataGetBytePtr(result);
    size_t Length = CFDataGetLength(*a2);
    return (const __CFData *)sub_1000D95C8(a1, BytePtr, Length);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  return result;
}

uint64_t sub_100640C20(uint64_t a1, Registry **a2, char *a3, signed int a4, int a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v10 = ServiceMap;
  uint64_t v11 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    unsigned int v12 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = (const char *)v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  int v44 = a5;
  if (v15)
  {
    uint64_t v17 = v15[3];
    char v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  char v16 = 0;
  char v18 = 1;
LABEL_9:
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v20 = v19;
  if (v21 < 0)
  {
    BOOL v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  *(void *)long long buf = v21;
  xpc_object_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
  char __sz_4 = v18;
  if (v25)
  {
    uint64_t v26 = v25[3];
    char v27 = (std::__shared_weak_count *)v25[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      char v28 = 0;
      if (!v17) {
        goto LABEL_27;
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v20);
  char v27 = 0;
  char v28 = 1;
  if (!v17)
  {
LABEL_27:
    sub_100640AF8();
    xpc_object_t v38 = qword_101B0D208;
    char v34 = v18;
    if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v39 = "#I unable to send message: Registry failed to provide MessageCenterModel or MMSDataCache.";
    goto LABEL_29;
  }
LABEL_18:
  if (!v26) {
    goto LABEL_27;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v26 + 168))(v26, a1)
    && (sub_1006437A0(a1, *a2) & 1) == 0)
  {
    sub_100640AF8();
    xpc_object_t v38 = qword_101B0D208;
    char v34 = v18;
    if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      xpc_object_t v39 = "#I unable to send message: Sim is not ready.";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v39, buf, 2u);
      goto LABEL_40;
    }
    goto LABEL_40;
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v26 + 96))(v26, a1) & 1) == 0)
  {
    sub_100640AF8();
    uint64_t v40 = qword_101B0D208;
    char v34 = v18;
    if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v35 = "unable to send message: MMS not configured";
LABEL_38:
    xpc_object_t v36 = v40;
    uint32_t v37 = 2;
LABEL_39:
    _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_40;
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v26 + 104))(v26, a1) & 1) == 0)
  {
    sub_100640AF8();
    uint64_t v40 = qword_101B0D208;
    char v34 = v18;
    if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v35 = "unable to send message: user disabled MMS";
    goto LABEL_38;
  }
  uint64_t v29 = v27;
  int v30 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 280))(v17, a1);
  if ((((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v26 + 64))(v26, a1) | v30) & 1) == 0)
  {
    sub_100640AF8();
    uint64_t v40 = qword_101B0D208;
    char v34 = __sz_4;
    char v27 = v29;
    if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    xpc_object_t v35 = "unable to send message: data not available";
    goto LABEL_38;
  }
  int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v26 + 136))(v26, a1);
  if (v31 < a4)
  {
    int v32 = v31;
    sub_100640AF8();
    uint64_t v33 = qword_101B0D208;
    char v34 = __sz_4;
    char v27 = v29;
    if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a4;
    LOWORD(v48[0]) = 1024;
    *(_DWORD *)((char *)v48 + 2) = v32;
    xpc_object_t v35 = "unable to send message: too large (%u bytes, max = %u bytes)";
    xpc_object_t v36 = v33;
    uint32_t v37 = 14;
    goto LABEL_39;
  }
  if (((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v26 + 56))(v26, a1) | v30) != 1
    || (int v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v26 + 144))(v26, a1), v42 >= a4))
  {
    *(_DWORD *)long long buf = a1;
    memset(v48, 0, sizeof(v48));
    sub_10014BD54((char *)v48, a3, &a3[a4], a4);
    int v49 = v44;
    char v50 = 1;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v26 + 192))(&v51, v26, a1);
    sub_1006438DC();
  }
  sub_100640AF8();
  xpc_object_t v43 = qword_101B0D208;
  char v34 = __sz_4;
  if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a4;
    LOWORD(v48[0]) = 1024;
    *(_DWORD *)((char *)v48 + 2) = v42;
    _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "unable to send message: too large over satellite (%u bytes, max over satellite = %u bytes)", buf, 0xEu);
  }
  char v27 = v29;
LABEL_40:
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  return 0xFFFFFFFFLL;
}

void sub_10064158C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25,uint64_t a26,uint64_t a27,char a28,void *__p,uint64_t a30)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006416E8()
{
  if (v0) {
    JUMPOUT(0x1006416E0);
  }
  JUMPOUT(0x1006416D8);
}

uint64_t sub_1006416F4(Registry **a1, xpc_object_t *a2)
{
  *(void *)long long buf = a2;
  *(void *)&uint8_t buf[8] = "kSmsSubInstance";
  sub_100048BAC((uint64_t)buf, object);
  uint64_t v5 = xpc::dyn_cast_or_default((xpc *)object, 0, v4);
  xpc_release(object[0]);
  if (v5 == 2) {
    uint64_t v6 = 2;
  }
  else {
    uint64_t v6 = v5 == 1;
  }
  if (v6)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    unint64_t v8 = ServiceMap;
    uint64_t v10 = v9;
    if (v9 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    unsigned int v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v15 = v14[3];
      char v16 = (std::__shared_weak_count *)v14[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::string v68 = v16;
        sub_10004D2C8(v16);
        char v70 = 0;
        if (!v15) {
          goto LABEL_11;
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    std::string v68 = 0;
    char v70 = 1;
    if (!v15)
    {
LABEL_11:
      sub_100640AF8();
      uint64_t v17 = qword_101B0D208;
      if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "SMS service not available", buf, 2u);
      }
      char v18 = 0;
      if (v70) {
        goto LABEL_110;
      }
LABEL_109:
      sub_10004D2C8(v68);
LABEL_110:
      if (v18) {
        operator delete(v18);
      }
      return 0xFFFFFFFFLL;
    }
LABEL_20:
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 392))(buf, v15, v6);
    uint64_t v20 = *(_DWORD **)&buf[8];
    std::string v69 = *(_DWORD **)buf;
    *(void *)long long buf = a2;
    *(void *)&uint8_t buf[8] = "kBypassSupportedMessageModesCheck";
    sub_100048BAC((uint64_t)buf, object);
    int v22 = xpc::dyn_cast_or_default((xpc *)object, 0, v21);
    xpc_release(object[0]);
    if (v22)
    {
      sub_100640AF8();
      uint64_t v23 = qword_101B0D208;
      int v67 = 0;
      if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I SMS bypass requested (supported modes check skipped)", buf, 2u);
LABEL_28:
        int v67 = 0;
      }
    }
    else
    {
      unsigned int v24 = v69;
      if (v69 != v20)
      {
        while (*v24)
        {
          if (++v24 == v20)
          {
            unsigned int v24 = v20;
            break;
          }
        }
      }
      if (v24 != v20) {
        goto LABEL_28;
      }
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v15 + 360))(v15))
      {
        sub_100640AF8();
        int v30 = qword_101B0D208;
        if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Sms not allowed on device.", buf, 2u);
        }
        goto LABEL_108;
      }
      sub_100640AF8();
      uint64_t v29 = qword_101B0D208;
      if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Emergency only Sms allowed", buf, 2u);
      }
      int v67 = 1;
    }
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v15 + 424))(v15, v6)
      && (sub_1006437A0(v6, *a1) & 1) == 0)
    {
      sub_100640AF8();
      char v28 = qword_101B0D208;
      if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Sim is not ready. SMS sending will fail.", buf, 2u);
      }
      goto LABEL_108;
    }
    *(void *)long long buf = a2;
    *(void *)&uint8_t buf[8] = "kSmsType";
    sub_100048BAC((uint64_t)buf, object);
    int v26 = xpc::dyn_cast_or_default((xpc *)object, 0, v25);
    xpc_release(object[0]);
    if (xpc_dictionary_get_value(*a2, "kSmsBinaryPayload"))
    {
      cf.__r_.__value_.__r.__words[0] = 0;
      *(void *)long long buf = a2;
      *(void *)&uint8_t buf[8] = "kSmsBinaryPayload";
      sub_100048BAC((uint64_t)buf, &v105);
      xpc::bridge((uint64_t *)object, (xpc *)&v105, v27);
      sub_1000C15D8(&cf, (CFTypeRef *)object);
      sub_1000577C4((const void **)object);
      xpc_release(v105.__r_.__value_.__l.__data_);
      object[0] = 0;
      object[1] = 0;
      *(void *)&long long v81 = 0;
      v105.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
      v105.__r_.__value_.__l.__size_ = (std::string::size_type)"kSmsDestinationAddress";
      sub_100048BAC((uint64_t)&v105, &v88);
      memset(buf, 0, sizeof(buf));
      uint64_t v91 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v91) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_release(v88);
      if (!v67)
      {
LABEL_51:
        memset(&v105, 0, sizeof(v105));
        xpc_object_t v88 = a2;
        long long v89 = "kSmsSmscAddress";
        sub_100048BAC((uint64_t)&v88, &v86);
        memset(buf, 0, sizeof(buf));
        uint64_t v91 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v91) < 0) {
          operator delete(*(void **)buf);
        }
        xpc_release(v86.__r_.__value_.__l.__data_);
        *(void *)long long buf = a2;
        *(void *)&uint8_t buf[8] = "kSmsApplicationAddressingScheme";
        sub_100048BAC((uint64_t)buf, &v88);
        int v35 = xpc::dyn_cast_or_default((xpc *)&v88, 0, v34);
        xpc_release(v88);
        *(void *)long long buf = a2;
        *(void *)&uint8_t buf[8] = "kSmsApplicationSourcePort";
        sub_100048BAC((uint64_t)buf, &v88);
        int v37 = xpc::dyn_cast_or_default((xpc *)&v88, 0, v36);
        xpc_release(v88);
        *(void *)long long buf = a2;
        *(void *)&uint8_t buf[8] = "kSmsApplicationDestinationPort";
        sub_100048BAC((uint64_t)buf, &v88);
        int v39 = xpc::dyn_cast_or_default((xpc *)&v88, 0, v38);
        xpc_release(v88);
        if (v35 == 2) {
          char v40 = 1;
        }
        else {
          char v40 = 2 * (v35 != 1);
        }
        xpc_object_t v88 = 0;
        long long v89 = 0;
        if (SBYTE7(v81) < 0)
        {
          sub_10004FC84(buf, object[0], (unint64_t)object[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)object;
          uint64_t v91 = v81;
        }
        int v92 = v6;
        std::string::size_type v76 = cf.__r_.__value_.__r.__words[0];
        if (cf.__r_.__value_.__r.__words[0]) {
          CFRetain(cf.__r_.__value_.__l.__data_);
        }
        sub_100640B90(&v93, (CFDataRef *)&v76);
        if (v26 == 1) {
          int v41 = 4;
        }
        else {
          int v41 = 1;
        }
        int v94 = v41;
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, v105.__r_.__value_.__l.__data_, v105.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v105;
        }
        uint64_t v96 = 0;
        char v97 = 0;
        int v98 = v37;
        int v99 = v39;
        char v100 = v40;
        int v101 = 0x1000000;
        int v102 = 4;
        LOBYTE(v103) = 0;
        char v104 = 0;
        sub_100643AD0();
      }
      if (SBYTE7(v81) < 0)
      {
        sub_10004FC84(__dst, object[0], (unint64_t)object[1]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)object;
        uint64_t v78 = v81;
      }
      int v31 = (*(uint64_t (**)(uint64_t, uint64_t, void **))(*(void *)v15 + 352))(v15, v6, __dst);
      int v32 = v31;
      if (SHIBYTE(v78) < 0)
      {
        operator delete(__dst[0]);
        if (v32)
        {
LABEL_49:
          sub_100640AF8();
          uint64_t v33 = qword_101B0D208;
          if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Emergency destination detected", buf, 2u);
          }
          goto LABEL_51;
        }
      }
      else if (v31)
      {
        goto LABEL_49;
      }
      sub_100640AF8();
      int v42 = qword_101B0D208;
      if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I MO-SMS not allowed on device.", buf, 2u);
      }
      if (SBYTE7(v81) < 0) {
        operator delete(object[0]);
      }
      sub_100030068((const void **)&cf.__r_.__value_.__l.__data_);
LABEL_108:
      char v18 = v69;
      if (v70) {
        goto LABEL_110;
      }
      goto LABEL_109;
    }
    if (!xpc_dictionary_get_value(*a2, "kSmsMessageBody")) {
      goto LABEL_108;
    }
    CFTypeRef v75 = 0;
    *(void *)long long buf = a2;
    *(void *)&uint8_t buf[8] = "kSmsMessageBody";
    sub_100048BAC((uint64_t)buf, &v105);
    xpc::bridge((uint64_t *)object, (xpc *)&v105, v43);
    sub_1000C15D8(&v75, (CFTypeRef *)object);
    sub_1000577C4((const void **)object);
    xpc_release(v105.__r_.__value_.__l.__data_);
    *(void *)long long buf = a2;
    *(void *)&uint8_t buf[8] = "kSmsMessageID";
    sub_100048BAC((uint64_t)buf, object);
    xpc::dyn_cast_or_default((xpc *)object, (const object *)0xFFFFFFFFLL, v44);
    xpc_release(object[0]);
    *(void *)long long buf = a2;
    *(void *)&uint8_t buf[8] = "kSmsMoreMessages";
    sub_100048BAC((uint64_t)buf, object);
    xpc::dyn_cast_or_default((xpc *)object, 0, v45);
    xpc_release(object[0]);
    long long v72 = 0;
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    CFTypeRef v71 = v75;
    if (v75) {
      CFRetain(v75);
    }
    sub_100640B90(&v72, (CFDataRef *)&v71);
    sub_100030068(&v71);
    int v46 = HIBYTE(v74);
    uint64_t v47 = (void **)v72;
    int v48 = v73;
    memset(&cf, 0, sizeof(cf));
    memset(&v86, 0, sizeof(v86));
    memset(&v85, 0, sizeof(v85));
    memset(&v84, 0, sizeof(v84));
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    *(_OWORD *)xpc_object_t object = 0u;
    long long v81 = 0u;
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)object, "com.apple.telephony", "msg.mms.pdu");
    if ((v46 & 0x80u) == 0) {
      int v49 = v46;
    }
    else {
      int v49 = v48;
    }
    char v50 = &v72;
    if ((v46 & 0x80u) != 0) {
      char v50 = v47;
    }
    LOWORD(v82) = 1;
    BYTE2(v82) = 1;
    HIDWORD(v82) = v6;
    object[1] = v50;
    HIDWORD(v81) = 106;
    LODWORD(v81) = v49;
    *(void *)((char *)&v81 + 4) = 0x6A00000000;
    if (sub_100FEFBD8((uint64_t)object, &v83, &cf, &v86, &v85, &v84))
    {
      std::string::size_type size = HIBYTE(cf.__r_.__value_.__r.__words[2]);
      if ((cf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = cf.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        if (!v67) {
          goto LABEL_123;
        }
        uint64_t v52 = (std::mutex *)Registry::getServiceMap(*a1);
        int v53 = v52;
        uint64_t v54 = v9;
        if (v9 < 0)
        {
          xpc_object_t v55 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v56 = 5381;
          do
          {
            uint64_t v54 = v56;
            unsigned int v57 = *v55++;
            uint64_t v56 = (33 * v56) ^ v57;
          }
          while (v57);
        }
        std::mutex::lock(v52);
        *(void *)long long buf = v54;
        xpc_object_t v58 = sub_10004D37C(&v53[1].__m_.__sig, (unint64_t *)buf);
        if (v58)
        {
          uint64_t v60 = v58[3];
          CFTypeRef v59 = (std::__shared_weak_count *)v58[4];
          if (v59)
          {
            atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v53);
            atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v59);
            char v61 = 0;
LABEL_115:
            if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v79, cf.__r_.__value_.__l.__data_, cf.__r_.__value_.__l.__size_);
            }
            else {
              std::string v79 = cf;
            }
            char v65 = (*(uint64_t (**)(uint64_t, uint64_t, std::string *))(*(void *)v60 + 352))(v60, v6, &v79);
            if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v79.__r_.__value_.__l.__data_);
            }
            if (v65)
            {
              if ((v61 & 1) == 0) {
                sub_10004D2C8(v59);
              }
LABEL_123:
              xpc_object_t v88 = 0;
              long long v89 = 0;
              sub_100B968D0(&v88);
            }
            sub_100640AF8();
            int v66 = qword_101B0D208;
            if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Non-Emergency SMS not allowed", buf, 2u);
              if (v61) {
                goto LABEL_97;
              }
              goto LABEL_126;
            }
            if ((v61 & 1) == 0) {
LABEL_126:
            }
              sub_10004D2C8(v59);
LABEL_97:
            ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)object);
            if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v84.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v85.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v86.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(cf.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v74) < 0) {
              operator delete(v72);
            }
            sub_100030068(&v75);
            goto LABEL_108;
          }
        }
        else
        {
          uint64_t v60 = 0;
        }
        std::mutex::unlock(v53);
        CFTypeRef v59 = 0;
        char v61 = 1;
        goto LABEL_115;
      }
      sub_100640AF8();
      uint64_t v62 = qword_101B0D208;
      if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
        goto LABEL_97;
      }
      *(_WORD *)long long buf = 0;
      long long v63 = "SMS: no recipient address specified";
    }
    else
    {
      sub_100640AF8();
      uint64_t v62 = qword_101B0D208;
      if (!os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR)) {
        goto LABEL_97;
      }
      *(_WORD *)long long buf = 0;
      long long v63 = "unable to deserialize sms";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, v63, buf, 2u);
    goto LABEL_97;
  }
  sub_100640AF8();
  uint64_t v19 = qword_101B0D208;
  if (os_log_type_enabled((os_log_t)qword_101B0D208, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid slot while queuing SMS.", buf, 2u);
  }
  return 0xFFFFFFFFLL;
}

void sub_100643198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, int a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, int a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,const void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,xpc_object_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,xpc_object_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a74 < 0) {
    operator delete(__p);
  }
  uint64_t v76 = a72;
  a72 = 0;
  if (v76) {
    (*(void (**)(uint64_t))(*(void *)v76 + 8))(v76);
  }
  if (a35) {
    sub_10004D2C8((std::__shared_weak_count *)a35);
  }
  if ((v74 & 1) == 0) {
    sub_10004D2C8(a13);
  }
  if ((a15 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a40);
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  if (a63 < 0) {
    operator delete(a58);
  }
  if (a69 < 0) {
    operator delete(a64);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_100030068(&a28);
  if ((a20 & 1) == 0) {
    sub_10004D2C8(a17);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006437A0(uint64_t a1, Registry *this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    uint64_t v13 = 0;
    if (v12) {
      return v13;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v13 = (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v11 + 248))(v11, a1) ^ 1;
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
  return v13;
}

void sub_1006438C0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006438DC()
{
}

void sub_1006439AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  _Unwind_Resume(a1);
}

void *sub_1006439E0(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  unsigned int v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100643A24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100643A5C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_100643A8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100643AD0()
{
}

uint64_t sub_100643BAC(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100643C00(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100643C68(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100643CA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100643CDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_100643D0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100643D50()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D220, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D220))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D218, kCtLoggingSystemName, "cs");
    __cxa_guard_release(&qword_101B0D220);
  }
}

void sub_100643DD0(_Unwind_Exception *a1)
{
}

uint64_t sub_100643DE8()
{
  if ((byte_101B0D1F0 & 1) == 0)
  {
    byte_101B0D1F0 = 1;
    return __cxa_atexit((void (*)(void *))sub_10063DB80, &stru_101B0A598, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_100643E24()
{
  if ((byte_101B0D1F8 & 1) == 0)
  {
    byte_101B0D1F8 = 1;
    return __cxa_atexit((void (*)(void *))sub_10063DBD8, &unk_101B0A5E8, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_100643E60()
{
  sub_100C624B8((uint64_t)&unk_101B0D202, (uint64_t)sub_10063DC30);
}

void *sub_100643EB4(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  char v12 = "DATA.Connection.EmLoc.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    char v12 = "DATA.Connection.EmLoc.2";
  }
  unsigned int v14 = "EmLoc.X";
  if (v13 == 2) {
    unsigned int v14 = "EmLoc.2";
  }
  if (v13 == 1) {
    unint64_t v15 = "DATA.Connection.EmLoc.1";
  }
  else {
    unint64_t v15 = v12;
  }
  if (v13 == 1) {
    char v16 = "EmLoc.1";
  }
  else {
    char v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_1019F2998, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_1019F1F60;
  a1[8] = off_1019F24B0;
  a1[9] = off_1019F2740;
  a1[10] = off_1019F2930;
  return a1;
}

void sub_100644040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_10064406C(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019F2998);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_10064409C(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_1019F2998);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1006440D0(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_1019F2998);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100644104(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_1019F2998);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100644138(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019F2998);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_10064417C(uint64_t a1)
{
}

void sub_100644184(uint64_t a1)
{
}

void sub_10064418C(uint64_t a1)
{
}

uint64_t sub_100644194()
{
  return 0x10101000000;
}

uint64_t sub_1006441A4()
{
  return 0x10101000000;
}

uint64_t sub_1006441B4()
{
  return 0;
}

uint64_t sub_1006441BC()
{
  return 100;
}

uint64_t sub_1006441C4()
{
  return 0;
}

uint64_t sub_1006441CC()
{
  return 100;
}

void sub_1006441D4(void *a1@<X8>)
{
  if (qword_101B13DE8 != -1) {
    dispatch_once(&qword_101B13DE8, &stru_1019F37C8);
  }
  uint64_t v2 = qword_101B13DF0;
  *a1 = 0;
  a1[1] = 0;
  if (v2) {
    sub_100644914();
  }
}

void sub_100644258(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v2, kCtLoggingSystemName, "bk.device");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v3, &v2);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v3);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v2);
  *a1 = off_1019F3728;
  a1[4] = 0;
  a1[5] = 0;
  operator new();
}

void sub_100644398()
{
  operator delete();
}

id sub_100644420(uint64_t a1, const char *a2)
{
  id v4 = *(id *)(*(void *)(a1 + 48) + 8);
  if (!v4)
  {
    uint64_t v9 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v19 = asString();
      uint64_t v7 = "No biometric device present of type %s";
      unsigned int v8 = v9;
      goto LABEL_18;
    }
LABEL_6:
    id v10 = 0;
    goto LABEL_16;
  }
  unint64_t v5 = sub_100644694(a2);
  uint64_t v6 = *(NSObject **)(a1 + 24);
  if (!HIDWORD(v5))
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v19 = (uint64_t)a2;
      uint64_t v7 = "Could not get UID for user '%s'";
      unsigned int v8 = v6;
LABEL_18:
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, buf, 0xCu);
      goto LABEL_6;
    }
    goto LABEL_6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v19 = asString();
    __int16 v20 = 2080;
    BOOL v21 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Attempting to force bio-lockout for device type %s, user '%s'", buf, 0x16u);
  }
  id v17 = 0;
  id v10 = [v4 forceBioLockoutIfLockedForUser:v5 error:&v17];
  id v11 = v17;
  if (v11) {
    char v12 = (char)v10;
  }
  else {
    char v12 = 1;
  }
  if ((v12 & 1) == 0)
  {
    int v13 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v15 = [v11 localizedDescription];
      char v16 = (const char *)[v15 UTF8String];
      *(_DWORD *)long long buf = 136315394;
      uint64_t v19 = (uint64_t)a2;
      __int16 v20 = 2080;
      BOOL v21 = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to force bio-lockout for user '%s', error: %s", buf, 0x16u);
    }
  }

LABEL_16:
  return v10;
}

void sub_100644658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t sub_100644694(const char *a1)
{
  uint64_t v2 = sysconf(71);
  if (v2 == -1) {
    return 0;
  }
  size_t v3 = v2;
  id v4 = (char *)&v8 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v4, v3);
  memset(&v10, 0, sizeof(v10));
  uint64_t v9 = 0;
  int v5 = getpwnam_r(a1, &v10, v4, v3, &v9);
  if (v9) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return v10.pw_uid | (unint64_t)&_mh_execute_header;
  }
  else {
    return 0;
  }
}

void sub_10064478C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1019F3728;
  sub_1006448B4(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  size_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  BiometricKitDeviceInterface::~BiometricKitDeviceInterface((BiometricKitDeviceInterface *)a1);
}

void sub_100644800(uint64_t *a1)
{
  *a1 = (uint64_t)off_1019F3728;
  sub_1006448B4(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  size_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  BiometricKitDeviceInterface::~BiometricKitDeviceInterface((BiometricKitDeviceInterface *)a1);

  operator delete();
}

void sub_100644888(id a1)
{
  qword_101B13DF0 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/BiometricKit.framework/BiometricKit", 1);
}

uint64_t *sub_1006448B4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

void sub_100644914()
{
  char v0 = operator new(0x50uLL);
  sub_100644990(v0);
}

void sub_10064497C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100644990(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019F37F8;
  sub_100644258(a1 + 3);
}

void sub_1006449F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100644A0C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019F37F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100644A2C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019F37F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100644A80(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100644AA8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1019F3728;
  sub_1006448B4(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  size_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  BiometricKitDeviceInterface::~BiometricKitDeviceInterface((BiometricKitDeviceInterface *)a1);
}

void sub_100644B1C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1019F3728;
  sub_1006448B4(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  size_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  BiometricKitDeviceInterface::~BiometricKitDeviceInterface((BiometricKitDeviceInterface *)a1);

  operator delete();
}

void sub_100644BA4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100644EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100645000(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  id v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100645100(uint64_t *result, unint64_t a2)
{
  size_t v3 = result;
  int v5 = (uint64_t **)(result + 13);
  id v4 = (uint64_t *)result[13];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        BOOL v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if (v7 <= a2) {
          break;
        }
        id v4 = *v6;
        int v5 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2) {
        break;
      }
      id v4 = v6[1];
      if (!v4)
      {
        int v5 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v6 = (uint64_t **)(result + 13);
LABEL_9:
    uint64_t v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = a2;
    uint64_t *v8 = 0;
    v8[1] = 0;
    _OWORD v8[2] = (uint64_t)v6;
    *int v5 = v8;
    uint64_t v9 = *(void *)v3[12];
    if (v9)
    {
      v3[12] = v9;
      passwd v10 = *v5;
    }
    else
    {
      passwd v10 = v8;
    }
    uint64_t result = sub_100046C90((uint64_t *)v3[13], v10);
    ++v3[14];
  }
  return result;
}

const void **sub_1006451B8(void *a1, const void *a2, const void *a3)
{
  CFMutableDictionaryRef theDict = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v7 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v10 = v7;
    sub_10005717C((const void **)&v10);
  }
  CFDictionaryAddValue(theDict, @"msg-name", a2);
  if (a3) {
    CFDictionaryAddValue(theDict, @"msg-body", a3);
  }
  sub_100062708(a1, theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_10064526C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void *sub_100645280(void *a1, const __CFDictionary *cf)
{
  if (cf)
  {
    CFDictionaryRef v3 = cf;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID()
      && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v3, @"msg-name")) != 0)
    {
      CFDictionaryRef v6 = Value;
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFStringGetTypeID()) {
        std::string cf = v6;
      }
      else {
        std::string cf = 0;
      }
    }
    else
    {
      std::string cf = 0;
    }
  }

  return sub_100056210(a1, cf);
}

void *sub_100645310(void *a1, const __CFDictionary *cf)
{
  if (cf)
  {
    CFDictionaryRef v3 = cf;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID()) {
      std::string cf = (const __CFDictionary *)CFDictionaryGetValue(v3, @"msg-body");
    }
    else {
      std::string cf = 0;
    }
  }

  return sub_100062708(a1, cf);
}

const void **sub_100645388(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v9 = 0;
  sub_1000584C8(&v7, a2);
  sub_100119B5C(&v8, a2 + 1);
  (*(void (**)(uint64_t, const void **, const __CFString *, const void **, uint64_t))(*(void *)a1 + 16))(a1, &v9, @"P2WSettingsManager", &v7, a3);
  sub_1000FE824(&v8);
  sub_1000577C4(&v7);
  return sub_1000558F4(&v9);
}

void sub_100645434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFTypeID v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_1000FE824(v2);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100645458(uint64_t a1, const __CFDictionary **a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  v128[0] = _NSConcreteStackBlock;
  v128[1] = 0x40000000;
  unsigned int v129 = sub_100646908;
  v130 = &unk_1019F38E8;
  uint64_t v131 = a3;
  sub_100645280(&cf, *a2);
  CFTypeRef v126 = 0;
  sub_100645310(&v126, *a2);
  CFStringRef v6 = (const __CFString *)cf;
  if (cf) {
    CFTypeID v7 = sub_1000810B8;
  }
  else {
    CFTypeID v7 = 0;
  }
  if (v7)
  {
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    char v121 = sub_10064699C;
    v122 = &unk_1019F3910;
    uint64_t v123 = a3;
    uint64_t v124 = a1;
    CFTypeRef v125 = cf;
    if (cf)
    {
      CFRetain(cf);
      CFStringRef v6 = (const __CFString *)cf;
    }
    if (CFStringCompare(v6, @"enable-cell-data-set", 0))
    {
      if (CFStringCompare((CFStringRef)cf, @"enable-cell-data-get", 0))
      {
        if (CFStringCompare((CFStringRef)cf, @"xpc-command-forwarding", 0))
        {
          if (CFStringCompare((CFStringRef)cf, @"cu-workspace-info-get", 0))
          {
            if (CFStringCompare((CFStringRef)cf, @"du-policies-get-queried", 0))
            {
              if (CFStringCompare((CFStringRef)cf, @"du-policies-get", 0))
              {
                if (CFStringCompare((CFStringRef)cf, @"du-policies-set", 0))
                {
                  uint64_t v8 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf) = 138412290;
                    *(void *)((char *)&buf + 4) = cf;
                    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Unknown message %@", (uint8_t *)&buf, 0xCu);
                  }
                  v129((uint64_t)v128, 4);
                }
                else
                {
                  sub_100646A8C(a1, v126, aBlock);
                }
                goto LABEL_76;
              }
              CFTypeRef v61 = v126;
              if (v126 && (CFTypeID v62 = CFGetTypeID(v126), v62 == CFBooleanGetTypeID()))
              {
                *(void *)&long long __p = v61;
                CFRetain(v61);
                uint64_t v63 = __p;
              }
              else
              {
                uint64_t v63 = 0;
                *(void *)&long long __p = 0;
              }
              if (v63) {
                uint64_t v64 = sub_100084B4C;
              }
              else {
                uint64_t v64 = 0;
              }
              if (!v64)
              {
                std::string v79 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#N Message does not specifiy if all policies should be retrieved", (uint8_t *)&buf, 2u);
                }
                v121((const void **)aBlock, 0, 0, 4, 0);
                goto LABEL_223;
              }
              ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
              int v66 = ServiceMap;
              if (v67 < 0)
              {
                std::string v68 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v69 = 5381;
                do
                {
                  uint64_t v67 = v69;
                  unsigned int v70 = *v68++;
                  uint64_t v69 = (33 * v69) ^ v70;
                }
                while (v70);
              }
              std::mutex::lock(ServiceMap);
              *(void *)&long long buf = v67;
              CFTypeRef v71 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)&buf);
              if (v71)
              {
                uint64_t v73 = v71[3];
                long long v72 = (std::__shared_weak_count *)v71[4];
                if (v72)
                {
                  atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v66);
                  atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v72);
                  char v74 = 0;
LABEL_142:
                  if (v73)
                  {
                    uint64_t v80 = _Block_copy(aBlock);
                    LOBYTE(buf) = 0;
                    ctu::cf::assign((ctu::cf *)&buf, (BOOL *)__p, v81);
                    int v82 = buf;
                    *(void *)&long long v138 = a1;
                    if (v80) {
                      uint64_t v83 = _Block_copy(v80);
                    }
                    else {
                      uint64_t v83 = 0;
                    }
                    *(void *)&long long buf = off_1019F3F50;
                    *((void *)&buf + 1) = a1;
                    *((void *)&v138 + 1) = 0;
                    v141 = v83;
                    p_long long buf = &buf;
                    (*(void (**)(uint64_t, BOOL, long long *))(*(void *)v73 + 72))(v73, v82 != 0, &buf);
                    sub_1000D9148(&buf);
                    if (*((void *)&v138 + 1)) {
                      _Block_release(*((const void **)&v138 + 1));
                    }
                    if (v80) {
                      _Block_release(v80);
                    }
                  }
                  else
                  {
                    v121((const void **)aBlock, 0, 0, 2, 0);
                  }
                  if ((v74 & 1) == 0) {
                    sub_10004D2C8(v72);
                  }
LABEL_223:
                  sub_100062778((const void **)&__p);
                  goto LABEL_76;
                }
              }
              else
              {
                uint64_t v73 = 0;
              }
              std::mutex::unlock(v66);
              long long v72 = 0;
              char v74 = 1;
              goto LABEL_142;
            }
            int v49 = (void *)v126;
            if (v126 && (CFTypeID v50 = CFGetTypeID(v126), v50 == CFArrayGetTypeID()))
            {
              xpc_object_t object = v49;
              CFRetain(v49);
              CFArrayRef v51 = (const __CFArray *)object;
            }
            else
            {
              CFArrayRef v51 = 0;
              xpc_object_t object = 0;
            }
            if (v51) {
              uint64_t v54 = sub_100083F10;
            }
            else {
              uint64_t v54 = 0;
            }
            if (!v54)
            {
              CFTypeRef v75 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#N Message does not specifiy policies to be retrieved", (uint8_t *)&buf, 2u);
              }
              v121((const void **)aBlock, 0, 0, 4, 0);
              goto LABEL_232;
            }
            long long v133 = 0uLL;
            v134 = 0;
            CFArrayRef theArray = v51;
            if (v51)
            {
              CFRetain(v51);
              CFArrayRef v51 = theArray;
            }
            if (v51) {
              xpc_object_t v55 = sub_100083F10;
            }
            else {
              xpc_object_t v55 = 0;
            }
            if (!v55)
            {
              *((void *)&v133 + 1) = 0;
              v134 = 0;
              *(void *)&long long v133 = (char *)&v133 + 8;
              goto LABEL_151;
            }
            *((void *)&v138 + 1) = 0;
            v139 = 0;
            *(void *)&long long v138 = (char *)&v138 + 8;
            CFIndex Count = CFArrayGetCount(v51);
            if (Count >= 1)
            {
              CFIndex v57 = 0;
              do
              {
                long long __p = 0uLL;
                v137 = 0;
                CFArrayGetValueAtIndex(theArray, v57);
                long long buf = 0uLL;
                v141 = 0;
                ctu::cf::assign();
                long long __p = buf;
                v137 = v141;
                uint64_t v58 = SHIBYTE(v141) >= 0 ? HIBYTE(v137) : *((void *)&__p + 1);
                if (v58)
                {
                  sub_1000F29CC((uint64_t **)&v138, (void **)&__p, (uint64_t)&__p);
                }
                else
                {
                  CFTypeRef v59 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#N Found empty bundle ID", (uint8_t *)&buf, 2u);
                  }
                  *((void *)&v133 + 1) = 0;
                  v134 = 0;
                  *(void *)&long long v133 = (char *)&v133 + 8;
                }
                if (SHIBYTE(v137) < 0) {
                  operator delete((void *)__p);
                }
                if (!v58) {
                  goto LABEL_150;
                }
              }
              while (Count != ++v57);
            }
            uint64_t v60 = v139;
            if (v60 == (void *)CFArrayGetCount(theArray))
            {
              long long v133 = v138;
              v134 = v139;
              if (v139)
              {
                *(void *)(*((void *)&v138 + 1) + 16) = (char *)&v133 + 8;
                *(void *)&long long v138 = (char *)&v138 + 8;
                *((void *)&v138 + 1) = 0;
                v139 = 0;
LABEL_150:
                sub_10005CD2C((uint64_t)&v138, *((char **)&v138 + 1));
LABEL_151:
                sub_100044D00((const void **)&theArray);
                if (!v134)
                {
                  unint64_t v95 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#N Unable to parse ids", (uint8_t *)&buf, 2u);
                  }
                  v121((const void **)aBlock, 0, 0, 4, 0);
                  goto LABEL_231;
                }
                std::string v85 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
                std::string v86 = v85;
                if (v87 < 0)
                {
                  xpc_object_t v88 = (unsigned __int8 *)(v87 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v89 = 5381;
                  do
                  {
                    uint64_t v87 = v89;
                    unsigned int v90 = *v88++;
                    uint64_t v89 = (33 * v89) ^ v90;
                  }
                  while (v90);
                }
                std::mutex::lock(v85);
                *(void *)&long long buf = v87;
                uint64_t v91 = sub_10004D37C(&v86[1].__m_.__sig, (unint64_t *)&buf);
                if (v91)
                {
                  uint64_t v93 = v91[3];
                  int v92 = (std::__shared_weak_count *)v91[4];
                  if (v92)
                  {
                    atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v86);
                    atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v92);
                    char v94 = 0;
LABEL_163:
                    if (v93)
                    {
                      uint64_t v96 = _Block_copy(aBlock);
                      sub_1000C6BDC((uint64_t *)&v138, (uint64_t)&v133);
                      *(void *)&long long __p = a1;
                      if (v96) {
                        char v97 = _Block_copy(v96);
                      }
                      else {
                        char v97 = 0;
                      }
                      *(void *)&long long buf = off_1019F3ED0;
                      *((void *)&buf + 1) = a1;
                      *((void *)&__p + 1) = 0;
                      v141 = v97;
                      p_long long buf = &buf;
                      (*(void (**)(uint64_t, long long *, long long *))(*(void *)v93 + 32))(v93, &v138, &buf);
                      sub_1000D86BC(&buf);
                      if (*((void *)&__p + 1)) {
                        _Block_release(*((const void **)&__p + 1));
                      }
                      sub_10005CD2C((uint64_t)&v138, *((char **)&v138 + 1));
                      if (v96) {
                        _Block_release(v96);
                      }
                    }
                    else
                    {
                      v121((const void **)aBlock, 0, 0, 2, 0);
                    }
                    if ((v94 & 1) == 0) {
                      sub_10004D2C8(v92);
                    }
LABEL_231:
                    sub_10005CD2C((uint64_t)&v133, *((char **)&v133 + 1));
LABEL_232:
                    sub_100044D00((const void **)&object);
                    goto LABEL_76;
                  }
                }
                else
                {
                  uint64_t v93 = 0;
                }
                std::mutex::unlock(v86);
                int v92 = 0;
                char v94 = 1;
                goto LABEL_163;
              }
            }
            else
            {
              std::string v84 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#N Did not process the same number of ids sent", (uint8_t *)&buf, 2u);
              }
              *((void *)&v133 + 1) = 0;
              v134 = 0;
            }
            *(void *)&long long v133 = (char *)&v133 + 8;
            goto LABEL_150;
          }
          int v42 = (ctu *)v126;
          if (v126)
          {
            CFTypeID v43 = CFGetTypeID(v126);
            if (v43 == CFDictionaryGetTypeID())
            {
              ctu::cf_to_xpc((uint64_t *)&buf, v42, v44);
              BOOL v45 = (void *)buf;
              *(void *)&long long __p = buf;
              if ((void)buf && xpc_get_type((xpc_object_t)buf) == (xpc_type_t)&_xpc_type_dictionary) {
                xpc_retain(v45);
              }
              else {
                *(void *)&long long __p = xpc_null_create();
              }
              xpc_release((xpc_object_t)buf);
              *(void *)&long long buf = _NSConcreteStackBlock;
              *((void *)&buf + 1) = 0x40000000;
              v141 = sub_10064A284;
              p_long long buf = (long long *)&unk_1019F3B88;
              v143 = aBlock;
              uint64_t v144 = a1;
              uint64_t v98 = *(void *)(a1 + 72);
              *(void *)&long long v138 = *(void *)(a1 + 64);
              *((void *)&v138 + 1) = v98;
              if (v98) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v98 + 8), 1uLL, memory_order_relaxed);
              }
              sub_10071D24C((Registry **)&v138, (xpc_object_t *)&__p, 1, (uint64_t)&buf);
              if (*((void *)&v138 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v138 + 1));
              }
              xpc_release((xpc_object_t)__p);
              goto LABEL_76;
            }
          }
          goto LABEL_42;
        }
        CFDictionaryRef v35 = (const __CFDictionary *)v126;
        if (!v126 || (CFTypeID v36 = CFGetTypeID(v126), v36 != CFDictionaryGetTypeID()))
        {
LABEL_42:
          v121((const void **)aBlock, 0, 0, 4, 0);
LABEL_76:
          sub_1000558F4(&v125);
          goto LABEL_77;
        }
        CFDictionaryGetValue(v35, @"name");
        long long buf = 0uLL;
        v141 = 0;
        ctu::cf::assign();
        long long v138 = buf;
        v139 = v141;
        CFDictionaryRef Value = (ctu *)CFDictionaryGetValue(v35, @"value");
        int v39 = Value;
        if (Value)
        {
          CFTypeID v40 = CFGetTypeID(Value);
          if (v40 == CFDictionaryGetTypeID()) {
            int v41 = v39;
          }
          else {
            int v41 = 0;
          }
        }
        else
        {
          int v41 = 0;
        }
        int v76 = SHIBYTE(v139);
        if (SHIBYTE(v139) >= 0) {
          uint64_t v77 = HIBYTE(v139);
        }
        else {
          uint64_t v77 = *((void *)&v138 + 1);
        }
        if (!v77 || !v41)
        {
          v121((const void **)aBlock, 0, 0, 4, 0);
          goto LABEL_214;
        }
        *(void *)&long long v133 = 0;
        ctu::cf_to_xpc((uint64_t *)&buf, v41, v38);
        uint64_t v78 = (void *)buf;
        *(void *)&long long v133 = buf;
        if ((void)buf && xpc_get_type((xpc_object_t)buf) == (xpc_type_t)&_xpc_type_dictionary) {
          xpc_retain(v78);
        }
        else {
          *(void *)&long long v133 = xpc_null_create();
        }
        xpc_release((xpc_object_t)buf);
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        v141 = sub_1006473AC;
        p_long long buf = (long long *)&unk_1019F39F0;
        v143 = aBlock;
        switch(v77)
        {
          case 14:
            long long v108 = (long long *)v138;
            if (v76 >= 0) {
              long long v108 = &v138;
            }
            uint64_t v109 = *(void *)v108;
            uint64_t v110 = *(void *)((char *)v108 + 6);
            if (v109 != 0x63696C6F5055436BLL || v110 != 0x7845746547796369) {
              goto LABEL_212;
            }
            uint64_t v112 = *(void *)(a1 + 72);
            *(void *)&long long __p = *(void *)(a1 + 64);
            *((void *)&__p + 1) = v112;
            if (v112) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v112 + 8), 1uLL, memory_order_relaxed);
            }
            xpc_object_t object = xpc_null_create();
            doCUPolicyGet((Registry **)&__p, (uint64_t)&v133, &object, (void (**)(void, void))&buf);
            xpc_release(object);
            break;
          case 17:
            uint64_t v113 = (long long *)v138;
            if (v76 >= 0) {
              uint64_t v113 = &v138;
            }
            uint64_t v114 = *(void *)v113;
            uint64_t v115 = *((void *)v113 + 1);
            int v116 = *((unsigned __int8 *)v113 + 16);
            if (v114 != 0x657361724555436BLL || v115 != 0x457364726F636552 || v116 != 120) {
              goto LABEL_212;
            }
            uint64_t v119 = *(void *)(a1 + 72);
            *(void *)&long long __p = *(void *)(a1 + 64);
            *((void *)&__p + 1) = v119;
            if (v119) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v119 + 8), 1uLL, memory_order_relaxed);
            }
            sub_10071DD28((Registry **)&__p, (uint64_t)&v133, (uint64_t)&buf);
            break;
          case 26:
            int v99 = (long long *)v138;
            if (v76 >= 0) {
              int v99 = &v138;
            }
            uint64_t v100 = *(void *)v99;
            uint64_t v101 = *((void *)v99 + 1);
            uint64_t v102 = *((void *)v99 + 2);
            int v103 = *((unsigned __int16 *)v99 + 12);
            BOOL v104 = v100 == 0x617355617461446BLL && v101 == 0x73614C726F466567;
            BOOL v105 = v104 && v102 == 0x73646F6972655074;
            if (!v105 || v103 != 30789)
            {
LABEL_212:
              v121((const void **)aBlock, 0, 0, 4, 0);
LABEL_213:
              xpc_release((xpc_object_t)v133);
LABEL_214:
              if (v76 < 0) {
                operator delete((void *)v138);
              }
              goto LABEL_76;
            }
            uint64_t v107 = *(void *)(a1 + 72);
            *(void *)&long long __p = *(void *)(a1 + 64);
            *((void *)&__p + 1) = v107;
            if (v107) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v107 + 8), 1uLL, memory_order_relaxed);
            }
            sub_10071CCEC((Registry **)&__p, (uint64_t)&v133, (void (**)(void *, xpc_object_t *))&buf);
            break;
          default:
            goto LABEL_212;
        }
        if (*((void *)&__p + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
        }
        goto LABEL_213;
      }
      uint64_t v25 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
      int v26 = v25;
      if (v27 < 0)
      {
        char v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v29 = 5381;
        do
        {
          uint64_t v27 = v29;
          unsigned int v30 = *v28++;
          uint64_t v29 = (33 * v29) ^ v30;
        }
        while (v30);
      }
      std::mutex::lock(v25);
      *(void *)&long long buf = v27;
      int v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)&buf);
      if (v31)
      {
        uint64_t v33 = v31[3];
        int v32 = (std::__shared_weak_count *)v31[4];
        if (v32)
        {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v26);
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v32);
          char v34 = 0;
          if (!v33) {
            goto LABEL_54;
          }
LABEL_50:
          *(void *)&long long buf = 2048;
          if (IsTelephonyRunningExtended(&buf))
          {
            int v46 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 696))(v33);
            uint64_t v47 = &kCFBooleanTrue;
            if (!v46) {
              uint64_t v47 = &kCFBooleanFalse;
            }
            goto LABEL_55;
          }
LABEL_54:
          uint64_t v47 = &kCFBooleanFalse;
LABEL_55:
          CFBooleanRef v48 = *v47;
          *(void *)&long long buf = 0;
          sub_100062778((const void **)&buf);
          *(void *)&long long __p = v48;
          *(void *)&long long v138 = 0;
          sub_100062778((const void **)&v138);
          v121((const void **)aBlock, v48, 0, 0, 0);
          sub_100062778((const void **)&__p);
          if ((v34 & 1) == 0) {
            sub_10004D2C8(v32);
          }
          goto LABEL_76;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      std::mutex::unlock(v26);
      int v32 = 0;
      char v34 = 1;
      if (!v33) {
        goto LABEL_54;
      }
      goto LABEL_50;
    }
    CFMutableDictionaryRef v10 = (BOOL *)v126;
    if (!v126 || (CFTypeID v11 = CFGetTypeID(v126), v11 != CFBooleanGetTypeID()))
    {
      uint64_t v24 = 4;
LABEL_75:
      v121((const void **)aBlock, 0, 0, v24, 0);
      goto LABEL_76;
    }
    LOBYTE(buf) = 0;
    ctu::cf::assign((ctu::cf *)&buf, v10, v12);
    int v13 = buf;
    unsigned int v14 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    id v15 = v14;
    if (v16 < 0)
    {
      id v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(v14);
    *(void *)&long long buf = v16;
    __int16 v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      BOOL v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_63:
        if ((v13 != 0) != (*(unsigned int (**)(uint64_t))(*(void *)v22 + 696))(v22))
        {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v22 + 456))(v22, 0, 3);
          long long v138 = 0uLL;
          (*(void (**)(uint64_t, BOOL, uint64_t, long long *))(*(void *)v22 + 72))(v22, v13 != 0, 1, &v138);
          if (*((void *)&v138 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v138 + 1));
          }
          uint64_t v52 = *(void *)(a1 + 72);
          *(void *)&long long __p = *(void *)(a1 + 64);
          *((void *)&__p + 1) = v52;
          if (v52) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
          }
          sub_100058DB0(&buf, "onSetEnableCellData");
          _DataSettingsChanged(1, (Registry **)&__p, v13, (uint64_t)&buf);
          if (SHIBYTE(v141) < 0) {
            operator delete((void *)buf);
          }
          if (*((void *)&__p + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
          }
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        uint64_t v24 = 0;
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    BOOL v21 = 0;
    char v23 = 1;
    goto LABEL_63;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Message of invalid format:", (uint8_t *)&buf, 2u);
  }
  *(void *)&long long buf = off_1019F3E50;
  *((void *)&buf + 1) = a1;
  p_long long buf = &buf;
  logger::CFTypeRefLogger();
  sub_10012C330(&buf);
  v129((uint64_t)v128, 4);
LABEL_77:
  sub_1000577C4(&v126);
  return sub_1000558F4(&cf);
}

void sub_10064662C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,xpc_object_t object,uint64_t a29,uint64_t a30,xpc_object_t a31,xpc_object_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100646908(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(const void ***)(a1 + 32);
  if (result)
  {
    CFTypeID v4 = 0;
    int v5 = 0;
    CFDictionaryRef v3 = 0;
    ((void (*)(const void **, const void **, const void **, uint64_t, void))result[2])(result, &v5, &v3, a2, 0);
    sub_1000FE824(&v4);
    sub_1000577C4(&v3);
    return sub_1000558F4(&v5);
  }
  return result;
}

void sub_100646974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFDictionaryRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  sub_1000FE824((const void **)va1);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_10064699C(const void **result, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  int v5 = (void (**)(const void *, const void **, const void **, uint64_t, uint64_t))result[4];
  if (v5)
  {
    CFTypeID v11 = 0;
    sub_1006451B8(&v9, result[6], a2);
    CFMutableDictionaryRef v10 = a3;
    if (a3) {
      CFRetain(a3);
    }
    v5[2](v5, &v11, &v9, a4, a5);
    sub_1000FE824(&v10);
    sub_1000577C4(&v9);
    return sub_1000558F4(&v11);
  }
  return result;
}

void sub_100646A4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFTypeID v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_1000FE824(v2);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100646A78(uint64_t a1, uint64_t a2)
{
  return sub_100083DA4((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_100646A84(uint64_t a1)
{
  return sub_1000558F4((const void **)(a1 + 48));
}

const void **sub_100646A8C(uint64_t a1, CFTypeRef cf, void *a3)
{
  if (cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFArrayGetTypeID()))
  {
    CFTypeRef cfa = cf;
    CFRetain(cf);
    CFTypeRef v7 = cf;
  }
  else
  {
    CFTypeRef v7 = 0;
    CFTypeRef cfa = 0;
  }
  if (v7) {
    uint64_t v8 = sub_100083F10;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    (*((void (**)(void *, void, void, uint64_t, void))a3 + 2))(a3, 0, 0, 4, 0);
    return sub_100044D00(&cfa);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  CFMutableDictionaryRef v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    CFBooleanRef v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v11;
  id v15 = sub_10004D37C(&v10[1].__m_.__sig, &v23);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_18:
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  uint64_t v17 = v15[3];
  uint64_t v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_18;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17)
  {
LABEL_15:
    (*((void (**)(void *, void, void, uint64_t, void))a3 + 2))(a3, 0, 0, 2, 0);
    goto LABEL_30;
  }
LABEL_19:
  if (a3) {
    a3 = _Block_copy(a3);
  }
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  CFTypeRef v22 = cfa;
  if (cfa) {
    CFRetain(cfa);
  }
  sub_10064870C(&v23, (CFArrayRef *)&v22, (os_log_t *)(a1 + 40));
  sub_100044D00(&v22);
  if (v25)
  {
    sub_1000E8470(v21, (uint64_t)&v23);
    if (a3) {
      unsigned int v19 = _Block_copy(a3);
    }
    else {
      unsigned int v19 = 0;
    }
    v27[0] = off_1019F3FE0;
    v27[1] = v19;
    void v27[3] = v27;
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 64))(v17, v21, v27);
    sub_100060644(v27);
    sub_10005CD2C((uint64_t)v21, (char *)v21[1]);
    sub_10005CD2C((uint64_t)&v23, v24);
    if (!a3) {
      goto LABEL_30;
    }
  }
  else
  {
    (*((void (**)(void *, void, void, uint64_t, void))a3 + 2))(a3, 0, 0, 5, 0);
    sub_10005CD2C((uint64_t)&v23, v24);
  }
  _Block_release(a3);
LABEL_30:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  return sub_100044D00(&cfa);
}

void sub_100646D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100646E24(uint64_t a1, const __CFString **a2, xpc_object_t *a3, uint64_t *a4)
{
  xpc_object_t v7 = *a3;
  xpc_object_t v11 = v7;
  if (v7)
  {
    xpc_retain(v7);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v11 = v7;
  }
  uint64_t v8 = *a4;
  uint64_t v9 = (std::__shared_weak_count *)a4[1];
  v10[0] = v8;
  v10[1] = (uint64_t)v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100646EF4(a1, a2, &v11, v10, (uint64_t)&stru_1019F3960);
  if (v9) {
    sub_10004D2C8(v9);
  }
  xpc_release(v7);
}

void sub_100646ECC(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(v1);
  _Unwind_Resume(a1);
}

const void **sub_100646EF4(uint64_t a1, const __CFString **a2, xpc_object_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v25 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFBooleanRef v12 = v25;
    uint64_t v25 = Mutable;
    char v28 = v12;
    sub_10005717C((const void **)&v28);
  }
  int v26 = 0;
  uint64_t v27 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v27, a2, (const char *)0x8000100, kCFAllocatorDefault, v11))
  {
    uint64_t v13 = v26;
    int v26 = v27;
    char v28 = v13;
    sub_1000558F4((const void **)&v28);
  }
  unsigned int v14 = v26;
  uint64_t v24 = v26;
  int v26 = 0;
  sub_1000558F4((const void **)&v26);
  CFDictionaryAddValue(v25, @"name", v14);
  sub_1000558F4((const void **)&v24);
  id v15 = v25;
  uint64_t v27 = (__CFDictionary *)*a3;
  if (v27) {
    xpc_retain(v27);
  }
  else {
    uint64_t v27 = (__CFDictionary *)xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v28, (xpc *)&v27, v16);
  CFDictionaryAddValue(v15, @"value", v28);
  sub_1000577C4((const void **)&v28);
  xpc_release(v27);
  sub_1006451B8(&v22, @"xpc-command-forwarding", v25);
  unint64_t v23 = 0;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 1174405120;
  v20[2] = sub_10064717C;
  unint64_t v20[3] = &unk_1019F39B8;
  uint64_t v18 = *a4;
  uint64_t v17 = (std::__shared_weak_count *)a4[1];
  v20[5] = a1;
  v20[6] = v18;
  BOOL v21 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v20[4] = a5;
  sub_100645388(*(void *)(a1 + 48), &v22, (uint64_t)v20);
  sub_1000FE824(&v23);
  sub_1000577C4(&v22);
  if (v21) {
    sub_10004D2C8(v21);
  }
  return sub_10005717C((const void **)&v25);
}

void sub_1006470F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  CFBooleanRef v12 = va_arg(va1, const void *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_1000FE824(v10);
  sub_1000577C4((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10064717C(void *a1, uint64_t a2, const __CFDictionary **a3, int a4)
{
  uint64_t v16 = 0;
  sub_100645280(&v16, *a3);
  uint64_t v15 = 0;
  sub_100645310(&v15, *a3);
  if (!a4)
  {
    if (v15 ? sub_100080934 : 0)
    {
      xpc_object_t object = 0;
      ctu::cf_to_xpc((uint64_t *)&object, v15, v7);
      if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_null)
      {
        xpc_object_t v9 = object;
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 1174405120;
        applier[2] = sub_100647350;
        applier[3] = &unk_1019F3980;
        CFMutableDictionaryRef v10 = (std::__shared_weak_count *)a1[7];
        applier[4] = a1[6];
        uint64_t v13 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        xpc_dictionary_apply(v9, applier);
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      xpc_release(object);
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  sub_1000577C4((const void **)&v15);
  sub_1000558F4(&v16);
  return 1;
}

void sub_1006472FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, xpc_object_t object)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  xpc_release(object);
  sub_1000577C4((const void **)(v16 - 48));
  sub_1000558F4((const void **)(v16 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_100647350(uint64_t a1, const char *a2, void *a3)
{
  CFDictionaryRef v3 = *(void ***)(a1 + 32);
  if (v3) {
    CFTypeID v4 = *v3;
  }
  else {
    CFTypeID v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

uint64_t sub_100647380(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10064739C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1006473AC(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFDictionaryRef v3 = *a2;
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v6, (xpc *)&object, v4);
  (*(void (**)(uint64_t, const void *, void, void, void))(v2 + 16))(v2, v6, 0, 0, 0);
  sub_1000577C4(&v6);
  xpc_release(object);
}

void sub_100647430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, const void *a10)
{
}

const void **sub_10064745C(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = (const void **)&kCFBooleanTrue;
  if (!a2) {
    int v5 = (const void **)&kCFBooleanFalse;
  }
  sub_1006451B8(&v8, @"enable-cell-data-set", *v5);
  xpc_object_t v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10064754C;
  v7[3] = &unk_1019F3A18;
  void v7[4] = a3;
  v7[5] = a1;
  sub_100645388(*(void *)(a1 + 48), &v8, (uint64_t)v7);
  sub_1000FE824(&v9);
  return sub_1000577C4(&v8);
}

void sub_100647530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1000FE824(v7);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10064754C(uint64_t a1, uint64_t a2, const __CFDictionary **a3)
{
  xpc_object_t v7 = 0;
  sub_100645280(&v7, *a3);
  CFTypeID v6 = 0;
  sub_100645310(&v6, *a3);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  sub_1000577C4(&v6);
  sub_1000558F4(&v7);
  return 1;
}

void sub_1006475E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_10064760C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef theArray = 0;
  sub_1000C6BDC((uint64_t *)&v22, a2);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v29 = Mutable;
  if (Mutable) {
    CFTypeID v6 = sub_100289354;
  }
  else {
    CFTypeID v6 = 0;
  }
  uint64_t v7 = v24;
  if (v6) {
    BOOL v8 = v24 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    xpc_object_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = Mutable;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to convert policies.  Array %p, policies %lu", buf, 0x16u);
    }
  }
  else
  {
    CFMutableDictionaryRef v10 = v22;
    if (v22 != &v23)
    {
      do
      {
        CFAllocatorRef v11 = v29;
        if (*((char *)v10 + 55) < 0)
        {
          sub_10004FC84(__dst, v10[4], (unint64_t)v10[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v10 + 2);
          uint64_t v27 = v10[6];
        }
        if (SHIBYTE(v27) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          int v32 = v27;
        }
        unsigned int v30 = 0;
        if (SHIBYTE(v32) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v32;
        }
        uint64_t v33 = 0;
        if (ctu::cf::convert_copy())
        {
          CFBooleanRef v12 = v30;
          unsigned int v30 = v33;
          char v34 = v12;
          sub_1000558F4(&v34);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        int value = v30;
        unsigned int v30 = 0;
        sub_1000558F4((const void **)&v30);
        if (SHIBYTE(v32) < 0) {
          operator delete(__p[0]);
        }
        CFArrayAppendValue(v11, value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v27) < 0) {
          operator delete(__dst[0]);
        }
        uint64_t v13 = v10[1];
        if (v13)
        {
          do
          {
            uint64_t v14 = (char **)v13;
            uint64_t v13 = *(char **)v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (char **)v10[2];
            BOOL v8 = *v14 == (char *)v10;
            CFMutableDictionaryRef v10 = v14;
          }
          while (!v8);
        }
        CFMutableDictionaryRef v10 = v14;
      }
      while (v14 != &v23);
    }
  }
  sub_100044D6C(&theArray, (CFTypeRef *)&v29);
  sub_1000440D4((const void **)&v29);
  sub_10005CD2C((uint64_t)&v22, v23);
  if (theArray) {
    uint64_t v15 = sub_100083F10;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15 && CFArrayGetCount(theArray))
  {
    sub_1006451B8(&v18, @"du-policies-get-queried", theArray);
    unsigned int v19 = 0;
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 1174405120;
    v35[2] = sub_100647B24;
    v35[3] = &unk_1019F3A38;
    v35[4] = a1;
    sub_10064B63C((uint64_t)v36, a3);
    sub_100645388(*(void *)(a1 + 48), &v18, (uint64_t)v35);
    sub_1000FE824(&v19);
    sub_1000577C4(&v18);
    sub_1000E6714(v36);
  }
  else
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "No policies to query", buf, 2u);
    }
    v21[0] = 0;
    v21[1] = 0;
    __int16 v20 = v21;
    sub_100647AD4(*(void *)(a3 + 24), (uint64_t)&v20, 96);
    sub_10005CD2C((uint64_t)&v20, v21[0]);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_1006479F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, const void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_1000E6714(v40);
  sub_1000FE824(v39);
  sub_1000577C4(&a10);
  sub_100044D00(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_100647AD4(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t sub_100647B24(uint64_t a1, uint64_t a2, const __CFDictionary **a3, int a4)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a1 + 32);
  CFTypeRef cf = 0;
  sub_100645310(&cf, *a3);
  if ((a4 - 1) < 5)
  {
    int v7 = *(_DWORD *)&asc_1014D12F4[4 * a4 - 4];
LABEL_80:
    v69[0] = 0;
    v69[1] = 0;
    std::string v68 = v69;
    sub_100647AD4(*(void *)(v5 + 64), (uint64_t)&v68, v7);
    sub_10005CD2C((uint64_t)&v68, v69[0]);
    goto LABEL_92;
  }
  CFTypeRef v8 = cf;
  if (cf) {
    xpc_object_t v9 = sub_100080934;
  }
  else {
    xpc_object_t v9 = 0;
  }
  if (!v9)
  {
    int v7 = 96;
    goto LABEL_80;
  }
  uint64_t v67 = 0;
  if (cf && (CFTypeID v10 = CFGetTypeID(cf), v10 == CFArrayGetTypeID()))
  {
    uint64_t v67 = v8;
    CFRetain(v8);
    CFArrayRef v11 = (const __CFArray *)v8;
  }
  else
  {
    CFArrayRef v11 = 0;
    uint64_t v67 = 0;
  }
  if (v11) {
    CFBooleanRef v12 = sub_100083F10;
  }
  else {
    CFBooleanRef v12 = 0;
  }
  if (!v12)
  {
    v66[0] = 0;
    v66[1] = 0;
    char v65 = v66;
    sub_100647AD4(*(void *)(v5 + 64), (uint64_t)&v65, 96);
    int v53 = (char *)v66[0];
    uint64_t v54 = (uint64_t ***)&v65;
    goto LABEL_91;
  }
  CFTypeID v62 = 0;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  CFArrayRef theArray = v11;
  if (v11)
  {
    CFRetain(v11);
    CFArrayRef v11 = theArray;
  }
  if (v11) {
    uint64_t v13 = sub_100083F10;
  }
  else {
    uint64_t v13 = 0;
  }
  if (!v13)
  {
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    CFTypeID v62 = &v63;
    goto LABEL_90;
  }
  uint64_t v57 = v5;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  long long v72 = &v73;
  CFIndex Count = CFArrayGetCount(v11);
  if (Count < 1)
  {
LABEL_83:
    CFTypeID v62 = v72;
    uint64_t v63 = v73;
    uint64_t v64 = v74;
    if (v74)
    {
      void v73[2] = (uint64_t)&v63;
      long long v72 = &v73;
      uint64_t v73 = 0;
      uint64_t v74 = 0;
    }
    else
    {
      CFTypeID v62 = &v63;
    }
    goto LABEL_89;
  }
  CFIndex v15 = 0;
  uint64_t v58 = "EEE26SetupEventIdleScreenNotifyNS9_INSB_ILl12EEE30SetupEventLanguageSelectNotifyNS9_INSB_ILl11EEE22SetupEventIMSRegNotifyNS9_INSB_ILl10EEE11OpenChannelNS9_INSB_ILl9EEE12CloseChannelNS9_INSB_ILl8EEE8SendDataNS9_INSB_ILl7EEE11ReceiveDataNS9_INSB_ILl6EEE12RefreshAlphaNS9_INSB_ILl5EEE4fillILi26EENS9_INSB_ILl4EEES1R_ILi27EENS9_INSB_ILl3EEES1R_ILi28EENS9_INSB_ILl2EEES1R_ILi29EENS9_INSB_ILl1EEES1R_ILi30EENS8_5l_endEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEJEEE20NotificationResponse30NotificationAdditionalResponsejE3$_1NS_9allocatorIS32_EEFvvEEE";
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v15);
    CFDictionaryRef v17 = ValueAtIndex;
    if (!ValueAtIndex) {
      break;
    }
    CFTypeID v18 = CFGetTypeID(ValueAtIndex);
    if (v18 != CFDictionaryGetTypeID()) {
      break;
    }
    CFDictionaryGetValue(v17, @"BundleID");
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    unint64_t v19 = *(void *)&buf[8];
    long long __p = *(void **)buf;
    v71[0] = *(_DWORD *)&buf[16];
    *(_DWORD *)((char *)v71 + 3) = *(_DWORD *)&buf[19];
    uint64_t v20 = buf[23];
    int v21 = (char)buf[23];
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v20 = *(void *)&buf[8];
    }
    if (!v20)
    {
      int v38 = *(NSObject **)(v6 + 40);
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_59;
      }
      *(_WORD *)long long buf = 0;
      int v39 = v38;
      CFTypeID v40 = "#N Found empty bundle ID";
      uint32_t v41 = 2;
      goto LABEL_58;
    }
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(v17, @"CellPolicy");
    unint64_t v23 = (void *)CFDictionaryGetValue(v17, @"WiFiPolicy");
    uint64_t v24 = (void *)CFDictionaryGetValue(v17, @"IsManaged");
    uint64_t v25 = (void *)CFDictionaryGetValue(v17, @"IsRestricted");
    int v26 = v25;
    if (Value && v23 && v24 && v25)
    {
      uint64_t v27 = v6;
      buf[0] = 0;
      CFTypeID v28 = CFGetTypeID(Value);
      if (v28 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)Value, v29);
      }
      buf[0] = 0;
      CFTypeID v30 = CFGetTypeID(v23);
      if (v30 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)v23, v31);
      }
      buf[0] = 0;
      CFTypeID v32 = CFGetTypeID(v24);
      if (v32 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, (BOOL *)v24, v33);
      }
      int v34 = buf[0];
      buf[0] = 0;
      CFTypeID v35 = CFGetTypeID(v26);
      if (v35 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, (BOOL *)v26, v36);
      }
      int v37 = buf[0];
      uint64_t v77 = 0;
      CFTypeRef v75 = (void **)operator new(0x48uLL);
      int v76 = &v73;
      LOBYTE(v77) = 0;
      if (v21 < 0)
      {
        sub_10004FC84(buf, __p, v19);
      }
      else
      {
        *(void *)long long buf = __p;
        *(void *)&uint8_t buf[8] = v19;
        *(_DWORD *)&uint8_t buf[16] = v71[0];
        *(_DWORD *)&buf[19] = *(_DWORD *)((char *)v71 + 3);
        buf[23] = v21;
      }
      CFBooleanRef v48 = *(std::__shared_weak_count **)(v27 + 72);
      uint64_t v78 = *(void *)(v27 + 64);
      std::string v79 = v48;
      if (v48) {
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LODWORD(v58) = v58 & 0xFFFF0000 | v34 | (v37 << 8);
      du::policy::BundleProperties::BundleProperties();
      uint64_t v6 = v27;
      if (v79) {
        sub_10004D2C8(v79);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      LOBYTE(v77) = 1;
      *(void *)long long buf = 0;
      int v49 = (uint64_t **)sub_100046ED4((uint64_t)&v72, buf, v75 + 4);
      if (*v49)
      {
        CFTypeID v50 = v75;
        CFTypeRef v75 = 0;
        if (v50) {
          sub_1000C6EE8((uint64_t)&v76, v50);
        }
      }
      else
      {
        uint64_t v51 = *(void *)buf;
        uint64_t v52 = (uint64_t *)v75;
        NSObject *v75 = 0;
        v52[1] = 0;
        v52[2] = v51;
        *int v49 = v52;
        if (*v72)
        {
          long long v72 = (uint64_t **)*v72;
          uint64_t v52 = *v49;
        }
        sub_100046C90(v73, v52);
        ++v74;
      }
      char v47 = 1;
      if ((v21 & 0x80000000) == 0) {
        goto LABEL_61;
      }
LABEL_60:
      operator delete(__p);
      goto LABEL_61;
    }
    int v42 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      if (Value) {
        CFTypeID v43 = "valid";
      }
      else {
        CFTypeID v43 = "null";
      }
      if (v23) {
        unsigned int v44 = "valid";
      }
      else {
        unsigned int v44 = "null";
      }
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v43;
      if (v24) {
        BOOL v45 = "valid";
      }
      else {
        BOOL v45 = "null";
      }
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v44;
      if (v26) {
        int v46 = "valid";
      }
      else {
        int v46 = "null";
      }
      *(_WORD *)&unsigned char buf[22] = 2080;
      CFBooleanRef v81 = v45;
      __int16 v82 = 2080;
      uint64_t v83 = v46;
      int v39 = v42;
      CFTypeID v40 = "#N Invalid policies.  cellular (%s), wifi (%s), isManaged (%s), isRestricted (%s)";
      uint32_t v41 = 42;
LABEL_58:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, buf, v41);
    }
LABEL_59:
    char v47 = 0;
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    CFTypeID v62 = &v63;
    if (v21 < 0) {
      goto LABEL_60;
    }
LABEL_61:
    if ((v47 & 1) == 0) {
      goto LABEL_89;
    }
    if (Count == ++v15) {
      goto LABEL_83;
    }
  }
  xpc_object_t v55 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#N Found empty policy record", buf, 2u);
  }
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  CFTypeID v62 = &v63;
LABEL_89:
  sub_10005CD2C((uint64_t)&v72, (char *)v73);
  uint64_t v5 = v57;
LABEL_90:
  sub_100044D00((const void **)&theArray);
  sub_1000E72F4(v60, (uint64_t)&v62);
  sub_100647AD4(*(void *)(v5 + 64), (uint64_t)v60, 0);
  sub_10005CD2C((uint64_t)v60, (char *)v60[1]);
  int v53 = (char *)v63;
  uint64_t v54 = &v62;
LABEL_91:
  sub_10005CD2C((uint64_t)v54, v53);
  sub_100044D00(&v67);
LABEL_92:
  sub_1000577C4(&cf);
  return 1;
}

void sub_1006481F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, char a19, uint64_t a20,uint64_t a21,const void *a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,const void *a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,const void *a37,uint64_t a38,char a39,char *a40)
{
  *(void *)(v41 - 20sub_10010E764((uint64_t)&a9, 0) = 0;
  sub_1000C6EE8(a10, v40);
  operator delete(__p);
  sub_10005CD2C((uint64_t)&a39, a40);
  sub_100044D00(&a22);
  sub_100044D00(&a31);
  sub_1000577C4(&a37);
  _Unwind_Resume(a1);
}

uint64_t sub_100648338(uint64_t a1, uint64_t a2)
{
  return sub_10064B63C(a1 + 40, a2 + 40);
}

void *sub_100648344(uint64_t a1)
{
  return sub_1000E6714((void *)(a1 + 40));
}

void *sub_10064834C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = (const void **)&kCFBooleanFalse;
  if (a2) {
    uint64_t v5 = (const void **)&kCFBooleanTrue;
  }
  sub_1006451B8(&v7, @"du-policies-get", *v5);
  CFTypeRef v8 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  xpc_object_t v9[2] = sub_100648494;
  v9[3] = &unk_1019F3A68;
  void v9[4] = a1;
  sub_10064B6D4((uint64_t)v10, a3);
  sub_100645388(*(void *)(a1 + 48), &v7, (uint64_t)v9);
  sub_1000FE824(&v8);
  sub_1000577C4(&v7);
  return sub_1000ED9C8(v10);
}

void sub_100648460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000ED9C8(v10);
  sub_1000FE824(v9);
  sub_1000577C4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100648494(uint64_t a1, uint64_t a2, const __CFDictionary **a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v25 = 0;
  sub_100645310(&v25, *a3);
  if ((a4 - 1) < 5)
  {
    int v7 = *(_DWORD *)&asc_1014D12F4[4 * a4 - 4];
LABEL_19:
    v24[0] = 0;
    v24[1] = 0;
    unint64_t v23 = v24;
    sub_1006486BC(*(void *)(a1 + 64), (uint64_t)&v23, v7);
    sub_10005CD2C((uint64_t)&v23, v24[0]);
    goto LABEL_22;
  }
  CFTypeRef v8 = v25;
  if (v25) {
    xpc_object_t v9 = sub_100080934;
  }
  else {
    xpc_object_t v9 = 0;
  }
  if (!v9)
  {
    int v7 = 0;
    goto LABEL_19;
  }
  if (v25 && (CFTypeID v10 = CFGetTypeID(v25), v10 == CFArrayGetTypeID()))
  {
    CFTypeRef v22 = v8;
    CFRetain(v8);
  }
  else
  {
    CFTypeRef v8 = 0;
    CFTypeRef v22 = 0;
  }
  if (v8) {
    CFArrayRef v11 = sub_100083F10;
  }
  else {
    CFArrayRef v11 = 0;
  }
  if (v11)
  {
    uint64_t v17 = 0;
    CFTypeID v18 = 0;
    uint64_t v19 = 0;
    uint64_t v16 = v8;
    if (v8) {
      CFRetain(v8);
    }
    sub_10064870C(&v17, (CFArrayRef *)&v16, (os_log_t *)(v6 + 40));
    sub_100044D00(&v16);
    sub_1000E8470(v15, (uint64_t)&v17);
    sub_1006486BC(*(void *)(a1 + 64), (uint64_t)v15, 0);
    sub_10005CD2C((uint64_t)v15, (char *)v15[1]);
    CFBooleanRef v12 = v18;
    uint64_t v13 = &v17;
  }
  else
  {
    v21[0] = 0;
    v21[1] = 0;
    uint64_t v20 = v21;
    sub_1006486BC(*(void *)(a1 + 64), (uint64_t)&v20, 0);
    CFBooleanRef v12 = (char *)v21[0];
    uint64_t v13 = (uint64_t *)&v20;
  }
  sub_10005CD2C((uint64_t)v13, v12);
  sub_100044D00(&v22);
LABEL_22:
  sub_1000577C4(&v25);
  return 1;
}

void sub_100648640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, char *a18)
{
  sub_10005CD2C((uint64_t)&a17, a18);
  sub_100044D00((const void **)(v18 - 72));
  sub_1000577C4((const void **)(v18 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_1006486BC(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 48))(a1, a2, &v4);
}

void sub_10064870C(void *a1, CFArrayRef *a2, os_log_t *a3)
{
  CFArrayRef v4 = *a2;
  if (*a2) {
    uint64_t v5 = sub_100083F10;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    a1[2] = 0;
    a1[1] = 0;
    *a1 = a1 + 1;
    return;
  }
  uint64_t v58 = a1;
  CFTypeID v62 = 0;
  uint64_t v63 = 0;
  CFTypeRef v61 = &v62;
  CFIndex Count = CFArrayGetCount(v4);
  int v7 = (uint64_t ***)v58;
  if (Count < 1)
  {
LABEL_55:
    CFBooleanRef v48 = v62;
    *int v7 = v61;
    v7[1] = (uint64_t **)v48;
    int v49 = (uint64_t **)(v7 + 1);
    CFTypeID v50 = v63;
    v7[2] = v63;
    if (v50)
    {
      v48[2] = (uint64_t)v49;
      CFTypeRef v61 = &v62;
      CFTypeID v62 = 0;
      uint64_t v63 = 0;
    }
    else
    {
      *int v7 = v49;
    }
    goto LABEL_62;
  }
  CFIndex v8 = 0;
  int v53 = v58 + 1;
  uint64_t v52 = "8__SecKeyEENS0_8functionIFvbNS0_12basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEEEEN3xpc4dictEENK3$_0clENS0_8optionalIN5euicc35EuiccAttestationServerDiscoveryRespEEERKSL_SW_EUlNSR_INSS_24EuiccAttestationResponseEEESW_E_";
  CFIndex v55 = Count;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*a2, v8);
    CFDictionaryRef v10 = ValueAtIndex;
    if (!ValueAtIndex) {
      break;
    }
    CFTypeID v11 = CFGetTypeID(ValueAtIndex);
    if (v11 != CFDictionaryGetTypeID()) {
      break;
    }
    CFDictionaryGetValue(v10, @"BundleID");
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    unint64_t v12 = *(void *)&buf[8];
    long long __p = *(void **)buf;
    *(_DWORD *)uint64_t v60 = *(_DWORD *)&buf[16];
    *(_DWORD *)&uint64_t v60[3] = *(_DWORD *)&buf[19];
    uint64_t v13 = buf[23];
    int v59 = (char)buf[23];
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v13 = *(void *)&buf[8];
    }
    if (!v13)
    {
      os_log_t v38 = *a3;
      if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v39 = v38;
        CFTypeID v40 = "#N Found empty bundle ID";
        uint32_t v41 = 2;
        goto LABEL_39;
      }
LABEL_40:
      char v43 = 0;
      void *v53 = 0;
      v58[2] = 0;
      int v7 = (uint64_t ***)v58;
      *uint64_t v58 = v53;
      goto LABEL_51;
    }
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(v10, @"CellPolicy");
    CFIndex v15 = (void *)CFDictionaryGetValue(v10, @"WiFiPolicy");
    uint64_t v16 = (void *)CFDictionaryGetValue(v10, @"IsManaged");
    uint64_t v17 = (void *)CFDictionaryGetValue(v10, @"IsRestricted");
    uint64_t v18 = (void *)CFDictionaryGetValue(v10, @"CellularAuthorization");
    uint64_t v19 = (void *)CFDictionaryGetValue(v10, @"WifiAuthorization");
    uint64_t v20 = (void *)CFDictionaryGetValue(v10, @"Modificationtime");
    int v21 = v20;
    if (!Value || !v15 || !v16 || !v17 || !v18 || !v19 || !v20)
    {
      os_log_t v42 = *a3;
      if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134219520;
        *(void *)&uint8_t buf[4] = Value;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v15;
        *(_WORD *)&unsigned char buf[22] = 2048;
        std::string v68 = v16;
        __int16 v69 = 2048;
        unsigned int v70 = v17;
        __int16 v71 = 2048;
        long long v72 = v18;
        __int16 v73 = 2048;
        uint64_t v74 = v19;
        __int16 v75 = 2048;
        int v76 = v21;
        int v39 = v42;
        CFTypeID v40 = "#N Invalid policies.  cellular %p, wifi %p, managed %p, restricted %p, cellular authorization %p, wifi aut"
              "horization %p, modicationTime %p";
        uint32_t v41 = 72;
LABEL_39:
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, buf, v41);
      }
      goto LABEL_40;
    }
    buf[0] = 0;
    CFTypeID v22 = CFGetTypeID(Value);
    if (v22 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)Value, v23);
    }
    buf[0] = 0;
    CFTypeID v24 = CFGetTypeID(v15);
    if (v24 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)v15, v25);
    }
    buf[0] = 0;
    CFTypeID v26 = CFGetTypeID(v16);
    if (v26 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (BOOL *)v16, v27);
    }
    int v28 = buf[0];
    buf[0] = 0;
    CFTypeID v29 = CFGetTypeID(v17);
    if (v29 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (BOOL *)v17, v30);
    }
    int v31 = buf[0];
    buf[0] = 0;
    CFTypeID v32 = CFGetTypeID(v18);
    if (v32 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)v18, v33);
    }
    buf[0] = 0;
    CFTypeID v34 = CFGetTypeID(v19);
    if (v34 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (unsigned __int8 *)v19, v35);
    }
    du::policy::AuthorizationProperties::AuthorizationProperties();
    *(void *)long long buf = 0;
    CFTypeID v36 = CFGetTypeID(v21);
    if (v36 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, (double *)v21, v37);
    }
    uint64_t v66 = 0;
    uint64_t v64 = operator new(0x58uLL);
    char v65 = &v62;
    LOBYTE(v66) = 0;
    if (v59 < 0)
    {
      sub_10004FC84(buf, __p, v12);
    }
    else
    {
      *(void *)long long buf = __p;
      *(void *)&uint8_t buf[8] = v12;
      *(_DWORD *)&uint8_t buf[16] = *(_DWORD *)v60;
      *(_DWORD *)&buf[19] = *(_DWORD *)&v60[3];
      buf[23] = v59;
    }
    LODWORD(v52) = v52 & 0xFFFF0000 | v28 | (v31 << 8);
    du::policy::Change::Change();
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    LOBYTE(v66) = 1;
    *(void *)long long buf = 0;
    unsigned int v44 = (uint64_t **)sub_100046ED4((uint64_t)&v61, buf, (void **)v64 + 4);
    if (*v44)
    {
      BOOL v45 = (void **)v64;
      uint64_t v64 = 0;
      if (v45) {
        sub_1000C6EE8((uint64_t)&v65, v45);
      }
    }
    else
    {
      uint64_t v46 = *(void *)buf;
      char v47 = (uint64_t *)v64;
      *(void *)uint64_t v64 = 0;
      v47[1] = 0;
      std::string v47[2] = v46;
      const char *v44 = v47;
      if (*v61)
      {
        CFTypeRef v61 = (uint64_t **)*v61;
        char v47 = *v44;
      }
      sub_100046C90(v62, v47);
      uint64_t v63 = (uint64_t **)((char *)v63 + 1);
    }
    char v43 = 1;
    int v7 = (uint64_t ***)v58;
LABEL_51:
    if (v59 < 0)
    {
      operator delete(__p);
      int v7 = (uint64_t ***)v58;
    }
    if ((v43 & 1) == 0) {
      goto LABEL_62;
    }
    if (v55 == ++v8) {
      goto LABEL_55;
    }
  }
  uint64_t v51 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#N Found empty policy record", buf, 2u);
  }
  void *v53 = 0;
  v58[2] = 0;
  *uint64_t v58 = v53;
LABEL_62:
  sub_10005CD2C((uint64_t)&v61, (char *)v62);
}

void sub_100648D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,int a25,uint64_t a26,uint64_t a27,char a28,char *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  a31 = 0;
  sub_1000C6EE8(a10, v39);
  operator delete(__p);
  sub_10005CD2C((uint64_t)&a28, a29);
  _Unwind_Resume(a1);
}

uint64_t sub_100648E0C(uint64_t a1, uint64_t a2)
{
  return sub_10064B6D4(a1 + 40, a2 + 40);
}

void *sub_100648E18(uint64_t a1)
{
  return sub_1000ED9C8((void *)(a1 + 40));
}

const void **sub_100648E20(uint64_t a1, void *a2, uint64_t a3)
{
  CFArrayRef theArray = 0;
  uint64_t v5 = (os_log_t *)(a1 + 40);
  sub_100648FF4(&theArray, a2, (NSObject **)(a1 + 40));
  if (theArray) {
    uint64_t v6 = sub_100083F10;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 && CFArrayGetCount(theArray))
  {
    sub_1006451B8(&v9, @"du-policies-set", theArray);
    CFDictionaryRef v10 = 0;
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 1174405120;
    void v13[2] = sub_10064966C;
    v13[3] = &unk_1019F3A98;
    sub_100356358((uint64_t)v14, a3);
    sub_100645388(*(void *)(a1 + 48), &v9, (uint64_t)v13);
    sub_1000FE824(&v10);
    sub_1000577C4(&v9);
    sub_1000F8E94(v14);
  }
  else
  {
    int v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No policies to send", buf, 2u);
    }
    sub_100356304(a3, 96);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100648FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13)
{
  sub_1000F8E94(v14);
  sub_1000FE824(v13);
  sub_1000577C4(&a9);
  sub_100044D00(&a13);
  _Unwind_Resume(a1);
}

const void **sub_100648FF4(void *a1, void *a2, NSObject **a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFBooleanRef v48 = Mutable;
  if (Mutable) {
    uint64_t v6 = sub_100289354;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = a2[2];
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    CFMutableArrayRef v9 = Mutable;
    CFDictionaryRef v10 = *a3;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Unable to convert policies.  Array %p, policies %lu", buf, 0x16u);
    }
  }
  else
  {
    uint64_t v13 = (void *)*a2;
    CFTypeID v11 = a2 + 1;
    unint64_t v12 = v13;
    if (v13 != v11)
    {
      do
      {
        char v47 = 0;
        CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        char v47 = v14;
        if (*((char *)v12 + 55) < 0)
        {
          sub_10004FC84(__dst, (void *)v12[4], v12[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v12 + 2);
          uint64_t v45 = v12[6];
        }
        if (SHIBYTE(v45) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v51 = v45;
        }
        int v49 = 0;
        if (SHIBYTE(v51) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v51;
        }
        uint64_t v52 = 0;
        if (ctu::cf::convert_copy())
        {
          CFIndex v15 = v49;
          int v49 = v52;
          int v53 = v15;
          sub_1000558F4((const void **)&v53);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        int value = v49;
        int v49 = 0;
        sub_1000558F4((const void **)&v49);
        if (SHIBYTE(v51) < 0) {
          operator delete(__p[0]);
        }
        CFDictionarySetValue(v14, @"BundleID", value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v45) < 0) {
          operator delete(__dst[0]);
        }
        uint64_t v16 = *((unsigned __int8 *)v12 + 56);
        uint64_t v17 = v47;
        __p[0] = 0;
        *(void *)long long buf = v16;
        CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v18)
        {
          uint64_t v19 = __p[0];
          __p[0] = v18;
          *(void *)long long buf = v19;
          sub_1000570E8((const void **)buf);
        }
        int v53 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v17, @"CellPolicy", v53);
        sub_1000570E8((const void **)&v53);
        uint64_t v20 = *((unsigned __int8 *)v12 + 60);
        int v21 = v47;
        __p[0] = 0;
        *(void *)long long buf = v20;
        CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v22)
        {
          CFNumberRef v23 = __p[0];
          __p[0] = v22;
          *(void *)long long buf = v23;
          sub_1000570E8((const void **)buf);
        }
        int v53 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v21, @"WiFiPolicy", v53);
        sub_1000570E8((const void **)&v53);
        CFTypeID v24 = v47;
        if (*((unsigned char *)v12 + 64)) {
          CFBooleanRef v25 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v25 = kCFBooleanFalse;
        }
        __p[0] = v25;
        *(void *)long long buf = 0;
        sub_100062778((const void **)buf);
        int v53 = __p[0];
        __p[0] = 0;
        sub_100062778((const void **)__p);
        CFDictionarySetValue(v24, @"IsManaged", v53);
        sub_100062778((const void **)&v53);
        CFTypeID v26 = v47;
        if (*((unsigned char *)v12 + 65)) {
          CFBooleanRef v27 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v27 = kCFBooleanFalse;
        }
        __p[0] = v27;
        *(void *)long long buf = 0;
        sub_100062778((const void **)buf);
        int v53 = __p[0];
        __p[0] = 0;
        sub_100062778((const void **)__p);
        CFDictionarySetValue(v26, @"IsRestricted", v53);
        sub_100062778((const void **)&v53);
        uint64_t v28 = *((unsigned __int8 *)v12 + 68);
        CFTypeID v29 = v47;
        __p[0] = 0;
        *(void *)long long buf = v28;
        CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v30)
        {
          int v31 = __p[0];
          __p[0] = v30;
          *(void *)long long buf = v31;
          sub_1000570E8((const void **)buf);
        }
        int v53 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v29, @"CellularAuthorization", v53);
        sub_1000570E8((const void **)&v53);
        uint64_t v32 = *((unsigned __int8 *)v12 + 72);
        CFNumberRef v33 = v47;
        __p[0] = 0;
        *(void *)long long buf = v32;
        CFNumberRef v34 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v34)
        {
          CFNumberRef v35 = __p[0];
          __p[0] = v34;
          *(void *)long long buf = v35;
          sub_1000570E8((const void **)buf);
        }
        int v53 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v33, @"WifiAuthorization", v53);
        sub_1000570E8((const void **)&v53);
        CFTypeID v36 = v47;
        uint64_t v37 = v12[10];
        __p[0] = 0;
        *(void *)long long buf = v37;
        CFNumberRef v38 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, buf);
        if (v38)
        {
          int v39 = __p[0];
          __p[0] = v38;
          *(void *)long long buf = v39;
          sub_1000570E8((const void **)buf);
        }
        int v53 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v36, @"Modificationtime", v53);
        sub_1000570E8((const void **)&v53);
        CFArrayAppendValue(v48, v47);
        sub_10005717C((const void **)&v47);
        CFTypeID v40 = (void *)v12[1];
        if (v40)
        {
          do
          {
            uint32_t v41 = v40;
            CFTypeID v40 = (void *)*v40;
          }
          while (v40);
        }
        else
        {
          do
          {
            uint32_t v41 = (void *)v12[2];
            BOOL v8 = *v41 == (void)v12;
            unint64_t v12 = v41;
          }
          while (!v8);
        }
        unint64_t v12 = v41;
      }
      while (v41 != v11);
    }
  }
  sub_100044D6C(a1, (CFTypeRef *)&v48);
  return sub_1000440D4((const void **)&v48);
}

void sub_100649590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,const void *a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
}

uint64_t sub_10064966C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((a4 - 1) > 4) {
    int v4 = 0;
  }
  else {
    int v4 = *(_DWORD *)&asc_1014D12F4[4 * a4 - 4];
  }
  sub_100356304(a1 + 32, v4);
  return 1;
}

uint64_t sub_1006496AC(uint64_t a1, uint64_t a2)
{
  return sub_100356358(a1 + 32, a2 + 32);
}

void *sub_1006496B8(uint64_t a1)
{
  return sub_1000F8E94((void *)(a1 + 32));
}

const void **sub_1006496C0(uint64_t a1, uint64_t a2)
{
  sub_1006451B8(&v6, @"enable-cell-data-get", 0);
  uint64_t v7 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_100649798;
  v5[3] = &unk_1019F3AD0;
  v5[4] = a2;
  v5[5] = a1;
  sub_100645388(*(void *)(a1 + 48), &v6, (uint64_t)v5);
  sub_1000FE824(&v7);
  return sub_1000577C4(&v6);
}

void sub_10064977C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1000FE824(v7);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100649798(uint64_t a1, uint64_t a2, const __CFDictionary **a3, int a4)
{
  uint64_t v13 = 0;
  sub_100645280(&v13, *a3);
  CFTypeRef cf = 0;
  sub_100645310(&cf, *a3);
  if ((a4 - 1) >= 5 && (uint64_t v7 = (BOOL *)cf) != 0 && (v8 = CFGetTypeID(cf), v8 == CFBooleanGetTypeID()))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    unsigned __int8 v14 = 0;
    ctu::cf::assign((ctu::cf *)&v14, v7, v9);
    (*(void (**)(uint64_t, void, void))(v10 + 16))(v10, v14, 0);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  sub_1000577C4(&cf);
  sub_1000558F4(&v13);
  return 1;
}

void sub_100649888(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFDictionaryRef v3 = va_arg(va1, const void *);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1006498B0(uint64_t a1, void **a2, uint64_t *a3)
{
  uint64_t v5 = *a2;
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v12, (xpc *)&object, v6);
  sub_1006451B8(&v13, @"cu-workspace-info-get", v12);
  unsigned __int8 v14 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  xpc_object_t v9[2] = sub_100649A1C;
  v9[3] = &unk_1019F3B20;
  uint64_t v8 = *a3;
  uint64_t v7 = (std::__shared_weak_count *)a3[1];
  void v9[4] = a1;
  void v9[5] = v8;
  uint64_t v10 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100645388(*(void *)(a1 + 48), &v13, (uint64_t)v9);
  sub_1000FE824(&v14);
  sub_1000577C4(&v13);
  sub_1000577C4(&v12);
  xpc_release(object);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_1006499CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, xpc_object_t object)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_1000FE824(v17);
  sub_1000577C4((const void **)(v18 - 48));
  sub_1000577C4((const void **)(v18 - 56));
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100649A1C(void *a1, uint64_t a2, const __CFDictionary **a3, int a4)
{
  uint64_t v7 = a1[4];
  char v65 = 0;
  sub_100645280(&v65, *a3);
  CFDictionaryRef v64 = 0;
  sub_100645310(&v63, *a3);
  v57[0] = v63;
  if (v63) {
    CFRetain(v63);
  }
  __p[0] = 0;
  *(void *)long long buf = 0;
  sub_10004EFE4(buf, (CFTypeRef *)v57);
  if (*(void *)buf) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8) {
    sub_100058140((const void **)__p, (const void **)buf);
  }
  sub_100057D78((const void **)buf);
  CFDictionaryRef v64 = (const __CFDictionary *)__p[0];
  __p[0] = 0;
  sub_100057D78((const void **)__p);
  sub_1000577C4((const void **)v57);
  sub_1000577C4((const void **)&v63);
  if (a4) {
    goto LABEL_9;
  }
  if (v64) {
    CFTypeID v11 = sub_100080778;
  }
  else {
    CFTypeID v11 = 0;
  }
  if (!v11 || (a3[1] ? (unint64_t v12 = sub_1000FCC20) : (unint64_t v12 = 0), !v12))
  {
    int64_t v10 = 94;
LABEL_30:
    xpc_object_t v48 = xpc_int64_create(v10);
    if (!v48) {
      xpc_object_t v48 = xpc_null_create();
    }
    *(void *)long long buf = a1[5];
    *(void *)&uint8_t buf[8] = "kPosixError";
    sub_100035E70((uint64_t)buf, &v48, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v48);
    xpc_object_t v48 = 0;
    goto LABEL_33;
  }
  CFTypeRef v61 = 0;
  CFTypeID v62 = &off_101A0BD40;
  __p[0] = 0;
  v57[0] = 0;
  if (ctu::cf::convert_copy((ctu::cf *)v57, (const __CFString **)"kCUWorkspaceInfo", (const char *)0x8000100, kCFAllocatorDefault, v9))
  {
    uint64_t v13 = __p[0];
    __p[0] = v57[0];
    *(void *)long long buf = v13;
    sub_1000558F4((const void **)buf);
  }
  CFTypeRef v61 = __p[0];
  __p[0] = 0;
  sub_1000558F4((const void **)__p);
  CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(v64, v61);
  CFDictionaryRef v15 = v14;
  if (v14)
  {
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 != CFDictionaryGetTypeID()) {
      CFDictionaryRef v15 = 0;
    }
  }
  uint64_t v17 = CFDictionaryGetValue(v15, @"kCTCellularUsageWorkspacePath");
  uint64_t v18 = v17;
  if (v17)
  {
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 == CFStringGetTypeID()) {
      uint64_t v20 = v18;
    }
    else {
      uint64_t v20 = 0;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  CFNumberRef v22 = CFDictionaryGetValue(v15, @"kCTCellularUsageWorkspaceName");
  CFNumberRef v23 = v22;
  if (v22)
  {
    CFTypeID v24 = CFGetTypeID(v22);
    if (v24 == CFStringGetTypeID()) {
      CFBooleanRef v25 = v23;
    }
    else {
      CFBooleanRef v25 = 0;
    }
  }
  else
  {
    CFBooleanRef v25 = 0;
  }
  int value = 0;
  CFTypeID v26 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%@-watch", v25);
  CFStringRef v59 = 0;
  int value = v26;
  CFStringRef v27 = CFStringCreateWithFormat(0, 0, @"%@/%@.sqlite", v20, v26);
  uint64_t v58 = 0;
  CFStringRef v59 = v27;
  v57[0] = 0;
  v57[1] = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)uint64_t v57 = *(_OWORD *)buf;
  uint64_t v58 = *(void *)&buf[16];
  CFURLRef v28 = a3[1];
  CFStringRef v56 = 0;
  CFStringRef v29 = CFURLCopyFileSystemPath(v28, kCFURLPOSIXPathStyle);
  uint64_t v55 = 0;
  CFStringRef v56 = v29;
  __p[0] = 0;
  __p[1] = 0;
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v55 = *(void *)&buf[16];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v7 + 64));
  int v31 = ServiceMap;
  if (v32 < 0)
  {
    CFNumberRef v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v34 = 5381;
    do
    {
      uint64_t v32 = v34;
      unsigned int v35 = *v33++;
      uint64_t v34 = (33 * v34) ^ v35;
    }
    while (v35);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v32;
  CFTypeID v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)buf);
  if (!v36)
  {
    uint64_t v37 = 0;
LABEL_48:
    std::mutex::unlock(v31);
    CFNumberRef v38 = 0;
    char v39 = 1;
    if (!v37) {
      goto LABEL_54;
    }
    goto LABEL_49;
  }
  uint64_t v37 = v36[3];
  CFNumberRef v38 = (std::__shared_weak_count *)v36[4];
  if (!v38) {
    goto LABEL_48;
  }
  atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v31);
  atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v38);
  char v39 = 0;
  if (!v37)
  {
LABEL_54:
    if (v39) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
LABEL_49:
  char v40 = (*(uint64_t (**)(uint64_t, void **, void **))(*(void *)v37 + 168))(v37, __p, v57);
  uint32_t v41 = *(NSObject **)(v7 + 40);
  if (v40)
  {
    if (!os_log_type_enabled(*(os_log_t *)(v7 + 40), OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_54;
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v56;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v59;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I moved %@ to %@", buf, 0x16u);
    if (v39) {
      goto LABEL_56;
    }
LABEL_55:
    sub_10004D2C8(v38);
    goto LABEL_56;
  }
  if (!os_log_type_enabled(*(os_log_t *)(v7 + 40), OS_LOG_TYPE_ERROR)) {
    goto LABEL_54;
  }
  *(_DWORD *)long long buf = 138412546;
  *(void *)&uint8_t buf[4] = v56;
  *(_WORD *)&unsigned char buf[12] = 2112;
  *(void *)&buf[14] = v59;
  _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "failed to copy DB %@ to %@", buf, 0x16u);
  if ((v39 & 1) == 0) {
    goto LABEL_55;
  }
LABEL_56:
  *(void *)long long buf = 0;
  *(void *)long long buf = CFDictionaryCreateMutableCopy(0, 0, v15);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, @"kCTCellularUsageWorkspaceName", value);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v64);
  CFDictionarySetValue(MutableCopy, v61, *(const void **)buf);
  xpc_object_t xdict = 0;
  ctu::cf_to_xpc((uint64_t *)&xdict, MutableCopy, v42);
  xpc_type_t type = xpc_get_type(xdict);
  if (v37) {
    BOOL v44 = type == (xpc_type_t)&_xpc_type_null;
  }
  else {
    BOOL v44 = 1;
  }
  char v45 = !v44;
  if (v44)
  {
    a4 = 4;
  }
  else
  {
    xpc_object_t v46 = xdict;
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 1174405120;
    applier[2] = sub_10064A254;
    applier[3] = &unk_1019F3AF0;
    char v47 = (std::__shared_weak_count *)a1[6];
    applier[4] = a1[5];
    uint64_t v51 = v47;
    if (v47) {
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_dictionary_apply(v46, applier);
    if (v51) {
      sub_10004D2C8(v51);
    }
    a4 = 0;
  }
  xpc_release(xdict);
  sub_10005717C((const void **)&MutableCopy);
  sub_10005717C((const void **)buf);
  if (SHIBYTE(v55) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4((const void **)&v56);
  if (SHIBYTE(v58) < 0) {
    operator delete(v57[0]);
  }
  sub_1000558F4((const void **)&v59);
  sub_1000558F4((const void **)&value);
  sub_1000558F4(&v61);
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v62);
  if ((v45 & 1) == 0)
  {
LABEL_9:
    if ((a4 - 1) > 4) {
      int64_t v10 = 0;
    }
    else {
      int64_t v10 = qword_1014D1308[a4 - 1];
    }
    goto LABEL_30;
  }
LABEL_33:
  sub_100057D78((const void **)&v64);
  sub_1000558F4(&v65);
  return 0;
}

void sub_10064A0D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, xpc_object_t object, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,const void *a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,const void *a34,const void *a35)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  xpc_release(object);
  sub_10005717C(&a20);
  sub_10005717C((const void **)(v35 - 112));
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_1000558F4(&a27);
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_1000558F4(&a34);
  sub_1000558F4(&a35);
  sub_1000558F4((const void **)(v35 - 152));
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)(v35 - 144));
  sub_100057D78((const void **)(v35 - 128));
  sub_1000558F4((const void **)(v35 - 120));
  _Unwind_Resume(a1);
}

void sub_10064A24C()
{
}

uint64_t sub_10064A254(uint64_t a1, const char *a2, void *a3)
{
  CFDictionaryRef v3 = *(void ***)(a1 + 32);
  if (v3) {
    int v4 = *v3;
  }
  else {
    int v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

const void **sub_10064A284(uint64_t a1, void **a2, CFTypeRef cf, char a4)
{
  uint64_t v8 = *(void *)(a1 + 40);
  CFTypeID v19 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  int64_t v10 = *a2;
  xpc_object_t object = v10;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v18, (xpc *)&object, v11);
  unint64_t v12 = v18;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  _OWORD v14[2] = sub_10064A3F0;
  v14[3] = &unk_1019F3B50;
  void v14[4] = v8;
  CFDictionaryRef v15 = v19;
  if (v19) {
    CFRetain(v19);
  }
  char v16 = a4;
  (*(void (**)(uint64_t, const void *, CFTypeRef, void, void *))(v9 + 16))(v9, v12, cf, 0, v14);
  sub_1000577C4(&v18);
  xpc_release(object);
  sub_1000FE824(&v15);
  return sub_1000FE824(&v19);
}

void sub_10064A3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, const void *a17)
{
  sub_1000FE824(v17);
  sub_1000577C4(&a17);
  xpc_release(object);
  sub_1000FE824((const void **)(v18 - 56));
  _Unwind_Resume(a1);
}

const void **sub_10064A3F0(uint64_t a1)
{
  uint64_t result = *(const void ***)(a1 + 40);
  if (result) {
    CFDictionaryRef v3 = sub_1000FCC20;
  }
  else {
    CFDictionaryRef v3 = 0;
  }
  if (v3 && *(unsigned char *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFStringRef v13 = CFURLCopyFileSystemPath((CFURLRef)result, kCFURLPOSIXPathStyle);
    if (v13) {
      uint64_t v5 = sub_1000810B8;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      unint64_t v12 = &off_101A0BD40;
      memset(buf, 0, sizeof(buf));
      uint64_t v15 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v8 = 0u;
      uint64_t v9 = 0;
      sub_100058DB0(__p, (char *)v8);
      sub_1007ED7D4((uint64_t)&v12, (uint64_t *)__p);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v9) < 0) {
        operator delete(v8[0]);
      }
      uint64_t v6 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N removed %@", buf, 0xCu);
      }
      FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v12);
    }
    return sub_1000558F4((const void **)&v13);
  }
  return result;
}

void sub_10064A580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,const void *a23)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a21);
  sub_1000558F4(&a23);
  _Unwind_Resume(a1);
}

const void **sub_10064A5DC(uint64_t a1, uint64_t a2)
{
  return sub_100119B5C((const void **)(a1 + 40), (const void **)(a2 + 40));
}

const void **sub_10064A5E8(uint64_t a1)
{
  return sub_1000FE824((const void **)(a1 + 40));
}

uint64_t sub_10064A5F0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_10064A624(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

const void **sub_10064A658(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_10064A68C(uint64_t a1)
{
  *(void *)a1 = off_1019F3888;
  sub_1001509E4(a1 + 120);
  sub_10005D144(*(void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFDictionaryRef v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  P2WSettingsInterface::~P2WSettingsInterface((P2WSettingsInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10064A718(uint64_t a1)
{
  *(void *)a1 = off_1019F3888;
  sub_1001509E4(a1 + 120);
  sub_10005D144(*(void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFDictionaryRef v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  P2WSettingsInterface::~P2WSettingsInterface((P2WSettingsInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  operator delete();
}

void sub_10064A7C8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10064A800(uint64_t a1)
{
}

uint64_t sub_10064A81C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10064A860(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10064A88C(ServiceManager::Service *this)
{
  *(void *)this = off_1019F3CC0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10064A8E8(ServiceManager::Service *this)
{
  *(void *)this = off_1019F3CC0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10064A958@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "P2WSettingsManager");
}

unsigned char *sub_10064A968@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10064A9A8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  CFDictionaryRef v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100645000(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100645000(v4, 0);
}

uint64_t sub_10064AA2C()
{
  return 0;
}

uint64_t sub_10064AA34()
{
  return 1;
}

uint64_t sub_10064AA3C()
{
  return 0;
}

uint64_t *sub_10064AA50(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFStringRef v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  CFDictionaryRef v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 72);
  uint64_t v17 = *(Registry **)(v2 + 64);
  uint64_t v18 = (uint64_t)v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100390EC4(&v17, buf);
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 56);
  *(_OWORD *)(v2 + 48) = *(_OWORD *)buf;
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  Registry::createRestModuleOneTimeUseConnection(&v30, *(Registry **)(v2 + 64));
  ctu::RestModule::connect();
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_10064AD44(v2 + 120);
  uint64_t v6 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v6 || (uint64_t v7 = *(void *)(v2 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  p_shared_weak_owners = &v8->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  uint64_t v11 = *(void *)(v2 + 48);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  CFBooleanRef v25 = sub_10064AE24;
  CFTypeID v26 = &unk_1019F3D30;
  uint64_t v27 = v2;
  uint64_t v28 = v7;
  CFStringRef v29 = v9;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v17 = (Registry *)_NSConcreteStackBlock;
  uint64_t v18 = 1174405120;
  CFTypeID v19 = sub_10064B084;
  uint64_t v20 = &unk_1019F3D60;
  uint64_t v21 = v2;
  uint64_t v22 = v7;
  CFNumberRef v23 = v9;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  v15[2] = sub_10064B170;
  uint64_t v15[3] = &unk_1019F3D90;
  void v15[4] = v2;
  v15[5] = v7;
  char v16 = v9;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, const __CFString *, uint8_t *, void, Registry **, void *))(*(void *)v11 + 88))(v11, @"P2WSettingsManager", buf, 0, &v17, v15);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  std::__shared_weak_count::__release_weak(v9);
  sub_100088C88(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_10064ACD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  if (a31) {
    std::__shared_weak_count::__release_weak(a31);
  }
  std::__shared_weak_count::__release_weak(v31);
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10064AD44(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/remote_paired_device_list");
  v4[0] = off_1019F3DD0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10064ADF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10064AE24(void *a1, uint64_t a2)
{
  char v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        *(_OWORD *)&v15[8] = 0u;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v18 = 0;
        ctu::cf::assign();
        uint64_t v14 = 0;
        *(void *)uint64_t v15 = 0;
        *(void *)&v15[7] = 0;
        char v8 = *(unsigned char *)(a2 + 8);
        v15[15] = 0;
        v15[16] = v8;
        xpc_object_t v19 = 0;
        rest::write_rest_value();
        sub_100058DB0(__p, "/cc/events/nearby_device_changed");
        xpc_object_t object = v19;
        xpc_object_t v19 = xpc_null_create();
        ctu::RestModule::sendEvent();
        xpc_release(object);
        xpc_object_t object = 0;
        if (SHIBYTE(v18) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(v19);
        uint64_t v9 = *(void **)(v5 + 96);
        if (v9 != (void *)(v5 + 104))
        {
          do
          {
            uint64_t v10 = v9[4];
            if (v10) {
              (*(void (**)(uint64_t, void **, void))(*(void *)v10 + 16))(v10, &v14, v15[16]);
            }
            uint64_t v11 = (void *)v9[1];
            if (v11)
            {
              do
              {
                unint64_t v12 = v11;
                uint64_t v11 = (void *)*v11;
              }
              while (v11);
            }
            else
            {
              do
              {
                unint64_t v12 = (void *)v9[2];
                BOOL v13 = *v12 == (void)v9;
                uint64_t v9 = v12;
              }
              while (!v13);
            }
            uint64_t v9 = v12;
          }
          while (v12 != (void *)(v5 + 104));
        }
        if ((v15[15] & 0x80000000) != 0) {
          operator delete(v14);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10064AFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  xpc_release(object);
  if (a23 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v24 - 40));
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_10064B058(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10064B074(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_10064B084(void *a1, uint64_t a2, const void **a3, const void **a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      if (a1[5])
      {
        sub_100083DA4(&v14, a3);
        sub_1000584C8(&v12, a4);
        sub_100119B5C(&v13, a4 + 1);
        sub_100645458(v8, (const __CFDictionary **)&v12, 0);
        sub_1000FE824(&v13);
        sub_1000577C4(&v12);
        sub_1000558F4(&v14);
      }
      sub_10004D2C8(v10);
    }
  }
  return 1;
}

void sub_10064B144(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  sub_1000FE824(v3);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10064B170(void *a1, uint64_t a2, const void **a3, const void **a4, uint64_t a5)
{
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    uint64_t v10 = a1[4];
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      unint64_t v12 = v11;
      if (a1[5])
      {
        sub_100083DA4(&v16, a3);
        sub_1000584C8(&v14, a4);
        sub_100119B5C(&v15, a4 + 1);
        sub_100645458(v10, (const __CFDictionary **)&v14, a5);
        sub_1000FE824(&v15);
        sub_1000577C4(&v14);
        sub_1000558F4(&v16);
      }
      sub_10004D2C8(v12);
    }
  }
  return 1;
}

void sub_10064B234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  sub_1000FE824(v3);
  sub_1000577C4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_10064B264()
{
}

void *sub_10064B278(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F3DD0;
  result[1] = v3;
  return result;
}

uint64_t sub_10064B2C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F3DD0;
  a2[1] = v2;
  return result;
}

void sub_10064B2EC(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10064B2F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10064B334()
{
}

void sub_10064B340(uint64_t *a1, xpc_object_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_1008EA904(&v4, a2);
  memset(v3, 0, sizeof(v3));
  sub_100151F50(v3, v4, v5, 0xD37A6F4DE9BD37A7 * ((v5 - v4) >> 3));
  sub_10064B404(v2, v3);
  uint64_t v7 = (void **)v3;
  sub_100150960(&v7);
  uint64_t v7 = (void **)&v4;
  sub_100150960(&v7);
}

void sub_10064B3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 24) = v13;
  sub_100150960((void ***)(v14 - 24));
  *(void *)(v14 - 24) = &a13;
  sub_100150960((void ***)(v14 - 24));
  _Unwind_Resume(a1);
}

void sub_10064B404(uint64_t a1, uint64_t *a2)
{
  sub_1008EB218(a2, (uint64_t)v3);
  sub_100150F2C(a1, (uint64_t)v3);
  if (v17 < 0) {
    operator delete(__p);
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if (v13 < 0) {
    operator delete(v12);
  }
  if (v11 < 0) {
    operator delete(v10);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
}

void sub_10064B4B8()
{
}

void *sub_10064B4CC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F3E50;
  result[1] = v3;
  return result;
}

uint64_t sub_10064B514(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F3E50;
  a2[1] = v2;
  return result;
}

void sub_10064B540(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_10064B5F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10064B630()
{
}

uint64_t sub_10064B63C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10064B6D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10064B76C(void *a1)
{
  *a1 = off_1019F3ED0;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10064B7BC(void *a1)
{
  *a1 = off_1019F3ED0;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10064B82C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F3ED0;
  sub_10064BEEC(v2 + 1, v1);
  return v2;
}

void *sub_10064B880(uint64_t a1, void *a2)
{
  *a2 = off_1019F3ED0;
  return sub_10064BEEC(a2 + 1, (void *)(a1 + 8));
}

void sub_10064B8AC(uint64_t a1)
{
}

void sub_10064B8B4(const void **a1)
{
  sub_10064BF28(a1[2]);

  operator delete(a1);
}

const void **sub_10064B8F0(uint64_t a1, void *a2)
{
  uint64_t v32 = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v37 = Mutable;
  if (Mutable) {
    int v5 = sub_100289354;
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = a2[2];
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    CFMutableArrayRef v8 = Mutable;
    char v9 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = "valid";
      if (!v8) {
        uint64_t v10 = "is null";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to convert policies.  Array %s, policies %lu", buf, 0x16u);
    }
  }
  else
  {
    char v13 = (void *)*a2;
    char v11 = a2 + 1;
    unint64_t v12 = v13;
    if (v13 != v11)
    {
      do
      {
        CFTypeID v36 = 0;
        CFMutableDictionaryRef v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFTypeID v36 = v14;
        if (*((char *)v12 + 55) < 0)
        {
          sub_10004FC84(__dst, (void *)v12[4], v12[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v12 + 2);
          uint64_t v34 = v12[6];
        }
        if (SHIBYTE(v34) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v40 = v34;
        }
        CFNumberRef v38 = 0;
        if (SHIBYTE(v40) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v40;
        }
        uint32_t v41 = 0;
        if (ctu::cf::convert_copy())
        {
          char v15 = v38;
          CFNumberRef v38 = v41;
          os_log_t v42 = v15;
          sub_1000558F4((const void **)&v42);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        int value = v38;
        CFNumberRef v38 = 0;
        sub_1000558F4((const void **)&v38);
        if (SHIBYTE(v40) < 0) {
          operator delete(__p[0]);
        }
        CFDictionarySetValue(v14, @"BundleID", value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v34) < 0) {
          operator delete(__dst[0]);
        }
        uint64_t v16 = *((unsigned __int8 *)v12 + 56);
        char v17 = v36;
        __p[0] = 0;
        *(void *)long long buf = v16;
        CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v18)
        {
          xpc_object_t v19 = __p[0];
          __p[0] = v18;
          *(void *)long long buf = v19;
          sub_1000570E8((const void **)buf);
        }
        os_log_t v42 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v17, @"CellPolicy", v42);
        sub_1000570E8((const void **)&v42);
        uint64_t v20 = *((unsigned __int8 *)v12 + 60);
        uint64_t v21 = v36;
        __p[0] = 0;
        *(void *)long long buf = v20;
        CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
        if (v22)
        {
          CFNumberRef v23 = __p[0];
          __p[0] = v22;
          *(void *)long long buf = v23;
          sub_1000570E8((const void **)buf);
        }
        os_log_t v42 = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        CFDictionarySetValue(v21, @"WiFiPolicy", v42);
        sub_1000570E8((const void **)&v42);
        uint64_t v24 = v36;
        if (*((unsigned char *)v12 + 64)) {
          CFBooleanRef v25 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v25 = kCFBooleanFalse;
        }
        __p[0] = v25;
        *(void *)long long buf = 0;
        sub_100062778((const void **)buf);
        os_log_t v42 = __p[0];
        __p[0] = 0;
        sub_100062778((const void **)__p);
        CFDictionarySetValue(v24, @"IsManaged", v42);
        sub_100062778((const void **)&v42);
        CFTypeID v26 = v36;
        if (*((unsigned char *)v12 + 65)) {
          CFBooleanRef v27 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v27 = kCFBooleanFalse;
        }
        __p[0] = v27;
        *(void *)long long buf = 0;
        sub_100062778((const void **)buf);
        os_log_t v42 = __p[0];
        __p[0] = 0;
        sub_100062778((const void **)__p);
        CFDictionarySetValue(v26, @"IsRestricted", v42);
        sub_100062778((const void **)&v42);
        CFArrayAppendValue(v37, v36);
        sub_10005717C((const void **)&v36);
        uint64_t v28 = (void *)v12[1];
        if (v28)
        {
          do
          {
            CFStringRef v29 = v28;
            uint64_t v28 = (void *)*v28;
          }
          while (v28);
        }
        else
        {
          do
          {
            CFStringRef v29 = (void *)v12[2];
            BOOL v7 = *v29 == (void)v12;
            unint64_t v12 = v29;
          }
          while (!v7);
        }
        unint64_t v12 = v29;
      }
      while (v29 != v11);
    }
  }
  sub_100044D6C(&v32, (CFTypeRef *)&v37);
  sub_1000440D4((const void **)&v37);
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  return sub_100044D00(&v32);
}

void sub_10064BDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
}

uint64_t sub_10064BEA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10064BEE0()
{
}

void *sub_10064BEEC(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    uint64_t v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_10064BF28(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10064BF48(void *a1)
{
  *a1 = off_1019F3F50;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10064BF98(void *a1)
{
  *a1 = off_1019F3F50;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10064C008(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F3F50;
  sub_10064C1C8(v2 + 1, v1);
  return v2;
}

void *sub_10064C05C(uint64_t a1, void *a2)
{
  *a2 = off_1019F3F50;
  return sub_10064C1C8(a2 + 1, (void *)(a1 + 8));
}

void sub_10064C088(uint64_t a1)
{
}

void sub_10064C090(const void **a1)
{
  sub_10064C204(a1[2]);

  operator delete(a1);
}

const void **sub_10064C0CC(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v5 = 0;
  sub_100648FF4(&v5, a2, (NSObject **)(v3 + 40));
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  return sub_100044D00(&v5);
}

void sub_10064C164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10064C17C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10064C1BC()
{
}

void *sub_10064C1C8(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    uint64_t v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_10064C204(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10064C224(void *a1)
{
  *a1 = off_1019F3FE0;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10064C274(void *a1)
{
  *a1 = off_1019F3FE0;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10064C2E4(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019F3FE0;
  sub_10064C420(v2 + 1, v1);
  return v2;
}

void *sub_10064C338(uint64_t a1, void *a2)
{
  *a2 = off_1019F3FE0;
  return sub_10064C420(a2 + 1, (void **)(a1 + 8));
}

void sub_10064C364(uint64_t a1)
{
}

void sub_10064C36C(const void **a1)
{
  sub_10064C458(a1[1]);

  operator delete(a1);
}

uint64_t sub_10064C3A8(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*a2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 5;
  }
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t, void))(v2 + 16))(v2, 0, 0, v3, 0);
}

uint64_t sub_10064C3D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10064C414()
{
}

void *sub_10064C420(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_10064C458(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void sub_10064C478(PB::Base *this)
{
  *(void *)this = &off_1019F4060;
  uint64_t v4 = *((void *)this + 3);
  uint64_t v2 = (void *)((char *)this + 24);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 16, v5);
  }
  uint64_t v6 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v6) {
    sub_100206334((uint64_t)this + 8, v6);
  }

  PB::Base::~Base(this);
}

void sub_10064C504(PB::Base *a1)
{
  sub_10064C478(a1);

  operator delete();
}

uint64_t sub_10064C53C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = &off_1019F4060;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 4sub_10010E764((uint64_t)&a9, 0) = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    int v2 = *(_DWORD *)(a2 + 32);
    *(unsigned char *)(result + 4sub_10010E764((uint64_t)&a9, 0) = 1;
    *(_DWORD *)(result + 32) = v2;
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if ((*(unsigned char *)(a2 + 40) & 2) != 0)
  {
    int v3 = *(_DWORD *)(a2 + 36);
    *(unsigned char *)(result + 40) |= 2u;
    *(_DWORD *)(result + 36) = v3;
  }
  return result;
}

uint64_t sub_10064C710(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  char v5 = *(unsigned char *)(a1 + 40);
  if (v5)
  {
    PB::TextFormatter::format(this, "status", *(_DWORD *)(a1 + 32));
    char v5 = *(unsigned char *)(a1 + 40);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(this, "type", *(_DWORD *)(a1 + 36));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10064C7D4(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v2sub_10010E764((uint64_t)&a9, 0) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_63:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        *(unsigned char *)(a1 + 40) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_58;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_47:
          LODWORD(v27) = 0;
          goto LABEL_58;
        }
        char v38 = 0;
        unsigned int v39 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        while (2)
        {
          if (v23 == v22)
          {
            LODWORD(v27) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v40 = v22 + 1;
            char v41 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v40;
            v27 |= (unint64_t)(v41 & 0x7F) << v38;
            if (v41 < 0)
            {
              v38 += 7;
              unint64_t v22 = v40;
              BOOL v14 = v39++ > 8;
              if (v14) {
                goto LABEL_47;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v27) = 0;
            }
          }
          break;
        }
LABEL_58:
        *(_DWORD *)(a1 + 32) = v27;
        goto LABEL_63;
      case 2u:
        operator new();
      case 3u:
        operator new();
      case 4u:
        operator new();
      case 5u:
        *(unsigned char *)(a1 + 40) |= 2u;
        unint64_t v30 = *((void *)this + 1);
        unint64_t v31 = *((void *)this + 2);
        uint64_t v32 = *(void *)this;
        if (v30 <= 0xFFFFFFFFFFFFFFF5 && v30 + 10 <= v31)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            unint64_t v36 = v30 + 1;
            *((void *)this + 1) = v30 + 1;
            char v37 = *(unsigned char *)(v32 + v30);
            v35 |= (unint64_t)(v37 & 0x7F) << v33;
            if ((v37 & 0x80) == 0) {
              goto LABEL_62;
            }
            v33 += 7;
            unint64_t v30 = v36;
            BOOL v14 = v34++ > 8;
          }
          while (!v14);
LABEL_54:
          LODWORD(v35) = 0;
          goto LABEL_62;
        }
        char v42 = 0;
        unsigned int v43 = 0;
        uint64_t v35 = 0;
        if (v31 <= v30) {
          unint64_t v31 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v31 == v30)
      {
        LODWORD(v35) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_62;
      }
      unint64_t v44 = v30 + 1;
      char v45 = *(unsigned char *)(v32 + v30);
      *((void *)this + 1) = v44;
      v35 |= (unint64_t)(v45 & 0x7F) << v42;
      if ((v45 & 0x80) == 0) {
        break;
      }
      v42 += 7;
      unint64_t v30 = v44;
      BOOL v14 = v43++ > 8;
      if (v14) {
        goto LABEL_54;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v35) = 0;
    }
LABEL_62:
    *(_DWORD *)(a1 + 36) = v35;
    goto LABEL_63;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_10064CC44(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 40)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(result + 32), 1u);
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  if ((*(unsigned char *)(v3 + 40) & 2) != 0)
  {
    unsigned int v4 = *(_DWORD *)(v3 + 36);
    return PB::Writer::writeVarInt(this, v4, 5u);
  }
  return result;
}

void sub_10064CCEC(void ***a1)
{
  *a1 = (void **)off_1019F40B0;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_10064CD44(void ***a1)
{
  *a1 = (void **)off_1019F40B0;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

void *sub_10064CDB0(void *result, uint64_t a2)
{
  void *result = off_1019F40B0;
  result[1] = 0;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_10064CE58(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10064CEB4(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      if ((v10 >> 3) == 1) {
        operator new();
      }
LABEL_23:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_10064D04C(uint64_t result, PB::Writer *this)
{
  unint64_t v2 = *(const PB::Data **)(result + 8);
  if (v2) {
    return PB::Writer::write(this, v2, 1u);
  }
  return result;
}

void SendRadioNotReadyEvent(void)
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(41, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_10064D0D4(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void C2KRadioModule::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10064D1C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (v10) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void C2KRadioModule::C2KRadioModule(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  uint64_t v3 = v2;
  CSIRadioModulePrivate::CSIRadioModulePrivate(a1, &v3);
}

void sub_10064D434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v15 = v12;
  sub_100136194(v15);
  EmergencyMode::~EmergencyMode(v14);
  EmergencyMode::~EmergencyMode(v13);
  sub_10019D5B8(v10 + 1200, *(void **)(v10 + 1208));
  sub_100087F94(v10 + 1136, *(void **)(v10 + 1144));
  sub_100087F94(v10 + 1104, *(void **)(v10 + 1112));
  a10 = (void **)(v10 + 1080);
  sub_10008A88C(&a10);
  if (*(char *)(v10 + 1071) < 0) {
    operator delete(*(void **)(v10 + 1048));
  }
  char v17 = *(std::__shared_weak_count **)(v10 + 1040);
  if (v17) {
    sub_10004D2C8(v17);
  }
  unsigned __int8 v18 = *(std::__shared_weak_count **)(v10 + 1024);
  if (v18) {
    sub_10004D2C8(v18);
  }
  unint64_t v19 = *(NSObject **)(v10 + 1008);
  if (v19) {
    dispatch_release(v19);
  }
  if (*(char *)(v10 + 999) < 0) {
    operator delete(*v11);
  }
  unint64_t v20 = *(void **)(v10 + 944);
  if (v20)
  {
    *(void *)(v10 + 952) = v20;
    operator delete(v20);
  }
  uint64_t v21 = *(void **)(v10 + 848);
  if (v21)
  {
    *(void *)(v10 + 856) = v21;
    operator delete(v21);
  }
  unint64_t v22 = *(void **)(v10 + 824);
  if (v22)
  {
    *(void *)(v10 + 832) = v22;
    operator delete(v22);
  }
  unint64_t v23 = *(void **)(v10 + 792);
  if (v23)
  {
    *(void *)(v10 + 80sub_10010E764((uint64_t)&a9, 0) = v23;
    operator delete(v23);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v10 + 784);
  if (v24) {
    sub_10004D2C8(v24);
  }
  CSIRadioModulePrivate::~CSIRadioModulePrivate((CSIRadioModulePrivate *)v10);
  _Unwind_Resume(a1);
}

void sub_10064D554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  JUMPOUT(0x10064D54CLL);
}

void sub_10064D58C(void *a1)
{
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 7)) & 1) == 0) {
    __TUAssertTrigger();
  }
  uint64_t v2 = a1[129];
  xpc_object_t v3 = xpc_null_create();
  uint64_t v4 = abm::kCommandGetBasebandOperatingMode;
  xpc_object_t v7 = v3;
  char v5 = a1[126];
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  v8[0] = off_1019F5FB8;
  v8[1] = a1;
  void v8[3] = v8;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v2 + 48))(v2, v4, &v7, &object, v8);
  sub_1000595E4(v8);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v7);
}

void sub_10064D6A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, char a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064D6E4(void *a1, NSObject **a2)
{
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 7)) & 1) == 0) {
    __TUAssertTrigger();
  }
  if (a1[103] == a1[104])
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      char v14 = "sendGetPkHash_nl";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    }
    uint64_t v5 = a1[129];
    xpc_object_t v6 = xpc_null_create();
    uint64_t v7 = abm::kKeyCommandGetPKHash;
    xpc_object_t v11 = v6;
    char v8 = a1[126];
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    unsigned int v9 = *a2;
    if (v9)
    {
      dispatch_retain(v9);
      dispatch_group_enter(v9);
    }
    v12[0] = off_1019F6038;
    v12[1] = a1;
    v12[2] = v9;
    v12[3] = v12;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v5 + 48))(v5, v7, &v11, &object, v12);
    sub_1000595E4(v12);
    if (object) {
      dispatch_release(object);
    }
    xpc_release(v11);
  }
}

void sub_10064D87C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, xpc_object_t a12, char a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064D8C8(void *a1, NSObject **a2)
{
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 7)) & 1) == 0) {
    __TUAssertTrigger();
  }
  if (a1[99] == a1[100])
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      char v14 = "sendGetFirmwareInfo_nl";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    }
    uint64_t v5 = a1[129];
    xpc_object_t v6 = xpc_null_create();
    uint64_t v7 = abm::kKeyCommandGetFirmwareInfo;
    xpc_object_t v11 = v6;
    char v8 = a1[126];
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    unsigned int v9 = *a2;
    if (v9)
    {
      dispatch_retain(v9);
      dispatch_group_enter(v9);
    }
    v12[0] = off_1019F60B8;
    v12[1] = a1;
    v12[2] = v9;
    v12[3] = v12;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v5 + 48))(v5, v7, &v11, &object, v12);
    sub_1000595E4(v12);
    if (object) {
      dispatch_release(object);
    }
    xpc_release(v11);
  }
}

void sub_10064DA60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, xpc_object_t a12, char a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064DAAC(void *a1, NSObject **a2)
{
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 7)) & 1) == 0) {
    __TUAssertTrigger();
  }
  if (a1[118] == a1[119])
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      char v14 = "sendGetManifestStatus_nl";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    }
    uint64_t v5 = a1[129];
    xpc_object_t v6 = xpc_null_create();
    uint64_t v7 = abm::kKeyCommandGetManifestStatus;
    xpc_object_t v11 = v6;
    char v8 = a1[126];
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    unsigned int v9 = *a2;
    if (v9)
    {
      dispatch_retain(v9);
      dispatch_group_enter(v9);
    }
    v12[0] = off_1019F6138;
    v12[1] = a1;
    v12[2] = v9;
    v12[3] = v12;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v5 + 48))(v5, v7, &v11, &object, v12);
    sub_1000595E4(v12);
    if (object) {
      dispatch_release(object);
    }
    xpc_release(v11);
  }
}

void sub_10064DC44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, xpc_object_t a12, char a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064DC90(void *a1)
{
  if (a1[129])
  {
    xpc_object_t object = 0;
    xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v3 = v2;
    if (v2)
    {
      xpc_object_t object = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
      xpc_object_t object = v3;
      if (!v3)
      {
        xpc_object_t v5 = xpc_null_create();
        xpc_object_t v3 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
LABEL_12:
      xpc_release(v3);
      if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v6 = a1[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to create input dictionary!", (uint8_t *)&buf, 2u);
        }
LABEL_51:
        xpc_release(object);
        return;
      }
      uint64_t v7 = (void *)a1[150];
      if (v7 == a1 + 151)
      {
LABEL_43:
        uint64_t v19 = a1[129];
        xpc_object_t v23 = object;
        if (object) {
          xpc_retain(object);
        }
        else {
          xpc_object_t v23 = xpc_null_create();
        }
        uint64_t v20 = abm::kCommandCallServiceState;
        uint64_t v21 = a1[126];
        dispatch_object_t v22 = v21;
        if (v21) {
          dispatch_retain(v21);
        }
        v31[0] = off_1019F6658;
        v31[1] = a1;
        v31[3] = v31;
        (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v19 + 48))(v19, v20, &v23, &v22, v31);
        sub_1000595E4(v31);
        if (v22) {
          dispatch_release(v22);
        }
        xpc_release(v23);
        xpc_object_t v23 = 0;
        goto LABEL_51;
      }
      char v8 = (char *)abm::kKeyPLMN2;
      unsigned int v9 = (char *)abm::kKeyPLMN1;
      while (1)
      {
        memset(&buf, 0, sizeof(buf));
        int v10 = *((_DWORD *)v7 + 8);
        xpc_object_t v11 = v9;
        if (v10 == 1) {
          goto LABEL_20;
        }
        if (v10 == 2) {
          break;
        }
LABEL_21:
        std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        char v13 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = buf.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          createPLMN();
          if (v26 >= 0) {
            p_p = (const char *)&__p;
          }
          else {
            p_p = (const char *)__p;
          }
          xpc_object_t v27 = xpc_string_create(p_p);
          if (!v27) {
            xpc_object_t v27 = xpc_null_create();
          }
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string buf = &buf;
          }
          else {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          v24[0] = &object;
          v24[1] = p_buf;
          sub_100035E70((uint64_t)v24, &v27, &v28);
          xpc_release(v28);
          xpc_object_t v28 = 0;
          xpc_release(v27);
          xpc_object_t v27 = 0;
          if (v26 < 0) {
            operator delete(__p);
          }
          char v13 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        if (v13 < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        unint64_t v16 = (void *)v7[1];
        if (v16)
        {
          do
          {
            char v17 = v16;
            unint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            char v17 = (void *)v7[2];
            BOOL v18 = *v17 == (void)v7;
            uint64_t v7 = v17;
          }
          while (!v18);
        }
        uint64_t v7 = v17;
        if (v17 == a1 + 151) {
          goto LABEL_43;
        }
      }
      xpc_object_t v11 = v8;
LABEL_20:
      sub_10003ED78(&buf, v11);
      goto LABEL_21;
    }
    xpc_object_t v5 = xpc_null_create();
LABEL_11:
    xpc_object_t object = v5;
    goto LABEL_12;
  }
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", (uint8_t *)&buf, 2u);
  }
}

void sub_10064E008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,xpc_object_t a26)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064E0A4(uint64_t a1)
{
  if (*(void *)(a1 + 1032))
  {
    xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v3 = v2;
    if (v2)
    {
      xpc_object_t object = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
      xpc_object_t object = v3;
      if (!v3)
      {
        xpc_object_t v5 = xpc_null_create();
        xpc_object_t v3 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
LABEL_12:
      xpc_release(v3);
      xpc_object_t v6 = object;
      if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v15 = xpc_BOOL_create(*(unsigned char *)(a1 + 1224));
        if (!v15) {
          xpc_object_t v15 = xpc_null_create();
        }
        *(void *)std::string buf = &object;
        uint64_t v14 = abm::kKeyVoiceCall;
        sub_100035E70((uint64_t)buf, &v15, &v16);
        xpc_release(v16);
        xpc_object_t v16 = 0;
        xpc_release(v15);
        xpc_object_t v15 = 0;
        uint64_t v8 = *(void *)(a1 + 1032);
        xpc_object_t v12 = object;
        if (object) {
          xpc_retain(object);
        }
        else {
          xpc_object_t v12 = xpc_null_create();
        }
        uint64_t v9 = abm::kCommandCallServiceState;
        int v10 = *(NSObject **)(a1 + 1008);
        dispatch_object_t v11 = v10;
        if (v10) {
          dispatch_retain(v10);
        }
        v18[0] = off_1019F66D8;
        v18[1] = a1;
        void v18[3] = v18;
        (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v8 + 48))(v8, v9, &v12, &v11, v18);
        sub_1000595E4(v18);
        if (v11) {
          dispatch_release(v11);
        }
        xpc_release(v12);
        xpc_object_t v12 = 0;
        xpc_object_t v6 = object;
      }
      else
      {
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create input dictionary!", buf, 2u);
        }
      }
      xpc_release(v6);
      return;
    }
    xpc_object_t v5 = xpc_null_create();
LABEL_11:
    xpc_object_t object = v5;
    goto LABEL_12;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", buf, 2u);
  }
}

void sub_10064E324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, char a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064E3A8(uint64_t a1)
{
  if (*(void *)(a1 + 1032))
  {
    xpc_object_t object = 0;
    xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v3 = v2;
    if (v2)
    {
      xpc_object_t object = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
      xpc_object_t object = v3;
      if (!v3)
      {
        xpc_object_t v5 = xpc_null_create();
        xpc_object_t v3 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v3);
      goto LABEL_12;
    }
    xpc_object_t v5 = xpc_null_create();
LABEL_11:
    xpc_object_t object = v5;
LABEL_12:
    xpc_release(v3);
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t v6 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
LABEL_34:
        xpc_release(object);
        return;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v7 = "Failed to create input dictionary!";
LABEL_15:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v7, buf, 2u);
      goto LABEL_34;
    }
    int v8 = *(_DWORD *)(a1 + 1228);
    if (v8 == 2)
    {
      xpc_object_t v14 = xpc_BOOL_create(*(unsigned char *)(a1 + 1236));
      if (!v14) {
        xpc_object_t v14 = xpc_null_create();
      }
      *(void *)std::string buf = &object;
      uint64_t v17 = abm::kKeyECBM2;
      sub_100035E70((uint64_t)buf, &v14, &v15);
      xpc_release(v15);
      xpc_object_t v15 = 0;
      xpc_release(v14);
      xpc_object_t v14 = 0;
    }
    else
    {
      if (v8 != 1)
      {
        xpc_object_t v6 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          goto LABEL_34;
        }
        *(_WORD *)std::string buf = 0;
        uint64_t v7 = "Failed to get EmergenyCallBackMode slot";
        goto LABEL_15;
      }
      xpc_object_t v18 = xpc_BOOL_create(*(unsigned char *)(a1 + 1236));
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
      *(void *)std::string buf = &object;
      uint64_t v17 = abm::kKeyECBM1;
      sub_100035E70((uint64_t)buf, &v18, &v19);
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_release(v18);
      xpc_object_t v18 = 0;
    }
    uint64_t v9 = *(void *)(a1 + 1032);
    xpc_object_t v13 = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t v13 = xpc_null_create();
    }
    uint64_t v10 = abm::kCommandCallServiceState;
    dispatch_object_t v11 = *(NSObject **)(a1 + 1008);
    dispatch_object_t v12 = v11;
    if (v11) {
      dispatch_retain(v11);
    }
    v21[0] = off_1019F67D8;
    v21[1] = a1;
    uint64_t v21[3] = v21;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v9 + 48))(v9, v10, &v13, &v12, v21);
    sub_1000595E4(v21);
    if (v12) {
      dispatch_release(v12);
    }
    xpc_release(v13);
    xpc_object_t v13 = 0;
    goto LABEL_34;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", buf, 2u);
  }
}

void sub_10064E6BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, char a18)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064E74C(std::string *a1)
{
  WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
  sub_100058DB0(&v4, WirelessUserDirectory);
  xpc_object_t v3 = std::string::append(&v4, "/Library/Logs/CrashReporter/Baseband/", 0x25uLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_10064E7C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10064E7DC(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = 0;
  if (!a2) {
    a2 = "none specified";
  }
  sub_100058DB0(v12, a2);
  if (*(void *)(a1 + 504))
  {
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a4;
      uint64_t v11 = *(void *)(a4 + 16);
    }
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(v8, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)int v8 = *(_OWORD *)a5;
      uint64_t v9 = *(void *)(a5 + 16);
    }
    operator new();
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_10064EA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 73) < 0) {
    operator delete(*(void **)(v33 - 96));
  }
  if (*(char *)(v33 - 41) < 0) {
    operator delete(*(void **)(v33 - 64));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10064EAB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 520))();
}

uint64_t sub_10064EAE0(void *a1)
{
  xpc_object_t v2 = (ATCSMutex *)(a1 + 7);
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  xpc_object_t v3 = a1[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Dump state complete, waiting for log post-processing to finish before notifying clients", v6, 2u);
  }
  std::string v4 = a1[68];
  a1[68] = 0;
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  return ATCSMutex::unlock(v2);
}

uint64_t sub_10064EB80(uint64_t a1, xpc::object *a2, NSObject **a3)
{
  xpc_object_t v6 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)__p, a2);
      int v8 = SHIBYTE(__p[2]) >= 0 ? __p : (void **)__p[0];
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
    long long buf = 0uLL;
    uint64_t v67 = 0;
    xpc_object_t v63 = a2;
    size_t v64 = abm::kKeyBasebandBootState;
    sub_100048BAC((uint64_t)&v63, object);
    memset(__p, 0, 24);
    xpc::dyn_cast_or_default();
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v55 = a3;
    xpc_release(object[0]);
    uint64_t v9 = (void *)abm::kBasebandBootStateIsReady;
    size_t v10 = HIBYTE(v67);
    int v11 = SHIBYTE(v67);
    size_t v12 = *((void *)&buf + 1);
    if (v67 >= 0) {
      size_t v13 = HIBYTE(v67);
    }
    else {
      size_t v13 = *((void *)&buf + 1);
    }
    if (v13 == strlen(abm::kBasebandBootStateIsReady)
      && (v67 >= 0 ? (p_long long buf = &buf) : (p_long long buf = (long long *)buf), !memcmp(p_buf, abm::kBasebandBootStateIsReady, v13))
      || (v13 != strlen(abm::kBasebandBootStateBooted)
       || (v11 >= 0 ? (xpc_object_t v15 = &buf) : (xpc_object_t v15 = (long long *)buf), memcmp(v15, abm::kBasebandBootStateBooted, v13)))
      && (v13 == strlen(abm::kBasebandBootStateWillReset)
       && (v11 >= 0 ? (xpc_object_t v16 = &buf) : (xpc_object_t v16 = (long long *)buf), !memcmp(v16, abm::kBasebandBootStateWillReset, v13))
       || v13 == strlen(abm::kBasebandBootStateDidReset)
       && (v11 >= 0 ? (uint64_t v17 = &buf) : (uint64_t v17 = (long long *)buf), !memcmp(v17, abm::kBasebandBootStateDidReset, v13))
       || v13 == strlen(abm::kBasebandBootStateWillShutdown)
       && (v11 >= 0 ? (xpc_object_t v18 = &buf) : (xpc_object_t v18 = (long long *)buf), !memcmp(v18, abm::kBasebandBootStateWillShutdown, v13))
       || v13 == strlen(abm::kBasebandBootStateHasShutdown)
       && (v11 >= 0 ? (xpc_object_t v19 = &buf) : (xpc_object_t v19 = (long long *)buf), !memcmp(v19, abm::kBasebandBootStateHasShutdown, v13))
       || v13 == strlen(abm::kBasebandBootStateDead)
       && (v11 >= 0 ? (uint64_t v20 = &buf) : (uint64_t v20 = (long long *)buf), !memcmp(v20, abm::kBasebandBootStateDead, v13))))
    {
      uint64_t v21 = *(void *)(a1 + 360);
      if (v21) {
        sub_100C5DBF8(v21);
      }
    }
    if ((v11 & 0x80u) == 0) {
      size_t v22 = v10;
    }
    else {
      size_t v22 = v12;
    }
    if (v22 == strlen((const char *)v9)
      && ((v11 & 0x80u) == 0 ? (xpc_object_t v23 = &buf) : (xpc_object_t v23 = (long long *)buf), !memcmp(v23, v9, v22)))
    {
      xpc_object_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = *(int *)(a1 + 380);
        if (v28 > 8) {
          char v29 = "???";
        }
        else {
          char v29 = off_1019F6A10[v28];
        }
        int v45 = *(_DWORD *)(a1 + 376);
        int v46 = *(unsigned __int8 *)(a1 + 256);
        LODWORD(__p[0]) = 136315650;
        *(void **)((char *)__p + 4) = (void *)v29;
        WORD2(__p[1]) = 1024;
        *(_DWORD *)((char *)&__p[1] + 6) = v45;
        WORD1(__p[2]) = 1024;
        HIDWORD(__p[2]) = v46;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I RadioState=%s, fPowerOffState=%d, fPowerDown=%d", (uint8_t *)__p, 0x18u);
        xpc_object_t v27 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Baseband is ready", (uint8_t *)__p, 2u);
      }
      int v47 = *(_DWORD *)(a1 + 380);
      if ((v47 - 5) < 4 || !v47)
      {
        if (*(_DWORD *)(a1 + 376) == 1)
        {
          xpc_object_t v48 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v9;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Skip processing event %s", (uint8_t *)__p, 0xCu);
          }
        }
        else
        {
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), 1);
          *(unsigned char *)(a1 + 256) = 0;
          *(_DWORD *)(a1 + 376) = 0;
          CSIRadioModulePrivate::changeState(a1, 1u);
          if ((ATCSMutex::isLocked(v6) & 1) == 0) {
            __TUAssertTrigger();
          }
          uint64_t v49 = *(void *)(a1 + 1032);
          xpc_object_t v50 = xpc_null_create();
          uint64_t v51 = abm::kCommandGetBasebandManagerInfo;
          xpc_object_t v63 = v50;
          uint64_t v52 = *(NSObject **)(a1 + 1008);
          object[0] = v52;
          if (v52) {
            dispatch_retain(v52);
          }
          __p[0] = off_1019F5F38;
          __p[1] = (void *)a1;
          __p[3] = __p;
          (*(void (**)(uint64_t, uint64_t, xpc_object_t *, xpc_object_t *, void **))(*(void *)v49 + 48))(v49, v51, &v63, object, __p);
          sub_1000595E4(__p);
          if (object[0]) {
            dispatch_release((dispatch_object_t)object[0]);
          }
          xpc_release(v63);
          sub_10064D58C((void *)a1);
          started = (capabilities::fusing *)CSIRadioModulePrivate::startTracing_nl(a1);
          if ((byte_101B0D228 & 1) == 0)
          {
            started = (capabilities::fusing *)sub_1006502CC(a1);
            byte_101B0D228 = 1;
          }
          if (capabilities::fusing::supportsCertIDFromPublicKeyHash(started))
          {
            __p[0] = 0;
            sub_10064D6E4((void *)a1, (NSObject **)__p);
          }
          xpc_object_t v63 = 0;
          sub_10064D8C8((void *)a1, (NSObject **)&v63);
          object[0] = 0;
          sub_10064DAAC((void *)a1, (NSObject **)object);
          sub_10064DC90((void *)a1);
          sub_10064E0A4(a1);
          sub_10064E3A8(a1);
          *(_DWORD *)(a1 + 888) = -1;
          *(void *)(a1 + 904) = 0;
          *(void *)(a1 + 896) = 0;
          *(_DWORD *)(a1 + 912) = -1;
          *(void *)(a1 + 928) = 0;
          *(void *)(a1 + 92sub_10010E764((uint64_t)&a9, 0) = 0;
          sub_10001F318(a1, 1);
          sub_10001F318(a1, 2);
        }
      }
    }
    else if (v22 == strlen(abm::kBasebandBootStateWillReset) {
           && ((v11 & 0x80u) == 0 ? (uint64_t v24 = &buf) : (uint64_t v24 = (long long *)buf),
    }
               !memcmp(v24, abm::kBasebandBootStateWillReset, v22)))
    {
      xpc_object_t v63 = 0;
      size_t v64 = 0;
      uint64_t v65 = 0;
      object[0] = a2;
      object[1] = (xpc_object_t)abm::kKeyBasebandResetType;
      sub_100048BAC((uint64_t)object, &v58);
      memset(__p, 0, 24);
      xpc::dyn_cast_or_default();
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v58);
      unint64_t v30 = (const void *)abm::kBasebandResetTypeHard;
      int v31 = SHIBYTE(v65);
      if (v65 >= 0) {
        size_t v32 = HIBYTE(v65);
      }
      else {
        size_t v32 = v64;
      }
      if (v32 == strlen(abm::kBasebandResetTypeHard)
        && (v65 >= 0 ? (uint64_t v33 = &v63) : (uint64_t v33 = v63), !memcmp(v33, abm::kBasebandResetTypeHard, v32))
        || v32 == strlen(abm::kBasebandResetTypeSoft)
        && (v31 >= 0 ? (unsigned int v34 = &v63) : (unsigned int v34 = v63), !memcmp(v34, abm::kBasebandResetTypeSoft, v32)))
      {
        memset(__p, 0, 24);
        object[0] = a2;
        object[1] = (xpc_object_t)abm::kKeyBasebandResetReason;
        sub_100048BAC((uint64_t)object, &v58);
        xpc::dyn_cast_or_default((uint64_t *)__p, (xpc *)&v58, (const object *)"no-reset-reason", v35);
        xpc_release(v58);
        object[0] = 0;
        object[1] = 0;
        uint64_t v62 = 0;
        xpc_object_t v58 = a2;
        uint64_t v59 = abm::kKeyTimestampString;
        sub_100048BAC((uint64_t)&v58, &v60);
        xpc::dyn_cast_or_default((uint64_t *)object, (xpc *)&v60, abm::kUnknownTimestamp, v36);
        xpc_release(v60);
        xpc_object_t v58 = a2;
        uint64_t v59 = abm::kKeyBasebandResetIsMTBF;
        sub_100048BAC((uint64_t)&v58, &v60);
        uint64_t v38 = xpc::dyn_cast_or_default((xpc *)&v60, (const object *)1, v37);
        xpc_release(v60);
        unsigned int v39 = *v55;
        if (*v55)
        {
          dispatch_retain(v39);
          dispatch_group_enter(v39);
        }
        unint64_t v40 = *(NSObject **)(a1 + 536);
        *(void *)(a1 + 536) = v39;
        if (v40)
        {
          dispatch_group_leave(v40);
          dispatch_release(v40);
        }
        if (SHIBYTE(__p[2]) >= 0) {
          char v41 = __p;
        }
        else {
          char v41 = (void **)__p[0];
        }
        if (v65 >= 0) {
          size_t v42 = HIBYTE(v65);
        }
        else {
          size_t v42 = v64;
        }
        if (v42 == strlen((const char *)v30))
        {
          if (v65 >= 0) {
            unsigned int v43 = &v63;
          }
          else {
            unsigned int v43 = v63;
          }
          BOOL v44 = memcmp(v43, v30, v42) == 0;
        }
        else
        {
          BOOL v44 = 0;
        }
        if (SHIBYTE(v62) < 0)
        {
          sub_10004FC84(__dst, object[0], (unint64_t)object[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)object;
          uint64_t v57 = v62;
        }
        (*(void (**)(uint64_t, void **, BOOL, uint64_t, void **))(*(void *)a1 + 432))(a1, v41, v44, v38, __dst);
        if (SHIBYTE(v57) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v62) < 0) {
          operator delete(object[0]);
        }
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        LOBYTE(v31) = HIBYTE(v65);
      }
      if ((v31 & 0x80) != 0) {
        operator delete(v63);
      }
    }
    else if (v22 == strlen(abm::kBasebandBootStateDidReset) {
           && ((v11 & 0x80u) == 0 ? (char v25 = &buf) : (char v25 = (long long *)buf),
    }
               !memcmp(v25, abm::kBasebandBootStateDidReset, v22)))
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 464))(a1);
    }
    else if (v22 == strlen(abm::kBasebandBootStateDead))
    {
      char v26 = (v11 & 0x80u) == 0 ? &buf : (long long *)buf;
      if (!memcmp(v26, abm::kBasebandBootStateDead, v22))
      {
        CSIRadioModulePrivate::changeState(a1, 8u);
        sub_100258494();
      }
    }
    if (SHIBYTE(v67) < 0) {
      operator delete((void *)buf);
    }
  }
  return ATCSMutex::unlock(v6);
}

void sub_10064F5F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, uint64_t a18, xpc_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,xpc_object_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  ATCSMutex::unlock(v44);
  _Unwind_Resume(a1);
}

void sub_10064F774(void *a1, void **a2, uint64_t a3)
{
  uint64_t v5 = a1[129];
  xpc_object_t v6 = *a2;
  v11[0] = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    v11[0] = xpc_null_create();
  }
  uint64_t v7 = a1[126];
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  v11[1] = a1;
  sub_100661870((uint64_t)v12, a3);
  xpc_object_t v14 = 0;
  int v8 = operator new(0x30uLL);
  uint64_t v9 = abm::kCommandGetAntennaProperty;
  void *v8 = off_1019F4ED8;
  v8[1] = a1;
  sub_100661C4C((uint64_t)(v8 + 2), (uint64_t)v12);
  xpc_object_t v14 = v8;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v5 + 48))(v5, v9, v11, &object, v13);
  sub_1000595E4(v13);
  sub_1001472DC(v12);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v11[0]);
}

void sub_10064F8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10064F924(void *a1, void **a2)
{
  uint64_t v20 = 0;
  size_t v21 = 0;
  uint64_t v22 = 0;
  xdict[0] = a2;
  xdict[1] = (xpc_object_t)abm::kCTTxPowerCommandString;
  sub_100048BAC((uint64_t)xdict, &object);
  long long __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v25) < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  if (v22 >= 0) {
    size_t v4 = HIBYTE(v22);
  }
  else {
    size_t v4 = v21;
  }
  if (v4 != strlen(abm::kSetMaxTransmitPowerDictCommand)
    || (v22 >= 0 ? (uint64_t v5 = &v20) : (uint64_t v5 = v20),
        xpc_object_t v6 = (capabilities::ct *)memcmp(v5, abm::kSetMaxTransmitPowerDictCommand, v4),
        v6))
  {
LABEL_17:
    uint64_t v11 = a1[129];
    size_t v12 = *a2;
    xpc_object_t v17 = v12;
    if (v12) {
      xpc_retain(v12);
    }
    else {
      xpc_object_t v17 = xpc_null_create();
    }
    uint64_t v13 = abm::kCommandSetAntennaProperty;
    xpc_object_t v14 = a1[126];
    dispatch_object_t v16 = v14;
    if (v14) {
      dispatch_retain(v14);
    }
    v26[0] = off_1019F4F58;
    v26[1] = a1;
    void v26[3] = v26;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v11 + 48))(v11, v13, &v17, &v16, v26);
    sub_1000595E4(v26);
    if (v16) {
      dispatch_release(v16);
    }
    xpc_release(v17);
    xpc_object_t v17 = 0;
    goto LABEL_25;
  }
  if (capabilities::ct::getCLTMInterfaceSupport(v6))
  {
    xdict[0] = 0;
    long long __p = a2;
    uint64_t v24 = abm::kCTTxPowerCommandData;
    sub_10000CB28((uint64_t)&__p, xdict);
    uint64_t v7 = abm::kCTThermalTxDutyCycle;
    if (xpc_dictionary_get_value(xdict[0], abm::kCTThermalTxDutyCycle))
    {
      long long __p = xdict;
      uint64_t v24 = v7;
      sub_100048BAC((uint64_t)&__p, &object);
      int v9 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)0xFFFFFFFFLL, v8);
      xpc_release(object);
      if (capabilities::ct::getCLTMInterfaceSupport(v10) == 2) {
        (*(void (**)(void *, BOOL))(*a1 + 40))(a1, v9 == 0);
      }
      if (!v9)
      {
        xpc_release(xdict[0]);
        goto LABEL_25;
      }
    }
    xpc_release(xdict[0]);
    goto LABEL_17;
  }
  xpc_object_t v15 = a1[5];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "CLTM duty cycle interface is not supported", (uint8_t *)&__p, 2u);
  }
LABEL_25:
  if (SHIBYTE(v22) < 0) {
    operator delete(v20);
  }
}

void sub_10064FBFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t a9, xpc_object_t a10, xpc_object_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10064FCC8(uint64_t a1, char a2)
{
  uint64_t v3 = a1;
  char v4 = a2;
  xpc_object_t v2 = *(NSObject **)(a1 + 48);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100661E64;
  block[3] = &unk_1019F4FC8;
  block[4] = &v3;
  dispatch_sync(v2, block);
}

uint64_t sub_10064FD44(void *a1, int a2)
{
  char v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "disable";
    if (a2) {
      uint64_t v5 = "enable";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Request to %s brick mode", (uint8_t *)&buf, 0xCu);
  }
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  xpc_object_t v6 = a1 + 81;
  uint64_t v7 = a1[81];
  if (a2)
  {
    if (!v7)
    {
      int v8 = a1[5];
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v9)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Brick mode enabled; acquiring airplane mode assertion",
          (uint8_t *)&buf,
          2u);
      }
      capabilities::ct::supportsFallbackToBrickAfterEmergency((capabilities::ct *)v9);
      sub_100058DB0(&buf, "/cc/assertions/airplane_mode");
      ctu::rest::AssertionHandle::create();
      if (v16 < 0) {
        operator delete((void *)buf);
      }
      size_t v12 = (std::__shared_weak_count *)a1[82];
      *xpc_object_t v6 = v14;
      if (v12) {
        sub_10004D2C8(v12);
      }
      *(void *)&long long buf = off_1019F4FF8;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(&buf);
    }
  }
  else if (v7)
  {
    size_t v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Brick mode disabled; release airplane mode assertion",
        (uint8_t *)&buf,
        2u);
    }
    uint64_t v11 = (std::__shared_weak_count *)a1[82];
    *(void *)xpc_object_t v6 = 0;
    a1[82] = 0;
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  return ATCSMutex::unlock((ATCSMutex *)(a1 + 7));
}

void sub_10064FF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  ATCSMutex::unlock(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_10064FFDC(void *a1, BOOL a2, uint64_t a3)
{
  xpc_object_t v6 = (ATCSMutex *)(a1 + 7);
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  xpc_object_t v21 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v21 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v21 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_9;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_8:
  xpc_object_t v21 = v9;
LABEL_9:
  xpc_release(v8);
  xpc_object_t v19 = xpc_BOOL_create(a2);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  v18[0] = &v21;
  v18[1] = abm::kKeyIsBreadPaired;
  sub_100035E70((uint64_t)v18, &v19, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  uint64_t v10 = a1[129];
  xpc_object_t v17 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v17 = xpc_null_create();
  }
  uint64_t v11 = a1[126];
  dispatch_object_t v16 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v22 = a1;
  sub_1000DFC90((uint64_t)v23, a3);
  uint64_t v25 = 0;
  size_t v12 = operator new(0x30uLL);
  uint64_t v13 = abm::kCommandUpdateBreadProperty;
  long long v14 = v22;
  void *v12 = off_1019F5078;
  v12[1] = v14;
  sub_100023950((uint64_t)(v12 + 2), (uint64_t)v23);
  uint64_t v25 = v12;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v10 + 48))(v10, v13, &v17, &v16, v24);
  sub_1000595E4(v24);
  sub_100060644(v23);
  if (v16) {
    dispatch_release(v16);
  }
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v21);
  return ATCSMutex::unlock(v6);
}

void sub_100650220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006502C4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1184);
}

const void **sub_1006502CC(uint64_t a1)
{
  uint64_t v57 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  xpc_object_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    xpc_object_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  xpc_object_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v10 + 40))(__p, v10, kDefaultBundleId, @"OnBodyThresholdParametersFile", 0, 0);
  sub_100056248(&v57, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v56 = 0;
  if (v57) {
    size_t v12 = sub_1000810B8;
  }
  else {
    size_t v12 = 0;
  }
  if (v12)
  {
    uint64_t v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
    long long v14 = v13;
    if (v15 < 0)
    {
      dispatch_object_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(v13);
    *(void *)long long buf = v15;
    xpc_object_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      uint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
LABEL_29:
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v21 + 152))(&v51, v21);
    memset(buf, 0, sizeof(buf));
    uint64_t v60 = 0;
    ctu::cf::assign();
    *(_OWORD *)uint64_t v49 = *(_OWORD *)buf;
    *(_OWORD *)int v53 = v51;
    uint64_t v54 = v52;
    uint64_t v52 = 0;
    uint64_t v50 = v60;
    long long v51 = 0uLL;
    ctu::path_join_impl();
    if (SHIBYTE(v56) < 0) {
      operator delete(__p[0]);
    }
    *(_OWORD *)long long __p = *(_OWORD *)v53;
    uint64_t v56 = v54;
    HIBYTE(v54) = 0;
    LOBYTE(v53[0]) = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(v49[0]);
    }
    if (SHIBYTE(v52) < 0)
    {
      int v31 = (void *)v51;
LABEL_41:
      operator delete(v31);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  xpc_object_t v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v24 = v23;
  if (v25 < 0)
  {
    char v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v23);
  *(void *)&long long v51 = v25;
  char v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&v51);
  if (v29)
  {
    uint64_t v30 = v29[3];
    uint64_t v20 = (std::__shared_weak_count *)v29[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
  std::mutex::unlock(v24);
  uint64_t v20 = 0;
  char v22 = 1;
LABEL_37:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v30 + 152))(v53, v30);
  *(_OWORD *)long long buf = *(_OWORD *)v53;
  uint64_t v60 = v54;
  v53[1] = 0;
  uint64_t v54 = 0;
  v53[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v56) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v56 = v60;
  HIBYTE(v6sub_10010E764((uint64_t)&a9, 0) = 0;
  buf[0] = 0;
  if (SHIBYTE(v54) < 0)
  {
    int v31 = v53[0];
    goto LABEL_41;
  }
LABEL_42:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  size_t v32 = (void *)HIBYTE(v56);
  if (v56 < 0) {
    size_t v32 = __p[1];
  }
  if (v32)
  {
    v53[0] = 0;
    uint64_t v33 = *(void *)(a1 + 752);
    *(void *)long long buf = *(void *)(a1 + 744);
    *(void *)&uint8_t buf[8] = v33;
    if (v33) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1007B946C((os_log_t *)(a1 + 40), (Registry **)buf, (const UInt8 *)__p, (const void **)v53);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    unsigned int v34 = (ctu *)v53[0];
    if (v53[0]) {
      uint64_t v35 = sub_100080778;
    }
    else {
      uint64_t v35 = 0;
    }
    unint64_t v36 = *(NSObject **)(a1 + 40);
    BOOL v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    if (v35)
    {
      if (v37)
      {
        unsigned int v39 = __p;
        if (v56 < 0) {
          unsigned int v39 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v39;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Loaded body threshold parameters file %s in the bundle", buf, 0xCu);
        unsigned int v34 = (ctu *)v53[0];
      }
      ctu::cf_to_xpc((uint64_t *)buf, v34, v38);
      xpc_object_t v40 = *(xpc_object_t *)buf;
      if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v40 = xpc_null_create();
      }
      xpc_release(*(xpc_object_t *)buf);
      uint64_t v43 = *(void *)(a1 + 1032);
      xpc_object_t v48 = v40;
      if (v40) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v48 = xpc_null_create();
      }
      uint64_t v44 = abm::kCommandSetBundle;
      int v45 = *(NSObject **)(a1 + 1008);
      dispatch_object_t object = v45;
      if (v45) {
        dispatch_retain(v45);
      }
      v58[0] = off_1019F50F8;
      v58[1] = a1;
      v58[3] = v58;
      (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v43 + 48))(v43, v44, &v48, &object, v58);
      sub_1000595E4(v58);
      if (object) {
        dispatch_release(object);
      }
      xpc_release(v48);
      xpc_object_t v48 = 0;
      xpc_release(v40);
    }
    else if (v37)
    {
      size_t v42 = __p;
      if (v56 < 0) {
        size_t v42 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v42;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Could not load body threshold parameters file %s in the bundle", buf, 0xCu);
    }
    sub_100057D78((const void **)v53);
  }
  else
  {
    char v41 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I No on body threshold parameters file in the bundle", buf, 2u);
    }
  }
  if (SHIBYTE(v56) < 0) {
    operator delete(__p[0]);
  }
  return sub_1000558F4(&v57);
}

void sub_10065097C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,const void *a36,__int16 a37,char a38,char a39)
{
  if (*(char *)(v41 - 73) < 0) {
    operator delete(*(void **)(v41 - 96));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if ((v40 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_1000558F4(&a36);
  _Unwind_Resume(a1);
}

uint64_t sub_100650AD8(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v6 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  uint64_t v22 = 0;
  *(_OWORD *)uint64_t v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  *(_OWORD *)xpc_object_t v19 = 0u;
  sub_10044AB4C((uint64_t)&v18);
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  sub_10044AD78((unsigned __int16 *)&v18, v16);
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  sub_100058DB0(v14, a2);
  uint64_t v7 = *(void *)(a1 + 1016);
  if (SHIBYTE(v15) < 0)
  {
    sub_10004FC84(&v10, v14[0], (unint64_t)v14[1]);
  }
  else
  {
    long long v10 = *(_OWORD *)v14;
    uint64_t v11 = v15;
  }
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&__p, v16[0], (unint64_t)v16[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v16;
    uint64_t v13 = v17;
  }
  uint64_t v24 = 0;
  xpc_object_t v8 = (char *)operator new(0x48uLL);
  v8[16] = a3;
  *(void *)xpc_object_t v8 = off_1019F5178;
  *((void *)v8 + 1) = a1;
  *(_OWORD *)(v8 + 24) = v10;
  *((void *)v8 + 5) = v11;
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  *((_OWORD *)v8 + 3) = __p;
  *((void *)v8 + 8) = v13;
  uint64_t v13 = 0;
  long long __p = 0uLL;
  uint64_t v24 = v8;
  (*(void (**)(uint64_t, void **, uint64_t, void *))(*(void *)v7 + 32))(v7, v14, a3, v23);
  sub_1000595E4(v23);
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  if (SHIBYTE(v20[0]) < 0) {
    operator delete(v19[0]);
  }
  return ATCSMutex::unlock(v6);
}

void sub_100650D08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  sub_10008AF64((uint64_t)&a32);
  ATCSMutex::unlock(v32);
  _Unwind_Resume(a1);
}

void sub_100650DA8(uint64_t a1, xpc_object_t *a2)
{
  if (&_sCanHostHelperServer && sCanHostHelperServer())
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100120074(a2, __p);
      uint64_t v5 = (SBYTE7(v22) & 0x80u) == 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ConfigureLogging option: %s", buf, 0xCu);
      if (SBYTE7(v22) < 0) {
        operator delete(__p[0]);
      }
    }
    if (xpc_dictionary_get_value(*a2, "kCTRadioUseLoggingProfileKey"))
    {
      __p[0] = a2;
      __p[1] = "kCTRadioUseLoggingProfileKey";
      sub_100048BAC((uint64_t)__p, buf);
      int v7 = xpc::dyn_cast_or_default((xpc *)buf, 0, v6);
      xpc_release(*(xpc_object_t *)buf);
      __p[0] = a2;
      __p[1] = "kCTRadioRequireUserConfirmationToEnableKey";
      sub_100048BAC((uint64_t)__p, buf);
      char v9 = xpc::dyn_cast_or_default((xpc *)buf, (const object *)1, v8);
      xpc_release(*(xpc_object_t *)buf);
      uint64_t v30 = 0;
      int v31 = 0;
      v28[1] = 0;
      char v29 = 0;
      abm::HelperClient::create();
      if (v29) {
        sub_10004D2C8(v29);
      }
      v28[0] = 0;
      xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v11 = v10;
      if (v10)
      {
        v28[0] = v10;
      }
      else
      {
        xpc_object_t v11 = xpc_null_create();
        v28[0] = v11;
        if (!v11)
        {
          xpc_object_t v13 = xpc_null_create();
          xpc_object_t v11 = 0;
          goto LABEL_22;
        }
      }
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v11);
        goto LABEL_23;
      }
      xpc_object_t v13 = xpc_null_create();
LABEL_22:
      v28[0] = v13;
LABEL_23:
      xpc_release(v11);
      xpc_object_t v26 = xpc_string_create(abm::helper::kDefaultCarrierLoggingProfileName);
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      __p[0] = v28;
      __p[1] = (void *)abm::helper::kKeyProfileName;
      sub_100035E70((uint64_t)__p, &v26, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_object_t v24 = xpc_BOOL_create(v9);
      if (!v24) {
        xpc_object_t v24 = xpc_null_create();
      }
      __p[0] = v28;
      __p[1] = (void *)abm::helper::kKeyRequireUserConfirmation;
      sub_100035E70((uint64_t)__p, &v24, &v25);
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_release(v24);
      xpc_object_t v23 = 0;
      xpc_object_t v24 = 0;
      xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v15 = v14;
      if (v14)
      {
        xpc_object_t v23 = v14;
      }
      else
      {
        xpc_object_t v15 = xpc_null_create();
        xpc_object_t v23 = v15;
        if (!v15)
        {
          xpc_object_t v16 = xpc_null_create();
          xpc_object_t v15 = 0;
          goto LABEL_34;
        }
      }
      if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v15);
LABEL_35:
        xpc_release(v15);
        *(_OWORD *)long long __p = 0u;
        long long v22 = 0u;
        xpc_object_t v20 = v28[0];
        if (v28[0]) {
          xpc_retain(v28[0]);
        }
        else {
          xpc_object_t v20 = xpc_null_create();
        }
        abm::HelperClient::perform();
        xpc_release(v20);
        if (LODWORD(__p[0]))
        {
          uint64_t v17 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            sub_100651340((uint64_t)__p, buf);
            long long v18 = "Uninstall";
            if (v7) {
              long long v18 = "Install";
            }
            if (v33 >= 0) {
              xpc_object_t v19 = buf;
            }
            else {
              xpc_object_t v19 = *(unsigned char **)buf;
            }
            *(_DWORD *)unsigned int v34 = 136315394;
            uint64_t v35 = v18;
            __int16 v36 = 2080;
            BOOL v37 = v19;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%s logging profile failed : %s", v34, 0x16u);
            if (v33 < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        if (SHIBYTE(v22) < 0) {
          operator delete(__p[1]);
        }
        xpc_release(v23);
        xpc_release(v28[0]);
        if (v31) {
          sub_10004D2C8(v31);
        }
        return;
      }
      xpc_object_t v16 = xpc_null_create();
LABEL_34:
      xpc_object_t v23 = v16;
      goto LABEL_35;
    }
  }
  else
  {
    size_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot host ABMHelper", (uint8_t *)__p, 2u);
    }
  }
}

void sub_100651244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100651340@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  uint64_t v4 = sub_10004B96C(v16, (uint64_t)"Result:'", 8);
  sub_10065C798(*(_DWORD *)a1, __p);
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__p[1];
  }
  int v7 = sub_10004B96C(v4, (uint64_t)v5, v6);
  sub_10004B96C(v7, (uint64_t)"'", 1);
  if ((char)v15 < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    if (!*(void *)(a1 + 16)) {
      goto LABEL_20;
    }
LABEL_13:
    BOOL v8 = sub_10004B96C(v16, (uint64_t)" Info:'", 7);
    int v9 = *(char *)(a1 + 31);
    if (v9 >= 0) {
      uint64_t v10 = a1 + 8;
    }
    else {
      uint64_t v10 = *(void *)(a1 + 8);
    }
    if (v9 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      uint64_t v11 = *(void *)(a1 + 16);
    }
    size_t v12 = sub_10004B96C(v8, v10, v11);
    sub_10004B96C(v12, (uint64_t)"'", 1);
    goto LABEL_20;
  }
  if (*(unsigned char *)(a1 + 31)) {
    goto LABEL_13;
  }
LABEL_20:
  sub_10004BC98((uint64_t)v16 + 8, a2);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10065156C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_10065159C(void *a1, unsigned int a2)
{
  long long v42 = 0uLL;
  uint64_t v43 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v41 = 0;
  if (a2 >= 7) {
    __TUAssertTrigger();
  }
  sub_100058DB0(__p, off_1019CE850[a2]);
  if ((*(unsigned int (**)(void, void **))(*(void *)a1[129] + 32))(a1[129], __p))
  {
    xpc_object_t v39 = 0;
    xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v5 = v4;
    if (v4)
    {
      xpc_object_t v39 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v39 = v5;
      if (!v5)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v5 = 0;
        goto LABEL_20;
      }
    }
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v5);
      goto LABEL_21;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_20:
    xpc_object_t v39 = v8;
LABEL_21:
    xpc_release(v5);
    xpc_object_t v38 = xpc_null_create();
    if (v41 >= 0) {
      uint64_t v10 = __p;
    }
    else {
      uint64_t v10 = (void **)__p[0];
    }
    xpc_object_t v36 = xpc_string_create((const char *)v10);
    if (!v36) {
      xpc_object_t v36 = xpc_null_create();
    }
    *(void *)long long buf = &v39;
    *(void *)&uint8_t buf[8] = abm::kKeyTraceName;
    sub_100035E70((uint64_t)buf, &v36, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v36);
    uint64_t v11 = (const char **)&abm::kKeyTraceMode;
    xpc_object_t v36 = 0;
    if (a2 != 5) {
      uint64_t v11 = (const char **)&abm::kKeyEnabled;
    }
    xpc_object_t v34 = xpc_string_create(*v11);
    if (!v34) {
      xpc_object_t v34 = xpc_null_create();
    }
    *(void *)long long buf = &v39;
    *(void *)&uint8_t buf[8] = abm::kKeyTracePropertyName;
    sub_100035E70((uint64_t)buf, &v34, &v35);
    xpc_release(v35);
    xpc_object_t v35 = 0;
    xpc_release(v34);
    uint64_t v12 = a1[129];
    xpc_object_t v33 = v39;
    xpc_object_t v34 = 0;
    if (v39) {
      xpc_retain(v39);
    }
    else {
      xpc_object_t v33 = xpc_null_create();
    }
    int v13 = (*(uint64_t (**)(uint64_t, void, xpc_object_t *, xpc_object_t *))(*(void *)v12 + 56))(v12, abm::kCommandGetTraceProperty, &v33, &v38);
    xpc_object_t v14 = v38;
    xpc_release(v33);
    if (v14) {
      int v15 = v13;
    }
    else {
      int v15 = 0;
    }
    xpc_object_t v33 = 0;
    if (v15 != 1)
    {
      uint64_t v17 = a1[5];
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to get trace property", buf, 2u);
      }
      uint64_t v6 = 0;
      goto LABEL_68;
    }
    xpc_object_t v32 = 0;
    xpc_object_t v16 = v38;
    if (v38)
    {
      xpc_object_t v32 = v38;
    }
    else
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v32 = v16;
      if (!v16)
      {
        xpc_object_t v18 = xpc_null_create();
        xpc_object_t v16 = 0;
        goto LABEL_48;
      }
    }
    if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v16);
      goto LABEL_49;
    }
    xpc_object_t v18 = xpc_null_create();
LABEL_48:
    xpc_object_t v32 = v18;
LABEL_49:
    xpc_release(v16);
    v30[0] = &v32;
    v30[1] = abm::kKeyTracePropertyValue;
    sub_100048BAC((uint64_t)v30, &v31);
    xpc::dyn_cast_or_default((uint64_t *)buf, (xpc *)&v31, (const object *)"", v19);
    if (SHIBYTE(v43) < 0) {
      operator delete((void *)v42);
    }
    long long v42 = *(_OWORD *)buf;
    uint64_t v43 = *(void *)&buf[16];
    buf[23] = 0;
    buf[0] = 0;
    xpc_release(v31);
    uint64_t v20 = HIBYTE(v43);
    if (v43 < 0) {
      uint64_t v20 = *((void *)&v42 + 1);
    }
    if (v20 == 5)
    {
      long long v23 = &v42;
      if (v43 < 0) {
        long long v23 = (long long *)v42;
      }
      int v24 = *(_DWORD *)v23;
      int v25 = *((unsigned __int8 *)v23 + 4);
      BOOL v22 = v24 == 1936482662 && v25 == 101;
    }
    else
    {
      if (v20 != 1)
      {
        uint64_t v6 = 1;
LABEL_67:
        xpc_release(v32);
LABEL_68:
        xpc_release(v39);
        goto LABEL_69;
      }
      long long v21 = &v42;
      if (v43 < 0) {
        long long v21 = (long long *)v42;
      }
      BOOL v22 = *(unsigned char *)v21 == 48;
    }
    uint64_t v6 = !v22;
    goto LABEL_67;
  }
  uint64_t v6 = a1[63];
  if (!v6) {
    goto LABEL_69;
  }
  sub_100058DB0(buf, abm::kKeyEnabled);
  uint64_t v7 = sub_10040A374(v6, (const void **)__p, buf, (uint64_t)&v42);
  uint64_t v6 = v7;
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v6) {
      goto LABEL_69;
    }
  }
  else if (!v7)
  {
    goto LABEL_69;
  }
  uint64_t v9 = HIBYTE(v43);
  if (v43 < 0) {
    uint64_t v9 = *((void *)&v42 + 1);
  }
  if (v9) {
    uint64_t v6 = sub_10040A950((unsigned __int8 *)&v42);
  }
  else {
    uint64_t v6 = 0;
  }
LABEL_69:
  long long v26 = a1[5];
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    long long v27 = __p;
    if (v41 < 0) {
      long long v27 = (void **)__p[0];
    }
    long long v28 = " ";
    if (!v6) {
      long long v28 = " not ";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v27;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v28;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s trace is%senabled", buf, 0x16u);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete((void *)v42);
  }
  return v6;
}

void sub_100651AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, xpc_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100651BE8(uint64_t a1)
{
  if (((*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 240))(a1, 0) & 1) != 0
    || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 2) & 1) != 0)
  {
    return 1;
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 240);

  return v3(a1, 5);
}

void sub_100651CAC(int a1, std::string *__str)
{
}

void sub_100651CB4(void *a1, uint64_t *a2)
{
  if ((*(unsigned int (**)(void *))(*a1 + 176))(a1))
  {
    if (*((unsigned char *)a2 + 41))
    {
      ATCSMutex::lock((ATCSMutex *)(a1 + 7));
      operator new();
    }
    uint64_t v6 = *(void (**)(void *, uint64_t *))(*a1 + 168);
    v6(a1, a2);
  }
  else
  {
    xpc_object_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        xpc_object_t v5 = a2;
      }
      else {
        xpc_object_t v5 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      xpc_object_t v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CSI state dump requested and state dump skipped: %s", buf, 0xCu);
    }
    if (*((unsigned char *)a2 + 41)) {
      operator new();
    }
  }
}

void sub_100651FD0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_10065209C(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  sub_10044AB4C((uint64_t)&v28);
  v26[0] = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  sub_10044AD78((unsigned __int16 *)&v28, v26);
  memset(&v25, 0, sizeof(v25));
  if (a2)
  {
    std::string::operator=(&v25, (const std::string *)a2);
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    operator delete();
  }
  xpc_object_t v24 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v24 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v24 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_13;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_12:
  xpc_object_t v24 = v6;
LABEL_13:
  xpc_release(v5);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v7 = &v25;
  }
  else {
    uint64_t v7 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v22 = xpc_string_create((const char *)v7);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  uint64_t v20 = &v24;
  uint64_t v21 = abm::kKeyTraceDumpStateReason;
  sub_100035E70((uint64_t)&v20, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  if (v27 >= 0) {
    xpc_object_t v8 = v26;
  }
  else {
    xpc_object_t v8 = (void **)v26[0];
  }
  xpc_object_t v18 = xpc_string_create((const char *)v8);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  uint64_t v20 = &v24;
  uint64_t v21 = abm::kKeyTimestampString;
  sub_100035E70((uint64_t)&v20, &v18, &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(v18);
  uint64_t v9 = *(void *)(a1 + 1032);
  xpc_object_t v17 = v24;
  xpc_object_t v18 = 0;
  if (v24) {
    xpc_retain(v24);
  }
  else {
    xpc_object_t v17 = xpc_null_create();
  }
  uint64_t v10 = *(NSObject **)(a1 + 1008);
  dispatch_object_t v16 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v13, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
  }
  else {
    std::string v13 = v25;
  }
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(&__p, v26[0], (unint64_t)v26[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v26;
    uint64_t v15 = v27;
  }
  xpc_object_t v34 = 0;
  uint64_t v11 = (char *)operator new(0x40uLL);
  uint64_t v12 = abm::kCommandTraceDumpState;
  *(void *)uint64_t v11 = off_1019F5240;
  *((void *)v11 + 1) = a1;
  *(std::string *)(v11 + 16) = v13;
  memset(&v13, 0, sizeof(v13));
  *((void *)v11 + 7) = v15;
  *(_OWORD *)(v11 + 4sub_10010E764((uint64_t)&a9, 0) = __p;
  uint64_t v15 = 0;
  long long __p = 0uLL;
  xpc_object_t v34 = v11;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v9 + 48))(v9, v12, &v17, &v16, v33);
  sub_1000595E4(v33);
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if (v16) {
    dispatch_release(v16);
  }
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v24);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(*((void **)&v30 + 1));
  }
  if (SBYTE7(v30) < 0) {
    operator delete((void *)v29);
  }
}

void sub_10065245C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object, xpc_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (object) {
    dispatch_release(object);
  }
  xpc_release(a20);
  xpc_release(a27);
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  sub_10008AF64(v39 - 144);
  _Unwind_Resume(a1);
}

void sub_100652550(uint64_t a1, const void **a2, uint64_t a3)
{
  xpc_object_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ABM Server is not available. So, dump CommCenter state alone and proceed.", (uint8_t *)&buf, 2u);
  }
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long buf = 0u;
  if (*(char *)(a1 + 1071) < 0)
  {
    **(unsigned char **)(a1 + 1048) = 0;
    *(void *)(a1 + 1056) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 1048) = 0;
    *(unsigned char *)(a1 + 1071) = 0;
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = (size_t)a2[1];
  }
  memset(&v26, 0, sizeof(v26));
  xpc_object_t v8 = &v26;
  sub_1000C140C((uint64_t)&v26, v7 + 25);
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    xpc_object_t v8 = (std::string *)v26.__r_.__value_.__r.__words[0];
  }
  if (v7)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *a2;
    }
    memmove(v8, v9, v7);
  }
  strcpy((char *)v8 + v7, " (Baseband not available)");
  memset(&__dst, 0, sizeof(__dst));
  int v10 = *(char *)(a3 + 23);
  if (v10 < 0)
  {
    sub_10004FC84(&__dst, *(void **)a3, *(void *)(a3 + 8));
    int v10 = *(char *)(a3 + 23);
    if (v10 < 0)
    {
      if (*(void *)(a3 + 8)) {
        goto LABEL_27;
      }
      goto LABEL_20;
    }
  }
  else
  {
    std::string __dst = *(std::string *)a3;
  }
  if ((_BYTE)v10) {
    goto LABEL_27;
  }
LABEL_20:
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  memset(v21, 0, sizeof(v21));
  sub_10044AB4C((uint64_t)v21);
  sub_10044AD78((unsigned __int16 *)v21, &__str);
  std::string::operator=(&__dst, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(*((void **)&v22 + 1));
  }
  if (SBYTE7(v22) < 0) {
    operator delete(*(void **)&v21[16]);
  }
LABEL_27:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v19, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v19 = __dst;
  }
  sub_10044ABFC((uint64_t)&v32, (char *)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  sub_10044ACC4((unsigned __int16 *)&v32, v21);
  std::string::operator=((std::string *)&buf, (const std::string *)v21);
  if ((v21[23] & 0x80000000) != 0) {
    operator delete(*(void **)v21);
  }
  LOBYTE(v3sub_10010E764((uint64_t)&a9, 0) = 0;
  std::string::operator=((std::string *)((char *)&v30 + 8), &v26);
  uint64_t v11 = *(const std::string **)(a1 + 504);
  if (v11)
  {
    std::string::operator=((std::string *)((char *)&v28 + 8), v11 + 8);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Warning: TraceModule has not been setup yet.", v21, 2u);
    }
    if (SHIBYTE(v29) < 0)
    {
      *(void *)&long long v29 = 0;
      std::string v13 = (unsigned char *)*((void *)&v28 + 1);
    }
    else
    {
      std::string v13 = (char *)&v28 + 8;
      HIBYTE(v29) = 0;
    }
    unsigned char *v13 = 0;
  }
  sub_100257970((uint64_t)&buf);
  if (byte_101B0D28F >= 0) {
    xpc_object_t v14 = (const char *)&qword_101B0D278;
  }
  else {
    xpc_object_t v14 = (const char *)qword_101B0D278;
  }
  int v15 = open(v14, 512, 420);
  sub_100101968(v15);
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    dispatch_object_t v16 = &v26;
  }
  else {
    dispatch_object_t v16 = (std::string *)v26.__r_.__value_.__r.__words[0];
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v18, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v18 = __dst;
  }
  sub_10064E74C(&v17);
  sub_10064E7DC(a1, (char *)v16, a1, (uint64_t)&v18, (uint64_t)&v17);
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(*((void **)&v30 + 1));
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(*((void **)&v28 + 1));
  }
  if (SBYTE7(v28) < 0) {
    operator delete((void *)buf);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(*((void **)&v34 + 1));
  }
  if (SBYTE7(v34) < 0) {
    operator delete((void *)v33);
  }
}

void sub_100652960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_10008AF64((uint64_t)&a32);
  if (a50 < 0) {
    operator delete(a45);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  sub_10019693C(v56 - 224);
  sub_10008AF64(v56 - 144);
  _Unwind_Resume(a1);
}

uint64_t sub_100652A24(void *a1, xpc_object_t *a2)
{
  xpc_object_t v4 = (ATCSMutex *)(a1 + 7);
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  memset(v30, 0, sizeof(v30));
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v26 = a2;
    uint64_t v27 = abm::kKeyTimestampString;
    sub_100048BAC((uint64_t)&v26, &object);
    *(void *)long long buf = 0;
    size_t v32 = 0;
    uint64_t v33 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v33) < 0) {
      operator delete(*(void **)buf);
    }
    xpc_object_t v6 = std::string::insert(&v29, 0, "log-bb-", 7uLL);
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[0];
    *(void *)long long v34 = v6->__r_.__value_.__l.__size_;
    *(void *)&v34[7] = *(std::string::size_type *)((char *)&v6->__r_.__value_.__r.__words[1] + 7);
    char v8 = HIBYTE(v6->__r_.__value_.__r.__words[2]);
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if ((v30[23] & 0x80000000) != 0) {
      operator delete(*(void **)v30);
    }
    *(void *)long long v30 = v7;
    *(void *)&v30[8] = *(void *)v34;
    *(void *)&v30[15] = *(void *)&v34[7];
    v30[23] = v8;
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    xpc_release(object);
    xpc_object_t v26 = a2;
    uint64_t v27 = abm::kKeyTraceDumpStatePath;
    sub_100048BAC((uint64_t)&v26, v34);
    *(void *)long long buf = 0;
    size_t v32 = 0;
    uint64_t v33 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v33) < 0) {
      operator delete(*(void **)buf);
    }
    if ((v30[47] & 0x80000000) != 0) {
      operator delete(*(void **)&v30[24]);
    }
    *(std::string *)&v30[24] = v29;
    *((unsigned char *)&v29.__r_.__value_.__s + 23) = 0;
    v29.__r_.__value_.__s.__data_[0] = 0;
    xpc_release(*(xpc_object_t *)v34);
    xpc_object_t v26 = a2;
    uint64_t v27 = abm::kKeyTraceDumpStateReason;
    sub_100048BAC((uint64_t)&v26, v34);
    *(void *)long long buf = 0;
    size_t v32 = 0;
    uint64_t v33 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v33) < 0) {
      operator delete(*(void **)buf);
    }
    if ((v30[79] & 0x80000000) != 0) {
      operator delete(*(void **)&v30[56]);
    }
    *(std::string *)&v30[56] = v29;
    *((unsigned char *)&v29.__r_.__value_.__s + 23) = 0;
    v29.__r_.__value_.__s.__data_[0] = 0;
    xpc_release(*(xpc_object_t *)v34);
    *(void *)long long buf = 0;
    size_t v32 = 0;
    uint64_t v33 = 0;
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
    v29.__r_.__value_.__l.__size_ = abm::kKeyTraceFilterAction;
    sub_100048BAC((uint64_t)&v29, &v26);
    uint64_t v9 = (char *)abm::kTraceFilterActionNone;
    xpc::dyn_cast_or_default((uint64_t *)buf, (xpc *)&v26, abm::kTraceFilterActionNone, v10);
    xpc_release(v26);
    sub_100058DB0(&v29, v9);
    char v11 = HIBYTE(v33);
    if (v33 >= 0) {
      size_t v12 = HIBYTE(v33);
    }
    else {
      size_t v12 = v32;
    }
    std::string::size_type size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    int v14 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v29.__r_.__value_.__l.__size_;
    }
    if (v12 == size)
    {
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v15 = &v29;
      }
      else {
        int v15 = (std::string *)v29.__r_.__value_.__r.__words[0];
      }
      if (SHIBYTE(v33) < 0)
      {
        BOOL v21 = memcmp(*(const void **)buf, v15, v32) != 0;
      }
      else if (HIBYTE(v33))
      {
        uint64_t v16 = HIBYTE(v33) - 1;
        std::string v17 = buf;
        do
        {
          int v19 = *v17++;
          int v18 = v19;
          int v20 = v15->__r_.__value_.__s.__data_[0];
          int v15 = (std::string *)((char *)v15 + 1);
          BOOL v22 = v18 == v20;
          BOOL v21 = v18 != v20;
          BOOL v22 = !v22 || v16-- == 0;
        }
        while (!v22);
      }
      else
      {
        BOOL v21 = 0;
      }
    }
    else
    {
      BOOL v21 = 1;
    }
    v30[48] = v21;
    if (v14 < 0)
    {
      operator delete(v29.__r_.__value_.__l.__data_);
      if ((v33 & 0x8000000000000000) == 0) {
        goto LABEL_47;
      }
    }
    else if ((v11 & 0x80) == 0)
    {
      goto LABEL_47;
    }
    operator delete(*(void **)buf);
  }
  else
  {
    xpc_object_t v5 = (const std::string *)a1[63];
    if (v5)
    {
      std::string::operator=((std::string *)v30, v5 + 10);
      std::string::operator=((std::string *)&v30[24], (const std::string *)(a1[63] + 192));
    }
    else
    {
      long long v23 = a1[5];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Warning: sendEndStateDumpNotification: TraceModule has not been setup yet.", buf, 2u);
      }
      if ((v30[47] & 0x80000000) != 0)
      {
        *(void *)&v30[32] = 0;
        uint64_t v24 = *(unsigned char **)&v30[24];
      }
      else
      {
        uint64_t v24 = &v30[24];
        v30[47] = 0;
      }
      *uint64_t v24 = 0;
    }
  }
LABEL_47:
  sub_100257D50((uint64_t)v30);
  if ((v30[79] & 0x80000000) != 0) {
    operator delete(*(void **)&v30[56]);
  }
  if ((v30[47] & 0x80000000) != 0) {
    operator delete(*(void **)&v30[24]);
  }
  if ((v30[23] & 0x80000000) != 0) {
    operator delete(*(void **)v30);
  }
  return ATCSMutex::unlock(v4);
}

void sub_100652E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (*(char *)(v19 - 73) < 0) {
    operator delete(*(void **)(v19 - 96));
  }
  sub_10019693C((uint64_t)&a18);
  ATCSMutex::unlock(v18);
  _Unwind_Resume(a1);
}

void sub_100652F54(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  xpc_object_t v2 = ServiceMap;
  uint64_t v3 = "N3awd7metrics14MetricCountersE";
  if (((unint64_t)"N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
  {
    xpc_object_t v4 = (unsigned __int8 *)((unint64_t)"N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = (const char *)v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  char v11 = v3;
  std::string::size_type v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)&v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    char v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v7[3];
  char v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    sub_100BA95B0(v9);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  sub_100258364();
}

void sub_10065303C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10065305C(uint64_t a1)
{
  CSIRadioModulePrivate::init((CSIRadioModulePrivate *)a1);
  LOBYTE(__p) = 0;
  uint64_t v2 = sub_100365D74();
  sub_100058DB0(&buf, "C2KRadioModule::kCellularDataUsed");
  BOOL v3 = sub_1002260B0(v2, (void **)&buf.__r_.__value_.__l.__data_, (BOOL *)&__p);
  BOOL v4 = v3;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if (!v4) {
      goto LABEL_4;
    }
  }
  else if (!v3)
  {
LABEL_4:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D238, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D238))
    {
      WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
      sub_100058DB0(&buf, WirelessUserDirectory);
      sub_10055B020("/Library/", &buf, (std::string *)&unk_101B0D290);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      __cxa_atexit((void (*)(void *))&std::string::~string, &unk_101B0D290, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D238);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D240, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D240))
    {
      sub_10055AF5C("/Logs/", (const void **)&unk_101B0D290, &qword_101B0D2A8);
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D2A8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D240);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D248, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D248))
    {
      sub_10055AF5C("/CrashReporter/Baseband/", (const void **)&qword_101B0D2A8, &qword_101B0D2C0);
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D2C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D248);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D250, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D250))
    {
      sub_10055AF5C("/CoreTelephonyTrace/", (const void **)&qword_101B0D2A8, &qword_101B0D2D8);
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D2D8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D250);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D258, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0D258))
    {
      sub_10055AF5C("/CoreTelephonyTraceScratch/", (const void **)&qword_101B0D2A8, &qword_101B0D2F0);
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D2F0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0D258);
    }
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ----------------- Starting C2KRadioModule ----------------", (uint8_t *)&buf, 2u);
    }
    *(void *)(a1 + 528) |= 0x800uLL;
    if (TelephonyRadiosGetRadioVendor() == 1)
    {
      uint64_t v6 = *(void *)(a1 + 752);
      long long __p = *(void **)(a1 + 744);
      uint64_t v11 = v6;
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = *(void *)(a1 + 184);
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      sub_1007CC690(&buf);
    }
    *(void *)(a1 + 528) |= 0x1000uLL;
    uint64_t v8 = *(void *)(a1 + 752);
    long long __p = *(void **)(a1 + 744);
    uint64_t v11 = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    PSManager::create();
  }
  *(unsigned char *)(a1 + 100sub_10010E764((uint64_t)&a9, 0) = (_BYTE)__p;
  goto LABEL_4;
}

void sub_100654ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
}

void sub_100654F44(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100654F60()
{
  *(void *)(v1 - 136) = v0;
  sub_100163C60((void ***)(v1 - 136));
  operator delete();
}

void sub_100654F74()
{
  __cxa_free_exception(v0);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 - 128);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (STACK[0x2B8]) {
    dispatch_release((dispatch_object_t)STACK[0x2B8]);
  }
  BOOL v3 = *(std::__shared_weak_count **)(v1 - 192);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(v1 - 160);
  if (v4) {
    sub_10004D2C8(v4);
  }
  JUMPOUT(0x1006554FCLL);
}

void sub_100654F94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  sub_1000595E4(&a43);
  if (STACK[0x298]) {
    dispatch_release((dispatch_object_t)STACK[0x298]);
  }
  xpc_release((xpc_object_t)STACK[0x2B8]);
  STACK[0x2B8] = 0;
  sub_10008AF64((uint64_t)&a51);
  xpc_release(*(xpc_object_t *)(v51 - 168));
  JUMPOUT(0x1006554F8);
}

void sub_100655000()
{
  __cxa_free_exception(v0);
  JUMPOUT(0x1006554FCLL);
}

void sub_100655010(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52)
{
  __cxa_free_exception(v52);
  if (a52) {
    sub_10004D2C8(a52);
  }
  JUMPOUT(0x1006554FCLL);
}

void sub_10065503C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  if (a24) {
    sub_10004D2C8(a24);
  }
  if (!a44) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100655504);
}

void sub_10065505C()
{
}

void sub_100655084(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,NSObject *object,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29)
{
  if (object) {
    dispatch_release(object);
  }
  xpc_release(a26);
  xpc_release(a29);
  JUMPOUT(0x1006554F8);
}

void sub_1006550C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (!a30) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006550E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (!a31) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006550F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (!a32) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (!a33) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655128(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (!a34) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655140(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (!a35) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  sub_10065D5AC((void *)(v36 - 232));
  if (!a36) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655170(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  sub_10065D5AC((void *)(v37 - 200));
  if (!a37) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_100655188(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  sub_10065D5AC((void *)(v38 - 168));
  if (!a38) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006551A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  sub_10065D5AC((void *)(v39 - 136));
  if (!a39) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006551B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  if (!a40) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006551D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  if (!a41) {
    JUMPOUT(0x1006554F8);
  }
  JUMPOUT(0x1006554F4);
}

void sub_1006551E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  if (a42) {
    (*(void (**)(uint64_t))(*(void *)a42 + 8))(a42);
  }
  JUMPOUT(0x1006554F8);
}

void sub_100655228(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100655268(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint **a13)
{
}

void sub_100655278(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100663D78(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100655298()
{
  __cxa_end_catch();
  sub_10000A740(v1);
  *(void *)uint64_t v0 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(v0 + 16));
  operator delete();
}

void sub_100655314()
{
}

void sub_10065531C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char *a51)
{
  dispatch_release(v51);
  dispatch_release(v51);
  dispatch_release(v51);
  dispatch_release(v51);
  dispatch_release(v51);
  dispatch_release(v51);
  dispatch_release(v51);
  sub_100664520(v52);
  a51 = &a43;
  sub_100163C60((void ***)&a51);
  JUMPOUT(0x1006554F0);
}

void sub_10065534C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52)
{
  if (a52) {
    sub_10004D2C8(a52);
  }
  JUMPOUT(0x1006554F8);
}

void sub_100655360()
{
}

void sub_1006553C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100655428()
{
}

void sub_100655468(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100655478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  sub_100664520(&a51);
  sub_100664520((uint64_t *)(v51 - 136));
  JUMPOUT(0x10065548CLL);
}

void sub_1006554B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  sub_100161F10(&a51);
  sub_100663070(&a43);
  dispatch_release(v51);
  if (a17) {
    sub_10004D2C8(a17);
  }
  JUMPOUT(0x100655508);
}

void sub_1006554C0()
{
}

void sub_1006554C8(_Unwind_Exception *a1)
{
}

uint64_t sub_100655510(void *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = (ATCSMutex *)(a1 + 7);
  ATCSMutex::lock((ATCSMutex *)(a1 + 7));
  if (a1[129])
  {
    xpc_object_t object = 0;
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v8 = v7;
    if (v7)
    {
      xpc_object_t object = v7;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t object = v8;
      if (!v8)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v8 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v8);
LABEL_12:
      xpc_release(v8);
      if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v22 = xpc_int64_create(a2);
        if (!v22) {
          xpc_object_t v22 = xpc_null_create();
        }
        *(void *)std::string buf = &object;
        uint64_t v21 = abm::kKeyVisitArrival;
        sub_100035E70((uint64_t)buf, &v22, &v23);
        xpc_release(v23);
        xpc_object_t v23 = 0;
        xpc_release(v22);
        xpc_object_t v22 = 0;
        xpc_object_t v18 = xpc_int64_create(a3);
        if (!v18) {
          xpc_object_t v18 = xpc_null_create();
        }
        *(void *)std::string buf = &object;
        uint64_t v21 = abm::kKeyVisitDeparture;
        sub_100035E70((uint64_t)buf, &v18, &v19);
        xpc_release(v19);
        xpc_object_t v19 = 0;
        xpc_release(v18);
        uint64_t v12 = a1[129];
        xpc_object_t v17 = object;
        xpc_object_t v18 = 0;
        if (object) {
          xpc_retain(object);
        }
        else {
          xpc_object_t v17 = xpc_null_create();
        }
        uint64_t v13 = abm::kCommandUpdateBreadProperty;
        int v14 = a1[126];
        dispatch_object_t v16 = v14;
        if (v14) {
          dispatch_retain(v14);
        }
        v25[0] = off_1019F65B8;
        v25[1] = a1;
        v25[3] = v25;
        (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v12 + 48))(v12, v13, &v17, &v16, v25);
        sub_1000595E4(v25);
        if (v16) {
          dispatch_release(v16);
        }
        xpc_release(v17);
        xpc_object_t v17 = 0;
      }
      else
      {
        uint64_t v11 = a1[5];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to create input dictionary!", buf, 2u);
        }
      }
      xpc_release(object);
      return ATCSMutex::unlock(v6);
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_11:
    xpc_object_t object = v10;
    goto LABEL_12;
  }
  uint64_t v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", buf, 2u);
  }
  return ATCSMutex::unlock(v6);
}

void sub_100655800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, char a18)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1006558A0(uint64_t a1)
{
  *(void *)a1 = off_1019F4100;
  *(void *)(a1 + 8) = off_1019F4370;
  *(void *)(a1 + 16) = off_1019F4398;
  sub_100136194(a1 + 2080);
  sub_100136194(a1 + 1280);
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 1260));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 1240));
  sub_10019D5B8(a1 + 1200, *(void **)(a1 + 1208));
  sub_100087F94(a1 + 1136, *(void **)(a1 + 1144));
  sub_100087F94(a1 + 1104, *(void **)(a1 + 1112));
  xpc_object_t v10 = (void **)(a1 + 1080);
  sub_10008A88C(&v10);
  if (*(char *)(a1 + 1071) < 0) {
    operator delete(*(void **)(a1 + 1048));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1040);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 1024);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(NSObject **)(a1 + 1008);
  if (v4) {
    dispatch_release(v4);
  }
  if (*(char *)(a1 + 999) < 0) {
    operator delete(*(void **)(a1 + 976));
  }
  uint64_t v5 = *(void **)(a1 + 944);
  if (v5)
  {
    *(void *)(a1 + 952) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 848);
  if (v6)
  {
    *(void *)(a1 + 856) = v6;
    operator delete(v6);
  }
  xpc_object_t v7 = *(void **)(a1 + 824);
  if (v7)
  {
    *(void *)(a1 + 832) = v7;
    operator delete(v7);
  }
  xpc_object_t v8 = *(void **)(a1 + 792);
  if (v8)
  {
    *(void *)(a1 + 80sub_10010E764((uint64_t)&a9, 0) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 784);
  if (v9) {
    sub_10004D2C8(v9);
  }
  CSIRadioModulePrivate::~CSIRadioModulePrivate((CSIRadioModulePrivate *)a1);
}

void sub_100655A14(uint64_t a1)
{
}

void sub_100655A1C(uint64_t a1)
{
}

void sub_100655A24(uint64_t a1)
{
  sub_1006558A0(a1);

  operator delete();
}

void sub_100655A5C(uint64_t a1)
{
  sub_1006558A0(a1 - 8);

  operator delete();
}

void sub_100655A98(uint64_t a1)
{
  sub_1006558A0(a1 - 16);

  operator delete();
}

uint64_t sub_100655AD4(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) < 0) {
    a2 = (uint64_t *)*a2;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1 + 144))(a1, a2, 1);
}

BOOL sub_100655B0C(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v13) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Request to enter low power", (uint8_t *)&v13, 2u);
  }
  uint64_t v5 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  unsigned int v6 = *(_DWORD *)(a1 + 380);
  if (v6 > 8)
  {
    __TUAssertTrigger();
LABEL_12:
    if (*(void *)(a1 + 248)) {
      __TUAssertTrigger();
    }
    sub_10033A644((void *)(a1 + 224), a2);
    BOOL v10 = CSIRadioModulePrivate::enterLowPowerInternal((CSIRadioModulePrivate *)a1);
    goto LABEL_18;
  }
  if (((1 << v6) & 0x1ED) != 0)
  {
    xpc_object_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v8 = off_1019F6A10[v6];
      int v13 = 136315138;
      int v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I State is %s, skipping enter low power", (uint8_t *)&v13, 0xCu);
    }
    BOOL v10 = 1;
    sub_1000607A8(a2, 1);
    goto LABEL_18;
  }
  if (v6 == 1)
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Entering low power", (uint8_t *)&v13, 2u);
    }
    goto LABEL_12;
  }
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 136315138;
    int v14 = "Exiting Low Power";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I State is %s, deferring enter low power", (uint8_t *)&v13, 0xCu);
  }
  sub_10033A644((void *)(a1 + 224), a2);
  BOOL v10 = 1;
LABEL_18:
  ATCSMutex::unlock(v5);
  return v10;
}

void sub_100655D44(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100655D78(uint64_t a1)
{
  uint64_t v2 = (ATCSMutex *)(a1 + 56);
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 56)) & 1) == 0) {
    __TUAssertTrigger();
  }
  ATCSMutex::unlock(v2);
  sub_100360A94((uint64_t *)(a1 + 440), 2u, *(_DWORD *)(a1 + 432), 0, 0);
  ATCSMutex::lock(v2);
  (*(void (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  int v5 = HIDWORD(*(void *)(a1 + 336));
  int v4 = 0;
  LOBYTE(v5) = 1;
  return sub_100655E2C(a1 + 304, &v4);
}

uint64_t sub_100655E2C(uint64_t a1, int *a2)
{
  uint64_t v4 = a1 + 32;
  uint64_t v5 = operator!=();
  if (v5)
  {
    int v6 = *a2;
    *(_WORD *)(v4 + 4) = *((_WORD *)a2 + 2);
    *(_DWORD *)uint64_t v4 = v6;
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v4);
    }
  }
  return v5;
}

uint64_t sub_100655EB4(uint64_t a1)
{
  uint64_t v2 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if (*(unsigned char *)(a1 + 256))
  {
    BOOL v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I already power off", buf, 2u);
    }
  }
  else
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 464))(a1);
    *(unsigned char *)(a1 + 256) = 1;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100655FE8;
    block[3] = &unk_1019F43C0;
    block[4] = a1;
    dispatch_async(global_queue, block);
  }
  return ATCSMutex::unlock(v2);
}

void sub_100655FCC(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100655FE8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int Uptime = CSIRadioModulePrivate::getUptime((CSIRadioModulePrivate *)v1);
  ATCSMutex::lock((ATCSMutex *)(v1 + 56));
  uint64_t v2 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&__p, *(char **)(v1 + 640));
  sub_1006560E0(v2, &__p, &Uptime);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *(_DWORD *)(v1 + 376) = 2;
  ATCSMutex::unlock((ATCSMutex *)(v1 + 56));
  (*(void (**)(void))(**(void **)(v1 + 64) + 64))(*(void *)(v1 + 64));
  return (*(uint64_t (**)(void))(**(void **)(v1 + 216) + 48))(*(void *)(v1 + 216));
}

void sub_1006560C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006560E0(uint64_t **a1, std::string *a2, _DWORD *a3)
{
  *(_OWORD *)std::string __str = 0u;
  long long v9 = 0u;
  snprintf(__str, 0x20uLL, "0x%x", *a3);
  sub_100058DB0(&__p, __str);
  uint64_t v5 = sub_10036627C(a1, a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_100656190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006561B4(uint64_t a1, uint64_t a2)
{
  int v4 = *(char *)(a1 + 1071);
  if (v4 < 0)
  {
    if (!*(void *)(a1 + 1056)) {
      goto LABEL_14;
    }
  }
  else if (!*(unsigned char *)(a1 + 1071))
  {
    goto LABEL_14;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ----------------- BB CORE DUMP ----------------", (uint8_t *)&v9, 2u);
    uint64_t v5 = *(NSObject **)(a1 + 40);
    LOBYTE(v4) = *(unsigned char *)(a1 + 1071);
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = (void *)(a1 + 1048);
    if ((v4 & 0x80) != 0) {
      int v6 = (void *)*v6;
    }
    int v9 = 136315138;
    BOOL v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v9, 0xCu);
    LOBYTE(v4) = *(unsigned char *)(a1 + 1071);
  }
  if ((v4 & 0x80) != 0)
  {
    **(unsigned char **)(a1 + 1048) = 0;
    *(void *)(a1 + 1056) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 1048) = 0;
    *(unsigned char *)(a1 + 1071) = 0;
  }
LABEL_14:
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      xpc_object_t v8 = (void *)a2;
    }
    else {
      xpc_object_t v8 = *(void **)a2;
    }
    int v9 = 136315138;
    BOOL v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I CSI state dump requested: %s", (uint8_t *)&v9, 0xCu);
  }
}

void sub_10065633C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I -----------------------------------------------", v2, 2u);
  }
}

void sub_10065639C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    **(unsigned char **)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 23) = 0;
  }
}

uint64_t sub_1006563C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if (*(char *)(a1 + 999) < 0)
  {
    sub_10004FC84((unsigned char *)a2, *(void **)(a1 + 976), *(void *)(a1 + 984));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 976);
    *(void *)(a2 + 16) = *(void *)(a1 + 992);
  }
  return ATCSMutex::unlock(v4);
}

void sub_100656430(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10065644C(uint64_t a1, void **a2)
{
  uint64_t v4 = *(void *)(a1 + 1032);
  xpc_object_t v8 = xpc_null_create();
  uint64_t v5 = *(NSObject **)(a1 + 1008);
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  int v6 = *a2;
  if (*a2) {
    int v6 = _Block_copy(v6);
  }
  v9[0] = off_1019F5E38;
  v9[1] = a1;
  xpc_object_t v9[2] = v6;
  v9[3] = v9;
  (*(void (**)(uint64_t, void, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v4 + 48))(v4, abm::kKeyCommandGetBasebandFirmwareNonce, &v8, &object, v9);
  sub_1000595E4(v9);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v8);
}

void sub_10065655C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, dispatch_object_t object, xpc_object_t a13, char a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006565AC(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1006565E0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v12 = "getFirmwareNonce";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  _OWORD v8[2] = sub_100656764;
  void v8[3] = &unk_1019F43E0;
  uint64_t v6 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  void v8[4] = a1;
  v8[5] = v6;
  int v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = _Block_copy(v8);
  BOOL v10 = v7;
  sub_10065644C(a1, &v10);
  if (v7) {
    _Block_release(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100656724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100656764(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(const void **)a2;
  size_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  if (v4)
  {
    xpc_object_t v6 = xpc_data_create(v3, v4);
    if (!v6) {
      xpc_object_t v6 = xpc_null_create();
    }
    *(void *)&long long buf = *(void *)(a1 + 40);
    *((void *)&buf + 1) = "kRadioModuleFirmwareNonce";
    sub_100035E70((uint64_t)&buf, &v6, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v6);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "getFirmwareNonce_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N %s: Nonce is not found", (uint8_t *)&buf, 0xCu);
    }
  }
}

void sub_100656860(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100656880(uint64_t a1, void *a2)
{
  size_t v4 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  xpc_object_t v24 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v24 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v24 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v24 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v22 = xpc_int64_create(*(unsigned int *)(a1 + 936));
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  long long v25 = 0uLL;
  uint64_t v26 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v19 = 0;
  int v20 = &v24;
  uint64_t v21 = __p;
  sub_100035E70((uint64_t)&v20, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_object_t v16 = xpc_int64_create(*(unsigned int *)(a1 + 968));
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  *(void *)&long long v25 = &v24;
  *((void *)&v25 + 1) = "AKeyStatus";
  sub_100035E70((uint64_t)&v25, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v8 = *(unsigned char **)(a1 + 944);
  int v9 = *(unsigned char **)(a1 + 952);
  if (v8 != v9 && *(_DWORD *)(a1 + 936) != 2)
  {
    xpc_object_t v14 = xpc_data_create(v8, v9 - v8);
    if (!v14) {
      xpc_object_t v14 = xpc_null_create();
    }
    long long v25 = 0uLL;
    uint64_t v26 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v25;
    uint64_t v19 = v26;
    BOOL v10 = __p;
    if (v26 < 0) {
      BOOL v10 = (void **)__p[0];
    }
    int v20 = &v24;
    uint64_t v21 = v10;
    sub_100035E70((uint64_t)&v20, &v14, &v15);
    xpc_release(v15);
    xpc_object_t v15 = 0;
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v14);
    xpc_object_t v14 = 0;
  }
  xpc_object_t v12 = v24;
  if (v24) {
    xpc_retain(v24);
  }
  else {
    xpc_object_t v12 = xpc_null_create();
  }
  *(void *)&long long v25 = *a2;
  *((void *)&v25 + 1) = "kRadioModuleFirmwareManifestStatus";
  sub_10014E03C((uint64_t)&v25, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v24);
  return ATCSMutex::unlock(v4);
}

void sub_100656B40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (*(char *)(v13 - 33) < 0) {
    operator delete(*(void **)(v13 - 56));
  }
  xpc_release(v12);
  xpc_release(*(xpc_object_t *)(v13 - 64));
  ATCSMutex::unlock(v11);
  _Unwind_Resume(a1);
}

void sub_100656BF4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 1032);
  xpc_object_t v5 = xpc_null_create();
  xpc_object_t v6 = *(NSObject **)(a1 + 1008);
  dispatch_object_t object = v6;
  xpc_object_t v12 = v5;
  if (v6) {
    dispatch_retain(v6);
  }
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  int v9 = operator new(0x20uLL);
  uint64_t v10 = abm::kKeyCommandGetManifest;
  void *v9 = off_1019F5EB8;
  v9[1] = a1;
  xpc_object_t v9[2] = v8;
  v9[3] = v7;
  void v13[3] = v9;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v4 + 48))(v4, v10, &v12, &object, v13);
  sub_1000595E4(v13);
  if (object) {
    dispatch_release(object);
  }
  xpc_release(v12);
}

void sub_100656D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, char a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100656D74(uint64_t a1, void *a2)
{
  uint64_t v4 = (ATCSMutex *)(a1 + 56);
  xpc_object_t v5 = (capabilities::fusing *)ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if (*(void *)(a1 + 792) != *(void *)(a1 + 800)
    && (!capabilities::fusing::supportsCertIDFromPublicKeyHash(v5)
     || *(void *)(a1 + 824) != *(void *)(a1 + 832)))
  {
    xpc_object_t v30 = 0;
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v7 = v6;
    if (v6)
    {
      xpc_object_t v30 = v6;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v30 = v7;
      if (!v7)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_13;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
LABEL_14:
      xpc_release(v7);
      if (*(void *)(a1 + 792) != *(void *)(a1 + 800))
      {
        xpc_object_t v28 = xpc_int64_create(*(unsigned int *)(a1 + 816));
        if (!v28) {
          xpc_object_t v28 = xpc_null_create();
        }
        *(void *)&long long buf = &v30;
        *((void *)&buf + 1) = "ChipID";
        sub_100035E70((uint64_t)&buf, &v28, &v29);
        xpc_release(v29);
        xpc_object_t v29 = 0;
        xpc_release(v28);
        xpc_object_t v28 = 0;
        xpc_object_t v26 = xpc_data_create(*(const void **)(a1 + 792), *(void *)(a1 + 800) - *(void *)(a1 + 792));
        if (!v26) {
          xpc_object_t v26 = xpc_null_create();
        }
        *(void *)&long long buf = &v30;
        *((void *)&buf + 1) = "ChipSerialNo";
        sub_100035E70((uint64_t)&buf, &v26, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v26);
        xpc_object_t v26 = 0;
      }
      if (*(void *)(a1 + 824) != *(void *)(a1 + 832)
        && capabilities::fusing::supportsCertIDFromPublicKeyHash(v10))
      {
        xpc_object_t v24 = xpc_data_create(*(const void **)(a1 + 824), *(void *)(a1 + 832) - *(void *)(a1 + 824));
        if (!v24) {
          xpc_object_t v24 = xpc_null_create();
        }
        *(void *)&long long buf = &v30;
        *((void *)&buf + 1) = "PkHash";
        sub_100035E70((uint64_t)&buf, &v24, &v25);
        xpc_release(v25);
        xpc_object_t v25 = 0;
        xpc_release(v24);
        xpc_object_t v24 = 0;
        int v12 = capabilities::fusing::inferFusingStateFromCertID((capabilities::fusing *)*(unsigned int *)(a1 + 820), v11);
        if ((v12 & 0xFFFFFFFE) == 2)
        {
          xpc_object_t v22 = xpc_int64_create(*(unsigned int *)(a1 + 820));
          if (!v22) {
            xpc_object_t v22 = xpc_null_create();
          }
          *(void *)&long long buf = &v30;
          *((void *)&buf + 1) = "CertID";
          sub_100035E70((uint64_t)&buf, &v22, &v23);
          xpc_release(v23);
          xpc_object_t v23 = 0;
          xpc_release(v22);
          xpc_object_t v22 = 0;
        }
        xpc_object_t v20 = xpc_int64_create(v12);
        if (!v20) {
          xpc_object_t v20 = xpc_null_create();
        }
        *(void *)&long long buf = &v30;
        *((void *)&buf + 1) = "FusingStatus";
        sub_100035E70((uint64_t)&buf, &v20, &v21);
        xpc_release(v21);
        xpc_object_t v21 = 0;
        xpc_release(v20);
        xpc_object_t v20 = 0;
      }
      uint64_t v13 = *(unsigned char **)(a1 + 848);
      xpc_object_t v14 = *(unsigned char **)(a1 + 856);
      if (v13 != v14)
      {
        xpc_object_t v18 = xpc_data_create(v13, v14 - v13);
        if (!v18) {
          xpc_object_t v18 = xpc_null_create();
        }
        *(void *)&long long buf = &v30;
        *((void *)&buf + 1) = "CertificationPublicKey";
        sub_100035E70((uint64_t)&buf, &v18, &v19);
        xpc_release(v19);
        xpc_object_t v19 = 0;
        xpc_release(v18);
        xpc_object_t v18 = 0;
      }
      xpc_object_t v16 = v30;
      if (v30) {
        xpc_retain(v30);
      }
      else {
        xpc_object_t v16 = xpc_null_create();
      }
      *(void *)&long long buf = *a2;
      *((void *)&buf + 1) = "kRadioModuleFirmwareSecurityInfo";
      sub_10014E03C((uint64_t)&buf, &v16, &v17);
      xpc_release(v17);
      xpc_object_t v17 = 0;
      xpc_release(v16);
      xpc_object_t v16 = 0;
      xpc_release(v30);
      return ATCSMutex::unlock(v4);
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_13:
    xpc_object_t v30 = v9;
    goto LABEL_14;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "getFirmwareSecurityInfo";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: Information not yet retrieved", (uint8_t *)&buf, 0xCu);
  }
  return ATCSMutex::unlock(v4);
}

void sub_100657174(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100657238(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

uint64_t sub_1006572D4(uint64_t a1)
{
  uint64_t v2 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  BOOL v3 = dispatch_group_create();
  uint64_t v4 = v3;
  if (*(void *)(a1 + 792) == *(void *)(a1 + 800))
  {
    unsigned int v11 = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    sub_10064D8C8((void *)a1, &v11);
    if (!v4)
    {
      if (*(void *)(a1 + 824) != *(void *)(a1 + 832))
      {
        if (*(_DWORD *)(a1 + 936) != 2) {
          goto LABEL_22;
        }
        xpc_object_t v9 = 0;
        goto LABEL_19;
      }
      uint64_t v10 = 0;
      goto LABEL_13;
    }
    dispatch_release(v4);
  }
  if (*(void *)(a1 + 824) != *(void *)(a1 + 832)) {
    goto LABEL_16;
  }
  uint64_t v10 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    char v5 = 0;
    goto LABEL_14;
  }
LABEL_13:
  char v5 = 1;
LABEL_14:
  sub_10064D6E4((void *)a1, &v10);
  if ((v5 & 1) == 0) {
    dispatch_release(v4);
  }
LABEL_16:
  if (*(_DWORD *)(a1 + 936) != 2) {
    goto LABEL_22;
  }
  xpc_object_t v9 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    char v6 = 0;
    goto LABEL_20;
  }
LABEL_19:
  char v6 = 1;
LABEL_20:
  sub_10064DAAC((void *)a1, &v9);
  if ((v6 & 1) == 0) {
    dispatch_release(v4);
  }
LABEL_22:
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _OWORD v8[2] = sub_1006574B4;
  void v8[3] = &unk_1019F4430;
  void v8[4] = a1;
  dispatch_group_notify(v4, *(dispatch_queue_t *)(a1 + 1008), v8);
  if (v4) {
    dispatch_release(v4);
  }
  return ATCSMutex::unlock(v2);
}

void sub_100657468(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    dispatch_release(v2);
  }
  if (v2) {
    dispatch_release(v2);
  }
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1006574B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100657570;
  uint64_t v3[3] = &unk_1019F4410;
  void v3[4] = v1;
  uint64_t v2 = _Block_copy(v3);
  uint64_t v4 = v2;
  sub_10065644C(v1, &v4);
  if (v2) {
    _Block_release(v2);
  }
}

void sub_100657550(_Unwind_Exception *exception_object)
{
  if (v1) {
    _Block_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100657570(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a2 + 8) == *(void *)a2)
  {
    xpc_object_t v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Nonce not available", buf, 2u);
    }
  }
  else
  {
    for (uint64_t i = *(void **)(v2 + 728); i != (void *)(v2 + 720); uint64_t i = (void *)i[1])
    {
      char v6 = (xpc_object_t *)i[2];
      char v5 = (std::__shared_weak_count *)i[3];
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v44 = 0;
      xpc_object_t v44 = xpc_null_create();
      if (xpc_dictionary_get_value(*v6, "kRadioModuleFirmwarePreflightInfo"))
      {
        *(void *)long long buf = v6;
        *(void *)&uint8_t buf[8] = "kRadioModuleFirmwarePreflightInfo";
        sub_10000CB28((uint64_t)buf, object);
        xpc_object_t v7 = object[0];
        object[0] = xpc_null_create();
        xpc_object_t v8 = v44;
        xpc_object_t v44 = v7;
        xpc_release(v8);
        xpc_release(object[0]);
      }
      else
      {
        xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
        if (v9 || (xpc_object_t v9 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v9);
            xpc_object_t v10 = v9;
          }
          else
          {
            xpc_object_t v10 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
        }
        xpc_release(v9);
        xpc_object_t v11 = xpc_null_create();
        xpc_object_t v12 = v44;
        xpc_object_t v44 = v10;
        xpc_release(v12);
        xpc_release(v11);
      }
      xpc_object_t v42 = xpc_data_create(*(const void **)a2, *(void *)(a2 + 8) - *(void *)a2);
      if (!v42) {
        xpc_object_t v42 = xpc_null_create();
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = "Nonce";
      sub_100035E70((uint64_t)buf, &v42, &v43);
      xpc_release(v43);
      xpc_object_t v43 = 0;
      xpc_release(v42);
      xpc_object_t v42 = 0;
      xpc_object_t v40 = xpc_int64_create(*(unsigned int *)(v2 + 816));
      if (!v40) {
        xpc_object_t v40 = xpc_null_create();
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = "ChipID";
      sub_100035E70((uint64_t)buf, &v40, &v41);
      xpc_release(v41);
      xpc_object_t v41 = 0;
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_object_t v38 = xpc_data_create(*(const void **)(v2 + 792), *(void *)(v2 + 800) - *(void *)(v2 + 792));
      if (!v38) {
        xpc_object_t v38 = xpc_null_create();
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = "ChipSerialNo";
      sub_100035E70((uint64_t)buf, &v38, &v39);
      xpc_release(v39);
      xpc_object_t v39 = 0;
      xpc_release(v38);
      xpc_object_t v38 = 0;
      if (TelephonyRadiosGetRadioVendor() == 1)
      {
        xpc_object_t v36 = xpc_int64_create(3);
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "VendorID";
        sub_100035E70((uint64_t)buf, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
      }
      else
      {
        xpc_object_t v34 = xpc_int64_create(2);
        if (!v34) {
          xpc_object_t v34 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "VendorID";
        sub_100035E70((uint64_t)buf, &v34, &v35);
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_release(v34);
        xpc_object_t v34 = 0;
      }
      xpc_object_t v32 = xpc_data_create(*(const void **)(v2 + 824), *(void *)(v2 + 832) - *(void *)(v2 + 824));
      if (!v32) {
        xpc_object_t v32 = xpc_null_create();
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = "PkHash";
      sub_100035E70((uint64_t)buf, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      int v14 = capabilities::fusing::inferFusingStateFromCertID((capabilities::fusing *)*(unsigned int *)(v2 + 820), v13);
      if ((v14 & 0xFFFFFFFE) == 2)
      {
        xpc_object_t v30 = xpc_int64_create(*(unsigned int *)(v2 + 820));
        if (!v30) {
          xpc_object_t v30 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "CertID";
        sub_100035E70((uint64_t)buf, &v30, &v31);
        xpc_release(v31);
        xpc_object_t v31 = 0;
        xpc_release(v30);
        xpc_object_t v30 = 0;
      }
      xpc_object_t v28 = xpc_int64_create(v14);
      if (!v28) {
        xpc_object_t v28 = xpc_null_create();
      }
      *(void *)long long buf = &v44;
      *(void *)&uint8_t buf[8] = "FusingStatus";
      sub_100035E70((uint64_t)buf, &v28, &v29);
      xpc_release(v29);
      xpc_object_t v29 = 0;
      xpc_release(v28);
      xpc_object_t v28 = 0;
      xpc_object_t v26 = xpc_int64_create(*(unsigned int *)(v2 + 936));
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v46 = 0;
      ctu::cf::assign();
      *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
      uint64_t v23 = v46;
      xpc_object_t v24 = &v44;
      xpc_object_t v15 = *(xpc_object_t **)buf;
      if (v46 >= 0) {
        xpc_object_t v15 = object;
      }
      xpc_object_t v25 = v15;
      sub_100035E70((uint64_t)&v24, &v26, &v27);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      if (SHIBYTE(v23) < 0) {
        operator delete(object[0]);
      }
      xpc_release(v26);
      xpc_object_t v26 = 0;
      if (*(_DWORD *)(v2 + 936) <= 1u)
      {
        xpc_object_t v20 = xpc_data_create(*(const void **)(v2 + 944), *(void *)(v2 + 952) - *(void *)(v2 + 944));
        if (!v20) {
          xpc_object_t v20 = xpc_null_create();
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v46 = 0;
        ctu::cf::assign();
        *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
        uint64_t v23 = v46;
        xpc_object_t v24 = &v44;
        xpc_object_t v16 = *(xpc_object_t **)buf;
        if (v46 >= 0) {
          xpc_object_t v16 = object;
        }
        xpc_object_t v25 = v16;
        sub_100035E70((uint64_t)&v24, &v20, &v21);
        xpc_release(v21);
        xpc_object_t v21 = 0;
        if (SHIBYTE(v23) < 0) {
          operator delete(object[0]);
        }
        xpc_release(v20);
        xpc_object_t v20 = 0;
      }
      xpc_object_t v18 = v44;
      if (v44) {
        xpc_retain(v44);
      }
      else {
        xpc_object_t v18 = xpc_null_create();
      }
      *(void *)long long buf = v6;
      *(void *)&uint8_t buf[8] = "kRadioModuleFirmwarePreflightInfo";
      sub_10014E03C((uint64_t)buf, &v18, &v19);
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_release(v18);
      xpc_object_t v18 = 0;
      xpc_release(v44);
      if (v5) {
        sub_10004D2C8(v5);
      }
    }
    sub_10011A838((uint64_t *)(v2 + 720));
    sub_100657CB4((void *)v2);
  }
}

void sub_100657BA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18)
{
  if (*(char *)(v19 - 89) < 0) {
    operator delete(*(void **)(v19 - 112));
  }
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v19 - 120));
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_100657CB4(void *a1)
{
  if (!a1[89] && !a1[92])
  {
    uint64_t v1 = a1 + 85;
    uint64_t v2 = (std::__shared_weak_count *)a1[86];
    _OWORD *v1 = 0u;
    if (v2) {
      sub_10004D2C8(v2);
    }
  }
}

void sub_100657CE0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v13 = 0x1F404000100;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Forcing fast dormancy after %d milliseconds", (uint8_t *)&v13, 8u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v4 = ServiceMap;
  char v5 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    char v6 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      char v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = (unint64_t)v5;
  xpc_object_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v13);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_11:
    std::mutex::unlock(v4);
    xpc_object_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v11 = v9[3];
  xpc_object_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 500);
LABEL_13:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100657E64(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100657E98(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v4 = ServiceMap;
  char v5 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    char v6 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      char v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v5;
  xpc_object_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v13);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    xpc_object_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  xpc_object_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 40))(v11, a2);
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100657FA4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100657FC0(uint64_t a1, uint64_t a2, void *a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v7 = ServiceMap;
  unsigned int v8 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    xpc_object_t v9 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unsigned int v8 = (const char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v18 = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v18);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    unint64_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  unint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14) {
    goto LABEL_15;
  }
LABEL_10:
  if (!*(unsigned char *)(a1 + 521)) {
    goto LABEL_15;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v17 = *(void *)(a2 + 16);
  }
  (*(void (**)(uint64_t, void **, void))(*(void *)v14 + 48))(v14, __p, *a3);
  if ((SHIBYTE(v17) & 0x80000000) == 0)
  {
LABEL_15:
    if (v15) {
      return;
    }
    goto LABEL_16;
  }
  operator delete(__p[0]);
  if (v15) {
    return;
  }
LABEL_16:
  sub_10004D2C8(v13);
}

void sub_100658128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10065815C(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  char v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v32 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v32);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    unsigned int v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_18;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_18;
  }
LABEL_10:
  if (!*(unsigned char *)(a1 + 520))
  {
    char v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    LOWORD(v32) = 0;
    xpc_object_t v16 = "#I dormancy support off";
LABEL_16:
    uint64_t v17 = v15;
    uint32_t v18 = 2;
    goto LABEL_17;
  }
  if (*(unsigned char *)(a1 + 521))
  {
    sub_100068A94(&v32);
    (*(void (**)(unint64_t))(*(void *)v32 + 368))(v32);
    uint64_t v14 = v33;
    if (!v33) {
      goto LABEL_18;
    }
    goto LABEL_13;
  }
  int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 72))(v12);
  if (v19 < 1)
  {
    xpc_object_t v30 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    LODWORD(v32) = 67109120;
    HIDWORD(v32) = v19;
    xpc_object_t v16 = "#I Data not active. Not requesting fast dormant: dataMode=0x%x";
    uint64_t v17 = v30;
    uint32_t v18 = 8;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v32, v18);
    goto LABEL_18;
  }
  if (!*(_DWORD *)(a1 + 516))
  {
    char v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    LOWORD(v32) = 0;
    xpc_object_t v16 = "#I Too soon from last request. Not requesting fast dormant";
    goto LABEL_16;
  }
  if (*(_DWORD *)(a1 + 512)) {
    CSISystemElapsedTime();
  }
  xpc_object_t v20 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  xpc_object_t v21 = v20;
  xpc_object_t v22 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    uint64_t v23 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      xpc_object_t v22 = (const char *)v24;
      unsigned int v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(v20);
  unint64_t v32 = (unint64_t)v22;
  xpc_object_t v26 = sub_10004D37C(&v21[1].__m_.__sig, &v32);
  if (v26)
  {
    uint64_t v28 = v26[3];
    xpc_object_t v27 = (std::__shared_weak_count *)v26[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v21);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      char v29 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
  std::mutex::unlock(v21);
  xpc_object_t v27 = 0;
  char v29 = 1;
LABEL_37:
  if (v28)
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v28 + 16))(v28, a2))
    {
      *(_DWORD *)(a1 + 512) = CSISystemElapsedTime();
    }
    else
    {
      xpc_object_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32) = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I No active PDP connections", (uint8_t *)&v32, 2u);
      }
    }
  }
  if ((v29 & 1) == 0)
  {
    uint64_t v14 = v27;
LABEL_13:
    sub_10004D2C8(v14);
  }
LABEL_18:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1006584EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100658548(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v21) = 67109120;
    HIDWORD(v21) = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I changing fast dormancy timeouts to %d", (uint8_t *)&v21, 8u);
    unint64_t v6 = *(NSObject **)(a1 + 40);
  }
  *(_DWORD *)(a1 + 516) = a3;
  int v7 = *(unsigned __int8 *)(a1 + 520);
  BOOL v8 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v8)
    {
      LODWORD(v21) = 67109376;
      HIDWORD(v21) = a3;
      __int16 v22 = 1024;
      int v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I setting fast dormancy timeouts to %d, (ignoring inhibit timer %d)", (uint8_t *)&v21, 0xEu);
    }
    uint64_t v9 = *(void *)(a1 + 216);
    if (a3)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 560))(a1);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 64))(v9, a3, v10);
    }
    else
    {
      (*(void (**)(void, void, void))(*(void *)v9 + 64))(*(void *)(a1 + 216), 0, 0);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
    char v12 = ServiceMap;
    char v13 = "N8dormancy15DormancyServiceE";
    if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
    {
      uint64_t v14 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        char v13 = (const char *)v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    xpc_object_t v21 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v21);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint32_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        if (!v19)
        {
LABEL_21:
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          return;
        }
LABEL_20:
        (*(void (**)(uint64_t, BOOL))(*(void *)v19 + 24))(v19, *(_DWORD *)(a1 + 516) != 0);
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint32_t v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (v8)
  {
    LOWORD(v21) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I dormancy support off in radio", (uint8_t *)&v21, 2u);
  }
}

void sub_100658804(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100658834(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  int v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = v7[3];
    BOOL v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  BOOL v8 = 0;
  char v10 = 1;
LABEL_9:
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 504))(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return v11;
}

void sub_100658944(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100658960(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, const char *))(*(void *)a1 + 256))(a1, "data inactivity from MUX");
}

uint64_t sub_100658994(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 8) + 256))();
}

uint64_t sub_1006589C8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1000);
}

void sub_1006589D0(uint64_t a1)
{
  char v1 = (unsigned __int8 *)(a1 + 1000);
  *(unsigned char *)(a1 + 100sub_10010E764((uint64_t)&a9, 0) = 1;
  char v2 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&__p, "C2KRadioModule::kCellularDataUsed");
  sub_1002264FC(v2, &__p, v1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100658A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100658A54(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v114 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  bzero(__dst, 0x400uLL);
  uint64_t v124 = 0;
  CFTypeRef v125 = 0;
  sub_100224000(*(Registry **)(a1 + 744), &v124);
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  unint64_t v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&buf.var0 = v14;
  uint32_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&buf);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_9:
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_19;
    }
    goto LABEL_10;
  }
  uint64_t v20 = v18[3];
  uint64_t v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (!v20) {
    goto LABEL_19;
  }
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, __CFString *, void, void))(*(void *)v20 + 96))(&v122, v20, a2, 1, sms::Model::sSMSCarrierBundleDict, 0, 0);
  sub_10004EFE4(&object, &v122);
  *(void *)&buf.var0 = theDict;
  CFDictionaryRef theDict = (CFDictionaryRef)object;
  xpc_object_t object = 0;
  sub_100057D78((const void **)&buf);
  sub_100057D78((const void **)&object);
  sub_1000577C4(&v122);
  if (theDict) {
    __int16 v22 = sub_100080778;
  }
  else {
    __int16 v22 = 0;
  }
  if (!v22)
  {
LABEL_19:
    BOOL v27 = 0;
    if (v21) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"AllowMMICommandSMSC");
  uint64_t v24 = Value;
  LOBYTE(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
  if (Value)
  {
    CFTypeID v25 = CFGetTypeID(Value);
    if (v25 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&buf, v24, v26);
    }
  }
  BOOL v27 = LOBYTE(buf.var0) != 0;
  if ((v21 & 1) == 0) {
LABEL_20:
  }
    sub_10004D2C8(v19);
LABEL_21:
  uint64_t v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    char v29 = "false";
    if (v27) {
      char v29 = "true";
    }
    buf.var0 = 136315138;
    *(void *)&buf.var1 = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I SMSC K00L Command allowed: %s", (uint8_t *)&buf, 0xCu);
  }
  LOBYTE(v122) = 0;
  xpc_object_t object = (xpc_object_t)a1;
  int v116 = (std::__shared_weak_count *)&v122;
  xpc_object_t v30 = *(NSObject **)(a1 + 48);
  *(void *)&buf.var0 = _NSConcreteStackBlock;
  buf.var2.__r_.__value_.var0.var1.__data_ = (char *)0x40000000;
  buf.var2.__r_.__value_.var0.var1.__size_ = (unint64_t)sub_10066B950;
  *((void *)&buf.var2.__r_.__value_.var0.var1 + 2) = &unk_1019F6628;
  *(void *)&buf.var2.__r_.var0 = &object;
  dispatch_sync(v30, &buf);
  if (!(_BYTE)v122
    || (*(_DWORD *)(a3 + a5) == 875705395 ? (BOOL v31 = *(unsigned __int16 *)(a3 + a5 + 4) == 35) : (BOOL v31 = 0), !v31))
  {
    uint64_t v32 = a3 + a5;
    if (*(_DWORD *)(a3 + a5) != 875967029 || *(_WORD *)(a3 + a5 + 4) != 35)
    {
      if (!v27 || (*(_DWORD *)v32 == 842479159 ? (BOOL v34 = *(unsigned __int16 *)(v32 + 4) == 35) : (BOOL v34 = 0), !v34))
      {
        if (*(_DWORD *)v32 != 926102834 || *(_WORD *)(v32 + 4) != 9008)
        {
          if (*(_DWORD *)v32 != 926102834 || *(_WORD *)(v32 + 4) != 9009)
          {
            xpc_object_t v37 = strrchr((char *)(a3 + a5), 35);
            if (!v37)
            {
              xpc_object_t v41 = *(NSObject **)(a1 + 40);
              uint64_t v42 = 0;
              if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_203;
              }
              LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
              xpc_object_t v43 = "#I Could not find a # in the string";
              goto LABEL_201;
            }
            xpc_object_t v38 = v37;
            if (*(_WORD *)v32 != 13880 || *(unsigned char *)(v32 + 2) != 42)
            {
              if (!v27 || (*(_DWORD *)v32 == 842479159 ? (BOOL v40 = *(unsigned char *)(v32 + 4) == 42) : (BOOL v40 = 0), !v40))
              {
                xpc_object_t v41 = *(NSObject **)(a1 + 40);
                uint64_t v42 = 0;
                if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_203;
                }
                LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
                xpc_object_t v43 = "#I Unhandled code";
LABEL_201:
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v43, (uint8_t *)&buf, 2u);
                goto LABEL_202;
              }
              uint64_t v112 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
                _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I Setting Service Center Address", (uint8_t *)&buf, 2u);
              }
              if (a4 && a4 != 3)
              {
                xpc_object_t v41 = *(NSObject **)(a1 + 40);
                uint64_t v42 = 0;
                if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_203;
                }
                LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
                xpc_object_t v43 = "#I Not activation or registration";
                goto LABEL_201;
              }
              sub_10007FB40();
              uint64_t v132 = 0;
              long long v130 = 0u;
              long long v131 = 0u;
              *(_OWORD *)unint64_t v128 = 0u;
              *(_OWORD *)unsigned int v129 = 0u;
              long long v127 = 0u;
              memset(&buf, 0, sizeof(buf));
              sub_1000D95C8(&object, (void *)(a5 + a3 + 5), (size_t)&v38[-a5 - 5 - a3]);
              CSIPhoneNumber::CSIPhoneNumber();
              if (v117 < 0) {
                operator delete(object);
              }
              *a6 |= 4u;
              sub_100659D2C(*(Registry **)(a1 + 744), &object);
              (*(void (**)(xpc_object_t, uint64_t, CSIPhoneNumber *))(*(void *)object + 248))(object, a2, &buf);
              if (v116) {
                sub_10004D2C8(v116);
              }
              sub_100087E24((uint64_t)&buf);
LABEL_197:
              uint64_t v42 = 1;
              goto LABEL_203;
            }
            xpc_object_t v88 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
              _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I Setting Voice mail number", (uint8_t *)&buf, 2u);
            }
            if (a4 && a4 != 3)
            {
              xpc_object_t v41 = *(NSObject **)(a1 + 40);
              uint64_t v42 = 0;
              if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_203;
              }
              LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
              xpc_object_t v43 = "#I Not activation or registration";
              goto LABEL_201;
            }
            sub_10007FB40();
            uint64_t v132 = 0;
            long long v130 = 0u;
            long long v131 = 0u;
            *(_OWORD *)unint64_t v128 = 0u;
            *(_OWORD *)unsigned int v129 = 0u;
            long long v127 = 0u;
            memset(&buf, 0, sizeof(buf));
            sub_1000D95C8(&object, (void *)(a5 + a3 + 3), (size_t)&v38[-a5 - 3 - a3]);
            CSIPhoneNumber::CSIPhoneNumber();
            if (v117 < 0) {
              operator delete(object);
            }
            uint64_t v89 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
            unsigned int v90 = v89;
            if (v91 < 0)
            {
              int v92 = (unsigned __int8 *)(v91 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v93 = 5381;
              do
              {
                uint64_t v91 = v93;
                unsigned int v94 = *v92++;
                uint64_t v93 = (33 * v93) ^ v94;
              }
              while (v94);
            }
            std::mutex::lock(v89);
            xpc_object_t object = (xpc_object_t)v91;
            unint64_t v95 = sub_10004D37C(&v90[1].__m_.__sig, (unint64_t *)&object);
            if (v95)
            {
              uint64_t v97 = v95[3];
              uint64_t v96 = (std::__shared_weak_count *)v95[4];
              if (v96)
              {
                atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v90);
                atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v96);
                char v98 = 0;
                goto LABEL_188;
              }
            }
            else
            {
              uint64_t v97 = 0;
            }
            std::mutex::unlock(v90);
            uint64_t v96 = 0;
            char v98 = 1;
LABEL_188:
            (*(void (**)(uint64_t, uint64_t, CSIPhoneNumber *))(*(void *)v97 + 296))(v97, a2, &buf);
            if ((v98 & 1) == 0) {
              sub_10004D2C8(v96);
            }
            sub_10007FBD8();
            if (SHIBYTE(v130) < 0) {
              operator delete(v129[1]);
            }
            if (SHIBYTE(v129[0]) < 0) {
              operator delete(v128[0]);
            }
            if (SBYTE7(v127) < 0) {
              operator delete(*(void **)&buf.var2.__r_.var0);
            }
            if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0)
            {
              CFDataRef data = buf.var2.__r_.__value_.var0.var1.__data_;
LABEL_62:
              operator delete(data);
            }
            goto LABEL_197;
          }
          __int16 v69 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I Enabling Test Alerts", (uint8_t *)&buf, 2u);
          }
          if (a4 && a4 != 3)
          {
            sub_10007FBD8();
            xpc_object_t v41 = *(NSObject **)(a1 + 40);
            uint64_t v42 = 0;
            if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_203;
            }
            LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
            xpc_object_t v43 = "#I Not activation or registration";
            goto LABEL_201;
          }
          sub_10007FB40();
          unsigned int v70 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
          __int16 v71 = v70;
          if (v72 < 0)
          {
            __int16 v73 = (unsigned __int8 *)(v72 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v74 = 5381;
            do
            {
              uint64_t v72 = v74;
              unsigned int v75 = *v73++;
              uint64_t v74 = (33 * v74) ^ v75;
            }
            while (v75);
          }
          std::mutex::lock(v70);
          *(void *)&buf.var0 = v72;
          int v76 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)&buf);
          if (v76)
          {
            uint64_t v77 = v76[3];
            uint64_t v55 = (std::__shared_weak_count *)v76[4];
            if (v55)
            {
              atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v71);
              atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v55);
              char v57 = 0;
LABEL_143:
              if (v77)
              {
                (*(void (**)(uint64_t, uint64_t))(*(void *)v77 + 432))(v77, 1);
                strlcpy(__dst, "Test alerts allowed", 0x400uLL);
                sub_100058DB0(&buf, __dst);
                sub_10007FFB4(1, 0, (uint64_t)&buf, a2);
LABEL_145:
                if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
                {
                  operator delete(*(void **)&buf.var0);
                  if (v57)
                  {
LABEL_116:
                    sub_10007FBD8();
                    goto LABEL_197;
                  }
LABEL_150:
                  sub_10004D2C8(v55);
                  goto LABEL_116;
                }
LABEL_149:
                if (v57) {
                  goto LABEL_116;
                }
                goto LABEL_150;
              }
              xpc_object_t v58 = *(NSObject **)(a1 + 40);
              if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
                goto LABEL_149;
              }
              LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
LABEL_207:
              _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Failed to get SMS interface", (uint8_t *)&buf, 2u);
              if (v57) {
                goto LABEL_116;
              }
              goto LABEL_150;
            }
          }
          else
          {
            uint64_t v77 = 0;
          }
          std::mutex::unlock(v71);
          uint64_t v55 = 0;
          char v57 = 1;
          goto LABEL_143;
        }
        int v47 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Disabling Test Alerts", (uint8_t *)&buf, 2u);
        }
        if (a4 && a4 != 3)
        {
          sub_10007FBD8();
          xpc_object_t v41 = *(NSObject **)(a1 + 40);
          uint64_t v42 = 0;
          if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_203;
          }
          LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
          xpc_object_t v43 = "#I Not activation or registration";
          goto LABEL_201;
        }
        sub_10007FB40();
        xpc_object_t v48 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
        uint64_t v49 = v48;
        if (v50 < 0)
        {
          uint64_t v51 = (unsigned __int8 *)(v50 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v52 = 5381;
          do
          {
            uint64_t v50 = v52;
            unsigned int v53 = *v51++;
            uint64_t v52 = (33 * v52) ^ v53;
          }
          while (v53);
        }
        std::mutex::lock(v48);
        *(void *)&buf.var0 = v50;
        uint64_t v54 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)&buf);
        if (v54)
        {
          uint64_t v56 = v54[3];
          uint64_t v55 = (std::__shared_weak_count *)v54[4];
          if (v55)
          {
            atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v49);
            atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v55);
            char v57 = 0;
            if (!v56)
            {
LABEL_78:
              xpc_object_t v58 = *(NSObject **)(a1 + 40);
              if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
                goto LABEL_149;
              }
              LOWORD(buf.varsub_10010E764((uint64_t)&a9, 0) = 0;
              goto LABEL_207;
            }
LABEL_120:
            (*(void (**)(uint64_t, void))(*(void *)v56 + 432))(v56, 0);
            strlcpy(__dst, "Test alerts not allowed", 0x400uLL);
            sub_100058DB0(&buf, __dst);
            sub_10007FFB4(1, 0, (uint64_t)&buf, a2);
            goto LABEL_145;
          }
        }
        else
        {
          uint64_t v56 = 0;
        }
        std::mutex::unlock(v49);
        uint64_t v55 = 0;
        char v57 = 1;
        if (!v56) {
          goto LABEL_78;
        }
        goto LABEL_120;
      }
      if (a4 != 4)
      {
        if (a4 != 2) {
          goto LABEL_197;
        }
        sub_10007FB40();
        *a6 |= 4u;
        uint64_t v78 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
        std::string v79 = v78;
        if (v80 < 0)
        {
          CFBooleanRef v81 = (unsigned __int8 *)(v80 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v82 = 5381;
          do
          {
            uint64_t v80 = v82;
            unsigned int v83 = *v81++;
            uint64_t v82 = (33 * v82) ^ v83;
          }
          while (v83);
        }
        std::mutex::lock(v78);
        *(void *)&buf.var0 = v80;
        std::string v84 = sub_10004D37C(&v79[1].__m_.__sig, (unint64_t *)&buf);
        if (v84)
        {
          uint64_t v86 = v84[3];
          std::string v85 = (std::__shared_weak_count *)v84[4];
          if (v85)
          {
            atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v79);
            atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v85);
            char v87 = 0;
LABEL_162:
            (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 240))(v86, a2);
            if (v87) {
              goto LABEL_197;
            }
            long long v111 = v85;
LABEL_176:
            sub_10004D2C8(v111);
            goto LABEL_197;
          }
        }
        else
        {
          uint64_t v86 = 0;
        }
        std::mutex::unlock(v79);
        std::string v85 = 0;
        char v87 = 1;
        goto LABEL_162;
      }
      sub_10007FB40();
      *a6 |= 4u;
      int v99 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
      uint64_t v100 = v99;
      if (v101 < 0)
      {
        uint64_t v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v103 = 5381;
        do
        {
          uint64_t v101 = v103;
          unsigned int v104 = *v102++;
          uint64_t v103 = (33 * v103) ^ v104;
        }
        while (v104);
      }
      std::mutex::lock(v99);
      *(void *)&buf.var0 = v101;
      BOOL v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)&buf);
      if (v105)
      {
        uint64_t v107 = v105[3];
        uint64_t v106 = (std::__shared_weak_count *)v105[4];
        if (v106)
        {
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v100);
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v106);
          char v108 = 0;
LABEL_166:
          CSIPhoneNumber::CSIPhoneNumber(&buf, "");
          (*(void (**)(uint64_t, uint64_t, CSIPhoneNumber *))(*(void *)v107 + 248))(v107, a2, &buf);
          if (SHIBYTE(v130) < 0) {
            operator delete(v129[1]);
          }
          if (SHIBYTE(v129[0]) < 0) {
            operator delete(v128[0]);
          }
          if (SBYTE7(v127) < 0) {
            operator delete(*(void **)&buf.var2.__r_.var0);
          }
          if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
            operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
          }
          if (v108) {
            goto LABEL_197;
          }
          long long v111 = v106;
          goto LABEL_176;
        }
      }
      else
      {
        uint64_t v107 = 0;
      }
      std::mutex::unlock(v100);
      uint64_t v106 = 0;
      char v108 = 1;
      goto LABEL_166;
    }
    sub_10007FB40();
    switch(a4)
    {
      case 0u:
      case 3u:
        *a6 |= 8u;
        strlcpy(__dst, "Please enter the ISO 639-1 language code", 0x400uLL);
        sub_100058DB0(&buf, __dst);
        sub_10007FFB4(1, 1, (uint64_t)&buf, a2);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
        {
          CFDataRef data = *(char **)&buf.var0;
          goto LABEL_62;
        }
        goto LABEL_197;
      case 1u:
      case 4u:
        uint64_t v59 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
        uint64_t v60 = v59;
        if (v61 < 0)
        {
          uint64_t v62 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v63 = 5381;
          do
          {
            uint64_t v61 = v63;
            unsigned int v64 = *v62++;
            uint64_t v63 = (33 * v63) ^ v64;
          }
          while (v64);
        }
        std::mutex::lock(v59);
        *(void *)&buf.var0 = v61;
        uint64_t v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)&buf);
        if (v65)
        {
          uint64_t v67 = v65[3];
          uint64_t v66 = (std::__shared_weak_count *)v65[4];
          if (v66)
          {
            atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v60);
            atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v66);
            char v68 = 0;
LABEL_110:
            sub_100058DB0(__p, "en");
            (*(void (**)(uint64_t, void **))(*(void *)v67 + 120))(v67, __p);
            if (v119 < 0) {
              operator delete(__p[0]);
            }
            if ((v68 & 1) == 0) {
              sub_10004D2C8(v66);
            }
            goto LABEL_114;
          }
        }
        else
        {
          uint64_t v67 = 0;
        }
        std::mutex::unlock(v60);
        uint64_t v66 = 0;
        char v68 = 1;
        goto LABEL_110;
      default:
LABEL_114:
        sub_100058DB0(&buf, __dst);
        sub_10007FFB4(1, 0, (uint64_t)&buf, a2);
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
          operator delete(*(void **)&buf.var0);
        }
        goto LABEL_116;
    }
  }
  if (a4 <= 1)
  {
    sub_10007FB40();
    xpc_object_t object = 0;
    xpc_object_t object = xpc_null_create();
    xpc_object_t v45 = xpc_dictionary_create(0, 0, 0);
    if (v45 || (xpc_object_t v45 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v45) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v45);
        xpc_object_t v46 = v45;
      }
      else
      {
        xpc_object_t v46 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v46 = xpc_null_create();
      xpc_object_t v45 = 0;
    }
    xpc_release(v45);
    xpc_object_t v109 = xpc_null_create();
    xpc_object_t v110 = object;
    xpc_object_t object = v46;
    xpc_release(v110);
    xpc_release(v109);
    xpc_object_t v120 = xpc_BOOL_create(a4 == 0);
    if (!v120) {
      xpc_object_t v120 = xpc_null_create();
    }
    *(void *)&buf.var0 = &object;
    buf.var2.__r_.__value_.var0.var1.__data_ = "kCTRadioUseLoggingProfileKey";
    sub_100035E70((uint64_t)&buf, &v120, &v121);
    xpc_release(v121);
    xpc_object_t v121 = 0;
    xpc_release(v120);
    xpc_object_t v120 = 0;
    sub_100068A94(&buf);
    (*(void (**)(void, xpc_object_t *))(**(void **)&buf.var0 + 416))(*(void *)&buf.var0, &object);
    if (buf.var2.__r_.__value_.var0.var1.__data_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
    }
    sub_10007FBD8();
    xpc_release(object);
    goto LABEL_197;
  }
LABEL_202:
  uint64_t v42 = 0;
LABEL_203:
  sub_100057D78((const void **)&theDict);
  if (v125) {
    sub_10004D2C8(v125);
  }
  ATCSMutex::unlock(v114);
  return v42;
}

void sub_100659B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ATCSMutex *a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,int a26,const void *a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100087E24((uint64_t)&a30);
  sub_100057D78(&a27);
  if (a29) {
    sub_10004D2C8(a29);
  }
  ATCSMutex::unlock(a10);
  _Unwind_Resume(a1);
}

void sub_100659D2C(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    char v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

uint64_t sub_100659DF4(uint64_t a1, uint64_t a2)
{
  if ((ATCSMutex::isLocked((ATCSMutex *)(a1 + 56)) & 1) == 0) {
    __TUAssertTrigger();
  }
  uint64_t v4 = *(void *)(a1 + 360);
  if (v4) {
    sub_100C5DCE8(v4);
  }
  uint64_t v6 = *(void *)(a1 + 336);
  LODWORD(v6) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 80))(*(void *)(a1 + 64), a2);
  return sub_100655E2C(a1 + 304, (int *)&v6);
}

void sub_100659E98(uint64_t a1)
{
  char v1 = 0;
  char v2 = 0;
  sub_100224000(*(Registry **)(a1 + 744), &v1);
  if (v1) {
    CallController::startOTASP(v1);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100659EDC(uint64_t a1)
{
  char v2 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  (*(void (**)(void))(**(void **)(a1 + 64) + 104))(*(void *)(a1 + 64));
  return ATCSMutex::unlock(v2);
}

void sub_100659F3C(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100659F54(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)(a1 + 1104);
  unint64_t v3 = (void *)(a1 + 1112);
  if (v2 != (void *)(a1 + 1112))
  {
    unint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      int v7 = *((_DWORD *)v2 + 8);
      unsigned int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          unsigned int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if ((rest::operator==() & 1) == 0) {
        break;
      }
LABEL_17:
      unint64_t v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          unint64_t v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unint64_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          char v2 = v13;
        }
        while (!v14);
      }
      char v2 = v13;
      if (v13 == v3) {
        return;
      }
    }
    int v7 = *((_DWORD *)v2 + 8);
LABEL_15:
    if (*(_DWORD *)(a1 + 1160) == v7) {
      sub_10065A1B8(a1);
    }
    goto LABEL_17;
  }
}

void *sub_10065A030(void *result, _DWORD *a2)
{
  int v2 = *((_DWORD *)result + 297);
  if ((*a2 != 1) == (v2 == 1))
  {
    unint64_t v3 = result;
    uint64_t v4 = result[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bread pairing status changed; acquiring airplane mode assertion to applying changes",
        buf,
        2u);
    }
    sub_100058DB0(buf, "/cc/assertions/airplane_mode");
    ctu::rest::AssertionHandle::create();
    if (SHIBYTE(v9) < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v5 = (std::__shared_weak_count *)v3[84];
    *(_OWORD *)(v3 + 83) = v6;
    if (v5) {
      sub_10004D2C8(v5);
    }
    *(void *)CSIPhoneNumber buf = off_1019F61B8;
    unsigned int v8 = v3;
    BOOL v9 = v2 == 1;
    BOOL v10 = buf;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(buf);
  }
  return result;
}

void sub_10065A184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10065A1B8(uint64_t a1)
{
  BOOL value_7 = 0;
  unsigned int value = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 744));
  unint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    unint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v24 = (xpc_object_t *)v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v24);
  if (v8)
  {
    uint64_t v10 = v8[3];
    BOOL v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  BOOL v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, BOOL *, unsigned int *))(*(void *)v10 + 136))(v10, &value_7, &value);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  xpc_object_t v28 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v28 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v28 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_19;
  }
  xpc_object_t v14 = xpc_null_create();
LABEL_18:
  xpc_object_t v28 = v14;
LABEL_19:
  xpc_release(v13);
  xpc_object_t v26 = xpc_string_create(abm::kActionConfigureDataThrottling);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  uint64_t v24 = &v28;
  uint64_t v25 = abm::kKeyAction;
  sub_100035E70((uint64_t)&v24, &v26, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_object_t v22 = xpc_BOOL_create(value_7);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  uint64_t v24 = &v28;
  uint64_t v25 = abm::kKeyEnabled;
  sub_100035E70((uint64_t)&v24, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  if (value_7)
  {
    xpc_object_t v20 = xpc_int64_create(value);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    uint64_t v24 = &v28;
    uint64_t v25 = abm::kKeyTimeout;
    sub_100035E70((uint64_t)&v24, &v20, &v21);
    xpc_release(v21);
    xpc_object_t v21 = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
  }
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  uint64_t v15 = *(void *)(a1 + 1032);
  uint64_t v16 = abm::kCommandNetworkInterfaceControl;
  xpc_object_t v19 = v28;
  if (v28) {
    xpc_retain(v28);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  unsigned int v17 = *(NSObject **)(a1 + 1008);
  dispatch_object_t v18 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  v31[0] = off_1019F62B8;
  v31[1] = a1;
  v31[3] = v31;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v15 + 48))(v15, v16, &v19, &v18, v31);
  sub_1000595E4(v31);
  if (v18) {
    dispatch_release(v18);
  }
  xpc_release(v19);
  xpc_object_t v19 = 0;
  ATCSMutex::unlock((ATCSMutex *)(a1 + 56));
  xpc_release(v28);
}

void sub_10065A54C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

BOOL sub_10065A614(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  LODWORD(v3) = (*(uint64_t (**)(void))(**(void **)(v3 + 64) + 72))(*(void *)(v3 + 64));
  ATCSMutex::unlock(v4);
  return v3 == a2;
}

void sub_10065A68C(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10065A6A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 1032) + 32))(*(void *)(a1 + 1032)))
  {
    return sub_10065A918((void *)a1, a2, a3, a4);
  }
  else
  {
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    int v10 = (char)v9;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    if (v9 == 6)
    {
      uint64_t v11 = v10 >= 0 ? a2 : *(void *)a2;
      int v12 = *(_DWORD *)v11;
      int v13 = *(unsigned __int16 *)(v11 + 4);
      if (v12 == *(_DWORD *)"CSILog" && v13 == *(unsigned __int16 *)"og")
      {
        uint64_t v15 = *(char *)(a3 + 23) >= 0 ? (const char *)a3 : *(const char **)a3;
        if (!strcasecmp(v15, "enabled"))
        {
          sub_100058DB0(v22, "ABM");
          sub_10065A918((void *)a1, (uint64_t)v22, a3, a4);
          if (v23 < 0) {
            operator delete(v22[0]);
          }
        }
      }
    }
    if (*(void *)(a1 + 504))
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)a2;
        uint64_t v21 = *(void *)(a2 + 16);
      }
      if (*(char *)(a3 + 23) < 0)
      {
        sub_10004FC84(v18, *(void **)a3, *(void *)(a3 + 8));
      }
      else
      {
        *(_OWORD *)dispatch_object_t v18 = *(_OWORD *)a3;
        uint64_t v19 = *(void *)(a3 + 16);
      }
      if (*(char *)(a4 + 23) < 0)
      {
        sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)a4;
        uint64_t v17 = *(void *)(a4 + 16);
      }
      sub_10040B070();
    }
    return 0;
  }
}

void sub_10065A8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 33) < 0) {
    operator delete(*(void **)(v28 - 56));
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10065A918(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = (char *)operator new(0x20uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)unsigned int v8 = off_1019B3378;
  unsigned char v8[24] = 0;
  uint64_t v9 = v8 + 24;
  xpc_object_t v47 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    xpc_object_t v47 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v47 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v11);
    goto LABEL_9;
  }
  xpc_object_t v12 = xpc_null_create();
LABEL_8:
  xpc_object_t v47 = v12;
LABEL_9:
  xpc_release(v11);
  if (*(char *)(a2 + 23) >= 0) {
    int v13 = (const char *)a2;
  }
  else {
    int v13 = *(const char **)a2;
  }
  xpc_object_t v45 = xpc_string_create(v13);
  if (!v45) {
    xpc_object_t v45 = xpc_null_create();
  }
  *(void *)CSIPhoneNumber buf = &v47;
  uint64_t v44 = abm::kKeyTraceName;
  sub_100035E70((uint64_t)buf, &v45, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v45);
  xpc_object_t v45 = 0;
  if (*(char *)(a3 + 23) >= 0) {
    xpc_object_t v14 = (const char *)a3;
  }
  else {
    xpc_object_t v14 = *(const char **)a3;
  }
  xpc_object_t v41 = xpc_string_create(v14);
  if (!v41) {
    xpc_object_t v41 = xpc_null_create();
  }
  *(void *)CSIPhoneNumber buf = &v47;
  uint64_t v44 = abm::kKeyTracePropertyName;
  sub_100035E70((uint64_t)buf, &v41, &v42);
  xpc_release(v42);
  xpc_object_t v42 = 0;
  xpc_release(v41);
  xpc_object_t v41 = 0;
  if (*(char *)(a4 + 23) >= 0) {
    uint64_t v15 = (const char *)a4;
  }
  else {
    uint64_t v15 = *(const char **)a4;
  }
  xpc_object_t v39 = xpc_string_create(v15);
  if (!v39) {
    xpc_object_t v39 = xpc_null_create();
  }
  *(void *)CSIPhoneNumber buf = &v47;
  uint64_t v44 = abm::kKeyTracePropertyValue;
  sub_100035E70((uint64_t)buf, &v39, &v40);
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_release(v39);
  xpc_object_t v39 = 0;
  uint64_t v16 = *(unsigned __int8 *)(a2 + 23);
  int v17 = (char)v16;
  if ((v16 & 0x80u) != 0) {
    uint64_t v16 = *(void *)(a2 + 8);
  }
  if (v16 == 3)
  {
    dispatch_object_t v18 = v17 >= 0 ? (unsigned __int16 *)a2 : *(unsigned __int16 **)a2;
    int v19 = *v18;
    int v20 = *((unsigned __int8 *)v18 + 2);
    if (v19 == 16961 && v20 == 77)
    {
      uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
      int v23 = (char)v22;
      if ((v22 & 0x80u) != 0) {
        uint64_t v22 = *(void *)(a3 + 8);
      }
      if (v22 == 6)
      {
        uint64_t v24 = v23 >= 0 ? (int *)a3 : *(int **)a3;
        int v25 = *v24;
        int v26 = *((unsigned __int16 *)v24 + 2);
        if (v25 == 1987208563 && v26 == 29285)
        {
          BOOL v35 = 1;
          goto LABEL_61;
        }
      }
    }
  }
  uint64_t v28 = dispatch_group_create();
  uint64_t v29 = a1[129];
  xpc_object_t v38 = v47;
  if (v47) {
    xpc_retain(v47);
  }
  else {
    xpc_object_t v38 = xpc_null_create();
  }
  xpc_object_t v30 = a1[126];
  dispatch_object_t v37 = v30;
  if (v30) {
    dispatch_retain(v30);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
  if (v28)
  {
    dispatch_retain(v28);
    dispatch_group_enter(v28);
  }
  uint64_t v49 = 0;
  BOOL v31 = operator new(0x28uLL);
  uint64_t v32 = abm::kCommandSetTraceProperty;
  *BOOL v31 = off_1019F6338;
  v31[1] = a1;
  v31[2] = v9;
  v31[3] = v8;
  void v31[4] = v28;
  uint64_t v49 = v31;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v29 + 48))(v29, v32, &v38, &v37, v48);
  sub_1000595E4(v48);
  if (v37) {
    dispatch_release(v37);
  }
  xpc_release(v38);
  xpc_object_t v38 = 0;
  dispatch_time_t v33 = dispatch_time(0, 3000000000);
  if (!dispatch_group_wait(v28, v33))
  {
    BOOL v35 = *v9 != 0;
    if (!v28) {
      goto LABEL_61;
    }
LABEL_60:
    dispatch_release(v28);
    goto LABEL_61;
  }
  BOOL v34 = a1[5];
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Timeout: Set Trace property", buf, 2u);
  }
  BOOL v35 = 0;
  if (v28) {
    goto LABEL_60;
  }
LABEL_61:
  xpc_release(v47);
  sub_10004D2C8((std::__shared_weak_count *)v8);
  return v35;
}

void sub_10065AD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, xpc_object_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t a23)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065AE40(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if ((*(unsigned int (**)(void))(*(void *)a1[129] + 32))(a1[129]))
  {
    uint64_t v9 = *a4;
    unsigned int v8 = (std::__shared_weak_count *)a4[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v10 = (char *)operator new(0x20uLL);
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
    *(void *)xpc_object_t v10 = off_1019B3378;
    v10[24] = 0;
    xpc_object_t v11 = v10 + 24;
    xpc_object_t v46 = 0;
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v13 = v12;
    if (v12)
    {
      xpc_object_t v46 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v46 = v13;
      if (!v13)
      {
        xpc_object_t v17 = xpc_null_create();
        xpc_object_t v13 = 0;
        goto LABEL_20;
      }
    }
    if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v13);
      goto LABEL_21;
    }
    xpc_object_t v17 = xpc_null_create();
LABEL_20:
    xpc_object_t v46 = v17;
LABEL_21:
    xpc_release(v13);
    if (*(char *)(a2 + 23) >= 0) {
      dispatch_object_t v18 = (const char *)a2;
    }
    else {
      dispatch_object_t v18 = *(const char **)a2;
    }
    xpc_object_t v44 = xpc_string_create(v18);
    if (!v44) {
      xpc_object_t v44 = xpc_null_create();
    }
    *(void *)string = &v46;
    BOOL v35 = abm::kKeyTraceName;
    sub_100035E70((uint64_t)string, &v44, &v45);
    xpc_release(v45);
    xpc_object_t v45 = 0;
    xpc_release(v44);
    xpc_object_t v44 = 0;
    if (*(char *)(a3 + 23) >= 0) {
      int v19 = (const char *)a3;
    }
    else {
      int v19 = *(const char **)a3;
    }
    xpc_object_t v42 = xpc_string_create(v19);
    if (!v42) {
      xpc_object_t v42 = xpc_null_create();
    }
    *(void *)string = &v46;
    BOOL v35 = abm::kKeyTracePropertyName;
    sub_100035E70((uint64_t)string, &v42, &v43);
    xpc_release(v43);
    xpc_object_t v43 = 0;
    xpc_release(v42);
    xpc_object_t v42 = 0;
    int v20 = dispatch_group_create();
    uint64_t v21 = a1[129];
    xpc_object_t v41 = v46;
    if (v46) {
      xpc_retain(v46);
    }
    else {
      xpc_object_t v41 = xpc_null_create();
    }
    uint64_t v22 = a1[126];
    dispatch_object_t v40 = v22;
    if (v22) {
      dispatch_retain(v22);
    }
    *(void *)string = a1;
    BOOL v35 = v20;
    if (v20)
    {
      dispatch_retain(v20);
      dispatch_group_enter(v20);
    }
    uint64_t v36 = v9;
    dispatch_object_t v37 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v38 = v10 + 24;
    xpc_object_t v39 = v10;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 1, 1uLL, memory_order_relaxed);
    xpc_object_t v48 = 0;
    int v23 = operator new(0x38uLL);
    uint64_t v24 = abm::kCommandGetTraceProperty;
    *int v23 = off_1019F63B8;
    v23[1] = a1;
    BOOL v35 = 0;
    int v23[2] = v20;
    void v23[3] = v9;
    uint64_t v36 = 0;
    dispatch_object_t v37 = 0;
    void v23[4] = v8;
    v23[5] = v11;
    v23[6] = v10;
    xpc_object_t v38 = 0;
    xpc_object_t v39 = 0;
    xpc_object_t v48 = v23;
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v21 + 48))(v21, v24, &v41, &v40, v47);
    sub_1000595E4(v47);
    if (v40) {
      dispatch_release(v40);
    }
    xpc_release(v41);
    xpc_object_t v41 = 0;
    dispatch_time_t v25 = dispatch_time(0, 3000000000);
    if (dispatch_group_wait(v20, v25))
    {
      int v26 = a1[5];
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CSIPhoneNumber buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Timeout: Get Trace property", buf, 2u);
      }
      xpc_object_t v32 = xpc_BOOL_create(1);
      if (!v32) {
        xpc_object_t v32 = xpc_null_create();
      }
      *(void *)CSIPhoneNumber buf = v9;
      uint64_t v31 = abm::kKeyTimeout;
      sub_100035E70((uint64_t)buf, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      if (v8)
      {
        sub_10004D2C8(v8);
        unsigned int v8 = 0;
      }
      uint64_t v15 = 0;
      if (!v20) {
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v15 = *v11 != 0;
      if (!v20)
      {
LABEL_51:
        xpc_release(v46);
        sub_10004D2C8((std::__shared_weak_count *)v10);
        if (v8) {
          sub_10004D2C8(v8);
        }
        return v15;
      }
    }
    dispatch_release(v20);
    goto LABEL_51;
  }
  *(void *)string = 0;
  BOOL v35 = 0;
  uint64_t v36 = 0;
  uint64_t v14 = a1[63];
  if (v14)
  {
    uint64_t v15 = sub_10040A374(v14, (const void **)a2, (unsigned __int8 *)a3, (uint64_t)string);
    if (v36 >= 0) {
      uint64_t v16 = string;
    }
    else {
      uint64_t v16 = *(char **)string;
    }
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = string;
  }
  xpc_object_t v28 = xpc_string_create(v16);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  v47[0] = *a4;
  v47[1] = "kRadioTracePropertyValue";
  sub_100035E70((uint64_t)v47, &v28, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (SHIBYTE(v36) < 0) {
    operator delete(*(void **)string);
  }
  return v15;
}

void sub_10065B330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,dispatch_object_t object,xpc_object_t a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void *sub_10065B428(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    dispatch_group_leave(v4);
    unint64_t v5 = a1[1];
    if (v5) {
      dispatch_release(v5);
    }
  }
  return a1;
}

uint64_t sub_10065B47C(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 1184) != a2)
  {
    uint64_t v2 = result;
    uint64_t v3 = (ATCSMutex *)(result + 56);
    ATCSMutex::lock((ATCSMutex *)(result + 56));
    sub_100258880(*(_DWORD *)(v2 + 1184));
    if (*(_DWORD *)(v2 + 1184) >= 2u)
    {
      if (*(void *)(v2 + 664))
      {
        uint64_t v9 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v12) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Baseband moved to airplane mode; release airplane mode assertion acquired for bread pairing status change",
            (uint8_t *)&v12,
            2u);
        }
        xpc_object_t v10 = *(std::__shared_weak_count **)(v2 + 672);
        *(void *)(v2 + 664) = 0;
        *(void *)(v2 + 672) = 0;
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      unsigned int v11 = *(_DWORD *)(v2 + 1184);
      if (v11 > 6 || ((0x67u >> v11) & 1) == 0) {
        return ATCSMutex::unlock(v3);
      }
      BOOL v4 = (*(_DWORD *)(v2 + 1184) & 0x7F) == 5;
      unsigned int v5 = (0x5Fu >> v11) & 1;
    }
    else
    {
      BOOL v4 = 0;
      LOBYTE(v5) = 1;
    }
    if (*(void *)(v2 + 712))
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v7 = "is";
        if (v4) {
          unsigned int v7 = "is not";
        }
        int v12 = 136315138;
        xpc_object_t v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Radio boot state %s healthy", (uint8_t *)&v12, 0xCu);
      }
      for (uint64_t i = *(void *)(v2 + 704); i != v2 + 696; uint64_t i = *(void *)(i + 8))
        sub_1000607A8(i + 16, v5);
      sub_10066AA88((uint64_t *)(v2 + 696));
    }
    sub_100657CB4((void *)v2);
    return ATCSMutex::unlock(v3);
  }
  return result;
}

void sub_10065B644(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10065B674(uint64_t a1, uint64_t a2)
{
  sub_1000DFC90((uint64_t)&v2, a2);
  operator new();
}

void sub_10065B750(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_10065B75C(void *result)
{
  char v1 = result;
  uint64_t v2 = result[85];
  if (v2)
  {
    if (*(_DWORD *)(v2 + 68) == 2 && result[92])
    {
      return (void *)sub_1006572D4((uint64_t)result);
    }
  }
  else
  {
    sub_100058DB0(__p, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v6 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[86];
    *(_OWORD *)(v1 + 85) = v4;
    if (v3) {
      sub_10004D2C8(v3);
    }
    __p[0] = off_1019F64B8;
    __p[1] = v1;
    unsigned int v7 = __p;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(__p);
  }
  return result;
}

void sub_10065B89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

void sub_10065B8D0(capabilities::abs *a1, uint64_t a2)
{
  if (!*(void *)(a2 + 24)) {
    return;
  }
  if (*((void *)a1 + 129))
  {
    if (capabilities::abs::supportsRFFEScanData(a1))
    {
      uint64_t v4 = *((void *)a1 + 129);
      xpc_object_t v5 = xpc_null_create();
      char v6 = *((void *)a1 + 126);
      dispatch_object_t object = v6;
      xpc_object_t v16 = v5;
      if (v6) {
        dispatch_retain(v6);
      }
      sub_10066AE14((uint64_t)v27, a2);
      uint64_t v8 = *((void *)a1 + 3);
      unsigned int v7 = (std::__shared_weak_count *)*((void *)a1 + 4);
      *(void *)&long long v29 = a1;
      *((void *)&v29 + 1) = v8;
      xpc_object_t v30 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v32 = 0;
      uint64_t v9 = operator new(0x40uLL);
      xpc_object_t v10 = v9;
      void *v9 = off_1019F6538;
      if (v28)
      {
        if (v28 == v27)
        {
          void v9[4] = v9 + 1;
          (*(void (**)(void *))(v27[0] + 24))(v27);
          goto LABEL_27;
        }
        unsigned int v11 = &v28;
        void v9[4] = v28;
      }
      else
      {
        unsigned int v11 = v9 + 4;
      }
      *unsigned int v11 = 0;
LABEL_27:
      uint64_t v14 = abm::kCommandGetBasebandRFFEScanData;
      *(_OWORD *)(v10 + 5) = v29;
      v10[7] = v30;
      *((void *)&v29 + 1) = 0;
      xpc_object_t v30 = 0;
      xpc_object_t v32 = v10;
      (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v4 + 48))(v4, v14, &v16, &object, v31);
      sub_1000595E4(v31);
      if (v30) {
        std::__shared_weak_count::__release_weak(v30);
      }
      sub_10065C870(v27);
      if (object) {
        dispatch_release(object);
      }
      xpc_release(v16);
      return;
    }
    xpc_object_t v13 = *((void *)a1 + 5);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "RFFE Scan Data is not supported", buf, 2u);
    }
  }
  else
  {
    int v12 = *((void *)a1 + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", buf, 2u);
    }
  }
  _DWORD v19[2] = 0;
  int v20 = 0;
  *(void *)CSIPhoneNumber buf = 0;
  v18[0] = 0;
  *(void *)((char *)v18 + 5) = 0;
  void v18[2] = 0;
  v19[0] = 0;
  *(void *)((char *)v19 + 5) = 0;
  *(_OWORD *)uint64_t v21 = 0u;
  *(_OWORD *)uint64_t v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v26 = 0u;
  sub_10065BC60(a2, 0);
  if (__p[1])
  {
    *(void **)&long long v26 = __p[1];
    operator delete(__p[1]);
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (v22[1])
  {
    *(void **)&long long v23 = v22[1];
    operator delete(v22[1]);
  }
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
}

void sub_10065BBE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, char a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065BC60(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

void *sub_10065BCB4(void *a1)
{
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  char v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  xpc_object_t v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  return a1;
}

void *sub_10065BD18(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_10065C870(a1);
}

void sub_10065BD58(void *a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    if (a1[129])
    {
      char v26 = 1;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D260, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B0D260))
      {
        qword_101B0D268 = abm::kKeyTraceCarrierCellularLoggingName1;
        unk_101B0D270 = abm::kKeyTraceCarrierCellularLoggingName2;
        __cxa_guard_release(&qword_101B0D260);
      }
      uint64_t v4 = 0;
      xpc_object_t v5 = (char *)abm::kTraceBaseband;
      do
      {
        char v6 = *(char **)((char *)&unk_101B0D230 + v4 + 56);
        sub_100058DB0(&buf, v5);
        sub_100058DB0(v24, v6);
        sub_100058DB0(__p, "");
        (*(void (**)(void *, long long *, void **, void **))(*a1 + 224))(a1, &buf, v24, __p);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
        if (v25 < 0) {
          operator delete(v24[0]);
        }
        if (v28 < 0) {
          operator delete((void *)buf);
        }
        v4 += 8;
      }
      while (v4 != 16);
      *(void *)&long long buf = a1;
      *((void *)&buf + 1) = &v26;
      unsigned int v7 = (void *)a1[142];
      if (v7 != a1 + 143)
      {
        uint64_t v8 = (void *)(a2 + 8);
        while (1)
        {
          uint64_t v9 = *v8;
          if (!*v8) {
            break;
          }
          uint64_t v10 = *((unsigned int *)v7 + 8);
          unsigned int v11 = v8;
          do
          {
            int v12 = *(_DWORD *)(v9 + 32);
            BOOL v13 = v12 < (int)v10;
            if (v12 >= (int)v10) {
              uint64_t v14 = (uint64_t *)v9;
            }
            else {
              uint64_t v14 = (uint64_t *)(v9 + 8);
            }
            if (!v13) {
              unsigned int v11 = (void *)v9;
            }
            uint64_t v9 = *v14;
          }
          while (*v14);
          if (v11 == v8 || (int)v10 < *((_DWORD *)v11 + 8)) {
            goto LABEL_26;
          }
          if ((rest::operator==() & 1) == 0) {
            break;
          }
LABEL_27:
          uint64_t v15 = (void *)v7[1];
          if (v15)
          {
            do
            {
              xpc_object_t v16 = v15;
              uint64_t v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              xpc_object_t v16 = (void *)v7[2];
              BOOL v17 = *v16 == (void)v7;
              unsigned int v7 = v16;
            }
            while (!v17);
          }
          unsigned int v7 = v16;
          if (v16 == a1 + 143) {
            goto LABEL_33;
          }
        }
        uint64_t v10 = *((unsigned int *)v7 + 8);
LABEL_26:
        sub_10066B96C((uint64_t *)&buf, v10, *((unsigned char *)v7 + 40), *((unsigned char *)v7 + 41));
        goto LABEL_27;
      }
LABEL_33:
      dispatch_object_t v18 = a1[5];
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        if (v26) {
          int v19 = "true";
        }
        else {
          int v19 = "false";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging is allowed: %s", (uint8_t *)&buf, 0xCu);
      }
      sub_100058DB0(&buf, v5);
      sub_100058DB0(v24, abm::kKeyTraceCarrierCellularLoggingAllowed);
      if (v26) {
        int v20 = "true";
      }
      else {
        int v20 = "false";
      }
      sub_100058DB0(__p, v20);
      (*(void (**)(void *, long long *, void **, void **))(*a1 + 224))(a1, &buf, v24, __p);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      if (v25 < 0) {
        operator delete(v24[0]);
      }
      if (v28 < 0) {
        operator delete((void *)buf);
      }
    }
    else
    {
      uint64_t v21 = a1[5];
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No Baseband Manager object yet!", (uint8_t *)&buf, 2u);
      }
    }
  }
}

void sub_10065C0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_10065C148(uint64_t a1)
{
}

void sub_10065C150(uint64_t a1)
{
}

void sub_10065C158(void *a1, unsigned int a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v19 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v19 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v17 = xpc_int64_create(a2);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  uint64_t v13 = (uint64_t)&v19;
  uint64_t v14 = (void *)abm::kKeyBasebandOperatingMode;
  sub_100035E70((uint64_t)&v13, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  uint64_t v13 = 1;
  uint64_t v14 = a1 + 38;
  int v16 = HIDWORD(a1[42]);
  xpc_object_t v17 = 0;
  int v15 = 3;
  uint64_t v7 = a1[129];
  xpc_object_t v12 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v12 = xpc_null_create();
  }
  uint64_t v8 = abm::kCommandSetBasebandOperatingMode;
  uint64_t v9 = a1[126];
  dispatch_object_t v11 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  unint64_t v10 = a2 | ((unint64_t)*((unsigned int *)a1 + 84) << 32);
  v20[0] = off_1019F6858;
  v20[1] = a1;
  v20[2] = v10;
  unint64_t v20[3] = v20;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v7 + 48))(v7, v8, &v12, &v11, v20);
  sub_1000595E4(v20);
  if (v11) {
    dispatch_release(v11);
  }
  xpc_release(v12);
  xpc_object_t v12 = 0;
  sub_10066C7F0((uint64_t)&v13);
  xpc_release(v19);
}

void sub_10065C368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, char a18)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10065C3E8(uint64_t a1, unsigned int a2)
{
}

void sub_10065C3F0()
{
}

void sub_10065C484()
{
}

uint64_t sub_10065C4A8(uint64_t a1)
{
  uint64_t v2 = (ATCSMutex *)(a1 + 56);
  ATCSMutex::lock((ATCSMutex *)(a1 + 56));
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64)))
  {
    sub_10065C158((void *)a1, 1u);
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode request discarded", v5, 2u);
    }
  }
  return ATCSMutex::unlock(v2);
}

void sub_10065C560(_Unwind_Exception *a1)
{
  ATCSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_10065C578()
{
}

void sub_10065C584(uint64_t a1)
{
}

void sub_10065C58C(uint64_t a1)
{
  if (isActive()) {
    unsigned int v2 = 1;
  }
  else {
    unsigned int v2 = isActive();
  }
  if (*(unsigned __int8 *)(a1 + 972) != v2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v4 = "Unblocking accessories";
      if (v2) {
        xpc_object_t v4 = "Blocking accessories due to emergency";
      }
      *(_DWORD *)long long buf = 136315138;
      int v15 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    }
    *(unsigned char *)(a1 + 972) = v2;
    uint64_t v5 = *(void *)(a1 + 1032);
    xpc_object_t v6 = xpc_null_create();
    uint64_t v7 = abm::kCommandBlockAccessories;
    uint64_t v8 = abm::kCommandUnblockAccessories;
    xpc_object_t v12 = v6;
    uint64_t v9 = *(NSObject **)(a1 + 1008);
    dispatch_object_t object = v9;
    if (v9) {
      dispatch_retain(v9);
    }
    v13[0] = off_1019F6920;
    v13[1] = a1 + 40;
    void v13[2] = v2;
    void v13[3] = v13;
    if (v2) {
      uint64_t v10 = v7;
    }
    else {
      uint64_t v10 = v8;
    }
    (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v5 + 48))(v5, v10, &v12, &object, v13);
    sub_1000595E4(v13);
    if (object) {
      dispatch_release(object);
    }
    xpc_release(v12);
  }
}

void sub_10065C738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, char a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void *sub_10065C798@<X0>(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case -534716416:
      unsigned int v2 = "kInternalError";
      break;
    case -534716415:
      unsigned int v2 = "kServerError";
      break;
    case -534716414:
      unsigned int v2 = "kCommandError";
      break;
    case -534716413:
      unsigned int v2 = "kTimeout";
      break;
    case -534716412:
      unsigned int v2 = "kNotSupported";
      break;
    case -534716411:
      unsigned int v2 = "kRetry";
      break;
    case -534716410:
      unsigned int v2 = "kPermissionDenied";
      break;
    case -534716409:
      unsigned int v2 = "kNotAvailable";
      break;
    default:
      if (a1) {
        unsigned int v2 = "kInvalidErrorCode";
      }
      else {
        unsigned int v2 = "kSuccess";
      }
      break;
  }
  return sub_100058DB0(a2, v2);
}

void *sub_10065C870(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10065C8F4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10065C974(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10065C9B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10065C9E8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10065CA18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10065CA60(ATCSDPCQueue::Callback *a1)
{
  ATCSDPCQueue::Callback::~Callback(a1);

  operator delete();
}

uint64_t sub_10065CA98(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    unsigned int v2 = *(uint64_t (**)(void *, void))(result + 24);
    uint64_t v3 = *(void *)(result + 32);
    xpc_object_t v4 = (void *)(v1 + (v3 >> 1));
    if (v3) {
      unsigned int v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
    }
    return v2(v4, *(unsigned __int8 *)(result + 8));
  }
  return result;
}

uint64_t sub_10065CAF0()
{
  return 0;
}

void sub_10065CAFC()
{
}

void *sub_10065CB10(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4538;
  result[1] = v3;
  return result;
}

uint64_t sub_10065CB58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4538;
  a2[1] = v2;
  return result;
}

void sub_10065CB84(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  xpc_object_t v30 = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v30 = xpc_null_create();
  }
  xpc_object_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  xpc_object_t v33 = 0;
  size_t v34 = 0;
  uint64_t v35 = 0;
  v31[0] = &v30;
  v31[1] = (xpc_object_t)abm::kKeyServerState;
  sub_100048BAC((uint64_t)v31, &object);
  memset(__p, 0, 24);
  xpc::dyn_cast_or_default();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = &v33;
    if (v35 < 0) {
      uint64_t v9 = v33;
    }
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = (void *)abm::kEventServerStateChange;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s (%s)", (uint8_t *)__p, 0x16u);
  }
  int v10 = SHIBYTE(v35);
  if (v35 >= 0) {
    size_t v11 = HIBYTE(v35);
  }
  else {
    size_t v11 = v34;
  }
  if (v11 == strlen(abm::kServerStateStarting))
  {
    xpc_object_t v12 = v35 >= 0 ? &v33 : (void **)v33;
    if (!memcmp(v12, abm::kServerStateStarting, v11)) {
      operator new();
    }
  }
  if (v11 != strlen(abm::kServerStateStarted)
    || (v10 >= 0 ? (uint64_t v13 = &v33) : (uint64_t v13 = v33), memcmp(v13, abm::kServerStateStarted, v11)))
  {
    if (v11 != strlen(abm::kServerStateStopping)) {
      goto LABEL_48;
    }
    uint64_t v14 = v10 >= 0 ? &v33 : (void **)v33;
    if (memcmp(v14, abm::kServerStateStopping, v11)) {
      goto LABEL_48;
    }
    int v15 = (ATCSMutex *)(v7 + 56);
    ATCSMutex::lock((ATCSMutex *)(v7 + 56));
    CSIRadioModulePrivate::changeState(v7, 7u);
    if (*(_DWORD *)(v7 + 376) != 2) {
      *(_DWORD *)(v7 + 376) = 1;
    }
    ATCSMutex::unlock((ATCSMutex *)(v7 + 56));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v7 + 744));
    xpc_object_t v17 = ServiceMap;
    if (v18 < 0)
    {
      xpc_object_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v18;
    uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)__p);
    if (v22)
    {
      uint64_t v24 = v22[3];
      char v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v25 = 0;
LABEL_45:
        (*(void (**)(uint64_t))(*(void *)v24 + 232))(v24);
        if ((v25 & 1) == 0) {
          sub_10004D2C8(v23);
        }
        ATCSMutex::lock(v15);
        ATCSMutex::unlock(v15);
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    char v23 = 0;
    char v25 = 1;
    goto LABEL_45;
  }
  sub_10065A1B8(v7);
  uint64_t v26 = *(void *)(v7 + 1032);
  xpc_object_t v27 = xpc_null_create();
  uint64_t v28 = abm::kCommandGetBasebandBootState;
  v31[0] = v27;
  long long v29 = *(NSObject **)(v7 + 1008);
  xpc_object_t object = v29;
  if (v29) {
    dispatch_retain(v29);
  }
  __p[0] = off_1019F45B8;
  __p[1] = (void *)v7;
  __p[3] = __p;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, xpc_object_t *, void **))(*(void *)v26 + 48))(v26, v28, v31, &object, __p);
  sub_1000595E4(__p);
  if (object) {
    dispatch_release((dispatch_object_t)object);
  }
  xpc_release(v31[0]);
  v31[0] = 0;
LABEL_48:
  if (SHIBYTE(v35) < 0) {
    operator delete(v33);
  }
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v30);
}

void sub_10065CFF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, uint64_t a12, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065D0E8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065D128()
{
}

void sub_10065D134(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v2 = *(_DWORD *)(v1 + 1188) == 1;
  uint64_t v3[3] = 0;
  sub_10064FFDC((void *)v1, v2, (uint64_t)v3);
  sub_100060644(v3);
  operator delete();
}

void sub_10065D1C4(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100060644((uint64_t *)va);
  operator delete();
}

void sub_10065D1F4()
{
}

void *sub_10065D208(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F45B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065D250(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F45B8;
  a2[1] = v2;
  return result;
}

void sub_10065D27C(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  int v14 = *a2;
  *(_OWORD *)int v15 = *(_OWORD *)(a2 + 2);
  uint64_t v16 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  uint64_t v6 = *(void *)(a1 + 8);
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    xpc_object_t v7 = v5;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
  }
  if (!v4 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    int v10 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Fetched baseband boot state from BasebandManager", __p, 2u);
    }
    unsigned int v11 = *(_DWORD *)(v6 + 380);
    if (v11)
    {
      xpc_object_t v12 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (v11 > 8) {
          uint64_t v13 = "???";
        }
        else {
          uint64_t v13 = off_1019F6A58[v11 - 1];
        }
        *(_DWORD *)std::string __p = 136315138;
        *(void *)&__p[4] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Ignoring fetched state, as we already received baseband boot state [%s]", __p, 0xCu);
      }
    }
    else
    {
      *(void *)std::string __p = v7;
      if (v7) {
        xpc_retain(v7);
      }
      else {
        *(void *)std::string __p = xpc_null_create();
      }
      *(void *)long long buf = 0;
      sub_10064EB80(v6, (xpc::object *)__p, (NSObject **)buf);
      xpc_release(*(xpc_object_t *)__p);
      *(void *)std::string __p = 0;
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100651340((uint64_t)&v14, __p);
      uint64_t v9 = v18 >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Fetching baseband boot state failed. %s", buf, 0xCu);
      if (v18 < 0) {
        operator delete(*(void **)__p);
      }
    }
  }
  xpc_release(v7);
  xpc_release(v5);
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void sub_10065D4E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065D560(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10065D5A0()
{
}

void *sub_10065D5AC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10065D634()
{
}

void *sub_10065D648(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4658;
  result[1] = v3;
  return result;
}

uint64_t sub_10065D690(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4658;
  a2[1] = v2;
  return result;
}

void sub_10065D6BC(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = abm::kEventBasebandBootStateChange;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", buf, 0xCu);
  }
  *(void *)long long buf = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    *(void *)long long buf = xpc_null_create();
  }
  uint64_t v9 = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  sub_10064EB80(v7, (xpc::object *)buf, &v9);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(*(xpc_object_t *)buf);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065D810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065D86C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065D8AC()
{
}

void sub_10065D8BC()
{
}

void *sub_10065D8D0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F46D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065D918(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F46D8;
  a2[1] = v2;
  return result;
}

void sub_10065D944(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = abm::kEventTraceDumpStateBegin;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", buf, 0xCu);
    uint64_t v8 = *(NSObject **)(v7 + 40);
  }
  memset(v56, 0, sizeof(v56));
  long long v55 = 0u;
  os_signpost_id_t v9 = os_signpost_id_generate(v8);
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v10 = *(NSObject **)(v7 + 40);
    if (os_signpost_enabled(v10))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_BEGIN, v9, "BasebandLogDump", (const char *)&unk_1017DEDA7, buf, 2u);
    }
  }
  *(void *)long long buf = off_1019F4748;
  *((void *)&v60 + 1) = buf;
  *(void *)&long long v55 = v9;
  *((void *)&v55 + 1) = os_retain(v8);
  sub_1000336E8((uint64_t)v56, (uint64_t)buf);
  sub_100033A10(buf);
  sub_100058DB0(&__p, "Baseband log dump");
  long long v53 = v55;
  sub_1000336E8((uint64_t)&v54, (uint64_t)v56);
  long long v55 = 0uLL;
  sub_100033AF4(v56);
  Registry::createXpcJetsamAssertion();
  long long v11 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  xpc_object_t v12 = *(std::__shared_weak_count **)(v7 + 576);
  *(_OWORD *)(v7 + 568) = v11;
  if (v12)
  {
    sub_10004D2C8(v12);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  sub_1000339DC((uint64_t *)&v53);
  if (v40 < 0) {
    operator delete(__p);
  }
  xpc_object_t object = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  if (v6) {
    dispatch_retain(v6);
  }
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v52 = 0;
    *(_OWORD *)uint64_t v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    *(_OWORD *)uint64_t v49 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    *(_OWORD *)long long buf = 0u;
    memset(&v47, 0, sizeof(v47));
    __s1 = &object;
    __uint64_t n = abm::kKeyTimestampString;
    sub_100048BAC((uint64_t)&__s1, &v43);
    uint64_t v13 = (char *)abm::kUnknownTimestamp;
    xpc::dyn_cast_or_default((uint64_t *)&v47, (xpc *)&v43, abm::kUnknownTimestamp, v14);
    xpc_release(v43.__r_.__value_.__l.__data_);
    __s1 = 0;
    __uint64_t n = 0;
    uint64_t v46 = 0;
    v43.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    v43.__r_.__value_.__l.__size_ = abm::kKeyTraceFilterAction;
    sub_100048BAC((uint64_t)&v43, &__dst);
    int v15 = (char *)abm::kTraceFilterActionNone;
    xpc::dyn_cast_or_default((uint64_t *)&__s1, (xpc *)&__dst, abm::kTraceFilterActionNone, v16);
    xpc_release(__dst.__r_.__value_.__l.__data_);
    memset(&v43, 0, sizeof(v43));
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    __dst.__r_.__value_.__l.__size_ = abm::kKeyTraceDumpStateReason;
    sub_100048BAC((uint64_t)&__dst, &v41);
    xpc::dyn_cast_or_default((uint64_t *)&v43, (xpc *)&v41, abm::kDefaultReason, v17);
    xpc_release(v41.__r_.__value_.__l.__data_);
    sub_100058DB0(&__dst, v15);
    if (v46 >= 0) {
      size_t v18 = HIBYTE(v46);
    }
    else {
      size_t v18 = __n;
    }
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    int v20 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    if (v18 == size)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_dst = &__dst;
      }
      else {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if (v46 < 0)
      {
        BOOL v30 = memcmp(__s1, p_dst, __n) == 0;
      }
      else if (HIBYTE(v46))
      {
        uint64_t v22 = HIBYTE(v46) - 1;
        p_s1 = &__s1;
        do
        {
          int v25 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          int v24 = v25;
          int v27 = p_dst->__r_.__value_.__s.__data_[0];
          p_dst = (std::string *)((char *)p_dst + 1);
          int v26 = v27;
          BOOL v29 = v22-- != 0;
          BOOL v30 = v24 == v26;
        }
        while (v30 && v29);
      }
      else
      {
        BOOL v30 = 1;
      }
    }
    else
    {
      BOOL v30 = 0;
    }
    LOBYTE(v62) = !v30;
    if (v20 < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    std::string::operator=((std::string *)((char *)&v62 + 8), &v43);
    if (!std::string::compare(&v47, v13))
    {
      sub_10003ED78((std::string *)buf, v13);
    }
    else
    {
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v47;
      }
      sub_10044ABFC((uint64_t)&v48, (char *)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      sub_10044ACC4((unsigned __int16 *)&v48, &v41);
      std::string::operator=((std::string *)buf, &v41);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v31 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)&v41, (xpc::object *)&object);
      xpc_object_t v32 = (v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v41
          : (std::string *)v41.__r_.__value_.__r.__words[0];
      *(_DWORD *)char v57 = 136446210;
      xpc_object_t v58 = v32;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", v57, 0xCu);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
    }
    xpc_object_t v33 = *(const std::string **)(v7 + 504);
    if (v33)
    {
      std::string::operator=((std::string *)((char *)&v60 + 8), v33 + 8);
    }
    else
    {
      size_t v34 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v41.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Warning: handleDumpStateStartEvent: TraceModule has not been setup yet.", (uint8_t *)&v41, 2u);
      }
      if (SHIBYTE(v61) < 0)
      {
        *(void *)&long long v61 = 0;
        uint64_t v35 = (unsigned char *)*((void *)&v60 + 1);
      }
      else
      {
        uint64_t v35 = (char *)&v60 + 8;
        HIBYTE(v61) = 0;
      }
      unsigned char *v35 = 0;
    }
    sub_100257970((uint64_t)buf);
    if (byte_101B0D28F >= 0) {
      uint64_t v36 = (const char *)&qword_101B0D278;
    }
    else {
      uint64_t v36 = (const char *)qword_101B0D278;
    }
    int v37 = open(v36, 512, 420);
    sub_100101968(v37);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v43.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46) < 0) {
      operator delete(__s1);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v63) < 0) {
      operator delete(*((void **)&v62 + 1));
    }
    if (SHIBYTE(v61) < 0) {
      operator delete(*((void **)&v60 + 1));
    }
    if (SBYTE7(v60) < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[1]);
    }
    if (SHIBYTE(v50[0]) < 0) {
      operator delete(v49[0]);
    }
  }
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  sub_1000339DC((uint64_t *)&v55);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065DFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,xpc_object_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  sub_10019693C(v58 - 160);
  sub_10008AF64((uint64_t)&a46);
  if (v57) {
    dispatch_release(v57);
  }
  xpc_release(object);
  sub_1000339DC((uint64_t *)(v58 - 224));
  if (v57) {
    dispatch_release(v57);
  }
  xpc_release(v56);
  _Unwind_Resume(a1);
}

uint64_t sub_10065E16C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065E1AC()
{
}

void sub_10065E1BC()
{
}

void *sub_10065E1D0()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019F4748;
  return result;
}

void sub_10065E208(uint64_t a1, void *a2)
{
  *a2 = off_1019F4748;
}

void sub_10065E230(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "BasebandLogDump", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_10065E2A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10065E2E8()
{
}

void sub_10065E2F8()
{
}

void *sub_10065E30C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F47D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065E354(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F47D8;
  a2[1] = v2;
  return result;
}

void sub_10065E380(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = abm::kEventTraceDumpStateEnd;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t object = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  if (v6) {
    dispatch_retain(v6);
  }
  ATCSMutex::lock((ATCSMutex *)(v7 + 56));
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    os_signpost_id_t v9 = *(NSObject **)(v7 + 544);
    *(void *)(v7 + 544) = v6;
    if (v9)
    {
      dispatch_group_leave(v9);
      dispatch_release(v9);
    }
    int v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&object);
      long long v11 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v28.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", (uint8_t *)&v28, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    memset(&v28, 0, sizeof(v28));
    v26[0] = &object;
    v26[1] = (void *)abm::kKeyTimestampString;
    sub_100048BAC((uint64_t)v26, &p_object);
    memset(&buf, 0, sizeof(buf));
    xpc::dyn_cast_or_default();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_release(p_object);
    v26[0] = 0;
    v26[1] = 0;
    uint64_t v27 = 0;
    p_xpc_object_t object = &object;
    uint64_t v24 = abm::kKeyTraceDumpStatePath;
    sub_100048BAC((uint64_t)&p_object, &v22);
    sub_10064E74C(&buf);
    xpc::dyn_cast_or_default();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_release(v22.__r_.__value_.__l.__data_);
    p_xpc_object_t object = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    buf.__r_.__value_.__l.__size_ = abm::kKeyTraceDumpStateReason;
    sub_100048BAC((uint64_t)&buf, &v22);
    xpc::dyn_cast_or_default((uint64_t *)&p_object, (xpc *)&v22, abm::kUnknown, v12);
    xpc_release(v22.__r_.__value_.__l.__data_);
    memset(&v22, 0, sizeof(v22));
    __p[0] = &object;
    __p[1] = (void *)abm::kKeyBasebandCrashReason;
    sub_100048BAC((uint64_t)__p, &v21);
    memset(&buf, 0, sizeof(buf));
    xpc::dyn_cast_or_default();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_release(v21);
    if (*(char *)(v7 + 1071) < 0)
    {
      **(unsigned char **)(v7 + 1048) = 0;
      *(void *)(v7 + 1056) = 0;
    }
    else
    {
      *(unsigned char *)(v7 + 1048) = 0;
      *(unsigned char *)(v7 + 1071) = 0;
    }
    std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
    int v14 = SHIBYTE(v22.__r_.__value_.__r.__words[2]);
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v22.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      int v15 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = (std::string *)v22.__r_.__value_.__r.__words[0];
        if (v14 >= 0) {
          uint64_t v16 = &v22;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I User-requested log explanation: %s", (uint8_t *)&buf, 0xCu);
      }
      std::string::operator=((std::string *)(v7 + 1048), &v22);
    }
    ATCSMutex::unlock((ATCSMutex *)(v7 + 56));
    if (v25 >= 0) {
      p_p_xpc_object_t object = (char *)&p_object;
    }
    else {
      p_p_xpc_object_t object = (char *)p_object;
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v28;
    }
    if (SHIBYTE(v27) < 0)
    {
      sub_10004FC84(__p, v26[0], (unint64_t)v26[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v26;
      uint64_t v20 = v27;
    }
    sub_10064E7DC(v7, p_p_object, v7, (uint64_t)&buf, (uint64_t)__p);
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    ATCSMutex::lock((ATCSMutex *)(v7 + 56));
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(p_object);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
  }
  ATCSMutex::unlock((ATCSMutex *)(v7 + 56));
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(object);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065E884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (*(char *)(v45 - 89) < 0) {
    operator delete(*(void **)(v45 - 112));
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  ATCSMutex::unlock(v44);
  if (v43) {
    dispatch_release(v43);
  }
  xpc_release(object);
  if (v43) {
    dispatch_release(v43);
  }
  xpc_release(v42);
  _Unwind_Resume(a1);
}

uint64_t sub_10065EA28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065EA68()
{
}

void sub_10065EA78()
{
}

void *sub_10065EA8C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4858;
  result[1] = v3;
  return result;
}

uint64_t sub_10065EAD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4858;
  a2[1] = v2;
  return result;
}

void sub_10065EB00(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    os_signpost_id_t v9 = xpc_copy_description(v5);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v15 = 0;
    sub_100058DB0(__p, v9);
    uint64_t v10 = abm::kEventTracePostProcessingEnd;
    free(v9);
    long long v11 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v17 = v10;
    __int16 v18 = 2080;
    xpc_object_t v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s with data: %s", buf, 0x16u);
    if (SHIBYTE(v15) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    __p[0] = xpc_null_create();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v7 + 528))(v7, __p);
  xpc_release(__p[0]);
  __p[0] = 0;
  uint64_t v13 = *(std::__shared_weak_count **)(v7 + 576);
  *(_OWORD *)(v7 + 568) = 0u;
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100102494((const std::__fs::filesystem::path *)&qword_101B0D278, v12);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065ECEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065ED44(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065ED84()
{
}

void sub_10065ED94()
{
}

void *sub_10065EDA8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F48D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065EDF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F48D8;
  a2[1] = v2;
  return result;
}

void sub_10065EE1C(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void **)(a1 + 8);
  uint64_t v8 = v7[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = abm::kEventBasebandPowerOff;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&v9, 0xCu);
    uint64_t v8 = v7[5];
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Baseband has powered-off", (uint8_t *)&v9, 2u);
  }
  (*(void (**)(void *))(*v7 + 160))(v7);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065EF64(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065EFA0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065EFE0()
{
}

void sub_10065EFF0()
{
}

void *sub_10065F004(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4958;
  result[1] = v3;
  return result;
}

uint64_t sub_10065F04C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4958;
  a2[1] = v2;
  return result;
}

void sub_10065F078(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = abm::kEventABMHasShutdown;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&v9, 0xCu);
    uint64_t v8 = *(NSObject **)(v7 + 40);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I BasebandManager service has shutdown", (uint8_t *)&v9, 2u);
  }
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065F198(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10065F1A8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065F1E8()
{
}

void sub_10065F1F8()
{
}

void *sub_10065F20C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F49D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065F254(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F49D8;
  a2[1] = v2;
  return result;
}

void sub_10065F280(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = abm::kEventBasebandOperatingModeChange;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&buf, 0xCu);
  }
  ATCSMutex::lock((ATCSMutex *)(v7 + 56));
  xpc_object_t v13 = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    xpc_object_t v9 = v5;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v13 = v9;
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    *(void *)&long long buf = &v13;
    *((void *)&buf + 1) = abm::kKeyBasebandOperatingMode;
    sub_100048BAC((uint64_t)&buf, &object);
    unsigned __int8 v10 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)8, v11);
    xpc_release(object);
    xpc_object_t v9 = v13;
  }
  else
  {
    unsigned __int8 v10 = 8;
  }
  xpc_release(v9);
  sub_100659DF4(v7, v10);
  ATCSMutex::unlock((ATCSMutex *)(v7 + 56));
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065F42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065F4C0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065F500()
{
}

void sub_10065F510()
{
}

void *sub_10065F524(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4A58;
  result[1] = v3;
  return result;
}

uint64_t sub_10065F56C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4A58;
  a2[1] = v2;
  return result;
}

void sub_10065F598(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  xpc_object_t v5 = *a2;
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = abm::kEventCTCellularTrasmitState;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", buf, 0xCu);
  }
  if (xpc_get_type(v5) != (xpc_type_t)&_xpc_type_null)
  {
    xpc_object_t v9 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)buf, (xpc::object *)&object);
      unsigned __int8 v10 = v14 >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)uint64_t v15 = 136446210;
      uint64_t v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", v15, 0xCu);
      if (v14 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  xpc_object_t v11 = xpc_null_create();
  *(void *)long long buf = v11;
  sub_1000452AC(142, &object, (xpc_object_t *)buf);
  xpc_release(v11);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(object);
}

void sub_10065F734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10065F78C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065F7CC()
{
}

void sub_10065F7DC()
{
}

void *sub_10065F7F0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4AD8;
  result[1] = v3;
  return result;
}

uint64_t sub_10065F838(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4AD8;
  a2[1] = v2;
  return result;
}

void sub_10065F864(uint64_t a1, void **a2, NSObject **a3)
{
  xpc_object_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = abm::kEventTracePropertyUpdate;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t object = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    xpc_object_t v9 = object;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t object = v9;
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unsigned __int8 v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&object);
      xpc_object_t v11 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      *(_DWORD *)int v26 = 136446210;
      *(void *)&void v26[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", v26, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    memset(&buf, 0, sizeof(buf));
    *(void *)int v26 = &object;
    *(void *)&v26[8] = abm::kKeyTraceName;
    sub_100048BAC((uint64_t)v26, &v24);
    xpc::dyn_cast_or_default((uint64_t *)&buf, (xpc *)&v24, abm::kUnknown, v12);
    xpc_release(v24.__r_.__value_.__l.__data_);
    memset(v26, 0, sizeof(v26));
    uint64_t v27 = 0;
    v24.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    v24.__r_.__value_.__l.__size_ = abm::kKeyTracePropertyName;
    sub_100048BAC((uint64_t)&v24, &__p);
    xpc::dyn_cast_or_default((uint64_t *)v26, (xpc *)&__p, (const object *)"", v13);
    xpc_release(__p.__r_.__value_.__l.__data_);
    memset(&v24, 0, sizeof(v24));
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    __p.__r_.__value_.__l.__size_ = abm::kKeyTracePropertyValue;
    sub_100048BAC((uint64_t)&__p, __dst);
    xpc::dyn_cast_or_default((uint64_t *)&v24, (xpc *)__dst, (const object *)"", v14);
    xpc_release(__dst[0]);
    if (v27 >= 0) {
      uint64_t v15 = v26;
    }
    else {
      uint64_t v15 = *(uint8_t **)v26;
    }
    if (strcasecmp((const char *)v15, abm::kKeyEnabled)) {
      goto LABEL_32;
    }
    std::string::size_type size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
    if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v24.__r_.__value_.__l.__size_;
    }
    if (size == 4)
    {
      xpc_object_t v19 = &v24;
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        xpc_object_t v19 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      if (LODWORD(v19->__r_.__value_.__l.__data_) == 1702195828) {
        goto LABEL_25;
      }
    }
    else if (size == 1)
    {
      uint64_t v17 = &v24;
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v17 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      if (v17->__r_.__value_.__s.__data_[0] == 49)
      {
LABEL_25:
        __int16 v18 = (std::string *)"true";
        goto LABEL_30;
      }
    }
    __int16 v18 = (std::string *)"false";
LABEL_30:
    std::string __p = *v18;
    std::string::operator=(&v24, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
LABEL_32:
    if (*(void *)(v7 + 504))
    {
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = buf;
      }
      if (SHIBYTE(v27) < 0)
      {
        sub_10004FC84(__dst, *(void **)v26, *(unint64_t *)&v26[8]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)v26;
        uint64_t v22 = v27;
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v20, v24.__r_.__value_.__l.__data_, v24.__r_.__value_.__l.__size_);
      }
      else {
        std::string v20 = v24;
      }
      sub_10040B070();
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(*(void **)v26);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  xpc_release(object);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_10065FCBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,xpc_object_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,xpc_object_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,xpc_object_t object,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (*(char *)(v44 - 73) < 0) {
    operator delete(*(void **)(v44 - 96));
  }
  xpc_release(object);
  if (v43) {
    dispatch_release(v43);
  }
  xpc_release(v42);
  _Unwind_Resume(a1);
}

uint64_t sub_10065FDF0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10065FE30()
{
}

void sub_10065FE40()
{
}

void *sub_10065FE54(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4B58;
  result[1] = v3;
  return result;
}

uint64_t sub_10065FE9C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4B58;
  a2[1] = v2;
  return result;
}

void sub_10065FEC8(uint64_t a1, void **a2, NSObject **a3)
{
  xpc_object_t v5 = *a2;
  *a2 = xpc_null_create();
  uint64_t v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = abm::kEventLogSummaryRequest;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v71 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v71 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v71 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_11;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_10:
  xpc_object_t v71 = v11;
LABEL_11:
  xpc_release(v10);
  xpc_object_t v69 = xpc_string_create(abm::kLogSummaryCSIDomain);
  if (!v69) {
    xpc_object_t v69 = xpc_null_create();
  }
  *(void *)&long long buf = &v71;
  *((void *)&buf + 1) = abm::kKeyLogSummaryDomain;
  sub_100035E70((uint64_t)&buf, &v69, &v70);
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_release(v69);
  xpc_object_t v68 = 0;
  xpc_object_t v69 = 0;
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v13 = v12;
  if (v12)
  {
    xpc_object_t v68 = v12;
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v68 = v13;
    if (!v13)
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v13 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v13);
    goto LABEL_21;
  }
  xpc_object_t v14 = xpc_null_create();
LABEL_20:
  xpc_object_t v68 = v14;
LABEL_21:
  xpc_release(v13);
  CTGetRootVersionString();
  if (v73 >= 0) {
    p_long long buf = (const char *)&buf;
  }
  else {
    p_long long buf = (const char *)buf;
  }
  xpc_object_t v66 = xpc_string_create(p_buf);
  if (!v66) {
    xpc_object_t v66 = xpc_null_create();
  }
  CFTimeZoneRef tz = (CFTimeZoneRef)&v68;
  uint64_t v65 = (std::__shared_weak_count *)abm::kKeyCSIDomainCTVersion;
  sub_100035E70((uint64_t)&tz, &v66, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v66);
  xpc_object_t v66 = 0;
  if (v73 < 0) {
    operator delete((void *)buf);
  }
  xpc_object_t v62 = xpc_string_create(kCTProjectBuildRevision);
  if (!v62) {
    xpc_object_t v62 = xpc_null_create();
  }
  *(void *)&long long buf = &v68;
  *((void *)&buf + 1) = abm::kKeyCSIDomainCTRepoVersion;
  sub_100035E70((uint64_t)&buf, &v62, &v63);
  xpc_release(v63);
  xpc_object_t v63 = 0;
  xpc_release(v62);
  xpc_object_t v62 = 0;
  xpc_object_t v60 = xpc_string_create(kCTProjectBuildReason);
  if (!v60) {
    xpc_object_t v60 = xpc_null_create();
  }
  *(void *)&long long buf = &v68;
  *((void *)&buf + 1) = abm::kKeyCSIDomainBuildReason;
  sub_100035E70((uint64_t)&buf, &v60, &v61);
  xpc_release(v61);
  xpc_object_t v61 = 0;
  xpc_release(v60);
  xpc_object_t v60 = 0;
  if (*(_DWORD *)(v7 + 1168))
  {
    uint64_t v16 = (const char *)asString();
    xpc_object_t v58 = xpc_string_create(v16);
    if (!v58) {
      xpc_object_t v58 = xpc_null_create();
    }
    *(void *)&long long buf = &v68;
    *((void *)&buf + 1) = "Baseband mode override";
    sub_100035E70((uint64_t)&buf, &v58, &v59);
    xpc_release(v59);
    xpc_object_t v59 = 0;
    xpc_release(v58);
    xpc_object_t v58 = 0;
  }
  if (*(_DWORD *)(v7 + 1172))
  {
    uint64_t v17 = (const char *)asString();
    xpc_object_t v56 = xpc_string_create(v17);
    if (!v56) {
      xpc_object_t v56 = xpc_null_create();
    }
    *(void *)&long long buf = &v68;
    *((void *)&buf + 1) = "Operating mode override";
    sub_100035E70((uint64_t)&buf, &v56, &v57);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    xpc_release(v56);
    xpc_object_t v56 = 0;
  }
  if (*(_DWORD *)(v7 + 1180))
  {
    __int16 v18 = (const char *)asString();
    xpc_object_t v54 = xpc_string_create(v18);
    if (!v54) {
      xpc_object_t v54 = xpc_null_create();
    }
    *(void *)&long long buf = &v68;
    *((void *)&buf + 1) = "WRM Telephony override";
    sub_100035E70((uint64_t)&buf, &v54, &v55);
    xpc_release(v55);
    xpc_object_t v55 = 0;
    xpc_release(v54);
    xpc_object_t v54 = 0;
  }
  xpc_object_t v19 = "kOff";
  switch(*(_DWORD *)(v7 + 1176))
  {
    case 0xFFFFFFFF:
      goto LABEL_51;
    case 0:
      goto LABEL_48;
    case 1:
      xpc_object_t v19 = "kCMAS";
      goto LABEL_48;
    case 2:
      xpc_object_t v19 = "kAPM";
      goto LABEL_48;
    default:
      xpc_object_t v19 = "???";
LABEL_48:
      xpc_object_t v52 = xpc_string_create(v19);
      if (!v52) {
        xpc_object_t v52 = xpc_null_create();
      }
      *(void *)&long long buf = &v68;
      *((void *)&buf + 1) = "WRM Baseband override";
      sub_100035E70((uint64_t)&buf, &v52, &v53);
      xpc_release(v53);
      xpc_object_t v53 = 0;
      xpc_release(v52);
      xpc_object_t v52 = 0;
LABEL_51:
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v7 + 744));
      xpc_object_t v21 = ServiceMap;
      if (v22 < 0)
      {
        char v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          uint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v22;
      int v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&buf);
      if (v26)
      {
        uint64_t v28 = v26[3];
        uint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
          if (!v28) {
            goto LABEL_61;
          }
          goto LABEL_60;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      uint64_t v27 = 0;
      char v29 = 1;
      if (!v28) {
        goto LABEL_61;
      }
LABEL_60:
      CFTimeZoneRef tz = 0;
      (*(void (**)(CFTimeZoneRef *__return_ptr, uint64_t))(*(void *)v28 + 104))(&tz, v28);
      CFTimeZoneRef v30 = tz;
      CFAbsoluteTime v31 = (*(double (**)(uint64_t))(*(void *)v28 + 96))(v28);
      double SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(v30, v31);
      CFStringRef Name = CFTimeZoneGetName(tz);
      xpc_object_t v51 = (xpc_object_t)CFStringCreateWithFormat(0, 0, @"[%d] %@", (int)(SecondsFromGMT / 3600.0), Name);
      ctu::cf_to_xpc((uint64_t *)&v49, (ctu *)v51, v34);
      *(void *)&long long buf = &v68;
      *((void *)&buf + 1) = "System Time Zone";
      sub_100035E70((uint64_t)&buf, &v49, &v50);
      xpc_release(v50);
      xpc_object_t v50 = 0;
      xpc_release(v49);
      xpc_object_t v49 = 0;
      sub_1000558F4((const void **)&v51);
      sub_1005653C4((const void **)&tz);
LABEL_61:
      if ((v29 & 1) == 0) {
        sub_10004D2C8(v27);
      }
      uint64_t v35 = *(void *)(v7 + 744);
      if (v35)
      {
        CFTimeZoneRef tz = 0;
        uint64_t v65 = 0;
        uint64_t v36 = *(void *)(v7 + 752);
        *(void *)&long long buf = v35;
        *((void *)&buf + 1) = v36;
        if (v36) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 8), 1uLL, memory_order_relaxed);
        }
        sGetSubscriberSimInterface();
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        CFTimeZoneRef v37 = tz;
        xpc_object_t v38 = v68;
        if (v68) {
          xpc_retain(v68);
        }
        else {
          xpc_object_t v38 = xpc_null_create();
        }
        xpc_object_t v40 = v71;
        if (v71) {
          xpc_retain(v71);
        }
        else {
          xpc_object_t v40 = xpc_null_create();
        }
        uint64_t v74 = 0;
        std::string v41 = (long long *)operator new(0x20uLL);
        *(void *)std::string v41 = off_1019F4BC8;
        *((void *)v41 + 1) = v7;
        *((void *)v41 + 2) = v38;
        xpc_object_t v42 = xpc_null_create();
        *((void *)v41 + 3) = v40;
        xpc_object_t v43 = xpc_null_create();
        uint64_t v74 = v41;
        (*(void (**)(CFTimeZoneRef, long long *))(*(void *)v37 + 56))(v37, &buf);
        sub_100033230(&buf);
        xpc_release(v43);
        xpc_release(v42);
        if (v65) {
          sub_10004D2C8(v65);
        }
      }
      else
      {
        xpc_object_t v39 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Registry has not been created!", (uint8_t *)&buf, 2u);
        }
        xpc_object_t v51 = v68;
        if (v68) {
          xpc_retain(v68);
        }
        else {
          xpc_object_t v51 = xpc_null_create();
        }
        *(void *)&long long buf = &v71;
        *((void *)&buf + 1) = abm::kKeyLogSummary;
        sub_10014E03C((uint64_t)&buf, &v51, (xpc_object_t *)&tz);
        xpc_release(tz);
        CFTimeZoneRef tz = 0;
        xpc_release(v51);
        xpc_object_t v51 = 0;
        uint64_t v44 = *(void *)(v7 + 1032);
        xpc_object_t v48 = v71;
        if (v71) {
          xpc_retain(v71);
        }
        else {
          xpc_object_t v48 = xpc_null_create();
        }
        uint64_t v45 = abm::kCommandReportLogSummary;
        uint64_t v46 = *(NSObject **)(v7 + 1008);
        dispatch_object_t v47 = v46;
        if (v46) {
          dispatch_retain(v46);
        }
        *(void *)&long long buf = off_1019F4CC8;
        *((void *)&buf + 1) = v7;
        uint64_t v74 = &buf;
        (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, long long *))(*(void *)v44 + 48))(v44, v45, &v48, &v47, &buf);
        sub_1000595E4(&buf);
        if (v47) {
          dispatch_release(v47);
        }
        xpc_release(v48);
        xpc_object_t v48 = 0;
      }
      xpc_release(v68);
      xpc_release(v71);
      if (v6) {
        dispatch_release(v6);
      }
      xpc_release(v5);
      return;
  }
}

void sub_1006607FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, xpc_object_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006609F4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100660A34()
{
}

uint64_t sub_100660A40(uint64_t a1)
{
  *(void *)a1 = off_1019F4BC8;
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  return a1;
}

void sub_100660AA0(uint64_t a1)
{
  *(void *)a1 = off_1019F4BC8;
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;

  operator delete();
}

void *sub_100660B20(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1019F4BC8;
  sub_100660E54(v2 + 1, v1);
  return v2;
}

void *sub_100660B74(uint64_t a1, void *a2)
{
  *a2 = off_1019F4BC8;
  return sub_100660E54(a2 + 1, (void *)(a1 + 8));
}

void sub_100660BA0(uint64_t a1)
{
}

void sub_100660BA8(void *a1)
{
  sub_100660EBC((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100660BE4(uint64_t a1, const void **a2)
{
  xpc_object_t v12 = (ctu *)*a2;
  uint64_t v3 = v12;
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  ctu::cf_to_xpc((uint64_t *)&v17, v3, a2);
  xpc_object_t v19 = (uint64_t (**)())(a1 + 16);
  uint64_t v20 = abm::kKeyCSIDomainInformation;
  sub_100035E70((uint64_t)&v19, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v5 = *(void **)(a1 + 16);
  xpc_object_t v15 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  uint64_t v6 = (void **)(a1 + 24);
  xpc_object_t v19 = (uint64_t (**)())(a1 + 24);
  uint64_t v20 = abm::kKeyLogSummary;
  sub_10014E03C((uint64_t)&v19, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  uint64_t v7 = *(void *)(v4 + 1032);
  uint64_t v8 = *v6;
  xpc_object_t v14 = v8;
  xpc_object_t v15 = 0;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  uint64_t v9 = abm::kCommandReportLogSummary;
  xpc_object_t v10 = *(NSObject **)(v4 + 1008);
  dispatch_object_t v13 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  xpc_object_t v19 = off_1019F4C38;
  uint64_t v20 = v4;
  xpc_object_t v21 = &v19;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, uint64_t (***)()))(*(void *)v7 + 48))(v7, v9, &v14, &v13, &v19);
  sub_1000595E4(&v19);
  if (v13) {
    dispatch_release(v13);
  }
  xpc_release(v14);
  return sub_100044D00((const void **)&v12);
}

void sub_100660DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100660E08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100660E48()
{
}

void *sub_100660E54(void *a1, void *a2)
{
  uint64_t v4 = (void *)a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    a1[1] = xpc_null_create();
  }
  xpc_object_t v5 = (void *)a2[2];
  a1[2] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    a1[2] = xpc_null_create();
  }
  return a1;
}

void sub_100660EBC(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
}

void sub_100660F00()
{
}

void *sub_100660F14(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4C38;
  result[1] = v3;
  return result;
}

uint64_t sub_100660F5C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4C38;
  a2[1] = v2;
  return result;
}

void sub_100660F88(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to run kCommandReportLogSummary command", v9, 2u);
    }
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_100661048(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100661088()
{
}

void sub_100661098()
{
}

void *sub_1006610AC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4CC8;
  result[1] = v3;
  return result;
}

uint64_t sub_1006610F4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4CC8;
  a2[1] = v2;
  return result;
}

void sub_100661120(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to run kCommandReportLogSummary command", v9, 2u);
    }
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_1006611E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100661220()
{
}

void sub_100661230()
{
}

void *sub_100661244(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4D58;
  result[1] = v3;
  return result;
}

uint64_t sub_10066128C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4D58;
  a2[1] = v2;
  return result;
}

void sub_1006612B8(uint64_t a1, void **a2, NSObject **a3)
{
  xpc_object_t v5 = *a2;
  *a2 = xpc_null_create();
  int v6 = *a3;
  *a3 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = abm::kEventBrickEnable;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I received event %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v13 = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    xpc_object_t v9 = v5;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v13 = v9;
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&v13);
      if (v15 >= 0) {
        p_long long buf = &buf;
      }
      else {
        p_long long buf = (long long *)buf;
      }
      *(_DWORD *)xpc_object_t v16 = 136446210;
      *(void *)&_OWORD v16[4] = p_buf;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I contents %{public}s", v16, 0xCu);
      if (v15 < 0) {
        operator delete((void *)buf);
      }
    }
    *(void *)&long long buf = &v13;
    *((void *)&buf + 1) = abm::kCTTxPowerCommandData;
    sub_100048BAC((uint64_t)&buf, v16);
    xpc::dyn_cast_or_default((xpc *)v16, 0, v12);
    xpc_release(*(xpc_object_t *)v16);
    operator new();
  }
  xpc_release(v9);
  if (v6) {
    dispatch_release(v6);
  }
  xpc_release(v5);
}

void sub_1006614F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  if (v16) {
    dispatch_release(v16);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100661568(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006615A8()
{
}

void sub_1006615B4(uint64_t a1)
{
  sub_10064FD44(*(void **)a1, *(unsigned __int8 *)(a1 + 8));

  operator delete();
}

void sub_100661604()
{
}

void sub_10066162C()
{
}

void *sub_100661640(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4DD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100661688(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4DD8;
  a2[1] = v2;
  return result;
}

void sub_1006616B4(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to run kCommandRegisterLogSummary command", v9, 2u);
    }
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_100661774(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006617B4()
{
}

void sub_1006617C4()
{
}

void *sub_1006617D8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4E58;
  result[1] = v3;
  return result;
}

uint64_t sub_100661824(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100661864()
{
}

uint64_t sub_100661870(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100661908(void *a1)
{
  *a1 = off_1019F4ED8;
  sub_1001472DC(a1 + 2);
  return a1;
}

void sub_10066194C(void *a1)
{
  *a1 = off_1019F4ED8;
  sub_1001472DC(a1 + 2);

  operator delete();
}

void *sub_1006619B0(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019F4ED8;
  v2[1] = v3;
  sub_100661870((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100661A08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100661A1C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019F4ED8;
  a2[1] = v2;
  return sub_100661870((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100661A4C(uint64_t a1)
{
  return sub_1001472DC((void *)(a1 + 16));
}

void sub_100661A54(void *a1)
{
  sub_1001472DC(a1 + 2);

  operator delete(a1);
}

void sub_100661A90(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to perform to get property for Antenna module", buf, 2u);
    }
  }
  xpc_object_t object = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v9 = *(void *)(a1 + 40);
  if (!v9) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v9 + 48))(v9, &object);
  xpc_release(object);
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100661BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v11);
  if (v12 < 0) {
    operator delete(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100661C00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100661C40()
{
}

uint64_t sub_100661C4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void sub_100661CD0()
{
}

void *sub_100661CE4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4F58;
  result[1] = v3;
  return result;
}

uint64_t sub_100661D2C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4F58;
  a2[1] = v2;
  return result;
}

void sub_100661D58(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to perform to set property for Antenna module", v9, 2u);
    }
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_100661E18(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100661E58()
{
}

uint64_t sub_100661E64(uint64_t a1)
{
  return sub_10064FD44(**(void ***)(a1 + 32), *(unsigned __int8 *)(*(void *)(a1 + 32) + 8));
}

void sub_100661E78()
{
}

void *sub_100661E8C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F4FF8;
  result[1] = v3;
  return result;
}

uint64_t sub_100661ED4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F4FF8;
  a2[1] = v2;
  return result;
}

void sub_100661F00(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      int v4 = "is";
    }
    else {
      int v4 = "is not";
    }
    int v5 = 136315138;
    int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Airplane mode assertion %s granted for brick mode", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100661FBC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100661FFC()
{
}

void *sub_100662008(void *a1)
{
  *a1 = off_1019F5078;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_10066204C(void *a1)
{
  *a1 = off_1019F5078;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_1006620B0(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019F5078;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100662108(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10066211C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019F5078;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_10066214C(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_100662154(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

void sub_100662190(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)uint64_t v9 = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  int v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_100651340((uint64_t)&v8, __p);
      uint64_t v7 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315138;
      xpc_object_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Failed to update Bread status. %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (*(void *)(a1 + 40)) {
    sub_1000607A8(a1 + 16, v8 == 0);
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
}

void sub_1006622D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100662310(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100662350()
{
}

void sub_100662360()
{
}

void *sub_100662374(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F50F8;
  result[1] = v3;
  return result;
}

uint64_t sub_1006623BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F50F8;
  a2[1] = v2;
  return result;
}

void sub_1006623E8(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  int v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to perform to set motion paraemters from the bundle", v9, 2u);
    }
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_1006624A4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006624E4()
{
}

uint64_t sub_1006624F0(uint64_t a1)
{
  *(void *)a1 = off_1019F5178;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100662550(uint64_t a1)
{
  *(void *)a1 = off_1019F5178;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_1006625D0(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_1019F5178;
  sub_10066295C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100662624(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100662638(uint64_t a1, void *a2)
{
  *a2 = off_1019F5178;
  return sub_10066295C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100662664(uint64_t a1)
{
}

void sub_10066266C(void *a1)
{
  sub_100087FF0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1006626A8(uint64_t a1, int *a2, void **a3)
{
  int v10 = *a2;
  int v4 = v10;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v12 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  int v5 = *a3;
  *a3 = xpc_null_create();
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 == -534716415)
  {
    if (!*(unsigned char *)(a1 + 16)) {
      goto LABEL_21;
    }
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(a1 + 24);
      uint64_t v14 = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 64);
    }
    sub_100652550(v6, (const void **)buf, (uint64_t)__dst);
    if (SHIBYTE(v16) < 0) {
      operator delete(*(void **)__dst);
    }
  }
  else
  {
    if (!v4)
    {
      uint64_t v7 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Reset success", buf, 2u);
      }
      goto LABEL_21;
    }
    int v8 = *(NSObject **)(v6 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_100651340((uint64_t)&v10, buf);
    if (v14 >= 0) {
      uint64_t v9 = buf;
    }
    else {
      uint64_t v9 = *(uint8_t **)buf;
    }
    *(_DWORD *)std::string __dst = 136446210;
    *(void *)&__dst[4] = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Reset failed. %{public}s", __dst, 0xCu);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_21:
  xpc_release(v5);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006628A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  xpc_release(v28);
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100662910(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100662950()
{
}

uint64_t sub_10066295C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  if (*((char *)a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), (void *)a2[2], a2[3]);
  }
  else
  {
    long long v5 = *((_OWORD *)a2 + 1);
    *(void *)(a1 + 32) = a2[4];
    *(_OWORD *)(a1 + 16) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 40);
  if (*((char *)a2 + 63) < 0)
  {
    sub_10004FC84(v6, (void *)a2[5], a2[6]);
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 5);
    *(void *)(a1 + 56) = a2[7];
    *(_OWORD *)uint64_t v6 = v7;
  }
  return a1;
}

void sub_1006629F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100662A18(ATCSDPCQueue::Callback *a1)
{
  ATCSDPCQueue::Callback::~Callback(a1);

  operator delete();
}

uint64_t sub_100662A50(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(uint64_t (**)(void *, void))(*v3 + v1);
  }
  return v1(v3, a1[4]);
}

uint64_t sub_100662AA0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_100662AA8(uint64_t a1)
{
  *(void *)a1 = off_1019F5240;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100662B08(uint64_t a1)
{
  *(void *)a1 = off_1019F5240;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100662B88(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019F5240;
  sub_100662FC0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100662BDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100662BF0(uint64_t a1, void *a2)
{
  *a2 = off_1019F5240;
  return sub_100662FC0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100662C1C(uint64_t a1)
{
}

void sub_100662C24(void *a1)
{
  sub_10016B57C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100662C60(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  int v11 = *a2;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v13 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  long long v5 = *a3;
  xpc_object_t v10 = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v10 = xpc_null_create();
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v4 == -534716415)
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v17 = 0;
    *(void *)std::string __dst = &v10;
    *(void *)&__dst[8] = abm::kKeyTimestampString;
    sub_100048BAC((uint64_t)__dst, object);
    xpc::dyn_cast_or_default();
    xpc_release(object[0]);
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 16);
      uint64_t v19 = *(void *)(a1 + 32);
    }
    if (SHIBYTE(v17) < 0)
    {
      sub_10004FC84(object, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
      uint64_t v15 = v17;
    }
    sub_100652550(v6, (const void **)__dst, (uint64_t)object);
    if (SHIBYTE(v15) < 0) {
      operator delete(object[0]);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(*(void **)__dst);
    }
  }
  else
  {
    if (!v4)
    {
      long long v7 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I DumpState command success", buf, 2u);
      }
      goto LABEL_26;
    }
    int v8 = *(NSObject **)(v6 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    sub_100651340((uint64_t)&v11, buf);
    if (v17 >= 0) {
      uint64_t v9 = buf;
    }
    else {
      uint64_t v9 = *(uint8_t **)buf;
    }
    *(_DWORD *)std::string __dst = 136315138;
    *(void *)&__dst[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N DumpState command failed. %s", __dst, 0xCu);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_26:
  xpc_release(v10);
  xpc_object_t v10 = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100662ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (*(char *)(v30 - 41) < 0) {
    operator delete(*(void **)(v30 - 64));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100662F74(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100662FB4()
{
}

uint64_t sub_100662FC0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  long long v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)long long v5 = v6;
  }
  return a1;
}

void sub_100663054(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100663070(uint64_t a1)
{
  sub_100664520((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_1006630B0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_1006630F4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_100663138(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

void sub_10066317C(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_10066342C(&v2, a2);
}

uint64_t sub_1006631F8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_10066323C(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v22 = *a4;
  xpc_object_t v10 = (uint64_t *)sub_1006630F4(a1);
  uint64_t result = (uint64_t *)sub_100663F2C(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100663138(result + 2);
        sub_100663A60(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100663138(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_1006630F4(a1);
        uint64_t v17 = sub_100663F2C(v16);
        uint64_t v18 = sub_100663138(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      uint64_t v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_1006630F4(a1);
      uint64_t v20 = (uint64_t *)sub_100663F2C(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_100663378(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_1006630F4(a1);
  uint64_t v10 = sub_100663F2C(v9);
  int v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_1006630F4(a1);
    int v11 = *(uint64_t **)(sub_100663F2C(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_10066323C(a1, a2, a3, &v14, a4);
}

void sub_10066342C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100663498(&v2);
}

void sub_100663484(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100663498(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100663508(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_10066351C(_Unwind_Exception *a1)
{
}

void sub_100663534()
{
}

uint64_t sub_100663548(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1006635AC()
{
  return 0;
}

uint64_t sub_1006635B4()
{
  return 0;
}

uint64_t sub_1006635BC()
{
  return 0;
}

void sub_1006635C4()
{
}

void sub_100663640()
{
}

uint64_t sub_100663664(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1006637F0((uint64_t *)a1, a2);
  sub_10066385C((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  long long v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    long long v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      void v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      int v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          uint64_t v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          long long v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      long long v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1006637C8(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006637F0(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100663848(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10066385C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1006638AC(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1006638C4(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100663930(&v2);
}

void sub_10066391C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100663930(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1006639A0(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1006639B4(_Unwind_Exception *a1)
{
}

void sub_1006639CC()
{
}

uint64_t sub_1006639E0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100663A48()
{
  return 0;
}

uint64_t sub_100663A50()
{
  return 0;
}

uint64_t sub_100663A58()
{
  return 0;
}

uint64_t *sub_100663A60(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    long long v6 = (uint64_t *)sub_100663AC8(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100663AC8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100663B10(uint64_t a1)
{
  sub_100663E5C(a1);

  operator delete();
}

BOOL sub_100663B48(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_100663AC8((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_100663AC8((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_100663C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100663CC4(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100663CF0(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100663D1C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_100663D78(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100664520((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100663DD8()
{
}

uint64_t sub_100663DEC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100664520((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100663E44()
{
  return 0;
}

uint64_t sub_100663E4C()
{
  return 0;
}

uint64_t sub_100663E54()
{
  return 0;
}

uint64_t sub_100663E5C(uint64_t a1)
{
  *(void *)a1 = off_1019F5380;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100663ED0()
{
}

uint64_t sub_100663EE4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100663F14()
{
  return 0;
}

uint64_t sub_100663F1C()
{
  return 0;
}

uint64_t sub_100663F24()
{
  return 0;
}

uint64_t sub_100663F2C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100663F70(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIN5boost3_bi6bind_tIvNS1_4_mfi3mf2Iv14C2KRadioModulejjEENS2_5"
                                        "list3INS2_5valueIPS6_EENS1_3argILi1EEENSC_ILi2EEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN5boost3_bi6bind_tIvNS1_4_mfi3mf2Iv14C2KRadioModulejjEENS2_5list3INS2_5valueIPS6_EENS1_3argILi1EEENSC_ILi2EEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_1006640A8(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_1019F54C8 + 1;
  operator new();
}

void sub_100664204()
{
}

uint64_t sub_100664238(uint64_t a1)
{
  sub_1006642E0(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100664520(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1006642E0(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  long long v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100664364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

uint64_t sub_100664378(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf2Iv14C2KRadioModulejjEENS0_5list3INS0_5valueIPS4_"
                                        "EENS_3argILi1EEENSA_ILi2EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf2Iv14C2KRadioModulejjEENS0_5list3INS0_5valueIPS4_EENS_3argILi1EEENSA_ILi2EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_100664418(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_100664460(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    long long v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        long long v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_1006644FC(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_10066450C(_Unwind_Exception *a1)
{
}

uint64_t *sub_100664520(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      long long v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void sub_100664574(uint64_t a1)
{
  uint64_t v1 = **(uint64_t (****)())(a1 + 32);
  sub_100058DB0(__p, "/cc/prefs-nb/debug_baseband_mode");
  uint64_t v16 = off_1019F5518;
  uint64_t v17 = v1 + 146;
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/prefs-nb/debug_baseband_operating_mode");
  uint64_t v16 = off_1019F5598;
  uint64_t v17 = (uint64_t (**)())((char *)v1 + 1172);
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/prefs-nb/wrm-enable-telephony-override");
  uint64_t v16 = off_1019F5618;
  uint64_t v17 = (uint64_t (**)())((char *)v1 + 1180);
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/prefs-nb/wrm-enable-baseband-state-override");
  uint64_t v16 = off_1019F5698;
  uint64_t v17 = v1 + 147;
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/bring_baseband_online");
  uint64_t v2 = (uint64_t (***)())operator new(0x20uLL);
  uint64_t *v2 = off_1019F5718;
  v2[1] = v1;
  v2[2] = (uint64_t (**)())sub_100659EDC;
  v2[3] = 0;
  uint64_t v19 = v2;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v16 = off_1019F5798;
  uint64_t v17 = v1 + 135;
  uint64_t v18 = v1;
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/operator_bundles");
  long long v3 = (uint64_t (***)())operator new(0x28uLL);
  *long long v3 = off_1019F5818;
  v3[1] = v1 + 138;
  v3[2] = v1;
  uint64_t v3[3] = (uint64_t (**)())sub_100659F54;
  void v3[4] = 0;
  uint64_t v19 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/default_bundle");
  uint64_t v16 = off_1019F5898;
  uint64_t v17 = v1 + 141;
  uint64_t v18 = v1;
  uint64_t v19 = &v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v4 = (uint64_t (***)())operator new(0x28uLL);
  *uint64_t v4 = off_1019F5938;
  v4[1] = v1 + 142;
  void v4[2] = v1;
  v4[3] = (uint64_t (**)())sub_10065BD58;
  void v4[4] = 0;
  uint64_t v19 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_10041BCB4((uint64_t)(v1 + 145));
  sub_100664E98((uint64_t)v1 + 1164);
  sub_100058DB0(__p, "/cc/props/radio_state");
  uint64_t v5 = (uint64_t (***)())operator new(0x28uLL);
  *uint64_t v5 = off_1019F59B8;
  v5[1] = v1 + 148;
  _DWORD v5[2] = v1;
  v5[3] = (uint64_t (**)())sub_10065B47C;
  v5[4] = 0;
  uint64_t v19 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/widget_state");
  long long v6 = (uint64_t (***)())operator new(0x28uLL);
  *long long v6 = off_1019F5A38;
  v6[1] = (uint64_t (**)())((char *)v1 + 1188);
  void v6[2] = v1;
  void v6[3] = (uint64_t (**)())sub_10065A030;
  v6[4] = 0;
  uint64_t v19 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/last_known_home_plmn");
  long long v7 = (uint64_t (***)())operator new(0x28uLL);
  *long long v7 = off_1019F5AB8;
  v7[1] = v1 + 150;
  v7[2] = v1;
  v7[3] = (uint64_t (**)())sub_10064DC90;
  void v7[4] = 0;
  uint64_t v19 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/call_state");
  uint64_t v8 = (uint64_t (***)())operator new(0x28uLL);
  NSObject *v8 = off_1019F5B38;
  v8[1] = v1 + 153;
  _OWORD v8[2] = v1;
  void v8[3] = (uint64_t (**)())sub_10064E0A4;
  void v8[4] = 0;
  uint64_t v19 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/emergency_callback_mode");
  uint64_t v9 = (uint64_t (***)())operator new(0x28uLL);
  uint64_t *v9 = off_1019F5BB8;
  v9[1] = (uint64_t (**)())((char *)v1 + 1228);
  xpc_object_t v9[2] = v1;
  v9[3] = (uint64_t (**)())sub_10064E3A8;
  void v9[4] = 0;
  uint64_t v19 = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/emergency_mode");
  uint64_t v10 = (uint64_t (***)())operator new(0x28uLL);
  void *v10 = off_1019F5C38;
  v10[1] = v1 + 155;
  uint64_t v10[2] = v1;
  v10[3] = (uint64_t (**)())sub_10065C77C;
  void v10[4] = 0;
  uint64_t v19 = v10;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/normal_emergency_mode");
  int v11 = (uint64_t (***)())operator new(0x28uLL);
  *int v11 = off_1019F5CB8;
  v11[1] = (uint64_t (**)())((char *)v1 + 1260);
  xpc_object_t v11[2] = v1;
  void v11[3] = (uint64_t (**)())sub_10065C780;
  v11[4] = 0;
  uint64_t v19 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_net_info1");
  unsigned int v12 = (uint64_t (***)())operator new(0x28uLL);
  void *v12 = off_1019F5D38;
  v12[1] = v1 + 160;
  v12[2] = v1;
  v12[3] = (uint64_t (**)())sub_10065C148;
  void v12[4] = 0;
  uint64_t v19 = v12;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_net_info2");
  unsigned int v13 = (uint64_t (***)())operator new(0x28uLL);
  void *v13 = off_1019F5DB8;
  v13[1] = v1 + 260;
  void v13[2] = v1;
  void v13[3] = (uint64_t (**)())sub_10065C150;
  void v13[4] = 0;
  uint64_t v19 = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100664DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100664E98(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/buddy_state");
  v4[0] = off_1019F69A0;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100664F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100664F7C()
{
}

void *sub_100664F90(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5518;
  result[1] = v3;
  return result;
}

uint64_t sub_100664FD8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5518;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100665004(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_1006650A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006650E0()
{
}

void sub_1006650F0()
{
}

void *sub_100665104(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5598;
  result[1] = v3;
  return result;
}

uint64_t sub_10066514C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5598;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100665178(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_100665214(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665254()
{
}

void sub_100665264()
{
}

void *sub_100665278(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5618;
  result[1] = v3;
  return result;
}

uint64_t sub_1006652C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5618;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_1006652EC(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_100665388(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006653C8()
{
}

void sub_1006653D8()
{
}

void *sub_1006653EC(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5698;
  result[1] = v3;
  return result;
}

uint64_t sub_100665434(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5698;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100665460(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_1006654FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10066553C()
{
}

void sub_10066554C()
{
}

__n128 sub_100665560(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019F5718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1006655B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5718;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006655EC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100665634(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665674()
{
}

void sub_100665684()
{
}

__n128 sub_100665698(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F5798;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1006656E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5798;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100665714(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 16) + 64) + 88);

  return v3();
}

uint64_t sub_100665778(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006657B8()
{
}

void sub_1006657C8()
{
}

__n128 sub_1006657DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5818;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100665830(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5818;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100665868(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100665928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100665940(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665980()
{
}

void sub_100665990()
{
}

__n128 sub_1006659A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F5898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1006659F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100665A20(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v4 = *(unsigned char **)(a1 + 8);
  int v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    LOBYTE(block[0]) = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)block, (signed __int8 *)a2, v7);
    *uint64_t v4 = block[0];
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(unsigned __int8 *)(v10 + 1128) != v5)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100665B80;
    block[3] = &unk_1019F58F8;
    block[4] = v10;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  }
}

uint64_t sub_100665B34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665B74()
{
}

const void **sub_100665B80(uint64_t a1)
{
  return sub_1006502CC(*(void *)(a1 + 32));
}

void sub_100665B8C()
{
}

__n128 sub_100665BA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5938;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100665BF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5938;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100665C2C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100665CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100665D04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665D44()
{
}

void sub_100665D54()
{
}

void *sub_100665D68(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F69A0;
  result[1] = v3;
  return result;
}

uint64_t sub_100665DB0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F69A0;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100665DDC(uint64_t a1, xpc_object_t *a2)
{
  return sub_10041DCE4((int **)(a1 + 8), a2);
}

uint64_t sub_100665DE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100665E24()
{
}

void sub_100665E34()
{
}

__n128 sub_100665E48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F59B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100665E9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F59B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100665ED4(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned int *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100665FCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10066600C()
{
}

void sub_10066601C()
{
}

__n128 sub_100666030(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5A38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666084(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5A38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006660BC(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  rest::read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100666140(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666180()
{
}

void sub_100666190()
{
}

__n128 sub_1006661A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5AB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006661F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5AB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100666230(uint64_t *a1, xpc_object_t *a2)
{
  sub_1006662F8(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1006662AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006662EC()
{
}

void sub_1006662F8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10019D5B8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v13, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v12, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v14; i != v12[1] || v13 != v12[0]; uint64_t i = ++v14)
    {
      xpc_object_t v11 = 0;
      object[0] = &v13;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v11);
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v10 = 0;
        long long v8 = 0u;
        *(_OWORD *)std::string __p = 0u;
        *(_OWORD *)xpc_object_t object = 0u;
        xpc_object_t v6 = v11;
        if (v11) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1006665B0((int *)object, &v6);
        xpc_release(v6);
        sub_1001A7D08((uint64_t **)a1, (int *)object, (uint64_t)object);
        if (SHIBYTE(v10) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v8) < 0) {
          operator delete(object[1]);
        }
      }
      xpc_release(v11);
    }
    xpc_release(v13);
    xpc_release(v13);
  }
  xpc_release(v3);
}

void sub_100666514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v19 - 48));
  xpc_release(v18);
  _Unwind_Resume(a1);
}

void sub_1006665B0(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_100666710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_100666768()
{
}

__n128 sub_10066677C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5B38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1006667D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5B38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100666808(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (unsigned char *)a1[1];
  v9[0] = 0;
  v9[1] = 0;
  long long v8 = v9;
  sub_10031571C((uint64_t)&v8, a2);
  int v4 = *v3;
  sub_1003159D4(v3, &v8);
  if (v4 != *v3)
  {
    uint64_t v5 = (void (*)(void *))a1[3];
    uint64_t v6 = a1[4];
    uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
    if (v6) {
      uint64_t v5 = *(void (**)(void *))(*v7 + v5);
    }
    v5(v7);
  }
  sub_10005CD2C((uint64_t)&v8, v9[0]);
}

void sub_1006668C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1006668E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666920()
{
}

void sub_100666930()
{
}

__n128 sub_100666944(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5BB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666998(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5BB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1006669D0(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  int v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_100666A4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666A8C()
{
}

void sub_100666A9C()
{
}

__n128 sub_100666AB0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5C38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666B04(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5C38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100666B3C(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(EmergencyMode **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100666BB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666BF8()
{
}

void sub_100666C08()
{
}

__n128 sub_100666C1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5CB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666C70(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5CB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100666CA8(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(EmergencyMode **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100666D24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666D64()
{
}

void sub_100666D74()
{
}

__n128 sub_100666D88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5D38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666DDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5D38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100666E14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666E54()
{
}

void sub_100666E64()
{
}

__n128 sub_100666E78(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019F5DB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100666ECC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F5DB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100666F04(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(RegisteredNetworkInfo **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100666F80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100666FC0()
{
}

void *sub_100666FCC(void *a1)
{
  *a1 = off_1019F5E38;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_10066701C(void *a1)
{
  *a1 = off_1019F5E38;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_10066708C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F5E38;
  sub_1006674B0(v2 + 1, v1);
  return v2;
}

void *sub_1006670E0(uint64_t a1, void *a2)
{
  *a2 = off_1019F5E38;
  return sub_1006674B0(a2 + 1, (void *)(a1 + 8));
}

void sub_10066710C(uint64_t a1)
{
}

void sub_100667114(const void **a1)
{
  sub_1006674EC(a1[2]);

  operator delete(a1);
}

void sub_100667150(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t xdict = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    xpc_object_t v8 = xdict;
    if (v4)
    {
LABEL_4:
      uint64_t v9 = *(void *)(a1 + 8);
      int v10 = (void *)abm::kKeyPreFlightError;
      if (xpc_dictionary_get_value(v8, abm::kKeyPreFlightError))
      {
        std::string __p = &xdict;
        uint64_t v24 = v10;
        sub_100048BAC((uint64_t)&__p, object);
        unsigned __int16 v12 = xpc::dyn_cast_or_default((xpc *)object, 0, v11);
        xpc_release(object[0]);
        unsigned int v13 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          ctu::hex((uint64_t *)&__p, (ctu *)v12, v14);
          char v15 = v25 >= 0 ? &__p : (void **)__p;
          LODWORD(object[0]) = 136315138;
          *(xpc_object_t *)((char *)object + 4) = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Error is found. BB security status= 0x%s", (uint8_t *)object, 0xCu);
          if (SHIBYTE(v25) < 0) {
            operator delete(__p);
          }
        }
      }
      goto LABEL_16;
    }
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t xdict = v8;
    if (v4) {
      goto LABEL_4;
    }
  }
  uint64_t v16 = abm::kKeyNonce;
  if (!xpc_dictionary_get_value(v8, abm::kKeyNonce))
  {
LABEL_16:
    xpc_object_t v17 = 0;
    uint64_t v18 = 0;
    goto LABEL_17;
  }
  v21[0] = &xdict;
  v21[1] = v16;
  sub_100048BAC((uint64_t)v21, &v22);
  std::string __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  xpc::dyn_cast_or_default();
  if (__p)
  {
    uint64_t v24 = __p;
    operator delete(__p);
  }
  uint64_t v18 = object[1];
  xpc_object_t v17 = object[0];
  memset(object, 0, sizeof(object));
  xpc_release(v22);
LABEL_17:
  uint64_t v19 = *(void *)(a1 + 16);
  std::string __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  sub_10005C928(&__p, v17, (uint64_t)v18, v18 - (unsigned char *)v17);
  (*(void (**)(uint64_t, void **))(v19 + 16))(v19, &__p);
  if (__p)
  {
    uint64_t v24 = __p;
    operator delete(__p);
  }
  if (v17) {
    operator delete(v17);
  }
  xpc_release(xdict);
  xpc_object_t xdict = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_1006673B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, uint64_t a16, xpc_object_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100667464(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006674A4()
{
}

void *sub_1006674B0(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    uint64_t v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_1006674EC(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_10066750C(void *a1)
{
  *a1 = off_1019F5EB8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100667558(void *a1)
{
  *a1 = off_1019F5EB8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_1006675C4(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019F5EB8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100667628(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019F5EB8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100667668(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100667678(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1006676B8(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t xdict = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t xdict = xpc_null_create();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  xpc_object_t v47 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v47 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v47 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_12;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_13;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_12:
  xpc_object_t v47 = v11;
LABEL_13:
  xpc_release(v10);
  if (v4)
  {
    unsigned __int16 v12 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Error is found in getting manifest", buf, 2u);
    }
  }
  else
  {
    uint64_t v13 = abm::kKeyBasebandRootManifestStatus;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandRootManifestStatus))
    {
      *(void *)long long buf = &xdict;
      *(void *)&uint8_t buf[8] = v13;
      sub_100048BAC((uint64_t)buf, object);
      unsigned int v15 = xpc::dyn_cast_or_default((xpc *)object, 0, v14);
      xpc_release(object[0]);
      xpc_object_t v45 = xpc_int64_create(v15);
      if (!v45) {
        xpc_object_t v45 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      *(void *)&uint8_t buf[8] = "RootManifestStatus";
      sub_100035E70((uint64_t)buf, &v45, &v46);
      xpc_release(v46);
      xpc_object_t v46 = 0;
      xpc_release(v45);
      xpc_object_t v45 = 0;
    }
    uint64_t v16 = abm::kKeyBasebandProvisioningManifestStatus;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandProvisioningManifestStatus))
    {
      *(void *)long long buf = &xdict;
      *(void *)&uint8_t buf[8] = v16;
      sub_100048BAC((uint64_t)buf, object);
      unsigned int v18 = xpc::dyn_cast_or_default((xpc *)object, 0, v17);
      xpc_release(object[0]);
      xpc_object_t v43 = xpc_int64_create(v18);
      if (!v43) {
        xpc_object_t v43 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v49 = 0;
      ctu::cf::assign();
      *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
      uint64_t v40 = v49;
      uint64_t v19 = *(xpc_object_t **)buf;
      if (v49 >= 0) {
        uint64_t v19 = object;
      }
      p_xpc_object_t xdict = &v47;
      xpc_object_t v42 = v19;
      sub_100035E70((uint64_t)&p_xdict, &v43, &v44);
      xpc_release(v44);
      xpc_object_t v44 = 0;
      if (SHIBYTE(v40) < 0) {
        operator delete(object[0]);
      }
      xpc_release(v43);
      xpc_object_t v43 = 0;
    }
    uint64_t v20 = abm::kKeyBasebandActivationManifestStatus;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandActivationManifestStatus))
    {
      *(void *)long long buf = &xdict;
      *(void *)&uint8_t buf[8] = v20;
      sub_100048BAC((uint64_t)buf, object);
      unsigned int v22 = xpc::dyn_cast_or_default((xpc *)object, 0, v21);
      xpc_release(object[0]);
      xpc_object_t v37 = xpc_int64_create(v22);
      if (!v37) {
        xpc_object_t v37 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      *(void *)&uint8_t buf[8] = "AKeyStatus";
      sub_100035E70((uint64_t)buf, &v37, &v38);
      xpc_release(v38);
      xpc_object_t v38 = 0;
      xpc_release(v37);
      xpc_object_t v37 = 0;
    }
    char v23 = (xpc_object_t *)abm::kKeyBasebandRootManifest;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandRootManifest))
    {
      p_xpc_object_t xdict = &xdict;
      xpc_object_t v42 = v23;
      sub_100048BAC((uint64_t)&p_xdict, &v36);
      memset(buf, 0, sizeof(buf));
      uint64_t v49 = 0;
      xpc::dyn_cast_or_default();
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      xpc_object_t v24 = object[0];
      uint64_t v25 = object[1];
      object[0] = 0;
      object[1] = 0;
      uint64_t v40 = 0;
      xpc_release(v36);
      xpc_object_t v35 = xpc_data_create(v24, v25 - (unsigned char *)v24);
      if (!v35) {
        xpc_object_t v35 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      *(void *)&uint8_t buf[8] = "RootManifestData";
      sub_100035E70((uint64_t)buf, &v35, &v36);
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_release(v35);
      xpc_object_t v35 = 0;
    }
    else
    {
      xpc_object_t v24 = 0;
    }
    int v26 = (xpc_object_t *)abm::kKeyBasebandProvisioningManifest;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandProvisioningManifest))
    {
      p_xpc_object_t xdict = &xdict;
      xpc_object_t v42 = v26;
      sub_100048BAC((uint64_t)&p_xdict, &v34);
      memset(buf, 0, sizeof(buf));
      uint64_t v49 = 0;
      xpc::dyn_cast_or_default();
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (v24) {
        operator delete(v24);
      }
      xpc_object_t v24 = object[0];
      uint64_t v27 = object[1];
      object[1] = 0;
      uint64_t v40 = 0;
      object[0] = 0;
      xpc_release(v34);
      xpc_object_t v33 = xpc_data_create(v24, v27 - (unsigned char *)v24);
      if (!v33) {
        xpc_object_t v33 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      *(void *)&uint8_t buf[8] = "ProvisioningManifestData";
      sub_100035E70((uint64_t)buf, &v33, &v34);
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_release(v33);
      xpc_object_t v33 = 0;
    }
    uint64_t v28 = (xpc_object_t *)abm::kKeyBasebandActivationManifest;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandActivationManifest))
    {
      p_xpc_object_t xdict = &xdict;
      xpc_object_t v42 = v28;
      sub_100048BAC((uint64_t)&p_xdict, &v32);
      memset(buf, 0, sizeof(buf));
      uint64_t v49 = 0;
      xpc::dyn_cast_or_default();
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (v24) {
        operator delete(v24);
      }
      xpc_object_t v24 = object[0];
      char v29 = object[1];
      object[1] = 0;
      uint64_t v40 = 0;
      object[0] = 0;
      xpc_release(v32);
      p_xpc_object_t xdict = xpc_data_create(v24, v29 - (unsigned char *)v24);
      if (!p_xdict) {
        p_xpc_object_t xdict = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      *(void *)&uint8_t buf[8] = "ActivationManifestData";
      sub_100035E70((uint64_t)buf, &p_xdict, object);
      xpc_release(object[0]);
      object[0] = 0;
      xpc_release(p_xdict);
      p_xpc_object_t xdict = 0;
    }
    xpc_object_t v31 = v47;
    if (v47) {
      xpc_retain(v47);
    }
    else {
      xpc_object_t v31 = xpc_null_create();
    }
    *(void *)long long buf = *(void *)(a1 + 16);
    *(void *)&uint8_t buf[8] = "kRadioModuleFirmwareManifestData";
    sub_10014E03C((uint64_t)buf, &v31, &v32);
    xpc_release(v32);
    xpc_object_t v32 = 0;
    xpc_release(v31);
    xpc_object_t v31 = 0;
    if (v24) {
      operator delete(v24);
    }
  }
  xpc_release(v47);
  xpc_release(xdict);
  xpc_object_t xdict = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100667D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t a24)
{
  char v29 = *(void **)(v27 - 96);
  if (v29)
  {
    *(void *)(v27 - 88) = v29;
    operator delete(v29);
  }
  xpc_release(object);
  if (v25) {
    operator delete(v25);
  }
  xpc_release(*(xpc_object_t *)(v27 - 104));
  xpc_release(a10);
  if (v26 < 0) {
    operator delete(v24);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100667ECC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100667F0C()
{
}

uint64_t *sub_100667F18(uint64_t a1)
{
  uint64_t v7 = a1;
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = operator new(0x20uLL);
  void v4[2] = v2;
  v4[3] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = v1[90];
  *int v4 = v5;
  v4[1] = v1 + 90;
  *(void *)(v5 + 8) = v4;
  v1[90] = v4;
  ++v1[92];
  sub_10065B75C(v1);
  return sub_1000E1A60(&v7);
}

void sub_100667F9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E1A60((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100667FB4()
{
}

void *sub_100667FC8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5F38;
  result[1] = v3;
  return result;
}

uint64_t sub_100668010(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5F38;
  a2[1] = v2;
  return result;
}

void sub_10066803C(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  int v23 = *a2;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v25 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  xpc_object_t object = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (ATCSMutex *)(v6 + 56);
  ATCSMutex::lock((ATCSMutex *)(v6 + 56));
  if (!v4 && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v10 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)&v29, (xpc::object *)&object);
      xpc_object_t v11 = v30 >= 0 ? &v29 : (long long *)v29;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I BasebandManager info:\n%{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v30) < 0) {
        operator delete((void *)v29);
      }
    }
    v26[0] = &object;
    v26[1] = abm::kKeyBasebandVersion;
    sub_100048BAC((uint64_t)v26, &v27);
    long long v29 = 0uLL;
    uint64_t v30 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v30) < 0) {
      operator delete((void *)v29);
    }
    if ((ATCSMutex::isLocked((ATCSMutex *)(v6 + 56)) & 1) == 0) {
      __TUAssertTrigger();
    }
    unsigned __int16 v12 = (std::string *)(v6 + 976);
    uint64_t v13 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    int v14 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
    }
    uint64_t v16 = *(unsigned __int8 *)(v6 + 999);
    int v17 = (char)v16;
    if ((v16 & 0x80u) != 0) {
      uint64_t v16 = *(void *)(v6 + 984);
    }
    if (size == v16)
    {
      if (v17 >= 0) {
        unsigned int v18 = (unsigned __int8 *)(v6 + 976);
      }
      else {
        unsigned int v18 = (unsigned __int8 *)v12->__r_.__value_.__r.__words[0];
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        unsigned int v21 = (std::string *)buf.__r_.__value_.__r.__words[0];
        if (!memcmp(buf.__r_.__value_.__l.__data_, v18, buf.__r_.__value_.__l.__size_))
        {
LABEL_45:
          operator delete(buf.__r_.__value_.__l.__data_);
          goto LABEL_46;
        }
        uint64_t v20 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      if (!*((unsigned char *)&buf.__r_.__value_.__s + 23))
      {
LABEL_46:
        xpc_release(v27);
        goto LABEL_47;
      }
      p_std::string buf = &buf;
      while (p_buf->__r_.__value_.__s.__data_[0] == *v18)
      {
        p_std::string buf = (std::string *)((char *)p_buf + 1);
        ++v18;
        if (!--v13) {
          goto LABEL_44;
        }
      }
    }
    uint64_t v20 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if (v14 >= 0) {
        unsigned int v21 = &buf;
      }
      else {
        unsigned int v21 = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
LABEL_42:
      LODWORD(v29) = 136315138;
      *(void *)((char *)&v29 + 4) = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Baseband version set to: %s", (uint8_t *)&v29, 0xCu);
    }
LABEL_43:
    std::string::operator=(v12, &buf);
    LOBYTE(v14) = *((unsigned char *)&buf.__r_.__value_.__s + 23);
LABEL_44:
    if ((v14 & 0x80) == 0) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  uint64_t v8 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100651340((uint64_t)&v23, &v29);
    xpc_object_t v9 = v30 >= 0 ? &v29 : (long long *)v29;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to retrieve info from BasebandManager: %{public}s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v30) < 0) {
      operator delete((void *)v29);
    }
  }
LABEL_47:
  ATCSMutex::unlock(v7);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006683B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  ATCSMutex::unlock(v25);
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100668454(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100668494()
{
}

void sub_1006684A4()
{
}

void *sub_1006684B8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F5FB8;
  result[1] = v3;
  return result;
}

uint64_t sub_100668500(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F5FB8;
  a2[1] = v2;
  return result;
}

void sub_10066852C(uint64_t a1, int *a2, xpc_object_t *a3)
{
  int v4 = *a2;
  int v13 = *a2;
  *(_OWORD *)int v14 = *(_OWORD *)(a2 + 2);
  uint64_t v15 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  xpc_object_t v5 = *a3;
  xpc_object_t object = v5;
  if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t object = v5;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (ATCSMutex *)(v6 + 56);
  ATCSMutex::lock((ATCSMutex *)(v6 + 56));
  if (!v4 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    __p[0] = &object;
    __p[1] = (void *)abm::kKeyBasebandOperatingMode;
    sub_100048BAC((uint64_t)__p, buf);
    unsigned __int8 v11 = xpc::dyn_cast_or_default((xpc *)buf, (const object *)8, v10);
    xpc_release(*(xpc_object_t *)buf);
    sub_100659DF4(v6, v11);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100651340((uint64_t)&v13, __p);
      xpc_object_t v9 = v17 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to get current operating mode: %{public}s", buf, 0xCu);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  ATCSMutex::unlock(v7);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void sub_1006686FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  ATCSMutex::unlock(v20);
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100668780(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1006687C0()
{
}

void *sub_1006687CC(void *a1)
{
  *a1 = off_1019F6038;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100668824(void *a1)
{
  *a1 = off_1019F6038;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_10066889C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F6038;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_1006688F0(uint64_t a1, void *a2)
{
  *a2 = off_1019F6038;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_10066891C(uint64_t a1)
{
}

void sub_100668924(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100668960(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t xdict = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t xdict = xpc_null_create();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  ATCSMutex::lock((ATCSMutex *)(v8 + 56));
  if (v4)
  {
    xpc_object_t v9 = (void *)abm::kKeyPreFlightError;
    if (xpc_dictionary_get_value(xdict, abm::kKeyPreFlightError))
    {
      std::string __p = &xdict;
      xpc_object_t v24 = v9;
      sub_100048BAC((uint64_t)&__p, object);
      unsigned __int16 v11 = xpc::dyn_cast_or_default((xpc *)object, 0, v10);
      xpc_release(object[0]);
      unsigned __int16 v12 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex((uint64_t *)&__p, (ctu *)v11, v13);
        int v14 = v25 >= 0 ? &__p : (void **)__p;
        LODWORD(object[0]) = 136315138;
        *(xpc_object_t *)((char *)object + 4) = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Error is found. BB security status= 0x%s", (uint8_t *)object, 0xCu);
        if (SHIBYTE(v25) < 0) {
          operator delete(__p);
        }
      }
    }
  }
  else
  {
    uint64_t v15 = abm::kKeyBasebandPKHash;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandPKHash))
    {
      v21[0] = &xdict;
      v21[1] = v15;
      sub_100048BAC((uint64_t)v21, &v22);
      std::string __p = 0;
      xpc_object_t v24 = 0;
      uint64_t v25 = 0;
      xpc::dyn_cast_or_default();
      if (__p)
      {
        xpc_object_t v24 = __p;
        operator delete(__p);
      }
      uint64_t v16 = (void *)(v8 + 824);
      char v17 = *(void **)(v8 + 824);
      if (v17)
      {
        *(void *)(v8 + 832) = v17;
        operator delete(v17);
        void *v16 = 0;
        *(void *)(v8 + 832) = 0;
        *(void *)(v8 + 84sub_10010E764((uint64_t)&a9, 0) = 0;
      }
      *(_OWORD *)uint64_t v16 = *(_OWORD *)object;
      *(void *)(v8 + 84sub_10010E764((uint64_t)&a9, 0) = v27;
      object[1] = 0;
      uint64_t v27 = 0;
      object[0] = 0;
      xpc_release(v22);
    }
    unsigned int v18 = (void *)abm::kKeyBasebandCertID;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandCertID))
    {
      std::string __p = &xdict;
      xpc_object_t v24 = v18;
      sub_100048BAC((uint64_t)&__p, object);
      *(_DWORD *)(v8 + 82sub_10010E764((uint64_t)&a9, 0) = xpc::dyn_cast_or_default((xpc *)object, 0, v19);
      xpc_release(object[0]);
    }
  }
  ATCSMutex::unlock((ATCSMutex *)(v8 + 56));
  xpc_release(xdict);
  xpc_object_t xdict = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100668BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, xpc_object_t a13, void *__p, uint64_t a15, uint64_t a16, xpc_object_t a17)
{
  ATCSMutex::unlock(v18);
  xpc_release(object);
  if (v19 < 0) {
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100668CB0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100668CF0()
{
}

void *sub_100668CFC(void *a1)
{
  *a1 = off_1019F60B8;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100668D54(void *a1)
{
  *a1 = off_1019F60B8;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100668DCC(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F60B8;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100668E20(uint64_t a1, void *a2)
{
  *a2 = off_1019F60B8;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100668E4C(uint64_t a1)
{
}

void sub_100668E54(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100668E90(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t xdict = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t xdict = xpc_null_create();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  ATCSMutex::lock((ATCSMutex *)(v8 + 56));
  if (v4)
  {
    xpc_object_t v9 = (void *)abm::kKeyPreFlightError;
    if (xpc_dictionary_get_value(xdict, abm::kKeyPreFlightError))
    {
      std::string __p = &xdict;
      long long v29 = v9;
      sub_100048BAC((uint64_t)&__p, object);
      unsigned __int16 v11 = xpc::dyn_cast_or_default((xpc *)object, 0, v10);
      xpc_release(object[0]);
      unsigned __int16 v12 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex((uint64_t *)&__p, (ctu *)v11, v13);
        int v14 = v30 >= 0 ? &__p : (void **)__p;
        LODWORD(object[0]) = 136315138;
        *(xpc_object_t *)((char *)object + 4) = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Error is found. BB security status= 0x%s", (uint8_t *)object, 0xCu);
        if (SHIBYTE(v30) < 0) {
          operator delete(__p);
        }
      }
    }
  }
  else
  {
    uint64_t v15 = abm::kKeyBasebandSerialNumber;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandSerialNumber))
    {
      p_xpc_object_t xdict = &xdict;
      uint64_t v26 = v15;
      sub_100048BAC((uint64_t)&p_xdict, &v27);
      std::string __p = 0;
      long long v29 = 0;
      uint64_t v30 = 0;
      xpc::dyn_cast_or_default();
      if (__p)
      {
        long long v29 = __p;
        operator delete(__p);
      }
      uint64_t v16 = (void *)(v8 + 792);
      char v17 = *(void **)(v8 + 792);
      if (v17)
      {
        *(void *)(v8 + 80sub_10010E764((uint64_t)&a9, 0) = v17;
        operator delete(v17);
        void *v16 = 0;
        *(void *)(v8 + 80sub_10010E764((uint64_t)&a9, 0) = 0;
        *(void *)(v8 + 808) = 0;
      }
      *(_OWORD *)uint64_t v16 = *(_OWORD *)object;
      *(void *)(v8 + 808) = v32;
      object[1] = 0;
      uint64_t v32 = 0;
      object[0] = 0;
      xpc_release(v27);
    }
    unsigned int v18 = (void *)abm::kKeyBasebandChipID;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandChipID))
    {
      std::string __p = &xdict;
      long long v29 = v18;
      sub_100048BAC((uint64_t)&__p, object);
      *(_DWORD *)(v8 + 816) = xpc::dyn_cast_or_default((xpc *)object, 0, v19);
      xpc_release(object[0]);
    }
    uint64_t v20 = (void *)abm::kKeyBasebandCertID;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandCertID))
    {
      std::string __p = &xdict;
      long long v29 = v20;
      sub_100048BAC((uint64_t)&__p, object);
      *(_DWORD *)(v8 + 82sub_10010E764((uint64_t)&a9, 0) = xpc::dyn_cast_or_default((xpc *)object, 0, v21);
      xpc_release(object[0]);
    }
    uint64_t v22 = abm::kKeyBasebandScrtPubK;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandScrtPubK))
    {
      p_xpc_object_t xdict = &xdict;
      uint64_t v26 = v22;
      sub_100048BAC((uint64_t)&p_xdict, &v27);
      std::string __p = 0;
      long long v29 = 0;
      uint64_t v30 = 0;
      xpc::dyn_cast_or_default();
      if (__p)
      {
        long long v29 = __p;
        operator delete(__p);
      }
      int v23 = *(void **)(v8 + 848);
      if (v23)
      {
        *(void *)(v8 + 856) = v23;
        operator delete(v23);
        *(void *)(v8 + 848) = 0;
        *(void *)(v8 + 856) = 0;
        *(void *)(v8 + 864) = 0;
      }
      *(_OWORD *)(v8 + 848) = *(_OWORD *)object;
      *(void *)(v8 + 864) = v32;
      object[1] = 0;
      uint64_t v32 = 0;
      object[0] = 0;
      xpc_release(v27);
    }
  }
  ATCSMutex::unlock((ATCSMutex *)(v8 + 56));
  xpc_release(xdict);
  xpc_object_t xdict = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_1006691F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, xpc_object_t a13, void *__p, uint64_t a15, uint64_t a16, xpc_object_t a17)
{
  ATCSMutex::unlock(v18);
  xpc_release(object);
  if (v19 < 0) {
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066930C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066934C()
{
}

void *sub_100669358(void *a1)
{
  *a1 = off_1019F6138;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_1006693B0(void *a1)
{
  *a1 = off_1019F6138;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100669428(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019F6138;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_10066947C(uint64_t a1, void *a2)
{
  *a2 = off_1019F6138;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_1006694A8(uint64_t a1)
{
}

void sub_1006694B0(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1006694EC(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t xdict = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t xdict = xpc_null_create();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  ATCSMutex::lock((ATCSMutex *)(v8 + 56));
  if (v4)
  {
    xpc_object_t v9 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Error is found in getting manifest status", buf, 2u);
    }
  }
  else
  {
    int v10 = (void *)abm::kKeyBasebandSKeyStatus;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandSKeyStatus))
    {
      *(void *)std::string buf = &xdict;
      uint64_t v22 = v10;
      sub_100048BAC((uint64_t)buf, object);
      *(_DWORD *)(v8 + 936) = xpc::dyn_cast_or_default((xpc *)object, 0, v11);
      xpc_release(object[0]);
    }
    unsigned __int16 v12 = (void *)abm::kKeyBasebandAKeyStatus;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandAKeyStatus))
    {
      *(void *)std::string buf = &xdict;
      uint64_t v22 = v12;
      sub_100048BAC((uint64_t)buf, object);
      *(_DWORD *)(v8 + 968) = xpc::dyn_cast_or_default((xpc *)object, 0, v13);
      xpc_release(object[0]);
    }
    uint64_t v14 = abm::kKeyBasebandSKeyHash;
    if (xpc_dictionary_get_value(xdict, abm::kKeyBasebandSKeyHash))
    {
      v17[0] = &xdict;
      v17[1] = v14;
      sub_100048BAC((uint64_t)v17, &v18);
      *(void *)std::string buf = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      xpc::dyn_cast_or_default();
      if (*(void *)buf)
      {
        uint64_t v22 = *(void **)buf;
        operator delete(*(void **)buf);
      }
      uint64_t v15 = *(void **)(v8 + 944);
      if (v15)
      {
        *(void *)(v8 + 952) = v15;
        operator delete(v15);
        *(void *)(v8 + 944) = 0;
        *(void *)(v8 + 952) = 0;
        *(void *)(v8 + 96sub_10010E764((uint64_t)&a9, 0) = 0;
      }
      *(_OWORD *)(v8 + 944) = *(_OWORD *)object;
      *(void *)(v8 + 96sub_10010E764((uint64_t)&a9, 0) = v20;
      object[1] = 0;
      uint64_t v20 = 0;
      object[0] = 0;
      xpc_release(v18);
    }
  }
  ATCSMutex::unlock((ATCSMutex *)(v8 + 56));
  xpc_release(xdict);
  xpc_object_t xdict = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100669714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  xpc_release(object);
  ATCSMutex::unlock(v19);
  xpc_release(a9);
  if (v20 < 0) {
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1006697C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100669804()
{
}

uint64_t sub_100669810(std::mutex *this, uint64_t *a2)
{
  if ((v4 & 0x8000000000000000) != 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  uint64_t v8 = *a2;
  xpc_object_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v14 = v8;
  uint64_t v15 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = v4;
  int v10 = this + 1;
  if (!v8)
  {
    sub_100136C98(v10, &v16);
    uint64_t v12 = 1;
    if (!v9) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  sub_100136784((uint64_t)v10, &v16, &v16, &v14);
  uint64_t v12 = v11 & 1;
  xpc_object_t v9 = v15;
  if (v15) {
LABEL_8:
  }
    sub_10004D2C8(v9);
LABEL_9:
  std::mutex::unlock(this);
  return v12;
}

uint64_t sub_1006698E8(std::mutex *this, uint64_t *a2)
{
  if ((v4 & 0x8000000000000000) != 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  uint64_t v8 = *a2;
  if (*a2)
  {
    xpc_object_t v9 = (std::__shared_weak_count *)a2[1];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v13 = v8;
    uint64_t v14 = v9;
    unint64_t v15 = v4;
    sub_100136784((uint64_t)&this[1], &v15, &v15, &v13);
    uint64_t v11 = v10 & 1;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = v4;
    sub_100136C98(&this[1].__m_.__sig, &v15);
    uint64_t v11 = 1;
  }
  std::mutex::unlock(this);
  return v11;
}

uint64_t sub_1006699C8(std::mutex *this, void *a2)
{
  if ((v4 & 0x8000000000000000) != 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(this);
  if (*a2)
  {
    uint64_t v8 = *a2 + 56;
    xpc_object_t v9 = (std::__shared_weak_count *)a2[1];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v13 = v8;
    uint64_t v14 = v9;
    unint64_t v15 = v4;
    sub_100136784((uint64_t)&this[1], &v15, &v15, &v13);
    uint64_t v11 = v10 & 1;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = v4;
    sub_100136C98(&this[1].__m_.__sig, &v15);
    uint64_t v11 = 1;
  }
  std::mutex::unlock(this);
  return v11;
}

void sub_100669AB0()
{
}

__n128 sub_100669AC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F61B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100669B10(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F61B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100669B40(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  unint64_t v4 = *(void **)(a1 + 8);
  xpc_object_t v5 = v4[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "is";
    if (!v3) {
      uint64_t v6 = "is not";
    }
    LODWORD(v8) = 136315138;
    *(void *)((char *)&v8 + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Airplane mode assertion %s granted for bread pairing status change", (uint8_t *)&v8, 0xCu);
  }
  if (v3)
  {
    char v7 = *(unsigned char *)(a1 + 16);
    *(void *)&long long v8 = off_1019F6228;
    *((void *)&v8 + 1) = v4;
    xpc_object_t v9 = &v8;
    sub_10064FFDC(v4, v7, (uint64_t)&v8);
    sub_100060644(&v8);
  }
}

void sub_100669C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100669C58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100669C98()
{
}

void sub_100669CA8()
{
}

void *sub_100669CBC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F6228;
  result[1] = v3;
  return result;
}

uint64_t sub_100669D04(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F6228;
  a2[1] = v2;
  return result;
}

void sub_100669D30(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v1 + 1184) >= 2u && *(void *)(v1 + 664))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Baseband is in airplane mode; release airplane mode assertion acquired for bread pairing status change",
        v4,
        2u);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 672);
    *(void *)(v1 + 664) = 0;
    *(void *)(v1 + 672) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100669DC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100669E04()
{
}

void sub_100669E14()
{
}

void *sub_100669E28(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F62B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100669E70(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F62B8;
  a2[1] = v2;
  return result;
}

void sub_100669E9C(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)xpc_object_t v9 = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  xpc_object_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_100651340((uint64_t)&v8, __p);
      char v7 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Failed to update data throttling for operator bundle change. %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
}

void sub_100669FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066A000(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066A040()
{
}

void *sub_10066A04C(void *a1)
{
  *a1 = off_1019F6338;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_10066A0B0(void *a1)
{
  *a1 = off_1019F6338;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_10066A134(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019F6338;
  sub_10034B048((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10066A188(uint64_t a1, void *a2)
{
  *a2 = off_1019F6338;
  return sub_10034B048((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10066A1B4(uint64_t a1)
{
}

void sub_10066A1BC(void *a1)
{
  sub_10034B0A8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10066A1F8(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  char v7 = *a3;
  *a3 = xpc_null_create();
  if (v4 || (xpc_object_t v9 = *(unsigned char **)(a1 + 16)) == 0)
  {
    int v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to set trace property", v10, 2u);
    }
  }
  else
  {
    unsigned char *v9 = 1;
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_10066A2C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10066A308()
{
}

void *sub_10066A314(void *a1)
{
  *a1 = off_1019F63B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = a1[2];
  if (v4)
  {
    dispatch_group_leave(v4);
    xpc_object_t v5 = a1[2];
    if (v5) {
      dispatch_release(v5);
    }
  }
  return a1;
}

void sub_10066A384(void *a1)
{
  *a1 = off_1019F63B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = a1[2];
  if (v4)
  {
    dispatch_group_leave(v4);
    xpc_object_t v5 = a1[2];
    if (v5) {
      dispatch_release(v5);
    }
  }

  operator delete();
}

void *sub_10066A414(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_1019F63B8;
  sub_10066A76C(v2 + 1, v1);
  return v2;
}

void *sub_10066A468(uint64_t a1, void *a2)
{
  *a2 = off_1019F63B8;
  return sub_10066A76C(a2 + 1, (void *)(a1 + 8));
}

void sub_10066A494(uint64_t a1)
{
}

void sub_10066A49C(void *a1)
{
  sub_10066A7E0(a1 + 1);

  operator delete(a1);
}

void sub_10066A4D8(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  xpc_object_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  char v7 = *a3;
  xpc_object_t v11 = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v11 = xpc_null_create();
  }
  if (v4 || !*(void *)(a1 + 40))
  {
    int v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to get trace property", buf, 2u);
    }
  }
  else
  {
    xpc_object_t v9 = *(xpc_object_t **)(a1 + 24);
    if (v9 && xpc_get_type(*v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      v12[0] = &v11;
      v12[1] = abm::kKeyTracePropertyValue;
      sub_100048BAC((uint64_t)v12, &v13);
      *(void *)std::string buf = 0;
      int v19 = 0;
      uint64_t v20 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v20) < 0) {
        operator delete(*(void **)buf);
      }
      if (v15 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      xpc_object_t v16 = xpc_string_create(p_p);
      if (!v16) {
        xpc_object_t v16 = xpc_null_create();
      }
      *(void *)std::string buf = *(void *)(a1 + 24);
      int v19 = "kRadioTracePropertyValue";
      sub_100035E70((uint64_t)buf, &v16, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v16);
      xpc_object_t v16 = 0;
      if (v15 < 0) {
        operator delete(__p);
      }
      xpc_release(v13);
    }
    **(unsigned char **)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = 1;
  }
  xpc_release(v11);
  xpc_object_t v11 = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10066A6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  xpc_release(a10);
  if (v25 < 0) {
    operator delete(v24);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066A720(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10066A760()
{
}

void *sub_10066A76C(void *a1, void *a2)
{
  int v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    xpc_object_t v5 = a1[1];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = a2[3];
  a1[2] = a2[2];
  a1[3] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a2[5];
  a1[4] = a2[4];
  a1[5] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10066A7E0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = a1[1];
  if (v4)
  {
    dispatch_group_leave(v4);
    xpc_object_t v5 = a1[1];
    if (v5)
    {
      dispatch_release(v5);
    }
  }
}

void sub_10066A84C()
{
}

void *sub_10066A860(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F6438;
  result[1] = v3;
  return result;
}

uint64_t sub_10066A8A8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F6438;
  a2[1] = v2;
  return result;
}

void sub_10066A8D4(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  xpc_object_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    uint64_t v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v8, v11);
      uint64_t v7 = v12 >= 0 ? v11 : (void **)v11[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to generate JSON for reporting CommCenter crash. %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066A9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066AA3C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066AA7C()
{
}

void sub_10066AA88(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        xpc_object_t v5 = (uint64_t *)v3[1];
        sub_100060644(v3 + 2);
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

uint64_t *sub_10066AAFC(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v2 = *(void **)a1;
  unsigned int v3 = *(_DWORD *)(*(void *)a1 + 1184);
  if (v3 <= 6 && ((0x67u >> v3) & 1) != 0)
  {
    uint64_t v7 = v2[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if ((v3 & 0x7F) == 5) {
        int v8 = "is not";
      }
      else {
        int v8 = "is";
      }
      *(_DWORD *)std::string buf = 136315138;
      char v12 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Radio boot state %s healthy", buf, 0xCu);
    }
    sub_1000607A8(a1 + 8, (0x5Fu >> v3) & 1);
  }
  else
  {
    uint64_t v4 = v2[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Waiting to report radio boot health", buf, 2u);
    }
    xpc_object_t v5 = operator new(0x30uLL);
    *xpc_object_t v5 = 0;
    v5[1] = 0;
    sub_1000DFC90((uint64_t)(v5 + 2), a1 + 8);
    v5[1] = v2 + 87;
    uint64_t v6 = v2[87];
    *xpc_object_t v5 = v6;
    *(void *)(v6 + 8) = v5;
    v2[87] = v5;
    ++v2[89];
    sub_10065B75C(v2);
  }
  return sub_10031EA88(&v10);
}

void sub_10066AC80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v10);
  sub_10031EA88(&a10);
  _Unwind_Resume(a1);
}

void sub_10066ACA8()
{
}

void *sub_10066ACBC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F64B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10066AD04(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F64B8;
  a2[1] = v2;
  return result;
}

void *sub_10066AD30(void *result, unsigned char *a2)
{
  if (*a2)
  {
    if (*(void *)(result[1] + 736)) {
      sub_1006572D4(result[1]);
    }
    v2[3] = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    return sub_100060644(v2);
  }
  return result;
}

void sub_10066ADB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10066ADC8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066AE08()
{
}

uint64_t sub_10066AE14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10066AEAC(void *a1)
{
  *a1 = off_1019F6538;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10065C870(a1 + 1);
  return a1;
}

void sub_10066AF00(void *a1)
{
  *a1 = off_1019F6538;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10065C870(a1 + 1);

  operator delete();
}

char *sub_10066AF74(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v3 = off_1019F6538;
  sub_10066AE14((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 4sub_10010E764((uint64_t)&a9, 0) = *(_OWORD *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 56);
  *((void *)v3 + 7) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return v3;
}

void sub_10066AFF4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10066B008(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F6538;
  uint64_t result = sub_10066AE14(a2 + 8, a1 + 8);
  *(_OWORD *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = *(_OWORD *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a2 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_10066B074(uint64_t a1)
{
  return sub_10065BD18((void *)(a1 + 8));
}

void sub_10066B07C(void *a1)
{
  sub_10065BD18(a1 + 1);

  operator delete(a1);
}

void sub_10066B0B8(void *a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  xpc_object_t object = v7;
  if (v7 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v8 = (uint64_t)(a1 + 1);
  xpc_object_t v9 = (std::__shared_weak_count *)a1[7];
  if (v9)
  {
    uint64_t v10 = a1[5];
    xpc_object_t v11 = std::__shared_weak_count::lock(v9);
    if (v11 && a1[6])
    {
      if (!v4 && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
      {
        int v19 = 0;
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        *(void *)std::string buf = &object;
        *(void *)&uint8_t buf[8] = abm::kKeyBasebandRFFEData;
        sub_100048BAC((uint64_t)buf, &v18);
        memset(__p, 0, 24);
        xpc::dyn_cast_or_default();
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        xpc_release(v18);
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        *(_OWORD *)xpc_object_t v24 = 0u;
        *(_OWORD *)int v25 = 0u;
        long long v23 = 0u;
        memset(__p, 0, sizeof(__p));
        if (TelephonyRadiosGetRadioVendor() == 1)
        {
          int64_t v13 = v20 - (unsigned char *)v19;
          if (v20 != v19 && v13 == 50)
          {
            v12.i32[0] = *(_DWORD *)v19;
            *(uint32x4_t *)std::string __p = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v12));
            LODWORD(__p[2]) = *((unsigned __int8 *)v19 + 4);
            BYTE4(__p[2]) = *((unsigned char *)v19 + 5);
            *(uint32x4_t *)&__p[3] = vmovl_u16(*(uint16x4_t *)((char *)v19 + 6));
            LODWORD(__p[5]) = 0;
            BYTE4(__p[5]) = *((unsigned char *)v19 + 14);
            LODWORD(v23) = *((unsigned __int8 *)v19 + 15);
            DWORD1(v23) = *((unsigned __int8 *)v19 + 16);
            DWORD2(v23) = *((unsigned __int8 *)v19 + 17);
            sub_10006E4A8(v24, (char *)v19 + 18, (char *)v19 + 50, 0x20uLL);
            uint64_t v14 = *(NSObject **)(v10 + 40);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 67110400;
              *(_DWORD *)&uint8_t buf[4] = HIDWORD(__p[0]);
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = BYTE4(__p[2]);
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = BYTE4(__p[5]);
              *(_WORD *)&buf[20] = 1024;
              int v31 = v23;
              __int16 v32 = 1024;
              int v33 = DWORD1(v23);
              __int16 v34 = 1024;
              int v35 = DWORD2(v23);
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I RFFEScanData: prd_id=%d, rfc_init_pass=%d, rffe_scan_pass=%d num_expected_devices=%d, num_detected_devices=%d, num_missing_devices=%d", buf, 0x26u);
            }
            sub_10065BC60(v8, 1);
            if (*((void *)&v28 + 1))
            {
              *(void *)&long long v29 = *((void *)&v28 + 1);
              operator delete(*((void **)&v28 + 1));
            }
            if ((void)v27)
            {
              *((void *)&v27 + 1) = v27;
              operator delete((void *)v27);
            }
            if (v25[1])
            {
              *(void **)&long long v26 = v25[1];
              operator delete(v25[1]);
            }
            if (v24[0])
            {
              v24[1] = v24[0];
              operator delete(v24[0]);
            }
            char v15 = v19;
            if (!v19) {
              goto LABEL_51;
            }
            uint64_t v20 = v19;
            goto LABEL_50;
          }
          xpc_object_t v16 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 134218240;
            *(void *)&uint8_t buf[4] = v13;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = 50;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid RFFE scan data: size=%ld, expected_size=%lu", buf, 0x16u);
          }
        }
        if (*((void *)&v28 + 1))
        {
          *(void *)&long long v29 = *((void *)&v28 + 1);
          operator delete(*((void **)&v28 + 1));
        }
        if ((void)v27)
        {
          *((void *)&v27 + 1) = v27;
          operator delete((void *)v27);
        }
        if (v25[1])
        {
          *(void **)&long long v26 = v25[1];
          operator delete(v25[1]);
        }
        if (v24[0])
        {
          v24[1] = v24[0];
          operator delete(v24[0]);
        }
        if (v19)
        {
          uint64_t v20 = v19;
          operator delete(v19);
        }
      }
      *(void *)&long long v23 = 0;
      DWORD2(v23) = 0;
      __p[0] = 0;
      __p[1] = 0;
      *(void **)((char *)&__p[1] + 5) = 0;
      __p[3] = 0;
      __p[4] = 0;
      *(void **)((char *)&__p[4] + 5) = 0;
      *(_OWORD *)xpc_object_t v24 = 0u;
      *(_OWORD *)int v25 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      sub_10065BC60(v8, 0);
      if (*((void *)&v28 + 1))
      {
        *(void *)&long long v29 = *((void *)&v28 + 1);
        operator delete(*((void **)&v28 + 1));
      }
      if ((void)v27)
      {
        *((void *)&v27 + 1) = v27;
        operator delete((void *)v27);
      }
      if (v25[1])
      {
        *(void **)&long long v26 = v25[1];
        operator delete(v25[1]);
      }
      char v15 = v24[0];
      if (!v24[0]) {
        goto LABEL_51;
      }
      v24[1] = v24[0];
LABEL_50:
      operator delete(v15);
      goto LABEL_51;
    }
  }
  else
  {
    xpc_object_t v11 = 0;
  }
  *(void *)&long long v23 = 0;
  DWORD2(v23) = 0;
  __p[0] = 0;
  __p[1] = 0;
  *(void **)((char *)&__p[1] + 5) = 0;
  __p[3] = 0;
  __p[4] = 0;
  *(void **)((char *)&__p[4] + 5) = 0;
  *(_OWORD *)xpc_object_t v24 = 0u;
  *(_OWORD *)int v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  sub_10065BC60((uint64_t)(a1 + 1), 0);
  if (v11) {
LABEL_51:
  }
    sub_10004D2C8(v11);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10066B56C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10066B6C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10066B708()
{
}

void sub_10066B718()
{
}

void *sub_10066B72C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F65B8;
  result[1] = v3;
  return result;
}

uint64_t sub_10066B774(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F65B8;
  a2[1] = v2;
  return result;
}

void sub_10066B7A0(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)xpc_object_t v9 = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_100651340((uint64_t)&v8, __p);
      uint64_t v7 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Failed to update Bread Property. %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
}

void sub_10066B8C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066B904(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066B944()
{
}

uint64_t sub_10066B950(uint64_t result)
{
  **(unsigned char **)(*(void *)(result + 32) + 8) = *(_DWORD *)(**(void **)(result + 32) + 1164) == 1;
  return result;
}

void sub_10066B96C(uint64_t *a1, uint64_t a2, unsigned __int8 a3, char a4)
{
  uint64_t v5 = *a1;
  if (a3 != 5 && a3 != 255 && a4)
  {
    CFTypeRef cf = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 744));
    int v8 = ServiceMap;
    uint64_t v10 = v9;
    if (v9 < 0)
    {
      xpc_object_t v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v10;
    uint64_t v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      char v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v8);
    char v15 = 0;
    char v17 = 1;
LABEL_15:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v16 + 96))(&cf, v16, a2, 1, @"SupportsCellularLoggingAccess", kCFBooleanFalse, 0);
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    int v19 = (BOOL *)cf;
    buf[0] = 0;
    if (cf)
    {
      CFTypeID v20 = CFGetTypeID(cf);
      if (v20 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, v19, v21);
      }
    }
    int v22 = buf[0];
    long long v23 = (char *)a1[1];
    if (buf[0]) {
      BOOL v24 = *v23 == 0;
    }
    else {
      BOOL v24 = 1;
    }
    char v25 = !v24;
    *long long v23 = v25;
    v44[0] = 0;
    v44[1] = 0;
    uint64_t v45 = 0;
    long long v26 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 744));
    long long v27 = v26;
    if (v9 < 0)
    {
      long long v28 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v9 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v26);
    *(void *)std::string buf = v9;
    int v31 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      __int16 v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v27);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
LABEL_34:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v33 + 96))(__p, v33, a2, 1, @"CarrierName", 0, 0);
        memset(buf, 0, sizeof(buf));
        if (ctu::cf::assign())
        {
          *(_OWORD *)xpc_object_t v44 = *(_OWORD *)buf;
          uint64_t v45 = *(void *)&buf[16];
        }
        else
        {
          sub_100058DB0(v44, "");
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        sub_1000577C4((const void **)__p);
        if ((v34 & 1) == 0) {
          sub_10004D2C8(v32);
        }
        unsigned int v35 = subscriber::simSlotAsInstance();
        if (v35 >= 2) {
          sub_1000C14F0("array::at");
        }
        xpc_object_t v36 = (char *)*((void *)&unk_101B0D230 + v35 + 7);
        sub_100058DB0(buf, abm::kTraceBaseband);
        sub_100058DB0(__p, v36);
        (*(void (**)(uint64_t, uint8_t *, void **, void **))(*(void *)v5 + 224))(v5, buf, __p, v44);
        if (v43 < 0) {
          operator delete(__p[0]);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        xpc_object_t v37 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = subscriber::asString();
          xpc_object_t v39 = "false";
          if (v22) {
            xpc_object_t v39 = "true";
          }
          int v40 = *(unsigned __int8 *)a1[1];
          std::string v41 = v44;
          if (v45 < 0) {
            std::string v41 = (void **)v44[0];
          }
          *(_DWORD *)std::string buf = 136315906;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v39;
          *(_WORD *)&unsigned char buf[22] = 1024;
          int v48 = v40;
          __int16 v49 = 2080;
          xpc_object_t v50 = v41;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Slot: %s, Carrier Bundle for Logging: %s, allowed: %d, Carrier Name: %s", buf, 0x26u);
        }
        if (SHIBYTE(v45) < 0) {
          operator delete(v44[0]);
        }
        sub_1000577C4(&cf);
        return;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v27);
    __int16 v32 = 0;
    char v34 = 1;
    goto LABEL_34;
  }
  xpc_object_t v18 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle Error or is not ready. Force the present key as false", buf, 2u);
  }
  *(unsigned char *)a1[1] = 0;
}

void sub_10066BE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a22);
  _Unwind_Resume(a1);
}

void sub_10066BEF4()
{
}

void *sub_10066BF08(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F6658;
  result[1] = v3;
  return result;
}

uint64_t sub_10066BF50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F6658;
  a2[1] = v2;
  return result;
}

void sub_10066BF7C(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v8, v11);
      uint64_t v7 = v12 >= 0 ? v11 : (void **)v11[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to update PLMN: %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066C0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066C0E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066C124()
{
}

void sub_10066C134()
{
}

void *sub_10066C148(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F66D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10066C190(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F66D8;
  a2[1] = v2;
  return result;
}

void sub_10066C1BC(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v8, v11);
      uint64_t v7 = v12 >= 0 ? v11 : (void **)v11[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to update active call state: %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066C2E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066C324(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066C364()
{
}

void sub_10066C374()
{
}

void *sub_10066C388(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F6758;
  result[1] = v3;
  return result;
}

uint64_t sub_10066C3D0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F6758;
  a2[1] = v2;
  return result;
}

void sub_10066C3FC(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v8, v11);
      uint64_t v7 = v12 >= 0 ? v11 : (void **)v11[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to send cellId/TAC: %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066C524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066C564(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066C5A4()
{
}

void sub_10066C5B4()
{
}

void *sub_10066C5C8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F67D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10066C610(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F67D8;
  a2[1] = v2;
  return result;
}

void sub_10066C63C(uint64_t a1, int *a2, void **a3)
{
  int v8 = *a2;
  int v4 = v8;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v10 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      sub_100651340((uint64_t)&v8, v11);
      uint64_t v7 = v12 >= 0 ? v11 : (void **)v11[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to update ECBM state: %s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(v11[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066C764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066C7A4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066C7E4()
{
}

uint64_t sub_10066C7F0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = (int *)(a1 + 16);
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = (_DWORD *)(v3 + 32);
    if (operator!=())
    {
      int v5 = *v2;
      *(_WORD *)(v3 + 36) = *(_WORD *)(a1 + 20);
      *int v4 = v5;
      uint64_t v6 = *(void *)(v3 + 24);
      if (v6) {
        (*(void (**)(uint64_t, _DWORD *))(*(void *)v6 + 48))(v6, v4);
      }
    }
  }
  return a1;
}

void sub_10066C888()
{
}

__n128 sub_10066C89C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F6858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10066C8E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F6858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10066C918(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  int v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(NSObject **)(v8 + 40);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v10)
    {
      LODWORD(v11) = 136315138;
      *(void *)((char *)&v11 + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Setting operating mode = %s, failed", (uint8_t *)&v11, 0xCu);
    }
    *(void *)&long long v11 = 1;
    *((void *)&v11 + 1) = v8 + 304;
    uint64_t v12 = *(void *)(v8 + 336);
    LODWORD(v12) = *(_DWORD *)(a1 + 20);
    sub_10066C7F0((uint64_t)&v11);
  }
  else if (v10)
  {
    LODWORD(v11) = 136315138;
    *(void *)((char *)&v11 + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Setting operating mode = %s, succeeded", (uint8_t *)&v11, 0xCu);
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10066CA7C(_Unwind_Exception *a1)
{
  xpc_release(v2);
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066CAB8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066CAF8()
{
}

void sub_10066CB08(ATCSDPCQueue::Callback *a1)
{
  ATCSDPCQueue::Callback::~Callback(a1);

  operator delete();
}

uint64_t sub_10066CB40(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v2 = a1[3];
  int v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(uint64_t (**)(void *, void))(*v3 + v1);
  }
  return v1(v3, a1[4]);
}

uint64_t sub_10066CB90(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

void sub_10066CB9C()
{
}

__n128 sub_10066CBB0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019F6920;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10066CBFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F6920;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10066CC2C(uint64_t a1, int *a2, void **a3)
{
  int v10 = *a2;
  int v4 = v10;
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 2);
  uint64_t v12 = *((void *)a2 + 3);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  int v5 = *a3;
  *a3 = xpc_null_create();
  if (v4)
  {
    int v6 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = *(unsigned __int8 *)(a1 + 16);
      sub_100651340((uint64_t)&v10, v13);
      uint64_t v8 = "Block";
      if (!v7) {
        uint64_t v8 = "Unblock";
      }
      if (v14 >= 0) {
        uint64_t v9 = v13;
      }
      else {
        uint64_t v9 = (void **)v13[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v16 = v8;
      __int16 v17 = 2080;
      xpc_object_t v18 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to %s accessories: %s", buf, 0x16u);
      if (v14 < 0) {
        operator delete(v13[0]);
      }
    }
  }
  xpc_release(v5);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10066CD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10066CDBC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10066CDFC()
{
}

uint64_t sub_10066CE08()
{
  if ((byte_101B09D70 & 1) == 0)
  {
    byte_101B09D70 = 1;
    return __cxa_atexit((void (*)(void *))sub_100160564, &stru_101B09D20, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_10066CE44()
{
  sub_100058DB0(&qword_101B0D278, "/tmp/CommCenter.dumping");

  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0D278, (void *)&_mh_execute_header);
}

void sub_10066CF50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066CFE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D060(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D0E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D2A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D4FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D7BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D8D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066D9F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066DB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066DBF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10066DC5C()
{
}

void sub_10066DD3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_10066DD90(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  uint64_t v8 = (ctu::OsLogLogger *)(a1 + 8);
  uint64_t v9 = "nnh.mdl.?";
  if (a3 == 2) {
    uint64_t v9 = "time.mdl.2";
  }
  if (a3 == 1) {
    int v10 = "time.mdl.1";
  }
  else {
    int v10 = v9;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v13, &v12);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019F6AA8;
  *(void *)(a1 + 32) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void))(**(void **)a4 + 24))();
  *(_DWORD *)(a1 + 64) = a3;
  sub_100416058();
}

void sub_10066DF60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  char v15 = (std::__shared_weak_count *)*((void *)v12 + 12);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v12 + 10);
  if (v16) {
    sub_10004D2C8(v16);
  }
  __int16 v17 = (std::__shared_weak_count *)*((void *)v12 + 7);
  if (v17) {
    sub_10004D2C8(v17);
  }
  xpc_object_t v18 = (std::__shared_weak_count *)*((void *)v12 + 5);
  if (v18) {
    sub_10004D2C8(v18);
  }
  int v19 = (std::__shared_weak_count *)*((void *)v12 + 3);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  TimeHandlerModelInterface::~TimeHandlerModelInterface(v12);
  _Unwind_Resume(a1);
}

BOOL sub_10066DFF8(uint64_t a1, int a2, unsigned int *a3, MCCAndMNC *this)
{
  if (a2 != 2) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 296) || *(unsigned char *)(a1 + 297))
  {
    int v5 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    LOWORD(buf[0]) = 0;
    int v6 = "#I NITZ or CDMA time available, preparing to fetch network time";
LABEL_6:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)buf, 2u);
    return 1;
  }
  if ((a3[2] & 0xFFFFFFFE) != 4)
  {
    int v5 = *(NSObject **)(a1 + 8);
    BOOL v11 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v11) {
      return result;
    }
    LOWORD(buf[0]) = 0;
    OsLogContext v12 = "#N Device is not registered, cannot handle a fetch time";
    goto LABEL_20;
  }
  uint64_t v9 = *a3;
  MCCAndMNC::getMcc(buf, this);
  MCCAndMNC::getMnc(v13, this);
  int v10 = sub_100014D10(a1, (MCC *)buf, (const MCC *)v13, v9, 1);
  if (v14 < 0) {
    operator delete((void *)v13[1]);
  }
  if (v16 < 0) {
    operator delete((void *)buf[1]);
  }
  int v5 = *(NSObject **)(a1 + 8);
  BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (!result) {
      return 1;
    }
    LOWORD(buf[0]) = 0;
    int v6 = "#I Operator supports network time, but earlier fetch resulted in kNetworkTimeUnavailable, still going ahead and fetching time";
    goto LABEL_6;
  }
  if (result)
  {
    LOWORD(buf[0]) = 0;
    OsLogContext v12 = "#N Operator does not support network time, so not fetching time";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)buf, 2u);
    return 0;
  }
  return result;
}

void sub_10066E184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_10066E1B8(uint64_t a1, int a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 448))
  {
    uint64_t v8 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      std::to_string(&v18, a3);
      int v9 = SHIBYTE(v18.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v18.__r_.__value_.__r.__words[0];
      std::to_string(&__p, a4);
      BOOL v11 = &v18;
      if (v9 < 0) {
        BOOL v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      CFTypeID v20 = v11;
      __int16 v21 = 2080;
      int v22 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Saving GSM Network parameters with Area code: %s, Cell ID: %s", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v18.__r_.__value_.__l.__data_);
      }
    }
    *(_DWORD *)(a1 + 44sub_10010E764((uint64_t)&a9, 0) = a3;
    *(_DWORD *)(a1 + 444) = a4;
    sub_100B3BEAC(a1, a1 + 312);
  }
  sub_100416230(*(void *)(a1 + 72), a3, 1);
  if (*(_DWORD *)(a1 + 304) != a2) {
    *(_DWORD *)(a1 + 304) = a2;
  }
  uint64_t v13 = *(void *)(a1 + 88);
  if (*(_DWORD *)(v13 + 32)) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = a2 == 0;
  }
  if (!v14)
  {
    int v15 = *(_DWORD *)(a1 + 300);
    if (v15)
    {
      if ((a2 - v15) <= 0x78)
      {
        int v16 = *(_DWORD *)(*(void *)(a1 + 72) + 32);
        sub_100416230(v13, v16, 0);
      }
    }
  }
}

void sub_10066E398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10066E3BC(uint64_t *a1)
{
  *(uint64_t *)((char *)a1 + 30sub_10010E764((uint64_t)&a9, 0) = 0;
  sub_100416590(a1[9]);
  uint64_t v2 = a1[11];

  return sub_100416590(v2);
}

void sub_10066E400(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 8);
  int v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 300);
    int v10 = 67109120;
    LODWORD(v11) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Time update timestamp: %u", (uint8_t *)&v10, 8u);
    int v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 304);
    int v10 = 67109120;
    LODWORD(v11) = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I LAC update timestamp: %u", (uint8_t *)&v10, 8u);
    int v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 308);
    int v10 = 67109120;
    LODWORD(v11) = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I TAC update timestamp: %u", (uint8_t *)&v10, 8u);
    int v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asString();
    int v10 = 136315138;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Last visible RAT: %s", (uint8_t *)&v10, 0xCu);
    int v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 296)) {
      uint64_t v8 = "Available";
    }
    else {
      uint64_t v8 = "Unavailable";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I NITZ Time Availability: %s", (uint8_t *)&v10, 0xCu);
    int v3 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 297)) {
      int v9 = "Available";
    }
    else {
      int v9 = "Unavailable";
    }
    int v10 = 136315138;
    uint64_t v11 = (uint64_t)v9;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CDMA Time Availability: %s", (uint8_t *)&v10, 0xCu);
  }
  sub_100416658(*(void *)(a1 + 72));
  sub_100416658(*(void *)(a1 + 88));
  sub_100416740(a1 + 104, v2);
}

void sub_10066E660(uint64_t a1, uint64_t a2)
{
  if (a2 == 2)
  {
    if (*(unsigned char *)(a1 + 296)) {
      return;
    }
    *(unsigned char *)(a1 + 296) = 1;
  }
  else
  {
    if (a2 != 1 || *(unsigned char *)(a1 + 297)) {
      return;
    }
    *(unsigned char *)(a1 + 297) = 1;
  }
  int v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "???";
    if (a2 == 1) {
      int v5 = "cdma";
    }
    if (a2 == 2) {
      int v5 = "nitz";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Calling CoreTime to inform source %s is available", (uint8_t *)&v6, 0xCu);
  }
  (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 64), a2);
  sub_10066E7A4(a1, a2, 1);
}

void sub_10066E7A4(uint64_t a1, int a2, BOOL a3)
{
  xpc_object_t v17 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    xpc_object_t v17 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v17 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v8;
LABEL_9:
  xpc_release(v7);
  sub_100D3CAC8(a2);
  v18[1] = 0;
  uint64_t v19 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0u;
  uint64_t v21 = 0;
  xpc_object_t v15 = xpc_string_create((const char *)__p);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  v18[0] = &v17;
  v18[1] = "source";
  sub_100035E70((uint64_t)v18, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v13 = xpc_BOOL_create(a3);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  v18[0] = &v17;
  v18[1] = "availability";
  sub_100035E70((uint64_t)v18, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  int v9 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)v18, (xpc::object *)&v17);
    int v10 = v19 >= 0 ? v18 : (void **)v18[0];
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Time availability notification: %s", (uint8_t *)__p, 0xCu);
    if (SHIBYTE(v19) < 0) {
      operator delete(v18[0]);
    }
  }
  xpc_object_t v11 = v17;
  v18[0] = v17;
  if (v17)
  {
    xpc_retain(v17);
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    v18[0] = v11;
  }
  xpc_object_t v12 = xpc_null_create();
  __p[0] = v12;
  sub_1000452AC(133, v18, __p);
  xpc_release(v12);
  xpc_release(v11);
  xpc_release(v17);
}

void sub_10066EA38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10066EAE0(uint64_t a1, const void **a2, long long *a3, int a4, MCC *a5, MNC *a6, uint64_t a7, int a8, char a9)
{
  xpc_object_t v15 = (os_log_t *)(a1 + 8);
  int v16 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v17 = "Time";
    if (a9) {
      xpc_object_t v17 = "Time and Timezone";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s received with the following parameters", buf, 0xCu);
  }
  long long v18 = a3[1];
  v110[0] = *a3;
  v110[1] = v18;
  v110[2] = a3[2];
  uint64_t v111 = *((void *)a3 + 6);
  sub_100416C10(v15, (uint64_t)v110, a5, a6, a7, a8);
  if (a9)
  {
    long long v19 = a3[1];
    long long v106 = *a3;
    long long v107 = v19;
    long long v108 = a3[2];
    uint64_t v109 = *((void *)a3 + 6);
    if (a7 <= 0xA)
    {
      if (((1 << a7) & 0x605) != 0)
      {
        memset(&buf[4], 0, 52);
        uint64_t v122 = 0;
        *(_OWORD *)std::string __p = 0u;
        long long v121 = 0u;
        *(_OWORD *)std::string::size_type v118 = 0u;
        long long v119 = 0u;
        *(_DWORD *)std::string buf = -1;
        *(void *)&buf[29] = 0;
        *(void *)&uint8_t buf[56] = 0xFFFFFFFFLL;
        MCC::MCC((MCC *)v118);
        MNC::MNC((MNC *)__p);
        uint64_t v122 = 0;
        sub_10066FBBC(a1 + 312, (long long *)buf);
        if (SHIBYTE(v121) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(v119) < 0) {
          operator delete(v118[1]);
        }
        *(_DWORD *)(a1 + 312) = a7;
        long long v20 = v107;
        *(_OWORD *)(a1 + 32sub_10010E764((uint64_t)&a9, 0) = v106;
        *(_OWORD *)(a1 + 336) = v20;
        *(_OWORD *)(a1 + 352) = v108;
        *(_DWORD *)(a1 + 368) = v109;
        MCC::operator=();
        MCC::operator=();
        goto LABEL_39;
      }
      if (((1 << a7) & 0x28) != 0)
      {
        memset(&buf[4], 0, 52);
        long long v119 = 0u;
        *(_OWORD *)std::string __p = 0u;
        *(_OWORD *)std::string::size_type v118 = 0u;
        *(_DWORD *)std::string buf = -1;
        *(void *)&buf[29] = 0;
        *(void *)&uint8_t buf[56] = 0xFFFFFFFFLL;
        MCC::MCC((MCC *)v118);
        int v86 = a4;
        long long v23 = v15;
        __p[0] = 0;
        LODWORD(__p[1]) = 0;
        long long v24 = *(_OWORD *)&buf[16];
        *(_OWORD *)(a1 + 60sub_10010E764((uint64_t)&a9, 0) = *(_OWORD *)buf;
        *(_OWORD *)(a1 + 616) = v24;
        *(_OWORD *)(a1 + 632) = *(_OWORD *)&buf[32];
        *(_OWORD *)(a1 + 644) = *(_OWORD *)&buf[44];
        char v25 = (void **)(a1 + 696);
        if (*(unsigned char *)(a1 + 712))
        {
          MCC::operator=();
          ATCSMutex *v25 = __p[0];
          *(_DWORD *)(a1 + 704) = __p[1];
        }
        else
        {
          MCC::MCC((MCC *)(a1 + 664), (const MCC *)v118);
          ATCSMutex *v25 = __p[0];
          *(_DWORD *)(a1 + 704) = __p[1];
          *(unsigned char *)(a1 + 712) = 1;
        }
        xpc_object_t v15 = v23;
        if (SHIBYTE(v119) < 0) {
          operator delete(v118[1]);
        }
        *(_DWORD *)(a1 + 60sub_10010E764((uint64_t)&a9, 0) = a7;
        long long v28 = v107;
        *(_OWORD *)(a1 + 608) = v106;
        *(_OWORD *)(a1 + 624) = v28;
        *(_OWORD *)(a1 + 64sub_10010E764((uint64_t)&a9, 0) = v108;
        *(_DWORD *)(a1 + 656) = v109;
        MCC::operator=();
        a4 = v86;
        goto LABEL_39;
      }
      if (a7 == 7)
      {
        memset(&buf[4], 0, 52);
        uint64_t v122 = 0;
        *(_OWORD *)std::string __p = 0u;
        long long v121 = 0u;
        *(_OWORD *)std::string::size_type v118 = 0u;
        long long v119 = 0u;
        *(_DWORD *)std::string buf = -1;
        *(void *)&buf[29] = 0;
        *(void *)&uint8_t buf[56] = 0xFFFFFFFFLL;
        MCC::MCC((MCC *)v118);
        MNC::MNC((MNC *)__p);
        uint64_t v122 = 0;
        sub_10066FBBC(a1 + 456, (long long *)buf);
        if (SHIBYTE(v121) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(v119) < 0) {
          operator delete(v118[1]);
        }
        *(_DWORD *)(a1 + 456) = 7;
        long long v27 = v107;
        *(_OWORD *)(a1 + 464) = v106;
        *(_OWORD *)(a1 + 48sub_10010E764((uint64_t)&a9, 0) = v27;
        *(_OWORD *)(a1 + 496) = v108;
        *(_DWORD *)(a1 + 512) = v109;
        MCC::operator=();
        MCC::operator=();
        goto LABEL_39;
      }
    }
    long long v26 = *v15;
    if (!os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    *(_WORD *)std::string buf = 0;
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Failed to identify the source of the time update", buf, 2u);
    goto LABEL_39;
  }
  if (a7 > 0xA)
  {
LABEL_24:
    long long v26 = *v15;
    if (!os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    *(_WORD *)std::string buf = 0;
    goto LABEL_34;
  }
  if (((1 << a7) & 0x685) == 0)
  {
    if (((1 << a7) & 0x28) != 0) {
      goto LABEL_39;
    }
    goto LABEL_24;
  }
  int v21 = *((_DWORD *)a3 + 6);
  int v22 = *((_DWORD *)a3 + 12);
  memset(&buf[4], 0, 52);
  uint64_t v122 = 0;
  *(_OWORD *)std::string __p = 0u;
  long long v121 = 0u;
  *(_OWORD *)std::string::size_type v118 = 0u;
  long long v119 = 0u;
  *(_DWORD *)std::string buf = -1;
  *(void *)&buf[29] = 0;
  *(void *)&uint8_t buf[56] = 0xFFFFFFFFLL;
  MCC::MCC((MCC *)v118);
  MNC::MNC((MNC *)__p);
  uint64_t v122 = 0;
  sub_10066FBBC(a1 + 312, (long long *)buf);
  if (SHIBYTE(v121) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v119) < 0) {
    operator delete(v118[1]);
  }
  *(_DWORD *)(a1 + 312) = a7;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 32sub_10010E764((uint64_t)&a9, 0) = 0;
  *(_DWORD *)(a1 + 344) = v21;
  *(unsigned char *)(a1 + 348) = v22 == 1;
  *(_DWORD *)(a1 + 364) = 0;
  *(void *)(a1 + 357) = 0;
  *(void *)(a1 + 349) = 0;
  *(_DWORD *)(a1 + 368) = v22;
  MCC::operator=();
  MCC::operator=();
LABEL_39:
  if ((sub_100014D10(a1, a5, a6, a7, a8) & 1) == 0)
  {
    *(_DWORD *)(a1 + 68) = a7;
    sub_1000675C8(a1, 1);
    sub_1000675C8(a1, 2);
    return;
  }
  if (*(_DWORD *)(a1 + 300) != a4)
  {
    *(_DWORD *)(a1 + 30sub_10010E764((uint64_t)&a9, 0) = a4;
    uint64_t v29 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a4;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Timestamping Time update with %u", buf, 8u);
    }
  }
  sub_100416590(*(void *)(a1 + 88));
  sub_1000085A4(*(void *)(a1 + 88), a7, a5, a6);
  if ((a7 & 0xFFFFFFFD) != 0)
  {
    if (a7 != 10 && a7 != 7)
    {
      os_log_t v40 = *v15;
      if (!os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      uint64_t v41 = asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v41;
      xpc_object_t v36 = "#N Area code update is not applicable for RAT: %s";
      uint64_t v38 = v40;
      uint32_t v39 = 12;
      goto LABEL_62;
    }
    int v30 = *(_DWORD *)(a1 + 308);
    if (v30)
    {
      int v31 = *(_DWORD *)(a1 + 300);
      if (v31)
      {
        if ((v31 - v30) <= 0x14)
        {
          sub_1000683EC(*(void *)(a1 + 88), *(_DWORD *)(*(void *)(a1 + 72) + 36), 0);
          goto LABEL_63;
        }
      }
    }
    os_log_t v34 = *v15;
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      int v35 = *(_DWORD *)(a1 + 300);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v35;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v30;
      xpc_object_t v36 = "#N Time (%u) and TAC update (%u) timestamps don't match or valid";
LABEL_59:
      uint64_t v38 = v34;
      uint32_t v39 = 14;
LABEL_62:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v36, buf, v39);
    }
  }
  else
  {
    int v32 = *(_DWORD *)(a1 + 304);
    if (v32)
    {
      int v33 = *(_DWORD *)(a1 + 300);
      if (v33)
      {
        if ((v33 - v32) <= 0x14)
        {
          sub_100416230(*(void *)(a1 + 88), *(_DWORD *)(*(void *)(a1 + 72) + 32), 0);
          goto LABEL_63;
        }
      }
    }
    os_log_t v34 = *v15;
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = *(_DWORD *)(a1 + 300);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v37;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v32;
      xpc_object_t v36 = "#N Time (%u) and LAC update (%u) timestamps don't match or valid";
      goto LABEL_59;
    }
  }
LABEL_63:
  sub_10006750C(a1, a7, 1);
  xpc_object_t v88 = v15;
  if (a7 > 0xA) {
    uint64_t v42 = 0;
  }
  else {
    uint64_t v42 = dword_1014D60D0[(int)a7];
  }
  sub_100670390((const void **)&calendar, a2);
  TMGetKernelMonotonicClock();
  int v45 = *(_DWORD *)a3;
  int v44 = *((_DWORD *)a3 + 1);
  int v46 = *((_DWORD *)a3 + 2);
  int v47 = *((_DWORD *)a3 + 3);
  int v49 = *((_DWORD *)a3 + 4);
  uint64_t v48 = *((unsigned int *)a3 + 5);
  at[0] = 0.0;
  xpc_object_t v50 = calendar;
  if (calendar) {
    xpc_object_t v51 = sub_100670388;
  }
  else {
    xpc_object_t v51 = 0;
  }
  if (!v51)
  {
    xpc_object_t v55 = v88;
    xpc_object_t v58 = *v88;
    double v59 = 0.0;
    if (os_log_type_enabled(*v88, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Invalid gregorian calendar!", buf, 2u);
    }
    goto LABEL_82;
  }
  char v84 = v44;
  uint64_t v85 = v48;
  unsigned int v87 = v42;
  unsigned int v52 = v43;
  int v53 = a4;
  unsigned int v90 = v43 - a4;
  xpc_object_t v54 = *v88;
  if (os_log_type_enabled(*v88, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v53;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v52;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = v90;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Time update receival timestamp %u, current %u, with Time lag: %u", buf, 0x14u);
    xpc_object_t v50 = calendar;
  }
  uint64_t v42 = v87;
  if (CFCalendarComposeAbsoluteTime(v50, at, "yMdHms", v85, (char)v49, (char)v47, (char)v45, v84, (double)v46))
  {
    xpc_object_t v55 = v88;
    if (CFCalendarAddComponents(calendar, at, 0, "s", (double)v90)) {
      goto LABEL_81;
    }
    xpc_object_t v56 = *v88;
    if (!os_log_type_enabled(*v88, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_81;
    }
    *(_WORD *)std::string buf = 0;
    xpc_object_t v57 = "#N Could not add components to gregorian time";
    goto LABEL_80;
  }
  xpc_object_t v55 = v88;
  xpc_object_t v56 = *v88;
  if (os_log_type_enabled(*v88, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    xpc_object_t v57 = "#N Could not compose absolute gregorian time";
LABEL_80:
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v57, buf, 2u);
  }
LABEL_81:
  double v59 = at[0];
LABEL_82:
  sub_1006020EC((const void **)&calendar);
  (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 64), v42);
  if (a9)
  {
    xpc_object_t v60 = *v55;
    if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
    {
      if (v42 > 2) {
        xpc_object_t v61 = "???";
      }
      else {
        xpc_object_t v61 = off_1019F6BE0[(int)v42];
      }
      *(_DWORD *)std::string buf = 134218242;
      *(double *)&uint8_t buf[4] = v59;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v61;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Calling CoreTime to set provide time update with time %lf, from Source: %s", buf, 0x16u);
    }
    (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v42, v59);
  }
  IntCFDictionaryRef Value = MCC::getIntValue(a5);
  xpc_object_t v63 = *v55;
  BOOL v64 = os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT);
  if (IntValue < 0x3E8)
  {
    if (v64)
    {
      if (v42 > 2) {
        xpc_object_t v66 = "???";
      }
      else {
        xpc_object_t v66 = off_1019F6BE0[(int)v42];
      }
      *(_DWORD *)std::string buf = 134218242;
      *(double *)&uint8_t buf[4] = v59;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v66;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I Calling CoreTime to set provide timezone update with time %lf, from source: %s", buf, 0x16u);
    }
    uint64_t v68 = *(void *)(a1 + 48);
    uint64_t v69 = *(unsigned int *)(a1 + 64);
    long long v70 = a3[1];
    v103[0] = *a3;
    v103[1] = v70;
    v103[2] = a3[2];
    uint64_t v104 = *((void *)a3 + 6);
    MCC::MCC((MCC *)v100, a5);
    (*(void (**)(uint64_t, uint64_t, uint64_t, _OWORD *, unsigned char *, double))(*(void *)v68 + 40))(v68, v69, v42, v103, v100, v59);
    if (v102 < 0) {
      operator delete(v101);
    }
  }
  else if (v64)
  {
    if (v42 > 2) {
      uint64_t v65 = "???";
    }
    else {
      uint64_t v65 = off_1019F6BE0[(int)v42];
    }
    int v67 = MCC::getIntValue(a5);
    *(_DWORD *)std::string buf = 134218498;
    *(double *)&uint8_t buf[4] = v59;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v65;
    *(_WORD *)&unsigned char buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = v67;
    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#N Dropping timezone update %lf, from source %s due to invalid mcc %d", buf, 0x1Cu);
  }
  if (a9)
  {
    long long v96 = *a3;
    long long v97 = a3[1];
    long long v98 = a3[2];
    uint64_t v99 = *((void *)a3 + 6);
    if (v42 > 2) {
      xpc_object_t v71 = "???";
    }
    else {
      xpc_object_t v71 = off_1019F6BE0[(int)v42];
    }
    sub_100058DB0(buf, v71);
    *(_OWORD *)(a1 + 104) = v96;
    *(_OWORD *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v97;
    *(_OWORD *)(a1 + 136) = v98;
    *(_DWORD *)(a1 + 152) = v99;
    std::string::operator=((std::string *)(a1 + 248), (const std::string *)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v72 = a3[1];
    *(_OWORD *)std::string buf = *a3;
    *(_OWORD *)&uint8_t buf[16] = v72;
    *(_OWORD *)&unsigned char buf[32] = a3[2];
    *(void *)&buf[48] = *((void *)a3 + 6);
    xpc_object_t object = 0;
    sub_10066FE78(&object, (int *)buf, v42);
    char v73 = *v55;
    if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)at, (xpc::object *)&object);
      uint64_t v74 = v113 >= 0 ? at : *(CFAbsoluteTime **)&at[0];
      *(_DWORD *)uint64_t v123 = 136315138;
      *(void *)&v123[4] = v74;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I Time update notification: %s", v123, 0xCu);
      if (v113 < 0) {
        operator delete(*(void **)&at[0]);
      }
    }
    xpc_object_t v75 = object;
    *(void *)&at[0] = object;
    if (object)
    {
      xpc_retain(object);
    }
    else
    {
      xpc_object_t v75 = xpc_null_create();
      *(void *)&at[0] = v75;
    }
    xpc_object_t v76 = xpc_null_create();
    *(void *)uint64_t v123 = v76;
    sub_1000452AC(131, (xpc_object_t *)at, (xpc_object_t *)v123);
    xpc_release(v76);
    xpc_release(v75);
    xpc_release(object);
  }
  long long v92 = *a3;
  long long v93 = a3[1];
  long long v94 = a3[2];
  uint64_t v95 = *((void *)a3 + 6);
  if (v42 > 2) {
    uint64_t v77 = "???";
  }
  else {
    uint64_t v77 = off_1019F6BE0[(int)v42];
  }
  sub_100058DB0(buf, v77);
  *(_OWORD *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = v92;
  *(_OWORD *)(a1 + 176) = v93;
  *(_OWORD *)(a1 + 192) = v94;
  *(_DWORD *)(a1 + 208) = v95;
  MCC::operator=();
  std::string::operator=((std::string *)(a1 + 272), (const std::string *)buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  long long v78 = a3[1];
  *(_OWORD *)std::string buf = *a3;
  *(_OWORD *)&uint8_t buf[16] = v78;
  *(_OWORD *)&unsigned char buf[32] = a3[2];
  *(void *)&buf[48] = *((void *)a3 + 6);
  xpc_object_t object = 0;
  sub_10066FE78(&object, (int *)buf, v42);
  unsigned int v79 = MCC::getIntValue(a5);
  xpc_object_t v114 = xpc_int64_create(v79);
  if (!v114) {
    xpc_object_t v114 = xpc_null_create();
  }
  *(void *)&at[0] = &object;
  *(void *)&at[1] = "mcc";
  sub_100035E70((uint64_t)at, &v114, &v115);
  xpc_release(v115);
  xpc_object_t v115 = 0;
  xpc_release(v114);
  xpc_object_t v114 = 0;
  uint64_t v80 = *v55;
  if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)at, (xpc::object *)&object);
    CFBooleanRef v81 = v113 >= 0 ? at : *(CFAbsoluteTime **)&at[0];
    *(_DWORD *)uint64_t v123 = 136315138;
    *(void *)&v123[4] = v81;
    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I Timezone update notification: %s", v123, 0xCu);
    if (v113 < 0) {
      operator delete(*(void **)&at[0]);
    }
  }
  xpc_object_t v82 = object;
  *(void *)&at[0] = object;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v82 = xpc_null_create();
    *(void *)&at[0] = v82;
  }
  xpc_object_t v83 = xpc_null_create();
  *(void *)uint64_t v123 = v83;
  sub_1000452AC(132, (xpc_object_t *)at, (xpc_object_t *)v123);
  xpc_release(v83);
  xpc_release(v82);
  xpc_release(object);
}

void sub_10066FA88(_Unwind_Exception *a1)
{
}

uint64_t sub_10066FBBC(uint64_t a1, long long *a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 136);
  long long v6 = a2[1];
  long long v5 = a2[2];
  long long v7 = *(long long *)((char *)a2 + 44);
  long long v9 = *a2;
  xpc_object_t v8 = (const MCC *)(a2 + 4);
  *(_OWORD *)(a1 + 44) = v7;
  *(_OWORD *)(a1 + 16) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v9;
  int v10 = (MCC *)(a1 + 64);
  if (v4)
  {
    MCC::operator=();
    MCC::operator=();
    *(void *)(a1 + 128) = *((void *)a2 + 16);
  }
  else
  {
    MCC::MCC(v10, v8);
    MCC::MCC((MCC *)(a1 + 96), (const MCC *)(a2 + 6));
    *(void *)(a1 + 128) = *((void *)a2 + 16);
    *(unsigned char *)(a1 + 136) = 1;
  }
  return a1;
}

void sub_10066FC50(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*(void **)(v1 + 72));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10066FC6C(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  return a1;
}

void sub_10066FCB0(uint64_t a1, int a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 712))
  {
    xpc_object_t v8 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      long long v9 = &v16;
      std::to_string(&v16, a2);
      if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v9 = (std::string *)v16.__r_.__value_.__r.__words[0];
      }
      std::to_string(&v15, a3);
      int v10 = SHIBYTE(v15.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v15.__r_.__value_.__r.__words[0];
      std::to_string(&v14, a4);
      xpc_object_t v12 = &v15;
      if (v10 < 0) {
        xpc_object_t v12 = (std::string *)v11;
      }
      if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        xpc_object_t v13 = &v14;
      }
      else {
        xpc_object_t v13 = (std::string *)v14.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315650;
      long long v18 = v9;
      __int16 v19 = 2080;
      long long v20 = v12;
      __int16 v21 = 2080;
      int v22 = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Saving CDMA Network parameters with SID: %s, NID: %s, Base ID: %s", buf, 0x20u);
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v14.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v15.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v16.__r_.__value_.__l.__data_);
      }
    }
    *(_DWORD *)(a1 + 696) = a2;
    *(_DWORD *)(a1 + 70sub_10010E764((uint64_t)&a9, 0) = a3;
    *(_DWORD *)(a1 + 704) = a4;
    sub_100B3C2E8(a1, a1 + 600);
  }
}

void sub_10066FE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_10066FE78(void *a1, int *a2, int a3)
{
  *a1 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  if (v6)
  {
    *a1 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    *a1 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  *a1 = v8;
LABEL_9:
  xpc_release(v7);
  xpc_object_t v30 = xpc_int64_create(a2[3]);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "day";
  sub_100035E70((uint64_t)&v32, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v28 = xpc_int64_create(a2[4]);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "month";
  sub_100035E70((uint64_t)&v32, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_object_t v26 = xpc_int64_create(a2[5]);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "year";
  sub_100035E70((uint64_t)&v32, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_object_t v24 = xpc_int64_create(*a2);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "hour";
  sub_100035E70((uint64_t)&v32, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_object_t v22 = xpc_int64_create(a2[1]);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "minute";
  sub_100035E70((uint64_t)&v32, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_object_t v20 = xpc_int64_create(a2[2]);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "second";
  sub_100035E70((uint64_t)&v32, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_object_t v18 = xpc_int64_create(a2[6]);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "TZ";
  sub_100035E70((uint64_t)&v32, &v18, &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_object_t v16 = xpc_BOOL_create(*((unsigned char *)a2 + 28));
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "dst";
  sub_100035E70((uint64_t)&v32, &v16, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v14 = xpc_int64_create(a2[12]);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "dst-abs";
  sub_100035E70((uint64_t)&v32, &v14, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  sub_100D3CAC8(a3);
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v32;
  uint64_t v11 = v33;
  if (v33 >= 0) {
    long long v9 = __p;
  }
  else {
    long long v9 = (void **)__p[0];
  }
  xpc_object_t v12 = xpc_string_create((const char *)v9);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = "source";
  sub_100035E70((uint64_t)&v32, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1006702A8(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 49) < 0) {
    operator delete(*(void **)(v2 - 72));
  }
  sub_10017143C(v1);
  _Unwind_Resume(a1);
}

void sub_100670350(uint64_t a1)
{
  sub_1006703C8(a1);

  operator delete();
}

uint64_t sub_100670388(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_100670390(const void **a1, const void **a2)
{
  int v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void sub_1006703C8(uint64_t a1)
{
  *(void *)a1 = off_1019F6AA8;
  if (*(unsigned char *)(a1 + 712) && *(char *)(a1 + 695) < 0) {
    operator delete(*(void **)(a1 + 672));
  }
  sub_1006704B4(a1 + 456);
  sub_1006704B4(a1 + 312);
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  if (*(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5) {
    sub_10004D2C8(v5);
  }
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  TimeHandlerModelInterface::~TimeHandlerModelInterface((TimeHandlerModelInterface *)a1);
}

uint64_t sub_1006704B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
  }
  return a1;
}

void sub_100670500(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100670580(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1006705BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1006705F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100670624(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void CarrierBundleHandler::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100670CDC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, ctu::OsLogLogger *a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

void sub_100671074(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100671010);
}

void sub_10067109C()
{
}

const char *sub_1006710A4(int a1)
{
  uint64_t v1 = "cb.client.?";
  if (a1 == 2) {
    uint64_t v1 = "cb.client.2";
  }
  if (a1 == 1) {
    return "cb.client.1";
  }
  else {
    return v1;
  }
}

void *sub_1006710D0(uint64_t a1)
{
  sub_100087F94(a1 + 32, *(void **)(a1 + 40));

  return sub_100687BA8((void *)a1);
}

void sub_100671110(uint64_t a1)
{
  *(void *)a1 = off_1019F6C10;
  sub_1000346F8(a1 + 2312, *(void **)(a1 + 2320));
  sub_10003FB28(a1 + 2280, *(void **)(a1 + 2288));
  sub_100687B24((void *)(a1 + 2240));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 2224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100087F94(a1 + 2192, *(void **)(a1 + 2200));
  sub_100687BA8((void *)(a1 + 2160));
  sub_100087F94(a1 + 2136, *(void **)(a1 + 2144));
  sub_100687BA8((void *)(a1 + 2104));
  uint64_t v11 = (void **)(a1 + 2072);
  sub_1000C56F4(&v11);
  int v3 = *(std::__shared_weak_count **)(a1 + 2064);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100136194(a1 + 1256);
  sub_100136194(a1 + 456);
  int v4 = *(std::__shared_weak_count **)(a1 + 448);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_10007CA64((const void **)(a1 + 416));
  if (*(char *)(a1 + 407) < 0) {
    operator delete(*(void **)(a1 + 384));
  }
  sub_100688B38(a1 + 360, *(void **)(a1 + 368));
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  sub_100688A7C(a1 + 312, *(void **)(a1 + 320));
  sub_1006889C0(a1 + 288, *(void **)(a1 + 296));
  sub_100057D78((const void **)(a1 + 280));
  sub_10068895C(*(char **)(a1 + 264));
  sub_10068895C(*(char **)(a1 + 240));
  sub_1000346F8(a1 + 208, *(void **)(a1 + 216));
  uint64_t v11 = (void **)(a1 + 184);
  sub_100687C2C(&v11);
  sub_1006888D0(*(void **)(a1 + 168));
  sub_100688868(*(const void ***)(a1 + 144));
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 128);
  if (v6) {
    sub_10004D2C8(v6);
  }
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 112);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100160A84((atomic_uint **)(a1 + 64));
  long long v9 = *(NSObject **)(a1 + 56);
  if (v9) {
    dispatch_release(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  CarrierBundleInterface::~CarrierBundleInterface((CarrierBundleInterface *)a1);
}

void sub_100671330(uint64_t a1)
{
  sub_100671110(a1);

  operator delete();
}

void sub_100671368(uint64_t a1, dispatch_object_t object)
{
  int v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_100671460(uint64_t a1, xpc_object_t object, dispatch_object_t *a3)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  uint64_t v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  long long v6 = 0uLL;
  sub_10003E168(&v6, (void *)(a1 + 8));
  xpc_null_create();
  long long v6 = 0uLL;
  operator new();
}

void sub_100671594(void *a1, uint64_t a2)
{
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFC8[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = *(_OWORD *)v15;
  *(void *)(a2 + 16) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFD0[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  int v4 = (void **)(a2 + 24);
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)int v4 = *(_OWORD *)v15;
  *(void *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFD8[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  uint64_t v5 = (void **)(a2 + 48);
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)uint64_t v5 = *(_OWORD *)v15;
  *(void *)(a2 + 64) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFE0[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  long long v6 = (void **)(a2 + 72);
  if (*(char *)(a2 + 95) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)long long v6 = *(_OWORD *)v15;
  *(void *)(a2 + 88) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFE8[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  xpc_object_t v7 = (void **)(a2 + 96);
  if (*(char *)(a2 + 119) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)xpc_object_t v7 = *(_OWORD *)v15;
  *(void *)(a2 + 112) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFF0[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  uint64_t v8 = (void **)(a2 + 128);
  if (*(char *)(a2 + 151) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v15;
  *(void *)(a2 + 144) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0AFF8[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  long long v9 = (void **)(a2 + 152);
  if (*(char *)(a2 + 175) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)long long v9 = *(_OWORD *)v15;
  *(void *)(a2 + 168) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  uint64_t v12 = a1;
  xpc_object_t v13 = off_101B0B000[0];
  sub_100048BAC((uint64_t)&v12, &object);
  std::string __p = 0;
  xpc_object_t v18 = 0;
  uint64_t v19 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v19) < 0) {
    operator delete(__p);
  }
  uint64_t v10 = (void **)(a2 + 176);
  if (*(char *)(a2 + 199) < 0) {
    operator delete(*v10);
  }
  *(_OWORD *)uint64_t v10 = *(_OWORD *)v15;
  *(void *)(a2 + 192) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15[0]) = 0;
  xpc_release(object);
  std::string __p = a1;
  xpc_object_t v18 = off_101B0B008[0];
  sub_100048BAC((uint64_t)&__p, v15);
  *(unsigned char *)(a2 + 12sub_10010E764((uint64_t)&a9, 0) = xpc::dyn_cast_or_default((xpc *)v15, 0, v11);
  xpc_release(v15[0]);
}

void sub_100671998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

const void **sub_100671AF0(uint64_t a1, uint64_t a2)
{
  os_log_t v34 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v5 = v34;
    os_log_t v34 = Mutable;
    *(void *)&long long v14 = v5;
    sub_10005717C((const void **)&v14);
  }
  CFDictionarySetValue(v34, (const void *)qword_101B13EC0, @"Default.bundle");
  sub_10004EFE4(&v33, (CFTypeRef *)&v34);
  long long v32 = 0;
  int v31 = 0;
  v36[0] = off_1019F7CD8;
  v36[3] = v36;
  char v6 = sub_100671D84(a2, 4u, &v33, &v32, (WirelessTechnologyList *)&v31, 0, 1, (uint64_t)v36);
  sub_10003B34C(v36);
  sub_100057D78(&v32);
  sub_100057D78(&v33);
  sub_100673654(a2, 4u, v6, 1);
  uint64_t v13 = 0x100000004;
  int v35 = &v13;
  xpc_object_t v7 = sub_100688D4C((uint64_t **)(a2 + 136), (unsigned __int8 *)&v13, (uint64_t)&unk_10144E20E, &v35);
  sub_10000BE9C((uint64_t)&v14, (uint64_t)(v7 + 40));
  *(void *)(a1 + 16) = v15;
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v17;
  *(void *)(a1 + 64) = v19;
  *(void *)(a1 + 88) = v21;
  *(void *)(a1 + 112) = v23;
  *(unsigned char *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v24;
  uint64_t v8 = v28;
  *(void *)(a1 + 144) = v26;
  *(_OWORD *)a1 = v14;
  long long v14 = 0uLL;
  long long v9 = v16;
  uint64_t v15 = 0;
  *(void *)&long long v16 = 0;
  *(_OWORD *)(a1 + 24) = v9;
  *((void *)&v16 + 1) = 0;
  uint64_t v17 = 0;
  *(_OWORD *)(a1 + 48) = v18;
  long long v18 = 0uLL;
  *(_OWORD *)(a1 + 72) = v20;
  uint64_t v19 = 0;
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  *(_OWORD *)(a1 + 96) = v22;
  long long v22 = 0uLL;
  *(_OWORD *)(a1 + 128) = v25;
  uint64_t v23 = 0;
  long long v25 = 0uLL;
  long long v10 = v27;
  *(void *)(a1 + 168) = v8;
  *(_OWORD *)(a1 + 152) = v10;
  uint64_t v28 = 0;
  uint64_t v26 = 0;
  long long v27 = 0uLL;
  long long v11 = v29;
  *(void *)(a1 + 192) = v30;
  *(_OWORD *)(a1 + 176) = v11;
  long long v29 = 0uLL;
  uint64_t v30 = 0;
  *(unsigned char *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = v6;
  sub_10000BDF8((uint64_t)&v14);
  return sub_10005717C((const void **)&v34);
}

void sub_100671D44(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 - 96));
  _Unwind_Resume(a1);
}

uint64_t sub_100671D84(uint64_t a1, unsigned int a2, const void **a3, const void **a4, WirelessTechnologyList *a5, int a6, uint64_t a7, uint64_t a8)
{
  long long v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a7);
  uint64_t v182 = 0;
  v181 = 0;
  uint64_t v15 = (Registry **)(a1 + 104);
  sub_100058198(&v180, a3);
  sub_100058198(&v179, a4);
  sub_100044108((uint64_t)buf, (os_log_t *)(a1 + 40), (Registry **)(a1 + 104), &v180, &v179);
  *(void *)&long long __dst = v182;
  uint64_t v182 = *(void **)buf;
  *(void *)std::string buf = 0;
  sub_100057D78((const void **)&__dst);
  *(void *)&long long __dst = v181;
  v181 = *(const void **)&buf[8];
  *(void *)&uint8_t buf[8] = 0;
  sub_100057D78((const void **)&__dst);
  int v16 = buf[16];
  sub_100057D78((const void **)&buf[8]);
  sub_100057D78((const void **)buf);
  sub_100057D78(&v179);
  sub_100057D78(&v180);
  if (v182) {
    uint64_t v17 = sub_100080778;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17 && CFDictionaryGetCount((CFDictionaryRef)v182))
  {
    int v147 = v16;
    unsigned int v151 = a2;
    int64_t value = a2;
    long long v18 = (void *)(a2 | ((unint64_t)a7 << 32));
    *(void *)&long long __dst = v18;
    *(void *)std::string buf = &__dst;
    int v144 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf)[160];
    *(void *)&long long __dst = v18;
    *(void *)std::string buf = &__dst;
    if (*((void *)sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf)+ 30))uint64_t v19 = sub_100080778; {
    else
    }
      uint64_t v19 = 0;
    v150 = v19;
    *(void *)&long long __dst = v18;
    *(void *)std::string buf = &__dst;
    v155 = (uint64_t **)(a1 + 136);
    long long v20 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
    BOOL v152 = isSame((const void **)v20 + 30, (const void **)&v182);
    if (!v152)
    {
      uint64_t v21 = *v14;
      if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s: Matching info has changed", buf, 0xCu);
      }
      *(void *)&long long __dst = v18;
      *(void *)std::string buf = &__dst;
      uint64_t v23 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
      sub_100058140((const void **)v23 + 30, (const void **)&v182);
    }
    *(void *)&long long __dst = v18;
    *(void *)std::string buf = &__dst;
    char v24 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
    BOOL v149 = isSame((const void **)v24 + 31, &v181);
    if (!v149)
    {
      long long v25 = *v14;
      if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s: Activation info has changed", buf, 0xCu);
      }
      *(void *)&long long __dst = v18;
      *(void *)std::string buf = &__dst;
      long long v27 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
      sub_100058140((const void **)v27 + 31, &v181);
    }
    *(void *)&long long __dst = v18;
    *(void *)std::string buf = &__dst;
    int v145 = *((_DWORD *)sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf) + 64);
    int v146 = *(_DWORD *)a5;
    if (v145 != *(_DWORD *)a5)
    {
      uint64_t v28 = *v14;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = asString();
        xpc_object_t v178 = v18;
        __p[0] = &v178;
        uint64_t v30 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
        WirelessTechnologyList::asString((uint64_t *)&__dst, (WirelessTechnologyList *)(v30 + 256));
        int v31 = SBYTE7(__dst_16);
        long long v32 = (long long *)__dst;
        WirelessTechnologyList::asString((uint64_t *)__p, a5);
        p_dst = &__dst;
        if (v31 < 0) {
          p_dst = v32;
        }
        if (v177 >= 0) {
          os_log_t v34 = __p;
        }
        else {
          os_log_t v34 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v29;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = p_dst;
        *(_WORD *)&unsigned char buf[22] = 2082;
        *(void *)&uint8_t buf[24] = v34;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: Wireless tech has changed from %{public}s to %{public}s", buf, 0x20u);
        if (v177 < 0) {
          operator delete(__p[0]);
        }
        if (SBYTE7(__dst_16) < 0) {
          operator delete((void *)__dst);
        }
        uint64_t v15 = (Registry **)(a1 + 104);
      }
      *(void *)&long long __dst = v18;
      *(void *)std::string buf = &__dst;
      *((_DWORD *)sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf) + 64) = *(_DWORD *)a5;
    }
    if ((a6 & v152) != 1) {
      goto LABEL_147;
    }
    long long v188 = 0u;
    long long v189 = 0u;
    long long v186 = 0u;
    long long v187 = 0u;
    long long v184 = 0u;
    long long v185 = 0u;
    memset(buf, 0, sizeof(buf));
    uint64_t v175 = v182;
    if (v182) {
      CFRetain(v182);
    }
    CarrierBundleHandler::lookupBundle_sync(a1, v151, &v175, (uint64_t)buf);
    sub_100057D78(&v175);
    long long v173 = 0u;
    long long v174 = 0u;
    long long v171 = 0u;
    long long v172 = 0u;
    long long v170 = 0u;
    long long __dst_16 = 0u;
    long long v169 = 0u;
    long long __dst = 0u;
    xpc_object_t v178 = v18;
    __p[0] = &v178;
    int v35 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
    std::string::operator=((std::string *)((char *)&__dst_16 + 8), (const std::string *)(v35 + 64));
    xpc_object_t v178 = v18;
    __p[0] = &v178;
    xpc_object_t v36 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
    std::string::operator=((std::string *)&__dst, (const std::string *)(v36 + 40));
    xpc_object_t v178 = v18;
    __p[0] = &v178;
    int v37 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
    std::string::operator=((std::string *)((char *)&v171 + 8), (const std::string *)(v37 + 112));
    xpc_object_t v178 = v18;
    __p[0] = &v178;
    uint64_t v38 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
    std::string::operator=((std::string *)&v170, (const std::string *)(v38 + 88));
    xpc_object_t v178 = v18;
    __p[0] = &v178;
    uint32_t v39 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)__p);
    std::string::operator=((std::string *)&v173, (const std::string *)(v39 + 136));
    uint64_t v40 = buf[23];
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v41 = buf[23];
    }
    else {
      uint64_t v41 = *(void *)&buf[8];
    }
    uint64_t v42 = BYTE7(__dst_16);
    if (SBYTE7(__dst_16) < 0) {
      uint64_t v42 = *((void *)&__dst + 1);
    }
    if (v41 != v42) {
      goto LABEL_117;
    }
    if ((SBYTE7(__dst_16) & 0x80u) == 0) {
      double v43 = (unsigned __int8 *)&__dst;
    }
    else {
      double v43 = (unsigned __int8 *)__dst;
    }
    if ((buf[23] & 0x80) != 0)
    {
      if (memcmp(*(const void **)buf, v43, *(size_t *)&buf[8])) {
        goto LABEL_117;
      }
    }
    else if (buf[23])
    {
      int v44 = buf;
      while (*v44 == *v43)
      {
        ++v44;
        ++v43;
        if (!--v40) {
          goto LABEL_53;
        }
      }
      goto LABEL_117;
    }
LABEL_53:
    uint64_t v49 = HIBYTE(v184);
    if (v184 >= 0) {
      uint64_t v50 = HIBYTE(v184);
    }
    else {
      uint64_t v50 = v184;
    }
    uint64_t v51 = HIBYTE(v169);
    if (v169 < 0) {
      uint64_t v51 = v169;
    }
    if (v50 != v51) {
      goto LABEL_117;
    }
    if (v169 >= 0) {
      unsigned int v52 = (unsigned __int8 *)&__dst_16 + 8;
    }
    else {
      unsigned int v52 = (unsigned __int8 *)*((void *)&__dst_16 + 1);
    }
    if ((HIBYTE(v184) & 0x80) != 0)
    {
      if (memcmp(*(const void **)&buf[24], v52, v184)) {
        goto LABEL_117;
      }
    }
    else if (HIBYTE(v184))
    {
      int v53 = &buf[24];
      while (*v53 == *v52)
      {
        ++v53;
        ++v52;
        if (!--v49) {
          goto LABEL_69;
        }
      }
      goto LABEL_117;
    }
LABEL_69:
    uint64_t v54 = BYTE7(v186);
    if ((SBYTE7(v186) & 0x80u) == 0) {
      uint64_t v55 = BYTE7(v186);
    }
    else {
      uint64_t v55 = *((void *)&v185 + 1);
    }
    uint64_t v56 = BYTE7(v171);
    if (SBYTE7(v171) < 0) {
      uint64_t v56 = *((void *)&v170 + 1);
    }
    if (v55 != v56) {
      goto LABEL_117;
    }
    if ((SBYTE7(v171) & 0x80u) == 0) {
      xpc_object_t v57 = &v170;
    }
    else {
      xpc_object_t v57 = (long long *)v170;
    }
    if ((BYTE7(v186) & 0x80) != 0)
    {
      if (memcmp((const void *)v185, v57, *((size_t *)&v185 + 1))) {
        goto LABEL_117;
      }
    }
    else if (BYTE7(v186))
    {
      xpc_object_t v58 = (unsigned __int8 *)&v185;
      while (*v58 == *(unsigned __int8 *)v57)
      {
        ++v58;
        xpc_object_t v57 = (long long *)((char *)v57 + 1);
        if (!--v54) {
          goto LABEL_85;
        }
      }
      goto LABEL_117;
    }
LABEL_85:
    uint64_t v59 = HIBYTE(v187);
    if (v187 >= 0) {
      uint64_t v60 = HIBYTE(v187);
    }
    else {
      uint64_t v60 = v187;
    }
    uint64_t v61 = HIBYTE(v172);
    if (v172 < 0) {
      uint64_t v61 = v172;
    }
    if (v60 != v61) {
      goto LABEL_117;
    }
    if (v172 >= 0) {
      xpc_object_t v62 = (unsigned __int8 *)&v171 + 8;
    }
    else {
      xpc_object_t v62 = (unsigned __int8 *)*((void *)&v171 + 1);
    }
    if ((HIBYTE(v187) & 0x80) != 0)
    {
      if (memcmp(*((const void **)&v186 + 1), v62, v187)) {
        goto LABEL_117;
      }
    }
    else if (HIBYTE(v187))
    {
      xpc_object_t v63 = (unsigned __int8 *)&v186 + 8;
      while (*v63 == *v62)
      {
        ++v63;
        ++v62;
        if (!--v59) {
          goto LABEL_101;
        }
      }
      goto LABEL_117;
    }
LABEL_101:
    uint64_t v64 = BYTE7(v189);
    if ((SBYTE7(v189) & 0x80u) == 0) {
      uint64_t v65 = BYTE7(v189);
    }
    else {
      uint64_t v65 = *((void *)&v188 + 1);
    }
    uint64_t v66 = BYTE7(v174);
    if (SBYTE7(v174) < 0) {
      uint64_t v66 = *((void *)&v173 + 1);
    }
    if (v65 == v66)
    {
      if ((SBYTE7(v174) & 0x80u) == 0) {
        int v67 = &v173;
      }
      else {
        int v67 = (long long *)v173;
      }
      if ((BYTE7(v189) & 0x80) == 0)
      {
        if (BYTE7(v189))
        {
          uint64_t v68 = (unsigned __int8 *)&v188;
          char v69 = 1;
          while (*v68 == *(unsigned __int8 *)v67)
          {
            ++v68;
            int v67 = (long long *)((char *)v67 + 1);
            if (!--v64) {
              goto LABEL_119;
            }
          }
          goto LABEL_117;
        }
LABEL_280:
        char v69 = 1;
        goto LABEL_119;
      }
      if (!memcmp((const void *)v188, v67, *((size_t *)&v188 + 1))) {
        goto LABEL_280;
      }
    }
LABEL_117:
    long long v70 = *(NSObject **)(a1 + 40);
    char v69 = 0;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Updated bundle available for same carrier info. Considering as inputs changed", (uint8_t *)__p, 2u);
      char v69 = 0;
    }
LABEL_119:
    if (SBYTE7(v174) < 0) {
      operator delete((void *)v173);
    }
    if (SHIBYTE(v172) < 0) {
      operator delete(*((void **)&v171 + 1));
    }
    if (SBYTE7(v171) < 0) {
      operator delete((void *)v170);
    }
    if (SHIBYTE(v169) < 0) {
      operator delete(*((void **)&__dst_16 + 1));
    }
    if (SBYTE7(__dst_16) < 0) {
      operator delete((void *)__dst);
    }
    if (SBYTE7(v189) < 0) {
      operator delete((void *)v188);
    }
    if (SHIBYTE(v187) < 0) {
      operator delete(*((void **)&v186 + 1));
    }
    if (SBYTE7(v186) < 0) {
      operator delete((void *)v185);
    }
    if (SHIBYTE(v184) < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    if (v147) {
      BOOL v71 = v145 == v146;
    }
    else {
      BOOL v71 = 1;
    }
    if (v71) {
      char v72 = v69;
    }
    else {
      char v72 = 0;
    }
    if (v72)
    {
      int v47 = 0;
LABEL_167:
      uint64_t v81 = a7 << 32;
      switch(v151)
      {
        case 1u:
        case 4u:
          if (v47
            || (*(char *)(a1 + 407) < 0 ? (uint64_t v102 = *(void *)(a1 + 392)) : (uint64_t v102 = *(unsigned __int8 *)(a1 + 407)), !v102))
          {
            CarrierBundleHandler::evaluateBestPathToPLMNTable_sync(a1, a7);
            CarrierBundleHandler::evaluateBestPathToEquivalentBundleTable_sync(a1, a7);
          }
          switch(v151)
          {
            case 1u:
              if (!v47) {
                goto LABEL_270;
              }
              uint64_t v103 = v15;
              if (a7 == 2) {
                xpc_object_t v83 = &kCarrier2BundleId;
              }
              else {
                xpc_object_t v83 = &kCarrier1BundleId;
              }
              ServiceMap = (std::mutex *)Registry::getServiceMap(*v103);
              BOOL v105 = ServiceMap;
              if (v106 < 0)
              {
                long long v107 = (unsigned __int8 *)(v106 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v108 = 5381;
                do
                {
                  uint64_t v106 = v108;
                  unsigned int v109 = *v107++;
                  uint64_t v108 = (33 * v108) ^ v109;
                }
                while (v109);
              }
              std::mutex::lock(ServiceMap);
              *(void *)std::string buf = v106;
              xpc_object_t v110 = sub_10004D37C(&v105[1].__m_.__sig, (unint64_t *)buf);
              if (v110)
              {
                uint64_t v92 = v110[3];
                uint64_t v91 = (std::__shared_weak_count *)v110[4];
                if (v91)
                {
                  atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v105);
                  atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v91);
                  char v93 = 0;
                  goto LABEL_262;
                }
              }
              else
              {
                uint64_t v92 = 0;
              }
              std::mutex::unlock(v105);
              uint64_t v91 = 0;
              char v93 = 1;
LABEL_262:
              *(void *)&long long __dst = v81 | 1;
              *(void *)std::string buf = &__dst;
              long long v130 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
              if (v130[239] < 0) {
                goto LABEL_264;
              }
              *(_OWORD *)std::string buf = *(_OWORD *)(v130 + 216);
              *(void *)&uint8_t buf[16] = *((void *)v130 + 29);
              break;
            case 2u:
              goto LABEL_212;
            case 3u:
              goto LABEL_205;
            case 4u:
              goto LABEL_235;
            default:
              goto LABEL_270;
          }
          goto LABEL_265;
        case 2u:
LABEL_212:
          if (!v47) {
            goto LABEL_270;
          }
          long long v121 = v15;
          if (a7 == 2) {
            xpc_object_t v83 = &kOperator2BundleId;
          }
          else {
            xpc_object_t v83 = &kOperator1BundleId;
          }
          uint64_t v122 = (std::mutex *)Registry::getServiceMap(*v121);
          uint64_t v123 = v122;
          if (v124 < 0)
          {
            CFTypeRef v125 = (unsigned __int8 *)(v124 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v126 = 5381;
            do
            {
              uint64_t v124 = v126;
              unsigned int v127 = *v125++;
              uint64_t v126 = (33 * v126) ^ v127;
            }
            while (v127);
          }
          std::mutex::lock(v122);
          *(void *)std::string buf = v124;
          unint64_t v128 = sub_10004D37C(&v123[1].__m_.__sig, (unint64_t *)buf);
          if (v128)
          {
            uint64_t v92 = v128[3];
            uint64_t v91 = (std::__shared_weak_count *)v128[4];
            if (v91)
            {
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v123);
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v91);
              char v93 = 0;
              goto LABEL_228;
            }
          }
          else
          {
            uint64_t v92 = 0;
          }
          std::mutex::unlock(v123);
          uint64_t v91 = 0;
          char v93 = 1;
LABEL_228:
          *(void *)&long long __dst = v81 | 2;
          *(void *)std::string buf = &__dst;
          long long v130 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
          if (v130[239] < 0) {
            goto LABEL_264;
          }
          *(_OWORD *)std::string buf = *(_OWORD *)(v130 + 216);
          *(void *)&uint8_t buf[16] = *((void *)v130 + 29);
          goto LABEL_265;
        case 3u:
LABEL_205:
          if (!v47) {
            goto LABEL_270;
          }
          uint64_t v111 = (std::mutex *)Registry::getServiceMap(*v15);
          uint64_t v112 = v111;
          if (v113 < 0)
          {
            xpc_object_t v114 = (unsigned __int8 *)(v113 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v115 = 5381;
            do
            {
              uint64_t v113 = v115;
              unsigned int v116 = *v114++;
              uint64_t v115 = (33 * v115) ^ v116;
            }
            while (v116);
          }
          std::mutex::lock(v111);
          *(void *)std::string buf = v113;
          char v117 = sub_10004D37C(&v112[1].__m_.__sig, (unint64_t *)buf);
          if (v117)
          {
            uint64_t v119 = v117[3];
            std::string::size_type v118 = (std::__shared_weak_count *)v117[4];
            if (v118)
            {
              atomic_fetch_add_explicit(&v118->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v112);
              atomic_fetch_add_explicit(&v118->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v118);
              char v120 = 0;
              goto LABEL_224;
            }
          }
          else
          {
            uint64_t v119 = 0;
          }
          std::mutex::unlock(v112);
          std::string::size_type v118 = 0;
          char v120 = 1;
LABEL_224:
          *(void *)&long long __dst = 0x100000003;
          *(void *)std::string buf = &__dst;
          unsigned int v129 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
          if (v129[239] < 0)
          {
            sub_10004FC84(buf, *((void **)v129 + 27), *((void *)v129 + 28));
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)(v129 + 216);
            *(void *)&uint8_t buf[16] = *((void *)v129 + 29);
          }
          (*(void (**)(uint64_t, void, uint8_t *))(*(void *)v119 + 56))(v119, kBootstrapBundleId, buf);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          if ((v120 & 1) == 0) {
            sub_10004D2C8(v118);
          }
LABEL_235:
          if (!v47) {
            goto LABEL_270;
          }
          long long v131 = (std::mutex *)Registry::getServiceMap(*v15);
          uint64_t v132 = v131;
          if (v133 < 0)
          {
            v134 = (unsigned __int8 *)(v133 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v135 = 5381;
            do
            {
              uint64_t v133 = v135;
              unsigned int v136 = *v134++;
              uint64_t v135 = (33 * v135) ^ v136;
            }
            while (v136);
          }
          std::mutex::lock(v131);
          *(void *)&long long __dst = v133;
          v137 = sub_10004D37C(&v132[1].__m_.__sig, (unint64_t *)&__dst);
          if (v137)
          {
            uint64_t v138 = v137[3];
            uint64_t v91 = (std::__shared_weak_count *)v137[4];
            if (v91)
            {
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v132);
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v91);
              char v93 = 0;
              goto LABEL_245;
            }
          }
          else
          {
            uint64_t v138 = 0;
          }
          std::mutex::unlock(v132);
          uint64_t v91 = 0;
          char v93 = 1;
LABEL_245:
          __p[0] = &dword_100000004;
          *(void *)&long long __dst = __p;
          v139 = sub_100688D4C(v155, (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, (void **)&__dst);
          if (v139[239] < 0)
          {
            sub_10004FC84(&__dst, *((void **)v139 + 27), *((void *)v139 + 28));
          }
          else
          {
            long long __dst = *(_OWORD *)(v139 + 216);
            *(void *)&long long __dst_16 = *((void *)v139 + 29);
          }
          (*(void (**)(uint64_t, void, long long *))(*(void *)v138 + 56))(v138, kDefaultBundleId, &__dst);
          if ((SBYTE7(__dst_16) & 0x80000000) == 0) {
            goto LABEL_268;
          }
          v140 = (void *)__dst;
          goto LABEL_267;
        case 5u:
          if (!v47) {
            goto LABEL_270;
          }
          long long v94 = v15;
          if (a7 == 2) {
            xpc_object_t v83 = &kCarrier2CountryBundleId;
          }
          else {
            xpc_object_t v83 = &kCarrier1CountryBundleId;
          }
          uint64_t v95 = (std::mutex *)Registry::getServiceMap(*v94);
          long long v96 = v95;
          if (v97 < 0)
          {
            long long v98 = (unsigned __int8 *)(v97 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v99 = 5381;
            do
            {
              uint64_t v97 = v99;
              unsigned int v100 = *v98++;
              uint64_t v99 = (33 * v99) ^ v100;
            }
            while (v100);
          }
          std::mutex::lock(v95);
          *(void *)std::string buf = v97;
          uint64_t v101 = sub_10004D37C(&v96[1].__m_.__sig, (unint64_t *)buf);
          if (v101)
          {
            uint64_t v92 = v101[3];
            uint64_t v91 = (std::__shared_weak_count *)v101[4];
            if (v91)
            {
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v96);
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v91);
              char v93 = 0;
              goto LABEL_256;
            }
          }
          else
          {
            uint64_t v92 = 0;
          }
          std::mutex::unlock(v96);
          uint64_t v91 = 0;
          char v93 = 1;
LABEL_256:
          *(void *)&long long __dst = v81 | 5;
          *(void *)std::string buf = &__dst;
          long long v130 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
          if (v130[239] < 0) {
            goto LABEL_264;
          }
          *(_OWORD *)std::string buf = *(_OWORD *)(v130 + 216);
          *(void *)&uint8_t buf[16] = *((void *)v130 + 29);
          goto LABEL_265;
        case 6u:
          if (!v47) {
            goto LABEL_270;
          }
          xpc_object_t v82 = v15;
          if (a7 == 2) {
            xpc_object_t v83 = &kOperator2CountryBundleId;
          }
          else {
            xpc_object_t v83 = &kOperator1CountryBundleId;
          }
          char v84 = (std::mutex *)Registry::getServiceMap(*v82);
          uint64_t v85 = v84;
          if (v86 < 0)
          {
            unsigned int v87 = (unsigned __int8 *)(v86 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v88 = 5381;
            do
            {
              uint64_t v86 = v88;
              unsigned int v89 = *v87++;
              uint64_t v88 = (33 * v88) ^ v89;
            }
            while (v89);
          }
          std::mutex::lock(v84);
          *(void *)std::string buf = v86;
          unsigned int v90 = sub_10004D37C(&v85[1].__m_.__sig, (unint64_t *)buf);
          if (v90)
          {
            uint64_t v92 = v90[3];
            uint64_t v91 = (std::__shared_weak_count *)v90[4];
            if (v91)
            {
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v85);
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v91);
              char v93 = 0;
              goto LABEL_252;
            }
          }
          else
          {
            uint64_t v92 = 0;
          }
          std::mutex::unlock(v85);
          uint64_t v91 = 0;
          char v93 = 1;
LABEL_252:
          *(void *)&long long __dst = v81 | 6;
          *(void *)std::string buf = &__dst;
          long long v130 = sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
          if (v130[239] < 0)
          {
LABEL_264:
            sub_10004FC84(buf, *((void **)v130 + 27), *((void *)v130 + 28));
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)(v130 + 216);
            *(void *)&uint8_t buf[16] = *((void *)v130 + 29);
          }
LABEL_265:
          (*(void (**)(uint64_t, void, uint8_t *))(*(void *)v92 + 56))(v92, *v83, buf);
          if ((char)buf[23] < 0)
          {
            v140 = *(void **)buf;
LABEL_267:
            operator delete(v140);
          }
LABEL_268:
          if ((v93 & 1) == 0) {
            sub_10004D2C8(v91);
          }
LABEL_270:
          char v141 = v152;
          if (!v150) {
            char v141 = 1;
          }
          if ((v141 & 1) == 0)
          {
            uint64_t v142 = *(void *)(a8 + 24);
            if (!v142) {
              sub_10007B600();
            }
            (*(void (**)(uint64_t, long long *))(*(void *)v142 + 48))(v142, v67);
          }
          if (v152 && v149)
          {
            *(void *)&long long __dst = v18;
            *(void *)std::string buf = &__dst;
            if (v144 == sub_100688D4C(v155, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf)[160]&& !v47)
            {
              goto LABEL_51;
            }
          }
          int v48 = 1;
          break;
        default:
          goto LABEL_270;
      }
      goto LABEL_279;
    }
LABEL_147:
    *(void *)&long long __dst = 0;
    xpc_object_t v73 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v74 = v73;
    if (v73)
    {
      *(void *)&long long __dst = v73;
    }
    else
    {
      xpc_object_t v74 = xpc_null_create();
      *(void *)&long long __dst = v74;
      if (!v74)
      {
        xpc_object_t v75 = xpc_null_create();
        xpc_object_t v74 = 0;
        goto LABEL_154;
      }
    }
    if (xpc_get_type(v74) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v74);
LABEL_155:
      xpc_release(v74);
      xpc_object_t v165 = xpc_string_create(off_101B0AEC8[0]);
      if (!v165) {
        xpc_object_t v165 = xpc_null_create();
      }
      *(void *)std::string buf = &__dst;
      *(char **)&uint8_t buf[8] = off_101B0AEB0[0];
      sub_100035E70((uint64_t)buf, &v165, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v165);
      xpc_object_t v165 = 0;
      xpc_object_t v163 = xpc_int64_create(value);
      if (!v163) {
        xpc_object_t v163 = xpc_null_create();
      }
      *(void *)std::string buf = &__dst;
      *(char **)&uint8_t buf[8] = off_101B0AF70[0];
      sub_100035E70((uint64_t)buf, &v163, &v164);
      xpc_release(v164);
      xpc_object_t v164 = 0;
      xpc_release(v163);
      xpc_object_t v163 = 0;
      xpc_object_t v161 = xpc_int64_create((int)a7);
      if (!v161) {
        xpc_object_t v161 = xpc_null_create();
      }
      *(void *)std::string buf = &__dst;
      *(char **)&uint8_t buf[8] = off_101B0AF50[0];
      sub_100035E70((uint64_t)buf, &v161, &v162);
      xpc_release(v162);
      xpc_object_t v162 = 0;
      xpc_release(v161);
      xpc_object_t v161 = 0;
      ctu::cf_to_xpc((uint64_t *)&v159, (ctu *)v182, v76);
      *(void *)std::string buf = &__dst;
      *(char **)&uint8_t buf[8] = off_101B0AF40[0];
      sub_100035E70((uint64_t)buf, &v159, &v160);
      xpc_release(v160);
      xpc_object_t v160 = 0;
      xpc_release(v159);
      xpc_object_t v159 = 0;
      xpc_object_t v157 = xpc_int64_create(*(unsigned int *)a5);
      if (!v157) {
        xpc_object_t v157 = xpc_null_create();
      }
      *(void *)std::string buf = &__dst;
      *(char **)&uint8_t buf[8] = off_101B0AF48[0];
      sub_100035E70((uint64_t)buf, &v157, &v158);
      xpc_release(v158);
      xpc_object_t v158 = 0;
      xpc_release(v157);
      __p[0] = 0;
      uint64_t v77 = *(void *)(a1 + 120);
      xpc_object_t v156 = (xpc_object_t)__dst;
      xpc_object_t v157 = 0;
      if ((void)__dst) {
        xpc_retain((xpc_object_t)__dst);
      }
      else {
        xpc_object_t v156 = xpc_null_create();
      }
      (*(void (**)(void **__return_ptr, uint64_t, xpc_object_t *))(*(void *)v77 + 16))(__p, v77, &v156);
      xpc_release(v156);
      xpc_object_t v156 = 0;
      xpc_object_t v178 = v18;
      *(void *)std::string buf = &v178;
      long long v78 = sub_100688D4C(v155, (unsigned __int8 *)&v178, (uint64_t)&unk_10144E20E, (void **)buf);
      sub_100671594(__p, (uint64_t)(v78 + 40));
      *(void *)std::string buf = __p;
      *(char **)&uint8_t buf[8] = off_101B0B010[0];
      sub_100048BAC((uint64_t)buf, &v178);
      unsigned __int8 v80 = xpc::dyn_cast_or_default((xpc *)&v178, 0, v79);
      xpc_release(v178);
      xpc_release(__p[0]);
      xpc_release((xpc_object_t)__dst);
      int v47 = v80;
      goto LABEL_167;
    }
    xpc_object_t v75 = xpc_null_create();
LABEL_154:
    *(void *)&long long __dst = v75;
    goto LABEL_155;
  }
  int v45 = *v14;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v46 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v46;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#N Invalid carrier info for %s, not processing it", buf, 0xCu);
  }
  int v47 = 0;
LABEL_51:
  int v48 = 0;
LABEL_279:
  sub_100057D78(&v181);
  sub_100057D78((const void **)&v182);
  return v47 | (v48 << 8);
}

void sub_100673420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,xpc_object_t a49,uint64_t a50,uint64_t a51,uint64_t a52,xpc_object_t object,uint64_t a54,uint64_t a55,const void *a56)
{
  if (*(char *)(v58 - 217) < 0) {
    operator delete(*(void **)(v58 - 240));
  }
  if ((v57 & 1) == 0) {
    sub_10004D2C8(v56);
  }
  sub_100057D78(&a56);
  sub_100057D78((const void **)(v58 - 256));
  _Unwind_Resume(a1);
}

void *sub_100673654(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
  long long v97 = 0u;
  long long v98 = 0u;
  long long v9 = (NSObject **)v8;
  switch(a2)
  {
    case 1u:
      __p[0] = (void *)((a4 << 32) | 1);
      buf[0].opaque[0] = (uint64_t)__p;
      long long v10 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, buf);
      long long v11 = v10;
      memset(__p, 0, sizeof(__p));
      memset(&v85, 0, sizeof(v85));
      LOBYTE(__p[0]) = a3;
      BYTE1(__p[0]) = v10[160];
      if (v10[87] < 0)
      {
        sub_10004FC84(&__p[1], *((void **)v10 + 8), *((void *)v10 + 9));
      }
      else
      {
        *(_OWORD *)&__p[1] = *((_OWORD *)v10 + 4);
        __p[3] = *((void **)v10 + 10);
      }
      if (v11[159] < 0) {
        sub_10004FC84(&v85, *((void **)v11 + 17), *((void *)v11 + 18));
      }
      else {
        std::string v85 = *(std::string *)(v11 + 136);
      }
      os_log_t v34 = *v9;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = asString();
        uint64_t v36 = asString();
        if (SHIBYTE(__p[3]) >= 0) {
          int v37 = &__p[1];
        }
        else {
          int v37 = (void **)__p[1];
        }
        if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v38 = &v85;
        }
        else {
          uint64_t v38 = (std::string *)v85.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].opaque[0]) = 136315906;
        *(uint64_t *)((char *)buf[0].opaque + 4) = v35;
        WORD2(buf[0].opaque[1]) = 2080;
        *(uint64_t *)((char *)&buf[0].opaque[1] + 6) = v36;
        HIWORD(buf[1].opaque[0]) = 2082;
        buf[1].opaque[1] = (uint64_t)v37;
        LOWORD(v10sub_10010E764((uint64_t)&a9, 0) = 2082;
        *(void *)((char *)&v100 + 2) = v38;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I CarrierBundleChange: %s : %s : %{public}s : %{public}s", (uint8_t *)buf, 0x2Au);
      }
      __int16 v81 = (__int16)__p[0];
      if (SHIBYTE(__p[3]) < 0) {
        sub_10004FC84(&v82, __p[1], (unint64_t)__p[2]);
      }
      else {
        std::string v82 = *(std::string *)&__p[1];
      }
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v83, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
      }
      else {
        std::string v83 = v85;
      }
      LODWORD(v93) = a4;
      if (a4 == 2)
      {
        int v44 = "SIM Slot_2: Updating Carrier Bundle";
      }
      else if (a4 == 1)
      {
        int v44 = "SIM Slot_1: Updating Carrier Bundle";
      }
      else
      {
        int v44 = "SIM Slot_Unknown: Updating Carrier Bundle";
      }
      v90[0] = _os_activity_create((void *)&_mh_execute_header, v44, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
      buf[0].opaque[0] = 0;
      buf[0].opaque[1] = 0;
      os_activity_scope_enter((os_activity_t)v90[0], buf);
      os_activity_scope_leave(buf);
      sub_100687EB8(v90);
      uint64_t v86 = 1;
      uint64_t v87 = a1 + 2104;
      buf[0].opaque[0] = (uint64_t)&v93;
      uint64_t v65 = sub_100699824((uint64_t **)(a1 + 2136), (int *)&v93, (uint64_t)&unk_10144E20E, buf);
      *((_WORD *)v65 + 2sub_10010E764((uint64_t)&a9, 0) = v81;
      std::string::operator=((std::string *)v65 + 2, &v82);
      std::string::operator=((std::string *)v65 + 3, &v83);
      sub_100687EEC((uint64_t)buf, v93, (uint64_t)&v81);
      object[0] = 0;
      rest::write_rest_value();
      sub_100058DB0(v90, "/cc/events/carrier_bundle_event");
      v96.__vftable = (std::runtime_error_vtbl *)object[0];
      object[0] = xpc_null_create();
      ctu::RestModule::sendEvent();
      xpc_release(v96.__vftable);
      v96.__vftable = 0;
      if (SBYTE7(v91) < 0) {
        operator delete(v90[0]);
      }
      xpc_release(object[0]);
      if (SBYTE7(v101) < 0) {
        operator delete((void *)v100);
      }
      if (SHIBYTE(buf[1].opaque[1]) < 0) {
        operator delete((void *)buf[0].opaque[1]);
      }
      sub_1006997C0((uint64_t)&v86);
      if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v83.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v82.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_113;
      }
      uint64_t v66 = (void *)v82.__r_.__value_.__r.__words[0];
      goto LABEL_112;
    case 2u:
      __p[0] = (void *)((a4 << 32) | 2);
      buf[0].opaque[0] = (uint64_t)__p;
      long long v32 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, buf);
      uint64_t v33 = v32;
      memset(__p, 0, sizeof(__p));
      memset(&v85, 0, sizeof(v85));
      LOBYTE(__p[0]) = a3;
      BYTE1(__p[0]) = v32[160];
      if (v32[87] < 0)
      {
        sub_10004FC84(&__p[1], *((void **)v32 + 8), *((void *)v32 + 9));
      }
      else
      {
        *(_OWORD *)&__p[1] = *((_OWORD *)v32 + 4);
        __p[3] = *((void **)v32 + 10);
      }
      if (v33[159] < 0) {
        sub_10004FC84(&v85, *((void **)v33 + 17), *((void *)v33 + 18));
      }
      else {
        std::string v85 = *(std::string *)(v33 + 136);
      }
      uint32_t v39 = *v9;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = asString();
        uint64_t v41 = asString();
        if (SHIBYTE(__p[3]) >= 0) {
          uint64_t v42 = &__p[1];
        }
        else {
          uint64_t v42 = (void **)__p[1];
        }
        if ((v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          double v43 = &v85;
        }
        else {
          double v43 = (std::string *)v85.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf[0].opaque[0]) = 136315906;
        *(uint64_t *)((char *)buf[0].opaque + 4) = v40;
        WORD2(buf[0].opaque[1]) = 2080;
        *(uint64_t *)((char *)&buf[0].opaque[1] + 6) = v41;
        HIWORD(buf[1].opaque[0]) = 2082;
        buf[1].opaque[1] = (uint64_t)v42;
        LOWORD(v10sub_10010E764((uint64_t)&a9, 0) = 2082;
        *(void *)((char *)&v100 + 2) = v43;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I OperatorBundleChange: %s : %s : %{public}s : %{public}s", (uint8_t *)buf, 0x2Au);
      }
      __int16 v78 = (__int16)__p[0];
      if (SHIBYTE(__p[3]) < 0) {
        sub_10004FC84(&v79, __p[1], (unint64_t)__p[2]);
      }
      else {
        std::string v79 = *(std::string *)&__p[1];
      }
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v80, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
      }
      else {
        std::string v80 = v85;
      }
      LODWORD(v93) = a4;
      if (a4 == 2)
      {
        int v45 = "SIM Slot_2: Updating Operator Bundle";
      }
      else if (a4 == 1)
      {
        int v45 = "SIM Slot_1: Updating Operator Bundle";
      }
      else
      {
        int v45 = "SIM Slot_Unknown: Updating Operator Bundle";
      }
      v90[0] = _os_activity_create((void *)&_mh_execute_header, v45, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
      buf[0].opaque[0] = 0;
      buf[0].opaque[1] = 0;
      os_activity_scope_enter((os_activity_t)v90[0], buf);
      os_activity_scope_leave(buf);
      sub_100687EB8(v90);
      uint64_t v86 = 1;
      uint64_t v87 = a1 + 2160;
      buf[0].opaque[0] = (uint64_t)&v93;
      int v67 = sub_100699824((uint64_t **)(a1 + 2192), (int *)&v93, (uint64_t)&unk_10144E20E, buf);
      *((_WORD *)v67 + 2sub_10010E764((uint64_t)&a9, 0) = v78;
      std::string::operator=((std::string *)v67 + 2, &v79);
      std::string::operator=((std::string *)v67 + 3, &v80);
      sub_100687EEC((uint64_t)buf, v93, (uint64_t)&v78);
      object[0] = 0;
      rest::write_rest_value();
      sub_100058DB0(v90, "/cc/events/operator_bundle_event");
      v96.__vftable = (std::runtime_error_vtbl *)object[0];
      object[0] = xpc_null_create();
      ctu::RestModule::sendEvent();
      xpc_release(v96.__vftable);
      v96.__vftable = 0;
      if (SBYTE7(v91) < 0) {
        operator delete(v90[0]);
      }
      xpc_release(object[0]);
      if (SBYTE7(v101) < 0) {
        operator delete((void *)v100);
      }
      if (SHIBYTE(buf[1].opaque[1]) < 0) {
        operator delete((void *)buf[0].opaque[1]);
      }
      sub_100699924((uint64_t)&v86);
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v80.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0)
      {
        uint64_t v66 = (void *)v79.__r_.__value_.__r.__words[0];
LABEL_112:
        operator delete(v66);
      }
LABEL_113:
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v85.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p[3]) < 0)
      {
        operator delete(__p[1]);
        if (!a3) {
          return sub_10003B34C(&v97);
        }
      }
      else if (!a3)
      {
        return sub_10003B34C(&v97);
      }
LABEL_117:
      switch(a2)
      {
        case 4u:
          (*(void (**)(void))(**(void **)(a1 + 2216) + 40))(*(void *)(a1 + 2216));
          break;
        case 2u:
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 2216) + 32))(*(void *)(a1 + 2216), a4);
          if (sub_100682218(a1) == a4)
          {
            DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
            CFNotificationCenterPostNotification(DarwinNotifyCenter, @"NewOperatorNotification", 0, 0, 0);
            xpc_object_t v74 = xpc_null_create();
            buf[0].opaque[0] = (uint64_t)v74;
            xpc_object_t v75 = xpc_null_create();
            __p[0] = v75;
            sub_1000452AC(102, (xpc_object_t *)buf, __p);
            xpc_release(v75);
            xpc_release(v74);
          }
          break;
        case 1u:
          buf[0].opaque[0] = 0;
          sub_10067C934((const void **)buf, a1, a4);
          uint64_t v68 = (CFStringRef *)&kCarrier2BundleId;
          if (a4 != 2) {
            uint64_t v68 = (CFStringRef *)&kCarrier1BundleId;
          }
          CFPreferencesSetValue(*v68, (CFPropertyListRef)buf[0].opaque[0], @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 2216) + 16))(*(void *)(a1 + 2216), a4);
          if (sub_100682218(a1) == a4)
          {
            char v69 = CFNotificationCenterGetDarwinNotifyCenter();
            CFNotificationCenterPostNotification(v69, @"NewCarrierNotification", 0, 0, 0);
            long long v70 = CFNotificationCenterGetDarwinNotifyCenter();
            CFNotificationCenterPostNotification(v70, kCTCarrierSettingsNewCarrierNotification, 0, 0, 0);
            xpc_object_t v71 = xpc_null_create();
            __p[0] = v71;
            xpc_object_t v72 = xpc_null_create();
            v90[0] = v72;
            sub_1000452AC(101, __p, v90);
            xpc_release(v72);
            xpc_release(v71);
          }
          sub_1000558F4((const void **)buf);
          break;
      }
      CarrierBundleHandler::submitBundleStateMetric_sync(a1, a2, a4);
      if (*((void *)&v98 + 1)) {
        (*(void (**)(void))(**((void **)&v98 + 1) + 48))(*((void *)&v98 + 1));
      }
      return sub_10003B34C(&v97);
    case 3u:
      uint64_t v77 = 0x100000003;
      buf[0].opaque[0] = (uint64_t)&v77;
      char v12 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v77, (uint64_t)&unk_10144E20E, buf)[160];
      xpc_object_t v114 = 0;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_10004DE24((uint64_t)buf);
      uint64_t v13 = (const char *)asString();
      size_t v14 = strlen(v13);
      uint64_t v15 = sub_10004B96C(buf, (uint64_t)v13, v14);
      int v16 = sub_10004B96C(v15, (uint64_t)", ", 2);
      uint64_t v17 = (const char *)asString();
      size_t v18 = strlen(v17);
      sub_10004B96C(v16, (uint64_t)v17, v18);
      sub_10004BC98((uint64_t)&buf[0].opaque[1], __p);
      sub_1001AA668((uint64_t *)&event::carrierbundle::bootstrap_bundle_setup + 3, (uint64_t *)__p);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v103) < 0) {
        operator delete(*((void **)&v102 + 1));
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      uint64_t v19 = (uint64_t *)*((void *)&event::carrierbundle::bootstrap_bundle_setup + 1);
      if (!v19) {
        __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
      }
      char v95 = a3;
      char v94 = v12;
      long long v93 = 0uLL;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      memset(buf, 0, sizeof(buf));
      long long v20 = (pthread_mutex_t *)sub_100060E64(v19 + 3);
      sub_100061F70(buf, v20);
      uint64_t v21 = v19[1];
      if (v21)
      {
        if (atomic_load_explicit((atomic_uint *volatile)(v21 + 8), memory_order_acquire) == 1)
        {
          uint64_t v22 = v19[1];
          if (!v22 || atomic_load_explicit((atomic_uint *volatile)(v22 + 8), memory_order_acquire) != 1) {
            __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
          }
          uint64_t v23 = (uint64_t *)sub_100694E28(*v19);
          uint64_t v24 = sub_100695234(*v23);
          long long v25 = (void *)v19[2];
          if (v25 == (void *)v24)
          {
            uint64_t v26 = (uint64_t *)sub_100694E28(*v19);
            long long v25 = *(void **)(sub_100695234(*v26) + 8);
          }
          __p[0] = v25;
          sub_100694E68(v19, (uint64_t **)__p, 1);
        }
        uint64_t v27 = *v19;
        uint64_t v28 = v19[1];
        if (v28) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v28 + 8), 1u, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v28 = 0;
        uint64_t v27 = *v19;
      }
      long long v46 = v93;
      *(void *)&long long v93 = v27;
      *((void *)&v93 + 1) = v28;
      *(_OWORD *)std::string __p = v46;
      sub_10000A740((atomic_uint **)&__p[1]);
      sub_10000A6C8(*((pthread_mutex_t **)&v109 + 1));
      sub_10000A5F8(buf);
      long long v111 = 0u;
      long long v112 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v100 = 0u;
      memset(buf, 0, sizeof(buf));
      *(void *)&long long v113 = 0;
      *((void *)&v113 + 1) = 10;
      xpc_object_t v114 = &buf[0].opaque[1];
      uint64_t v115 = 0;
      unsigned int v116 = &v95;
      char v117 = &v94;
      uint64_t v119 = 0;
      uint64_t v118 = 0;
      int v47 = (uint64_t *)sub_100694E28(v93);
      int v48 = (void *)sub_100695234(*v47);
      object[0] = buf;
      object[1] = v19;
      xpc_object_t object[2] = v48;
      uint64_t v49 = sub_100694E28(v93);
      sub_100060EA8((uint64_t *)(v49 + 16));
      uint64_t v50 = (uint64_t *)sub_100694E28(v93);
      uint64_t v51 = *(void **)(sub_100695234(*v50) + 8);
      unsigned int v52 = (uint64_t *)sub_100694E28(v93);
      int v53 = (void *)sub_100695234(*v52);
      v90[0] = v51;
      v90[1] = v53;
      *(void *)&long long v91 = buf;
      *((void *)&v91 + 1) = v53;
      sub_100695274((uint64_t *)v90);
      uint64_t v54 = *(void *)sub_100694E28(v93);
      sub_100695234(v54);
      uint64_t v55 = (uint64_t *)sub_100694E28(v93);
      uint64_t v56 = sub_100695234(*v55);
      uint64_t v86 = v54;
      uint64_t v87 = v56;
      uint64_t v88 = buf;
      uint64_t v89 = v56;
      sub_100695274(&v86);
      *(_OWORD *)std::string __p = *(_OWORD *)v90;
      *(_OWORD *)&xpc_object_t __p[2] = v91;
      char v57 = (void *)v86;
      uint64_t v58 = (void **)v90[0];
      if (v90[0] != (void *)v86)
      {
        uint64_t v59 = (char **)__p[2];
        int v60 = *(unsigned __int8 *)__p[2];
        BOOL v61 = *(unsigned char *)__p[2] == 0;
        do
        {
          if (v61)
          {
            uint64_t v62 = sub_1006951B4((uint64_t)v58[2]);
            uint64_t v63 = sub_1006951F4(*(void *)(v62 + 32));
            uint64_t v64 = *(void *)(v63 + 24);
            if (!v64)
            {
              std::runtime_error::runtime_error(&v96, "call to empty boost::function");
              v96.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
              sub_100098518(&v96);
            }
            (*(void (**)(uint64_t, void, void))((v64 & 0xFFFFFFFFFFFFFFFELL) + 8))(v63 + 32, *v59[34], *v59[35]);
            if (!*(unsigned char *)v59) {
              *(unsigned char *)uint64_t v59 = 1;
            }
          }
          else if (!v60)
          {
            __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
          }
          __p[0] = v58[1];
          sub_100695274((uint64_t *)__p);
          uint64_t v59 = (char **)__p[2];
          if (*(unsigned char *)__p[2]) {
            *(unsigned char *)xpc_object_t __p[2] = 0;
          }
          int v60 = 0;
          uint64_t v58 = (void **)__p[0];
          BOOL v61 = 1;
        }
        while (__p[0] != v57);
      }
      sub_1006955D8(object);
      sub_100695E10((uint64_t)buf);
      sub_10000A740((atomic_uint **)&v93 + 1);
      return sub_10003B34C(&v97);
    case 4u:
      if (*(unsigned __int8 *)(a1 + 2272) != a3)
      {
        *(unsigned char *)(a1 + 2272) = a3;
        uint64_t v29 = *(void *)(a1 + 2264);
        if (v29) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v29 + 48))(v29, a1 + 2272);
        }
      }
      __p[0] = (void *)((a4 << 32) | 1);
      buf[0].opaque[0] = (uint64_t)__p;
      if (*((void *)sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, buf) + 30)) {
        uint64_t v30 = sub_100080778;
      }
      else {
        uint64_t v30 = 0;
      }
      if (!v30)
      {
        int v31 = *v9;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0].opaque[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Not sending default bundle change as there is no carrier info", (uint8_t *)buf, 2u);
        }
      }
      buf[0].opaque[0] = (uint64_t)off_1019F8280;
      buf[0].opaque[1] = a1;
      buf[1].opaque[1] = (uint64_t)buf;
      sub_100335220(buf, &v97);
      sub_10003B34C(buf);
      if (!a3) {
        return sub_10003B34C(&v97);
      }
      goto LABEL_117;
    default:
      return sub_10003B34C(&v97);
  }
}

void sub_1006746EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,xpc_object_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,xpc_object_t object,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  xpc_release(v54);
  xpc_release(v53);
  sub_1000558F4((const void **)&a53);
  sub_10003B34C(&v55);
  JUMPOUT(0x100674A0CLL);
}

void sub_1006749D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
}

void sub_100674A04(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x100674A0CLL);
  }
  sub_10006A6AC(a1);
}

const void **sub_100674A2C(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  return sub_100057D78((const void **)a1);
}

void sub_100674AB0(uint64_t a1, const void **a2, int a3, void *a4)
{
  void v8[4] = a1;
  sub_100058198(&v9, a2);
  int v10 = a3;
  uint64_t v7 = a4[3];
  if (v7)
  {
    if ((void *)v7 == a4)
    {
      char v12 = v11;
      (*(void (**)(void *, void *))(*a4 + 24))(a4, v11);
LABEL_6:
      v8[0] = 0;
      v8[1] = 0;
      sub_10003E168(v8, (void *)(a1 + 8));
      operator new();
    }
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
  }
  char v12 = (void *)v7;
  goto LABEL_6;
}

void sub_100674CC4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t CarrierBundleHandler::matchCarrierBundle_sync@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, const void **a3@<X2>, int *a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, uint64_t a7@<X8>)
{
  sub_100058198(&v124, a2);
  sub_100058198(&v123, a3);
  int v122 = *a4;
  v151[0] = off_1019F7D58;
  v151[1] = a1;
  v151[3] = v151;
  unsigned __int8 v14 = sub_100671D84(a1, 1u, &v124, &v123, (WirelessTechnologyList *)&v122, a6, a5, (uint64_t)v151);
  sub_10003B34C(v151);
  sub_100057D78(&v123);
  sub_100057D78(&v124);
  long long v121 = 0u;
  memset(v120, 0, sizeof(v120));
  sub_100058198(&cf, a2);
  *(void *)&long long buf = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100678168((uint64_t)v120, a1, 5u, (const void **)&buf, a5, a6);
  sub_100057D78((const void **)&buf);
  sub_100057D78(&cf);
  unsigned __int8 v15 = BYTE8(v121);
  if (v14) {
    unsigned __int8 v16 = v14;
  }
  else {
    unsigned __int8 v16 = BYTE8(v121);
  }
  sub_100673654(a1, 1u, (char)v16, a5);
  if (v14 == 4) {
    unsigned __int8 v17 = 0;
  }
  else {
    unsigned __int8 v17 = v14;
  }
  if (v17 | v15)
  {
    size_t v18 = CarrierBundleHandler::handleOperatorBundleSetup_sync(a1, a5, 1);
    if (v17)
    {
      if (v17 != 1)
      {
        if (v17 == 3 && capabilities::ct::supportsGemini((capabilities::ct *)v18))
        {
          uint64_t v19 = *(void **)(a1 + 136);
          long long v20 = (void *)(a1 + 144);
          if (v19 != (void *)(a1 + 144))
          {
            while (*((unsigned char *)v19 + 32) != 1 || *((_DWORD *)v19 + 9) == a5)
            {
              uint64_t v21 = (void *)v19[1];
              if (v21)
              {
                do
                {
                  uint64_t v22 = v21;
                  uint64_t v21 = (void *)*v21;
                }
                while (v21);
              }
              else
              {
                do
                {
                  uint64_t v22 = (void *)v19[2];
                  BOOL v23 = *v22 == (void)v19;
                  uint64_t v19 = v22;
                }
                while (!v23);
              }
              uint64_t v19 = v22;
              if (v22 == v20) {
                goto LABEL_99;
              }
            }
          }
          if (v19 != v20)
          {
            if (*((char *)v19 + 63) < 0 ? v19[6] : *((unsigned __int8 *)v19 + 63))
            {
              uint64_t v42 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v43 = subscriber::asString();
                LODWORD(buf) = 136315138;
                *(void *)((char *)&buf + 4) = v43;
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Initial bundle set up only for slot %s. Need to check for bundle update.", (uint8_t *)&buf, 0xCu);
              }
              (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 96))(a1, 3);
            }
          }
        }
LABEL_99:
        uint64_t v56 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a5);
        CFDictionaryRef theDict = 0;
        *(void *)&long long __p = (a5 << 32) | 1;
        *(void *)&long long buf = &__p;
        char v57 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__p, (uint64_t)&unk_10144E20E, (void **)&buf);
        sub_100058198((const void **)&theDict, (const void **)v57 + 30);
        if (theDict) {
          uint64_t v58 = sub_100080778;
        }
        else {
          uint64_t v58 = 0;
        }
        if (!v58)
        {
          long long v70 = *v56;
          if (os_log_type_enabled(*v56, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "No valid matching info for slot, cannot check OtherKnown settings state", (uint8_t *)&buf, 2u);
          }
          goto LABEL_188;
        }
        long long __p = 0uLL;
        uint64_t v130 = 0;
        CFDictionaryGetValue(theDict, (const void *)qword_101B13EB8);
        long long buf = 0uLL;
        uint64_t v135 = 0;
        ctu::cf::assign();
        long long __p = buf;
        uint64_t v130 = v135;
        uint64_t v59 = *((void *)&buf + 1);
        if (v135 >= 0) {
          uint64_t v59 = HIBYTE(v135);
        }
        if (!v59)
        {
          xpc_object_t v71 = *v56;
          if (os_log_type_enabled(*v56, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "No ICCID present in matching info, cannot proceed to read the switch state.", (uint8_t *)&buf, 2u);
          }
          goto LABEL_186;
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
        BOOL v61 = ServiceMap;
        if (v62 < 0)
        {
          uint64_t v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v64 = 5381;
          do
          {
            uint64_t v62 = v64;
            unsigned int v65 = *v63++;
            uint64_t v64 = (33 * v64) ^ v65;
          }
          while (v65);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long buf = v62;
        uint64_t v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)&buf);
        if (v66)
        {
          int v67 = (std::__shared_weak_count *)v66[4];
          uint64_t v118 = v66[3];
          if (v67)
          {
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v61);
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v68 = v67;
            sub_10004D2C8(v67);
            char v69 = 0;
            goto LABEL_118;
          }
        }
        else
        {
          uint64_t v118 = 0;
        }
        std::mutex::unlock(v61);
        uint64_t v68 = 0;
        char v69 = 1;
LABEL_118:
        if (!v118)
        {
          xpc_object_t v72 = *v56;
          if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface.", (uint8_t *)&buf, 2u);
          }
          goto LABEL_184;
        }
        long long buf = 0uLL;
        uint64_t v135 = 0;
        if (SHIBYTE(v130) < 0)
        {
          sub_10004FC84(&buf, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long buf = __p;
          uint64_t v135 = v130;
        }
        if (sub_100684AF0(a1, a5))
        {
          unint64_t v128 = 0;
          (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v118 + 64))(&v127);
          CFTypeRef v133 = v127;
          if (v127) {
            CFRetain(v127);
          }
          uint64_t v132 = 0;
          *(void *)BOOL v152 = 0;
          sub_1000057AC(v152, &v133);
          if (*(void *)v152) {
            xpc_object_t v73 = sub_100084B4C;
          }
          else {
            xpc_object_t v73 = 0;
          }
          if (v73) {
            sub_1005AED68((const void **)&v132, (const void **)v152);
          }
          sub_100062778((const void **)v152);
          unint64_t v128 = v132;
          uint64_t v132 = 0;
          sub_100062778((const void **)&v132);
          sub_1000577C4(&v133);
          sub_1000577C4(&v127);
          if (v128) {
            xpc_object_t v74 = sub_100084B4C;
          }
          else {
            xpc_object_t v74 = 0;
          }
          if (v74) {
            goto LABEL_182;
          }
          xpc_object_t v75 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            p_p = &__p;
            if (v130 < 0) {
              p_p = (long long *)__p;
            }
            *(_DWORD *)BOOL v152 = 136315138;
            *(void *)&v152[4] = p_p;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I No switch state stored for this ICCID:%s in preferences. Settings enabled by default", v152, 0xCu);
          }
          CFTypeRef v126 = 0;
          uint64_t v77 = kOtherKnownCarrierSettingsAppliedByDefault;
          (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v118 + 64))(&v125);
          CFTypeRef v133 = v125;
          if (v125) {
            CFRetain(v125);
          }
          uint64_t v132 = 0;
          *(void *)BOOL v152 = 0;
          sub_1000057AC(v152, &v133);
          __int16 v78 = v56;
          if (*(void *)v152) {
            std::string v79 = sub_100084B4C;
          }
          else {
            std::string v79 = 0;
          }
          if (v79) {
            sub_1005AED68((const void **)&v132, (const void **)v152);
          }
          sub_100062778((const void **)v152);
          std::string v80 = v132;
          CFTypeRef v126 = v132;
          uint64_t v132 = 0;
          sub_100062778((const void **)&v132);
          sub_1000577C4(&v133);
          sub_1000577C4(&v125);
          if (v80) {
            __int16 v81 = sub_100084B4C;
          }
          else {
            __int16 v81 = 0;
          }
          if (!v81)
          {
            if ((*(unsigned int (**)(uint64_t, long long *, uint64_t, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v118 + 48))(v118, &buf, v77, kCFBooleanTrue, 0, 0, 1, 0))
            {
              std::string v82 = *v78;
              if (os_log_type_enabled(*v78, OS_LOG_TYPE_ERROR))
              {
                long long v113 = &__p;
                if (v130 < 0) {
                  long long v113 = (long long *)__p;
                }
                *(_DWORD *)BOOL v152 = 136315138;
                *(void *)&v152[4] = v113;
                _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "Could not store OtherKnown default ON Switch state for %s", v152, 0xCu);
              }
            }
          }
          std::string v83 = &v126;
LABEL_181:
          sub_100062778(v83);
LABEL_182:
          sub_100062778((const void **)&v128);
          if (SHIBYTE(v135) < 0) {
            operator delete((void *)buf);
          }
LABEL_184:
          if ((v69 & 1) == 0) {
            sub_10004D2C8(v68);
          }
LABEL_186:
          if (SHIBYTE(v130) < 0) {
            operator delete((void *)__p);
          }
LABEL_188:
          sub_100057D78((const void **)&theDict);
          goto LABEL_189;
        }
        unsigned int v116 = v68;
        unint64_t v128 = 0;
        char v84 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
        std::string v85 = v84;
        if (v86 < 0)
        {
          uint64_t v87 = (unsigned __int8 *)(v86 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v88 = 5381;
          do
          {
            uint64_t v86 = v88;
            unsigned int v89 = *v87++;
            uint64_t v88 = (33 * v88) ^ v89;
          }
          while (v89);
        }
        std::mutex::lock(v84);
        *(void *)BOOL v152 = v86;
        unsigned int v90 = sub_10004D37C(&v85[1].__m_.__sig, (unint64_t *)v152);
        if (v90)
        {
          uint64_t v92 = v90[3];
          long long v91 = (std::__shared_weak_count *)v90[4];
          if (v91)
          {
            atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v85);
            atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v91);
            char v93 = 0;
LABEL_162:
            (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, void, const CFBooleanRef, void))(*(void *)v92 + 80))(&v133, v92, a5, 1, kApplyGSMASettingsKey, kCFBooleanFalse, 0);
            sub_1000057AC(&v128, &v133);
            sub_1000577C4(&v133);
            if ((v93 & 1) == 0) {
              sub_10004D2C8(v91);
            }
            v152[0] = 0;
            ctu::cf::assign((ctu::cf *)v152, v128, v94);
            uint64_t v68 = v116;
            if (v152[0]) {
              goto LABEL_182;
            }
            CFTypeRef v127 = 0;
            uint64_t v95 = kOtherKnownCarrierSettingsAppliedByDefault;
            (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v118 + 64))(&v126);
            CFTypeRef v133 = v126;
            if (v126) {
              CFRetain(v126);
            }
            uint64_t v132 = 0;
            *(void *)BOOL v152 = 0;
            sub_1000057AC(v152, &v133);
            std::runtime_error v96 = v56;
            if (*(void *)v152) {
              long long v97 = sub_100084B4C;
            }
            else {
              long long v97 = 0;
            }
            if (v97) {
              sub_1005AED68((const void **)&v132, (const void **)v152);
            }
            sub_100062778((const void **)v152);
            long long v98 = v132;
            CFTypeRef v127 = v132;
            uint64_t v132 = 0;
            sub_100062778((const void **)&v132);
            sub_1000577C4(&v133);
            sub_1000577C4(&v126);
            if (v98) {
              uint64_t v99 = sub_100084B4C;
            }
            else {
              uint64_t v99 = 0;
            }
            if (v99)
            {
              long long v100 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)BOOL v152 = 0;
                _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I Resetting OtherKnownSettings default ON switch", v152, 2u);
              }
              uint64_t v68 = v116;
              if ((*(unsigned int (**)(uint64_t, long long *, uint64_t, void, void, void, uint64_t, void))(*(void *)v118 + 48))(v118, &buf, v95, 0, 0, 0, 1, 0))
              {
                long long v101 = *v96;
                if (os_log_type_enabled(*v96, OS_LOG_TYPE_ERROR))
                {
                  long long v111 = &__p;
                  if (v130 < 0) {
                    long long v111 = (long long *)__p;
                  }
                  *(_DWORD *)BOOL v152 = 136315138;
                  *(void *)&v152[4] = v111;
                  _os_log_error_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "Could not reset OtherKnown default ON Switch state for %s", v152, 0xCu);
                }
              }
            }
            std::string v83 = &v127;
            goto LABEL_181;
          }
        }
        else
        {
          uint64_t v92 = 0;
        }
        std::mutex::unlock(v85);
        long long v91 = 0;
        char v93 = 1;
        goto LABEL_162;
      }
      if (CarrierBundleHandler::evaluateGsmaSettingsSwitchState_sync(a1, a5)) {
        goto LABEL_99;
      }
      uint64_t v24 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a5);
      CFDictionaryRef theDict = 0;
      *(void *)&long long __p = (a5 << 32) | 1;
      *(void *)&long long buf = &__p;
      long long v25 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__p, (uint64_t)&unk_10144E20E, (void **)&buf);
      sub_100058198((const void **)&theDict, (const void **)v25 + 30);
      if (theDict) {
        uint64_t v26 = sub_100080778;
      }
      else {
        uint64_t v26 = 0;
      }
      if (!v26)
      {
        uint64_t v40 = *v24;
        if (os_log_type_enabled(*v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "No valid matching info for slot, cannot check OtherKnown bundle updated settings state", (uint8_t *)&buf, 2u);
        }
        goto LABEL_98;
      }
      long long __p = 0uLL;
      uint64_t v130 = 0;
      CFDictionaryGetValue(theDict, (const void *)qword_101B13EB8);
      long long buf = 0uLL;
      uint64_t v135 = 0;
      ctu::cf::assign();
      long long __p = buf;
      uint64_t v130 = v135;
      uint64_t v27 = *((void *)&buf + 1);
      if (v135 >= 0) {
        uint64_t v27 = HIBYTE(v135);
      }
      if (!v27)
      {
        uint64_t v41 = *v24;
        if (os_log_type_enabled(*v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "No ICCID present in matching info, cannot proceed to read the switch state.", (uint8_t *)&buf, 2u);
        }
        goto LABEL_96;
      }
      uint64_t v28 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
      uint64_t v29 = v28;
      if (v30 < 0)
      {
        int v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      *(void *)&long long buf = v30;
      os_log_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&buf);
      char v117 = v24;
      if (v34)
      {
        uint64_t v36 = v34[3];
        uint64_t v35 = (std::__shared_weak_count *)v34[4];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          int v37 = v35;
          sub_10004D2C8(v35);
          char v38 = 0;
          goto LABEL_52;
        }
      }
      else
      {
        uint64_t v36 = 0;
      }
      std::mutex::unlock(v29);
      int v37 = 0;
      char v38 = 1;
LABEL_52:
      if (!v36)
      {
        int v44 = *v117;
        if (os_log_type_enabled(*v117, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface.", (uint8_t *)&buf, 2u);
        }
        goto LABEL_94;
      }
      long long buf = 0uLL;
      uint64_t v135 = 0;
      if (SHIBYTE(v130) < 0)
      {
        sub_10004FC84(&buf, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        long long buf = __p;
        uint64_t v135 = v130;
      }
      unint64_t v128 = 0;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, long long *, void, void, void, uint64_t))(*(void *)v36 + 64))(&v127, v36, &buf, kGsmaSettingsSwitchState, 0, 0, 1);
      CFTypeRef v133 = v127;
      if (v127) {
        CFRetain(v127);
      }
      uint64_t v132 = 0;
      *(void *)BOOL v152 = 0;
      sub_1000057AC(v152, &v133);
      if (*(void *)v152) {
        int v45 = sub_100084B4C;
      }
      else {
        int v45 = 0;
      }
      if (v45) {
        sub_1005AED68((const void **)&v132, (const void **)v152);
      }
      sub_100062778((const void **)v152);
      unint64_t v128 = v132;
      uint64_t v132 = 0;
      sub_100062778((const void **)&v132);
      sub_1000577C4(&v133);
      sub_1000577C4(&v127);
      if (v128) {
        int v47 = sub_100084B4C;
      }
      else {
        int v47 = 0;
      }
      if (v47)
      {
        v152[0] = 0;
        ctu::cf::assign((ctu::cf *)v152, v128, v46);
        if (!v152[0])
        {
LABEL_92:
          sub_100062778((const void **)&v128);
          if (SHIBYTE(v135) < 0) {
            operator delete((void *)buf);
          }
LABEL_94:
          if ((v38 & 1) == 0) {
            sub_10004D2C8(v37);
          }
LABEL_96:
          if (SHIBYTE(v130) < 0) {
            operator delete((void *)__p);
          }
LABEL_98:
          sub_100057D78((const void **)&theDict);
          goto LABEL_99;
        }
      }
      else
      {
        uint64_t v48 = v36;
        char v115 = v38;
        xpc_object_t v114 = v37;
        uint64_t v49 = *v117;
        if (os_log_type_enabled(*v117, OS_LOG_TYPE_ERROR))
        {
          long long v112 = &__p;
          if (v130 < 0) {
            long long v112 = (long long *)__p;
          }
          *(_DWORD *)BOOL v152 = 136315138;
          *(void *)&v152[4] = v112;
          _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "No switch state stored for this ICCID:%s in preferences.", v152, 0xCu);
        }
        CFTypeRef v126 = 0;
        uint64_t v50 = kOtherKnownCarrierSettingsAppliedByDefault;
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, long long *, void, void, void, uint64_t))(*(void *)v48 + 64))(&v125, v48, &buf, kOtherKnownCarrierSettingsAppliedByDefault, 0, 0, 1);
        CFTypeRef v133 = v125;
        if (v125) {
          CFRetain(v125);
        }
        uint64_t v132 = 0;
        *(void *)BOOL v152 = 0;
        sub_1000057AC(v152, &v133);
        if (*(void *)v152) {
          uint64_t v51 = sub_100084B4C;
        }
        else {
          uint64_t v51 = 0;
        }
        if (v51) {
          sub_1005AED68((const void **)&v132, (const void **)v152);
        }
        sub_100062778((const void **)v152);
        unsigned int v52 = v132;
        CFTypeRef v126 = v132;
        uint64_t v132 = 0;
        sub_100062778((const void **)&v132);
        sub_1000577C4(&v133);
        sub_1000577C4(&v125);
        if (v52) {
          int v53 = sub_100084B4C;
        }
        else {
          int v53 = 0;
        }
        if (!v53)
        {
          sub_100062778(&v126);
          int v37 = v114;
          char v38 = v115;
          goto LABEL_92;
        }
        uint64_t v54 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v152 = 0;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I OtherKnownSettings switch was default ON. Reset.", v152, 2u);
        }
        (*(void (**)(uint64_t, long long *, uint64_t, void, void, void, uint64_t, void))(*(void *)v48 + 48))(v48, &buf, v50, 0, 0, 0, 1, 0);
        sub_100062778(&v126);
        int v37 = v114;
        char v38 = v115;
      }
      if (*(unsigned char *)(a1 + 2304))
      {
        sub_100684EF4(a1);
      }
      else
      {
        uint64_t v55 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v152 = 0;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I SB start up not done. Will wait to show up and show the alerts", v152, 2u);
        }
        sub_100684E30(a1, 1);
      }
      goto LABEL_92;
    }
  }
LABEL_189:
  if (*(_DWORD *)(a1 + 412) == 4)
  {
    long long v102 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I Subscriber information available, checking for bundle update", (uint8_t *)&buf, 2u);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 96))(a1, 3);
  }
  *(void *)BOOL v152 = (a5 << 32) | 1;
  *(void *)&long long __p = v152;
  long long v103 = sub_100688D4C((uint64_t **)(a1 + 136), v152, (uint64_t)&unk_10144E20E, (void **)&__p);
  sub_10000BE9C((uint64_t)&buf, (uint64_t)(v103 + 40));
  uint64_t v104 = v137;
  *(void *)(a7 + 16) = v135;
  *(void *)(a7 + 4sub_10010E764((uint64_t)&a9, 0) = v104;
  uint64_t v105 = v141;
  *(void *)(a7 + 64) = v139;
  *(void *)(a7 + 88) = v105;
  *(void *)(a7 + 112) = v143;
  *(unsigned char *)(a7 + 12sub_10010E764((uint64_t)&a9, 0) = v144;
  uint64_t v106 = v148;
  *(void *)(a7 + 144) = v146;
  *(_OWORD *)a7 = buf;
  long long buf = 0uLL;
  long long v107 = v136;
  uint64_t v135 = 0;
  *(void *)&long long v136 = 0;
  *(_OWORD *)(a7 + 24) = v107;
  *((void *)&v136 + 1) = 0;
  uint64_t v137 = 0;
  *(_OWORD *)(a7 + 48) = v138;
  long long v138 = 0uLL;
  *(_OWORD *)(a7 + 72) = v140;
  uint64_t v139 = 0;
  long long v140 = 0uLL;
  uint64_t v141 = 0;
  *(_OWORD *)(a7 + 96) = v142;
  long long v142 = 0uLL;
  *(_OWORD *)(a7 + 128) = v145;
  uint64_t v143 = 0;
  long long v145 = 0uLL;
  long long v108 = v147;
  *(void *)(a7 + 168) = v106;
  *(_OWORD *)(a7 + 152) = v108;
  uint64_t v146 = 0;
  long long v147 = 0uLL;
  long long v109 = v149;
  *(void *)(a7 + 192) = v150;
  *(_OWORD *)(a7 + 176) = v109;
  uint64_t v148 = 0;
  long long v149 = 0uLL;
  uint64_t v150 = 0;
  *(unsigned char *)(a7 + 20sub_10010E764((uint64_t)&a9, 0) = v17;
  sub_10000BDF8((uint64_t)&buf);
  return sub_10000BDF8((uint64_t)v120);
}

void sub_100676054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, char a10, uint64_t a11, uint64_t a12, __int16 a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,const void *a44,uint64_t a45,const void *a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,const void *a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a61 < 0) {
    operator delete(__p);
  }
  if ((a10 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  sub_100057D78(&a53);
  sub_10000BDF8((uint64_t)&a13);
  _Unwind_Resume(a1);
}

const void **CarrierBundleHandler::handleOperatorBundleSetup_sync(uint64_t a1, uint64_t a2, int a3)
{
  int v47 = 0;
  uint64_t v6 = *(void *)(a1 + 216);
  if (v6)
  {
    uint64_t v7 = a1 + 216;
    do
    {
      int v8 = *(_DWORD *)(v6 + 28);
      BOOL v9 = v8 < (int)a2;
      if (v8 >= (int)a2) {
        int v10 = (uint64_t *)v6;
      }
      else {
        int v10 = (uint64_t *)(v6 + 8);
      }
      if (!v9) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = *v10;
    }
    while (*v10);
    if (v7 != a1 + 216 && *(_DWORD *)(v7 + 28) <= (int)a2)
    {
      switch(*(_DWORD *)(v7 + 32))
      {
        case 0xFFFFFFFF:
        case 0xB:
          goto LABEL_13;
        case 0:
        case 2:
        case 7:
        case 8:
        case 9:
        case 0xA:
          uint64_t v19 = *(void *)(a1 + 240);
          if (!v19) {
            goto LABEL_72;
          }
          uint64_t v20 = a1 + 240;
          do
          {
            int v21 = *(_DWORD *)(v19 + 32);
            BOOL v22 = v21 < (int)a2;
            if (v21 >= (int)a2) {
              BOOL v23 = (uint64_t *)v19;
            }
            else {
              BOOL v23 = (uint64_t *)(v19 + 8);
            }
            if (!v22) {
              uint64_t v20 = v19;
            }
            uint64_t v19 = *v23;
          }
          while (*v23);
          if (v20 != a1 + 240 && *(_DWORD *)(v20 + 32) <= (int)a2 && *(unsigned char *)(v20 + 72))
          {
            uint64_t v24 = *(void *)(a1 + 264);
            if (v24)
            {
              uint64_t v25 = a1 + 264;
              do
              {
                int v26 = *(_DWORD *)(v24 + 32);
                BOOL v27 = v26 < (int)a2;
                if (v26 >= (int)a2) {
                  uint64_t v28 = (uint64_t *)v24;
                }
                else {
                  uint64_t v28 = (uint64_t *)(v24 + 8);
                }
                if (!v27) {
                  uint64_t v25 = v24;
                }
                uint64_t v24 = *v28;
              }
              while (*v28);
              if (v25 != a1 + 264 && *(_DWORD *)(v25 + 32) <= (int)a2 && *(unsigned char *)(v25 + 72))
              {
                uint64_t v29 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf) = 67109632;
                  DWORD1(buf) = MCC::getIntValue((MCC *)(v20 + 40));
                  WORD4(buf) = 1024;
                  *(_DWORD *)((char *)&buf + 1sub_10010E764((uint64_t)&a9, 0) = MNC::getIntegerWidth((MNC *)(v25 + 40));
                  HIWORD(buf) = 1024;
                  LODWORD(v54) = MCC::getIntValue((MCC *)(v25 + 40));
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Matching operator bundle for %03d-%0.*d", (uint8_t *)&buf, 0x14u);
                }
                if (!*(unsigned char *)(v20 + 72) || !*(unsigned char *)(v25 + 72)) {
                  sub_10016C840();
                }
                sub_100679644((const void **)&v49, a1, (const MCC *)(v20 + 40), (const MNC *)(v25 + 40), a2);
                *(void *)&long long buf = v47;
                int v47 = (__CFDictionary *)v49;
                *(void *)&long long v49 = 0;
                sub_100057D78((const void **)&buf);
                sub_100057D78((const void **)&v49);
                uint64_t v41 = v47;
                if (v47) {
                  CFRetain(v47);
                }
                sub_100677E3C((uint64_t)v42, a1, (const void **)&v41, a2, a3);
                sub_10000BDF8((uint64_t)v42);
                uint64_t v30 = (const void **)&v41;
LABEL_83:
                sub_100057D78(v30);
                return sub_100057D78((const void **)&v47);
              }
            }
            int v31 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
              return sub_100057D78((const void **)&v47);
            }
            LOWORD(buf) = 0;
            uint64_t v32 = "#N Could not find serving PLMN MNC";
          }
          else
          {
LABEL_72:
            int v31 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
              return sub_100057D78((const void **)&v47);
            }
            LOWORD(buf) = 0;
            uint64_t v32 = "#I Could not find serving PLMN MNC";
          }
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&buf, 2u);
          return sub_100057D78((const void **)&v47);
        case 3:
        case 5:
          if (*(void *)(a1 + 280)) {
            unsigned int v33 = sub_100080778;
          }
          else {
            unsigned int v33 = 0;
          }
          if (!v33) {
            goto LABEL_80;
          }
          sub_100058198(&v45, (const void **)(a1 + 280));
          sub_100677E3C((uint64_t)v46, a1, &v45, a2, a3);
          sub_10000BDF8((uint64_t)v46);
          uint64_t v30 = &v45;
          goto LABEL_83;
        case 4:
LABEL_80:
          sub_10067BFBC((const void **)&v49, a1, a2);
          *(void *)&long long buf = v47;
          int v47 = (__CFDictionary *)v49;
          *(void *)&long long v49 = 0;
          sub_100057D78((const void **)&buf);
          sub_100057D78((const void **)&v49);
          uint64_t v43 = v47;
          if (v47) {
            CFRetain(v47);
          }
          sub_100677E3C((uint64_t)v44, a1, (const void **)&v43, a2, a3);
          sub_10000BDF8((uint64_t)v44);
          uint64_t v30 = (const void **)&v43;
          goto LABEL_83;
        default:
          return sub_100057D78((const void **)&v47);
      }
    }
  }
  long long v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not find RAT", (uint8_t *)&buf, 2u);
  }
LABEL_13:
  char v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Check if updated operator bundle available for existing bundle", (uint8_t *)&buf, 2u);
  }
  long long __dst = 0uLL;
  uint64_t v40 = 0;
  *(void *)&long long v49 = (a2 << 32) | 2;
  *(void *)&long long buf = &v49;
  uint64_t v13 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v49, (uint64_t)&unk_10144E20E, (void **)&buf);
  if (v13[63] < 0)
  {
    sub_10004FC84(&__dst, *((void **)v13 + 5), *((void *)v13 + 6));
  }
  else
  {
    long long __dst = *(_OWORD *)(v13 + 40);
    uint64_t v40 = *((void *)v13 + 7);
  }
  if (SHIBYTE(v40) < 0)
  {
    if (!*((void *)&__dst + 1))
    {
LABEL_40:
      operator delete((void *)__dst);
      return sub_100057D78((const void **)&v47);
    }
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    if (!HIBYTE(v40)) {
      return sub_100057D78((const void **)&v47);
    }
    long long __p = __dst;
    uint64_t v37 = v40;
  }
  if (SHIBYTE(v37) < 0)
  {
    sub_10004FC84(&v49, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    long long v49 = __p;
    uint64_t v50 = v37;
  }
  CFStringRef v48 = 0;
  if (SHIBYTE(v50) < 0)
  {
    sub_10004FC84(&buf, (void *)v49, *((unint64_t *)&v49 + 1));
  }
  else
  {
    long long buf = v49;
    uint64_t v54 = v50;
  }
  CFStringRef v51 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v14 = v48;
    CFStringRef v48 = v51;
    CFStringRef v52 = v14;
    sub_1000558F4((const void **)&v52);
  }
  if (SHIBYTE(v54) < 0) {
    operator delete((void *)buf);
  }
  CFStringRef v15 = v48;
  CFStringRef v38 = v48;
  CFStringRef v48 = 0;
  sub_1000558F4((const void **)&v48);
  if (SHIBYTE(v50) < 0) {
    operator delete((void *)v49);
  }
  unsigned __int8 v16 = sub_1006B3B68((os_log_t *)(a1 + 40), v15);
  unsigned __int8 v17 = v47;
  int v47 = v16;
  *(void *)&long long buf = v17;
  sub_100057D78((const void **)&buf);
  sub_1000558F4((const void **)&v38);
  if (SHIBYTE(v37) < 0) {
    operator delete((void *)__p);
  }
  os_log_t v34 = v47;
  if (v47) {
    CFRetain(v47);
  }
  sub_100677E3C((uint64_t)v35, a1, (const void **)&v34, a2, a3);
  sub_10000BDF8((uint64_t)v35);
  sub_100057D78((const void **)&v34);
  if (SHIBYTE(v40) < 0) {
    goto LABEL_40;
  }
  return sub_100057D78((const void **)&v47);
}

void sub_1006769D8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t CarrierBundleHandler::evaluateGsmaSettingsSwitchState_sync(uint64_t a1, uint64_t a2)
{
  char v93 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    long long v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  long long v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, uint64_t, void, const CFBooleanRef, void))(*(void *)v12 + 80))(&__dst, v12, a2, 1, kApplyGSMASettingsKey, kCFBooleanFalse, 0);
  sub_1000057AC(&v93, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v93, v14);
  if (buf[0])
  {
    CFDictionaryRef theDict = 0;
    __dst.__r_.__value_.__r.__words[0] = (a2 << 32) | 1;
    *(void *)long long buf = &__dst;
    CFStringRef v15 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)buf);
    sub_100058198((const void **)&theDict, (const void **)v15 + 30);
    if (theDict) {
      unsigned __int8 v16 = sub_100080778;
    }
    else {
      unsigned __int8 v16 = 0;
    }
    if (!v16)
    {
      int v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No valid matching info for slot. Hide the switch.", buf, 2u);
      }
      uint64_t v20 = 0;
      goto LABEL_122;
    }
    CFDictionaryGetValue(theDict, (const void *)qword_101B13EB8);
    memset(buf, 0, 24);
    ctu::cf::assign();
    *(_OWORD *)unsigned int v90 = *(_OWORD *)buf;
    uint64_t v91 = *(void *)&buf[16];
    uint64_t v17 = *(void *)&buf[8];
    if (buf[23] >= 0) {
      uint64_t v17 = buf[23];
    }
    if (!v17)
    {
      BOOL v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No ICCID present in matching info. Cannot read the switch state. Hide switch.", buf, 2u);
      }
      uint64_t v20 = 0;
      goto LABEL_120;
    }
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    CFStringRef v85 = 0;
    CFStringRef theString = 0;
    CFTypeRef cf1 = theDict;
    if (theDict)
    {
      CFRetain(theDict);
      CFTypeRef v18 = cf1;
    }
    else
    {
      CFTypeRef v18 = 0;
    }
    memset(&v107, 0, sizeof(v107));
    std::string::size_type v105 = 0;
    std::string::size_type v106 = 0;
    if (v18) {
      BOOL v23 = sub_100080778;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23)
    {
      uint64_t v28 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Empty lookup info.", buf, 2u);
      }
LABEL_93:
      sub_1004D4B6C(__p, (long long *)&v107, (const void **)&v106, (const void **)&v105);
      sub_1000558F4((const void **)&v105);
      sub_1000558F4((const void **)&v106);
      if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v107.__r_.__value_.__l.__data_);
      }
      *(void *)long long buf = &v87;
      *(void *)&uint8_t buf[8] = &theString;
      *(void *)&uint8_t buf[16] = &v85;
      sub_100688068(buf, (long long *)__p);
      sub_1000558F4(&v84);
      sub_1000558F4(&v83);
      if (v82 < 0) {
        operator delete(__p[0]);
      }
      sub_100057D78(&cf1);
      uint64_t v56 = HIBYTE(v89);
      if (v89 < 0) {
        uint64_t v56 = v88;
      }
      if (!v56
        || (theString ? (char v57 = sub_1000810B8) : (char v57 = 0),
            !v57
         || (v85 ? (uint64_t v58 = sub_1000810B8) : (uint64_t v58 = 0), !v58 || !CFStringGetLength(theString) || !CFStringGetLength(v85))))
      {
        char v69 = *(NSObject **)(a1 + 40);
        uint64_t v20 = 0;
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#N Invalid GSMA config look up result.", buf, 2u);
          uint64_t v20 = 0;
        }
        goto LABEL_118;
      }
      uint64_t v59 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
      int v60 = v59;
      if (v61 < 0)
      {
        uint64_t v62 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v63 = 5381;
        do
        {
          uint64_t v61 = v63;
          unsigned int v64 = *v62++;
          uint64_t v63 = (33 * v63) ^ v64;
        }
        while (v64);
      }
      std::mutex::lock(v59);
      *(void *)long long buf = v61;
      unsigned int v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)buf);
      if (v65)
      {
        uint64_t v67 = v65[3];
        uint64_t v66 = (std::__shared_weak_count *)v65[4];
        if (v66)
        {
          atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v60);
          atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v66);
          char v68 = 0;
          goto LABEL_126;
        }
      }
      else
      {
        uint64_t v67 = 0;
      }
      std::mutex::unlock(v60);
      uint64_t v66 = 0;
      char v68 = 1;
LABEL_126:
      if (v67)
      {
        memset(buf, 0, 24);
        if (SHIBYTE(v91) < 0)
        {
          sub_10004FC84(buf, v90[0], (unint64_t)v90[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v90;
          *(void *)&uint8_t buf[16] = v91;
        }
        *(void *)long long v110 = 0;
        (*(void (**)(const void **__return_ptr, uint64_t, unsigned char *, void, void, void, uint64_t))(*(void *)v67 + 64))(&v79, v67, buf, kGsmaSettingsSwitchState, 0, 0, 1);
        sub_1000584C8((const void **)__p, &v79);
        v107.__r_.__value_.__r.__words[0] = 0;
        __dst.__r_.__value_.__r.__words[0] = 0;
        sub_1000057AC(&__dst, (CFTypeRef *)__p);
        if (__dst.__r_.__value_.__r.__words[0]) {
          xpc_object_t v72 = sub_100084B4C;
        }
        else {
          xpc_object_t v72 = 0;
        }
        if (v72) {
          sub_1005AED68((const void **)&v107.__r_.__value_.__l.__data_, (const void **)&__dst.__r_.__value_.__l.__data_);
        }
        sub_100062778((const void **)&__dst.__r_.__value_.__l.__data_);
        *(void *)long long v110 = v107.__r_.__value_.__r.__words[0];
        v107.__r_.__value_.__r.__words[0] = 0;
        sub_100062778((const void **)&v107.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)__p);
        sub_1000577C4(&v79);
        if (*(void *)v110) {
          xpc_object_t v73 = sub_100084B4C;
        }
        else {
          xpc_object_t v73 = 0;
        }
        if (v73)
        {
          if (CFBooleanGetValue(*(CFBooleanRef *)v110)) {
            uint64_t v20 = 1;
          }
          else {
            uint64_t v20 = 2;
          }
          xpc_object_t v74 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v75 = asString();
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v75;
            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I GSMA switch state: %s", (uint8_t *)&__dst, 0xCu);
          }
        }
        else
        {
          xpc_object_t v76 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v77 = v90;
            if (v91 < 0) {
              uint64_t v77 = (void **)v90[0];
            }
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v77;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I No switch state stored for this ICCID:%s in preferences. Checking further.", (uint8_t *)&__dst, 0xCu);
          }
          if (sub_100684AF0(a1, a2))
          {
            __int16 v78 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I No switch state but GSMA settings applied.", (uint8_t *)&__dst, 2u);
            }
            uint64_t v20 = 1;
          }
          else
          {
            uint64_t v20 = 2;
          }
        }
        sub_100062778((const void **)v110);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v68) {
          goto LABEL_118;
        }
      }
      else
      {
        xpc_object_t v71 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v20 = 2;
          _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface.", buf, 2u);
          if (v68)
          {
LABEL_118:
            sub_1000558F4((const void **)&v85);
            sub_1000558F4((const void **)&theString);
            if (SHIBYTE(v89) < 0) {
              operator delete(v87);
            }
LABEL_120:
            if (SHIBYTE(v91) < 0) {
              operator delete(v90[0]);
            }
LABEL_122:
            sub_100057D78((const void **)&theDict);
            goto LABEL_123;
          }
        }
        else
        {
          uint64_t v20 = 2;
          if (v68) {
            goto LABEL_118;
          }
        }
      }
      sub_10004D2C8(v66);
      goto LABEL_118;
    }
    uint64_t v24 = *(void *)(a1 + 184);
    uint64_t v25 = *(void *)(a1 + 192);
    while (v24 != v25)
    {
      if (CFEqual(cf1, *(CFTypeRef *)v24))
      {
        std::string::operator=(&v107, (const std::string *)(v24 + 8));
        sub_100083EB8((const void **)&v106, (const void **)(v24 + 32));
        sub_100083EB8((const void **)&v105, (const void **)(v24 + 40));
        goto LABEL_93;
      }
      v24 += 48;
    }
    xpc_object_t v104 = 0;
    xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v27 = v26;
    if (v26)
    {
      xpc_object_t v104 = v26;
    }
    else
    {
      xpc_object_t v27 = xpc_null_create();
      xpc_object_t v104 = v27;
      if (!v27)
      {
        xpc_object_t v29 = xpc_null_create();
        xpc_object_t v27 = 0;
        goto LABEL_48;
      }
    }
    if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v27);
LABEL_49:
      xpc_release(v27);
      xpc_object_t object = xpc_string_create(off_101B0AF28[0]);
      if (!object) {
        xpc_object_t object = xpc_null_create();
      }
      *(void *)long long buf = &v104;
      *(char **)&uint8_t buf[8] = off_101B0AEB0[0];
      sub_100035E70((uint64_t)buf, &object, &v103);
      xpc_release(v103);
      xpc_object_t v103 = 0;
      xpc_release(object);
      xpc_object_t object = 0;
      ctu::cf_to_xpc((uint64_t *)&v100, (ctu *)cf1, v30);
      *(void *)long long buf = &v104;
      *(char **)&uint8_t buf[8] = off_101B0AF40[0];
      sub_100035E70((uint64_t)buf, &v100, &v101);
      xpc_release(v101);
      xpc_object_t v101 = 0;
      xpc_release(v100);
      xpc_object_t v99 = 0;
      xpc_object_t v100 = 0;
      uint64_t v31 = *(void *)(a1 + 120);
      xpc_object_t v98 = v104;
      if (v104) {
        xpc_retain(v104);
      }
      else {
        xpc_object_t v98 = xpc_null_create();
      }
      (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v31 + 16))(&v99, v31, &v98);
      xpc_release(v98);
      xpc_object_t v98 = 0;
      uint64_t v32 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        xpc::object::to_string((uint64_t *)buf, (xpc::object *)&v104);
        int v33 = buf[23];
        os_log_t v34 = *(unsigned char **)buf;
        xpc::object::to_string((uint64_t *)&__dst, (xpc::object *)&v99);
        uint64_t v35 = buf;
        if (v33 < 0) {
          uint64_t v35 = v34;
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long v110 = 136315394;
        *(void *)&v110[4] = v35;
        *(_WORD *)&v110[12] = 2082;
        *(void *)&v110[14] = p_dst;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Sent request %s to lookup GSMA config, received result: %{public}s", v110, 0x16u);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      *(void *)long long v110 = &v99;
      *(char **)&v110[8] = off_101B0B048[0];
      sub_100048BAC((uint64_t)v110, &v97);
      memset(buf, 0, 24);
      xpc::dyn_cast_or_default();
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v107.__r_.__value_.__l.__data_);
      }
      std::string v107 = __dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
      __dst.__r_.__value_.__s.__data_[0] = 0;
      xpc_release(v97);
      *(void *)long long buf = &v99;
      *(char **)&uint8_t buf[8] = off_101B0B050[0];
      sub_100048BAC((uint64_t)buf, &v96);
      xpc::bridge((uint64_t *)&v97, (xpc *)&v96, v37);
      sub_100056248(v110, (CFTypeRef *)&v97);
      __dst.__r_.__value_.__r.__words[0] = v106;
      std::string::size_type v106 = *(void *)v110;
      *(void *)long long v110 = 0;
      sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)v110);
      sub_1000577C4((const void **)&v97);
      xpc_release(v96);
      *(void *)long long buf = &v99;
      *(char **)&uint8_t buf[8] = off_101B0B058[0];
      sub_100048BAC((uint64_t)buf, &v96);
      xpc::bridge((uint64_t *)&v97, (xpc *)&v96, v38);
      sub_100056248(v110, (CFTypeRef *)&v97);
      __dst.__r_.__value_.__r.__words[0] = v105;
      std::string::size_type v105 = *(void *)v110;
      *(void *)long long v110 = 0;
      sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)v110);
      sub_1000577C4((const void **)&v97);
      xpc_release(v96);
      sub_1004D4B6C(&__dst, (long long *)&v107, (const void **)&v106, (const void **)&v105);
      *(void *)long long buf = cf1;
      if (cf1) {
        CFRetain(cf1);
      }
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
      memset(&__dst, 0, sizeof(__dst));
      uint64_t v39 = v109;
      *(void *)&uint8_t buf[24] = *((void *)&__dst.__r_.__value_.__l + 2);
      long long v95 = v109;
      uint64_t v40 = *((void *)&v109 + 1);
      long long v109 = 0uLL;
      unint64_t v42 = *(void *)(a1 + 192);
      unint64_t v41 = *(void *)(a1 + 200);
      if (v42 >= v41)
      {
        uint64_t v45 = *(void *)(a1 + 184);
        unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v42 - v45) >> 4) + 1;
        if (v46 > 0x555555555555555) {
          sub_10006A748();
        }
        unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - v45) >> 4);
        if (2 * v47 > v46) {
          unint64_t v46 = 2 * v47;
        }
        if (v47 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v48 = 0x555555555555555;
        }
        else {
          unint64_t v48 = v46;
        }
        if (v48 > 0x555555555555555) {
          sub_10006A7CC();
        }
        long long v49 = (char *)operator new(48 * v48);
        uint64_t v50 = &v49[16 * ((uint64_t)(v42 - v45) >> 4)];
        *(void *)uint64_t v50 = *(void *)buf;
        *(_OWORD *)(v50 + 8) = *(_OWORD *)&buf[8];
        uint64_t v51 = *(void *)&buf[24];
        memset(&buf[8], 0, 24);
        *((void *)v50 + 3) = v51;
        *((void *)v50 + 4) = v39;
        *((void *)v50 + 5) = v40;
        long long v95 = 0uLL;
        *(void *)long long buf = 0;
        if (v42 == v45)
        {
          int v44 = v50 + 48;
          *(void *)(a1 + 184) = v50;
          *(void *)(a1 + 192) = v50 + 48;
          *(void *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = &v49[48 * v48];
        }
        else
        {
          CFStringRef v52 = &v49[16 * ((uint64_t)(v42 - v45) >> 4)];
          do
          {
            uint64_t v53 = *(void *)(v42 - 48);
            v42 -= 48;
            *((void *)v52 - 6) = v53;
            v52 -= 48;
            *(void *)unint64_t v42 = 0;
            long long v54 = *(_OWORD *)(v42 + 8);
            *((void *)v52 + 3) = *(void *)(v42 + 24);
            *(_OWORD *)(v52 + 8) = v54;
            *(void *)(v42 + 16) = 0;
            *(void *)(v42 + 24) = 0;
            *(void *)(v42 + 8) = 0;
            *((void *)v52 + 4) = *(void *)(v42 + 32);
            *(void *)(v42 + 32) = 0;
            *((void *)v52 + 5) = *(void *)(v42 + 40);
            *(void *)(v42 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
          }
          while (v42 != v45);
          unint64_t v42 = *(void *)(a1 + 184);
          uint64_t v55 = *(void *)(a1 + 192);
          int v44 = v50 + 48;
          *(void *)(a1 + 184) = v52;
          *(void *)(a1 + 192) = v50 + 48;
          *(void *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = &v49[48 * v48];
          while (v55 != v42)
          {
            v55 -= 48;
            sub_100684D00(v55);
          }
        }
        if (v42) {
          operator delete((void *)v42);
        }
      }
      else
      {
        *(void *)unint64_t v42 = 0;
        *(void *)unint64_t v42 = *(void *)buf;
        *(void *)long long buf = 0;
        long long v43 = *(_OWORD *)&buf[8];
        *(void *)(v42 + 24) = *(void *)&buf[24];
        *(_OWORD *)(v42 + 8) = v43;
        memset(&buf[8], 0, 24);
        *(_OWORD *)(v42 + 32) = 0u;
        *(_OWORD *)(v42 + 32) = v95;
        long long v95 = 0u;
        int v44 = (char *)(v42 + 48);
      }
      *(void *)(a1 + 192) = v44;
      sub_1000558F4((const void **)&v95 + 1);
      sub_1000558F4((const void **)&v95);
      if ((buf[31] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[8]);
      }
      sub_100057D78((const void **)buf);
      sub_1000558F4((const void **)&v109 + 1);
      sub_1000558F4((const void **)&v109);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      xpc_release(v99);
      xpc_release(v104);
      goto LABEL_93;
    }
    xpc_object_t v29 = xpc_null_create();
LABEL_48:
    xpc_object_t v104 = v29;
    goto LABEL_49;
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  uint64_t v20 = 0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I GSMA Settings key is not present. Hide the switch.", buf, 2u);
    uint64_t v20 = 0;
  }
LABEL_123:
  sub_100062778((const void **)&v93);
  return v20;
}

void sub_100677990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,const void *a34,const void *a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,xpc_object_t a46,xpc_object_t a47,xpc_object_t a48,xpc_object_t object)
{
  sub_100062778((const void **)(v51 - 128));
  if (a41 < 0) {
    operator delete(__p);
  }
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v49);
  }
  sub_1000558F4(&a19);
  sub_1000558F4(&a20);
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  sub_100057D78(&a34);
  sub_100062778(&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_100677C10(uint64_t a1, uint64_t a2, const void **a3, const void **a4)
{
  sub_100058198(&v33, a3);
  sub_100058198(&v32, a4);
  int v31 = 0;
  v34[0] = off_1019F7DD8;
  v34[1] = a2;
  v34[3] = v34;
  LOBYTE(a4) = sub_100671D84(a2, 3u, &v33, &v32, (WirelessTechnologyList *)&v31, 0, 1, (uint64_t)v34);
  sub_10003B34C(v34);
  sub_100057D78(&v32);
  sub_100057D78(&v33);
  sub_100673654(a2, 3u, (char)a4, 1);
  uint64_t v13 = 0x100000003;
  *(void *)&long long v14 = &v13;
  uint64_t v7 = sub_100688D4C((uint64_t **)(a2 + 136), (unsigned __int8 *)&v13, (uint64_t)&unk_10144E20E, (void **)&v14);
  sub_10000BE9C((uint64_t)&v14, (uint64_t)(v7 + 40));
  *(void *)(a1 + 16) = v15;
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v17;
  *(void *)(a1 + 64) = v19;
  *(void *)(a1 + 88) = v21;
  *(void *)(a1 + 112) = v23;
  *(unsigned char *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v24;
  uint64_t v8 = v28;
  *(void *)(a1 + 144) = v26;
  *(_OWORD *)a1 = v14;
  long long v14 = 0uLL;
  long long v9 = v16;
  uint64_t v15 = 0;
  *(void *)&long long v16 = 0;
  *(_OWORD *)(a1 + 24) = v9;
  *((void *)&v16 + 1) = 0;
  uint64_t v17 = 0;
  *(_OWORD *)(a1 + 48) = v18;
  long long v18 = 0uLL;
  *(_OWORD *)(a1 + 72) = v20;
  uint64_t v19 = 0;
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  *(_OWORD *)(a1 + 96) = v22;
  long long v22 = 0uLL;
  *(_OWORD *)(a1 + 128) = v25;
  uint64_t v23 = 0;
  long long v25 = 0uLL;
  long long v10 = v27;
  *(void *)(a1 + 168) = v8;
  *(_OWORD *)(a1 + 152) = v10;
  uint64_t v28 = 0;
  uint64_t v26 = 0;
  long long v27 = 0uLL;
  long long v11 = v29;
  *(void *)(a1 + 192) = v30;
  *(_OWORD *)(a1 + 176) = v11;
  long long v29 = 0uLL;
  uint64_t v30 = 0;
  *(unsigned char *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = (_BYTE)a4;
  return sub_10000BDF8((uint64_t)&v14);
}

void sub_100677E10(_Unwind_Exception *a1)
{
  sub_10003B34C((void *)(v1 - 72));
  sub_100057D78((const void **)(v1 - 96));
  sub_100057D78((const void **)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_100677E3C(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, int a5)
{
  sub_100058198(&v42, a3);
  unint64_t v41 = 0;
  int v40 = 0;
  v44[0] = off_1019F7E58;
  v44[3] = v44;
  char v10 = sub_100671D84(a2, 2u, &v42, &v41, (WirelessTechnologyList *)&v40, a5, a4, (uint64_t)v44);
  sub_10003B34C(v44);
  sub_100057D78(&v41);
  sub_100057D78(&v42);
  long long v11 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Need to check if country operator bundle needs to be updated", (uint8_t *)buf, 2u);
  }
  long long v39 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_100058198(&cf, a3);
  *(void *)&long long v20 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100678168((uint64_t)buf, a2, 6u, (const void **)&v20, a4, a5);
  sub_100057D78((const void **)&v20);
  sub_100057D78(&cf);
  char v12 = BYTE8(v39);
  if (v10) {
    char v12 = v10;
  }
  sub_100673654(a2, 2u, v12, a4);
  uint64_t v19 = (a4 << 32) | 2;
  long long v43 = &v19;
  uint64_t v13 = sub_100688D4C((uint64_t **)(a2 + 136), (unsigned __int8 *)&v19, (uint64_t)&unk_10144E20E, &v43);
  sub_10000BE9C((uint64_t)&v20, (uint64_t)(v13 + 40));
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v23;
  *(void *)(a1 + 64) = v25;
  *(void *)(a1 + 88) = v27;
  *(void *)(a1 + 112) = v29;
  *(unsigned char *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v30;
  uint64_t v14 = v34;
  *(void *)(a1 + 144) = v32;
  *(_OWORD *)a1 = v20;
  long long v20 = 0uLL;
  long long v15 = v22;
  uint64_t v21 = 0;
  *(void *)&long long v22 = 0;
  *(_OWORD *)(a1 + 24) = v15;
  *((void *)&v22 + 1) = 0;
  uint64_t v23 = 0;
  *(_OWORD *)(a1 + 48) = v24;
  long long v24 = 0uLL;
  *(_OWORD *)(a1 + 72) = v26;
  uint64_t v25 = 0;
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  *(_OWORD *)(a1 + 96) = v28;
  long long v28 = 0uLL;
  *(_OWORD *)(a1 + 128) = v31;
  uint64_t v29 = 0;
  long long v31 = 0uLL;
  long long v16 = v33;
  *(void *)(a1 + 168) = v14;
  *(_OWORD *)(a1 + 152) = v16;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  long long v33 = 0uLL;
  long long v17 = v35;
  *(void *)(a1 + 192) = v36;
  *(_OWORD *)(a1 + 176) = v17;
  long long v35 = 0uLL;
  uint64_t v36 = 0;
  *(unsigned char *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = v10;
  sub_10000BDF8((uint64_t)&v20);
  return sub_10000BDF8((uint64_t)buf);
}

void sub_10067810C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,int a37,__int16 a38,char a39,char a40)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100678168(uint64_t a1, uint64_t a2, unsigned int a3, const void **a4, uint64_t a5, int a6)
{
  char v12 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a5);
  uint64_t v13 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Starting %s country bundle match", (uint8_t *)&buf, 0xCu);
  }
  CFDictionaryRef v14 = (const __CFDictionary *)*a4;
  if (*a4) {
    long long v15 = sub_100080778;
  }
  else {
    long long v15 = 0;
  }
  if (v15)
  {
    uint64_t v67 = 0;
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v14);
    sub_100058198(&v66, a4);
    BOOL v16 = sub_1004D4A44((const __CFDictionary **)&v66);
    sub_100057D78(&v66);
    if (v16)
    {
      uint64_t v17 = *(void *)(a2 + 2288);
      if (v17)
      {
        uint64_t v18 = a2 + 2288;
        do
        {
          int v19 = *(_DWORD *)(v17 + 32);
          BOOL v20 = v19 < (int)a5;
          if (v19 >= (int)a5) {
            uint64_t v21 = (uint64_t *)v17;
          }
          else {
            uint64_t v21 = (uint64_t *)(v17 + 8);
          }
          if (!v20) {
            uint64_t v18 = v17;
          }
          uint64_t v17 = *v21;
        }
        while (*v21);
        if (v18 != a2 + 2288 && *(_DWORD *)(v18 + 32) <= (int)a5)
        {
          long long buf = 0u;
          *(_OWORD *)xpc_object_t v76 = 0u;
          MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v18 + 40));
          if (MCC::valid((MCC *)&buf))
          {
            long long v22 = theDict;
            uint64_t v23 = (const void *)qword_101B13EC0;
            MCC::getStringValue((uint64_t *)v63, (MCC *)&buf);
            if (SHIBYTE(v64) < 0)
            {
              sub_10004FC84(&__dst, v63[0], (unint64_t)v63[1]);
            }
            else
            {
              long long __dst = *(_OWORD *)v63;
              uint64_t v92 = v64;
            }
            char v69 = 0;
            if (SHIBYTE(v92) < 0)
            {
              sub_10004FC84(__p, (void *)__dst, *((unint64_t *)&__dst + 1));
            }
            else
            {
              *(_OWORD *)long long __p = __dst;
              uint64_t v71 = v92;
            }
            xpc_object_t v72 = 0;
            if (ctu::cf::convert_copy())
            {
              char v57 = v69;
              char v69 = v72;
              xpc_object_t v73 = v57;
              sub_1000558F4(&v73);
            }
            if (SHIBYTE(v71) < 0) {
              operator delete(__p[0]);
            }
            uint64_t v58 = v69;
            unsigned int v65 = v69;
            char v69 = 0;
            sub_1000558F4(&v69);
            if (SHIBYTE(v92) < 0) {
              operator delete((void *)__dst);
            }
            CFDictionarySetValue(v22, v23, v58);
            sub_1000558F4(&v65);
            if (SHIBYTE(v64) < 0) {
              operator delete(v63[0]);
            }
          }
          if ((v76[15] & 0x80000000) != 0) {
            operator delete(*((void **)&buf + 1));
          }
        }
      }
LABEL_49:
      sub_10004EFE4(&v62, (CFTypeRef *)&theDict);
      uint64_t v61 = 0;
      int v60 = 0;
      v74[0] = off_1019F7ED8;
      v74[3] = v74;
      char v48 = sub_100671D84(a2, a3, &v62, &v61, (WirelessTechnologyList *)&v60, a6, a5, (uint64_t)v74);
      sub_10003B34C(v74);
      sub_100057D78(&v61);
      sub_100057D78(&v62);
      *(void *)&long long __dst = a3 | (unint64_t)(a5 << 32);
      __p[0] = &__dst;
      long long v49 = sub_100688D4C((uint64_t **)(a2 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)__p);
      sub_10000BE9C((uint64_t)&buf, (uint64_t)(v49 + 40));
      *(_OWORD *)a1 = buf;
      *(void *)(a1 + 16) = *(void *)v76;
      long long buf = 0uLL;
      long long v50 = *(_OWORD *)&v76[8];
      *(void *)xpc_object_t v76 = 0;
      *(void *)&v76[8] = 0;
      *(_OWORD *)(a1 + 24) = v50;
      *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v77;
      *(void *)&v76[16] = 0;
      uint64_t v77 = 0;
      *(void *)(a1 + 64) = v79;
      *(_OWORD *)(a1 + 48) = v78;
      long long v78 = 0uLL;
      long long v51 = v80;
      *(void *)(a1 + 88) = v81;
      *(_OWORD *)(a1 + 72) = v51;
      uint64_t v79 = 0;
      long long v80 = 0uLL;
      uint64_t v81 = 0;
      long long v52 = v82;
      *(void *)(a1 + 112) = v83;
      *(_OWORD *)(a1 + 96) = v52;
      long long v82 = 0uLL;
      uint64_t v83 = 0;
      *(unsigned char *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v84;
      long long v53 = v85;
      *(void *)(a1 + 144) = v86;
      *(_OWORD *)(a1 + 128) = v53;
      long long v85 = 0uLL;
      long long v54 = v87;
      *(void *)(a1 + 168) = v88;
      *(_OWORD *)(a1 + 152) = v54;
      uint64_t v86 = 0;
      long long v87 = 0uLL;
      uint64_t v88 = 0;
      long long v55 = v89;
      *(void *)(a1 + 192) = v90;
      *(_OWORD *)(a1 + 176) = v55;
      long long v89 = 0uLL;
      uint64_t v90 = 0;
      *(unsigned char *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = v48;
      sub_10000BDF8((uint64_t)&buf);
      sub_100057D78(&v67);
      return sub_10005717C((const void **)&theDict);
    }
    xpc_object_t v73 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 104));
    uint64_t v34 = ServiceMap;
    if (v35 < 0)
    {
      uint64_t v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        uint64_t v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v35;
    long long v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&buf);
    int v59 = a6;
    if (v39)
    {
      uint64_t v41 = v39[3];
      int v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        char v42 = 0;
LABEL_32:
        if (a3 == 5) {
          uint64_t v43 = 1;
        }
        else {
          uint64_t v43 = 2 * (a3 == 6);
        }
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v41 + 80))(__p, v41, a5, v43, @"HomeBundleIdentifier", 0, 0);
        sub_100056248(&v73, (CFTypeRef *)__p);
        a6 = v59;
        sub_1000577C4((const void **)__p);
        if ((v42 & 1) == 0) {
          sub_10004D2C8(v40);
        }
        int v44 = v73;
        if (v73) {
          uint64_t v45 = sub_1000810B8;
        }
        else {
          uint64_t v45 = 0;
        }
        if (v45)
        {
          unint64_t v46 = *v12;
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            long long buf = 0uLL;
            *(void *)xpc_object_t v76 = 0;
            ctu::cf::assign();
            *(_OWORD *)long long __p = buf;
            uint64_t v71 = *(void *)v76;
            unint64_t v47 = __p;
            if (v76[7] < 0) {
              unint64_t v47 = (void **)__p[0];
            }
            LODWORD(__dst) = 136446210;
            *(void *)((char *)&__dst + 4) = v47;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Home bundle Identifier: %{public}s", (uint8_t *)&__dst, 0xCu);
            if (SHIBYTE(v71) < 0) {
              operator delete(__p[0]);
            }
            int v44 = v73;
          }
          CFDictionarySetValue(theDict, @"HomeBundleIdentifier", v44);
        }
        sub_1000558F4(&v73);
        goto LABEL_49;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v34);
    int v40 = 0;
    char v42 = 1;
    goto LABEL_32;
  }
  long long v24 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v56 = asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v56;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Missing matching info. Unable to match %s bundle", (uint8_t *)&buf, 0xCu);
  }
  __p[0] = (void *)(a3 | (unint64_t)(a5 << 32));
  *(void *)&long long buf = __p;
  uint64_t v25 = sub_100688D4C((uint64_t **)(a2 + 136), (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, (void **)&buf);
  sub_10000BE9C((uint64_t)&buf, (uint64_t)(v25 + 40));
  *(_OWORD *)a1 = buf;
  *(void *)(a1 + 16) = *(void *)v76;
  long long buf = 0uLL;
  long long v26 = *(_OWORD *)&v76[8];
  *(void *)xpc_object_t v76 = 0;
  *(void *)&v76[8] = 0;
  *(_OWORD *)(a1 + 24) = v26;
  *(void *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v77;
  *(void *)&v76[16] = 0;
  uint64_t v77 = 0;
  *(void *)(a1 + 64) = v79;
  *(_OWORD *)(a1 + 48) = v78;
  long long v78 = 0uLL;
  long long v27 = v80;
  *(void *)(a1 + 88) = v81;
  *(_OWORD *)(a1 + 72) = v27;
  uint64_t v79 = 0;
  long long v80 = 0uLL;
  uint64_t v81 = 0;
  long long v28 = v82;
  *(void *)(a1 + 112) = v83;
  *(_OWORD *)(a1 + 96) = v28;
  long long v82 = 0uLL;
  uint64_t v83 = 0;
  *(unsigned char *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v84;
  long long v29 = v85;
  *(void *)(a1 + 144) = v86;
  *(_OWORD *)(a1 + 128) = v29;
  long long v85 = 0uLL;
  long long v30 = v87;
  *(void *)(a1 + 168) = v88;
  *(_OWORD *)(a1 + 152) = v30;
  uint64_t v86 = 0;
  long long v87 = 0uLL;
  uint64_t v88 = 0;
  long long v31 = v89;
  *(void *)(a1 + 192) = v90;
  *(_OWORD *)(a1 + 176) = v31;
  long long v89 = 0uLL;
  uint64_t v90 = 0;
  *(unsigned char *)(a1 + 20sub_10010E764((uint64_t)&a9, 0) = 0;
  return (const void **)sub_10000BDF8((uint64_t)&buf);
}

void sub_100678920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,const void *a21,const void *a22,const void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  sub_1000558F4(&a23);
  if (*(char *)(v41 - 105) < 0) {
    operator delete(*(void **)(v40 + 240));
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a40 < 0) {
    operator delete(*(void **)(v40 + 40));
  }
  sub_100057D78(&a21);
  sub_10005717C(&a22);
  _Unwind_Resume(a1);
}

void sub_100678A54(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100678B30(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 168);
  sub_1006888D0(*(void **)(a1 + 168));
  *(v2 - 1) = v2;
  void *v2 = 0;
  v2[1] = 0;
  uint64_t v5 = v2 + 2;
  uint64_t v4 = v2[2];
  for (uint64_t i = v5[1]; i != v4; sub_100684D00(i))
    i -= 48;
  *(void *)(a1 + 192) = v4;
  xpc_object_t v74 = 0;
  uint64_t v6 = off_101B0AEB0[0];
  uint64_t v7 = off_101B0AEE0[0];
  sub_1006941A8(buf);
  sub_1006940C4(v7, (void **)buf, (uint64_t)v6, &v74);
  xpc_release(*(xpc_object_t *)&buf[0]);
  uint64_t v8 = *(void *)(a1 + 120);
  xpc_object_t v72 = v74;
  if (v74) {
    xpc_retain(v74);
  }
  else {
    xpc_object_t v72 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v8 + 16))(&v73, v8, &v72);
  xpc_release(v73);
  xpc_object_t v73 = 0;
  xpc_release(v72);
  xpc_object_t v72 = 0;
  sub_100671AF0((uint64_t)v71, a1);
  sub_10000BDF8((uint64_t)v71);
  v75[0] = (void *)(&_mh_execute_header + 3);
  *(void *)&buf[0] = v75;
  long long v9 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)v75, (uint64_t)&unk_10144E20E, (void **)buf);
  sub_100058198(&v69, (const void **)v9 + 30);
  long long v85 = (uint64_t **)(&_mh_execute_header + 3);
  *(void *)&buf[0] = &v85;
  char v10 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v85, (uint64_t)&unk_10144E20E, (void **)buf);
  sub_100058198(&v68, (const void **)v10 + 31);
  sub_100677C10((uint64_t)v70, a1, &v69, &v68);
  sub_10000BDF8((uint64_t)v70);
  sub_100057D78(&v68);
  sub_100057D78(&v69);
  subscriber::makeSimSlotRange();
  long long v11 = (unsigned int *)*((void *)&buf[0] + 1);
  char v12 = *(unsigned int **)&buf[0];
  if (*(void *)&buf[0] != *((void *)&buf[0] + 1))
  {
    uint64_t v13 = *(uint64_t (**)(void))&buf[1];
    while ((v13(*v12) & 1) == 0)
    {
      if (++v12 == v11)
      {
        char v12 = v11;
        break;
      }
    }
    CFDictionaryRef v14 = (unsigned int *)*((void *)&buf[0] + 1);
    while (v12 != v14)
    {
      uint64_t v15 = *v12;
      long long v85 = (uint64_t **)((v15 << 32) | 1);
      v75[0] = &v85;
      BOOL v16 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v85, (uint64_t)&unk_10144E20E, v75);
      sub_100058198(&v66, (const void **)v16 + 30);
      uint64_t v82 = (v15 << 32) | 1;
      v75[0] = &v82;
      uint64_t v17 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v82, (uint64_t)&unk_10144E20E, v75);
      sub_100058198(&v65, (const void **)v17 + 31);
      uint64_t v79 = (v15 << 32) | 1;
      v75[0] = &v79;
      int v64 = *((_DWORD *)sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)&v79, (uint64_t)&unk_10144E20E, v75) + 64);
      CarrierBundleHandler::matchCarrierBundle_sync(a1, &v66, &v65, &v64, v15, 0, (uint64_t)v67);
      sub_10000BDF8((uint64_t)v67);
      sub_100057D78(&v65);
      sub_100057D78(&v66);
      CarrierBundleHandler::handleOperatorBundleSetup_sync(a1, v15, 0);
      uint64_t v18 = v12 + 1;
      char v12 = v11;
      if (v18 != v11)
      {
        char v12 = v18;
        while ((v13(*v12) & 1) == 0)
        {
          if (++v12 == v11)
          {
            char v12 = v11;
            break;
          }
        }
      }
    }
  }
  uint64_t v86 = 0;
  uint64_t v87 = 0;
  long long v85 = &v86;
  subscriber::makeSimSlotRange();
  int v19 = (unsigned int *)v82;
  BOOL v20 = v83;
  if ((unsigned int *)v82 != v83)
  {
    uint64_t v21 = v84;
    while ((v21(*v19) & 1) == 0)
    {
      if (++v19 == v20)
      {
        int v19 = v20;
        break;
      }
    }
    uint64_t v63 = v83;
    if (v19 != v83)
    {
      long long v22 = (uint64_t *)(a1 + 144);
      do
      {
        uint64_t v23 = *v19;
        uint64_t v79 = 0;
        long long v80 = 0;
        uint64_t v81 = 0;
        sub_10067CDD0((uint64_t)&v79, a1, v23);
        if ((_BYTE)v79)
        {
          uint64_t v24 = *v22;
          if (*v22)
          {
            uint64_t v25 = a1 + 144;
            do
            {
              if (*(unsigned char *)(v24 + 32)) {
                char v26 = 1;
              }
              else {
                char v26 = -1;
              }
              if (*(unsigned char *)(v24 + 32) == 1)
              {
                int v27 = *(_DWORD *)(v24 + 36);
                BOOL v28 = v27 == v23;
                char v26 = v27 >= (int)v23 ? 1 : -1;
                if (v28) {
                  char v26 = 0;
                }
              }
              BOOL v29 = (v26 & 0x80) == 0;
              if (v26 < 0) {
                long long v30 = (uint64_t *)(v24 + 8);
              }
              else {
                long long v30 = (uint64_t *)v24;
              }
              if (v29) {
                uint64_t v25 = v24;
              }
              uint64_t v24 = *v30;
            }
            while (*v30);
            if (v22 != (uint64_t *)v25)
            {
              unsigned int v31 = *(unsigned __int8 *)(v25 + 32);
              BOOL v32 = v31 == 1;
              if (v31 <= 1) {
                char v33 = 1;
              }
              else {
                char v33 = -1;
              }
              if (v32)
              {
                int v34 = *(_DWORD *)(v25 + 36);
                BOOL v35 = v34 == v23;
                char v33 = v34 <= (int)v23 ? 1 : -1;
                if (v35) {
                  char v33 = 0;
                }
              }
              if ((v33 & 0x80) == 0)
              {
                uint64_t v78 = 0;
                long long v76 = 0u;
                long long v77 = 0u;
                memset(v75, 0, sizeof(v75));
                sub_10000BE9C((uint64_t)v75, v25 + 40);
                sub_100058198((const void **)&v76 + 1, (const void **)(v25 + 240));
                sub_100058198((const void **)&v77, (const void **)(v25 + 248));
                DWORD2(v77) = *(_DWORD *)(v25 + 256);
                LOBYTE(v78) = 0;
                sub_10000BE9C((uint64_t)buf, (uint64_t)v75);
                long long v102 = (const void *)*((void *)&v76 + 1);
                if (*((void *)&v76 + 1)) {
                  CFRetain(*((CFTypeRef *)&v76 + 1));
                }
                xpc_object_t v103 = (const void *)v77;
                if ((void)v77) {
                  CFRetain((CFTypeRef)v77);
                }
                int v104 = DWORD2(v77);
                char v105 = v78;
                char v106 = v79;
                *(void *)&long long v107 = v80;
                if (v80) {
                  CFRetain(v80);
                }
                *((void *)&v107 + 1) = v81;
                if (v81) {
                  CFRetain(v81);
                }
                uint64_t v36 = v86;
                for (j = &v86; ; uint64_t v36 = *j)
                {
                  unsigned int v38 = j;
                  if (!v36) {
                    break;
                  }
                  while (1)
                  {
                    uint64_t j = (uint64_t **)v36;
                    int v39 = *((_DWORD *)v36 + 8);
                    if (v39 > (int)v23) {
                      break;
                    }
                    if (v39 >= (int)v23) {
                      goto LABEL_79;
                    }
                    uint64_t v36 = j[1];
                    if (!v36)
                    {
                      unsigned int v38 = j + 1;
                      goto LABEL_76;
                    }
                  }
                }
LABEL_76:
                unint64_t v46 = (char *)operator new(0x110uLL);
                *((_DWORD *)v46 + 8) = v23;
                *(_OWORD *)(v46 + 4sub_10010E764((uint64_t)&a9, 0) = buf[0];
                *((void *)v46 + 7) = *(void *)&buf[1];
                memset(buf, 0, 24);
                *((_OWORD *)v46 + 4) = *(_OWORD *)((char *)&buf[1] + 8);
                *((void *)v46 + 1sub_10010E764((uint64_t)&a9, 0) = *((void *)&buf[2] + 1);
                memset((char *)&buf[1] + 8, 0, 24);
                *((void *)v46 + 13) = v90;
                *(_OWORD *)(v46 + 88) = v89;
                uint64_t v90 = 0;
                long long v89 = 0u;
                long long v47 = v91;
                *((void *)v46 + 16) = v92;
                *((_OWORD *)v46 + 7) = v47;
                uint64_t v92 = 0;
                long long v91 = 0u;
                long long v48 = v93;
                *((void *)v46 + 19) = v94;
                *(_OWORD *)(v46 + 136) = v48;
                uint64_t v94 = 0;
                long long v93 = 0u;
                v46[160] = v95;
                long long v49 = v96;
                *((void *)v46 + 23) = v97;
                *(_OWORD *)(v46 + 168) = v49;
                uint64_t v97 = 0;
                long long v96 = 0u;
                long long v50 = v98;
                *((void *)v46 + 26) = v99;
                *((_OWORD *)v46 + 12) = v50;
                uint64_t v99 = 0;
                long long v98 = 0u;
                long long v51 = v100;
                *((void *)v46 + 29) = v101;
                *(_OWORD *)(v46 + 216) = v51;
                uint64_t v101 = 0;
                long long v100 = 0u;
                v46[240] = v105;
                v46[248] = v106;
                *((_OWORD *)v46 + 16) = v107;
                long long v107 = 0u;
                *(_OWORD *)unint64_t v46 = 0u;
                *((void *)v46 + 2) = j;
                *unsigned int v38 = (uint64_t *)v46;
                if (*v85)
                {
                  long long v85 = (uint64_t **)*v85;
                  unint64_t v46 = (char *)*v38;
                }
                sub_100046C90(v86, (uint64_t *)v46);
                ++v87;
LABEL_79:
                sub_100057D78((const void **)&v107 + 1);
                sub_100057D78((const void **)&v107);
                sub_100057D78(&v103);
                sub_100057D78(&v102);
                sub_10000BDF8((uint64_t)buf);
                sub_100057D78((const void **)&v77);
                sub_100057D78((const void **)&v76 + 1);
                sub_10000BDF8((uint64_t)v75);
                goto LABEL_80;
              }
            }
          }
          uint64_t v40 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v23);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v41 = asString();
            LODWORD(buf[0]) = 136315138;
            *(void *)((char *)buf + 4) = v41;
            char v42 = v40;
            uint64_t v43 = "#N Could not find linked %s bundle for install update check";
LABEL_75:
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v43, (uint8_t *)buf, 0xCu);
          }
        }
        else
        {
          int v44 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v23);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = asString();
            LODWORD(buf[0]) = 136315138;
            *(void *)((char *)buf + 4) = v45;
            char v42 = v44;
            uint64_t v43 = "#N Ignoring bundle type: %s";
            goto LABEL_75;
          }
        }
LABEL_80:
        sub_100057D78(&v81);
        sub_100057D78(&v80);
        long long v52 = v19 + 1;
        int v19 = v20;
        if (v52 != v20)
        {
          int v19 = v52;
          while ((v21(*v19) & 1) == 0)
          {
            if (++v19 == v20)
            {
              int v19 = v20;
              break;
            }
          }
        }
      }
      while (v19 != v63);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  long long v54 = ServiceMap;
  if (v55 < 0)
  {
    uint64_t v56 = (unsigned __int8 *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v57 = 5381;
    do
    {
      uint64_t v55 = v57;
      unsigned int v58 = *v56++;
      uint64_t v57 = (33 * v57) ^ v58;
    }
    while (v58);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&buf[0] = v55;
  int v59 = sub_10004D37C(&v54[1].__m_.__sig, (unint64_t *)buf);
  if (!v59)
  {
    uint64_t v61 = 0;
LABEL_94:
    std::mutex::unlock(v54);
    int v60 = 0;
    char v62 = 1;
    if (!v61) {
      goto LABEL_96;
    }
    goto LABEL_95;
  }
  uint64_t v61 = v59[3];
  int v60 = (std::__shared_weak_count *)v59[4];
  if (!v60) {
    goto LABEL_94;
  }
  atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v54);
  atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v60);
  char v62 = 0;
  if (v61)
  {
LABEL_95:
    sub_10069AF38((uint64_t *)buf, (uint64_t)&v85);
    (*(void (**)(uint64_t, _OWORD *))(*(void *)v61 + 88))(v61, buf);
    sub_10069AE60((uint64_t)buf, *((const void ***)&buf[0] + 1));
  }
LABEL_96:
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v60);
  }
  sub_10069AE60((uint64_t)&v85, (const void **)v86);
  xpc_release(v74);
}

void sub_1006794F0(_Unwind_Exception *a1)
{
  sub_10069AE60((uint64_t)&STACK[0x490], (const void **)STACK[0x498]);
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  sub_10069AE60((uint64_t)&STACK[0x478], *(const void ***)(v3 + 320));
  xpc_release(*(xpc_object_t *)(v3 + 16));
  _Unwind_Resume(a1);
}

const void **sub_100679644(const void **a1, uint64_t a2, const MCC *a3, const MNC *a4, uint64_t a5)
{
  CFArrayRef theArray = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 104));
  long long v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long value = v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&value);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v18 + 80))(__p, v18, a5, 1, @"SupportedPLMNs", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  CFArrayRef v20 = theArray;
  if (theArray) {
    uint64_t v21 = sub_100083F10;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v21)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    createCFPLMN(a3, a4);
    v73.locatiouint64_t n = 0;
    v73.length = Count;
    int v23 = CFArrayContainsValue(v20, v73, (const void *)value);
    sub_1000558F4((const void **)&value);
    if (v23)
    {
      sub_10067BFBC(a1, a2, a5);
      return sub_100044D00((const void **)&theArray);
    }
    uint64_t v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a5);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      IntCFDictionaryRef Value = MCC::getIntValue(a3);
      int IntegerWidth = MNC::getIntegerWidth(a4);
      int v27 = MCC::getIntValue(a4);
      LODWORD(value) = 67109632;
      DWORD1(value) = IntValue;
      WORD4(value) = 1024;
      *(_DWORD *)((char *)&value + 1sub_10010E764((uint64_t)&a9, 0) = IntegerWidth;
      HIWORD(value) = 1024;
      LODWORD(v66) = v27;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Current PLMN %d-%0.*d is not present in the Supported PLMNs", (uint8_t *)&value, 0x14u);
    }
  }
  v54[0] = 0;
  v54[1] = 0;
  uint64_t v55 = 0;
  formPLMN(a3, a4);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v53 = Mutable;
  BOOL v29 = (const void *)qword_101B13EC0;
  *(_OWORD *)long long __dst = *(_OWORD *)v54;
  uint64_t v51 = 0;
  *(_OWORD *)long long __p = *(_OWORD *)v54;
  uint64_t v61 = 0;
  uint64_t v57 = 0;
  long long value = *(_OWORD *)v54;
  *(void *)&long long v66 = 0;
  unsigned int v58 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v30 = v57;
    uint64_t v57 = v58;
    int v59 = v30;
    sub_1000558F4(&v59);
  }
  if (SBYTE7(v66) < 0) {
    operator delete((void *)value);
  }
  long long v52 = v57;
  uint64_t v57 = 0;
  sub_1000558F4((const void **)&v57);
  if (SHIBYTE(v61) < 0) {
    operator delete(__p[0]);
  }
  CFDictionaryAddValue(Mutable, v29, v52);
  sub_1000558F4((const void **)&v52);
  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long value = 0u;
  long long v66 = 0u;
  sub_10004EFE4(&v49, (CFTypeRef *)&v53);
  CarrierBundleHandler::lookupBundle_sync(a2, 2u, &v49, (uint64_t)&value);
  sub_100057D78(&v49);
  uint64_t v31 = BYTE7(v66);
  if (SBYTE7(v66) < 0) {
    uint64_t v31 = *((void *)&value + 1);
  }
  if (v31)
  {
    sub_1000292E0((uint64_t)__p);
    if ((SBYTE7(v66) & 0x80u) == 0) {
      BOOL v32 = (void *)BYTE7(v66);
    }
    else {
      BOOL v32 = (void *)*((void *)&value + 1);
    }
    char v33 = (void *)HIBYTE(v61);
    int v34 = SHIBYTE(v61);
    if (v61 < 0) {
      char v33 = __p[1];
    }
    if (v32 != v33)
    {
      BOOL v44 = 0;
      if ((SHIBYTE(v61) & 0x80000000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_49;
    }
    if (v61 >= 0) {
      BOOL v35 = __p;
    }
    else {
      BOOL v35 = (void **)__p[0];
    }
    if ((BYTE7(v66) & 0x80) != 0)
    {
      BOOL v44 = memcmp((const void *)value, v35, *((size_t *)&value + 1)) == 0;
    }
    else
    {
      if (!BYTE7(v66))
      {
        BOOL v44 = 1;
        if ((SHIBYTE(v61) & 0x80000000) == 0)
        {
LABEL_53:
          if (!v44) {
            goto LABEL_65;
          }
          goto LABEL_54;
        }
LABEL_49:
        operator delete(__p[0]);
        if (!v44) {
          goto LABEL_65;
        }
        goto LABEL_54;
      }
      uint64_t v36 = BYTE7(v66) - 1;
      p_long long value = &value;
      do
      {
        int v39 = *(unsigned __int8 *)p_value;
        p_long long value = (long long *)((char *)p_value + 1);
        int v38 = v39;
        int v41 = *(unsigned __int8 *)v35;
        BOOL v35 = (void **)((char *)v35 + 1);
        int v40 = v41;
        BOOL v43 = v36-- != 0;
        BOOL v44 = v38 == v40;
      }
      while (v38 == v40 && v43);
    }
    if ((v34 & 0x80000000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
LABEL_54:
  *a1 = 0;
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)__p, a3, a4);
  CarrierBundleHandler::lookupEquivalentBundleNameForMccAndMnc_sync((uint64_t **)a2, (const MCCAndMNC *)__p, a1);
  if (v64 < 0) {
    operator delete(v63);
  }
  if (v62 < 0) {
    operator delete(__p[1]);
  }
  uint64_t v45 = (void *)*a1;
  if (*a1) {
    unint64_t v46 = sub_100080778;
  }
  else {
    unint64_t v46 = 0;
  }
  if (v46)
  {
    long long v47 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__p[0]) = 138412290;
      *(void **)((char *)__p + 4) = v45;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Found equivalent matching info: %@", (uint8_t *)__p, 0xCu);
    }
    goto LABEL_66;
  }
  sub_100057D78(a1);
LABEL_65:
  sub_10004EFE4(a1, (CFTypeRef *)&v53);
LABEL_66:
  if (SBYTE7(v72) < 0) {
    operator delete((void *)v71);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete(*((void **)&v69 + 1));
  }
  if (SBYTE7(v69) < 0) {
    operator delete((void *)v68);
  }
  if (SHIBYTE(v67) < 0) {
    operator delete(*((void **)&v66 + 1));
  }
  if (SBYTE7(v66) < 0) {
    operator delete((void *)value);
  }
  sub_10005717C((const void **)&v53);
  if (SHIBYTE(v55) < 0) {
    operator delete(v54[0]);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100679C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,const void *a26,const void *a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10005717C(&a19);
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_100044D00(&a26);
  _Unwind_Resume(a1);
}

void sub_100679D88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  sub_1000577C4((const void **)va);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  JUMPOUT(0x100679D80);
}

void sub_100679DAC(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100679D80);
}

void sub_100679DBC(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 409);
  if (v3 == a2)
  {
    int v3 = a2;
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315394;
      uint64_t v10 = asString();
      __int16 v11 = 2080;
      uint64_t v12 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Internet availability is changing from %s to %s", (uint8_t *)&v9, 0x16u);
      int v3 = *(unsigned __int8 *)(a1 + 409);
    }
  }
  if (v3 == 1 && *(_DWORD *)(a1 + 412) == 5)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Internet available", (uint8_t *)&v9, 2u);
    }
    char v6 = sub_100679F70(a1);
    uint64_t v7 = *(NSObject **)(a1 + 40);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        LOWORD(v9) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Internet available, checking for bundle update", (uint8_t *)&v9, 2u);
      }
      sub_100679FCC(a1);
    }
    else if (v8)
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Internet available, but not valid time window for silent updates.", (uint8_t *)&v9, 2u);
    }
  }
}

uint64_t sub_100679F70(uint64_t a1)
{
  if (!sub_10067DB44(a1) || *(unsigned __int8 *)(a1 + 408) - 1 > 1 || sub_1006C6874()) {
    return 1;
  }
  sub_10067D784(a1, 3, 1);
  return 0;
}

const void **sub_100679FCC(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Checking if there is carrier bundle update", (uint8_t *)&__p, 2u);
  }
  if (sub_10067E160(a1, 1, 1u) || sub_10067E160(a1, 2, 1u) || (BOOL v3 = sub_10067E160(a1, 1, 3u)))
  {
LABEL_6:
    if (*(unsigned char *)(a1 + 409) == 1)
    {
      if (*(unsigned char *)(a1 + 2096))
      {
        uint64_t v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p) = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I At least one call is active, will check for update after call has ended", (uint8_t *)&__p, 2u);
        }
        return (const void **)sub_10067E2D0(a1, 6);
      }
      if (*(unsigned char *)(a1 + 434))
      {
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Plans update check is in progress, will check after that", (uint8_t *)&__p, 2u);
        }
        return (const void **)sub_10067E2D0(a1, 7);
      }
      BOOL v35 = 0;
      sub_10067E4A4(&v35, a1);
      xpc_object_t v34 = 0;
      xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v12 = v11;
      if (v11)
      {
        xpc_object_t v34 = v11;
      }
      else
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v34 = v12;
        if (!v12)
        {
          xpc_object_t v13 = xpc_null_create();
          xpc_object_t v12 = 0;
          goto LABEL_40;
        }
      }
      if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v12);
LABEL_41:
        xpc_release(v12);
        xpc_object_t v32 = xpc_string_create(off_101B0AEE8[0]);
        if (!v32) {
          xpc_object_t v32 = xpc_null_create();
        }
        long long __p = &v34;
        long long v22 = off_101B0AEB0[0];
        sub_100035E70((uint64_t)&__p, &v32, &v33);
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_release(v32);
        xpc_object_t v32 = 0;
        xpc_object_t v30 = xpc_int64_create(*(unsigned __int8 *)(a1 + 408));
        if (!v30) {
          xpc_object_t v30 = xpc_null_create();
        }
        long long __p = &v34;
        long long v22 = off_101B0B020[0];
        sub_100035E70((uint64_t)&__p, &v30, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v30);
        xpc_object_t v30 = 0;
        ctu::cf_to_xpc((uint64_t *)&v28, v35, v16);
        long long __p = &v34;
        long long v22 = off_101B0AF40[0];
        sub_100035E70((uint64_t)&__p, &v28, &v29);
        xpc_release(v29);
        xpc_object_t v29 = 0;
        xpc_release(v28);
        xpc_object_t v28 = 0;
        char v17 = sub_10067F9E0(a1);
        xpc_object_t v26 = xpc_BOOL_create(v17);
        if (!v26) {
          xpc_object_t v26 = xpc_null_create();
        }
        long long __p = &v34;
        long long v22 = off_101B0B060;
        sub_100035E70((uint64_t)&__p, &v26, &v27);
        xpc_release(v27);
        xpc_object_t v27 = 0;
        xpc_release(v26);
        xpc_object_t v25 = 0;
        xpc_object_t v26 = 0;
        uint64_t v18 = *(void *)(a1 + 120);
        xpc_object_t v24 = v34;
        if (v34) {
          xpc_retain(v34);
        }
        else {
          xpc_object_t v24 = xpc_null_create();
        }
        (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v18 + 16))(&v25, v18, &v24);
        xpc_release(v24);
        xpc_object_t v24 = 0;
        char v19 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&v34);
          CFArrayRef v20 = v23 >= 0 ? &__p : (void **)__p;
          *(_DWORD *)long long buf = 136315138;
          uint64_t v37 = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Sent request %s to check bundle update", buf, 0xCu);
          if (v23 < 0) {
            operator delete(__p);
          }
        }
        xpc_release(v25);
        xpc_release(v34);
        return sub_100057D78((const void **)&v35);
      }
      xpc_object_t v13 = xpc_null_create();
LABEL_40:
      xpc_object_t v34 = v13;
      goto LABEL_41;
    }
    char v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Internet not available, will check for update after internet is available", (uint8_t *)&__p, 2u);
    }
    return (const void **)sub_10067E2D0(a1, 5);
  }
  else
  {
    if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v3) == 2)
    {
      for (uint64_t i = *(void *)(a1 + 2072); i != *(void *)(a1 + 2080); i += 88)
      {
        if (*(unsigned char *)(i + 80)) {
          BOOL v9 = *(void *)(i + 56) == *(void *)(i + 64);
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          uint64_t v14 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Matching info not available but vinyl profile present. Continue with the update.", (uint8_t *)&__p, 2u);
          }
          goto LABEL_6;
        }
      }
    }
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Subscriber information not available, cannot check for bundle update now, will check once it is available", (uint8_t *)&__p, 2u);
    }
    return (const void **)sub_10067E2D0(a1, 4);
  }
}

void sub_10067A508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10067A5C0(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 2096)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = a2 == 0;
  }
  if (!v2 && *(_DWORD *)(a1 + 412) == 6)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315394;
      uint64_t v7 = "true";
      __int16 v8 = 2080;
      BOOL v9 = "false";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Any call active changing from %s to %s", (uint8_t *)&v6, 0x16u);
    }
    if (sub_100679F70(a1))
    {
      sub_100679FCC(a1);
    }
    else
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v6) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I No active call, but not valid time window for silent updates.", (uint8_t *)&v6, 2u);
      }
    }
  }
}

void sub_10067A6E8(uint64_t a1)
{
  xpc_object_t v110 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v110 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v110 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t v110 = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v108 = xpc_string_create(off_101B0AF38[0]);
  if (!v108) {
    xpc_object_t v108 = xpc_null_create();
  }
  *(void *)&long long buf = &v110;
  *((char **)&buf + 1) = off_101B0AEB0[0];
  sub_100035E70((uint64_t)&buf, &v108, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v108);
  xpc_object_t v108 = 0;
  uint64_t v5 = *(void *)(a1 + 120);
  xpc_object_t v106 = v110;
  if (v110) {
    xpc_retain(v110);
  }
  else {
    xpc_object_t v106 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v5 + 16))(&v107, v5, &v106);
  xpc_release(v107);
  xpc_object_t v107 = 0;
  xpc_release(v106);
  xpc_object_t v106 = 0;
  int v6 = *(void **)(a1 + 136);
  if (v6 != (void *)(a1 + 144))
  {
    uint64_t v7 = (os_log_t *)(a1 + 40);
    do
    {
      __int16 v8 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Linked %s bundle", (uint8_t *)&buf, 0xCu);
      }
      LinkedBundleInfo::dumpState((LinkedBundleInfo *)(v6 + 5), (const ctu::OsLogLogger *)(a1 + 40));
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          xpc_object_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          xpc_object_t v11 = (void *)v6[2];
          BOOL v12 = *v11 == (void)v6;
          int v6 = v11;
        }
        while (!v12);
      }
      int v6 = v11;
    }
    while (v11 != (void *)(a1 + 144));
  }
  xpc_object_t v13 = *(void **)(a1 + 160);
  uint64_t v100 = a1;
  if (v13 != (void *)(a1 + 168))
  {
    uint64_t v14 = (os_log_t *)(a1 + 40);
    do
    {
      char v15 = *v14;
      if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Cached look up results for %s", (uint8_t *)&buf, 0xCu);
      }
      char v17 = (const __CFDictionary **)v13[5];
      uint64_t v18 = (const __CFDictionary **)v13[6];
      while (v17 != v18)
      {
        char v19 = *v14;
        if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Match criteria", (uint8_t *)&buf, 2u);
        }
        CFDictionaryRef v20 = *v17;
        v105[0] = _NSConcreteStackBlock;
        v105[1] = 0x40000000;
        v105[2] = sub_10067B720;
        v105[3] = &unk_1019F6D80;
        v105[4] = a1;
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        *(void *)&long long v122 = sub_100694264;
        *((void *)&v122 + 1) = &unk_1019F7FB0;
        uint64_t v123 = v105;
        *(void *)&long long context = &buf;
        CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)sub_10069430C, &context);
        MatchedBundle::dumpState((MatchedBundle *)(v17 + 1), (const ctu::OsLogLogger *)v14);
        v17 += 17;
      }
      uint64_t v21 = (void *)v13[1];
      if (v21)
      {
        do
        {
          long long v22 = v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          long long v22 = (void *)v13[2];
          BOOL v12 = *v22 == (void)v13;
          xpc_object_t v13 = v22;
        }
        while (!v12);
      }
      xpc_object_t v13 = v22;
    }
    while (v22 != (void *)(a1 + 168));
  }
  char v23 = *(void **)(a1 + 208);
  if (v23 != (void *)(a1 + 216))
  {
    do
    {
      xpc_object_t v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v23 + 7));
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Current technology: %s", (uint8_t *)&buf, 0xCu);
      }
      xpc_object_t v26 = (void *)v23[1];
      if (v26)
      {
        do
        {
          xpc_object_t v27 = v26;
          xpc_object_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          xpc_object_t v27 = (void *)v23[2];
          BOOL v12 = *v27 == (void)v23;
          char v23 = v27;
        }
        while (!v12);
      }
      char v23 = v27;
    }
    while (v27 != (void *)(a1 + 216));
  }
  xpc_object_t v28 = *(void **)(a1 + 232);
  if (v28 != (void *)(a1 + 240))
  {
    do
    {
      xpc_object_t v29 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
      if (*((unsigned char *)v28 + 72))
      {
        xpc_object_t v30 = *(NSObject **)v29();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          IntCFDictionaryRef Value = MCC::getIntValue((MCC *)(v28 + 5));
          LODWORD(buf) = 67109120;
          DWORD1(buf) = IntValue;
          xpc_object_t v32 = v30;
          xpc_object_t v33 = "#I Network MCC: %03d";
          uint32_t v34 = 8;
LABEL_54:
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)&buf, v34);
        }
      }
      else
      {
        BOOL v35 = *(NSObject **)v29();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          xpc_object_t v32 = v35;
          xpc_object_t v33 = "#I Network MCC: invalid";
          uint32_t v34 = 2;
          goto LABEL_54;
        }
      }
      uint64_t v36 = (void *)v28[1];
      if (v36)
      {
        do
        {
          uint64_t v37 = v36;
          uint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v37 = (void *)v28[2];
          BOOL v12 = *v37 == (void)v28;
          xpc_object_t v28 = v37;
        }
        while (!v12);
      }
      xpc_object_t v28 = v37;
    }
    while (v37 != (void *)(a1 + 240));
  }
  int v38 = *(void **)(a1 + 256);
  if (v38 != (void *)(a1 + 264))
  {
    do
    {
      int v39 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
      if (*((unsigned char *)v38 + 72))
      {
        int v40 = *(NSObject **)v39();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          int IntegerWidth = MNC::getIntegerWidth((MNC *)(v38 + 5));
          int v42 = MCC::getIntValue((MCC *)(v38 + 5));
          LODWORD(buf) = 67109376;
          DWORD1(buf) = IntegerWidth;
          WORD4(buf) = 1024;
          *(_DWORD *)((char *)&buf + 1sub_10010E764((uint64_t)&a9, 0) = v42;
          BOOL v43 = v40;
          BOOL v44 = "#I Network MNC: %0.*d";
          uint32_t v45 = 14;
LABEL_67:
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v44, (uint8_t *)&buf, v45);
        }
      }
      else
      {
        unint64_t v46 = *(NSObject **)v39();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          BOOL v43 = v46;
          BOOL v44 = "#I Network MNC: invalid";
          uint32_t v45 = 2;
          goto LABEL_67;
        }
      }
      long long v47 = (void *)v38[1];
      if (v47)
      {
        do
        {
          long long v48 = v47;
          long long v47 = (void *)*v47;
        }
        while (v47);
      }
      else
      {
        do
        {
          long long v48 = (void *)v38[2];
          BOOL v12 = *v48 == (void)v38;
          int v38 = v48;
        }
        while (!v12);
      }
      int v38 = v48;
    }
    while (v48 != (void *)(a1 + 264));
  }
  long long v49 = (os_log_t *)(a1 + 40);
  long long v50 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v51 = *(void *)(a1 + 280);
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v51;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Current Network Bundle info for CDMA 1x network: %{public}@", (uint8_t *)&buf, 0xCu);
  }
  long long v52 = *(void **)(a1 + 288);
  if (v52 != (void *)(a1 + 296))
  {
    do
    {
      CFMutableDictionaryRef v53 = *v49;
      if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I CDMA 1x cell:", (uint8_t *)&buf, 2u);
      }
      Cdma1xCell::dumpState((Cdma1xCell *)(v52 + 4), (const ctu::OsLogLogger *)(a1 + 40));
      long long v54 = *v49;
      if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
      {
        ctu::cf::show((uint64_t *)&buf, (ctu::cf *)v52[17], v55);
        uint64_t v56 = (SBYTE7(v122) & 0x80u) == 0 ? &buf : (long long *)buf;
        LODWORD(context) = 136446210;
        *(void *)((char *)&context + 4) = v56;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Matches to: %{public}s", (uint8_t *)&context, 0xCu);
        if (SBYTE7(v122) < 0) {
          operator delete((void *)buf);
        }
      }
      uint64_t v57 = (void *)v52[1];
      if (v57)
      {
        do
        {
          unsigned int v58 = v57;
          uint64_t v57 = (void *)*v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          unsigned int v58 = (void *)v52[2];
          BOOL v12 = *v58 == (void)v52;
          long long v52 = v58;
        }
        while (!v12);
      }
      long long v52 = v58;
    }
    while (v58 != (void *)(a1 + 296));
  }
  int v59 = *(std::string ***)(a1 + 312);
  if (v59 != (std::string **)(a1 + 320))
  {
    do
    {
      int v60 = *v49;
      if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I CDMA 1x cell:", (uint8_t *)&buf, 2u);
      }
      Cdma1xCell::dumpState((Cdma1xCell *)(v59 + 4), (const ctu::OsLogLogger *)(a1 + 40));
      if (*((unsigned char *)v59 + 160))
      {
        uint64_t v61 = *v49;
        if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
        {
          sub_1012121F8(v59 + 17, &buf);
          char v62 = (SBYTE7(v122) & 0x80u) == 0 ? &buf : (long long *)buf;
          LODWORD(context) = 136446210;
          *(void *)((char *)&context + 4) = v62;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Matches to bundle names: %{public}s", (uint8_t *)&context, 0xCu);
          if (SBYTE7(v122) < 0) {
            operator delete((void *)buf);
          }
        }
      }
      uint64_t v63 = v59[1];
      if (v63)
      {
        do
        {
          char v64 = (std::string ***)v63;
          uint64_t v63 = (std::string *)v63->__r_.__value_.__r.__words[0];
        }
        while (v63);
      }
      else
      {
        do
        {
          char v64 = (std::string ***)v59[2];
          BOOL v12 = *v64 == v59;
          int v59 = (std::string **)v64;
        }
        while (!v12);
      }
      int v59 = (std::string **)v64;
    }
    while (v64 != (std::string ***)(a1 + 320));
  }
  unsigned int v65 = *v49;
  if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
  {
    long long v66 = (void *)(a1 + 336);
    if (*(char *)(a1 + 359) < 0) {
      long long v66 = (void *)*v66;
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v66;
    _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I Best CDMA 1x to bundle name table path: %{public}s", (uint8_t *)&buf, 0xCu);
  }
  long long v67 = *(void **)(a1 + 360);
  if (v67 != (void *)(a1 + 368))
  {
    do
    {
      long long v68 = *v49;
      if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
      {
        MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v67 + 4));
        int v69 = MCC::getIntValue((MCC *)&buf);
        MCCAndMNC::getMnc((uint64_t *)&context, (MCCAndMNC *)(v67 + 4));
        int v70 = MNC::getIntegerWidth((MNC *)&context);
        MCCAndMNC::getMnc(v103, (MCCAndMNC *)(v67 + 4));
        int v71 = MCC::getIntValue((MCC *)v103);
        ctu::cf::show((uint64_t *)__p, (ctu::cf *)v67[12], v72);
        if (v102 >= 0) {
          CFRange v73 = __p;
        }
        else {
          CFRange v73 = (void **)__p[0];
        }
        *(_DWORD *)long long v113 = 67109890;
        int v114 = v69;
        __int16 v115 = 1024;
        int v116 = v70;
        __int16 v117 = 1024;
        int v118 = v71;
        __int16 v119 = 2082;
        char v120 = v73;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Bundle name: %03d-%0.*d matches to bundle names: %{public}s", v113, 0x1Eu);
        if (v102 < 0) {
          operator delete(__p[0]);
        }
        if (v104 < 0) {
          operator delete((void *)v103[1]);
        }
        if (v112 < 0) {
          operator delete(*((void **)&context + 1));
        }
        if (SHIBYTE(v122) < 0) {
          operator delete(*((void **)&buf + 1));
        }
      }
      xpc_object_t v74 = (void *)v67[1];
      if (v74)
      {
        do
        {
          uint64_t v75 = v74;
          xpc_object_t v74 = (void *)*v74;
        }
        while (v74);
      }
      else
      {
        do
        {
          uint64_t v75 = (void *)v67[2];
          BOOL v12 = *v75 == (void)v67;
          long long v67 = v75;
        }
        while (!v12);
      }
      long long v67 = v75;
    }
    while (v75 != (void *)(v100 + 368));
  }
  long long v76 = *v49;
  if (os_log_type_enabled(*v49, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v77 = v100;
    uint64_t v78 = (void *)(v100 + 384);
    if (*(char *)(v100 + 407) < 0) {
      uint64_t v78 = (void *)*v78;
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v78;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Best Equivalent bundle name table path: %{public}s", (uint8_t *)&buf, 0xCu);
    long long v76 = *v49;
  }
  else
  {
    uint64_t v77 = v100;
  }
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v79 = asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v79;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Internet status: %s", (uint8_t *)&buf, 0xCu);
    long long v76 = *v49;
  }
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v80 = asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v80;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Check bundle update upon: %s", (uint8_t *)&buf, 0xCu);
    long long v76 = *v49;
  }
  uint64_t v81 = *(void *)(v77 + 416);
  if (v81) {
    uint64_t v82 = sub_1001908E4;
  }
  else {
    uint64_t v82 = 0;
  }
  BOOL v83 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
  if (v82)
  {
    if (!v83) {
      goto LABEL_148;
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v81;
    char v84 = "#I Date of next update: %{public}@";
    long long v85 = v76;
    uint32_t v86 = 12;
  }
  else
  {
    if (!v83) {
      goto LABEL_148;
    }
    LOWORD(buf) = 0;
    char v84 = "#I Date of next update: not scheduled";
    long long v85 = v76;
    uint32_t v86 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v84, (uint8_t *)&buf, v86);
LABEL_148:
  uint64_t v87 = *(void **)(v77 + 2280);
  if (v87 != (void *)(v77 + 2288))
  {
    do
    {
      long long buf = 0u;
      long long v122 = 0u;
      MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v87 + 5));
      int v88 = MCC::valid((MCC *)&buf);
      long long v89 = *(uint64_t (**)(void))(**(void **)(v77 + 48) + 16);
      if (v88)
      {
        uint64_t v90 = *(NSObject **)v89();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
        {
          int v91 = MCC::getIntValue((MCC *)&buf);
          LODWORD(context) = 67109120;
          DWORD1(context) = v91;
          uint64_t v92 = v90;
          long long v93 = "#I Geo MCC: %d";
          uint32_t v94 = 8;
LABEL_154:
          _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, v93, (uint8_t *)&context, v94);
        }
      }
      else
      {
        char v95 = *(NSObject **)v89();
        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(context) = 0;
          uint64_t v92 = v95;
          long long v93 = "#I Geo MCC: invalid";
          uint32_t v94 = 2;
          goto LABEL_154;
        }
      }
      if (SHIBYTE(v122) < 0) {
        operator delete(*((void **)&buf + 1));
      }
      long long v96 = (void *)v87[1];
      if (v96)
      {
        do
        {
          uint64_t v97 = v96;
          long long v96 = (void *)*v96;
        }
        while (v96);
      }
      else
      {
        do
        {
          uint64_t v97 = (void *)v87[2];
          BOOL v12 = *v97 == (void)v87;
          uint64_t v87 = v97;
        }
        while (!v12);
      }
      uint64_t v87 = v97;
    }
    while (v97 != (void *)(v77 + 2288));
  }
  long long v98 = *v49;
  if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v99 = "true";
    if (!*(unsigned char *)(v77 + 433)) {
      uint64_t v99 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v99;
    _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "#I Show alert upon SB startup: %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_release(v110);
}

void sub_10067B600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t a31,uint64_t a32,uint64_t a33,uint64_t a34,xpc_object_t object,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10067B720(uint64_t a1, uint64_t *a2, CFTypeRef *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFTypeID v6 = CFGetTypeID(*a3);
  if (v6 == CFNumberGetTypeID())
  {
    uint64_t v7 = *(NSObject **)(v5 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    uint64_t v9 = (uint64_t *)*a3;
    *(void *)long long buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v9, v8);
    uint64_t v10 = *(void *)buf;
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&_OWORD buf[12] = 2048;
    *(void *)&buf[14] = v10;
    xpc_object_t v11 = "#I   %s = %lld";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v11, buf, 0x16u);
    return;
  }
  CFTypeID v12 = CFGetTypeID(*a3);
  CFTypeID TypeID = CFStringGetTypeID();
  uint64_t v7 = *(NSObject **)(v5 + 40);
  BOOL v14 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v12 != TypeID)
  {
    if (!v14) {
      return;
    }
    if (*((char *)a2 + 23) >= 0) {
      char v19 = a2;
    }
    else {
      char v19 = (uint64_t *)*a2;
    }
    CFTypeRef v20 = *a3;
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v19;
    *(_WORD *)&_OWORD buf[12] = 2112;
    *(void *)&buf[14] = v20;
    xpc_object_t v11 = "#I   %s = %@";
    goto LABEL_20;
  }
  if (v14)
  {
    int v15 = *((char *)a2 + 23);
    uint64_t v16 = (uint64_t *)*a2;
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    if (v15 >= 0) {
      char v17 = a2;
    }
    else {
      char v17 = v16;
    }
    *(_OWORD *)long long __p = *(_OWORD *)buf;
    uint64_t v22 = *(void *)&buf[16];
    uint64_t v18 = __p;
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v18 = *(void ***)buf;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&_OWORD buf[12] = 2080;
    *(void *)&buf[14] = v18;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I   %s = %s", buf, 0x16u);
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_10067B930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10067B954(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 216))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFTypeID v6 = Mutable;
    uint64_t v16 = Mutable;
    CFMutableDictionaryRef v17 = Mutable;
    uint64_t v15 = a1;
    if (Mutable) {
      CFRetain(Mutable);
    }
    uint64_t v7 = (const void **)(a3 + 96);
    sub_10067BBF8(a1, v6, @"MCC", a3 + 96);
    CFNumberRef v8 = (const void **)(a3 + 120);
    sub_10067BBF8(v15, v16, @"MNC", a3 + 120);
    sub_10067BBF8(v15, v16, @"GID1", a3 + 144);
    sub_10067BBF8(v15, v16, @"GID2", a3 + 168);
    sub_10067BBF8(v15, v16, (const void *)qword_101B13EB8, a3 + 16);
    uint64_t v9 = (const void *)qword_101B13EC0;
    sub_1002055B4(v7, v8, buf);
    sub_10067BBF8(v15, v16, v9, (uint64_t)buf);
    if (v19 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received bootstrap profile, created dictionary: %@", buf, 0xCu);
    }
    sub_10004EFE4(&v13, (CFTypeRef *)&v17);
    sub_10004EFE4(&v12, (CFTypeRef *)&v17);
    sub_100677C10((uint64_t)v14, a1, &v13, &v12);
    sub_10000BDF8((uint64_t)v14);
    sub_100057D78(&v12);
    sub_100057D78(&v13);
    sub_10005717C((const void **)&v16);
    sub_10005717C((const void **)&v17);
  }
  else
  {
    xpc_object_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Bootstrap profile isn't set, not processing", buf, 2u);
    }
  }
}

void sub_10067BB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10067BBF8(uint64_t a1, __CFDictionary *a2, const void *a3, uint64_t a4)
{
  if (*(char *)(a4 + 23) < 0)
  {
    unint64_t v6 = *(void *)(a4 + 8);
    if (v6)
    {
      sub_10004FC84(v11, *(void **)a4, v6);
LABEL_6:
      if (SHIBYTE(v12) < 0)
      {
        sub_10004FC84(__p, v11[0], (unint64_t)v11[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)v11;
        uint64_t v16 = v12;
      }
      BOOL v14 = 0;
      if (SHIBYTE(v16) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        uint64_t v20 = v16;
      }
      CFMutableDictionaryRef v17 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v9 = v14;
        BOOL v14 = v17;
        uint64_t v18 = v9;
        sub_1000558F4(&v18);
      }
      if (SHIBYTE(v20) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v10 = v14;
      xpc_object_t v13 = v14;
      BOOL v14 = 0;
      sub_1000558F4(&v14);
      if (SHIBYTE(v16) < 0) {
        operator delete(__p[0]);
      }
      CFDictionarySetValue(a2, a3, v10);
      sub_1000558F4(&v13);
      if (SHIBYTE(v12) < 0)
      {
        CFNumberRef v8 = v11[0];
        goto LABEL_23;
      }
      return;
    }
  }
  else if (*(unsigned char *)(a4 + 23))
  {
    *(_OWORD *)xpc_object_t v11 = *(_OWORD *)a4;
    uint64_t v12 = *(void *)(a4 + 16);
    goto LABEL_6;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)&unsigned char buf[12] = 0;
    uint64_t v20 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0u;
    uint64_t v16 = 0;
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = __p;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Not adding %s as it is empty", buf, 0xCu);
    if (SHIBYTE(v16) < 0)
    {
      CFNumberRef v8 = __p[0];
LABEL_23:
      operator delete(v8);
    }
  }
}

void sub_10067BE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 41) < 0) {
    operator delete(*(void **)(v26 - 64));
  }
  _Unwind_Resume(exception_object);
}

void sub_10067BE88(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, void *a6@<X8>)
{
  int v9 = a5;
  int v10 = a2;
  v8[0] = &v10;
  v8[1] = a1;
  _OWORD v8[2] = &v9;
  void v8[3] = a3;
  void v8[4] = a4;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  xpc_object_t v11[2] = sub_100694328;
  void v11[3] = &unk_1019F7FD0;
  v11[4] = a1 + 8;
  v11[5] = v8;
  uint64_t v12 = v11;
  uint64_t v7 = a1 + 24;
  unint64_t v6 = *(NSObject **)(a1 + 24);
  if (*(void *)(v7 + 8))
  {
    *a6 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_100694464;
    uint64_t v16 = &unk_1019F8010;
    CFMutableDictionaryRef v17 = a6;
    uint64_t v18 = &v12;
    dispatch_async_and_wait(v6, &block);
  }
  else
  {
    *a6 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_1006943EC;
    uint64_t v16 = &unk_1019F7FF0;
    CFMutableDictionaryRef v17 = a6;
    uint64_t v18 = &v12;
    dispatch_sync(v6, &block);
  }
}

uint64_t sub_10067BFBC(const void **a1, uint64_t a2, int a3)
{
  *a1 = 0;
  uint64_t result = sub_1000608A8(a2 + 136, 1u, a3);
  if (a2 + 144 != result)
  {
    uint64_t v6 = result;
    uint64_t result = (uint64_t)sub_100058140(a1, (const void **)(result + 240));
    if (*(unsigned char *)(v6 + 160) == 1)
    {
      uint64_t v7 = (const void *)qword_101B13ED0;
      uint64_t result = CFDictionaryContainsKey((CFDictionaryRef)*a1, (const void *)qword_101B13ED0);
      if (result)
      {
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)*a1);
        CFDictionaryRemoveValue(MutableCopy, v7);
        sub_10004EFE4(&v8, (CFTypeRef *)&MutableCopy);
        if (&v8 != a1)
        {
          int v10 = *a1;
          *a1 = v8;
          CFNumberRef v8 = 0;
          sub_100057D78(&v10);
        }
        sub_100057D78(&v8);
        return (uint64_t)sub_10005717C((const void **)&MutableCopy);
      }
    }
  }
  return result;
}

void sub_10067C0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10005717C((const void **)va);
  sub_100057D78(v3);
  _Unwind_Resume(a1);
}

const void **sub_10067C0D4@<X0>(const void **a1@<X8>)
{
  *a1 = 0;
  DevicePersistentCopyValue((uint64_t *)&v4, kServerURLOverride, 0);
  sub_100056248(a1, &v4);
  uint64_t result = sub_1000577C4(&v4);
  if (*a1) {
    xpc_object_t v3 = sub_1000810B8;
  }
  else {
    xpc_object_t v3 = 0;
  }
  if (!v3)
  {
    xpc_object_t v4 = (const void *)kDefaultServerURL;
    return sub_100013168(a1, &v4);
  }
  return result;
}

void sub_10067C168(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

const void **sub_10067C18C(uint64_t a1, const void **a2)
{
  xpc_object_t v2 = *a2;
  xpc_object_t v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  DevicePersistentSaveValue();
  return sub_1000577C4(&v4);
}

void sub_10067C1E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10067C1F4(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 128))(&__p);
  copyURLForPath();
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_10067C260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10067C27C(int a1@<W1>, void *a2@<X8>)
{
}

void sub_10067C284(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_1000278EC((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_10067C3C8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10067C3E0(void *a1@<X8>)
{
}

void sub_10067C3EC(void *a1@<X8>)
{
}

void sub_10067C3F8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100694614;
  v7[3] = &unk_1019F8030;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  CFNumberRef v8 = v7;
  uint64_t v4 = a1 + 24;
  xpc_object_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    xpc_object_t v11 = sub_100694674;
    uint64_t v12 = &unk_1019F8070;
    xpc_object_t v13 = a3;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    xpc_object_t v11 = sub_100003E60;
    uint64_t v12 = &unk_1019F8050;
    xpc_object_t v13 = a3;
    uint64_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

uint64_t sub_10067C528(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4)
{
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t result = sub_1000608A8(a2 + 136, a3, a4);
  if (a2 + 144 != result)
  {
    uint64_t v7 = result;
    sub_10000BE9C(a1, result + 40);
    sub_100058198((const void **)(a1 + 200), (const void **)(v7 + 240));
    uint64_t result = (uint64_t)sub_100058198((const void **)(a1 + 208), (const void **)(v7 + 248));
    int v8 = *(_DWORD *)(v7 + 256);
    *(unsigned char *)(a1 + 224) = 1;
    *(_DWORD *)(a1 + 216) = v8;
  }
  return result;
}

void sub_10067C5CC(_Unwind_Exception *a1)
{
  sub_100687D34(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10067C5E0(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1006946D8;
  v7[3] = &unk_1019F8090;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  char v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    xpc_object_t v11 = sub_100694790;
    uint64_t v12 = &unk_1019F80D0;
    xpc_object_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    xpc_object_t v11 = sub_100694754;
    uint64_t v12 = &unk_1019F80B0;
    xpc_object_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_10067C718(uint64_t a1, int a2, void *a3)
{
  v6[4] = a1;
  uint64_t v5 = (void *)a3[3];
  if (v5)
  {
    if (v5 == a3)
    {
      int v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      int v8 = (void *)(*(uint64_t (**)(void *))(*v5 + 16))(v5);
    }
  }
  else
  {
    int v8 = 0;
  }
  int v9 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_10067C918(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10067C934(const void **a1, uint64_t a2, int a3)
{
  *a1 = 0;
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  sub_10067C528((uint64_t)&v10, a2, 1u, a3);
  if ((_BYTE)v24)
  {
    if (SBYTE7(v11) < 0)
    {
      sub_10004FC84(__p, (void *)v10, *((unint64_t *)&v10 + 1));
    }
    else
    {
      *(_OWORD *)long long __p = v10;
      uint64_t v8 = v11;
    }
    if (SHIBYTE(v8) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v27 = v8;
    }
    uint64_t v25 = 0;
    if (SHIBYTE(v27) < 0)
    {
      sub_10004FC84(&v28, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v28 = __dst;
      uint64_t v29 = v27;
    }
    xpc_object_t v30 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v4 = v25;
      uint64_t v25 = v30;
      uint64_t v31 = v4;
      sub_1000558F4(&v31);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete((void *)v28);
    }
    uint64_t v5 = v25;
    int v9 = v25;
    uint64_t v25 = 0;
    sub_1000558F4(&v25);
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)__dst);
    }
    if (&v9 != a1)
    {
      *(void *)&long long v28 = *a1;
      *a1 = v5;
      int v9 = 0;
      sub_1000558F4((const void **)&v28);
    }
    sub_1000558F4(&v9);
    if (SHIBYTE(v8) < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_100687D34((uint64_t)&v10);
}

void sub_10067CAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  sub_1000558F4((const void **)(v17 - 120));
  if (*(char *)(v17 - 89) < 0) {
    operator delete(*(void **)(v17 - 112));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100687D34((uint64_t)&a16);
  sub_1000558F4(v16);
  _Unwind_Resume(a1);
}

void sub_10067CB4C(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100128950((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_10067CC90(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10067CCA8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100694A38;
  void v7[3] = &unk_1019F80F0;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_100694AC4;
    long long v12 = &unk_1019F8130;
    long long v13 = a3;
    long long v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_100694A4C;
    long long v12 = &unk_1019F8110;
    long long v13 = a3;
    long long v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

const void **sub_10067CDD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1000608A8(a2 + 136, 1u, a3);
  if (a2 + 144 == v6)
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = asString();
      uint64_t v10 = *(void *)(a2 + 152);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      __int16 v14 = 2048;
      uint64_t v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Did not match bundle type %s, against %zu linked bundles", buf, 0x16u);
    }
    *(unsigned char *)a1 = 0;
    long long v12 = 0;
    *(void *)long long buf = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100057D78(&v12);
  }
  else
  {
    uint64_t v7 = v6;
    sub_10067BFBC((const void **)buf, a2, a3);
    *(unsigned char *)a1 = *(unsigned char *)(v7 + 160);
    *(void *)(a1 + 8) = *(void *)buf;
    *(void *)long long buf = 0;
    sub_100058198((const void **)(a1 + 16), (const void **)(v7 + 248));
  }
  return sub_100057D78((const void **)buf);
}

void sub_10067CF30(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100694B3C;
  void v7[3] = &unk_1019F8150;
  void v7[4] = a1 + 8;
  v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_100694C2C;
    long long v12 = &unk_1019F8190;
    long long v13 = a3;
    __int16 v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_100694B50;
    long long v12 = &unk_1019F8170;
    long long v13 = a3;
    __int16 v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_10067D060(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_10067D25C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10067D278(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  int v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v7 = (uint64_t **)(a1 + 136);
  __p[0] = (void *)((a2 << 32) | 1);
  *(void *)long long buf = __p;
  uint64_t v8 = sub_100688D4C((uint64_t **)(a1 + 136), (unsigned __int8 *)__p, (uint64_t)&unk_10144E20E, (void **)buf);
  if (v8[63] < 0)
  {
    if (*((void *)v8 + 6))
    {
LABEL_3:
      CFTypeRef cf1 = 0;
      *(void *)long long buf = CFPreferencesCopyValue(a3, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100225AE0(&cf1, (CFTypeRef *)buf);
      CFPropertyListRef value = 0;
      uint64_t v24 = (a2 << 32) | 1;
      *(void *)long long buf = &v24;
      uint64_t v9 = sub_100688D4C(v7, (unsigned __int8 *)&v24, (uint64_t)&unk_10144E20E, (void **)buf);
      if (v9[63] < 0)
      {
        sub_10004FC84(__dst, *((void **)v9 + 5), *((void *)v9 + 6));
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)(v9 + 40);
        uint64_t v26 = *((void *)v9 + 7);
      }
      if (SHIBYTE(v26) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)__dst;
        uint64_t v31 = v26;
      }
      uint64_t v29 = 0;
      if (SHIBYTE(v31) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        uint64_t v37 = v31;
      }
      xpc_object_t v32 = 0;
      if (ctu::cf::convert_copy())
      {
        long long v11 = v29;
        uint64_t v29 = v32;
        *(void *)xpc_object_t v33 = v11;
        sub_1000558F4((const void **)v33);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(*(void **)buf);
      }
      long long v12 = v29;
      CFPropertyListRef value = v29;
      uint64_t v29 = 0;
      sub_1000558F4(&v29);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
      if (cf1) {
        long long v13 = sub_1000810B8;
      }
      else {
        long long v13 = 0;
      }
      if (v13)
      {
        int v14 = CFEqual(cf1, v12);
        uint64_t v15 = *v6;
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v37 = 0;
        ctu::cf::assign();
        uint64_t v31 = v37;
        xpc_object_t v32 = (const void *)((a2 << 32) | 1);
        *(_OWORD *)long long __p = *(_OWORD *)buf;
        int v16 = SHIBYTE(v37);
        uint64_t v17 = *(void ***)buf;
        *(void *)long long buf = &v32;
        long long v18 = sub_100688D4C(v7, (unsigned __int8 *)&v32, (uint64_t)&unk_10144E20E, (void **)buf);
        long long v19 = v16 >= 0 ? __p : v17;
        long long v20 = v18 + 40;
        if (v18[63] < 0) {
          long long v20 = (void *)*v20;
        }
        *(_DWORD *)xpc_object_t v33 = 136315394;
        *(void *)&v33[4] = v19;
        __int16 v34 = 2080;
        BOOL v35 = v20;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle name in preference file '%s', current bundle name '%s'", v33, 0x16u);
        if (SHIBYTE(v31) < 0)
        {
          operator delete(__p[0]);
          if (v14) {
            goto LABEL_41;
          }
        }
        else
        {
LABEL_34:
          if (v14)
          {
LABEL_41:
            sub_1000558F4(&value);
            sub_1000558F4(&cf1);
            return;
          }
        }
      }
      else
      {
        long long v21 = *v6;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)xpc_object_t v33 = (a2 << 32) | 1;
          __p[0] = v33;
          long long v22 = sub_100688D4C(v7, v33, (uint64_t)&unk_10144E20E, (void **)__p);
          long long v23 = v22 + 40;
          if (v22[63] < 0) {
            long long v23 = (void *)*v23;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v23;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Bundle entry is not there in preferences file, restoring it with %s", buf, 0xCu);
        }
      }
      CFPreferencesSetValue(a3, value, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_1003F2A04();
      goto LABEL_41;
    }
  }
  else if (v8[63])
  {
    goto LABEL_3;
  }
  uint64_t v10 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I There is no carrier bundle present", buf, 2u);
  }
}

void sub_10067D6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, const void *a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

void sub_10067D784(uint64_t a1, int a2, int a3)
{
  if (*(unsigned __int8 *)(a1 + 408) != a3)
  {
    char v5 = a3;
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      uint64_t v8 = asString();
      __int16 v9 = 2080;
      uint64_t v10 = asString();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting update trigger from %s to %s", (uint8_t *)&v7, 0x16u);
    }
    *(unsigned char *)(a1 + 408) = v5;
  }
  sub_10067E2D0(a1, a2);
}

void sub_10067D874(uint64_t a1, int a2)
{
  if (a2 == 3)
  {
    double v5 = (double)(rand() % 24 + 1);
    double v3 = CFAbsoluteTimeGetCurrent() + v5 * 3600.0;
  }
  else
  {
    if (a2 != 2)
    {
      double v3 = 0.0;
      if (a2) {
        goto LABEL_10;
      }
      double Current = CFAbsoluteTimeGetCurrent();
      goto LABEL_9;
    }
    int v6 = rand() % 7;
    double v3 = CFAbsoluteTimeGetCurrent() + (double)(v6 + 8) * 86400.0;
  }
  if (!sub_10067DB44(a1)) {
    goto LABEL_10;
  }
  double Current = sub_1006C6950(v3);
LABEL_9:
  double v3 = Current;
LABEL_10:
  CFDateRef v7 = CFDateCreate(kCFAllocatorDefault, v3);
  uint64_t v8 = *(void *)(a1 + 416);
  *(void *)(a1 + 416) = v7;
  *(void *)long long v21 = v8;
  sub_10007CA64((const void **)v21);
  __int16 v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(a1 + 416);
    *(_DWORD *)long long v21 = 138543362;
    *(void *)&void v21[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Saving the next update check at %{public}@", v21, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  long long v12 = ServiceMap;
  if (v13 < 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long v21 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v21);
  if (!v17)
  {
    uint64_t v19 = 0;
LABEL_20:
    std::mutex::unlock(v12);
    long long v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  uint64_t v19 = v17[3];
  long long v18 = (std::__shared_weak_count *)v17[4];
  if (!v18) {
    goto LABEL_20;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
  if (v19) {
LABEL_21:
  }
    (*(void (**)(uint64_t, void, void, void, const CFStringRef, const CFStringRef))(*(void *)v19 + 16))(v19, kNextCarrierBundleUpdateCheck, *(void *)(a1 + 416), kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
LABEL_22:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_10067DB14(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10067DB44(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  double v3 = ServiceMap;
  if (v4 < 0)
  {
    double v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v17 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v17);
  if (v8)
  {
    uint64_t v10 = (GestaltUtilityInterface *)v8[3];
    __int16 v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  __int16 v9 = 0;
  char v11 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (isWatch) {
    return 0;
  }
  Registry::getMobileHelper((uint64_t *)&v17, *(Registry **)(a1 + 104));
  uint64_t v13 = (*(uint64_t (**)(void))(*(void *)v17 + 152))(v17);
  if (*((void *)&v17 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
  }
  int v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = "false";
    if (v13) {
      uint64_t v15 = "true";
    }
    LODWORD(v17) = 136315138;
    *(void *)((char *)&v17 + 4) = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Auto bundle update setting: %s", (uint8_t *)&v17, 0xCu);
  }
  return v13;
}

void sub_10067DD0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10067DD50(uint64_t a1)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 416));
  uint64_t v3 = (uint64_t)(AbsoluteTime - CFAbsoluteTimeGetCurrent());
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    *(void *)&uint8_t buf[4] = v3;
    *(void *)&buf[14] = v3 / 3600;
    *(_WORD *)&unsigned char buf[12] = 2048;
    __int16 v17 = 2048;
    uint64_t v18 = v3 / 86400;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Scheduling a carrier bundle update check in seconds: %lld, in hours: %ld, in days: %ld", buf, 0x20u);
  }
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 104));
  uint64_t v5 = *(void *)buf;
  sub_100058DB0(__p, "Carrier bundle update timer");
  uint64_t v6 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  void aBlock[2] = sub_10067E010;
  aBlock[3] = &unk_1019F6DA0;
  aBlock[4] = a1;
  char v11 = _Block_copy(aBlock);
  sub_100118A44(v5, (uint64_t)__p, 1, 1000000 * v3, &object, &v11);
  uint64_t v7 = v15;
  uint64_t v15 = 0;
  uint64_t v8 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v15;
    uint64_t v15 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  if (v11) {
    _Block_release(v11);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10067DFA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10067E010(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle update timer has fired", v4, 2u);
  }
  return sub_100679FCC(v1);
}

void sub_10067E07C(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL sub_10067E160(uint64_t a1, int a2, unsigned __int8 a3)
{
  uint64_t v4 = sub_1000608A8(a1 + 136, a3, a2);
  if (a1 + 144 == v4)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v9 = 136315394;
    uint64_t v10 = subscriber::asString();
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    uint64_t v8 = "Empty linked bundle info for slot %s and bundle type %s.";
LABEL_12:
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v9, 0x16u);
    return 0;
  }
  if (*(void *)(v4 + 240)) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5) {
    return 1;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v9 = 136315394;
    uint64_t v10 = subscriber::asString();
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    uint64_t v8 = "Empty matching info for slot %s and bundle type %s.";
    goto LABEL_12;
  }
  return result;
}

void sub_10067E2D0(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136315394;
    uint64_t v11 = asString();
    __int16 v12 = 2080;
    uint64_t v13 = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting carrier bundle update upon from %s to %s", (uint8_t *)&v10, 0x16u);
  }
  *(_DWORD *)(a1 + 412) = a2;
  switch(a2)
  {
    case 0:
      sub_10067D874(a1, 0);
      uint64_t v7 = *(void *)(a1 + 424);
      *(void *)(a1 + 424) = 0;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      sub_100679FCC(a1);
      return;
    case 1:
      goto LABEL_12;
    case 2:
      uint64_t v8 = a1;
      int v9 = 2;
      goto LABEL_11;
    case 3:
      uint64_t v8 = a1;
      int v9 = 3;
LABEL_11:
      sub_10067D874(v8, v9);
LABEL_12:
      sub_10067DD50(a1);
      break;
    case 4:
    case 5:
    case 6:
    case 7:
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = asString();
        int v10 = 136315138;
        uint64_t v11 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Not starting an update timer, bundle update will be checked as soon as %s happens", (uint8_t *)&v10, 0xCu);
      }
      break;
    default:
      return;
  }
}

const void **sub_10067E4A4(void *a1, uint64_t a2)
{
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (capabilities::ct::supportsVoiceCall(theDict)) {
    uint64_t v5 = (const void **)&kCFBooleanTrue;
  }
  else {
    uint64_t v5 = (const void **)&kCFBooleanFalse;
  }
  int v71 = 0;
  v93.__r_.__value_.__r.__words[0] = 0;
  __dst.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&__dst, (const __CFString **)"", (const char *)0x8000100, kCFAllocatorDefault, v4))
  {
    std::string::size_type v6 = v93.__r_.__value_.__r.__words[0];
    v93.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = v6;
    sub_1000558F4((const void **)&__p[0].__r_.__value_.__l.__data_);
  }
  int v71 = (const void *)v93.__r_.__value_.__r.__words[0];
  v93.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 104));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0].__r_.__value_.__r.__words[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  uint64_t v63 = a1;
  if (v13)
  {
    uint64_t v14 = v13[3];
    uint64_t v15 = (std::__shared_weak_count *)v13[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v16 = 1;
LABEL_14:
  if (v14)
  {
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v14 + 200))(&v70, v14);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v70.__r_.__value_.__l.__data_, v70.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v70;
    }
    v88.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      __p[0] = __dst;
    }
    v89.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v17 = v88.__r_.__value_.__r.__words[0];
      v88.__r_.__value_.__r.__words[0] = v89.__r_.__value_.__r.__words[0];
      v93.__r_.__value_.__r.__words[0] = v17;
      sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v18 = (const void *)v88.__r_.__value_.__r.__words[0];
    v88.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v88.__r_.__value_.__l.__data_);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v71;
    int v71 = v18;
    __src.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&__p[0].__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&__src.__r_.__value_.__l.__data_);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v70.__r_.__value_.__l.__data_);
    }
  }
  CFDictionarySetValue(theDict, @"SupportsVoiceCall", *v5);
  CFDictionarySetValue(theDict, @"DeviceName", v71);
  CFPropertyListRef value = 0;
  sub_10067FAAC(&value, a2);
  CFDictionarySetValue(theDict, @"kBundleUpdateCheckCriteria", value);
  if (*(void *)(a2 + 2080) != *(void *)(a2 + 2072))
  {
    CFArrayRef theArray = 0;
    int v91 = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      char v20 = v91;
      int v91 = Mutable;
      __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
      sub_1000440D4((const void **)&__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v21 = *(void *)(a2 + 2072);
    uint64_t v64 = *(void *)(a2 + 2080);
    if (v21 != v64)
    {
      long long v67 = (void *)qword_101B13EC0;
      long long v66 = (void *)qword_101B13EB8;
      while (1)
      {
        uint64_t v65 = v21;
        if (*(unsigned char *)(v21 + 80)) {
          break;
        }
LABEL_218:
        uint64_t v21 = v65 + 88;
        if (v65 + 88 == v64) {
          goto LABEL_219;
        }
      }
      uint64_t v23 = *(void *)(v21 + 56);
      uint64_t v22 = *(void *)(v21 + 64);
      while (1)
      {
        if (v23 == v22) {
          goto LABEL_218;
        }
        uint64_t v90 = 0;
        CFMutableDictionaryRef v24 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v24)
        {
          uint64_t v25 = v90;
          uint64_t v90 = v24;
          __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
          sub_10005717C((const void **)&__p[0].__r_.__value_.__l.__data_);
        }
        int v26 = *(unsigned __int8 *)(v23 + 88);
        if (*(unsigned char *)(v23 + 88)) {
          unsigned __int8 v27 = 3;
        }
        else {
          unsigned __int8 v27 = 1;
        }
        __dst.__r_.__value_.__r.__words[0] = 0;
        if (v26) {
          std::string::size_type v28 = 3;
        }
        else {
          std::string::size_type v28 = 1;
        }
        __p[0].__r_.__value_.__r.__words[0] = v28;
        CFNumberRef v29 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
        if (v29)
        {
          std::string::size_type v30 = __dst.__r_.__value_.__r.__words[0];
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
          __p[0].__r_.__value_.__r.__words[0] = v30;
          sub_1000570E8((const void **)&__p[0].__r_.__value_.__l.__data_);
        }
        v93.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
        __dst.__r_.__value_.__r.__words[0] = 0;
        sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
        sub_10069637C(v90, @"kUpdateBundleType", (uint64_t)v93.__r_.__value_.__l.__data_);
        sub_1000570E8((const void **)&v93.__r_.__value_.__l.__data_);
        uint64_t v31 = (void **)(v23 + 96);
        if (*(char *)(v23 + 119) < 0)
        {
          unint64_t v33 = *(void *)(v23 + 104);
          if (!v33)
          {
LABEL_54:
            __int16 v34 = *(NSObject **)(a2 + 40);
            if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_217;
            }
            LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
            BOOL v35 = v34;
            uint64_t v36 = "#I MCC not set in this profile, skipping";
LABEL_77:
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v36, (uint8_t *)__p, 2u);
            goto LABEL_217;
          }
          sub_10004FC84(&v89, *v31, v33);
        }
        else
        {
          if (!*(unsigned char *)(v23 + 119)) {
            goto LABEL_54;
          }
          long long v32 = *(_OWORD *)v31;
          v89.__r_.__value_.__r.__words[2] = *(void *)(v23 + 112);
          *(_OWORD *)&v89.__r_.__value_.__l.__data_ = v32;
        }
        if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v89.__r_.__value_.__l.__data_, v89.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v89;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v37 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v37;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, @"MCC", (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v89.__r_.__value_.__l.__data_);
        }
        int v38 = (void **)(v23 + 120);
        if (*(char *)(v23 + 143) < 0)
        {
          unint64_t v40 = *(void *)(v23 + 128);
          if (!v40)
          {
LABEL_75:
            int v41 = *(NSObject **)(a2 + 40);
            if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_217;
            }
            LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
            BOOL v35 = v41;
            uint64_t v36 = "#I MNC not set in this profile, skipping";
            goto LABEL_77;
          }
          sub_10004FC84(&v88, *v38, v40);
        }
        else
        {
          if (!*(unsigned char *)(v23 + 143)) {
            goto LABEL_75;
          }
          long long v39 = *(_OWORD *)v38;
          v88.__r_.__value_.__r.__words[2] = *(void *)(v23 + 136);
          *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v39;
        }
        if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v88.__r_.__value_.__l.__data_, v88.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v88;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v42 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v42;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, @"MNC", (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v88.__r_.__value_.__l.__data_);
        }
        sub_1002055B4((const void **)(v23 + 96), (const void **)(v23 + 120), &__src);
        if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __src;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v43 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v43;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, v67, (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__src.__r_.__value_.__l.__data_);
        }
        if (*(char *)(v23 + 167) < 0)
        {
          sub_10004FC84(&v86, *(void **)(v23 + 144), *(void *)(v23 + 152));
        }
        else
        {
          long long v44 = *(_OWORD *)(v23 + 144);
          v86.__r_.__value_.__r.__words[2] = *(void *)(v23 + 160);
          *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v44;
        }
        if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v86;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v45 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v45;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, @"GID1", (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v86.__r_.__value_.__l.__data_);
        }
        if (*(char *)(v23 + 191) < 0)
        {
          sub_10004FC84(&v85, *(void **)(v23 + 168), *(void *)(v23 + 176));
        }
        else
        {
          long long v46 = *(_OWORD *)(v23 + 168);
          v85.__r_.__value_.__r.__words[2] = *(void *)(v23 + 184);
          *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v46;
        }
        if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v85;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v47 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v47;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, @"GID2", (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v85.__r_.__value_.__l.__data_);
        }
        if (*(char *)(v23 + 39) < 0)
        {
          sub_10004FC84(&v84, *(void **)(v23 + 16), *(void *)(v23 + 24));
        }
        else
        {
          long long v48 = *(_OWORD *)(v23 + 16);
          v84.__r_.__value_.__r.__words[2] = *(void *)(v23 + 32);
          *(_OWORD *)&v84.__r_.__value_.__l.__data_ = v48;
        }
        if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v84.__r_.__value_.__l.__data_, v84.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v84;
        }
        char v95 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          __p[0] = __dst;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v49 = (std::string::size_type)v95;
          char v95 = (void *)__str.__r_.__value_.__r.__words[0];
          v93.__r_.__value_.__r.__words[0] = v49;
          sub_1000558F4((const void **)&v93.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        uint32_t v94 = v95;
        char v95 = 0;
        sub_1000558F4((const void **)&v95);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_10010F3F0(v90, v66, (uint64_t)v94);
        sub_1000558F4((const void **)&v94);
        if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v84.__r_.__value_.__l.__data_);
        }
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v79 = 0u;
        memset(__p, 0, sizeof(__p));
        sub_10004EFE4(&v77, (CFTypeRef *)&v90);
        CarrierBundleHandler::lookupBundle_sync(a2, v27, &v77, (uint64_t)__p);
        sub_100057D78(&v77);
        std::string::size_type size = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
        if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __p[0].__r_.__value_.__l.__size_;
        }
        if (size)
        {
          memset(&__str, 0, sizeof(__str));
          if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, __p[1].__r_.__value_.__l.__data_, __p[1].__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = __p[1];
          }
          std::string::size_type v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          int v52 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v51 = __str.__r_.__value_.__l.__size_;
          }
          if (v51 < 0xB)
          {
            CFMutableDictionaryRef v53 = *(NSObject **)(a2 + 40);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
              if (v52 >= 0) {
                p_str = &__str;
              }
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#N Invalid bundle identifer: %{public}s", (uint8_t *)&__dst, 0xCu);
            }
          }
          else
          {
            std::string::basic_string(&__dst, &__str, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v93);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            std::string __str = __dst;
          }
          uint64_t v55 = v90;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v74, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          }
          else {
            std::string v74 = __str;
          }
          if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v93, v74.__r_.__value_.__l.__data_, v74.__r_.__value_.__l.__size_);
          }
          else {
            std::string v93 = v74;
          }
          uint64_t v92 = 0;
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v93.__r_.__value_.__l.__data_, v93.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v93;
          }
          uint32_t v94 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v56 = v92;
            uint64_t v92 = v94;
            char v95 = v56;
            sub_1000558F4((const void **)&v95);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          uint64_t v75 = v92;
          uint64_t v92 = 0;
          sub_1000558F4((const void **)&v92);
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v93.__r_.__value_.__l.__data_);
          }
          CFDictionarySetValue(v55, @"BundleIDOnTheDevice", v75);
          sub_1000558F4((const void **)&v75);
          if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v74.__r_.__value_.__l.__data_);
          }
          uint64_t v57 = v90;
          if (SBYTE7(v83) < 0)
          {
            sub_10004FC84(&v73, (void *)v82, *((unint64_t *)&v82 + 1));
          }
          else
          {
            *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v82;
            v73.__r_.__value_.__r.__words[2] = v83;
          }
          if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v93, v73.__r_.__value_.__l.__data_, v73.__r_.__value_.__l.__size_);
          }
          else {
            std::string v93 = v73;
          }
          uint64_t v92 = 0;
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v93.__r_.__value_.__l.__data_, v93.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v93;
          }
          uint32_t v94 = 0;
          if (ctu::cf::convert_copy())
          {
            unsigned int v58 = v92;
            uint64_t v92 = v94;
            char v95 = v58;
            sub_1000558F4((const void **)&v95);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          uint64_t v75 = v92;
          uint64_t v92 = 0;
          sub_1000558F4((const void **)&v92);
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v93.__r_.__value_.__l.__data_);
          }
          CFDictionarySetValue(v57, @"BundleVersionOnTheDevice", v75);
          sub_1000558F4((const void **)&v75);
          if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v73.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
        }
        sub_100699750(v91, v90);
        if (SBYTE7(v83) < 0) {
          operator delete((void *)v82);
        }
        if (SHIBYTE(v81) < 0) {
          operator delete(*((void **)&v80 + 1));
        }
        if (SBYTE7(v80) < 0) {
          operator delete((void *)v79);
        }
        if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[1].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
LABEL_217:
        sub_10005717C((const void **)&v90);
        v23 += 216;
      }
    }
LABEL_219:
    sub_100044D6C(&theArray, (CFTypeRef *)&v91);
    sub_1000440D4((const void **)&v91);
    if (theArray) {
      int v59 = sub_100083F10;
    }
    else {
      int v59 = 0;
    }
    if (v59)
    {
      MutableCopy = CFArrayCreateMutableCopy(0, 0, theArray);
      __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)MutableCopy;
      CFArrayRef v61 = (const __CFArray *)value;
      v97.length = CFArrayGetCount((CFArrayRef)value);
      v97.locatiouint64_t n = 0;
      CFArrayAppendArray(MutableCopy, v61, v97);
      CFDictionarySetValue(theDict, @"kBundleUpdateCheckCriteria", __p[0].__r_.__value_.__l.__data_);
      sub_1000440D4((const void **)&__p[0].__r_.__value_.__l.__data_);
    }
    sub_100044D00((const void **)&theArray);
  }
  sub_10004EFE4(v63, (CFTypeRef *)&theDict);
  sub_100044D00((const void **)&value);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  sub_1000558F4(&v71);
  return sub_10005717C((const void **)&theDict);
}

void sub_10067F51C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,const void *a36,const void *a37)
{
  sub_1000558F4((const void **)(v39 - 256));
  if (*(char *)(v39 - 105) < 0) {
    operator delete(*(void **)(v39 - 128));
  }
  if (a35 < 0) {
    operator delete(__p);
  }
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  sub_1000558F4(&a36);
  sub_10005717C(&a37);
  _Unwind_Resume(a1);
}

uint64_t sub_10067F9E0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 408) == 5 || !sub_10067DB44(a1))
  {
    CFAllocatorRef v4 = *(NSObject **)(a1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v5)
    {
      *(_WORD *)std::string::size_type v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bundle updates will not be silent", v6, 2u);
      return 0;
    }
  }
  else
  {
    char v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bundle updates will be silent", buf, 2u);
    }
    return 1;
  }
  return result;
}

void sub_10067FAAC(void *a1, uint64_t a2)
{
  v17[0] = 0;
  v17[1] = 0;
  uint64_t v18 = 0;
  sub_100058DB0(v17, "com.apple.");
  char v16 = v17;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v15 = Mutable;
  long long v14 = 0u;
  *(_OWORD *)long long __p = 0u;
  uint64_t v11 = a2;
  CFMutableArrayRef v12 = Mutable;
  if (Mutable) {
    CFRetain(Mutable);
  }
  if (SHIBYTE(v18) < 0)
  {
    sub_10004FC84(__p, v17[0], (unint64_t)v17[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v17;
    *(void *)&long long v14 = v18;
  }
  *((void *)&v14 + 1) = &v16;
  subscriber::makeSimSlotRange();
  BOOL v5 = v8;
  if (v8 != v9)
  {
    while ((v10(*v5) & 1) == 0)
    {
      if (++v5 == v9)
      {
        BOOL v5 = v9;
        break;
      }
    }
LABEL_10:
    while (v5 != v9)
    {
      uint64_t v6 = *v5;
      sub_10067FCF4((uint64_t)&v11, 1, v6);
      sub_10067FCF4((uint64_t)&v11, 2, v6);
      sub_10067FCF4((uint64_t)&v11, 5, v6);
      sub_10067FCF4((uint64_t)&v11, 6, v6);
      uint64_t v7 = v5 + 1;
      BOOL v5 = v9;
      if (v7 != v9)
      {
        BOOL v5 = v7;
        while ((v10(*v5) & 1) == 0)
        {
          if (++v5 == v9)
          {
            BOOL v5 = v9;
            goto LABEL_10;
          }
        }
      }
    }
  }
  sub_10067FCF4((uint64_t)&v11, 3, 1);
  sub_10067FCF4((uint64_t)&v11, 4, 1);
  sub_100044D6C(a1, (CFTypeRef *)&v15);
  if (SBYTE7(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_1000440D4((const void **)&v12);
  sub_1000440D4((const void **)&v15);
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
}

void sub_10067FC9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1000440D4(v25);
  sub_1000440D4(&a18);
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10067FCF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a1;
  if (((a2 & 0xFB) - 1) > 1u) {
    uint64_t v7 = (os_log_t *)(v6 + 40);
  }
  else {
    uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), a3);
  }
  std::string::size_type v8 = a2;
  *(void *)&long long valuePtr = a2 | (unint64_t)(a3 << 32);
  *(void *)long long buf = &valuePtr;
  if (*((void *)sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&valuePtr, (uint64_t)&unk_10144E20E, (void **)buf)+ 30))std::string::size_type v9 = sub_100080778; {
  else
  }
    std::string::size_type v9 = 0;
  if (v9)
  {
    *(_OWORD *)uint64_t v135 = 0u;
    long long v136 = 0u;
    *(_OWORD *)CFTypeRef v133 = 0u;
    long long v134 = 0u;
    *(_OWORD *)uint64_t v132 = 0u;
    *(_OWORD *)long long buf = 0u;
    memset(__src, 0, sizeof(__src));
    LODWORD(__dst.__r_.__value_.__l.__data_) = a2;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = a3;
    *(void *)&long long valuePtr = &__dst;
    int v10 = sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)&valuePtr);
    sub_100058198(&v126, (const void **)v10 + 30);
    CarrierBundleHandler::lookupBundle_sync(v6, a2, &v126, (uint64_t)buf);
    sub_100057D78(&v126);
    CFTypeRef v125 = 0;
    LODWORD(__dst.__r_.__value_.__l.__data_) = a2;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = a3;
    *(void *)&long long valuePtr = &__dst;
    uint64_t v11 = sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)&valuePtr);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *((CFDictionaryRef *)v11 + 30));
    CFMutableDictionaryRef v13 = MutableCopy;
    CFTypeRef v125 = MutableCopy;
    uint64_t v14 = HIBYTE(__src[0]);
    if (SHIBYTE(__src[0]) < 0) {
      uint64_t v14 = *(void *)&buf[8];
    }
    if (v14)
    {
      CFMutableArrayRef v15 = (void *)HIBYTE(__src[3]);
      char v16 = HIBYTE(__src[3]);
      uint64_t v17 = **(void **)(a1 + 40);
      if (*(char *)(v17 + 23) < 0) {
        unint64_t v18 = *(void *)(v17 + 8);
      }
      else {
        unint64_t v18 = *(unsigned __int8 *)(v17 + 23);
      }
      if (SHIBYTE(__src[3]) < 0) {
        CFMutableArrayRef v15 = __src[2];
      }
      if ((unint64_t)v15 > v18)
      {
        if (BYTE8(v136) == 1)
        {
          CFDictionaryRemoveValue(MutableCopy, (const void *)qword_101B13ED0);
          char v16 = HIBYTE(__src[3]);
        }
        memset(&__str, 0, sizeof(__str));
        if (v16 < 0) {
          sub_10004FC84(&__str, __src[1], (unint64_t)__src[2]);
        }
        else {
          std::string __str = *(std::string *)&__src[1];
        }
        if (*(char *)(a1 + 39) < 0) {
          std::string::size_type v21 = *(void *)(a1 + 24);
        }
        else {
          std::string::size_type v21 = *(unsigned __int8 *)(a1 + 39);
        }
        std::string::basic_string((std::string *)&valuePtr, &__str, v21, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
        uint64_t v22 = v7;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        __str.__r_.__value_.__r.__words[2] = *(void *)&valuePtr_16[0];
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = valuePtr;
        uint64_t v23 = v125;
        if (SBYTE7(valuePtr_16[0]) < 0) {
          sub_10004FC84(&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = __str;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __p;
        }
        unint64_t v128 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else
        {
          long long valuePtr = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          *(void *)&valuePtr_16[0] = *((void *)&__dst.__r_.__value_.__l + 2);
        }
        unsigned int v129 = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v24 = (std::string::size_type)v128;
          unint64_t v128 = v129;
          v109.__r_.__value_.__r.__words[0] = v24;
          sub_1000558F4((const void **)&v109.__r_.__value_.__l.__data_);
        }
        if (SBYTE7(valuePtr_16[0]) < 0) {
          operator delete((void *)valuePtr);
        }
        CFPropertyListRef value = v128;
        unint64_t v128 = 0;
        sub_1000558F4((const void **)&v128);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v23, @"BundleIDOnTheDevice", value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v25 = v125;
        if (SBYTE7(v136) < 0)
        {
          sub_10004FC84(&v123, v135[0], (unint64_t)v135[1]);
        }
        else
        {
          *(_OWORD *)&v123.__r_.__value_.__l.__data_ = *(_OWORD *)v135;
          v123.__r_.__value_.__r.__words[2] = v136;
        }
        if (SHIBYTE(v123.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v123.__r_.__value_.__l.__data_, v123.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v123;
        }
        unint64_t v128 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else
        {
          long long valuePtr = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          *(void *)&valuePtr_16[0] = *((void *)&__dst.__r_.__value_.__l + 2);
        }
        unsigned int v129 = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v26 = (std::string::size_type)v128;
          unint64_t v128 = v129;
          v109.__r_.__value_.__r.__words[0] = v26;
          sub_1000558F4((const void **)&v109.__r_.__value_.__l.__data_);
        }
        if (SBYTE7(valuePtr_16[0]) < 0) {
          operator delete((void *)valuePtr);
        }
        CFPropertyListRef value = v128;
        unint64_t v128 = 0;
        sub_1000558F4((const void **)&v128);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v25, @"BundleVersionOnTheDevice", value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v123.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v123.__r_.__value_.__l.__data_);
        }
        unsigned __int8 v27 = v125;
        __dst.__r_.__value_.__r.__words[0] = 0;
        *(void *)&long long valuePtr = a2;
        CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
        if (v28)
        {
          std::string::size_type v29 = __dst.__r_.__value_.__r.__words[0];
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
          *(void *)&long long valuePtr = v29;
          sub_1000570E8((const void **)&valuePtr);
        }
        v109.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
        __dst.__r_.__value_.__r.__words[0] = 0;
        sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
        CFDictionarySetValue(v27, @"kUpdateBundleType", v109.__r_.__value_.__l.__data_);
        sub_1000570E8((const void **)&v109.__r_.__value_.__l.__data_);
        uint64_t v7 = v22;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        CFMutableDictionaryRef v13 = v125;
      }
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), v13);
    LODWORD(__dst.__r_.__value_.__l.__data_) = a2;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = a3;
    *(void *)&long long valuePtr = &__dst;
    std::string::size_type v30 = sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)&valuePtr);
    uint64_t v31 = v30;
    if (v30[63] < 0)
    {
      if (!*((void *)v30 + 6)) {
        goto LABEL_142;
      }
    }
    else if (!v30[63])
    {
      goto LABEL_142;
    }
    unint64_t v32 = v30[87];
    uint64_t v33 = **(void **)(a1 + 40);
    if (*(char *)(v33 + 23) < 0) {
      unint64_t v34 = *(void *)(v33 + 8);
    }
    else {
      unint64_t v34 = *(unsigned __int8 *)(v33 + 23);
    }
    if ((v32 & 0x80u) != 0) {
      unint64_t v32 = *((void *)v30 + 9);
    }
    if (v32 > v34)
    {
      CFPropertyListRef value = 0;
      CFPropertyListRef value = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      memset(&__str, 0, sizeof(__str));
      if (v31[87] < 0) {
        sub_10004FC84(&__str, *((void **)v31 + 8), *((void *)v31 + 9));
      }
      else {
        std::string __str = *(std::string *)(v31 + 64);
      }
      if (*(char *)(a1 + 39) < 0) {
        std::string::size_type v35 = *(void *)(a1 + 24);
      }
      else {
        std::string::size_type v35 = *(unsigned __int8 *)(a1 + 39);
      }
      std::string::basic_string((std::string *)&valuePtr, &__str, v35, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
      uint64_t v101 = v31;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      __str.__r_.__value_.__r.__words[2] = *(void *)&valuePtr_16[0];
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = valuePtr;
      uint64_t v36 = (__CFDictionary *)value;
      if (SBYTE7(valuePtr_16[0]) < 0) {
        sub_10004FC84(&v121, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else {
        std::string v121 = __str;
      }
      if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v121.__r_.__value_.__l.__data_, v121.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v121;
      }
      unint64_t v128 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else
      {
        long long valuePtr = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
        *(void *)&valuePtr_16[0] = *((void *)&__dst.__r_.__value_.__l + 2);
      }
      unsigned int v129 = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v37 = (std::string::size_type)v128;
        unint64_t v128 = v129;
        v109.__r_.__value_.__r.__words[0] = v37;
        sub_1000558F4((const void **)&v109.__r_.__value_.__l.__data_);
      }
      if (SBYTE7(valuePtr_16[0]) < 0) {
        operator delete((void *)valuePtr);
      }
      CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v128;
      unint64_t v128 = 0;
      sub_1000558F4((const void **)&v128);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(v36, @"BundleIDOnTheDevice", theDict);
      sub_1000558F4((const void **)&theDict);
      if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v121.__r_.__value_.__l.__data_);
      }
      int v38 = (__CFDictionary *)value;
      CFTypeRef v119 = (CFTypeRef)(a2 | (unint64_t)(a3 << 32));
      *(void *)&long long valuePtr = &v119;
      uint64_t v39 = sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&v119, (uint64_t)&unk_10144E20E, (void **)&valuePtr);
      if (v39[159] < 0) {
        sub_10004FC84(&v120, *((void **)v39 + 17), *((void *)v39 + 18));
      }
      else {
        std::string v120 = *(std::string *)(v39 + 136);
      }
      if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v120.__r_.__value_.__l.__data_, v120.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v120;
      }
      unint64_t v128 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else
      {
        long long valuePtr = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
        *(void *)&valuePtr_16[0] = *((void *)&__dst.__r_.__value_.__l + 2);
      }
      unsigned int v129 = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v40 = (std::string::size_type)v128;
        unint64_t v128 = v129;
        v109.__r_.__value_.__r.__words[0] = v40;
        sub_1000558F4((const void **)&v109.__r_.__value_.__l.__data_);
      }
      if (SBYTE7(valuePtr_16[0]) < 0) {
        operator delete((void *)valuePtr);
      }
      CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v128;
      unint64_t v128 = 0;
      sub_1000558F4((const void **)&v128);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(v38, @"BundleVersionOnTheDevice", theDict);
      sub_1000558F4((const void **)&theDict);
      if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v120.__r_.__value_.__l.__data_);
      }
      int v41 = (__CFDictionary *)value;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v118, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else {
        std::string v118 = __str;
      }
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v118.__r_.__value_.__l.__data_, v118.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v118;
      }
      unint64_t v128 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(&valuePtr, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else
      {
        long long valuePtr = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
        *(void *)&valuePtr_16[0] = *((void *)&__dst.__r_.__value_.__l + 2);
      }
      unsigned int v129 = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v42 = (std::string::size_type)v128;
        unint64_t v128 = v129;
        v109.__r_.__value_.__r.__words[0] = v42;
        sub_1000558F4((const void **)&v109.__r_.__value_.__l.__data_);
      }
      if (SBYTE7(valuePtr_16[0]) < 0) {
        operator delete((void *)valuePtr);
      }
      CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v128;
      unint64_t v128 = 0;
      sub_1000558F4((const void **)&v128);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(v41, @"kBundleNameToCheckForUpdate", theDict);
      sub_1000558F4((const void **)&theDict);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v118.__r_.__value_.__l.__data_);
      }
      std::string::size_type v43 = (__CFDictionary *)value;
      __dst.__r_.__value_.__r.__words[0] = 0;
      *(void *)&long long valuePtr = a2;
      CFNumberRef v44 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
      if (v44)
      {
        std::string::size_type v45 = __dst.__r_.__value_.__r.__words[0];
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
        *(void *)&long long valuePtr = v45;
        sub_1000570E8((const void **)&valuePtr);
      }
      v109.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = 0;
      sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
      CFDictionarySetValue(v43, @"kUpdateBundleType", v109.__r_.__value_.__l.__data_);
      sub_1000570E8((const void **)&v109.__r_.__value_.__l.__data_);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), value);
      uint64_t v31 = v101;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      sub_10005717C((const void **)&value);
    }
LABEL_142:
    if ((a2 - 1) > 1u) {
      goto LABEL_321;
    }
    if (a2 == 1) {
      char v46 = 5;
    }
    else {
      char v46 = 6;
    }
    unsigned __int8 v100 = v46;
    CFMutableDictionaryRef theDict = 0;
    LODWORD(__dst.__r_.__value_.__l.__data_) = a2;
    HIDWORD(__dst.__r_.__value_.__r.__words[0]) = a3;
    *(void *)&long long valuePtr = &__dst;
    std::string::size_type v47 = sub_100688D4C((uint64_t **)(v6 + 136), (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, (void **)&valuePtr);
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *((CFDictionaryRef *)v47 + 30));
    CFTypeRef v119 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v6 + 104));
    std::string::size_type v49 = ServiceMap;
    if (v50 < 0)
    {
      std::string::size_type v51 = (unsigned __int8 *)(v50 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v52 = 5381;
      do
      {
        uint64_t v50 = v52;
        unsigned int v53 = *v51++;
        uint64_t v52 = (33 * v52) ^ v53;
      }
      while (v53);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long valuePtr = v50;
    long long v54 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)&valuePtr);
    char v102 = v31;
    if (v54)
    {
      uint64_t v56 = v54[3];
      uint64_t v55 = (std::__shared_weak_count *)v54[4];
      if (v55)
      {
        atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v49);
        atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v55);
        char v57 = 0;
        goto LABEL_154;
      }
    }
    else
    {
      uint64_t v56 = 0;
    }
    std::mutex::unlock(v49);
    uint64_t v55 = 0;
    char v57 = 1;
LABEL_154:
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v56 + 80))(&__dst, v56, a3, a2, @"HomeBundleIdentifier", 0, 0);
    sub_100056248(&v119, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
    uint64_t v58 = v6;
    sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
    if ((v57 & 1) == 0) {
      sub_10004D2C8(v55);
    }
    CFTypeRef v59 = v119;
    if (v119) {
      int v60 = sub_1000810B8;
    }
    else {
      int v60 = 0;
    }
    if (v60)
    {
      CFArrayRef v61 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        long long valuePtr = 0uLL;
        *(void *)&valuePtr_16[0] = 0;
        ctu::cf::assign();
        __dst.__r_.__value_.__r.__words[2] = *(void *)&valuePtr_16[0];
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = valuePtr;
        int v62 = SBYTE7(valuePtr_16[0]);
        uint64_t v63 = (std::string *)valuePtr;
        uint64_t v64 = asString();
        p_dst = &__dst;
        if (v62 < 0) {
          p_dst = v63;
        }
        LODWORD(__str.__r_.__value_.__l.__data_) = 136446466;
        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_dst;
        WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = v64;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Adding Home bundle Identifier: %{public}s from %s bundle to update check criteria.", (uint8_t *)&__str, 0x16u);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        CFTypeRef v59 = v119;
      }
      CFDictionarySetValue(theDict, @"HomeBundleIdentifier", v59);
    }
    *(_OWORD *)int v116 = 0u;
    long long v117 = 0u;
    *(_OWORD *)int v114 = 0u;
    long long v115 = 0u;
    *(_OWORD *)long long v113 = 0u;
    long long valuePtr = 0u;
    memset(valuePtr_16, 0, sizeof(valuePtr_16));
    sub_10004EFE4(&v110, (CFTypeRef *)&theDict);
    CarrierBundleHandler::lookupBundle_sync(v58, v100, &v110, (uint64_t)&valuePtr);
    sub_100057D78(&v110);
    uint64_t v66 = BYTE7(valuePtr_16[0]);
    if (SBYTE7(valuePtr_16[0]) < 0) {
      uint64_t v66 = *((void *)&valuePtr + 1);
    }
    if (v66)
    {
      unint64_t v67 = HIBYTE(valuePtr_16[1]);
      char v68 = HIBYTE(valuePtr_16[1]);
      if (valuePtr_16[1] < 0) {
        unint64_t v67 = *(void *)&valuePtr_16[1];
      }
      if (v67 >= 0xB)
      {
        if (BYTE8(v117) == 1)
        {
          CFDictionaryRemoveValue(theDict, (const void *)qword_101B13ED0);
          char v68 = HIBYTE(valuePtr_16[1]);
        }
        memset(&v109, 0, sizeof(v109));
        if (v68 < 0) {
          sub_10004FC84(&v109, *((void **)&valuePtr_16[0] + 1), *(unint64_t *)&valuePtr_16[1]);
        }
        else {
          std::string v109 = *(std::string *)((char *)valuePtr_16 + 8);
        }
        std::string::basic_string(&__dst, &v109, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__str);
        if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v109.__r_.__value_.__l.__data_);
        }
        std::string v109 = __dst;
        int v69 = theDict;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v107, v109.__r_.__value_.__l.__data_, v109.__r_.__value_.__l.__size_);
        }
        else {
          std::string v107 = v109;
        }
        if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__str, v107.__r_.__value_.__l.__data_, v107.__r_.__value_.__l.__size_);
        }
        else {
          std::string __str = v107;
        }
        CFPropertyListRef value = 0;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __str;
        }
        unint64_t v128 = 0;
        if (ctu::cf::convert_copy())
        {
          std::string v70 = value;
          CFPropertyListRef value = v128;
          unsigned int v129 = v70;
          sub_1000558F4((const void **)&v129);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        xpc_object_t v108 = value;
        CFPropertyListRef value = 0;
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v69, @"BundleIDOnTheDevice", v108);
        sub_1000558F4((const void **)&v108);
        if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v107.__r_.__value_.__l.__data_);
        }
        int v71 = theDict;
        if (SBYTE7(v117) < 0)
        {
          sub_10004FC84(&v106, v116[0], (unint64_t)v116[1]);
        }
        else
        {
          *(_OWORD *)&v106.__r_.__value_.__l.__data_ = *(_OWORD *)v116;
          v106.__r_.__value_.__r.__words[2] = v117;
        }
        if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__str, v106.__r_.__value_.__l.__data_, v106.__r_.__value_.__l.__size_);
        }
        else {
          std::string __str = v106;
        }
        CFPropertyListRef value = 0;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = __str;
        }
        unint64_t v128 = 0;
        if (ctu::cf::convert_copy())
        {
          long long v72 = value;
          CFPropertyListRef value = v128;
          unsigned int v129 = v72;
          sub_1000558F4((const void **)&v129);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        xpc_object_t v108 = value;
        CFPropertyListRef value = 0;
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v71, @"BundleVersionOnTheDevice", v108);
        sub_1000558F4((const void **)&v108);
        if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v106.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v109.__r_.__value_.__l.__data_);
        }
      }
    }
    std::string v73 = theDict;
    __str.__r_.__value_.__r.__words[0] = 0;
    __dst.__r_.__value_.__r.__words[0] = v100;
    CFNumberRef v74 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &__dst);
    if (v74)
    {
      std::string::size_type v75 = __str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
      __dst.__r_.__value_.__r.__words[0] = v75;
      sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
    }
    v109.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
    __str.__r_.__value_.__r.__words[0] = 0;
    sub_1000570E8((const void **)&__str.__r_.__value_.__l.__data_);
    CFDictionarySetValue(v73, @"kUpdateBundleType", v109.__r_.__value_.__l.__data_);
    sub_1000570E8((const void **)&v109.__r_.__value_.__l.__data_);
    long long v76 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__dst.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)theDict;
      _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Adding criteria for country bundle: %@", (uint8_t *)&__dst, 0xCu);
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), theDict);
    if (SBYTE7(v117) < 0) {
      operator delete(v116[0]);
    }
    if (SHIBYTE(v115) < 0) {
      operator delete(v114[1]);
    }
    if (SHIBYTE(v114[0]) < 0) {
      operator delete(v113[0]);
    }
    if (SHIBYTE(valuePtr_16[1]) < 0) {
      operator delete(*((void **)&valuePtr_16[0] + 1));
    }
    if (SBYTE7(valuePtr_16[0]) < 0) {
      operator delete((void *)valuePtr);
    }
    sub_1000558F4(&v119);
    sub_10005717C((const void **)&theDict);
    if (a2 != 1) {
      goto LABEL_321;
    }
    sub_1000292E0((uint64_t)&valuePtr);
    uint64_t v77 = v102[63];
    if ((v77 & 0x80u) == 0) {
      uint64_t v78 = v102[63];
    }
    else {
      uint64_t v78 = *((void *)v102 + 6);
    }
    uint64_t v79 = BYTE7(valuePtr_16[0]);
    int v80 = SBYTE7(valuePtr_16[0]);
    if (SBYTE7(valuePtr_16[0]) < 0) {
      uint64_t v79 = *((void *)&valuePtr + 1);
    }
    if (v78 != v79)
    {
      BOOL v90 = 0;
      if ((SBYTE7(valuePtr_16[0]) & 0x80000000) == 0) {
        goto LABEL_254;
      }
      goto LABEL_250;
    }
    long long v81 = (const void **)(v102 + 40);
    if ((SBYTE7(valuePtr_16[0]) & 0x80u) == 0) {
      p_long long valuePtr = (unsigned __int8 *)&valuePtr;
    }
    else {
      p_long long valuePtr = (unsigned __int8 *)valuePtr;
    }
    if ((v77 & 0x80) != 0)
    {
      BOOL v90 = memcmp(*v81, p_valuePtr, *((void *)v102 + 6)) == 0;
    }
    else
    {
      if (!v102[63])
      {
        BOOL v90 = 1;
        if ((SBYTE7(valuePtr_16[0]) & 0x80000000) == 0)
        {
LABEL_254:
          if (v90)
          {
LABEL_255:
            int v91 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(valuePtr) = 0;
              _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "#I Unknown bundle is present, add other known bundle match criteria.", (uint8_t *)&valuePtr, 2u);
            }
            CFMutableDictionaryRef theDict = 0;
            CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              CFMutableDictionaryRef v93 = theDict;
              CFMutableDictionaryRef theDict = Mutable;
              *(void *)&long long valuePtr = v93;
              sub_10005717C((const void **)&valuePtr);
            }
            sub_10010F3F0(theDict, (void *)qword_101B13EC0, @"OtherKnown.bundle");
            *(_OWORD *)int v116 = 0u;
            long long v117 = 0u;
            *(_OWORD *)int v114 = 0u;
            long long v115 = 0u;
            *(_OWORD *)long long v113 = 0u;
            long long valuePtr = 0u;
            memset(valuePtr_16, 0, sizeof(valuePtr_16));
            sub_10004EFE4(&v105, (CFTypeRef *)&theDict);
            CarrierBundleHandler::lookupBundle_sync(v58, 1u, &v105, (uint64_t)&valuePtr);
            sub_100057D78(&v105);
            uint64_t v94 = BYTE7(valuePtr_16[0]);
            if (SBYTE7(valuePtr_16[0]) < 0) {
              uint64_t v94 = *((void *)&valuePtr + 1);
            }
            if (v94)
            {
              unint64_t v95 = HIBYTE(valuePtr_16[1]);
              if (valuePtr_16[1] < 0) {
                unint64_t v95 = *(void *)&valuePtr_16[1];
              }
              if (v95 >= 0xB)
              {
                memset(&v109, 0, sizeof(v109));
                if (SHIBYTE(valuePtr_16[1]) < 0) {
                  sub_10004FC84(&v109, *((void **)&valuePtr_16[0] + 1), *(unint64_t *)&valuePtr_16[1]);
                }
                else {
                  std::string v109 = *(std::string *)((char *)valuePtr_16 + 8);
                }
                std::string::basic_string(&__dst, &v109, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__str);
                if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v109.__r_.__value_.__l.__data_);
                }
                std::string v109 = __dst;
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&v104, v109.__r_.__value_.__l.__data_, v109.__r_.__value_.__l.__size_);
                }
                else {
                  std::string v104 = v109;
                }
                if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&__str, v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_);
                }
                else {
                  std::string __str = v104;
                }
                CFPropertyListRef value = 0;
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                }
                else {
                  std::string __dst = __str;
                }
                unint64_t v128 = 0;
                if (ctu::cf::convert_copy())
                {
                  long long v96 = value;
                  CFPropertyListRef value = v128;
                  unsigned int v129 = v96;
                  sub_1000558F4((const void **)&v129);
                }
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
                CFTypeRef v119 = value;
                CFPropertyListRef value = 0;
                sub_1000558F4((const void **)&value);
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
                sub_10010F3F0(theDict, @"BundleIDOnTheDevice", (uint64_t)v119);
                sub_1000558F4(&v119);
                if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v104.__r_.__value_.__l.__data_);
                }
                if (SBYTE7(v117) < 0)
                {
                  sub_10004FC84(&v103, v116[0], (unint64_t)v116[1]);
                }
                else
                {
                  *(_OWORD *)&v103.__r_.__value_.__l.__data_ = *(_OWORD *)v116;
                  v103.__r_.__value_.__r.__words[2] = v117;
                }
                if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&__str, v103.__r_.__value_.__l.__data_, v103.__r_.__value_.__l.__size_);
                }
                else {
                  std::string __str = v103;
                }
                CFPropertyListRef value = 0;
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                }
                else {
                  std::string __dst = __str;
                }
                unint64_t v128 = 0;
                if (ctu::cf::convert_copy())
                {
                  CFRange v97 = value;
                  CFPropertyListRef value = v128;
                  unsigned int v129 = v97;
                  sub_1000558F4((const void **)&v129);
                }
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
                CFTypeRef v119 = value;
                CFPropertyListRef value = 0;
                sub_1000558F4((const void **)&value);
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
                sub_10010F3F0(theDict, @"BundleVersionOnTheDevice", (uint64_t)v119);
                sub_1000558F4(&v119);
                if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v103.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v109.__r_.__value_.__l.__data_);
                }
              }
            }
            __str.__r_.__value_.__r.__words[0] = 0;
            __dst.__r_.__value_.__r.__words[0] = v8;
            CFNumberRef v98 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &__dst);
            if (v98)
            {
              std::string::size_type v99 = __str.__r_.__value_.__r.__words[0];
              __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v98;
              __dst.__r_.__value_.__r.__words[0] = v99;
              sub_1000570E8((const void **)&__dst.__r_.__value_.__l.__data_);
            }
            v109.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
            __str.__r_.__value_.__r.__words[0] = 0;
            sub_1000570E8((const void **)&__str.__r_.__value_.__l.__data_);
            sub_10069637C(theDict, @"kUpdateBundleType", (uint64_t)v109.__r_.__value_.__l.__data_);
            sub_1000570E8((const void **)&v109.__r_.__value_.__l.__data_);
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), theDict);
            if (SBYTE7(v117) < 0) {
              operator delete(v116[0]);
            }
            if (SHIBYTE(v115) < 0) {
              operator delete(v114[1]);
            }
            if (SHIBYTE(v114[0]) < 0) {
              operator delete(v113[0]);
            }
            if (SHIBYTE(valuePtr_16[1]) < 0) {
              operator delete(*((void **)&valuePtr_16[0] + 1));
            }
            if (SBYTE7(valuePtr_16[0]) < 0) {
              operator delete((void *)valuePtr);
            }
            sub_10005717C((const void **)&theDict);
          }
LABEL_321:
          sub_10005717C((const void **)&v125);
          if (SBYTE7(v136) < 0) {
            operator delete(v135[0]);
          }
          if (SHIBYTE(v134) < 0) {
            operator delete(v133[1]);
          }
          if (SHIBYTE(v133[0]) < 0) {
            operator delete(v132[0]);
          }
          if (SHIBYTE(__src[3]) < 0) {
            operator delete(__src[1]);
          }
          if (SHIBYTE(__src[0]) < 0) {
            operator delete(*(void **)buf);
          }
          return;
        }
LABEL_250:
        operator delete((void *)valuePtr);
        if (v90) {
          goto LABEL_255;
        }
        goto LABEL_321;
      }
      uint64_t v83 = v77 - 1;
      do
      {
        int v85 = *(unsigned __int8 *)v81;
        long long v81 = (const void **)((char *)v81 + 1);
        int v84 = v85;
        int v87 = *p_valuePtr++;
        int v86 = v87;
        BOOL v89 = v83-- != 0;
        BOOL v90 = v84 == v86;
      }
      while (v84 == v86 && v89);
    }
    if ((v80 & 0x80000000) == 0) {
      goto LABEL_254;
    }
    goto LABEL_250;
  }
  uint64_t v19 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I No matching info for %s", buf, 0xCu);
  }
}

void sub_10068143C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1000558F4(&a73);
  if (*(char *)(v73 - 137) < 0) {
    operator delete(*(void **)(v73 - 160));
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  sub_10039A890((uint64_t)&a39);
  sub_10005717C(&a66);
  sub_10005717C(&a72);
  sub_10039A890((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_1006819A4()
{
}

void sub_1006819AC()
{
}

uint64_t sub_1006819B4(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  sub_1000440D4((const void **)(a1 + 8));
  return a1;
}

void sub_1006819F0(uint64_t a1, uint64_t *a2)
{
  std::string::size_type v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = &v24;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      uint64_t v6 = v24;
      uint64_t v7 = &v24;
      std::string::size_type v8 = &v24;
      if (v24)
      {
        unsigned int v9 = *(unsigned __int8 *)(v4 + 8);
        while (1)
        {
          while (1)
          {
            std::string::size_type v8 = (uint64_t **)v6;
            unsigned int v10 = *((unsigned __int8 *)v6 + 25);
            if (v10 <= v9) {
              break;
            }
            uint64_t v6 = *v8;
            uint64_t v7 = v8;
            if (!*v8) {
              goto LABEL_10;
            }
          }
          if (v10 >= v9) {
            break;
          }
          uint64_t v6 = v8[1];
          if (!v6)
          {
            uint64_t v7 = v8 + 1;
            goto LABEL_10;
          }
        }
        uint64_t v11 = v8;
      }
      else
      {
LABEL_10:
        uint64_t v11 = operator new(0x20uLL);
        v11[25] = *(unsigned char *)(v4 + 8);
        v11[26] = 0;
        *(void *)uint64_t v11 = 0;
        *((void *)v11 + 1) = 0;
        *((void *)v11 + 2) = v8;
        *uint64_t v7 = (uint64_t *)v11;
        CFMutableArrayRef v12 = (uint64_t *)v11;
        if (*v23)
        {
          uint64_t v23 = (uint64_t **)*v23;
          CFMutableArrayRef v12 = *v7;
        }
        sub_100046C90(v24, v12);
        ++v25;
      }
      v11[26] = 1;
      v4 += 16;
    }
    while (v4 != v5);
  }
  int v13 = *(unsigned __int8 *)(a1 + 408);
  buf[0] = 4;
  if (*((unsigned char *)sub_100696420((uint64_t **)&v23, 4u, buf) + 26))
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I New update has been installed", buf, 2u);
    }
    sub_100678B30(a1);
    int v13 = 2;
  }
  buf[0] = 1;
  if (*((unsigned char *)sub_100696420((uint64_t **)&v23, 1u, buf) + 26))
  {
    CFMutableArrayRef v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Could not reach the server, will try after internet becomes available", buf, 2u);
    }
    int v16 = 5;
  }
  else
  {
    int v16 = 2;
  }
  buf[0] = 2;
  if (*((unsigned char *)sub_100696420((uint64_t **)&v23, 2u, buf) + 26)
    || (unsigned __int8 v21 = 7, *((unsigned char *)sub_100696420((uint64_t **)&v23, 7u, &v21) + 26))
    || (unsigned __int8 v20 = 6, *((unsigned char *)sub_100696420((uint64_t **)&v23, 6u, &v20) + 26))
    || (unsigned __int8 v19 = 5, *((unsigned char *)sub_100696420((uint64_t **)&v23, 5u, &v19) + 26)))
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Could not check for update, will try shortly", buf, 2u);
    }
    int v13 = 1;
    int v16 = 3;
  }
  if (*a2 == a2[1])
  {
    unint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I No result from update check, will try shortly", buf, 2u);
    }
    int v13 = 1;
    int v16 = 3;
  }
  sub_10067D784(a1, v16, v13);
  CarrierBundleHandler::submitBundleScheduleMetric_sync((CarrierBundleHandler *)a1);
  sub_10005D144(v24);
}

void sub_100681D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void sub_100681D40(uint64_t a1@<X0>, char a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  char v6 = a2;
  int v7 = a3;
  uint64_t v8 = a1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  xpc_object_t v9[2] = sub_1006964D0;
  v9[3] = &unk_1019F82F0;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  unsigned int v10 = v9;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    int v13 = sub_100694674;
    uint64_t v14 = &unk_1019F8070;
    CFMutableArrayRef v15 = a4;
    int v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    int v13 = sub_100003E60;
    uint64_t v14 = &unk_1019F8050;
    CFMutableArrayRef v15 = a4;
    int v16 = &v10;
    dispatch_sync(v4, &block);
  }
}

void sub_100681E6C(uint64_t a1@<X0>, char a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  char v6 = a2;
  int v7 = a3;
  uint64_t v8 = a1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  xpc_object_t v9[2] = sub_1006965FC;
  v9[3] = &unk_1019F8330;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  unsigned int v10 = v9;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    int v13 = sub_100694674;
    uint64_t v14 = &unk_1019F8070;
    CFMutableArrayRef v15 = a4;
    int v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    int v13 = sub_100003E60;
    uint64_t v14 = &unk_1019F8050;
    CFMutableArrayRef v15 = a4;
    int v16 = &v10;
    dispatch_sync(v4, &block);
  }
}

uint64_t sub_100681F98(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 208));
  sub_100057D78((const void **)(a1 + 200));

  return sub_10000BDF8(a1);
}

uint64_t sub_100681FDC(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4)
{
  uint64_t result = sub_1000608A8(a2 + 136, a3, a4);
  if (a2 + 144 == result)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    uint64_t v7 = result;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    memset(v8, 0, sizeof(v8));
    sub_10000BE9C((uint64_t)v8, result + 40);
    sub_100058198((const void **)&v15 + 1, (const void **)(v7 + 240));
    sub_100058198((const void **)&v16, (const void **)(v7 + 248));
    DWORD2(v16) = *(_DWORD *)(v7 + 256);
    if (SBYTE7(v10) < 0)
    {
      sub_10004FC84((unsigned char *)a1, (void *)v9, *((unint64_t *)&v9 + 1));
    }
    else
    {
      *(_OWORD *)a1 = v9;
      *(void *)(a1 + 16) = v10;
    }
    sub_100057D78((const void **)&v16);
    sub_100057D78((const void **)&v15 + 1);
    return sub_10000BDF8((uint64_t)v8);
  }
  return result;
}

void sub_1006820E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1006820F4(uint64_t a1@<X0>, char a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  char v6 = a2;
  int v7 = a3;
  uint64_t v8 = a1;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  xpc_object_t v9[2] = sub_100696614;
  v9[3] = &unk_1019F8350;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  long long v10 = v9;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    long long v13 = sub_100694464;
    long long v14 = &unk_1019F8010;
    long long v15 = a4;
    long long v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    long long v13 = sub_1006943EC;
    long long v14 = &unk_1019F7FF0;
    long long v15 = a4;
    long long v16 = &v10;
    dispatch_sync(v4, &block);
  }
}

uint64_t sub_100682218(uint64_t a1)
{
  if (capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
    return *(unsigned int *)(a1 + 2232);
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Overriding user data slot %s to kOne", (uint8_t *)&v4, 0xCu);
  }
  return 1;
}

void sub_1006822D0(uint64_t a1, const void **a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100119B5C(&v6, a2);
  sub_1000DFC90((uint64_t)&v7, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100682420(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10068244C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_100682488(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_100682580(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL sub_10068265C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100697C38;
  v5[3] = &unk_1019F83F0;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  char v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    long long v9 = sub_10005AE4C;
    long long v10 = &unk_1019F8430;
    long long v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    long long v9 = sub_10005A0E8;
    long long v10 = &unk_1019F8410;
    long long v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_10068278C(uint64_t a1, const void **a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100058198(&v6, a2);
  sub_100128950((uint64_t)&v7, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1006828DC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100682908(const void **a1, uint64_t a2, const void **a3)
{
  *a1 = 0;
  v22[0] = 0;
  v22[1] = 0;
  uint64_t v23 = 0;
  sub_100058198(&v21, a3);
  sub_100682C2C(buf, a2, 1u, &v21);
  *(_OWORD *)uint64_t v22 = v34;
  uint64_t v23 = v35;
  uint64_t v35 = 0;
  long long v34 = 0uLL;
  if (v33 < 0) {
    operator delete(__p);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(*(void **)buf);
  }
  sub_100057D78(&v21);
  int v5 = SHIBYTE(v23);
  if (v23 >= 0) {
    char v6 = (void *)HIBYTE(v23);
  }
  else {
    char v6 = v22[1];
  }
  uint64_t v7 = *(NSObject **)(a2 + 40);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      long long v9 = (void **)v22[0];
      if (v5 >= 0) {
        long long v9 = v22;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I matchedbundle carrier file path: %{public}s", buf, 0xCu);
    }
    *(void *)long long buf = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a2 + 88) + 152))(buf);
    if (*(void *)buf) {
      long long v10 = sub_100080778;
    }
    else {
      long long v10 = 0;
    }
    if (v10)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)buf, @"RemoteCardProvisioningSettings");
      uint64_t v12 = Value;
      if (Value && (CFTypeID v13 = CFGetTypeID(Value), v13 == CFDictionaryGetTypeID()))
      {
        unsigned __int8 v20 = v12;
        CFRetain(v12);
      }
      else
      {
        uint64_t v12 = 0;
        unsigned __int8 v20 = 0;
      }
      if (v12) {
        long long v14 = sub_100080778;
      }
      else {
        long long v14 = 0;
      }
      if (v14)
      {
        long long v15 = CFDictionaryGetValue((CFDictionaryRef)v12, @"ServerURL");
        long long v16 = v15;
        if (v15)
        {
          CFTypeID v17 = CFGetTypeID(v15);
          if (v17 == CFStringGetTypeID()) {
            unint64_t v18 = v16;
          }
          else {
            unint64_t v18 = 0;
          }
        }
        else
        {
          unint64_t v18 = 0;
        }
        CFTypeRef v19 = v18;
        sub_100013168(a1, &v19);
      }
      sub_100057D78(&v20);
    }
    sub_100057D78((const void **)buf);
  }
  else if (v8)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N No matching bundle for match criteria found.", buf, 2u);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
}

void sub_100682BC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100682C2C(char *a1, uint64_t a2, unsigned int a3, const void **a4)
{
  long long v49 = 0uLL;
  uint64_t v50 = 0;
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)CFPropertyListRef value = 0u;
  *(_OWORD *)std::string::size_type v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  *(_OWORD *)CFNumberRef v44 = 0u;
  *(_OWORD *)int v41 = 0u;
  *(_OWORD *)std::string::size_type v42 = 0u;
  sub_100058198(&v40, a4);
  sub_100027ECC((uint64_t)v41, a2, a3, &v40);
  sub_100057D78(&v40);
  BOOL v8 = (void *)HIBYTE(v42[0]);
  if (SHIBYTE(v42[0]) < 0) {
    BOOL v8 = v41[1];
  }
  if (v8)
  {
    if (SHIBYTE(v45[0]) >= 0) {
      size_t v9 = HIBYTE(v45[0]);
    }
    else {
      size_t v9 = (size_t)v44[1];
    }
    uint64_t v52 = 0;
    memset(buf, 0, sizeof(buf));
    long long v10 = buf;
    sub_1000C140C((uint64_t)buf, v9 + 14);
    if (v52 < 0) {
      long long v10 = *(uint8_t **)buf;
    }
    if (v9)
    {
      if (SHIBYTE(v45[0]) >= 0) {
        long long v11 = v44;
      }
      else {
        long long v11 = (void **)v44[0];
      }
      memmove(v10, v11, v9);
    }
    strcpy((char *)&v10[v9], "/carrier.plist");
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)v49);
    }
    long long v49 = *(_OWORD *)buf;
    uint64_t v50 = v52;
    xpc_object_t v39 = 0;
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v13 = v12;
    if (v12)
    {
      xpc_object_t v39 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v39 = v13;
      if (!v13)
      {
        xpc_object_t v16 = xpc_null_create();
        xpc_object_t v13 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v13);
LABEL_27:
      xpc_release(v13);
      xpc_object_t v37 = xpc_string_create(off_101B0AF20[0]);
      if (!v37) {
        xpc_object_t v37 = xpc_null_create();
      }
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0AEB0[0];
      sub_100035E70((uint64_t)buf, &v37, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v37);
      xpc_object_t v37 = 0;
      xpc_object_t v35 = xpc_int64_create(a3);
      if (!v35) {
        xpc_object_t v35 = xpc_null_create();
      }
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0AF70[0];
      sub_100035E70((uint64_t)buf, &v35, &v36);
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_release(v35);
      xpc_object_t v35 = 0;
      ctu::cf_to_xpc((uint64_t *)&v33, (ctu *)*a4, v17);
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0AF40[0];
      sub_100035E70((uint64_t)buf, &v33, &v34);
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_release(v33);
      xpc_object_t v33 = 0;
      if (SHIBYTE(v45[0]) >= 0) {
        unint64_t v18 = v44;
      }
      else {
        unint64_t v18 = (void **)v44[0];
      }
      xpc_object_t v31 = xpc_string_create((const char *)v18);
      if (!v31) {
        xpc_object_t v31 = xpc_null_create();
      }
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0AFD8[0];
      sub_100035E70((uint64_t)buf, &v31, &v32);
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_release(v31);
      xpc_object_t v31 = 0;
      xpc_object_t v29 = xpc_int64_create(SLOBYTE(value[1]));
      if (!v29) {
        xpc_object_t v29 = xpc_null_create();
      }
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0B008[0];
      sub_100035E70((uint64_t)buf, &v29, &v30);
      xpc_release(v30);
      xpc_object_t v30 = 0;
      xpc_release(v29);
      xpc_object_t v29 = 0;
      if (v50 >= 0) {
        CFTypeRef v19 = (const char *)&v49;
      }
      else {
        CFTypeRef v19 = (const char *)v49;
      }
      xpc_object_t v27 = xpc_string_create(v19);
      if (!v27) {
        xpc_object_t v27 = xpc_null_create();
      }
      *(void *)long long buf = &v39;
      *(char **)&uint8_t buf[8] = off_101B0B000[0];
      sub_100035E70((uint64_t)buf, &v27, &v28);
      xpc_release(v28);
      xpc_object_t v28 = 0;
      xpc_release(v27);
      xpc_object_t v26 = 0;
      xpc_object_t v27 = 0;
      uint64_t v20 = *(void *)(a2 + 120);
      xpc_object_t v25 = v39;
      if (v39) {
        xpc_retain(v39);
      }
      else {
        xpc_object_t v25 = xpc_null_create();
      }
      (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v20 + 16))(&v26, v20, &v25);
      xpc_release(v25);
      xpc_object_t v25 = 0;
      v21[0] = &v26;
      v21[1] = off_101B0B000[0];
      sub_100048BAC((uint64_t)v21, &v22);
      memset(buf, 0, sizeof(buf));
      uint64_t v52 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v52) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v50) < 0) {
        operator delete((void *)v49);
      }
      long long v49 = v23;
      uint64_t v50 = v24;
      HIBYTE(v24) = 0;
      LOBYTE(v23) = 0;
      xpc_release(v22);
      sub_100687FA4(a1, (long long *)v41, &v49);
      xpc_release(v26);
      xpc_release(v39);
      goto LABEL_51;
    }
    xpc_object_t v16 = xpc_null_create();
LABEL_26:
    xpc_object_t v39 = v16;
    goto LABEL_27;
  }
  long long v14 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    long long v15 = *a4;
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N No matched bundle found for provided matching info: %@", buf, 0xCu);
  }
  sub_100687FA4(a1, (long long *)v41, &v49);
LABEL_51:
  if (SHIBYTE(value[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[1]);
  }
  if (SHIBYTE(v45[0]) < 0) {
    operator delete(v44[0]);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[1]);
  }
  if (SHIBYTE(v42[0]) < 0) {
    operator delete(v41[0]);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete((void *)v49);
  }
}

void sub_1006831BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, xpc_object_t object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1006832E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_1006833E0(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_10062B11C((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100683524(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10068353C(uint64_t a1, int a2, char a3, uint64_t a4)
{
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  sub_1000278EC((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100683684(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_10068369C(const void **a1)
{
  sub_100057D78(a1 + 31);
  sub_100057D78(a1 + 30);
  sub_100057D78(a1 + 26);
  sub_100057D78(a1 + 25);

  return sub_10000BDF8((uint64_t)a1);
}

void sub_1006836F0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10069B198;
  void v6[3] = &unk_1019F84D0;
  v6[4] = a1 + 8;
  void v6[5] = v5;
  char v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *(void *)(a3 + 144) = 0;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_10069B3F0;
    long long v11 = &unk_1019F8510;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(void *)(a3 + 144) = 0;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 8sub_10010E764((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_10069B200;
    long long v11 = &unk_1019F84F0;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_100683840(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10069B504;
  void v6[3] = &unk_1019F8550;
  v6[4] = a1 + 8;
  void v6[5] = v5;
  char v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_100694AC4;
    long long v11 = &unk_1019F8130;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_100694A4C;
    long long v11 = &unk_1019F8110;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_100683960(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10069B808;
  void v6[3] = &unk_1019F8570;
  v6[4] = a1 + 8;
  void v6[5] = v5;
  char v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_100694AC4;
    long long v11 = &unk_1019F8130;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_100694A4C;
    long long v11 = &unk_1019F8110;
    uint64_t v12 = a3;
    xpc_object_t v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

BOOL sub_100683A80(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v2 + 16);
  uint64_t v3 = *(void *)(v2 + 24);
  return v4 == *(void *)(a2 + 16) && v3 == *(void *)(a2 + 24);
}

void sub_100683A9C(void *a1, uint64_t *a2)
{
  if (*a2 != a2[1])
  {
    uint64_t v3 = a1[259];
    uint64_t v4 = a1[260];
    if (v3 != v4)
    {
      while (2)
      {
        uint64_t v6 = *a2;
        uint64_t v7 = a2[1];
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        long long v10 = sub_100683A80;
        long long v11 = &unk_1019F6DC0;
        uint64_t v12 = v3;
        while (v6 != v7)
        {
          if (((uint64_t (*)(void *, uint64_t))v10)(v9, v6))
          {
            if (v6 != v7
              && *(unsigned char *)(v3 + 80)
              && (!*(unsigned char *)(v6 + 80)
               || 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v3 + 64) - *(void *)(v3 + 56)) >> 3) > 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v6 + 64) - *(void *)(v6 + 56)) >> 3)))
            {
              uint64_t v8 = a1[5];
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v9[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I New profile available. Check for update.", (uint8_t *)v9, 2u);
              }
              sub_10067D784((uint64_t)a1, 0, 3);
              return;
            }
            break;
          }
          v6 += 88;
        }
        v3 += 88;
        if (v3 != v4) {
          continue;
        }
        break;
      }
    }
  }
}

void sub_100683C30(uint64_t a1, int a2, char a3, uint64_t a4)
{
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  sub_1000278EC((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100683D78(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100683D90(uint64_t a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, void *a4@<X8>)
{
  if (*a2) {
    int v5 = sub_100080778;
  }
  else {
    int v5 = 0;
  }
  if (!v5 || a3[1] == *a3)
  {
    *a4 = 0;
    return;
  }
  long long v50 = 0uLL;
  uint64_t v51 = 0;
  sub_100058198(&v39, a2);
  v52[0] = (const void *)a1;
  v52[1] = &v39;
  v53[0] = _NSConcreteStackBlock;
  v53[1] = (const void *)0x40000000;
  v53[2] = sub_10069B49C;
  v53[3] = &unk_1019F8530;
  v53[4] = (const void *)(a1 + 8);
  v53[5] = v52;
  CFDictionaryRef v54 = (const __CFDictionary *)v53;
  uint64_t v8 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *(_OWORD *)std::string::size_type v40 = 0u;
    *(_OWORD *)int v41 = 0u;
    long long v42 = 0u;
    *(_OWORD *)long long v43 = 0u;
    *(_OWORD *)CFNumberRef v44 = 0u;
    long long v45 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v49 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v56 = 0x40000000;
    char v57 = sub_10069B3F0;
    uint64_t v58 = &unk_1019F8510;
    CFTypeRef v59 = v40;
    int v60 = (const void **)&v54;
    dispatch_async_and_wait(v8, &block);
  }
  else
  {
    *(_OWORD *)std::string::size_type v40 = 0u;
    *(_OWORD *)int v41 = 0u;
    long long v42 = 0u;
    *(_OWORD *)long long v43 = 0u;
    *(_OWORD *)CFNumberRef v44 = 0u;
    long long v45 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v49 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v56 = 0x40000000;
    char v57 = sub_10069B200;
    uint64_t v58 = &unk_1019F84F0;
    CFTypeRef v59 = v40;
    int v60 = (const void **)&v54;
    dispatch_sync(v8, &block);
  }
  long long v50 = v48;
  uint64_t v51 = v49;
  long long v48 = 0uLL;
  uint64_t v49 = 0;
  if (SBYTE7(v47) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete(v44[1]);
  }
  if (SHIBYTE(v44[0]) < 0) {
    operator delete(v43[0]);
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(v41[1]);
  }
  if (SHIBYTE(v41[0]) < 0) {
    operator delete(v40[0]);
  }
  sub_100057D78(&v39);
  blocuint64_t k = 0;
  v53[0] = 0;
  v52[0] = 0;
  uint64_t v9 = HIBYTE(v51);
  if (v51 < 0) {
    uint64_t v9 = *((void *)&v50 + 1);
  }
  if (v9)
  {
    CFDictionaryRef v54 = 0;
    Registry::getFileSystemInterface((uint64_t *)v40, *(Registry **)(a1 + 104));
    (*(void (**)(const __CFDictionary **__return_ptr))(*(void *)v40[0] + 152))(&v54);
    if (v40[1]) {
      sub_10004D2C8((std::__shared_weak_count *)v40[1]);
    }
    if (v54) {
      long long v10 = sub_100080778;
    }
    else {
      long long v10 = 0;
    }
    if (v10)
    {
      if (a3[1] == *a3) {
        sub_10015B728();
      }
      v40[0] = (void *)CFDictionaryGetValue(v54, **a3);
      sub_100057DAC((const void **)&block, (CFTypeRef *)v40);
    }
    sub_100057D78((const void **)&v54);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    long long v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  v40[0] = (void *)v13;
  CFTypeID v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v40);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unint64_t v18 = 0;
  char v20 = 1;
LABEL_40:
  if (a3[1] == *a3) {
    sub_10015B728();
  }
  (*(void (**)(const __CFDictionary **__return_ptr, uint64_t, uint64_t, uint64_t, const void *, void, void))(*(void *)v19 + 80))(&v54, v19, 1, 4, **a3, 0, 0);
  v40[0] = (void *)v53[0];
  v53[0] = v54;
  CFDictionaryRef v54 = 0;
  sub_1000577C4((const void **)v40);
  sub_1000577C4((const void **)&v54);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (block) {
    unsigned __int8 v21 = sub_100080934;
  }
  else {
    unsigned __int8 v21 = 0;
  }
  if (v21)
  {
    CFTypeID v22 = CFGetTypeID(block);
    if (v22 != CFDictionaryGetTypeID())
    {
      *a4 = block;
      blocuint64_t k = 0;
      goto LABEL_91;
    }
    sub_100058470(v52, (const void **)&block);
    if (v53[0]) {
      long long v23 = sub_100080934;
    }
    else {
      long long v23 = 0;
    }
    if (v23)
    {
      CFTypeID v24 = CFGetTypeID(v53[0]);
      if (v24 == CFDictionaryGetTypeID())
      {
        copyMergedDictionaries((const __CFDictionary *)v53[0], (const __CFDictionary *)block, &cf);
        CFDictionaryRef v54 = (const __CFDictionary *)cf;
        if (cf)
        {
          CFRetain(cf);
          CFDictionaryRef v25 = v54;
        }
        else
        {
          CFDictionaryRef v25 = 0;
        }
        v40[0] = (void *)v52[0];
        v52[0] = v25;
        CFDictionaryRef v54 = 0;
        sub_1000577C4((const void **)v40);
        sub_1000577C4((const void **)&v54);
        sub_100057D78(&cf);
      }
    }
LABEL_65:
    if (v52[0]) {
      xpc_object_t v28 = sub_100080934;
    }
    else {
      xpc_object_t v28 = 0;
    }
    if (v28)
    {
      if ((char *)a3[1] - (char *)*a3 == 8)
      {
        *a4 = v52[0];
        v52[0] = 0;
      }
      else
      {
        CFDictionaryRef v54 = 0;
        sub_10004EFE4(&v54, v52);
        CFTypeRef cf = 0;
        uint64_t v29 = (char *)a3[1] - (char *)*a3;
        if ((unint64_t)v29 >= 9)
        {
          unint64_t v30 = (v29 >> 3) - 1;
          if ((unint64_t)(v29 >> 3) <= 2) {
            uint64_t v31 = 2;
          }
          else {
            uint64_t v31 = v29 >> 3;
          }
          uint64_t v32 = 2 - (v29 >> 3);
          unint64_t v33 = 1;
          while (v32 + v33 != 1)
          {
            if (v33 >= a3[1] - *a3) {
              sub_10015B728();
            }
            CFTypeRef Value = CFDictionaryGetValue(v54, (*a3)[v33]);
            v40[0] = 0;
            sub_10004EFE4(v40, &Value);
            CFDictionaryRef v34 = v54;
            CFDictionaryRef v54 = (const __CFDictionary *)v40[0];
            v40[0] = v34;
            sub_100057D78((const void **)v40);
            if (v54) {
              xpc_object_t v35 = sub_100080778;
            }
            else {
              xpc_object_t v35 = 0;
            }
            if (!v35 || (CFTypeID v36 = CFGetTypeID(v54), v36 != CFDictionaryGetTypeID()))
            {
              *a4 = 0;
              goto LABEL_90;
            }
            if (v31 == ++v33) {
              goto LABEL_89;
            }
          }
          if (v30 >= a3[1] - *a3) {
            sub_10015B728();
          }
          v40[0] = (void *)CFDictionaryGetValue(v54, (*a3)[v30]);
          sub_100057DAC(&cf, (CFTypeRef *)v40);
        }
LABEL_89:
        *a4 = cf;
        CFTypeRef cf = 0;
LABEL_90:
        sub_1000577C4(&cf);
        sub_100057D78((const void **)&v54);
      }
      goto LABEL_91;
    }
    goto LABEL_71;
  }
  if (v53[0]) {
    xpc_object_t v26 = sub_100080934;
  }
  else {
    xpc_object_t v26 = 0;
  }
  if (v26)
  {
    CFTypeID v27 = CFGetTypeID(v53[0]);
    if (v27 != CFDictionaryGetTypeID())
    {
      *a4 = v53[0];
      v53[0] = 0;
      goto LABEL_91;
    }
    sub_100058470(v52, v53);
    goto LABEL_65;
  }
LABEL_71:
  *a4 = 0;
LABEL_91:
  sub_1000577C4(v52);
  sub_1000577C4(v53);
  sub_1000577C4((const void **)&block);
  if (SHIBYTE(v51) < 0) {
    operator delete((void *)v50);
  }
}

void sub_100684490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_1000577C4(&a11);
  sub_100057D78((const void **)(v38 - 120));
  sub_1000577C4((const void **)(v38 - 184));
  sub_1000577C4((const void **)(v38 - 168));
  sub_1000577C4((const void **)(v38 - 112));
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10068452C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10069BAEC;
  void v6[3] = &unk_1019F8590;
  v6[4] = a1 + 8;
  void v6[5] = v5;
  char v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_10069C2B8;
    long long v11 = &unk_1019F85D0;
    uint64_t v12 = a3;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    long long v10 = sub_10069C240;
    long long v11 = &unk_1019F85B0;
    uint64_t v12 = a3;
    uint64_t v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_10068464C(uint64_t a1, const void **a2, char a3, uint64_t a4)
{
  void v7[4] = a1;
  sub_100062740(&v8, a2);
  char v9 = a3;
  sub_1000DFC90((uint64_t)&v10, a4);
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_1006847B0(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1006847DC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_100684818(uint64_t a1, int a2, char a3, uint64_t a4)
{
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  sub_1000DFC90((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100684960(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100684978(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10069D4F0;
  void v7[3] = &unk_1019F8670;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v15 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_10069D53C;
    uint64_t v12 = &unk_1019F86B0;
    uint64_t v13 = &v15;
    long long v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v15 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_10069D500;
    uint64_t v12 = &unk_1019F8690;
    uint64_t v13 = &v15;
    long long v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

uint64_t sub_100684AAC(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100684AF0(uint64_t a1, int a2)
{
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  memset(v18, 0, sizeof(v18));
  sub_10067C528((uint64_t)v18, a1, 1u, a2);
  if ((_BYTE)v22)
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v17 = 0;
    if (SBYTE7(v20) < 0)
    {
      sub_10004FC84(__dst, (void *)v19, *((unint64_t *)&v19 + 1));
    }
    else
    {
      *(_OWORD *)std::string __dst = v19;
      uint64_t v17 = v20;
    }
    uint64_t v3 = HIBYTE(v17);
    if (v17 >= 0)
    {
      uint64_t v4 = __dst;
    }
    else
    {
      uint64_t v3 = (uint64_t)__dst[1];
      uint64_t v4 = (void **)__dst[0];
    }
    if (v3 >= 4)
    {
      int v5 = (char *)v4 + v3;
      int v6 = v4;
      do
      {
        char v7 = (char *)memchr(v6, 103, v3 - 3);
        if (!v7) {
          break;
        }
        if (*(_DWORD *)v7 == 1634562919)
        {
          if (v7 == v5 || v7 - (char *)v4 == -1) {
            break;
          }
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          (*(void (**)(void **__return_ptr))(**(void **)(a1 + 88) + 120))(&__p);
          getGSMAOverlayKey(&v13);
          if (v12 < 0) {
            operator delete(__p);
          }
          if (SHIBYTE(v15) < 0)
          {
            uint64_t v9 = v14;
            operator delete(v13);
            if (!v9) {
              break;
            }
          }
          else if (!HIBYTE(v15))
          {
            break;
          }
          if (SHIBYTE(v17) < 0) {
            operator delete(__dst[0]);
          }
          uint64_t v8 = 1;
          goto LABEL_27;
        }
        int v6 = (void **)(v7 + 1);
        uint64_t v3 = v5 - (char *)v6;
      }
      while (v5 - (char *)v6 >= 4);
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(__dst[0]);
    }
  }
  uint64_t v8 = 0;
LABEL_27:
  sub_100687D34((uint64_t)v18);
  return v8;
}

void sub_100684CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_100687D34((uint64_t)&a25);
  _Unwind_Resume(a1);
}

const void **sub_100684D00(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 40));
  sub_1000558F4((const void **)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  return sub_100057D78((const void **)a1);
}

void sub_100684D54(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100684E30(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "false";
    if (a2) {
      int v5 = "true";
    }
    int v6 = 136315138;
    char v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Queue alert to show when SB started?: %s", (uint8_t *)&v6, 0xCu);
  }
  *(unsigned char *)(a1 + 433) = a2;
}

void sub_100684EF4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending request to show Other Known Carrier Settings removed alert", buf, 2u);
  }
  xpc_object_t object = 0;
  uint64_t v3 = off_101B0AEB0[0];
  uint64_t v4 = off_101B0AF18[0];
  sub_1006941A8(buf);
  sub_1006940C4(v4, (void **)buf, (uint64_t)v3, &object);
  xpc_release(*(xpc_object_t *)buf);
  uint64_t v5 = *(void *)(a1 + 120);
  xpc_object_t v6 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, xpc_object_t *))(*(void *)v5 + 16))(&v7, v5, &v6);
  xpc_release(v7);
  xpc_object_t v7 = 0;
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
}

void sub_100685014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12)
{
}

void sub_100685044(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100685120(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 2304);
  if (v2 == a2) {
    return;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "true";
    if (!v2) {
      uint64_t v5 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SpringBoardFinishedStartup state : %s", buf, 0xCu);
    int v2 = *(unsigned __int8 *)(a1 + 2304);
  }
  if (v2)
  {
    if (*(unsigned char *)(a1 + 433))
    {
      xpc_object_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I SB Startup done. Show Other known alert.", buf, 2u);
      }
      sub_100684EF4(a1);
      sub_100684E30(a1, 0);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (!v13)
    {
      std::mutex::unlock(v8);
      return;
    }
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      if (!v15) {
        goto LABEL_47;
      }
    }
    else
    {
      std::mutex::unlock(v8);
      if (!v15) {
        return;
      }
    }
    unint64_t v30 = 0;
    (*(void (**)(__CFString **__return_ptr, uint64_t))(*(void *)v15 + 112))(&v30, v15);
    if (v30) {
      uint64_t v17 = sub_1000810B8;
    }
    else {
      uint64_t v17 = 0;
    }
    if (v17)
    {
      unint64_t v18 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
      long long v19 = v18;
      if (v20 < 0)
      {
        long long v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v22 = 5381;
        do
        {
          uint64_t v20 = v22;
          unsigned int v23 = *v21++;
          uint64_t v22 = (33 * v22) ^ v23;
        }
        while (v23);
      }
      std::mutex::lock(v18);
      *(void *)long long buf = v20;
      CFTypeID v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
      if (!v24)
      {
        std::mutex::unlock(v19);
        goto LABEL_46;
      }
      uint64_t v26 = v24[3];
      CFDictionaryRef v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        if (!v26)
        {
LABEL_45:
          sub_10004D2C8(v25);
          goto LABEL_46;
        }
      }
      else
      {
        std::mutex::unlock(v19);
        if (!v26) {
          goto LABEL_46;
        }
      }
      *(void *)long long buf = 0;
      (*(void (**)(const void **__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v26 + 40))(&v29, v26, @"lastKnownOSVersion", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100056248(buf, &v29);
      sub_1000577C4(&v29);
      if (*(void *)buf) {
        xpc_object_t v28 = sub_1000810B8;
      }
      else {
        xpc_object_t v28 = 0;
      }
      if (!v28 || _CompareBundleVersionStrings(v30, *(const __CFString **)buf))
      {
        sub_10067D784(a1, 0, 6);
        (*(void (**)(uint64_t, const __CFString *, __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v26 + 16))(v26, @"lastKnownOSVersion", v30, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      }
      sub_1000558F4((const void **)buf);
      if (v25) {
        goto LABEL_45;
      }
    }
    else
    {
      CFTypeID v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Error fetching current OS version for update check.", buf, 2u);
      }
    }
LABEL_46:
    sub_1000558F4((const void **)&v30);
    if (!v14) {
      return;
    }
LABEL_47:
    sub_10004D2C8(v14);
    return;
  }
  unsigned int v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Springboard is not started. Nothing to do.", buf, 2u);
  }
}

void sub_100685580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a9);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_1000558F4(&a10);
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_1006855FC(int a1@<W1>, int a2@<W2>, void *a3@<X8>)
{
}

void sub_100685604(uint64_t a1, uint64_t *a2, char *a3)
{
  long long v72 = 0;
  uint64_t v73 = 0;
  CFNumberRef v74 = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  *(void *)long long buf = &v72;
  if (v5 != v4)
  {
    unint64_t v6 = 0x8E38E38E38E38E39 * ((v5 - v4) >> 4);
    *(void *)&uint8_t buf[8] = 0;
    if (v6 >= 0x1C71C71C71C71C8) {
      sub_10006A748();
    }
    uint64_t v8 = (long long *)sub_100344704((uint64_t)&v74, v6);
    unint64_t v9 = 0;
    long long v72 = v8;
    uint64_t v73 = v8;
    CFNumberRef v74 = (char *)&v8[9 * v10];
    do
    {
      uint64_t v11 = (char *)&v8[v9 / 0x10];
      unsigned int v12 = (long long *)(v4 + v9);
      if (*(char *)(v4 + v9 + 23) < 0)
      {
        sub_10004FC84(v11, *(void **)v12, *((void *)v12 + 1));
      }
      else
      {
        long long v13 = *v12;
        *((void *)v11 + 2) = *((void *)v12 + 2);
        *(_OWORD *)uint64_t v11 = v13;
      }
      uint64_t v14 = (char *)&v8[v9 / 0x10 + 1] + 8;
      uint64_t v15 = (void **)(v4 + v9 + 24);
      if (*(char *)(v4 + v9 + 47) < 0)
      {
        sub_10004FC84(v14, *v15, *(void *)(v4 + v9 + 32));
      }
      else
      {
        long long v16 = *(_OWORD *)v15;
        *((void *)&v8[v9 / 0x10 + 2] + 1) = *(void *)(v4 + v9 + 40);
        *(_OWORD *)uint64_t v14 = v16;
      }
      uint64_t v17 = (char *)&v8[v9 / 0x10 + 3];
      unint64_t v18 = (void **)(v4 + v9 + 48);
      if (*(char *)(v4 + v9 + 71) < 0)
      {
        sub_10004FC84(v17, *v18, *(void *)(v4 + v9 + 56));
      }
      else
      {
        long long v19 = *(_OWORD *)v18;
        *(void *)&v8[v9 / 0x10 + 4] = *(void *)(v4 + v9 + 64);
        *(_OWORD *)uint64_t v17 = v19;
      }
      uint64_t v20 = (char *)&v8[v9 / 0x10 + 4] + 8;
      long long v21 = (void **)(v4 + v9 + 72);
      if (*(char *)(v4 + v9 + 95) < 0)
      {
        sub_10004FC84(v20, *v21, *(void *)(v4 + v9 + 80));
      }
      else
      {
        long long v22 = *(_OWORD *)v21;
        *((void *)&v8[v9 / 0x10 + 5] + 1) = *(void *)(v4 + v9 + 88);
        *(_OWORD *)uint64_t v20 = v22;
      }
      unsigned int v23 = (char *)&v8[v9 / 0x10 + 6];
      CFTypeID v24 = (void **)(v4 + v9 + 96);
      if (*(char *)(v4 + v9 + 119) < 0)
      {
        sub_10004FC84(v23, *v24, *(void *)(v4 + v9 + 104));
      }
      else
      {
        long long v25 = *(_OWORD *)v24;
        *(void *)&v8[v9 / 0x10 + 7] = *(void *)(v4 + v9 + 112);
        *(_OWORD *)unsigned int v23 = v25;
      }
      uint64_t v26 = (char *)&v8[v9 / 0x10 + 7] + 8;
      CFTypeID v27 = (void **)(v4 + v9 + 120);
      if (*(char *)(v4 + v9 + 143) < 0)
      {
        sub_10004FC84(v26, *v27, *(void *)(v4 + v9 + 128));
      }
      else
      {
        long long v28 = *(_OWORD *)v27;
        *((void *)&v8[v9 / 0x10 + 8] + 1) = *(void *)(v4 + v9 + 136);
        *(_OWORD *)uint64_t v26 = v28;
      }
      v9 += 144;
    }
    while (v4 + v9 != v5);
    uint64_t v73 = &v8[v9 / 0x10];
    if (v72 != &v8[v9 / 0x10])
    {
      if (*(unsigned char *)(a1 + 409) != 1)
      {
        uint64_t v31 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Internet not available, Cannot process update check", buf, 2u);
        }
        char v30 = 1;
        goto LABEL_43;
      }
      if (*(unsigned char *)(a1 + 2096))
      {
        uint64_t v29 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I At least one call is active, Cannot process update check", buf, 2u);
        }
        char v30 = 2;
        goto LABEL_43;
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 120) + 32))(buf);
      uint64_t v32 = *(void *)buf;
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v32)
      {
        unint64_t v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          CFDictionaryRef v34 = "#I Bundle update is in progress. Cannot process this update check.";
LABEL_41:
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v34, buf, 2u);
          goto LABEL_42;
        }
        goto LABEL_42;
      }
      if (*(unsigned char *)(a1 + 2306))
      {
        unint64_t v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          CFDictionaryRef v34 = "#I Desktop Bundle update is in progress. Cannot process this update check.";
          goto LABEL_41;
        }
LABEL_42:
        char v30 = 3;
LABEL_43:
        *a3 = v30;
        goto LABEL_44;
      }
      CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      xpc_object_t v35 = (capabilities::ct *)capabilities::ct::supportsVoiceCall(theDict);
      if (v35) {
        CFTypeID v36 = &kCFBooleanTrue;
      }
      else {
        CFTypeID v36 = &kCFBooleanFalse;
      }
      xpc_object_t v70 = 0;
      capabilities::ct::deviceName((uint64_t *)v68, v35);
      if (SHIBYTE(v69) < 0)
      {
        sub_10004FC84(__p, v68[0], (unint64_t)v68[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v68;
        uint64_t v77 = v69;
      }
      xpc_object_t v75 = 0;
      if (SHIBYTE(v77) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        uint64_t v79 = v77;
      }
      CFMutableArrayRef v80 = 0;
      if (ctu::cf::convert_copy())
      {
        xpc_object_t v37 = v75;
        xpc_object_t v75 = v80;
        *(void *)long long v81 = v37;
        sub_1000558F4((const void **)v81);
      }
      if (SHIBYTE(v79) < 0) {
        operator delete(*(void **)buf);
      }
      CFBooleanRef v38 = *v36;
      xpc_object_t v70 = v75;
      xpc_object_t v75 = 0;
      sub_1000558F4((const void **)&v75);
      if (SHIBYTE(v77) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v69) < 0) {
        operator delete(v68[0]);
      }
      CFDictionarySetValue(theDict, @"SupportsVoiceCall", v38);
      CFDictionarySetValue(theDict, @"DeviceName", v70);
      CFMutableArrayRef v80 = 0;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        CFMutableArrayRef v40 = v80;
        CFMutableArrayRef v80 = Mutable;
        *(void *)long long buf = v40;
        sub_1000440D4((const void **)buf);
      }
      int v41 = v72;
      long long v42 = v73;
      sub_100057240(&v64, (const void **)&theDict);
      sub_100687E80(v65, (const void **)&v80);
      v65[1] = (const void *)a1;
      sub_100686118((uint64_t)&v66, v41, v42, (uint64_t)&v64);
      sub_1000440D4(&v67);
      sub_10005717C(&v66);
      sub_1000440D4(v65);
      sub_10005717C(&v64);
      if (v80) {
        long long v43 = sub_100289354;
      }
      else {
        long long v43 = 0;
      }
      if (!v43)
      {
        *a3 = 0;
LABEL_94:
        sub_1000440D4((const void **)&v80);
        sub_1000558F4((const void **)&v70);
        sub_10005717C((const void **)&theDict);
        goto LABEL_44;
      }
      CFDictionarySetValue(theDict, @"kBundleUpdateCheckCriteria", v80);
      xpc_object_t v75 = 0;
      xpc_object_t v44 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v45 = v44;
      if (v44)
      {
        xpc_object_t v75 = v44;
      }
      else
      {
        xpc_object_t v45 = xpc_null_create();
        xpc_object_t v75 = v45;
        if (!v45)
        {
          xpc_object_t v46 = xpc_null_create();
          xpc_object_t v45 = 0;
          goto LABEL_76;
        }
      }
      if (xpc_get_type(v45) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v45);
LABEL_77:
        xpc_release(v45);
        xpc_object_t v62 = xpc_string_create(off_101B0AEF8[0]);
        if (!v62) {
          xpc_object_t v62 = xpc_null_create();
        }
        *(void *)long long buf = &v75;
        *(char **)&uint8_t buf[8] = off_101B0AEB0[0];
        sub_100035E70((uint64_t)buf, &v62, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v62);
        xpc_object_t v62 = 0;
        xpc_object_t v60 = xpc_int64_create(8);
        if (!v60) {
          xpc_object_t v60 = xpc_null_create();
        }
        *(void *)long long buf = &v75;
        *(char **)&uint8_t buf[8] = off_101B0B020[0];
        sub_100035E70((uint64_t)buf, &v60, &v61);
        xpc_release(v61);
        xpc_object_t v61 = 0;
        xpc_release(v60);
        xpc_object_t v60 = 0;
        ctu::cf_to_xpc((uint64_t *)&v58, theDict, v47);
        *(void *)long long buf = &v75;
        *(char **)&uint8_t buf[8] = off_101B0AF40[0];
        sub_100035E70((uint64_t)buf, &v58, &v59);
        xpc_release(v59);
        xpc_object_t v59 = 0;
        xpc_release(v58);
        xpc_object_t v58 = 0;
        char v48 = sub_10067F9E0(a1);
        xpc_object_t v56 = xpc_BOOL_create(v48);
        if (!v56) {
          xpc_object_t v56 = xpc_null_create();
        }
        *(void *)long long buf = &v75;
        *(void *)&uint8_t buf[8] = off_101B0B060;
        sub_100035E70((uint64_t)buf, &v56, &v57);
        xpc_release(v57);
        xpc_object_t v57 = 0;
        xpc_release(v56);
        xpc_object_t v56 = 0;
        *(unsigned char *)(a1 + 434) = 1;
        __p[0] = 0;
        __p[1] = 0;
        sub_100687204(__p, (uint64_t)a3);
        uint64_t v49 = *(void *)(a1 + 120);
        sub_100117418(&v55, &v75);
        uint64_t v51 = __p[0];
        long long v50 = (std::__shared_weak_count *)__p[1];
        if (__p[1]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v83 = 0;
        uint64_t v52 = operator new(0x20uLL);
        void *v52 = off_1019F8730;
        v52[1] = v51;
        v52[2] = v50;
        v52[3] = a1;
        uint64_t v83 = v52;
        (*(void (**)(uint64_t, xpc_object_t *, void *))(*(void *)v49 + 24))(v49, &v55, v82);
        sub_1001472DC(v82);
        xpc_release(v55);
        xpc_object_t v55 = 0;
        unsigned int v53 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          xpc::object::to_string((uint64_t *)buf, (xpc::object *)&v75);
          CFDictionaryRef v54 = v79 >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)long long v81 = 136315138;
          *(void *)&v81[4] = v54;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Sent request %s to check bundle update for requested plans", v81, 0xCu);
          if (SHIBYTE(v79) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v50) {
          sub_10004D2C8(v50);
        }
        xpc_release(v75);
        goto LABEL_94;
      }
      xpc_object_t v46 = xpc_null_create();
LABEL_76:
      xpc_object_t v75 = v46;
      goto LABEL_77;
    }
  }
  *a3 = 0;
LABEL_44:
  *(void *)long long buf = &v72;
  sub_1006881C0((void ***)buf);
}

void sub_100685EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,xpc_object_t object,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100686118(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    CFMutableArrayRef v40 = (void *)qword_101B13EC0;
    xpc_object_t v7 = (void *)qword_101B13EB8;
    do
    {
      uint64_t v8 = *(void *)(a4 + 16);
      xpc_object_t v58 = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v10 = v58;
        xpc_object_t v58 = Mutable;
        valuePtr[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
        sub_10005717C((const void **)&valuePtr[0].__r_.__value_.__l.__data_);
      }
      v63.__r_.__value_.__r.__words[0] = 0;
      valuePtr[0].__r_.__value_.__r.__words[0] = 1;
      CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, valuePtr);
      if (v11)
      {
        std::string::size_type v12 = v63.__r_.__value_.__r.__words[0];
        v63.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
        valuePtr[0].__r_.__value_.__r.__words[0] = v12;
        sub_1000570E8((const void **)&valuePtr[0].__r_.__value_.__l.__data_);
      }
      v60.__r_.__value_.__r.__words[0] = v63.__r_.__value_.__r.__words[0];
      v63.__r_.__value_.__r.__words[0] = 0;
      sub_1000570E8((const void **)&v63.__r_.__value_.__l.__data_);
      sub_10069637C(v58, @"kUpdateBundleType", (uint64_t)v60.__r_.__value_.__l.__data_);
      sub_1000570E8((const void **)&v60.__r_.__value_.__l.__data_);
      long long v13 = (void **)v6 + 15;
      if (*((char *)v6 + 143) < 0)
      {
        unint64_t v15 = *((void *)v6 + 16);
        if (!v15)
        {
LABEL_14:
          sub_1002055B4((const void **)v6 + 3, (const void **)v6 + 6, &__dst);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v63, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string v63 = __dst;
          }
          __p.__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
          }
          else {
            valuePtr[0] = v63;
          }
          v56.__r_.__value_.__r.__words[0] = 0;
          if (ctu::cf::convert_copy())
          {
            std::string::size_type v17 = __p.__r_.__value_.__r.__words[0];
            __p.__r_.__value_.__r.__words[0] = v56.__r_.__value_.__r.__words[0];
            v60.__r_.__value_.__r.__words[0] = v17;
            sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(valuePtr[0].__r_.__value_.__l.__data_);
          }
          v54.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
          __p.__r_.__value_.__r.__words[0] = 0;
          sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
          if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v63.__r_.__value_.__l.__data_);
          }
          goto LABEL_37;
        }
        sub_10004FC84(&__dst, *v13, v15);
      }
      else
      {
        if (!*((unsigned char *)v6 + 143)) {
          goto LABEL_14;
        }
        long long v14 = *(_OWORD *)v13;
        __dst.__r_.__value_.__r.__words[2] = *((void *)v6 + 17);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v14;
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = __dst;
      }
      __p.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      v56.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
        __p.__r_.__value_.__r.__words[0] = v56.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v16;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      v54.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
      __p.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
LABEL_37:
      sub_10010F3F0(v58, v40, (uint64_t)v54.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v54.__r_.__value_.__l.__data_);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (*((char *)v6 + 47) < 0)
      {
        sub_10004FC84(&v56, *((void **)v6 + 3), *((void *)v6 + 4));
      }
      else
      {
        long long v18 = *(long long *)((char *)v6 + 24);
        v56.__r_.__value_.__r.__words[2] = *((void *)v6 + 5);
        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v18;
      }
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, v56.__r_.__value_.__l.__data_, v56.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = v56;
      }
      v54.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      __p.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v19 = v54.__r_.__value_.__r.__words[0];
        v54.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v19;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      v53.__r_.__value_.__r.__words[0] = v54.__r_.__value_.__r.__words[0];
      v54.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v54.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      sub_10010F3F0(v58, @"MCC", (uint64_t)v53.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v53.__r_.__value_.__l.__data_);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v56.__r_.__value_.__l.__data_);
      }
      if (*((char *)v6 + 71) < 0)
      {
        sub_10004FC84(&__p, *((void **)v6 + 6), *((void *)v6 + 7));
      }
      else
      {
        long long v20 = v6[3];
        __p.__r_.__value_.__r.__words[2] = *((void *)v6 + 8);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v20;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = __p;
      }
      v53.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      v54.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v21 = v53.__r_.__value_.__r.__words[0];
        v53.__r_.__value_.__r.__words[0] = v54.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v21;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      v52.__r_.__value_.__r.__words[0] = v53.__r_.__value_.__r.__words[0];
      v53.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v53.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      sub_10010F3F0(v58, @"MNC", (uint64_t)v52.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v52.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (*((char *)v6 + 95) < 0)
      {
        sub_10004FC84(&v54, *((void **)v6 + 9), *((void *)v6 + 10));
      }
      else
      {
        long long v22 = *(long long *)((char *)v6 + 72);
        v54.__r_.__value_.__r.__words[2] = *((void *)v6 + 11);
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v22;
      }
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, v54.__r_.__value_.__l.__data_, v54.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = v54;
      }
      v52.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      v53.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v23 = v52.__r_.__value_.__r.__words[0];
        v52.__r_.__value_.__r.__words[0] = v53.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v23;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      __str.__r_.__value_.__r.__words[0] = v52.__r_.__value_.__r.__words[0];
      v52.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v52.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      sub_10010F3F0(v58, @"GID1", (uint64_t)__str.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v54.__r_.__value_.__l.__data_);
      }
      if (*((char *)v6 + 119) < 0)
      {
        sub_10004FC84(&v53, *((void **)v6 + 12), *((void *)v6 + 13));
      }
      else
      {
        long long v24 = v6[6];
        v53.__r_.__value_.__r.__words[2] = *((void *)v6 + 14);
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v24;
      }
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, v53.__r_.__value_.__l.__data_, v53.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = v53;
      }
      __str.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      v52.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v25 = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = v52.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v25;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      v43.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      sub_10010F3F0(v58, @"GID2", (uint64_t)v43.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v43.__r_.__value_.__l.__data_);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v53.__r_.__value_.__l.__data_);
      }
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(&v52, *(void **)v6, *((void *)v6 + 1));
      }
      else
      {
        long long v26 = *v6;
        v52.__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v26;
      }
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v63, v52.__r_.__value_.__l.__data_, v52.__r_.__value_.__l.__size_);
      }
      else {
        std::string v63 = v52;
      }
      v43.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(valuePtr, v63.__r_.__value_.__l.__data_, v63.__r_.__value_.__l.__size_);
      }
      else {
        valuePtr[0] = v63;
      }
      __str.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v27 = v43.__r_.__value_.__r.__words[0];
        v43.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        v60.__r_.__value_.__r.__words[0] = v27;
        sub_1000558F4((const void **)&v60.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      v41.__r_.__value_.__r.__words[0] = v43.__r_.__value_.__r.__words[0];
      v43.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v43.__r_.__value_.__l.__data_);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      sub_10010F3F0(v58, v7, (uint64_t)v41.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v41.__r_.__value_.__l.__data_);
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v52.__r_.__value_.__l.__data_);
      }
      *(_OWORD *)long long v50 = 0u;
      long long v51 = 0u;
      *(_OWORD *)char v48 = 0u;
      long long v49 = 0u;
      *(_OWORD *)long long v47 = 0u;
      memset(valuePtr, 0, sizeof(valuePtr));
      sub_10004EFE4(&v45, (CFTypeRef *)&v58);
      CarrierBundleHandler::lookupBundle_sync(v8, 1u, &v45, (uint64_t)valuePtr);
      sub_100057D78(&v45);
      std::string::size_type size = HIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]);
      if ((valuePtr[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = valuePtr[0].__r_.__value_.__l.__size_;
      }
      if (size)
      {
        memset(&__str, 0, sizeof(__str));
        if (SHIBYTE(valuePtr[1].__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__str, valuePtr[1].__r_.__value_.__l.__data_, valuePtr[1].__r_.__value_.__l.__size_);
        }
        else {
          std::string __str = valuePtr[1];
        }
        std::string::size_type v29 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        int v30 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v29 = __str.__r_.__value_.__l.__size_;
        }
        if (v29 < 0xB)
        {
          uint64_t v31 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            if (v30 >= 0) {
              p_str = &__str;
            }
            LODWORD(v63.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v63.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N Invalid bundle identifer: %s", (uint8_t *)&v63, 0xCu);
          }
        }
        else
        {
          std::string::basic_string(&v63, &__str, 0xAuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v60);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string __str = v63;
        }
        unint64_t v33 = v58;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v43, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string v43 = __str;
        }
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v60, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
        }
        else {
          std::string v60 = v43;
        }
        xpc_object_t v61 = 0;
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v63, v60.__r_.__value_.__l.__data_, v60.__r_.__value_.__l.__size_);
        }
        else {
          std::string v63 = v60;
        }
        xpc_object_t v62 = 0;
        if (ctu::cf::convert_copy())
        {
          std::string::size_type v34 = (std::string::size_type)v61;
          xpc_object_t v61 = v62;
          v41.__r_.__value_.__r.__words[0] = v34;
          sub_1000558F4((const void **)&v41.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v63.__r_.__value_.__l.__data_);
        }
        xpc_object_t v59 = v61;
        xpc_object_t v61 = 0;
        sub_1000558F4(&v61);
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v60.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v33, @"BundleIDOnTheDevice", v59);
        sub_1000558F4(&v59);
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v43.__r_.__value_.__l.__data_);
        }
        xpc_object_t v35 = v58;
        if (SBYTE7(v51) < 0)
        {
          sub_10004FC84(&v41, v50[0], (unint64_t)v50[1]);
        }
        else
        {
          *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)v50;
          v41.__r_.__value_.__r.__words[2] = v51;
        }
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v60, v41.__r_.__value_.__l.__data_, v41.__r_.__value_.__l.__size_);
        }
        else {
          std::string v60 = v41;
        }
        xpc_object_t v59 = 0;
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v63, v60.__r_.__value_.__l.__data_, v60.__r_.__value_.__l.__size_);
        }
        else {
          std::string v63 = v60;
        }
        xpc_object_t v61 = 0;
        if (ctu::cf::convert_copy())
        {
          CFTypeID v36 = v59;
          xpc_object_t v59 = v61;
          xpc_object_t v62 = v36;
          sub_1000558F4(&v62);
        }
        if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v63.__r_.__value_.__l.__data_);
        }
        xpc_object_t v37 = v59;
        long long v42 = v59;
        xpc_object_t v59 = 0;
        sub_1000558F4(&v59);
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v60.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue(v35, @"BundleVersionOnTheDevice", v37);
        sub_1000558F4(&v42);
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v41.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      sub_100699750(*(__CFArray **)(a4 + 8), v58);
      if (SBYTE7(v51) < 0) {
        operator delete(v50[0]);
      }
      if (SHIBYTE(v49) < 0) {
        operator delete(v48[1]);
      }
      if (SHIBYTE(v48[0]) < 0) {
        operator delete(v47[0]);
      }
      if (SHIBYTE(valuePtr[1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[1].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(valuePtr[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(valuePtr[0].__r_.__value_.__l.__data_);
      }
      sub_10005717C((const void **)&v58);
      v6 += 9;
    }
    while (v6 != a3);
  }
  __n128 result = *(__n128 *)a4;
  *(_OWORD *)a1 = *(_OWORD *)a4;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a1 + 16) = *(void *)(a4 + 16);
  return result;
}

void sub_100686E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  sub_1000558F4((const void **)&a61);
  if (*(char *)(v61 - 105) < 0) {
    operator delete(*(void **)(v61 - 128));
  }
  if (*(char *)(v61 - 201) < 0) {
    operator delete(*(void **)(v61 - 224));
  }
  sub_10005717C((const void **)(v61 - 192));
  _Unwind_Resume(a1);
}

void sub_100687204(void *a1, uint64_t a2)
{
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x30uLL);
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019F86E0;
  *(_OWORD *)&v4[1].__shared_owners_ = *(_OWORD *)(a2 + 8);
  v4->__shared_owners_ = 0;
  LOBYTE(v4[1].__vftable) = *(unsigned char *)a2;
  *a1 = v4 + 1;
  a1[1] = v4;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);

  sub_10004D2C8(v4);
}

void sub_10068728C(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 16) && *(void *)(a1 + 2328))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Previous Rest property empty - probably a restart", buf, 2u);
    }
    uint64_t v3 = *(void **)(a1 + 2312);
    uint64_t v4 = (void *)(a1 + 2320);
    if (v3 != (void *)(a1 + 2320))
    {
      uint64_t v5 = (uint64_t **)(a1 + 136);
      uint64_t v48 = kApplyGSMASettingsKey;
      key = (void *)qword_101B13EB8;
      uint64_t v46 = kGsmaSettingsSwitchState;
      while (*((unsigned char *)v3 + 32))
      {
LABEL_71:
        std::string v43 = (void *)v3[1];
        if (v43)
        {
          do
          {
            xpc_object_t v44 = v43;
            std::string v43 = (void *)*v43;
          }
          while (v43);
        }
        else
        {
          do
          {
            xpc_object_t v44 = (void *)v3[2];
            BOOL v45 = *v44 == (void)v3;
            uint64_t v3 = v44;
          }
          while (!v45);
        }
        uint64_t v3 = v44;
        if (v44 == v4) {
          return;
        }
      }
      uint64_t v6 = *((unsigned int *)v3 + 7);
      uint64_t v61 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v9;
      long long v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
      if (v13)
      {
        uint64_t v15 = v13[3];
        long long v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      long long v14 = 0;
      char v16 = 1;
LABEL_17:
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, const CFBooleanRef, void))(*(void *)v15 + 80))(__src, v15, v6, 1, v48, kCFBooleanFalse, 0);
      sub_1000057AC(&v61, (CFTypeRef *)__src);
      sub_1000577C4((const void **)__src);
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v14);
      }
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v61, v17);
      if (!buf[0])
      {
        std::string::size_type v34 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I GSMA Settings key is not set in bundle. Nothing to do", buf, 2u);
        }
        goto LABEL_70;
      }
      CFDictionaryRef theDict = 0;
      __src[0] = (void *)((v6 << 32) | 1);
      *(void *)long long buf = __src;
      long long v18 = sub_100688D4C(v5, (unsigned __int8 *)__src, (uint64_t)&unk_10144E20E, (void **)buf);
      sub_100058198((const void **)&theDict, (const void **)v18 + 30);
      if (theDict) {
        std::string::size_type v19 = sub_100080778;
      }
      else {
        std::string::size_type v19 = 0;
      }
      if (!v19)
      {
        xpc_object_t v35 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "No valid matching info for slot.", buf, 2u);
        }
        goto LABEL_69;
      }
      CFDictionaryGetValue(theDict, key);
      memset(buf, 0, sizeof(buf));
      unint64_t v65 = 0;
      ctu::cf::assign();
      uint64_t v59 = v65;
      *(_OWORD *)std::string __src = *(_OWORD *)buf;
      unint64_t v20 = HIBYTE(v65);
      int v21 = SHIBYTE(v65);
      unint64_t v22 = *(void *)&buf[8];
      if ((v65 & 0x8000000000000000) != 0) {
        unint64_t v20 = *(void *)&buf[8];
      }
      if (!v20)
      {
        CFTypeID v36 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "No ICCID present in matching info. Cannot read the switch state.", buf, 2u);
        }
        goto LABEL_66;
      }
      std::string::size_type v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 104));
      long long v24 = v23;
      if (v25 < 0)
      {
        long long v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v27 = 5381;
        do
        {
          uint64_t v25 = v27;
          unsigned int v28 = *v26++;
          uint64_t v27 = (33 * v27) ^ v28;
        }
        while (v28);
      }
      std::mutex::lock(v23);
      *(void *)long long buf = v25;
      std::string::size_type v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
      if (v29)
      {
        uint64_t v31 = v29[3];
        int v30 = (std::__shared_weak_count *)v29[4];
        if (v30)
        {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v24);
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v30);
          char v32 = 0;
          if (!v31) {
            goto LABEL_33;
          }
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v31 = 0;
      }
      std::mutex::unlock(v24);
      int v30 = 0;
      char v32 = 1;
      if (!v31)
      {
LABEL_33:
        unint64_t v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface.", buf, 2u);
        }
LABEL_64:
        if ((v32 & 1) == 0) {
          sub_10004D2C8(v30);
        }
LABEL_66:
        if (SHIBYTE(v59) < 0) {
          operator delete(__src[0]);
        }
        uint64_t v4 = (void *)(a1 + 2320);
LABEL_69:
        sub_100057D78((const void **)&theDict);
LABEL_70:
        sub_100062778((const void **)&v61);
        goto LABEL_71;
      }
LABEL_43:
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v57 = 0;
      if (v21 < 0)
      {
        sub_10004FC84(__p, __src[0], v22);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__src;
        uint64_t v57 = v59;
      }
      xpc_object_t v55 = 0;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, uint64_t, void, void, uint64_t))(*(void *)v31 + 64))(&cf, v31, __p, v46, 0, 0, 1);
      CFTypeRef v63 = cf;
      if (cf) {
        CFRetain(cf);
      }
      xpc_object_t v62 = 0;
      *(void *)long long buf = 0;
      sub_1000057AC(buf, &v63);
      if (*(void *)buf) {
        xpc_object_t v37 = sub_100084B4C;
      }
      else {
        xpc_object_t v37 = 0;
      }
      if (v37) {
        sub_1005AED68(&v62, (const void **)buf);
      }
      sub_100062778((const void **)buf);
      xpc_object_t v55 = v62;
      xpc_object_t v62 = 0;
      sub_100062778(&v62);
      sub_1000577C4(&v63);
      sub_1000577C4(&cf);
      if (v55) {
        CFBooleanRef v38 = sub_100084B4C;
      }
      else {
        CFBooleanRef v38 = 0;
      }
      if (!v38)
      {
        xpc_object_t v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          CFMutableArrayRef v40 = __src;
          if (v59 < 0) {
            CFMutableArrayRef v40 = (void **)__src[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v40;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I No switch state stored for this ICCID:%s in preferences. Rematch carrier bundle for GSMA settings", buf, 0xCu);
        }
        xpc_object_t v62 = (const void *)((v6 << 32) | 1);
        *(void *)long long buf = &v62;
        std::string v41 = sub_100688D4C(v5, (unsigned __int8 *)&v62, (uint64_t)&unk_10144E20E, (void **)buf);
        sub_100058198(&v63, (const void **)v41 + 30);
        uint64_t v52 = (v6 << 32) | 1;
        *(void *)long long buf = &v52;
        long long v42 = sub_100688D4C(v5, (unsigned __int8 *)&v52, (uint64_t)&unk_10144E20E, (void **)buf);
        sub_100058198(&v53, (const void **)v42 + 31);
        uint64_t v50 = (v6 << 32) | 1;
        *(void *)long long buf = &v50;
        int v51 = *((_DWORD *)sub_100688D4C(v5, (unsigned __int8 *)&v50, (uint64_t)&unk_10144E20E, (void **)buf) + 64);
        CarrierBundleHandler::matchCarrierBundle_sync(a1, &v63, &v53, &v51, v6, 0, (uint64_t)buf);
        sub_10000BDF8((uint64_t)buf);
        sub_100057D78(&v53);
        sub_100057D78(&v63);
      }
      sub_100062778(&v55);
      if (SHIBYTE(v57) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_64;
    }
  }
}

void sub_1006879F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,const void *a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,const void *a41,const void *a42,__int16 a43,char a44,char a45,int a46,const void *a47,uint64_t a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  xpc_object_t v55 = v53;
  sub_100057D78(&a47);
  sub_100062778(&a26);
  if (a32 < 0) {
    operator delete(__p);
  }
  if ((v54 & 1) == 0) {
    sub_10004D2C8(v55);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  sub_100057D78(&a41);
  sub_100062778(&a42);
  _Unwind_Resume(a1);
}

void *sub_100687B24(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100687BA8(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100687C2C(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_100684D00(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_100687CB0(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100687D34(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 224))
  {
    sub_100057D78((const void **)(a1 + 208));
    sub_100057D78((const void **)(a1 + 200));
    sub_10000BDF8(a1);
  }
  return a1;
}

void *sub_100687D78(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100687DFC(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

const void **sub_100687E80(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void **sub_100687EB8(void **a1)
{
  int v2 = *a1;
  if (v2) {
    os_release(v2);
  }
  return a1;
}

uint64_t sub_100687EEC(uint64_t a1, int a2, uint64_t a3)
{
  *(_WORD *)a1 = *(_WORD *)a3;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a1 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)(a1 + 8) = v6;
  }
  xpc_object_t v7 = (unsigned char *)(a1 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_10004FC84(v7, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    long long v8 = *(_OWORD *)(a3 + 32);
    *(void *)(a1 + 48) = *(void *)(a3 + 48);
    *(_OWORD *)xpc_object_t v7 = v8;
  }
  *(_DWORD *)(a1 + 56) = a2;
  return a1;
}

void sub_100687F88(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100687FA4(char *a1, long long *a2, long long *a3)
{
  uint64_t v5 = sub_100029158(a1, a2) + 128;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    *((void *)v5 + 2) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100687FF8(_Unwind_Exception *a1)
{
  sub_10039A890(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10068800C(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 80));
  sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  sub_100057D78((const void **)(a1 + 40));
  sub_100057D78((const void **)(a1 + 32));
  sub_1000558F4((const void **)(a1 + 24));
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100688068(void *a1, long long *a2)
{
  uint64_t v4 = *a1;
  if (*(char *)(*a1 + 23) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  long long v6 = (const void **)a2 + 3;
  xpc_object_t v7 = (const void **)a1[1];
  if (v7 != (const void **)((char *)a2 + 24))
  {
    long long v8 = *v7;
    *xpc_object_t v7 = 0;
    unsigned int v12 = v8;
    *xpc_object_t v7 = *v6;
    *long long v6 = 0;
    sub_1000558F4(&v12);
  }
  uint64_t v9 = (const void **)(a2 + 2);
  uint64_t v10 = (const void **)a1[2];
  if (v10 != (const void **)(a2 + 2))
  {
    uint64_t v11 = *v10;
    unsigned __int8 *v10 = 0;
    unsigned int v12 = v11;
    unsigned __int8 *v10 = *v9;
    unsigned int *v9 = 0;
    sub_1000558F4(&v12);
  }
}

void sub_100688128(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    int v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_1006881C0(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 144;
        sub_100688128(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100688248(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100688280(uint64_t a1)
{
}

uint64_t sub_10068829C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1006882E0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10068830C(ServiceManager::Service *this)
{
  *(void *)this = off_1019F6FD0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100688368(ServiceManager::Service *this)
{
  *(void *)this = off_1019F6FD0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1006883D8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CarrierBundleHandler");
}

unsigned char *sub_1006883E8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100688428(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100671368(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100671368(v4, 0);
}

uint64_t sub_1006884AC()
{
  return 1;
}

uint64_t sub_1006884B4()
{
  return 1;
}

uint64_t sub_1006884BC()
{
  return 1;
}

void sub_1006884C4(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  long long v6 = *a3;
  dispatch_object_t v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_100671460(v4, v5, &v7);
  }
  sub_100671460(v4, v5, &v7);
}

void sub_100688574(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_100688650(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

void sub_100688764(ServiceManager::Service *this)
{
  *(void *)this = off_1019F6FD0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1006887C0(ServiceManager::Service *this)
{
  *(void *)this = off_1019F6FD0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100688830()
{
  return 0;
}

uint64_t sub_100688838()
{
  return 0;
}

void sub_100688848()
{
}

uint64_t sub_10068885C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100688868(const void **a1)
{
  if (a1)
  {
    sub_100688868(*a1);
    sub_100688868(a1[1]);
    sub_100057D78(a1 + 31);
    sub_100057D78(a1 + 30);
    sub_10000BDF8((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void sub_1006888D0(void *a1)
{
  if (a1)
  {
    sub_1006888D0(*a1);
    sub_1006888D0(a1[1]);
    uint64_t v2 = a1[5];
    if (v2)
    {
      uint64_t v3 = a1[6];
      uint64_t v4 = (void *)a1[5];
      if (v3 != v2)
      {
        do
        {
          v3 -= 136;
          sub_100674A2C(v3);
        }
        while (v3 != v2);
        uint64_t v4 = (void *)a1[5];
      }
      a1[6] = v2;
      operator delete(v4);
    }
    operator delete(a1);
  }
}

void sub_10068895C(char *a1)
{
  if (a1)
  {
    sub_10068895C(*(void *)a1);
    sub_10068895C(*((void *)a1 + 1));
    if (a1[72] && a1[71] < 0) {
      operator delete(*((void **)a1 + 6));
    }
    operator delete(a1);
  }
}

void sub_1006889C0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1006889C0(a1, *a2);
    sub_1006889C0(a1, a2[1]);
    sub_100688A1C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100688A1C(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 104));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

void sub_100688A7C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100688A7C(a1, *a2);
    sub_100688A7C(a1, a2[1]);
    sub_100688AD8((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100688AD8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v2 = (void **)(a1 + 104);
    sub_100047F64(&v2);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100688B38(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100688B38(a1, *a2);
    sub_100688B38(a1, a2[1]);
    sub_100688B94((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100688B94(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t *sub_100688BF4(void **a1)
{
  uint64_t v1 = *a1;
  long long v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 2056);
  xpc_object_t v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 440));
  for (uint64_t i = *(void *)(v2 + 72); i != v2 + 64; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 64));
  sub_100088C88((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100688D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
}

char *sub_100688D4C(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, void **a4)
{
  uint64_t v10 = 0;
  long long v6 = sub_100688E14((uint64_t)a1, &v10, a2);
  dispatch_object_t v7 = (char *)*v6;
  if (!*v6)
  {
    long long v8 = (uint64_t **)v6;
    dispatch_object_t v7 = (char *)operator new(0x108uLL);
    *((void *)v7 + 4) = **a4;
    *(_OWORD *)(v7 + 248) = 0u;
    *(_OWORD *)(v7 + 232) = 0u;
    *(_OWORD *)(v7 + 216) = 0u;
    *(_OWORD *)(v7 + 20sub_10010E764((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(v7 + 184) = 0u;
    *(_OWORD *)(v7 + 168) = 0u;
    *(_OWORD *)(v7 + 152) = 0u;
    *(_OWORD *)(v7 + 136) = 0u;
    *(_OWORD *)(v7 + 12sub_10010E764((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(v7 + 104) = 0u;
    *(_OWORD *)(v7 + 88) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *(_OWORD *)(v7 + 4sub_10010E764((uint64_t)&a9, 0) = 0u;
    sub_100046C38(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *sub_100688E14(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  xpc_object_t v5 = *(uint64_t **)(a1 + 8);
  __n128 result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unsigned int v6 = *a3;
    int v7 = *((_DWORD *)a3 + 1);
    while (1)
    {
      long long v8 = v4;
      unsigned int v9 = *((unsigned __int8 *)v4 + 32);
      if (v6 == v9)
      {
        int v10 = *((_DWORD *)v8 + 9);
        if (v7 >= v10)
        {
          BOOL v11 = v10 == v7;
          if (v10 >= v7) {
            char v12 = 1;
          }
          else {
            char v12 = -1;
          }
          if (v11) {
            char v12 = 0;
          }
          if ((v12 & 0x80) == 0) {
            goto LABEL_22;
          }
          goto LABEL_19;
        }
LABEL_13:
        uint64_t v4 = (uint64_t *)*v8;
        __n128 result = v8;
        if (!*v8) {
          goto LABEL_22;
        }
      }
      else
      {
        if (v6 < v9) {
          goto LABEL_13;
        }
        if (v9 >= v6) {
          char v13 = 1;
        }
        else {
          char v13 = -1;
        }
        if ((v13 & 0x80) == 0) {
          goto LABEL_22;
        }
LABEL_19:
        __n128 result = v8 + 1;
        uint64_t v4 = (uint64_t *)v8[1];
        if (!v4) {
          goto LABEL_22;
        }
      }
    }
  }
  long long v8 = result;
LABEL_22:
  *a2 = v8;
  return result;
}

void sub_100688E94(void **a1)
{
  uint64_t v1 = a1;
  sub_100688EF4(*a1);
}

void sub_100688ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100688EF4(void *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(NSObject **)(*a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 2056);
  xpc_object_t v5 = a1[1];
  dispatch_group_t group = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(group);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v4 + 16))(v4, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  CarrierBundleHandler::prepareBundleMetric((CarrierBundleHandler *)v2);
  sub_100058DB0(__p, "/cc/events/dump_state");
  unsigned int v6 = operator new(0x20uLL);
  *unsigned int v6 = off_1019F7078;
  v6[1] = v2;
  void v6[2] = sub_10067A6E8;
  void v6[3] = 0;
  *((void *)&v19 + 1) = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  aBlocuint64_t k = 0;
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  char v13 = sub_10068C938;
  long long v14 = &unk_1019F70E8;
  uint64_t v15 = v2 + 8;
  char v16 = sub_1006819F0;
  uint64_t v17 = 0;
  aBlocuint64_t k = _Block_copy(__p);
  sub_10003E168(&v10, (void *)(v2 + 8));
  sub_10068E0B4((dispatch_object_t *)&v8, &aBlock, *(dispatch_object_t *)(v2 + 24));
  sub_10068E0FC(buf, (NSObject **)&v8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 2, 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_10068BF90(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    STACK[0x208] = v2;
    sub_100163C60((void ***)&STACK[0x208]);
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_10068C804()
{
}

__n128 sub_10068C818(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = off_1019F7078;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10068C86C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7078;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10068C8A4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10068C8EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10068C92C()
{
}

void sub_10068C938(void *a1, uint64_t *a2)
{
  uint64_t v3 = (void (*)(void *, const void **))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v4 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    uint64_t v3 = *(void (**)(void *, const void **))(*v4 + v3);
  }
  memset(v5, 0, sizeof(v5));
  sub_10055D914(v5, *a2, a2[1], (a2[1] - *a2) >> 4);
  v3(v4, v5);
  unsigned int v6 = v5;
  sub_10055D640((void ***)&v6);
}

void sub_10068C9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10055D640((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068CA00(uint64_t a1)
{
  sub_10068EEB0((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_10068CA40(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10068CA84(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_10068CB7C(a1, v3);
}

void sub_10068CB4C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10068CB7C(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_10068CC74(a1, a2);
}

void sub_10068CC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_10068CC74(uint64_t *a1, void *a2)
{
}

void sub_10068CCE8()
{
}

uint64_t sub_10068CD0C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_10068CD50(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_10068CD94(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_10068D0B0(a1, a2, 1, 2);
}

void sub_10068CE90()
{
}

void sub_10068CEB4(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_10068D164(&v2, a2);
}

uint64_t sub_10068CF30(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_10068CF74(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  unint64_t v22 = *a4;
  xpc_object_t v10 = (uint64_t *)sub_10068CD0C(a1);
  uint64_t result = (uint64_t *)sub_10068E070(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_10068CD50(result + 2);
        sub_10068D798(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_10068CD50(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        char v16 = (uint64_t *)sub_10068CD0C(a1);
        uint64_t v17 = sub_10068E070(v16);
        uint64_t v18 = sub_10068CD50(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      unint64_t v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_10068CD0C(a1);
      unint64_t v20 = (uint64_t *)sub_10068E070(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_10068D0B0(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  unsigned int v9 = (uint64_t *)sub_10068CD0C(a1);
  uint64_t v10 = sub_10068E070(v9);
  BOOL v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_10068CD0C(a1);
    BOOL v11 = *(uint64_t **)(sub_10068E070(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_10068CF74(a1, a2, a3, &v14, a4);
}

void sub_10068D164(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068D1D0(&v2);
}

void sub_10068D1BC(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068D1D0(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068D240(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_10068D254(_Unwind_Exception *a1)
{
}

void sub_10068D26C()
{
}

uint64_t sub_10068D280(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10068D2E4()
{
  return 0;
}

uint64_t sub_10068D2EC()
{
  return 0;
}

uint64_t sub_10068D2F4()
{
  return 0;
}

void sub_10068D2FC()
{
}

void sub_10068D378()
{
}

uint64_t sub_10068D39C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10068D528((uint64_t *)a1, a2);
  sub_10068D594((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  unsigned int v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    int v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      void v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      BOOL v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          char v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          int v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      int v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_10068D500(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10068D528(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_10068D580(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10068D594(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10068D5E4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10068D5FC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068D668(&v2);
}

void sub_10068D654(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068D668(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068D6D8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_10068D6EC(_Unwind_Exception *a1)
{
}

void sub_10068D704()
{
}

uint64_t sub_10068D718(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10068D780()
{
  return 0;
}

uint64_t sub_10068D788()
{
  return 0;
}

uint64_t sub_10068D790()
{
  return 0;
}

uint64_t *sub_10068D798(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    unsigned int v6 = (uint64_t *)sub_10068D800(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_10068D800(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10068D844(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_1019F71D8;
  operator new();
}

void sub_10068D958(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_10068D9C0(uint64_t a1)
{
  sub_10068DD74(a1);

  operator delete();
}

BOOL sub_10068D9F8(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_10068DDE4((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_10068DAA8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10068DAD8(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10068DB04(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_10068DB30@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_10068DB8C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068DBF8(&v2);
}

void sub_10068DBE4(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068DBF8(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068DC68(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10068DC90(v1);
  __cxa_rethrow();
}

void sub_10068DC7C(_Unwind_Exception *a1)
{
}

uint64_t sub_10068DC90(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_10068EEB0((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_10068DCF0()
{
}

uint64_t sub_10068DD04(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10068EEB0((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_10068DD5C()
{
  return 0;
}

uint64_t sub_10068DD64()
{
  return 0;
}

uint64_t sub_10068DD6C()
{
  return 0;
}

uint64_t sub_10068DD74(uint64_t a1)
{
  *(void *)a1 = off_1019F71D8;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_10068DDE4(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_10068D800((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_10068D800(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_10068DEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10068DEE8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068DF54(&v2);
}

void sub_10068DF40(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068DF54(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068DFC4(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_10068DFFC(_Unwind_Exception *a1)
{
}

void sub_10068E014()
{
}

uint64_t sub_10068E028(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10068E058()
{
  return 0;
}

uint64_t sub_10068E060()
{
  return 0;
}

uint64_t sub_10068E068()
{
  return 0;
}

uint64_t sub_10068E070(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

dispatch_object_t *sub_10068E0B4(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    xpc_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_10068E0FC(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_10068E154((uint64_t)a1, a2);
  return a1;
}

void sub_10068E134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_10068EEB0((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10068E154(uint64_t a1, NSObject **a2)
{
  sub_10068E230(v4, a2);
  sub_10068E1AC((uint64_t *)(a1 + 24), v4);
  return sub_10068F234((uint64_t)v4);
}

void sub_10068E198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_10068E1AC(uint64_t *a1, NSObject **a2)
{
  sub_10068E230(v4, a2);
  sub_10068E2F8(v5, v4);
  sub_10068E27C(v5, a1);
  sub_10068EEB0(v5);
  sub_10068F234((uint64_t)v4);
  return a1;
}

void sub_10068E20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_10068E230(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_10068E27C(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_10068EDF0((uint64_t)v4, result);
    sub_10068EDF0(v3, a2);
    sub_10068EDF0((uint64_t)a2, (uint64_t *)v4);
    return sub_10068EEB0((uint64_t *)v4);
  }
  return result;
}

void sub_10068E2E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10068E2F8(void *a1, NSObject **a2)
{
  sub_10068E230(v4, a2);
  sub_10068E358(a1, v4);
  sub_10068F234((uint64_t)v4);
  return a1;
}

void sub_10068E344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10068E358(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_10068E230(v4, a2);
  sub_10068E3B8((uint64_t)a1, v4);
  sub_10068F234((uint64_t)v4);
  return a1;
}

void sub_10068E3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10068E3B8(uint64_t a1, NSObject **a2)
{
  sub_10068E230(v6, a2);
  int v3 = sub_10068E57C((uint64_t)off_1019F72E0, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_10068F234((uint64_t)v6);
  if (v3) {
    long long v5 = off_1019F72E0;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_10068E420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10068E434(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10068E230((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_10068F234(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvNSt3__16vectorINS3_4pairINS_2"
                                    "cf11CFSharedRefIKvEE18BundleUpdateResultEENS3_9allocatorISB_EEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvNSt3__16vectorINS3_4pairINS_2cf11CFSharedRefIKvEE18BundleUpdateResultEENS3_9allocatorISB_EEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_10068E50C(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  uint64_t v3 = *((void *)a2 + 2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  sub_10068E5E4(a1, (uint64_t *)&v2);
}

void sub_10068E560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10055D640(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10068E57C(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_10068E230(v7, a2);
  uint64_t v5 = sub_10068EDA8(a1, v7, a3);
  sub_10068F234((uint64_t)v7);
  return v5;
}

void sub_10068E5D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10068E5E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_10068E9C0(v6, &aBlock);
  memset(v4, 0, sizeof(v4));
  sub_10055D914(v4, *a2, a2[1], (a2[1] - *a2) >> 4);
  sub_10068E6C4();
}

void sub_10068E684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *aBlock, uint64_t a14)
{
  *(void *)(v15 - 24) = v14;
  sub_10055D640((void ***)(v15 - 24));
  sub_10068EEB0(&a14);
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(a1);
}

void sub_10068E6C4()
{
}

void sub_10068E7E0()
{
}

uint64_t *sub_10068E820(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  long long v2 = *(uint64_t **)(a1 + 40);
  uint64_t v7 = 0;
  long long v6 = 0uLL;
  sub_10055D914((const void **)&v6, *v2, v2[1], (v2[1] - *v2) >> 4);
  sub_10068E8F0(v3, &v6);
  uint64_t v8 = (void **)&v6;
  sub_10055D640(&v8);
  uint64_t result = *(uint64_t **)(a1 + 32);
  if (result)
  {
    sub_10068EEB0(result);
    operator delete();
  }
  uint64_t v5 = *(void ***)(a1 + 40);
  if (v5)
  {
    uint64_t v8 = v5;
    sub_10055D640(&v8);
    operator delete();
  }
  return result;
}

void sub_10068E8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10055D640((void ***)va);
  _Unwind_Resume(a1);
}

void sub_10068E8F0(void *a1, long long *a2)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v5, "call to empty boost::function");
    v5.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v5);
  }
  long long v2 = *(void (**)(void *, long long *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  long long v3 = *a2;
  uint64_t v4 = *((void *)a2 + 2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  v2(a1 + 1, &v3);
  v5.__vftable = (std::runtime_error_vtbl *)&v3;
  sub_10055D640((void ***)&v5);
}

void sub_10068E994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
  a13.__vftable = (std::runtime_error_vtbl *)&a9;
  sub_10055D640((void ***)&a13);
  _Unwind_Resume(a1);
}

void *sub_10068E9C0(void *a1, void **a2)
{
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_10068EA3C(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_10068EA20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10068EA3C(void *a1, void **a2)
{
  *a1 = 0;
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  sub_10068EAB8((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_10068EA9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_10068EAB8(uint64_t a1, void **a2)
{
  long long v3 = *a2;
  if (*a2) {
    long long v3 = _Block_copy(v3);
  }
  aBlocuint64_t k = v3;
  int v4 = sub_10068EB74((uint64_t)off_1019F7320, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    std::runtime_error v5 = off_1019F7320;
  }
  else {
    std::runtime_error v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_10068EB34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_10068EB50(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_10068EBF8(a1, a2, a3);
  }
}

uint64_t sub_10068EB74(uint64_t a1, void **a2, void **a3)
{
  std::runtime_error v5 = *a2;
  if (*a2) {
    std::runtime_error v5 = _Block_copy(v5);
  }
  aBlocuint64_t k = v5;
  uint64_t v6 = sub_10068ED48(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_10068EBDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_10068EBF8(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvNSt3__16vectorINS1_4pairIN3ctu2cf11"
                                                  "CFSharedRefIKvEE18BundleUpdateResultEENS1_9allocatorISA_EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvNSt3__16vectorINS1_4pairIN3ctu2cf11CFSharedRefIKvEE18BundleUpdateResultEENS1_9allocatorISA_EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

void sub_10068ECCC(uint64_t *a1, long long *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  long long v4 = *a2;
  uint64_t v5 = *((void *)a2 + 2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  (*(void (**)(uint64_t, long long *, uint64_t))(v3 + 16))(v3, &v4, a3);
  uint64_t v6 = (void **)&v4;
  sub_10055D640(&v6);
}

void sub_10068ED2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10055D640(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10068ED48(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (long long v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_10068EDA8(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_10068E230(v5, a2);
  sub_10068E230(a3, v5);
  sub_10068F234((uint64_t)v5);
  return 1;
}

uint64_t sub_10068EDF0(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    long long v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      long long v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_10068EE8C(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_10068EE9C(_Unwind_Exception *a1)
{
}

uint64_t *sub_10068EEB0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_10068EF04(void *a1)
{
  *a1 = off_1019F7350;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10068EF50(void *a1)
{
  *a1 = off_1019F7350;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_10068EFBC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_10068F06C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10068F084(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_10068F0A4()
{
}

void *sub_10068F110(void *a1)
{
  *a1 = off_1019F73A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10068F15C(void *a1)
{
  *a1 = off_1019F73A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_10068F1C8()
{
}

uint64_t sub_10068F234(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_10068F270(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, unsigned char *))a1[5];
  uint64_t v4 = a1[6];
  uint64_t v6 = (void *)(a1[4] + (v4 >> 1) - 8);
  if (v4) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, unsigned char *))(*v6 + v5);
  }
  sub_1003DABB4(v8, a3);
  uint64_t result = v5(v6, a2, v8);
  if (v8[216]) {
    return sub_1000C584C((uint64_t)v8);
  }
  return result;
}

void sub_10068F348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a37) {
    sub_1000C584C((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10068F36C(uint64_t a1)
{
  sub_100690C98((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_10068F3AC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_10068F3F0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_10068F434(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

void sub_10068F478(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_10068F728(&v2, a2);
}

uint64_t sub_10068F4F4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_10068F538(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  unint64_t v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_10068F3F0(a1);
  uint64_t result = (uint64_t *)sub_100690228(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_10068F434(result + 2);
        sub_10068FD5C(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_10068F434(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        char v16 = (uint64_t *)sub_10068F3F0(a1);
        uint64_t v17 = sub_100690228(v16);
        uint64_t v18 = sub_10068F434(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      unint64_t v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_10068F3F0(a1);
      unint64_t v20 = (uint64_t *)sub_100690228(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_10068F674(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_10068F3F0(a1);
  uint64_t v10 = sub_100690228(v9);
  BOOL v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_10068F3F0(a1);
    BOOL v11 = *(uint64_t **)(sub_100690228(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_10068F538(a1, a2, a3, &v14, a4);
}

void sub_10068F728(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068F794(&v2);
}

void sub_10068F780(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068F794(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068F804(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_10068F818(_Unwind_Exception *a1)
{
}

void sub_10068F830()
{
}

uint64_t sub_10068F844(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10068F8A8()
{
  return 0;
}

uint64_t sub_10068F8B0()
{
  return 0;
}

uint64_t sub_10068F8B8()
{
  return 0;
}

void sub_10068F8C0()
{
}

void sub_10068F93C()
{
}

uint64_t sub_10068F960(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10068FAEC((uint64_t *)a1, a2);
  sub_10068FB58((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    long long v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      void v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      BOOL v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          char v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          long long v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      long long v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_10068FAC4(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10068FAEC(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_10068FB44(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10068FB58(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10068FBA8(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10068FBC0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10068FC2C(&v2);
}

void sub_10068FC18(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10068FC2C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10068FC9C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_10068FCB0(_Unwind_Exception *a1)
{
}

void sub_10068FCC8()
{
}

uint64_t sub_10068FCDC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10068FD44()
{
  return 0;
}

uint64_t sub_10068FD4C()
{
  return 0;
}

uint64_t sub_10068FD54()
{
  return 0;
}

uint64_t *sub_10068FD5C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_10068FDC4(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_10068FDC4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10068FE0C(uint64_t a1)
{
  sub_100690158(a1);

  operator delete();
}

BOOL sub_10068FE44(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_10068FDC4((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_10068FDC4((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_10068FF7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068FFC0(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_10068FFEC(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100690018@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_100690074(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100690C98((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_1006900D4()
{
}

uint64_t sub_1006900E8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100690C98((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100690140()
{
  return 0;
}

uint64_t sub_100690148()
{
  return 0;
}

uint64_t sub_100690150()
{
  return 0;
}

uint64_t sub_100690158(uint64_t a1)
{
  *(void *)a1 = off_1019F74C0;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1006901CC()
{
}

uint64_t sub_1006901E0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100690210()
{
  return 0;
}

uint64_t sub_100690218()
{
  return 0;
}

uint64_t sub_100690220()
{
  return 0;
}

uint64_t sub_100690228(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

NSObject **sub_10069026C(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_1006902BC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_10069026C((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100690CEC(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENSt3__1"
                                    "8optionalI19VinylProfileDetailsEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENSt3__18optionalI19VinylProfileDetailsEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100690394(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100690AC0(v18, a3);
  uint64_t v4 = *(const void **)(a1 + 8);
  if (v4 && (uint64_t v5 = _Block_copy(v4)) != 0 && (v6 = _Block_copy(v5), (v7 = v6) != 0))
  {
    uint64_t v8 = _Block_copy(v6);
    uint64_t v9 = v8;
    if (v8)
    {
      uint64_t v10 = _Block_copy(v8);
      BOOL v11 = v10;
      if (v10)
      {
        unsigned int v12 = _Block_copy(v10);
        unsigned int v13 = v12;
        if (v12)
        {
          BOOL v14 = _Block_copy(v12);
          uint64_t v15 = v14;
          if (v14)
          {
            *(void *)&long long v17 = _Block_copy(v14);
            _Block_release(v15);
          }
          else
          {
            *(void *)&long long v17 = 0;
          }
          _Block_release(v13);
        }
        else
        {
          *(void *)&long long v17 = 0;
        }
        _Block_release(v11);
      }
      else
      {
        *(void *)&long long v17 = 0;
      }
      char v16 = off_1019F7608;
      _Block_release(v9);
    }
    else
    {
      char v16 = off_1019F7608;
      *(void *)&long long v17 = 0;
    }
    _Block_release(v7);
  }
  else
  {
    char v16 = off_1019F7608;
    *(void *)&long long v17 = 0;
  }
  sub_1003DABB4(v19, (uint64_t)v18);
  operator new();
}

void sub_100690644(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100690710(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = **(unsigned int **)(a1 + 40);
  sub_1003DABB4(v6, *(void *)(a1 + 48));
  sub_100690828(v2, v3, (uint64_t)v6);
  if (v6[216]) {
    sub_1000C584C((uint64_t)v6);
  }
  uint64_t v4 = *(uint64_t **)(a1 + 32);
  if (v4)
  {
    sub_100690C98(v4);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    if (*(unsigned char *)(result + 216)) {
      sub_1000C584C(result);
    }
    operator delete();
  }
  return result;
}

void sub_100690804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a37) {
    sub_1000C584C((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100690828(void *a1, uint64_t a2, uint64_t a3)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v7, "call to empty boost::function");
    v7.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v7);
  }
  uint64_t v4 = *(uint64_t (**)(void *, uint64_t, unsigned char *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v5 = a1 + 1;
  sub_100690AC0(v8, a3);
  uint64_t result = v4(v5, a2, v8);
  if (v8[216]) {
    return sub_1000C584C((uint64_t)v8);
  }
  return result;
}

void sub_100690900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::runtime_error a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void sub_100690934(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENSt3__18optio"
                                                  "nalI19VinylProfileDetailsEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotENSt3__18optionalI19VinylProfileDetailsEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      std::runtime_error v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      std::runtime_error v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100690A10(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  sub_100690AC0(v6, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(v4 + 16))(v4, a2, v6);
  if (v6[216]) {
    return sub_1000C584C((uint64_t)v6);
  }
  return result;
}

void sub_100690AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a37) {
    sub_1000C584C((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100690AC0(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[216] = 0;
  sub_100690AF4((uint64_t)a1, a2);
  return a1;
}

__n128 sub_100690AF4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 216))
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
    long long v2 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v2;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    long long v3 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 4sub_10010E764((uint64_t)&a9, 0) = v3;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 4sub_10010E764((uint64_t)&a9, 0) = 0;
    long long v4 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 8sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v4;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 8sub_10010E764((uint64_t)&a9, 0) = 0;
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
    long long v5 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v5;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 96) = 0;
    long long v6 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 12sub_10010E764((uint64_t)&a9, 0) = v6;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 12sub_10010E764((uint64_t)&a9, 0) = 0;
    long long v7 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 16sub_10010E764((uint64_t)&a9, 0) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v7;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 16sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)(a2 + 144) = 0;
    long long v8 = *(_OWORD *)(a2 + 168);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = v8;
    *(void *)(a2 + 168) = 0;
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    __n128 result = *(__n128 *)(a2 + 192);
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(__n128 *)(a1 + 192) = result;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 20sub_10010E764((uint64_t)&a9, 0) = 0;
    *(void *)(a2 + 208) = 0;
    *(unsigned char *)(a1 + 216) = 1;
  }
  return result;
}

uint64_t sub_100690BD8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    long long v2 = a2;
    long long v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)__n128 result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        __n128 result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        long long v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          __n128 result = v6(result + 8, result + 8, 2);
        }
      }
      long long v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_100690C74(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_100690C84(_Unwind_Exception *a1)
{
}

uint64_t *sub_100690C98(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      long long v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100690CEC(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100690D2C()
{
}

void *sub_100690D40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F7638;
  result[1] = v3;
  return result;
}

uint64_t sub_100690D88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F7638;
  a2[1] = v2;
  return result;
}

void sub_100690DB4(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_100690EEC(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100690E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100690EA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100690EE0()
{
}

void sub_100690EEC(xpc_object_t *a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  long long v8 = (void *)*a2;
  xpc_object_t v6 = a2 + 1;
  long long v7 = v8;
  if (v8 != v6)
  {
    do
    {
      xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v10 = v9;
      if (v9)
      {
        xpc_object_t v25 = v9;
      }
      else
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v25 = v10;
        if (!v10)
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t v10 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v11 = xpc_null_create();
LABEL_15:
        xpc_object_t v25 = v11;
        goto LABEL_16;
      }
      xpc_retain(v10);
LABEL_16:
      xpc_release(v10);
      int v12 = *((_DWORD *)v7 + 8);
      uint64_t v13 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v23, (ctu::rest::detail *)v12, v13, v14);
      int v21 = &v25;
      unint64_t v22 = "first";
      sub_100035E70((uint64_t)&v21, &v23, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      rest::write_rest_value();
      int v21 = &v25;
      unint64_t v22 = "second";
      sub_100035E70((uint64_t)&v21, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v15 = v25;
      if (v25) {
        xpc_retain(v25);
      }
      else {
        xpc_object_t v15 = xpc_null_create();
      }
      xpc_release(v25);
      xpc_array_append_value(v5, v15);
      xpc_release(v15);
      char v16 = (void *)v7[1];
      if (v16)
      {
        do
        {
          long long v17 = v16;
          char v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          long long v17 = (void *)v7[2];
          BOOL v18 = *v17 == (void)v7;
          long long v7 = v17;
        }
        while (!v18);
      }
      long long v7 = v17;
    }
    while (v17 != v6);
  }
  *a1 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100691164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void *sub_1006911C0(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        uint64_t v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        uint64_t v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        uint64_t v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      uint64_t v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100691428(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100691438()
{
}

void *sub_10069144C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F76C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100691494(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F76C8;
  a2[1] = v2;
  return result;
}

void sub_1006914C0(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_100690EEC(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/operator_bundles");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100691564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1006915AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006915EC()
{
}

void sub_1006915FC()
{
}

void *sub_100691610(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019F7748;
  result[1] = v3;
  return result;
}

uint64_t sub_100691658(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019F7748;
  a2[1] = v2;
  return result;
}

void sub_100691684(uint64_t a1, char *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/default_bundle");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100691738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10069177C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006917BC()
{
}

void sub_1006917CC()
{
}

__n128 sub_1006917E0(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_1019F77D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100691834(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F77D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10069186C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1006918AC()
{
}

void sub_1006918BC()
{
}

__n128 sub_1006918D0(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_1019F7858;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100691924(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F7858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10069195C(void *a1, const xpc::object *a2)
{
  uint64_t v4 = (const RegisteredNetworkInfo *)a1[1];
  bzero(v9, 0x320uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)v9, v4);
  read_rest_value(v4, a2);
  char v5 = (void (*)(void *, unsigned char *))a1[3];
  uint64_t v6 = a1[4];
  long long v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    char v5 = *(void (**)(void *, unsigned char *))(*v7 + v5);
  }
  v5(v7, v9);
  if (v18 && v17 < 0) {
    operator delete(__p);
  }
  sub_10002B2D8((uint64_t)&v15);
  sub_10002B28C((uint64_t)&v14);
  sub_10002B1F4((uint64_t)&v13);
  sub_10002B1A8((uint64_t)&v12);
  sub_10002B1A8((uint64_t)&v11);
  return sub_10002B240((uint64_t)&v10);
}

void sub_100691A7C(_Unwind_Exception *a1)
{
}

uint64_t sub_100691ADC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100691B1C()
{
}

void sub_100691B2C()
{
}

__n128 sub_100691B40(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_1019F78D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100691B94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019F78D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100691BCC(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100691CC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100691D04()
{
}

void sub_100691D14()
{
}

__n128 sub_100691D28(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_1019F7958;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}