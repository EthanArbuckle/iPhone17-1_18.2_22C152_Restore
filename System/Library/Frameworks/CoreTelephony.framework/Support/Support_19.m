void sub_100A71CDC(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;

  v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Phone Book Capabilities", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Primary:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 44);
    v17 = 67109120;
    v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfPbType: %d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(unsigned __int16 *)(a1 + 48);
    v17 = 67109120;
    v18 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfUsedRecords:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(unsigned __int16 *)(a1 + 50);
    v17 = 67109120;
    v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxRecords:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(unsigned __int8 *)(a1 + 52);
    v17 = 67109120;
    v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxNumLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(unsigned __int8 *)(a1 + 53);
    v17 = 67109120;
    v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxNameLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Groups:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(unsigned __int8 *)(a1 + 56);
    v17 = 67109120;
    v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxGroups:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(unsigned __int8 *)(a1 + 57);
    v17 = 67109120;
    v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxGroupNameLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I AdditionaNumber:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(unsigned __int8 *)(a1 + 58);
    v17 = 67109120;
    v18 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxAddNumbers:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(unsigned __int8 *)(a1 + 59);
    v17 = 67109120;
    v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxAddNumLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(unsigned __int8 *)(a1 + 60);
    v17 = 67109120;
    v18 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxNameLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Email:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(unsigned __int8 *)(a1 + 61);
    v17 = 67109120;
    v18 = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxEmailsPossible:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(unsigned __int8 *)(a1 + 62);
    v17 = 67109120;
    v18 = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxEmailLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SecondName:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *(unsigned __int8 *)(a1 + 63);
    v17 = 67109120;
    v18 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tfMaxSecondNameLength:%d", (uint8_t *)&v17, 8u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I HiddenRecords:", (uint8_t *)&v17, 2u);
    v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v16 = *(unsigned __int8 *)(a1 + 64);
    v17 = 67109120;
    v18 = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I \t\tisHiddenRecordSupported:%d", (uint8_t *)&v17, 8u);
  }
}

void sub_100A722D0(uint64_t a1, char a2)
{
  v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v25.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Resetting the Phone Book Model", (uint8_t *)&v25, 2u);
  }
  *(void *)(a1 + 36) = 0x600000006;
  memset(&v25, 0, 24);
  PBCapabilities::PrimaryNumber::PrimaryNumber((PBCapabilities::PrimaryNumber *)&v25);
  PBCapabilities::Groups::Groups((PBCapabilities::Groups *)((char *)&v25.var2.__r_.__value_.var0.var1.__data_ + 4));
  PBCapabilities::AdditionaNumber::AdditionaNumber((PBCapabilities::AdditionaNumber *)((char *)&v25.var2.__r_.__value_.var0.var1.__data_
                                                                                     + 6));
  PBCapabilities::Email::Email((PBCapabilities::Email *)((char *)&v25.var2.__r_.__value_.var0.var1.__size_ + 1));
  PBCapabilities::SecondName::SecondName((PBCapabilities::SecondName *)((char *)&v25.var2.__r_.__value_.var0.var1.__size_
                                                                      + 3));
  PBCapabilities::HiddenRecords::HiddenRecords((PBCapabilities::HiddenRecords *)((char *)&v25.var2.__r_.__value_.var0.var1.__size_
                                                                               + 4));
  *(_OWORD *)(a1 + 44) = *(_OWORD *)&v25.var0;
  *(void *)(a1 + 57) = *(char **)((char *)&v25.var2.__r_.__value_.var0.var1.__data_ + 5);
  sub_100A72A70(*(void **)(a1 + 80));
  *(void *)(a1 + 72) = a1 + 80;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_1002AE1CC((uint64_t)&v25);
  sub_100A71020(a1 + 96, (uint64_t)&v25);
  sub_100039D40((uint64_t)&v25);
  *(_WORD *)(a1 + 480) = 0;
  *(unsigned char *)(a1 + 896) = 1;
  if ((a2 & 1) == 0)
  {
    CSIPhoneNumber::CSIPhoneNumber(&v25);
    *(void *)(a1 + 488) = *(void *)&v25.var0;
    v5 = (void **)(a1 + 496);
    if (*(char *)(a1 + 519) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)v5 = *(_OWORD *)v25.var2.__r_.__value_.var0.var0.__data_;
    *(void *)(a1 + 512) = *((void *)&v25.var2.__r_.__value_.var0.var1 + 2);
    *((unsigned char *)&v25.var2.__r_.__value_.var0.var1 + 23) = 0;
    v25.var2.__r_.__value_.var0.var0.__data_[0] = 0;
    v6 = (void **)(a1 + 520);
    if (*(char *)(a1 + 543) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)v6 = *(_OWORD *)&v25.var2.__r_.var0;
    *(void *)(a1 + 536) = v26;
    HIBYTE(v26) = 0;
    LOBYTE(v25.var2.__r_.var0) = 0;
    *(_DWORD *)(a1 + 544) = v27;
    *(unsigned char *)(a1 + 548) = v28;
    v7 = (void **)(a1 + 552);
    if (*(char *)(a1 + 575) < 0) {
      operator delete(*v7);
    }
    char v8 = 0;
    *(_OWORD *)v7 = __p;
    *(void *)(a1 + 568) = v30;
    HIBYTE(v30) = 0;
    LOBYTE(__p) = 0;
    v9 = (void **)(a1 + 576);
    if (*(char *)(a1 + 599) < 0)
    {
      operator delete(*v9);
      char v8 = HIBYTE(v30);
    }
    *(_OWORD *)v9 = v31;
    *(void *)(a1 + 592) = v32;
    HIBYTE(v32) = 0;
    LOBYTE(v31) = 0;
    *(unsigned char *)(a1 + 616) = v34;
    *(_OWORD *)(a1 + 600) = v33;
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v26) < 0) {
      operator delete(*(void **)&v25.var2.__r_.var0);
    }
    if (*((char *)&v25.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(v25.var2.__r_.__value_.var0.var1.__data_);
    }
    CSIPhoneNumber::CSIPhoneNumber(&v25);
    *(void *)(a1 + 624) = *(void *)&v25.var0;
    v10 = (void **)(a1 + 632);
    if (*(char *)(a1 + 655) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)v10 = *(_OWORD *)v25.var2.__r_.__value_.var0.var0.__data_;
    *(void *)(a1 + 648) = *((void *)&v25.var2.__r_.__value_.var0.var1 + 2);
    *((unsigned char *)&v25.var2.__r_.__value_.var0.var1 + 23) = 0;
    v25.var2.__r_.__value_.var0.var0.__data_[0] = 0;
    v11 = (void **)(a1 + 656);
    if (*(char *)(a1 + 679) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)v11 = *(_OWORD *)&v25.var2.__r_.var0;
    *(void *)(a1 + 672) = v26;
    HIBYTE(v26) = 0;
    LOBYTE(v25.var2.__r_.var0) = 0;
    *(_DWORD *)(a1 + 680) = v27;
    *(unsigned char *)(a1 + 684) = v28;
    v12 = (void **)(a1 + 688);
    if (*(char *)(a1 + 711) < 0) {
      operator delete(*v12);
    }
    char v13 = 0;
    *(_OWORD *)v12 = __p;
    *(void *)(a1 + 704) = v30;
    HIBYTE(v30) = 0;
    LOBYTE(__p) = 0;
    v14 = (void **)(a1 + 712);
    if (*(char *)(a1 + 735) < 0)
    {
      operator delete(*v14);
      char v13 = HIBYTE(v30);
    }
    *(_OWORD *)v14 = v31;
    *(void *)(a1 + 728) = v32;
    HIBYTE(v32) = 0;
    LOBYTE(v31) = 0;
    *(_OWORD *)(a1 + 736) = v33;
    *(unsigned char *)(a1 + 752) = v34;
    if (v13 < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v26) < 0) {
      operator delete(*(void **)&v25.var2.__r_.var0);
    }
    if (*((char *)&v25.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(v25.var2.__r_.__value_.var0.var1.__data_);
    }
    CSIPhoneNumber::CSIPhoneNumber(&v25);
    *(void *)(a1 + 760) = *(void *)&v25.var0;
    v15 = (void **)(a1 + 768);
    if (*(char *)(a1 + 791) < 0) {
      operator delete(*v15);
    }
    *(_OWORD *)v15 = *(_OWORD *)v25.var2.__r_.__value_.var0.var0.__data_;
    *(void *)(a1 + 784) = *((void *)&v25.var2.__r_.__value_.var0.var1 + 2);
    *((unsigned char *)&v25.var2.__r_.__value_.var0.var1 + 23) = 0;
    v25.var2.__r_.__value_.var0.var0.__data_[0] = 0;
    v16 = (void **)(a1 + 792);
    if (*(char *)(a1 + 815) < 0) {
      operator delete(*v16);
    }
    *(_OWORD *)v16 = *(_OWORD *)&v25.var2.__r_.var0;
    *(void *)(a1 + 808) = v26;
    HIBYTE(v26) = 0;
    LOBYTE(v25.var2.__r_.var0) = 0;
    *(_DWORD *)(a1 + 816) = v27;
    *(unsigned char *)(a1 + 820) = v28;
    v17 = (void **)(a1 + 824);
    if (*(char *)(a1 + 847) < 0) {
      operator delete(*v17);
    }
    *(_OWORD *)v17 = __p;
    *(void *)(a1 + 840) = v30;
    HIBYTE(v30) = 0;
    LOBYTE(__p) = 0;
    v18 = (_OWORD *)(a1 + 848);
    if (*(char *)(a1 + 871) < 0)
    {
      operator delete(*(void **)(a1 + 848));
      int v19 = SHIBYTE(v30);
      _OWORD *v18 = v31;
      *(void *)(a1 + 864) = v32;
      HIBYTE(v32) = 0;
      LOBYTE(v31) = 0;
      *(_OWORD *)(a1 + 872) = v33;
      *(unsigned char *)(a1 + 888) = v34;
      if (v19 < 0) {
        operator delete((void *)__p);
      }
    }
    else
    {
      _OWORD *v18 = v31;
      *(void *)(a1 + 864) = v32;
      HIBYTE(v32) = 0;
      LOBYTE(v31) = 0;
      *(unsigned char *)(a1 + 888) = v34;
      *(_OWORD *)(a1 + 872) = v33;
    }
    if (SHIBYTE(v26) < 0) {
      operator delete(*(void **)&v25.var2.__r_.var0);
    }
    if (*((char *)&v25.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(v25.var2.__r_.__value_.var0.var1.__data_);
    }
  }
  CSIPhoneNumber::CSIPhoneNumber(&v25);
  *(void *)(a1 + 904) = *(void *)&v25.var0;
  v20 = (void **)(a1 + 912);
  if (*(char *)(a1 + 935) < 0) {
    operator delete(*v20);
  }
  *(_OWORD *)v20 = *(_OWORD *)v25.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a1 + 928) = *((void *)&v25.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v25.var2.__r_.__value_.var0.var1 + 23) = 0;
  v25.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  v21 = (void **)(a1 + 936);
  if (*(char *)(a1 + 959) < 0) {
    operator delete(*v21);
  }
  *(_OWORD *)v21 = *(_OWORD *)&v25.var2.__r_.var0;
  *(void *)(a1 + 952) = v26;
  HIBYTE(v26) = 0;
  LOBYTE(v25.var2.__r_.var0) = 0;
  *(_DWORD *)(a1 + 960) = v27;
  *(unsigned char *)(a1 + 964) = v28;
  v22 = (void **)(a1 + 968);
  if (*(char *)(a1 + 991) < 0) {
    operator delete(*v22);
  }
  *(_OWORD *)v22 = __p;
  *(void *)(a1 + 984) = v30;
  HIBYTE(v30) = 0;
  LOBYTE(__p) = 0;
  v23 = (_OWORD *)(a1 + 992);
  if (*(char *)(a1 + 1015) < 0)
  {
    operator delete(*(void **)(a1 + 992));
    int v24 = SHIBYTE(v30);
    _OWORD *v23 = v31;
    *(void *)(a1 + 1008) = v32;
    HIBYTE(v32) = 0;
    LOBYTE(v31) = 0;
    *(_OWORD *)(a1 + 1016) = v33;
    *(unsigned char *)(a1 + 1032) = v34;
    if (v24 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    _OWORD *v23 = v31;
    *(void *)(a1 + 1008) = v32;
    HIBYTE(v32) = 0;
    LOBYTE(v31) = 0;
    *(unsigned char *)(a1 + 1032) = v34;
    *(_OWORD *)(a1 + 1016) = v33;
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(*(void **)&v25.var2.__r_.var0);
  }
  if (*((char *)&v25.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v25.var2.__r_.__value_.var0.var1.__data_);
  }
  sub_10005D144(*(void **)(a1 + 1048));
  *(void *)(a1 + 1040) = a1 + 1048;
  *(void *)(a1 + 1056) = 0;
  *(void *)(a1 + 1048) = 0;
}

void sub_100A728F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100A72908(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A72988(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A729C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A729FC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A72A2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A72A70(void *a1)
{
  if (a1)
  {
    sub_100A72A70(*a1);
    sub_100A72A70(a1[1]);
    sub_100039D40((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void sub_100A72AC4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100039D40((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

uint64_t sub_100A72B1C()
{
  v0 = [(objc_class *)off_101B0B068() sharedInstance];
  if (v0)
  {
    uint64_t v1 = v0;
    BOOL v2 = [v0 getPowerMode] == (id)1;

    int v3 = 1;
  }
  else
  {
    BOOL v2 = 0;
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

void sub_100A72B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A72B88(unsigned int a1, uint64_t a2)
{
  v4 = (std::__shared_weak_count *)operator new(0x38uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3388;
  sub_100023950((uint64_t)&v4[1], a2);
  v5 = [(objc_class *)off_101B0B068() sharedInstance];
  v6 = v5;
  if (v5)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3321888768;
    v7[2] = sub_100A72CC4;
    v7[3] = &unk_101A33350;
    v7[4] = v4 + 1;
    char v8 = v4;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    [v5 setPowerMode:a1 fromSource:@"com.apple.CommCenter" withCompletion:v7];
    if (v8) {
      sub_10004D2C8(v8);
    }
  }

  sub_10004D2C8(v4);
}

void sub_100A72C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }

  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100A72CC4(uint64_t a1, char a2)
{
  return sub_1000607A8(*(void *)(a1 + 32), a2);
}

uint64_t sub_100A72CCC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A72CE8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

Class sub_100A72CF8()
{
  if (qword_101B0FD10 != -1) {
    dispatch_once(&qword_101B0FD10, &stru_101A33380);
  }
  Class result = objc_getClass("_PMLowPowerMode");
  qword_101B0FD08 = (uint64_t)result;
  off_101B0B068 = (uint64_t (*)())sub_100A72D5C;
  return result;
}

id sub_100A72D5C()
{
  return (id)qword_101B0FD08;
}

void sub_100A72D68(id a1)
{
  qword_101B0FD00 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/LowPowerMode.framework/LowPowerMode", 2);
}

void ServiceMonitor::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A7309C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100A731E4(uint64_t a1)
{
  *(void *)a1 = off_101A333B0;
  uint64_t v2 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  v6 = (void **)(a1 + 112);
  sub_10008A88C(&v6);
  sub_1000346F8(a1 + 88, *(void **)(a1 + 96));
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A732A8(uint64_t a1)
{
  sub_100A731E4(a1);

  operator delete();
}

void sub_100A732E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100A733C0(uint64_t result)
{
  if (*(unsigned char *)(result + 80))
  {
    uint64_t v1 = result;
    Class result = *(void *)(result + 144);
    if (result)
    {
      *(void *)(v1 + 144) = 0;
      return (*(uint64_t (**)(void))(*(void *)result + 8))();
    }
  }
  return result;
}

void sub_100A73400(uint64_t a1)
{
  if ((operator==() & 1) == 0)
  {
    sub_100A73454(a1);
  }
}

void sub_100A73454(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80)) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(a1 + 136) == 1) {
    goto LABEL_11;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  uint64_t v3 = *(void *)(a1 + 120);
  if (v2 == v3) {
    goto LABEL_11;
  }
  uint64_t v4 = 0;
  do
  {
    if (*(_DWORD *)(v2 + 8) == 5) {
      ++v4;
    }
    v2 += 168;
  }
  while (v2 != v3);
  if (!v4 || v4 != 2 && *(_DWORD *)(a1 + 84))
  {
LABEL_11:
    uint64_t v5 = *(void *)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    if (v5)
    {
      v6 = *(void (**)(void))(*(void *)v5 + 8);
      v6();
    }
    return;
  }
  if (!sub_100529568()) {
    goto LABEL_30;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 48));
  v9 = ServiceMap;
  if (v10 < 0)
  {
    v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  char v34 = (uint64_t (**)())v10;
  v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v34);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_23;
  }
  uint64_t v16 = v14[3];
  v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_23:
    std::mutex::unlock(v9);
    v15 = 0;
    char v17 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_24:
  if (v16)
  {
    char v34 = off_101A339E0;
    uint64_t v35 = a1;
    v36 = &v34;
    (*(void (**)(uint64_t, uint64_t (***)()))(*(void *)v16 + 80))(v16, &v34);
    sub_1004CACEC(&v34);
    if (v17) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  v18 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    if (v17) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  LOWORD(v34) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to get the 2G setting", (uint8_t *)&v34, 2u);
  if ((v17 & 1) == 0) {
LABEL_29:
  }
    sub_10004D2C8(v15);
LABEL_30:
  int v19 = *(void **)(a1 + 88);
  if (v19 != (void *)(a1 + 96))
  {
    while ((*((_DWORD *)v19 + 8) - 6) <= 0xFFFFFFFD)
    {
      v20 = (void *)v19[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          v21 = (void *)v19[2];
          BOOL v22 = *v21 == (void)v19;
          int v19 = v21;
        }
        while (!v22);
      }
      int v19 = v21;
      if (v21 == (void *)(a1 + 96)) {
        goto LABEL_38;
      }
    }
    goto LABEL_11;
  }
LABEL_38:
  if (*(void *)(a1 + 144)) {
    return;
  }
  v23 = (std::mutex *)Registry::getServiceMap(0, *(Registry **)(a1 + 48));
  int v24 = v23;
  if (v25 < 0)
  {
    uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v23);
  char v34 = (uint64_t (**)())v25;
  v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&v34);
  if (!v29)
  {
    uint64_t v31 = 0;
    goto LABEL_46;
  }
  uint64_t v31 = v29[3];
  uint64_t v30 = (std::__shared_weak_count *)v29[4];
  if (!v30)
  {
LABEL_46:
    std::mutex::unlock(v24);
    uint64_t v30 = 0;
    char v32 = 1;
    goto LABEL_47;
  }
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v24);
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  char v32 = 0;
LABEL_47:
  if (v31)
  {
    char v34 = off_101A337E0;
    uint64_t v35 = a1;
    v36 = &v34;
    (*(void (**)(uint64_t, uint64_t (***)()))(*(void *)v31 + 80))(v31, &v34);
    sub_1004CACEC(&v34);
    if (v32) {
      return;
    }
  }
  else
  {
    long long v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Could not get Max Data Rate Manager to get the 2G setting", (uint8_t *)&v34, 2u);
      if (v32) {
        return;
      }
    }
    else if (v32)
    {
      return;
    }
  }
  sub_10004D2C8(v30);
}

void sub_100A73874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1004CACEC(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100A738C4(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 136) != a2) {
    sub_100A73454(a1);
  }
}

double sub_100A738D8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 48));
  v6 = ServiceMap;
  if (v7 < 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v7;
  v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
LABEL_13:
      v20 = 0;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v13 + 40))(buf, v13, a2, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_1000842D0(&v20, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      if (v20) {
        v18 = sub_100081E58;
      }
      else {
        v18 = 0;
      }
      if (v18)
      {
        *(void *)buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v20, v17);
        double v16 = *(double *)buf;
      }
      else
      {
        double v16 = 0.0;
      }
      sub_1000570E8((const void **)&v20);
      if (v14) {
        return v16;
      }
LABEL_20:
      sub_10004D2C8(v12);
      return v16;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (v13) {
    goto LABEL_13;
  }
LABEL_7:
  v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not get CFPreferences", buf, 2u);
  }
  double v16 = 0.0;
  if ((v14 & 1) == 0) {
    goto LABEL_20;
  }
  return v16;
}

void sub_100A73AC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100A73B00(Registry *a1@<X0>, __int16 a2@<W1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v23 = (xpc_object_t *)v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v23);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_34;
  }
LABEL_10:
  xpc_object_t v27 = 0;
  xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v15 = v14;
  if (v14)
  {
    xpc_object_t v27 = v14;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v27 = v15;
    if (!v15)
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v15 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v16 = xpc_null_create();
LABEL_17:
    xpc_object_t v27 = v16;
    goto LABEL_18;
  }
  xpc_retain(v15);
LABEL_18:
  xpc_release(v15);
  if ((a2 & 0xFF00) != 0) {
    CFNumberRef v17 = "true";
  }
  else {
    CFNumberRef v17 = "false";
  }
  xpc_object_t v25 = xpc_string_create(v17);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  v23 = &v27;
  int v24 = "alertDisplayed";
  sub_100035E70((uint64_t)&v23, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  v18 = "Action";
  if (!(_BYTE)a2) {
    v18 = "Dismiss";
  }
  if ((a2 & 0xFF00) != 0) {
    int v19 = v18;
  }
  else {
    int v19 = "invalid";
  }
  xpc_object_t v21 = xpc_string_create(v19);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  v23 = &v27;
  int v24 = "userAction";
  sub_100035E70((uint64_t)&v23, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v20 = v27;
  xpc_object_t v21 = 0;
  if (v27) {
    xpc_retain(v27);
  }
  else {
    xpc_object_t v20 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v12 + 16))(v12, "commCenterOos2GDisabledAndOnlyAvailableRat", &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v27);
LABEL_34:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A73DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16)
{
  xpc_release(object);
  xpc_release(a16);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

void sub_100A73E00(Registry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  CFAbsoluteTime valuePtr = *(double *)&v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&valuePtr);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_10:
    CFAbsoluteTime valuePtr = CFAbsoluteTimeGetCurrent();
    CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat64Type, &valuePtr);
    (*(void (**)(uint64_t, uint64_t, CFNumberRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v12 + 16))(v12, a2, v14, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_1000570E8((const void **)&v14);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A73F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100A73F8C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 144)) {
      char v3 = " is";
    }
    else {
      char v3 = "";
    }
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I OOS Throttle Timer%s running", (uint8_t *)&v4, 0xCu);
  }
}

void sub_100A74048(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A74080(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A740B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A740F4(ServiceManager::Service *this)
{
  *(void *)this = off_101A334E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100A74150(ServiceManager::Service *this)
{
  *(void *)this = off_101A334E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100A741C0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ServiceMonitor");
}

unsigned char *sub_100A741D0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 1;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100A74210(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  char v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100A732E0(v2);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100A732E0(v4);
}

uint64_t sub_100A7428C()
{
  return 0;
}

uint64_t sub_100A74294()
{
  return 1;
}

uint64_t sub_100A7429C()
{
  return 0;
}

void sub_100A742A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A74388(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7449C(uint64_t **a1)
{
  uint64_t v7 = a1;
  uint64_t v1 = **a1;
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A33560;
  v2[1] = v1 + 80;
  v2[2] = v1;
  v2[3] = sub_100A733C0;
  v2[4] = 0;
  v11 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100899E4C(v1 + 84);
  sub_100058DB0(__p, "/cc/props/registration_status");
  uint64_t v3 = operator new(0x28uLL);
  *uint64_t v3 = off_101A335E0;
  v3[1] = v1 + 88;
  v3[2] = v1;
  v3[3] = sub_100A73400;
  v3[4] = 0;
  v11 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v4 = operator new(0x28uLL);
  void *v4 = off_101A33660;
  v4[1] = v1 + 112;
  v4[2] = v1;
  v4[3] = sub_100A738C0;
  v4[4] = 0;
  v11 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/wifi_status");
  uint64_t v5 = operator new(0x28uLL);
  void *v5 = off_101A336E0;
  v5[1] = v1 + 136;
  v5[2] = v1;
  v5[3] = sub_100A738C4;
  v5[4] = 0;
  v11 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  unint64_t v6 = operator new(0x20uLL);
  void *v6 = off_101A33760;
  v6[1] = v1;
  v6[2] = sub_100A73F8C;
  v6[3] = 0;
  v11 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  operator delete();
}

void sub_100A74794(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100A7480C()
{
}

__n128 sub_100A74820(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A33560;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A74874(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A33560;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A748AC(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  unint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100A74948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A74988()
{
}

void sub_100A74998()
{
}

__n128 sub_100A749AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A335E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A74A00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A335E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A74A38(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  v11 = (void **)*v3;
  uint64_t v12 = v5;
  char v13 = (void *)v3[2];
  if (v13)
  {
    v5[2] = &v12;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v11 = &v12;
  }
  sub_100026EC0((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  char v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    v12[2] = v10;
    v11 = &v12;
    uint64_t v12 = 0;
    char v13 = 0;
  }
  else
  {
    char v9 = v10;
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10[0]);
  sub_1000346F8((uint64_t)&v11, v12);
}

void sub_100A74B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_100A74B60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A74BA0()
{
}

void sub_100A74BB0()
{
}

__n128 sub_100A74BC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A33660;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A74C18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A33660;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A74C50(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100A74CCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A74D0C()
{
}

void sub_100A74D1C()
{
}

__n128 sub_100A74D30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A336E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A74D84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A336E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A74DBC(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    unsigned __int8 *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned __int8 *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  char v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    char v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100A74EB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A74EF4()
{
}

void sub_100A74F04()
{
}

__n128 sub_100A74F18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A33760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A74F6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A33760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A74FA4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A74FEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A7502C()
{
}

void sub_100A75038(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v13, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (sub_100529568()) {
LABEL_16:
  }
    operator delete();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(v1 + 48));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11)
      {
LABEL_14:
        if ((v12 & 1) == 0) {
          sub_10004D2C8(v10);
        }
        goto LABEL_16;
      }
LABEL_13:
      (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v11 + 16))(v11, @"Enable2GPromptLastShownTime", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  char v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

void sub_100A751C4()
{
  if ((v0 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  operator delete();
}

uint64_t *sub_100A7521C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  uint64_t v3 = *(void *)(v2 + 144);
  *(void *)(v2 + 144) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100A75294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100A752B4()
{
}

void *sub_100A752C8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A337E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A75310(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A337E0;
  a2[1] = v2;
  return result;
}

void sub_100A7533C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100A7542C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A7546C()
{
}

void sub_100A75478(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v22 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I User preference of enable 2G: %s", buf, 0xCu);
  }
  if (*((_DWORD *)v1 + 2) == 3 && sub_100529568() && !*(void *)(v2 + 144))
  {
    memset(v20, 0, 24);
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v4 || (uint64_t v5 = *(void *)(v2 + 8), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v7 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v6);
    unsigned int v8 = operator new(0x20uLL);
    *unsigned int v8 = off_101A338E0;
    v8[1] = v2;
    v8[2] = v5;
    v8[3] = v7;
    v20[3] = v8;
    Registry::getTimerService(&v15, *(Registry **)(v2 + 48));
    uint64_t v9 = v15;
    sub_100058DB0(v13, "ServiceMonitorOOSTimer");
    *(_OWORD *)long long __p = *(_OWORD *)v13;
    uint64_t v19 = v14;
    v13[0] = 0;
    v13[1] = 0;
    uint64_t v14 = 0;
    sub_1000DA470((uint64_t)buf, (uint64_t)v20);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, uint8_t *))(*(void *)v9 + 40))(&v17, v9, __p, 2, 900000000, 0, buf);
    sub_10003B34C(buf);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = v17;
    uint64_t v17 = 0;
    uint64_t v11 = *(void *)(v2 + 144);
    *(void *)(v2 + 144) = v10;
    if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      uint64_t v12 = v17;
      uint64_t v17 = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[0]);
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
    sub_10003B34C(v20);
  }
  operator delete();
}

void sub_100A756F8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27)
{
  sub_10003B34C((void *)(v27 - 80));
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10003B34C(&a27);
  operator delete();
}

void *sub_100A7578C(void *a1)
{
  *a1 = off_101A33860;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A757D8(void *a1)
{
  *a1 = off_101A33860;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A75844(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A33860;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A758A8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A33860;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A758E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A758F8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A75938(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[2])
      {
LABEL_24:
        sub_10004D2C8(v7);
        return;
      }
      unsigned int v8 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Enable 2G prompt response: %s", buf, 0xCu);
      }
      if (v4 != 1)
      {
LABEL_23:
        sub_100A73B00(*(Registry **)(v5 + 48), (v4 == 1) | 0x100, (uint64_t *)(v4 == 1));
        goto LABEL_24;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(v5 + 48));
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)buf = v12;
      xpc_object_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
LABEL_15:
          xpc_object_t v20 = *(NSObject **)(v5 + 24);
          dispatch_object_t object = v20;
          if (v20) {
            dispatch_retain(v20);
          }
          sub_100058DB0(buf, "prefs:root=Privacy#LOCKDOWN_MODE");
          (*(void (**)(uint64_t, dispatch_object_t *, unsigned char *))(*(void *)v18 + 16))(v18, &object, buf);
          if (v23 < 0) {
            operator delete(*(void **)buf);
          }
          if (object) {
            dispatch_release(object);
          }
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
      goto LABEL_15;
    }
  }
}

void sub_100A75B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (object) {
    dispatch_release(object);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100A75BB0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A75BF0()
{
}

void *sub_100A75BFC(void *a1)
{
  *a1 = off_101A338E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A75C48(void *a1)
{
  *a1 = off_101A338E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A75CB4(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A338E0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A75D18(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A338E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A75D58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A75D68(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A75DA8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100A75EB8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A75EF8()
{
}

void sub_100A75F04(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 144);
  *(void *)(v1 + 144) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I OOS timer fired", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13) {
    goto LABEL_17;
  }
LABEL_14:
  unsigned int v15 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v15 || (uint64_t v16 = *(void *)(v1 + 8), (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
    sub_100088B9C();
  }
  char v18 = v17;
  atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  xpc_object_t v21 = 0;
  char v19 = operator new(0x20uLL);
  *char v19 = off_101A33950;
  v19[1] = v1;
  v19[2] = v16;
  v19[3] = v18;
  xpc_object_t v21 = v19;
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 24))(v13, buf);
  sub_100060644(buf);
LABEL_17:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  operator delete();
}

void sub_100A76144(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void *sub_100A761B4(void *a1)
{
  *a1 = off_101A33950;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A76200(void *a1)
{
  *a1 = off_101A33950;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A7626C(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A33950;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A762D0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A33950;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A76310(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A76320(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A76360(void *a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (v3)
    {
      uint64_t v4 = a1[1];
      uint64_t v5 = std::__shared_weak_count::lock(v3);
      if (v5)
      {
        if (a1[2])
        {
          uint64_t v6 = *(std::__shared_weak_count **)(v4 + 16);
          if (v6)
          {
            if (std::__shared_weak_count::lock(v6)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
        sub_10004D2C8(v5);
      }
    }
  }
}

uint64_t sub_100A76478(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A764B8()
{
}

void sub_100A764C4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (sub_100A738D8(v1, @"Enable2GPromptLastShownTime", __stack_chk_guard) > 1.0)
  {
    sub_100A73B00(*(Registry **)(v1 + 48), 0, v2);
    goto LABEL_31;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(v1 + 48));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_9:
    uint64_t v13 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N No localization handler", buf, 2u);
    }
LABEL_29:
    if ((v12 & 1) == 0) {
      sub_10004D2C8(v10);
    }
LABEL_31:
    operator delete();
  }
LABEL_13:
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  uint64_t v14 = kAlertDialogLocalizationTable;
  (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v11 + 16))(v30, v11, kAlertDialogLocalizationTable, @"REENABLEMENT_TITLE", 1);
  memset(buf, 0, sizeof(buf));
  uint64_t v35 = 0;
  ctu::cf::assign();
  *(_OWORD *)char v32 = *(_OWORD *)buf;
  uint64_t v33 = v35;
  sub_1000558F4((const void **)v30);
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v11 + 16))(v28, v11, v14, @"REENABLEMENT_2G_TEXT", 1);
  memset(buf, 0, sizeof(buf));
  uint64_t v35 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v30 = *(_OWORD *)buf;
  uint64_t v31 = v35;
  sub_1000558F4((const void **)v28);
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v11 + 16))(__p, v11, v14, @"OPEN_SETTINGS", 1);
  memset(buf, 0, sizeof(buf));
  uint64_t v35 = 0;
  ctu::cf::assign();
  *(_OWORD *)unsigned int v28 = *(_OWORD *)buf;
  uint64_t v29 = v35;
  sub_1000558F4((const void **)__p);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v27 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v11 + 16))(&v24, v11, v14, @"DISMISS", 1);
  memset(buf, 0, sizeof(buf));
  uint64_t v35 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v27 = v35;
  sub_1000558F4(&v24);
  unsigned int v15 = (std::__shared_weak_count *)operator new(0x20uLL);
  v15->__shared_owners_ = 0;
  v15->__shared_weak_owners_ = 0;
  v15->__vftable = (std::__shared_weak_count_vtbl *)off_101A73DC8;
  v15[1].__vftable = (std::__shared_weak_count_vtbl *)&off_101A73D60;
  int v24 = 0;
  xpc_object_t v25 = 0;
  uint64_t v16 = *(NSObject **)(v1 + 24);
  dispatch_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v17 || (v18 = *(void *)(v1 + 8), (char v19 = std::__shared_weak_count::lock(v17)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v20 = v19;
  atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  v36 = 0;
  xpc_object_t v21 = operator new(0x20uLL);
  void *v21 = off_101A33860;
  v21[1] = v1;
  v21[2] = v18;
  v21[3] = v20;
  v36 = v21;
  ((void (*)(const void **__return_ptr, std::__shared_weak_count *, void **, void **, void **, void **, dispatch_object_t *, uint8_t *))v15[1].__vftable[1].~__shared_weak_count)(&v24, &v15[1], v32, v30, v28, __p, &object, buf);
  sub_1000DA3EC(buf);
  if (object) {
    dispatch_release(object);
  }
  sub_100A73E00(*(Registry **)(v1 + 48), @"Enable2GPromptLastShownTime", v22);
  (*(void (**)(const void *))(*(void *)v24 + 16))(v24);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_10004D2C8(v15);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[0]);
  }
  goto LABEL_29;
}

void sub_100A769E4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_1000DA3EC((void *)(v42 - 128));
  if (object) {
    dispatch_release(object);
  }
  sub_10004D2C8(v40);
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  operator delete();
}

void sub_100A76B68()
{
}

void *sub_100A76B7C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A339E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A76BC4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A339E0;
  a2[1] = v2;
  return result;
}

void sub_100A76BF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100A76CE0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A76D20()
{
}

void sub_100A76D2C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  uint64_t v28 = v2 + 40;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I User preference of enable 2G: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v4 = (uint64_t *)*((unsigned int *)v1 + 2);
  if (v4 == 2) {
LABEL_32:
  }
    operator delete();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    uint64_t v12 = v11[3];
    uint64_t v13 = (std::__shared_weak_count *)v11[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v14 = 0;
      if (!v12)
      {
LABEL_30:
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_32;
      }
LABEL_13:
      uint64_t v27 = v2;
      unsigned int v15 = dispatch_group_create();
      uint64_t v16 = operator new(0x20uLL);
      v16[1] = 0;
      uint64_t v17 = v16 + 1;
      v16[2] = 0;
      *uint64_t v16 = off_1019B3378;
      *((unsigned char *)v16 + 24) = 0;
      subscriber::makeSimSlotRange();
      uint64_t v18 = (unsigned int *)*((void *)&buf + 1);
      char v19 = (unsigned int *)buf;
      if ((void)buf != *((void *)&buf + 1))
      {
        xpc_object_t v20 = v32;
        do
        {
          if (v20(*v19)) {
            goto LABEL_18;
          }
          ++v19;
        }
        while (v19 != v18);
        char v19 = v18;
LABEL_18:
        xpc_object_t v21 = (unsigned int *)*((void *)&buf + 1);
LABEL_19:
        while (v19 != v21)
        {
          uint64_t v22 = *v19;
          atomic_fetch_add_explicit(v17, 1uLL, memory_order_relaxed);
          if (v15)
          {
            dispatch_retain(v15);
            dispatch_group_enter(v15);
          }
          uint64_t v30 = 0;
          char v23 = operator new(0x28uLL);
          void *v23 = off_101A33A50;
          v23[1] = v16 + 3;
          v23[2] = v16;
          v23[3] = v28;
          v23[4] = v15;
          uint64_t v30 = v23;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v12 + 136))(v12, v22, v29);
          sub_10010E020(v29);
          int v24 = v19 + 1;
          char v19 = v18;
          if (v24 != v18)
          {
            char v19 = v24;
            do
            {
              if (v20(*v19)) {
                goto LABEL_19;
              }
              ++v19;
            }
            while (v19 != v18);
            char v19 = v18;
          }
        }
      }
      xpc_object_t v25 = *(std::__shared_weak_count **)(v27 + 16);
      if (v25)
      {
        uint64_t v26 = std::__shared_weak_count::lock(v25);
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v26);
          atomic_fetch_add_explicit(v17, 1uLL, memory_order_relaxed);
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v13 = 0;
  char v14 = 1;
  if (!v12) {
    goto LABEL_30;
  }
  goto LABEL_13;
}

void sub_100A770E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12)
{
  sub_10004D2C8(v14);
  std::__shared_weak_count::__release_weak(v13);
  sub_10004D2C8(v14);
  if (v12) {
    dispatch_release(v12);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  operator delete();
}

void *sub_100A771B0(void *a1)
{
  *a1 = off_101A33A50;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100A77214(void *a1)
{
  *a1 = off_101A33A50;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_100A77298(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A33A50;
  sub_100A7752C(v2 + 1, v1);
  return v2;
}

void *sub_100A772EC(uint64_t a1, void *a2)
{
  *a2 = off_101A33A50;
  return sub_100A7752C(a2 + 1, (void *)(a1 + 8));
}

void sub_100A77318(uint64_t a1)
{
}

void sub_100A77320(void *a1)
{
  sub_100A77584((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100A7735C(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v16 = v3;
  uint64_t v17 = v3;
  *a2 = 0;
  uint64_t v4 = *(os_log_t **)(a1 + 24);
  if (v3)
  {
    uint64_t v5 = sub_100080778;
    CFRetain(v3);
  }
  else
  {
    uint64_t v5 = 0;
  }
  BOOL v6 = (char)v5;
  if (v5)
  {
    uint64_t v7 = (const void *)kCTRegistrationRadioAccessTechnologyGSM;
    if (kCTRegistrationRadioAccessTechnologyGSM)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, kCTRegistrationBandActive);
      CFDictionaryRef v9 = Value;
      BOOL v6 = Value
        && (CFTypeID v10 = CFGetTypeID(Value), v10 == CFDictionaryGetTypeID())
        && (v11 = (const __CFArray *)CFDictionaryGetValue(v9, v7), (CFArrayRef v12 = v11) != 0)
        && (CFTypeID v13 = CFGetTypeID(v11), v13 == CFArrayGetTypeID())
        && CFArrayGetCount(v12) > 0;
    }
    else
    {
      char v14 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N CF key mapping not found for GSM", buf, 2u);
      }
      BOOL v6 = 1;
    }
  }
  **(unsigned char **)(a1 + 8) |= v6;
  sub_100057D78(&v17);
  return sub_100057D78(&v16);
}

void sub_100A774C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_100A774E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A77520()
{
}

void *sub_100A7752C(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[3];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

void sub_100A77584(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

uint64_t *sub_100A775E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100A77640(uint64_t a1)
{
  uint64_t v20 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!*(void *)(a1 + 8) || !**(unsigned char **)(a1 + 24)) {
        goto LABEL_39;
      }
      BOOL v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "2G is active", buf, 2u);
      }
      double v8 = sub_100A738D8(v3, @"2GActiveABCTime", v7);
      if (CFAbsoluteTimeGetCurrent() - v8 < 86400.0) {
        goto LABEL_39;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)"delNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE", *(Registry **)(v3 + 48));
      CFTypeID v10 = ServiceMap;
      if (v11 < 0)
      {
        CFArrayRef v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          uint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v11;
      unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
      if (v15)
      {
        uint64_t v17 = v15[3];
        uint64_t v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
          if (!v17)
          {
LABEL_37:
            if ((v18 & 1) == 0) {
              sub_10004D2C8(v16);
            }
LABEL_39:
            sub_10004D2C8(v5);
            return sub_100A775E0(&v20);
          }
LABEL_17:
          memset(&buf[8], 0, 32);
          long long v32 = 0u;
          long long v33 = 0u;
          long long v37 = 0u;
          long long v36 = 0u;
          memset(&v34, 0, sizeof(v34));
          uint64_t v35 = 23;
          qmemcpy(&buf[23], "\tServiceMonitor", 15);
          qmemcpy(buf, "Telephony", 9);
          BYTE7(v32) = 14;
          HIBYTE(v33) = 2;
          WORD4(v32) = 18226;
          sub_10003ECB8(&v34, "2G enabled unexpectedly", 0x17uLL);
          v35 |= 0x11uLL;
          sub_1000DB86C((char *)__dst, (long long *)buf);
          v38[0] = off_101A33AE0;
          v38[1] = v3;
          v38[3] = v38;
          (*(void (**)(uint64_t, void **, void *))(*(void *)v17 + 16))(v17, __dst, v38);
          sub_1000DBADC(v38);
          if (v30 < 0) {
            operator delete(__p);
          }
          if (v28 < 0) {
            operator delete(v27);
          }
          if (v26 < 0) {
            operator delete(v25);
          }
          if (v24 < 0) {
            operator delete(v23);
          }
          if (v22 < 0) {
            operator delete(__dst[0]);
          }
          if (SBYTE7(v37) < 0) {
            operator delete((void *)v36);
          }
          if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v34.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v33) < 0) {
            operator delete(*((void **)&v32 + 1));
          }
          if (SBYTE7(v32) < 0) {
            operator delete(*(void **)&buf[24]);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      uint64_t v16 = 0;
      char v18 = 1;
      if (!v17) {
        goto LABEL_37;
      }
      goto LABEL_17;
    }
  }
  return sub_100A775E0(&v20);
}

void sub_100A779BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_1000DBADC((void *)(v30 - 120));
  sub_1001278A0((uint64_t)&a10);
  sub_1001278A0((uint64_t)&a27);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  sub_10004D2C8(v27);
  sub_100A775E0(&a9);
  _Unwind_Resume(a1);
}

void sub_100A77A20()
{
}

void *sub_100A77A34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A33AE0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A77A7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A33AE0;
  a2[1] = v2;
  return result;
}

void sub_100A77AA8(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v3 = *a2;
  uint64_t v4 = *(void **)a3;
  int v5 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v3) {
    sub_100A73E00(*(Registry **)(*(void *)(a1 + 8) + 48), @"2GActiveABCTime", *(uint64_t **)(a1 + 8));
  }
  if (v5 < 0)
  {
    operator delete(v4);
  }
}

void sub_100A77B14(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A77B30(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A77B70()
{
}

void sub_100A77B7C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A78168(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, dispatch_object_t a11, dispatch_object_t a12, dispatch_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void sub_100A783D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100A783B4);
}

void sub_100A783FC()
{
}

const char *sub_100A78404(int a1)
{
  uint64_t v1 = "pp.?";
  if (a1 == 2) {
    uint64_t v1 = "pp.2";
  }
  if (a1 == 1) {
    return "pp.1";
  }
  else {
    return v1;
  }
}

void sub_100A78430(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100A78530(uint64_t a1)
{
  *(void *)a1 = off_101A33B60;
  sub_10030AB98((void *)(a1 + 232));
  uint64_t v11 = (void **)(a1 + 200);
  sub_10008A88C(&v11);
  int v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 176);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 160);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 144);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 120);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100160A84((atomic_uint **)(a1 + 56));
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  ActivationInterface::~ActivationInterface((ActivationInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A78638(uint64_t a1)
{
  sub_100A78530(a1);

  operator delete();
}

void sub_100A78670(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  v4[0] = a2;
  v4[1] = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100A7FBBC;
  block[3] = &unk_101A33F18;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  int v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100A786FC(uint64_t a1, const void **a2)
{
  uint64_t v4 = *(void *)(a1 + 152);
  sub_100058198(&v8, a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v4 + 40))(v4, &v8);
  sub_100057D78(&v8);
  char v9 = v5;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 408))(*(void *)(a1 + 112), v5);
  v7[0] = &v9;
  v7[1] = a1;
  v7[2] = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100A7FC4C;
  block[3] = &unk_101A33F38;
  block[4] = a1 + 8;
  block[5] = v7;
  uint64_t v6 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32)) {
    dispatch_async_and_wait(v6, block);
  }
  else {
    dispatch_sync(v6, block);
  }
}

void sub_100A78820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A78834()
{
  return DevicePersistentSaveValue(kPostponementTicketLock, kCFBooleanTrue);
}

void sub_100A78850(uint64_t a1)
{
  DevicePersistentSaveValue(kPostponementTicketLock, kCFBooleanFalse);
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7894C(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  v4[0] = a2;
  v4[1] = a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100A80208;
  block[3] = &unk_101A33F58;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  int v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

BOOL sub_100A789D8(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80298;
  v5[3] = &unk_101A33F78;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100A78B08(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80408;
  v5[3] = &unk_101A33FD8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100A78C38(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80438;
  v5[3] = &unk_101A33FF8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100A78D68(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80468;
  v5[3] = &unk_101A34018;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100A78E98(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80498;
  v5[3] = &unk_101A34038;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_100A78FC8(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A804C8;
  v5[3] = &unk_101A34058;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100A790F8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_1000DFC90((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A79230(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

BOOL sub_100A79248(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A80598;
  v5[3] = &unk_101A34078;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005B0E0;
    uint64_t v10 = &unk_101A33FB8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10005A37C;
    uint64_t v10 = &unk_101A33F98;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100A79378(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = a1;
  char v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A794C4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A794DC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[19];
  uint64_t v7 = a1[25];
  if (v7 != a1[26])
  {
    memset(v21, 0, 32);
    *(_OWORD *)uint64_t v20 = 0u;
    sub_100E63EA4((uint64_t)v20);
    int v8 = SHIBYTE(v21[0]);
    if (SHIBYTE(v21[0]) < 0)
    {
      sub_10004FC84(buf, v20[0], (unint64_t)v20[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)v20;
      char v29 = v21[0];
    }
    int v10 = SHIBYTE(v21[3]);
    if (SHIBYTE(v21[3]) < 0)
    {
      sub_10004FC84(&v30, v21[1], (unint64_t)v21[2]);
    }
    else
    {
      long long v30 = *(_OWORD *)&v21[1];
      uint64_t v31 = v21[3];
    }
    if (*(char *)(v7 + 143) < 0)
    {
      sub_10004FC84(&v32, *(void **)(v7 + 120), *(void *)(v7 + 128));
    }
    else
    {
      long long v32 = *(_OWORD *)(v7 + 120);
      uint64_t v33 = *(void *)(v7 + 136);
    }
    if (*(char *)(v7 + 167) < 0)
    {
      sub_10004FC84(&v34, *(void **)(v7 + 144), *(void *)(v7 + 152));
    }
    else
    {
      long long v34 = *(_OWORD *)(v7 + 144);
      v35[0] = *(void *)(v7 + 160);
    }
    uint64_t v17 = 0;
    char v18 = 0;
    char v19 = 0;
    v21[4] = &v17;
    v21[5] = 0;
    uint64_t v17 = (std::string *)operator new(0x60uLL);
    char v18 = v17;
    char v19 = (char *)&v17[4];
    uint64_t v11 = 0;
    char v18 = (std::string *)sub_1000D8A18((uint64_t)&v19, (long long *)buf, &v36, (char *)v17);
    do
    {
      if (SHIBYTE(v35[v11]) < 0) {
        operator delete((void *)v35[v11 - 2]);
      }
      v11 -= 3;
    }
    while (v11 != -12);
    sub_100062B40(v17, v18, "/", 1uLL, &__p);
    *(void *)long long buf = &v17;
    sub_100047F64((void ***)buf);
    if (v10 < 0)
    {
      operator delete(v21[1]);
      if ((v8 & 0x80000000) == 0) {
        goto LABEL_23;
      }
    }
    else if ((v8 & 0x80000000) == 0)
    {
      goto LABEL_23;
    }
    operator delete(v20[0]);
    goto LABEL_23;
  }
  char v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to get Carrier Information for Post Buddy Ticket Refresh Metric: (no valid sim)", buf, 2u);
  }
  sub_100058DB0(&__p, "no_sim");
LABEL_23:
  *(void *)&long long v22 = a1;
  CFArrayRef v12 = (std::__shared_weak_count *)a1[2];
  if (!v12 || (uint64_t v13 = a1[1], (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
    sub_100088B9C();
  }
  *((void *)&v22 + 1) = v13;
  char v23 = v14;
  atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v24 = a2;
  sub_1000DFC90((uint64_t)v25, a3);
  uint64_t v27 = 0;
  unsigned int v15 = (char *)operator new(0x48uLL);
  *(void *)unsigned int v15 = off_101A340A8;
  *(_OWORD *)(v15 + 8) = v22;
  *((void *)v15 + 3) = v23;
  *((void *)&v22 + 1) = 0;
  char v23 = 0;
  v15[32] = v24;
  sub_100023950((uint64_t)(v15 + 40), (uint64_t)v25);
  uint64_t v27 = v15;
  (*(void (**)(uint64_t, uint64_t, std::string *, void *))(*(void *)v6 + 80))(v6, a2, &__p, v26);
  sub_100060644(v26);
  sub_100060644(v25);
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100A79858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

uint64_t sub_100A79944(uint64_t a1)
{
  sub_100060644((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A7997C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A79AC8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100A79AE0(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A81794;
  v5[3] = &unk_101A341A8;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100A81864;
    int v10 = &unk_101A341E8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    uint64_t v13 = 0;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100A81820;
    int v10 = &unk_101A341C8;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    uint64_t v13 = 0;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_100A79C08(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v7 = v6;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v6);
    }
    else
    {
      uint64_t v7 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A79E08(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A79E24(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100A81CA0;
  v5[3] = &unk_101A34208;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100A81D14;
    int v10 = &unk_101A34248;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100A81CD8;
    int v10 = &unk_101A34228;
    uint64_t v11 = &v13;
    CFArrayRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_100A79F4C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int **)(a1 + 200);
  uint64_t v1 = *(unsigned int **)(a1 + 208);
  if (v2 != v1)
  {
    char v4 = 1;
LABEL_3:
    char v59 = v4;
    do
    {
      uint64_t v5 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 112) + 192))(*(void *)(a1 + 112), *v2);
      if ((subscriber::isSimReady() & 1) != 0 || (v2[2] == HIDWORD(v5) ? (BOOL v6 = v2[1] == v5) : (BOOL v6 = 0), !v6))
      {
        if (!subscriber::isSimSettled())
        {
          char v4 = 0;
          v2 += 42;
          if (v2 != v1) {
            goto LABEL_3;
          }
          goto LABEL_25;
        }
        *(void *)v62 = 0;
        ActivationSimInfo::ActivationSimInfo((ActivationSimInfo *)v62);
        if (capabilities::ct::activationSIMInfoHardwareSlotBased(v7))
        {
          *(_DWORD *)v62 = v2[1];
          uint64_t v8 = *v2;
        }
        else
        {
          uint64_t v8 = *v2;
          if (v8 == 2 || v8 == 1) {
            *(_DWORD *)v62 = *v2;
          }
        }
        *(_DWORD *)&v62[4] = v2[2];
        char v9 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = subscriber::asString();
          uint64_t v11 = subscriber::asString();
          uint64_t v12 = subscriber::asString();
          uint64_t v13 = subscriber::asString();
          uint64_t v14 = subscriber::asString();
          *(_DWORD *)long long buf = 136316162;
          *(void *)&uint8_t buf[4] = v10;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v11;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = v12;
          *(_WORD *)&buf[32] = 2080;
          *(void *)&buf[34] = v13;
          *(_WORD *)&buf[42] = 2080;
          *(void *)&buf[44] = v14;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I SIM[%s] changing from %s - %s to %s - %s", buf, 0x34u);
          uint64_t v8 = *v2;
        }
        (*(void (**)(void, uint64_t, uint8_t *))(**(void **)(a1 + 112) + 184))(*(void *)(a1 + 112), v8, v62);
      }
      v2 += 42;
    }
    while (v2 != v1);
    if (v59)
    {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 192))(*(void *)(a1 + 112), 1);
      if (subscriber::isSimReady())
      {
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 1);
        sub_100A7D170(a1);
        return;
      }
      uint64_t v16 = *(void *)(a1 + 200);
      if (*(void *)(a1 + 208) == v16) {
        sub_10015B728();
      }
      uint64_t v72 = 0;
      long long v70 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)v68 = 0u;
      *(_OWORD *)v69 = 0u;
      *(_OWORD *)v66 = 0u;
      long long v67 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_10002E664((uint64_t)buf, v16);
      int isSimAbsent = subscriber::isSimAbsent();
      int isSimUnreadable = subscriber::isSimUnreadable();
      int isSimSettled = subscriber::isSimSettled();
      if (BasicSimInfo::isEmptyEsimCapableCard((BasicSimInfo *)buf))
      {
        uint64_t v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v62 = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I SIM with no active profile", v62, 2u);
        }
        if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 232))(*(void *)(a1 + 112)))
        {
          xpc_object_t v21 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v62 = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I clearing service provisioning in progress", v62, 2u);
          }
          (*(void (**)(void, void))(**(void **)(a1 + 112) + 224))(*(void *)(a1 + 112), 0);
        }
        (*(void (**)(void))(**(void **)(a1 + 112) + 176))(*(void *)(a1 + 112));
LABEL_91:
        if (SHIBYTE(v72) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v70) < 0) {
          operator delete(v69[1]);
        }
        if (SHIBYTE(v69[0]) < 0) {
          operator delete(v68[0]);
        }
        if (SHIBYTE(v67) < 0) {
          operator delete(v66[1]);
        }
        *(void *)v62 = &buf[40];
        sub_10002E39C((void ***)v62);
        if (*(void *)&buf[16])
        {
          *(void *)&buf[24] = *(void *)&buf[16];
          operator delete(*(void **)&buf[16]);
        }
        return;
      }
      if (isSimSettled)
      {
        (*(void (**)(void))(**(void **)(a1 + 112) + 176))(*(void *)(a1 + 112));
        if ((isSimAbsent | isSimUnreadable) == 1)
        {
          if (isSimAbsent)
          {
            long long v22 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v62 = 0;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I There is no SIM, clearing OTASP attempts", v62, 2u);
            }
            ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 80));
            xpc_object_t v25 = ServiceMap;
            if (v26 < 0)
            {
              uint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v28 = 5381;
              do
              {
                uint64_t v26 = v28;
                unsigned int v29 = *v27++;
                uint64_t v28 = (33 * v28) ^ v29;
              }
              while (v29);
            }
            std::mutex::lock(ServiceMap);
            *(void *)v62 = v26;
            long long v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)v62);
            if (v30)
            {
              uint64_t v32 = v30[3];
              uint64_t v31 = (std::__shared_weak_count *)v30[4];
              if (v31)
              {
                atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v25);
                atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v31);
                char v33 = 0;
                goto LABEL_57;
              }
            }
            else
            {
              uint64_t v32 = 0;
            }
            std::mutex::unlock(v25);
            uint64_t v31 = 0;
            char v33 = 1;
LABEL_57:
            (*(void (**)(uint64_t))(*(void *)v32 + 40))(v32);
            if ((v33 & 1) == 0) {
              sub_10004D2C8(v31);
            }
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 320))(*(void *)(a1 + 112), 0);
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 304))(*(void *)(a1 + 112), 0);
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 368))(*(void *)(a1 + 112), 0);
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 224))(*(void *)(a1 + 112), 0);
            if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 272))(*(void *)(a1 + 112)))
            {
              v40 = operator new(0x10uLL);
              v63 = v40 + 2;
              v64 = v40 + 2;
              void *v40 = @"OTAActivation";
              v40[1] = @"SupportsColdSIMActivation";
              CFTypeRef cf = 0;
              *(void *)v62 = v40;
              char v41 = (std::mutex *)Registry::getServiceMap(v40 + 2, *(Registry **)(a1 + 80));
              uint64_t v42 = v41;
              if ((v43 & 0x8000000000000000) != 0)
              {
                v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v45 = 5381;
                do
                {
                  std::string::size_type v43 = v45;
                  unsigned int v46 = *v44++;
                  uint64_t v45 = (33 * v45) ^ v46;
                }
                while (v46);
              }
              std::mutex::lock(v41);
              v60.__r_.__value_.__r.__words[0] = v43;
              v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)&v60);
              if (v47)
              {
                uint64_t v49 = v47[3];
                v48 = (std::__shared_weak_count *)v47[4];
                if (v48)
                {
                  atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v42);
                  atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v48);
                  char v50 = 0;
                  goto LABEL_68;
                }
              }
              else
              {
                uint64_t v49 = 0;
              }
              std::mutex::unlock(v42);
              v48 = 0;
              char v50 = 1;
LABEL_68:
              (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint8_t *, const CFBooleanRef, void))(*(void *)v49 + 16))(&cf, v49, kCarrier1BundleId, v62, kCFBooleanFalse, 0);
              if ((v50 & 1) == 0) {
                sub_10004D2C8(v48);
              }
              v51 = (BOOL *)cf;
              v60.__r_.__value_.__s.__data_[0] = 0;
              if (cf)
              {
                CFTypeID v52 = CFGetTypeID(cf);
                if (v52 == CFBooleanGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v60, v51, v53);
                }
                if (v60.__r_.__value_.__s.__data_[0])
                {
                  char v54 = (*(unsigned int (**)(void))(**(void **)(a1 + 112) + 280))(*(void *)(a1 + 112)) == 1;
                  sub_100358C28((uint64_t)&event::activation::simRemoved, v54);
                }
              }
              sub_1000577C4(&cf);
              if (*(void *)v62)
              {
                v63 = *(void **)v62;
                operator delete(*(void **)v62);
              }
            }
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 288))(*(void *)(a1 + 112), 0);
            if (*(unsigned char *)(a1 + 132))
            {
              v55 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v62 = 0;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Ticket was previously rejected, attempting to unbrick", v62, 2u);
              }
              (*(void (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
            }
          }
          v56 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v62 = 0;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I The SIM state has gone to a non ready state, and marking SIM event as pending", v62, 2u);
          }
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 1);
          sub_100A7D170(a1);
        }
      }
      else
      {
        uint64_t v34 = *(void *)&buf[16];
        uint64_t v35 = *(void *)&buf[24];
        memset(&v60, 0, sizeof(v60));
        if (*(void *)&buf[16] != *(void *)&buf[24])
        {
          long long v36 = (char *)subscriber::asString();
          sub_10003ED78(&v60, v36);
          for (uint64_t i = v34 + 4; i != v35; i += 4)
          {
            HIBYTE(v64) = 1;
            strcpy((char *)v62, ",");
            std::string::append(&v60, (const std::string::value_type *)v62, 1uLL);
            if (SHIBYTE(v64) < 0) {
              operator delete(*(void **)v62);
            }
            v38 = (const char *)subscriber::asString();
            size_t v39 = strlen(v38);
            std::string::append(&v60, v38, v39);
          }
          if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v60.__r_.__value_.__l.__data_);
          }
        }
      }
      if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 152))(*(void *)(a1 + 112)) == 4) {
        int v57 = 0;
      }
      else {
        int v57 = isSimUnreadable;
      }
      if (v57 == 1)
      {
        v58 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v62 = 0;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Making the BB go online due to unreadable SIM", v62, 2u);
        }
        sub_100358C28((uint64_t)&event::activation::basebandActivated, 0);
      }
      goto LABEL_91;
    }
LABEL_25:
    unsigned int v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I SIM states haven't settled yet, waiting until they have", buf, 2u);
    }
  }
}

void sub_100A7AA28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27)
{
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  if (__p) {
    operator delete(__p);
  }
  sub_100086B34((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_100A7AAE8(uint64_t a1, void **a2)
{
  char v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *a2;
    }
    BOOL v6 = "true";
    if (!*((unsigned char *)a2 + 24)) {
      BOOL v6 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received request to reset BB (%s) want logs (%s)", buf, 0x16u);
  }
  (*(void (**)(void))(**(void **)(a1 + 112) + 216))(*(void *)(a1 + 112));
  dispatch_get_global_queue(0, 0);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(buf, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)a2;
    *(void *)&uint8_t buf[16] = a2[2];
  }
  char v8 = *((unsigned char *)a2 + 24);
  operator new();
}

void sub_100A7ACBC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A7ACC8(uint64_t a1, char a2)
{
  (*(void (**)(void))(**(void **)(a1 + 112) + 344))(*(void *)(a1 + 112));
  if ((a2 & 1) == 0)
  {
    char v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I All OTA activation assertions have been removed, kicking the state machine", v6, 2u);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 1);
    uint64_t v5 = (int *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112));
    sub_100A7B84C(a1, v5);
  }
}

uint64_t sub_100A7ADC4(uint64_t result, int a2)
{
  uint64_t v2 = result;
  if (a2 == 2)
  {
    BOOL v6 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Service provisioning has failed", v9, 2u);
    }
    (*(void (**)(void, void))(**(void **)(v2 + 112) + 224))(*(void *)(v2 + 112), 0);
    __n128 result = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 248))(*(void *)(v2 + 112));
    if (result)
    {
      uint64_t v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I There is a pending SIM event to process, querying BB for activation status", v8, 2u);
      }
      return (*(uint64_t (**)(void))(**(void **)(v2 + 96) + 40))(*(void *)(v2 + 96));
    }
  }
  else
  {
    if (a2 == 1)
    {
      uint64_t v5 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Service provisioning has ended", v10, 2u);
      }
      char v4 = *(uint64_t (**)(void))(**(void **)(v2 + 112) + 224);
    }
    else
    {
      if (a2) {
        return result;
      }
      uint64_t v3 = *(NSObject **)(result + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Service provisioning has started", buf, 2u);
      }
      char v4 = *(uint64_t (**)(void))(**(void **)(v2 + 112) + 224);
    }
    return v4();
  }
  return result;
}

void sub_100A7AFC0(uint64_t a1, int a2, int a3)
{
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Postponement status changing from %s to %s", buf, 0x16u);
  }
  if (a2 != 2 && a3 == 2)
  {
    *(unsigned char *)(a1 + 132) = 0;
    *(void *)long long buf = 0;
    DevicePersistentCopyValue((uint64_t *)v22, kPostponementTicketPlist, 0);
    sub_10004EFE4(buf, v22);
    sub_1000577C4(v22);
    if (*(void *)buf) {
      uint64_t v7 = sub_100080778;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      xpc_object_t v21 = *(const void **)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
      sub_100A7D2A0(a1, &v21);
      sub_100057D78(&v21);
      goto LABEL_37;
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 400))(*(void *)(a1 + 112)))
    {
      char v9 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 88))(*(void *)(a1 + 112));
      if (*v9 != v9[1])
      {
        uint64_t v10 = *(void *)(a1 + 96);
        uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 88))(*(void *)(a1 + 112));
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v11);
        ++*(_DWORD *)(a1 + 128);
LABEL_37:
        sub_100057D78((const void **)buf);
        return;
      }
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N No prepared ticket found", (uint8_t *)v22, 2u);
      }
      uint64_t v17 = *(void **)(a1 + 152);
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 400))(*(void *)(a1 + 112));
      char v18 = (void (**)(void *, uint64_t))(*v17 + 16);
    }
    else
    {
      unsigned int v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I No stored ticket found", (uint8_t *)v22, 2u);
      }
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 264))(*(void *)(a1 + 112));
      uint64_t v17 = *(void **)(a1 + 152);
      char v18 = (void (**)(void *, uint64_t))(*v17 + 32);
    }
    (*v18)(v17, v16);
    goto LABEL_37;
  }
  if (a3 == 3)
  {
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 440))(*(void *)(a1 + 112)) == 2)
    {
      if (*(unsigned char *)(a1 + 132))
      {
        char v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Ticket was previously rejected, wait for next sim activation", buf, 2u);
        }
      }
      else
      {
        *(unsigned char *)(a1 + 132) = 1;
        char v19 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Request to update baseband ticket", buf, 2u);
        }
        *(void *)long long buf = off_101A349F0;
        *(void *)&uint8_t buf[8] = a1;
        char v24 = buf;
        sub_100A794DC((void *)a1, 0, (uint64_t)buf);
        sub_100060644(buf);
      }
    }
    else
    {
      *(unsigned char *)(a1 + 132) = 1;
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Ticket was rejected, requesting reactivation", buf, 2u);
      }
      uint64_t v13 = *(void *)(a1 + 152);
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 400))(*(void *)(a1 + 112));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 16))(v13, v14);
    }
  }
  else
  {
    if (a2 == 3) {
      *(unsigned char *)(a1 + 132) = 0;
    }
    if (a3 == 4) {
      (*(void (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
    }
  }
}

void sub_100A7B540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100A7B59C(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 112) + 96))(*(void *)(a1 + 112));
  (*(void (**)(void))(**(void **)(a1 + 152) + 48))(*(void *)(a1 + 152));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 132)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fTicketPreviouslyRejected = %s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_100A7B6A4(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 224);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 == a2)
  {
    if (v6)
    {
      int v8 = 136315138;
      uint64_t v9 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Preferred data slot remains at %s", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    if (v6)
    {
      int v8 = 136315394;
      uint64_t v9 = subscriber::asString();
      __int16 v10 = 2080;
      uint64_t v11 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Preferred data slot changed from %s to %s", (uint8_t *)&v8, 0x16u);
      int v4 = *(_DWORD *)(a1 + 224);
    }
    if (v4)
    {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 1);
      (*(void (**)(void))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96));
      uint64_t v7 = (int *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112));
      sub_100A7B84C(a1, v7);
    }
  }
}

void sub_100A7B84C(uint64_t a1, int *a2)
{
  uint64_t v3 = *a2;
  if (v3 > 2) {
    int v4 = 0;
  }
  else {
    int v4 = dword_101530D9C[v3];
  }
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 152))(*(void *)(a1 + 112));
  int v6 = *(_DWORD *)((*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112)) + 4);
  int v7 = a2[1];
  int v8 = *(unsigned __int8 *)((*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112))
                          + 8);
  int v9 = *((unsigned __int8 *)a2 + 8);
  int v10 = *(unsigned __int8 *)((*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112))
                           + 9);
  int v11 = *((unsigned __int8 *)a2 + 9);
  (*(void (**)(void, int *))(**(void **)(a1 + 112) + 120))(*(void *)(a1 + 112), a2);
  uint64_t v12 = *(NSObject **)(a1 + 40);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  BOOL v14 = v5 == v4 && v6 == v7;
  int v80 = v9;
  BOOL v15 = v14 && v8 == v9;
  int v78 = v11;
  int v79 = v10;
  if (v15 && v10 == v11)
  {
    if (v13)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I State has not changed, but we have pending SIM event to process", buf, 2u);
    }
  }
  else
  {
    if (v13)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I State has not changed but we support async activation, process it", buf, 2u);
    }
    if (capabilities::ct::getCardProvisioningStatusVersion((capabilities::ct *)v13) != 1)
    {
      subscriber::makeSimSlotRange();
      char v18 = *(unsigned int **)buf;
      uint64_t v17 = *(unsigned int **)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        char v19 = v83;
        while ((v19(*v18) & 1) == 0)
        {
          if (++v18 == v17)
          {
            char v18 = v17;
            break;
          }
        }
        uint64_t v20 = *(unsigned int **)&buf[8];
        if (v18 != *(unsigned int **)&buf[8])
        {
          v75 = *(unsigned int **)&buf[8];
          while (1)
          {
            uint64_t v21 = *v18;
            BOOL v22 = v21 != 2 || v79 == v78;
            BOOL v23 = v22;
            BOOL v24 = v8 != v80 && v21 == 1;
            if (v24 || !v23) {
              break;
            }
            uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *v18);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v84 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Not handling service provisioned change", v84, 2u);
            }
LABEL_65:
            v48 = v18 + 1;
            char v18 = v17;
            if (v48 != v17)
            {
              char v18 = v48;
              while ((v19(*v18) & 1) == 0)
              {
                if (++v18 == v17)
                {
                  char v18 = v17;
                  break;
                }
              }
            }
            if (v18 == v20) {
              goto LABEL_74;
            }
          }
          if (v21 == 1) {
            char v26 = v80;
          }
          else {
            char v26 = v78;
          }
          unsigned __int8 v27 = v26 - 1;
          if (v27 > 2u) {
            unsigned int v76 = 0;
          }
          else {
            unsigned int v76 = dword_101530DA8[(char)v27];
          }
          long long v30 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v21);
          uint64_t v31 = *v30;
          BOOL v32 = os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT);
          if (v32)
          {
            uint64_t v33 = subscriber::asString();
            *(_DWORD *)v84 = 136315138;
            *(void *)&v84[4] = v33;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Received card provisioning status: %s", v84, 0xCu);
          }
          if (capabilities::ct::getCardProvisioningStatusVersion((capabilities::ct *)v32) == 1) {
            (*(void (**)(void, void))(**(void **)(a1 + 112) + 368))(*(void *)(a1 + 112), v76);
          }
          int v34 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 208))(*(void *)(a1 + 112));
          uint64_t v35 = *v30;
          BOOL v36 = os_log_type_enabled(*v30, OS_LOG_TYPE_DEFAULT);
          if (!v34)
          {
            if (v36)
            {
              *(_WORD *)v84 = 0;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Baseband is not activated, delaying the card provisioned state notification", v84, 2u);
            }
            goto LABEL_65;
          }
          if (v36)
          {
            *(_WORD *)v84 = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Baseband is activated, notifying the card provisioned state now", v84, 2u);
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap(v37, *(Registry **)(a1 + 80));
          size_t v39 = ServiceMap;
          if (v40 < 0)
          {
            char v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v42 = 5381;
            do
            {
              uint64_t v40 = v42;
              unsigned int v43 = *v41++;
              uint64_t v42 = (33 * v42) ^ v43;
            }
            while (v43);
          }
          std::mutex::lock(ServiceMap);
          *(void *)v84 = v40;
          v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)v84);
          if (v44)
          {
            uint64_t v46 = v44[3];
            uint64_t v45 = (std::__shared_weak_count *)v44[4];
            if (v45)
            {
              atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v39);
              atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v20 = v75;
              sub_10004D2C8(v45);
              char v47 = 0;
              goto LABEL_63;
            }
          }
          else
          {
            uint64_t v46 = 0;
          }
          std::mutex::unlock(v39);
          uint64_t v45 = 0;
          char v47 = 1;
LABEL_63:
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v46 + 16))(v46, v21, v76);
          if ((v47 & 1) == 0) {
            sub_10004D2C8(v45);
          }
          goto LABEL_65;
        }
      }
    }
  }
LABEL_74:
  (*(void (**)(void, void))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 0);
  memset(buf, 0, sizeof(buf));
  v83 = 0;
  if (!*a2)
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 144))(*(void *)(a1 + 112), 4);
    if ((a2[1] | 2) != 2)
    {
      v73 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v84 = 0;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#N Baseband activation result is unexpected!", v84, 2u);
      }
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 352))(*(void *)(a1 + 112)))
    {
      v56 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v84 = 0;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Baseband is activated, but we still have active OTA assertions. Dropping activated state", v84, 2u);
      }
      goto LABEL_88;
    }
    if (!*(unsigned char *)((*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112)) + 456))
    {
      v74 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v84 = 0;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I BB activated, but there is no SIM, making the BB go online", v84, 2u);
      }
      sub_100358C28((uint64_t)&event::activation::basebandActivated, 1);
      goto LABEL_89;
    }
    if (sub_100A7C67C(a1)) {
      goto LABEL_89;
    }
    uint64_t v57 = *(void *)(a1 + 136);
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 112) + 48))(&v81);
    (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v57 + 48))(v57, 2, &v81);
    sub_100057D78(&v81);
    v58 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 360))(*(void *)(a1 + 112));
    if (capabilities::ct::getCardProvisioningStatusVersion(v58) != 1 || !v58) {
      goto LABEL_89;
    }
    char v59 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = subscriber::asString();
      *(_DWORD *)v84 = 136315138;
      *(void *)&v84[4] = v61;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Baseband has moved to activated state, notifying card provisioned state: %s", v84, 0xCu);
    }
    v62 = (std::mutex *)Registry::getServiceMap(v60, *(Registry **)(a1 + 80));
    v63 = v62;
    if (v64 < 0)
    {
      v65 = (unsigned __int8 *)(v64 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v66 = 5381;
      do
      {
        uint64_t v64 = v66;
        unsigned int v67 = *v65++;
        uint64_t v66 = (33 * v66) ^ v67;
      }
      while (v67);
    }
    std::mutex::lock(v62);
    *(void *)v84 = v64;
    v68 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)v84);
    if (v68)
    {
      uint64_t v70 = v68[3];
      v69 = (std::__shared_weak_count *)v68[4];
      if (v69)
      {
        atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v63);
        atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v69);
        char v71 = 0;
        goto LABEL_125;
      }
    }
    else
    {
      uint64_t v70 = 0;
    }
    std::mutex::unlock(v63);
    v69 = 0;
    char v71 = 1;
LABEL_125:
    (*(void (**)(uint64_t, uint64_t, capabilities::ct *))(*(void *)v70 + 16))(v70, 1, v58);
    if ((v71 & 1) == 0) {
      sub_10004D2C8(v69);
    }
    goto LABEL_89;
  }
  if (*a2 != 1)
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 144))(*(void *)(a1 + 112), 5);
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 168))(*(void *)(a1 + 112), 1);
LABEL_88:
    sub_100A7D024();
    goto LABEL_89;
  }
  int v49 = a2[1];
  if (v49 == 1)
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 144))(*(void *)(a1 + 112), 3);
    sub_100A7C518(a1);
    if (*((unsigned char *)a2 + 456))
    {
      if (!*((unsigned char *)a2 + 517) || *((unsigned char *)a2 + 516))
      {
        if (!*((unsigned char *)a2 + 519) || *((unsigned char *)a2 + 518)) {
          goto LABEL_89;
        }
        sub_100A7D0BC((uint64_t *)v84, (unsigned char *)a2 + 280, v72);
      }
      else
      {
        sub_100A7D0BC((uint64_t *)v84, (unsigned char *)a2 + 104, v72);
      }
      *(_OWORD *)long long buf = *(_OWORD *)v84;
      v83 = v85;
    }
  }
  else
  {
    if (v49 != 2) {
      goto LABEL_89;
    }
    uint64_t v50 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112));
    uint64_t v51 = **(void **)(a1 + 112);
    if (!(*(unsigned __int8 *)(v50 + 88) | *(unsigned __int8 *)(v50 + 456)))
    {
      (*(void (**)(void))(v51 + 144))();
      v55 = (void (**)(void))(**(void **)(a1 + 112) + 168);
LABEL_114:
      (*v55)();
      sub_100A7D024();
      goto LABEL_89;
    }
    int v52 = (*(uint64_t (**)(void))(v51 + 376))();
    CFBooleanRef v53 = *(NSObject **)(a1 + 40);
    BOOL v54 = os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT);
    if (v52)
    {
      if (v54)
      {
        *(_WORD *)v84 = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Ticket is present", v84, 2u);
      }
      v55 = (void (**)(void))(**(void **)(a1 + 112) + 144);
      goto LABEL_114;
    }
    if (v54)
    {
      *(_WORD *)v84 = 0;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Ticket is not present", v84, 2u);
    }
    if ((sub_100A7C67C(a1) & 1) == 0) {
      sub_100A7C518(a1);
    }
  }
LABEL_89:
  (*(void (**)(void, uint8_t *))(**(void **)(a1 + 112) + 136))(*(void *)(a1 + 112), buf);
  if (SHIBYTE(v83) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100A7C490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100A7C518(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I sending kDefaultCarrierActivationInfoAvailable", buf, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 136);
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 112) + 48))(&v5);
  (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v3 + 48))(v3, 1, &v5);
  return sub_100057D78(&v5);
}

void sub_100A7C5E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A7C5F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 96);
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(v1 + 112) + 88))(*(void *)(v1 + 112));
  int v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 48);

  return v4(v2, v3);
}

uint64_t sub_100A7C67C(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 272))(*(void *)(a1 + 112));
  uint64_t v3 = **(void **)(a1 + 112);
  if (v2)
  {
    int isSimReady = *(unsigned char *)((*(uint64_t (**)(void))(v3 + 128))() + 456) != 0;
  }
  else
  {
    (*(void (**)(void))(v3 + 192))();
    int isSimReady = subscriber::isSimReady();
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 272))(*(void *)(a1 + 112))) {
    BOOL v5 = isSimReady == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  CFTypeRef cf = 0;
  uint64_t v6 = *(void *)(a1 + 136);
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 112) + 48))(&v54);
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, const void **, void))(*(void *)v6 + 40))(buf, v6, 1, &v54, 0);
  sub_10004EFE4(&cf, (CFTypeRef *)buf);
  sub_10005717C((const void **)buf);
  sub_100057D78(&v54);
  *(_OWORD *)v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)std::string v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  *(_OWORD *)char v59 = 0u;
  *(_OWORD *)long long buf = 0u;
  *(_OWORD *)uint64_t v57 = 0u;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 80));
  int v9 = ServiceMap;
  if (v10 < 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v10;
  BOOL v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  uint64_t v16 = v14[3];
  BOOL v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_15:
    std::mutex::unlock(v9);
    BOOL v15 = 0;
    char v17 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_16:
  CFTypeRef v53 = cf;
  if (cf) {
    CFRetain(cf);
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, CFTypeRef *))(*(void *)v16 + 24))(buf, v16, &v53);
  sub_100057D78(&v53);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  uint64_t v18 = HIBYTE(v57[0]);
  if (SHIBYTE(v57[0]) < 0) {
    uint64_t v18 = *(void *)&buf[8];
  }
  if (!v18)
  {
    LODWORD(v24) = 0;
    goto LABEL_49;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v52 = 0;
  if (SHIBYTE(v60[0]) >= 0) {
    size_t v19 = HIBYTE(v60[0]);
  }
  else {
    size_t v19 = (size_t)v59[1];
  }
  uint64_t v20 = __p;
  sub_1000C140C((uint64_t)__p, v19 + 14);
  if (v52 < 0) {
    uint64_t v20 = (void **)__p[0];
  }
  if (v19)
  {
    if (SHIBYTE(v60[0]) >= 0) {
      uint64_t v21 = v59;
    }
    else {
      uint64_t v21 = (void **)v59[0];
    }
    memmove(v20, v21, v19);
  }
  strcpy((char *)v20 + v19, "/carrier.plist");
  CFDictionaryRef theDict = 0;
  uint64_t v50 = &off_101A0BD40;
  sub_1007EDF30(kCFAllocatorDefault, (uint64_t)__p, &theDict);
  if (theDict) {
    BOOL v22 = sub_100080778;
  }
  else {
    BOOL v22 = 0;
  }
  if (v22)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"OTAActivation");
    CFDictionaryRef v24 = Value;
    if (!Value) {
      goto LABEL_46;
    }
    CFTypeID v25 = CFGetTypeID(Value);
    if (v25 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef v26 = (const __CFDictionary *)CFDictionaryGetValue(v24, @"SupportsColdSIMActivation");
      CFDictionaryRef v24 = v26;
      v48[0] = 0;
      if (!v26) {
        goto LABEL_46;
      }
      CFTypeID v27 = CFGetTypeID(v26);
      if (v27 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)v48, (BOOL *)v24, v28);
        if (v48[0])
        {
          unsigned int v29 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v48 = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Bundle supports cold SIM activation", v48, 2u);
          }
          LODWORD(v24) = 1;
          goto LABEL_46;
        }
      }
    }
  }
  LODWORD(v24) = 0;
LABEL_46:
  sub_100057D78((const void **)&theDict);
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v50);
  if (SHIBYTE(v52) < 0) {
    operator delete(__p[0]);
  }
LABEL_49:
  if (SBYTE7(v63) < 0) {
    operator delete(v62[0]);
  }
  if (SHIBYTE(v61) < 0) {
    operator delete(v60[1]);
  }
  if (SHIBYTE(v60[0]) < 0) {
    operator delete(v59[0]);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete(v57[1]);
  }
  if (SHIBYTE(v57[0]) < 0) {
    operator delete(*(void **)buf);
  }
  sub_100057D78(&cf);
  uint64_t v30 = **(void **)(a1 + 112);
  if (!v24)
  {
    (*(void (**)(void))(v30 + 288))();
    return 0;
  }
  if ((*(unsigned int (**)(void))(v30 + 280))()) {
    return 0;
  }
  uint64_t v31 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Going to detect SIM provisioned state", buf, 2u);
  }
  int v32 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 296))(*(void *)(a1 + 112));
  uint64_t v33 = *(NSObject **)(a1 + 40);
  BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
  if (!v32)
  {
    if (v34)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Phone number is not available now, pending MDN request", buf, 2u);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 320))(*(void *)(a1 + 112), 1);
    return 1;
  }
  if (v34)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Phone number is available now, detecting SIM provisioned state", buf, 2u);
  }
  uint64_t v35 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 336))(*(void *)(a1 + 112));
  BOOL v36 = (char *)v35;
  if ((*(char *)(v35 + 23) & 0x80000000) == 0)
  {
    uint64_t v37 = *(unsigned __int8 *)(v35 + 23);
    if (!*(unsigned char *)(v35 + 23)) {
      goto LABEL_87;
    }
LABEL_76:
    if (v37 >= 3)
    {
      size_t v39 = &v36[v37];
      uint64_t v40 = v36;
      do
      {
        char v41 = (char *)memchr(v40, 48, v37 - 2);
        if (!v41) {
          break;
        }
        if (*(_WORD *)v41 == 12336 && v41[2] == 48)
        {
          int v43 = 1;
          if (v41 == v39 || v41 != v36) {
            goto LABEL_88;
          }
          goto LABEL_87;
        }
        uint64_t v40 = v41 + 1;
        uint64_t v37 = v39 - v40;
      }
      while (v39 - v40 >= 3);
    }
    int v43 = 1;
    goto LABEL_88;
  }
  uint64_t v37 = *(void *)(v35 + 8);
  if (v37)
  {
    BOOL v36 = *(char **)v35;
    goto LABEL_76;
  }
LABEL_87:
  int v43 = 0;
LABEL_88:
  v44 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v45 = "false";
    if (v43) {
      uint64_t v45 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v45;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Detected SIM provisioned state as: %s", buf, 0xCu);
  }
  (*(void (**)(void))(**(void **)(a1 + 112) + 288))();
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 112) + 152))() == 3)
  {
    uint64_t v46 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Current ticket state is rejected, going to setup kDefaultCarrierActivationInfoAvailable", buf, 2u);
    }
    sub_100A7C518(a1);
  }
  else
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 240))(*(void *)(a1 + 112), 1);
    (*(void (**)(void))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96));
    uint64_t v47 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))();
    sub_100A7B84C(a1, v47);
  }
  return 1;
}

void sub_100A7CF7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,const void *a28,__int16 a29,char a30,char a31)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10039A890((uint64_t)&a29);
  sub_100057D78(&a28);
  _Unwind_Resume(a1);
}

void sub_100A7D024()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(113, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_100A7D090(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A7D0BC(uint64_t *result, unsigned char *a2, unint64_t a3)
{
  *__n128 result = 0;
  result[1] = 0;
  result[2] = 0;
  if (a2[168]) {
    BOOL v3 = a2[19] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    int v4 = result;
    __n128 result = ctu::hex((uint64_t *)&v9, (ctu *)(a2 + 9), (const void *)0xA, a3);
    *(_OWORD *)int v4 = v9;
    void v4[2] = v10;
    if (*((char *)v4 + 23) < 0)
    {
      int v8 = (uint64_t *)*v4;
      uint64_t v7 = v4[1];
      if (*(unsigned char *)(*v4 + v7 - 1) != 102) {
        return result;
      }
      uint64_t v6 = v7 - 1;
      v4[1] = v6;
      int v4 = v8;
    }
    else
    {
      uint64_t v5 = *((unsigned __int8 *)v4 + 23);
      if (*((unsigned char *)v4 + v5 - 1) != 102) {
        return result;
      }
      uint64_t v6 = v5 - 1;
      *((unsigned char *)v4 + 23) = v6 & 0x7F;
    }
    *((unsigned char *)v4 + v6) = 0;
  }
  return result;
}

void sub_100A7D170(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 256))(*(void *)(a1 + 112));
  BOOL v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reached steady state, querying activation status from BB", buf, 2u);
    }
    (*(void (**)(void))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96));
    uint64_t v5 = (int *)(*(uint64_t (**)(void))(**(void **)(a1 + 112) + 128))(*(void *)(a1 + 112));
    sub_100A7B84C(a1, v5);
  }
  else if (v4)
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I We don't have steady state, ignoring SIM event for now", v6, 2u);
  }
}

const void **sub_100A7D2A0(uint64_t a1, const void **a2)
{
  CFBooleanRef v20 = 0;
  DevicePersistentCopyValue((uint64_t *)buf, kPostponementTicketLock, kCFBooleanFalse);
  sub_1000057AC(&v20, buf);
  sub_1000577C4(buf);
  if (v20 == kCFBooleanTrue)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return sub_100062778((const void **)&v20);
    }
    LOWORD(buf[0]) = 0;
    long long v9 = "#I Aborting ticket push because ticket lock is enabled";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)buf, 2u);
    return sub_100062778((const void **)&v20);
  }
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 112) + 264))(*(void *)(a1 + 112)) & 1) == 0)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return sub_100062778((const void **)&v20);
    }
    LOWORD(buf[0]) = 0;
    long long v9 = "#I Aborting ticket push because BB activation not enabled";
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(a1 + 112);
  sub_100058198(&v18, a2);
  LOBYTE(v4) = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v4 + 80))(v4, &v18);
  sub_100057D78(&v18);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Issuing stored ticket", (uint8_t *)buf, 2u);
    }
    uint64_t v6 = *(void *)(a1 + 96);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 88))(*(void *)(a1 + 112));
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v7))
    {
      ++*(_DWORD *)(a1 + 128);
    }
    else
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Failed to issue a ticket", (uint8_t *)buf, 2u);
      }
      uint64_t v13 = *(void *)(a1 + 152);
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 400))(*(void *)(a1 + 112));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 16))(v13, v14);
    }
    uint64_t v15 = *(void *)(a1 + 168);
    if (!v15)
    {
      int v8 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        return sub_100062778((const void **)&v20);
      }
      LOWORD(buf[0]) = 0;
      long long v9 = "#I No Activation push controller";
      goto LABEL_12;
    }
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v15 + 48))(v15))
    {
      uint64_t v16 = *(void *)(a1 + 168);
      v21[0] = off_101A34A70;
      v21[1] = a1;
      v21[3] = v21;
      (*(void (**)(uint64_t, void *))(*(void *)v16 + 40))(v16, v21);
      sub_10003B34C(v21);
      (*(void (**)(void))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168));
      return sub_100062778((const void **)&v20);
    }
    int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      long long v9 = "#I Activation Push token is registered";
      goto LABEL_12;
    }
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to prepare ticket", (uint8_t *)buf, 2u);
    }
    uint64_t v10 = *(void *)(a1 + 152);
    uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 400))(*(void *)(a1 + 112));
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 16))(v10, v11);
  }
  return sub_100062778((const void **)&v20);
}

void sub_100A7D72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, const void *);
  sub_10003B34C((uint64_t *)va1);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100A7D77C(uint64_t a1)
{
  xpc_object_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7D870(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A7D8A8(uint64_t a1)
{
}

uint64_t sub_100A7D8C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A7D908(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100A7D934(ServiceManager::Service *this)
{
  *(void *)this = off_101A33D68;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100A7D990(ServiceManager::Service *this)
{
  *(void *)this = off_101A33D68;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100A7DA00@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "Activation");
}

unsigned char *sub_100A7DA10@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  *int v2 = 3;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100A7DA50(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  BOOL v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100A78430(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100A78430(v4, 0);
}

uint64_t sub_100A7DAD4()
{
  return 0;
}

uint64_t sub_100A7DADC()
{
  return 1;
}

uint64_t sub_100A7DAE4()
{
  return 0;
}

void sub_100A7DAF0(uint64_t a1)
{
  xpc_object_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7DBD0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7DCE8()
{
}

uint64_t sub_100A7DCFC(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100A7DD08(void **a1)
{
  xpc_object_t v1 = *a1;
  uint64_t v16 = a1;
  char v17 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 112);
  uint64_t v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    if (*(void *)buf) {
      dispatch_group_enter(*(dispatch_group_t *)buf);
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  uint64_t v6 = *(void *)(v2 + 136);
  uint64_t v7 = v1[1];
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(group);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 32))(v6, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v8 = *(void *)(v2 + 96);
  long long v9 = v1[1];
  dispatch_group_t object = v9;
  if (v9)
  {
    dispatch_retain(v9);
    dispatch_group_enter(object);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v8 + 32))(v8, &object);
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  uint64_t v10 = *(void *)(v2 + 152);
  uint64_t v11 = v1[1];
  dispatch_group_t v19 = v11;
  if (v11)
  {
    dispatch_retain(v11);
    dispatch_group_enter(v11);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v10 + 72))(v10, &v19);
  if (v19)
  {
    dispatch_group_leave(v19);
    if (v19) {
      dispatch_release(v19);
    }
  }
  uint64_t v12 = *(void *)(v2 + 168);
  if (v12)
  {
    uint64_t v13 = v1[1];
    dispatch_group_t v18 = v13;
    if (v13)
    {
      dispatch_retain(v13);
      dispatch_group_enter(v13);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v12 + 24))(v12, &v18);
    if (v18)
    {
      dispatch_group_leave(v18);
      if (v18) {
        dispatch_release(v18);
      }
    }
  }
  for (uint64_t i = *(void *)(v2 + 64); i != v2 + 56; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 56));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 184));
  sub_100088C88((uint64_t *)&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_100A7DFB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t a12, dispatch_group_t a13, dispatch_group_t a14, dispatch_group_t a15)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100A7E064(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)(v1 + 8);
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  uint64_t v3 = operator new(0x28uLL);
  *uint64_t v3 = off_101A34278;
  v3[1] = v2 + 200;
  v3[2] = v2;
  v3[3] = sub_100A79F4C;
  v3[4] = 0;
  *((void *)&v13 + 1) = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v12);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(NSObject **)(v2 + 24);
      dispatch_retain(v7);
      long long v12 = 0u;
      long long v13 = 0u;
      dispatch_retain(v7);
      dispatch_retain(v7);
      dispatch_retain(v7);
      dispatch_retain(v7);
      dispatch_retain(v7);
      dispatch_retain(v7);
      dispatch_retain(v7);
      __p[1] = v7;
      uint64_t v11 = v2;
      dispatch_retain(v7);
      dispatch_release(v7);
      dispatch_release(v7);
      dispatch_release(v7);
      __p[0] = off_101A34400;
      dispatch_release(v7);
      dispatch_release(v7);
      sub_100A82AD0((uint64_t *)__p, (uint64_t *)&v13 + 1);
      sub_100A83014((uint64_t *)__p);
      dispatch_release(v7);
      dispatch_release(v7);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A7EDE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t *a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_group_t group,uint64_t a23,dispatch_group_t object,uint64_t a25,dispatch_group_t a26,uint64_t a27,dispatch_group_t a28,uint64_t a29,dispatch_group_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,std::__shared_weak_count *a35,int a36,__int16 a37,char a38,char a39)
{
  sub_10003F600((void *)(v39 - 176));
  if (a39 < 0) {
    operator delete(__p);
  }
  sub_10062AF08(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100A7F170(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A33E28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A7F190(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A33E28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A7F1E4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100A7F20C(ActivationCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A33EE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ActivationCommandDriverDelegateInterface::~ActivationCommandDriverDelegateInterface(this);
}

void sub_100A7F268(ActivationCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A33EE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ActivationCommandDriverDelegateInterface::~ActivationCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100A7F2D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = "not ";
          if (a2) {
            uint64_t v9 = "";
          }
          int v12 = 136315138;
          long long v13 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Command driver is %sready", (uint8_t *)&v12, 0xCu);
        }
        (*(void (**)(void, uint64_t))(**(void **)(v7 + 112) + 104))(*(void *)(v7 + 112), a2);
        if (a2)
        {
          if ((*(unsigned int (**)(void))(**(void **)(v7 + 112) + 248))(*(void *)(v7 + 112)))
          {
            uint64_t v10 = *(NSObject **)(v7 + 40);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v12) = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I The command driver is ready and we have a pending SIM event, querying the activation status", (uint8_t *)&v12, 2u);
            }
            (*(void (**)(void))(**(void **)(v7 + 96) + 40))(*(void *)(v7 + 96));
          }
        }
        else
        {
          uint64_t v11 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v12) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I The command driver is not ready, clearing state", (uint8_t *)&v12, 2u);
          }
          (*(void (**)(void, void))(**(void **)(v7 + 112) + 144))(*(void *)(v7 + 112), 0);
          *(_DWORD *)(v7 + 128) = 0;
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A7F524(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A7F538(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7 && a2 == 1)
      {
        if (HIDWORD(a2) == 4)
        {
          *(_DWORD *)(v7 + 128) = 0;
          uint64_t v16 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(block[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Command driver response was cancelled", (uint8_t *)block, 2u);
          }
        }
        else if (HIDWORD(a2) == 2)
        {
          *(_DWORD *)(v7 + 128) = 0;
          uint64_t v15 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            LOWORD(block[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Missing activation/provisioning status", (uint8_t *)block, 2u);
          }
        }
        else if (HIDWORD(a2) == 1 && *(_DWORD *)(v7 + 128) == 1)
        {
          v17[0] = _NSConcreteStackBlock;
          v17[1] = 0x40000000;
          v17[2] = sub_100A7C5F8;
          v17[3] = &unk_101A33C10;
          v17[4] = v7;
          uint64_t v8 = *(std::__shared_weak_count **)(v7 + 16);
          if (!v8 || (v9 = *(void *)(v7 + 8), (uint64_t v10 = std::__shared_weak_count::lock(v8)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v11 = v10;
          int v12 = *(NSObject **)(v7 + 24);
          block[0] = _NSConcreteStackBlock;
          block[1] = 1174405120;
          block[2] = sub_100A84F84;
          block[3] = &unk_101A34930;
          block[5] = v9;
          dispatch_group_t v19 = v11;
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          block[4] = v17;
          dispatch_async(v12, block);
          if (v19) {
            sub_10004D2C8(v19);
          }
          sub_10004D2C8(v11);
        }
        else
        {
          *(_DWORD *)(v7 + 128) = 0;
          (*(void (**)(void, uint64_t))(**(void **)(v7 + 112) + 144))(*(void *)(v7 + 112), 3);
          long long v13 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(block[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N Ticket rejected", (uint8_t *)block, 2u);
          }
          if ((sub_100A7C67C(v7) & 1) == 0)
          {
            uint64_t v14 = *(NSObject **)(v7 + 40);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(block[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Going to setup kDefaultCarrierActivationInfoAvailable", (uint8_t *)block, 2u);
            }
            sub_100A7C518(v7);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A7F810(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A7F824(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(void, uint64_t))(**(void **)(v7 + 112) + 112))(*(void *)(v7 + 112), a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A7F8BC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A7F8D0(uint64_t a1, int *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        sub_100A7B84C(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A7F944(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A7F958(ActivationCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A33EE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ActivationCommandDriverDelegateInterface::~ActivationCommandDriverDelegateInterface(this);
}

void sub_100A7F9B4(ActivationCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A33EE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ActivationCommandDriverDelegateInterface::~ActivationCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100A7FA24(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", (uint8_t *)&buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&buf, *(Registry **)(v1 + 80));
  ctu::RestModule::connect();
  if (v4) {
    sub_10004D2C8(v4);
  }
  (*(void (**)(void))(**(void **)(v1 + 96) + 24))(*(void *)(v1 + 96));
  (*(void (**)(void))(**(void **)(v1 + 152) + 64))(*(void *)(v1 + 152));
  (*(void (**)(void))(**(void **)(v1 + 112) + 24))(*(void *)(v1 + 112));
  (*(void (**)(void))(**(void **)(v1 + 136) + 24))(*(void *)(v1 + 136));
  operator delete();
}

void sub_100A7FB7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

const void **sub_100A7FBBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(v1 + 8) + 112) + 40))(&v5);
  uint64_t v2 = *(const void ***)v1;
  if (*(const void ***)v1 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

void sub_100A7FC4C(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v2 = (uint64_t)v1[1];
  int v3 = **v1;
  uint64_t v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I FactoryActivation enabled, preparing ticket in memory but not writing to disk", buf, 2u);
    }
    uint64_t v6 = *(void *)(v2 + 112);
    sub_100058198(&v16, (const void **)v1[2]);
    int v7 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v6 + 80))(v6, &v16);
    sub_100057D78(&v16);
    uint64_t v8 = *(NSObject **)(v2 + 40);
    if (v7)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I prepared ticket successfully, will issue when BB is ready", buf, 2u);
      }
    }
    else
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to prepare the ticket", buf, 2u);
      }
      (*(void (**)(void, void))(**(void **)(v2 + 152) + 16))(*(void *)(v2 + 152), **v1);
    }
  }
  else
  {
    if (v5)
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Client is setting postponement ticket", buf, 2u);
    }
    DevicePersistentSaveValue(kPostponementTicketPlist, *(const void **)v1[2]);
    DevicePersistentSaveValue(kPostponementTicketObliterated, 0);
    _CFPreferencesFlushCachesForIdentifier();
  }
  if ((*(unsigned int (**)(void))(**(void **)(v2 + 112) + 152))(*(void *)(v2 + 112)) == 2) {
    goto LABEL_17;
  }
  if ((*(unsigned int (**)(void))(**(void **)(v2 + 112) + 152))(*(void *)(v2 + 112)) == 3)
  {
    uint64_t v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I let's try sending the ticket again", buf, 2u);
    }
LABEL_17:
    sub_100058198((const void **)buf, (const void **)v1[2]);
    sub_100A7D2A0(v2, (const void **)buf);
    sub_100057D78((const void **)buf);
    goto LABEL_18;
  }
  if (*(unsigned char *)(v2 + 133))
  {
    if (!*(unsigned char *)(v2 + 264))
    {
      *(unsigned char *)(v2 + 264) = 1;
      uint64_t v10 = *(void *)(v2 + 256);
      if (v10) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v2 + 264);
      }
    }
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Resetting baseband to update new ticket", buf, 2u);
    }
    sub_100058DB0(&__p, "Activation Ticket Updated");
    rest::ResetPayload::ResetPayload();
    sub_1004BC4DC();
    if (v15 < 0) {
      operator delete(*(void **)buf);
    }
    if (v13 < 0) {
      operator delete(__p);
    }
  }
LABEL_18:
  *(unsigned char *)(v2 + 133) = 0;
}

void sub_100A7FFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A80034(uint64_t **a1)
{
  uint64_t v6 = a1;
  uint64_t v1 = **a1;
  if ((*(unsigned int (**)(void))(**(void **)(v1 + 112) + 152))(*(void *)(v1 + 112)) == 2)
  {
    uint64_t v8 = 0;
    DevicePersistentCopyValue((uint64_t *)buf, kPostponementTicketPlist, 0);
    sub_10004EFE4(&v8, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    uint64_t v2 = v8;
    if (v8) {
      int v3 = sub_100080778;
    }
    else {
      int v3 = 0;
    }
    uint64_t v4 = *(NSObject **)(v1 + 40);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v5)
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Pushing ticket after unlock", buf, 2u);
        uint64_t v2 = v8;
      }
      *(void *)uint64_t buf = v2;
      if (v2) {
        CFRetain(v2);
      }
      sub_100A7D2A0(v1, (const void **)buf);
      sub_100057D78((const void **)buf);
    }
    else if (v5)
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I No cached ticket found after unlock", buf, 2u);
    }
    sub_100057D78(&v8);
  }
  operator delete();
}

void sub_100A801B4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v2 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  operator delete();
}

const void **sub_100A80208(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(v1 + 8) + 112) + 48))(&v5);
  uint64_t v2 = *(const void ***)v1;
  if (*(const void ***)v1 != &v5)
  {
    int v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    BOOL v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

uint64_t sub_100A80298(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v1, *(Registry **)(*v1 + 80));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = (CarrierBundleInterface *)v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  CarrierBundleTechType = (capabilities::ct *)CarrierBundleInterface::getCarrierBundleTechType(v11);
  if (CarrierBundleTechType == 2)
  {
    if ((v12 & 1) == 0) {
      sub_10004D2C8(v10);
    }
    return 1;
  }
  if (capabilities::ct::getCardProvisioningStatusVersion(CarrierBundleTechType) == 1)
  {
    char v14 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 64))(*(void *)(v2 + 112));
    if ((v12 & 1) == 0) {
      sub_10004D2C8(v10);
    }
    if (v14) {
      return 1;
    }
  }
  else if ((v12 & 1) == 0)
  {
    sub_10004D2C8(v10);
  }
  return 0;
}

void sub_100A803F0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A80408(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 56))();
}

uint64_t sub_100A80438(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 64))();
}

uint64_t sub_100A80468(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 200))();
}

uint64_t sub_100A80498(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 208))();
}

uint64_t sub_100A804C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 264))();
}

uint64_t *sub_100A80500(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  char v2 = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 112) + 376))(*(void *)(*(void *)v1 + 112));
  sub_1000607A8(v1 + 8, v2);
  sub_1003F5954(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100A8057C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100A80598(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 392))();
}

uint64_t *sub_100A805D0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  char v2 = *(void **)v1;
  int v3 = *(unsigned __int8 *)(v1 + 8);
  sub_1000DFC90((uint64_t)v7, v1 + 16);
  sub_100A794DC(v2, v3 != 0, (uint64_t)v7);
  sub_100060644(v7);
  sub_100494E40(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100A80668(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  sub_100494E40((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100A80694(void *a1)
{
  *a1 = off_101A340A8;
  sub_100060644(a1 + 5);
  char v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A806E4(void *a1)
{
  *a1 = off_101A340A8;
  sub_100060644(a1 + 5);
  char v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100A80754(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x48uLL);
  *char v2 = off_101A340A8;
  sub_100A80A20((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100A807A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A807BC(uint64_t a1, void *a2)
{
  *a2 = off_101A340A8;
  return sub_100A80A20((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100A807E8(uint64_t a1)
{
}

void sub_100A807F0(void *a1)
{
  sub_100A80A90((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A8082C(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        sub_1000DFC90((uint64_t)&v6, (uint64_t)(a1 + 5));
        uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100A809A8(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100A809D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A80A14()
{
}

uint64_t sub_100A80A20(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  sub_1000DFC90(a1 + 32, a2 + 32);
  return a1;
}

void sub_100A80A78(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A80A90(uint64_t a1)
{
  sub_100060644((void *)(a1 + 32));
  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_100A80ADC(unsigned char **a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (v1[8]) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    uint64_t v5 = "success";
    if (!v1[9]) {
      uint64_t v5 = "failed";
    }
    *(_DWORD *)uint64_t buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v14 = 2080;
    char v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Request to update baseband ticket (fetchBAAOnly : %s) : %s", buf, 0x16u);
  }
  if (v1[9])
  {
    if (v1[8])
    {
      char v6 = 1;
    }
    else
    {
      uint64_t v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Resetting baseband to update new fetched ticket", buf, 2u);
      }
      sub_100058DB0(&__p, "Activation Ticket Updated");
      rest::ResetPayload::ResetPayload();
      sub_1004BC4DC();
      if (v16 < 0) {
        operator delete(*(void **)buf);
      }
      if (v12 < 0) {
        operator delete(__p);
      }
      char v6 = v1[9] != 0;
    }
  }
  else
  {
    char v6 = 0;
  }
  sub_1000607A8((uint64_t)(v1 + 16), v6);
  sub_100A80CE4((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100A80C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_100A80CE4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A80CE4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100A80D34(unsigned int **a1)
{
  uint64_t v1 = *a1;
  dispatch_group_t v18 = a1;
  dispatch_group_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(*(void *)v1 + 80));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
LABEL_14:
      uint64_t v15 = v1[2];
      *(void *)uint64_t buf = v2;
      int v21 = v15;
      sub_1000DFC90((uint64_t)v22, (uint64_t)(v1 + 4));
      CFDictionaryRef v24 = 0;
      char v16 = operator new(0x38uLL);
      uint64_t v17 = *(void *)buf;
      *char v16 = off_101A34128;
      v16[1] = v17;
      *((_DWORD *)v16 + 4) = v21;
      sub_100023950((uint64_t)(v16 + 3), (uint64_t)v22);
      CFDictionaryRef v24 = v16;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v11 + 176))(v11, v15, v23);
      sub_100687D78(v23);
      sub_100060644(v22);
      if (v12) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_14;
  }
LABEL_7:
  char v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface for determining if device is customer ready!", buf, 2u);
  }
  sub_1000607A8((uint64_t)(v1 + 4), 0);
  if ((v12 & 1) == 0) {
LABEL_10:
  }
    sub_10004D2C8(v10);
LABEL_11:
  sub_10041EF98((uint64_t *)&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100A80F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_100687D78(&a18);
  sub_100060644(v19);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  sub_10041EF98(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_100A80FF0(void *a1)
{
  *a1 = off_101A34128;
  sub_100060644(a1 + 3);
  return a1;
}

void sub_100A81034(void *a1)
{
  *a1 = off_101A34128;
  sub_100060644(a1 + 3);

  operator delete();
}

void *sub_100A81098(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A34128;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  sub_1000DFC90((uint64_t)(v2 + 3), a1 + 24);
  return v2;
}

void sub_100A810FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A81110(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A34128;
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  return sub_1000DFC90(a2 + 24, a1 + 24);
}

void *sub_100A8114C(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 24));
}

void sub_100A81154(void *a1)
{
  sub_100060644(a1 + 3);

  operator delete(a1);
}

void sub_100A81190(uint64_t a1, char *a2)
{
  char v2 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 16);
  char v6 = v2;
  sub_1000DFC90((uint64_t)&v7, a1 + 24);
  uint64_t v3 = *(std::__shared_weak_count **)(v4 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A812E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100A81300(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A81340()
{
}

uint64_t *sub_100A8134C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFBooleanRef v28 = a1;
  uint64_t v29 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 12);
  int v5 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v3);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v2 + 80));
  unsigned int v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&cf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    __int16 v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  __int16 v14 = 0;
  char v16 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 96))(&cf, v15, v3, 1, @"RequiresServiceProvisioning", kCFBooleanFalse, 0);
  uint64_t v17 = (BOOL *)cf;
  buf[0] = 0;
  if (cf && (CFTypeID v18 = CFGetTypeID(cf), v18 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)buf, v17, v19);
    BOOL v20 = buf[0] == 0;
  }
  else
  {
    BOOL v20 = 1;
  }
  sub_1000577C4(&cf);
  char v21 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 208))(*(void *)(v2 + 112));
  BOOL v22 = (unsigned __int8 *)(*(uint64_t (**)(void))(**(void **)(v2 + 112) + 128))(*(void *)(v2 + 112));
  if (!v22[12]) {
    goto LABEL_17;
  }
  if (v3 == 2)
  {
    int v23 = v22[9];
    goto LABEL_19;
  }
  if (v3 != 1)
  {
LABEL_17:
    BOOL v24 = 0;
    goto LABEL_20;
  }
  int v23 = v22[8];
LABEL_19:
  BOOL v24 = v23 == 2;
LABEL_20:
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v2 + 112) + 48))(&cf);
  if (cf) {
    CFTypeID v25 = sub_100080778;
  }
  else {
    CFTypeID v25 = 0;
  }
  if (!v25)
  {
    CFDictionaryRef v26 = *v5;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "No activation Info", buf, 2u);
    }
LABEL_29:
    char v21 = 0;
    goto LABEL_30;
  }
  if (v4 != 1)
  {
    if (v4 == 2)
    {
      v21 &= v24;
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  (*(void (**)(void))(**(void **)(v2 + 112) + 264))(*(void *)(v2 + 112));
  if (!v20 && (*(unsigned int (**)(void))(**(void **)(v2 + 112) + 264))(*(void *)(v2 + 112))) {
    v21 &= v24;
  }
LABEL_30:
  sub_100057D78(&cf);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_1000607A8(v1 + 16, v21);
  sub_100A81744(&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_100A816DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  sub_100057D78(&a12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_100A81744(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A81744(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

unint64_t sub_100A81794(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (*(unsigned char *)((*(uint64_t (**)(void))(**(void **)(v1 + 112) + 128))(*(void *)(v1 + 112)) + 508)) {
    return *(unsigned int *)((*(uint64_t (**)(void))(**(void **)(v1 + 112) + 128))(*(void *)(v1 + 112))
  }
                           + 504) | (unint64_t)&_mh_execute_header;
  else {
    return 0;
  }
}

uint64_t sub_100A81820(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

uint64_t sub_100A81864(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

uint64_t *sub_100A818A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFBooleanRef v28 = a1;
  uint64_t v29 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  if (v3 == 3 || v3 == 0)
  {
    int v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v33 = subscriber::asString();
      char v6 = "#N Requesting invalid instance: %s";
      uint64_t v7 = v5;
      uint32_t v8 = 12;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
  else
  {
    uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 128))(*(void *)(v2 + 112));
    uint64_t v10 = v9;
    if (*(unsigned char *)(v9 + 456))
    {
      __int16 v31 = 0;
      int v30 = 0;
      uint64_t v11 = (capabilities::ct *)UMTSProvisioningSlotInfo::PriVersion::PriVersion((UMTSProvisioningSlotInfo::PriVersion *)&v30);
      LOBYTE(v31) = 0;
      if (capabilities::ct::activationSIMInfoHardwareSlotBased(v11))
      {
        unsigned int v12 = *(_DWORD **)(v2 + 200);
        char v13 = *(_DWORD **)(v2 + 208);
        if (v12 != v13)
        {
          while (*v12 != *(_DWORD *)(v1 + 8))
          {
            v12 += 42;
            if (v12 == v13) {
              goto LABEL_25;
            }
          }
        }
        if (v12 == v13)
        {
LABEL_25:
          CFBooleanRef v19 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v26 = subscriber::asString();
            *(_DWORD *)uint64_t buf = 136315138;
            uint64_t v33 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Cannot find instance (%s)", buf, 0xCu);
          }
          goto LABEL_27;
        }
        int v17 = v12[1];
        if (v17 == 2)
        {
          int v30 = *(_DWORD *)(v10 + 432);
          char v18 = *(unsigned char *)(v10 + 436);
        }
        else
        {
          if (v17 != 1)
          {
            int v23 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
            {
              uint64_t v27 = subscriber::asString();
              *(_DWORD *)uint64_t buf = 136315138;
              uint64_t v33 = v27;
              _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "Invalid slot (%s)", buf, 0xCu);
            }
            goto LABEL_34;
          }
          int v30 = *(_DWORD *)(v10 + 256);
          char v18 = *(unsigned char *)(v10 + 260);
        }
        LOBYTE(v31) = v18;
LABEL_34:
        if ((_BYTE)v31) {
          goto LABEL_35;
        }
        CFTypeID v25 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N UMTS slot PRI version is invalid, cannot get PRI version", buf, 2u);
        }
LABEL_27:
        char v20 = 0;
        char v21 = 0;
        __int16 v22 = 0;
LABEL_36:
        sub_100A81C40(*(void *)(v1 + 40), v20, v21, v22);
        goto LABEL_37;
      }
      int v15 = *(_DWORD *)(v1 + 8);
      if (v15 == 2)
      {
        uint64_t v16 = v10 + 432;
      }
      else
      {
        if (v15 != 1)
        {
LABEL_35:
          char v20 = BYTE2(v30);
          char v21 = HIBYTE(v30);
          __int16 v22 = v30;
          goto LABEL_36;
        }
        uint64_t v16 = v10 + 256;
      }
      int v30 = *(_DWORD *)v16;
      LOBYTE(v31) = *(unsigned char *)(v16 + 4);
      goto LABEL_35;
    }
    __int16 v14 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      char v6 = "#N UMTS provisioning info is invalid, cannot get PRI version";
      uint64_t v7 = v14;
      uint32_t v8 = 2;
      goto LABEL_8;
    }
  }
  sub_100A81C40(*(void *)(v1 + 40), 0, 0, 0);
LABEL_37:
  sub_100A81BF0(&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_100A81BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100A81BF0((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A81BF0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1007B3488((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100A81C40(uint64_t a1, char a2, char a3, __int16 a4)
{
  char v7 = a2;
  char v6 = a3;
  __int16 v5 = a4;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *, __int16 *))(*(void *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t sub_100A81CA0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(**(void **)(a1 + 40) + 112) + 432))();
}

uint64_t sub_100A81CD8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100A81D14(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_100A81D54()
{
}

__n128 sub_100A81D68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A34278;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A81DBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A34278;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A81DF4(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  __int16 v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100A81E70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A81EB0()
{
}

uint64_t sub_100A81EBC(uint64_t a1)
{
  sub_100A83014((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100A81EFC(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100A81FF4(a1, v3);
}

void sub_100A81FC4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A81FF4(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100A820EC(a1, a2);
}

void sub_100A820D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100A820EC(uint64_t *a1, void *a2)
{
}

void sub_100A82160()
{
}

uint64_t *sub_100A82184(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1006EB884(a1, a2, 1, 2);
}

void sub_100A82280()
{
}

void sub_100A822A4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A342F8;
  operator new();
}

void sub_100A823B8(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100A82420(uint64_t a1)
{
  sub_100A827D4(a1);

  operator delete();
}

BOOL sub_100A82458(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100A82844((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100A82508(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A82538(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100A82564(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100A82590@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100A825EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A82658(&v2);
}

void sub_100A82644(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A82658(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A826C8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100A826F0(v1);
  __cxa_rethrow();
}

void sub_100A826DC(_Unwind_Exception *a1)
{
}

uint64_t sub_100A826F0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100A83014((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100A82750()
{
}

uint64_t sub_100A82764(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100A83014((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100A827BC()
{
  return 0;
}

uint64_t sub_100A827C4()
{
  return 0;
}

uint64_t sub_100A827CC()
{
  return 0;
}

uint64_t sub_100A827D4(uint64_t a1)
{
  *(void *)a1 = off_101A342F8;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100A82844(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1006EBB64((uint64_t *)result + 4); ; i += 6)
    {
      __n128 result = (atomic_uint **)sub_1006EBB64(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100A82928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A82948(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A829B4(&v2);
}

void sub_100A829A0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A829B4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A82A24(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100A82A5C(_Unwind_Exception *a1)
{
}

void sub_100A82A74()
{
}

uint64_t sub_100A82A88(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A82AB8()
{
  return 0;
}

uint64_t sub_100A82AC0()
{
  return 0;
}

uint64_t sub_100A82AC8()
{
  return 0;
}

uint64_t *sub_100A82AD0(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100A82F54((uint64_t)v4, result);
    sub_100A82F54(v3, a2);
    sub_100A82F54((uint64_t)a2, (uint64_t *)v4);
    return sub_100A83014((uint64_t *)v4);
  }
  return result;
}

void sub_100A82B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100A82B4C(uint64_t a1, void *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    char v6 = *(NSObject **)a1;
    *a2 = *(void *)a1;
    a2[1] = *(void *)(a1 + 8);
    dispatch_retain(v6);
    if (a3 != 1) {
      return;
    }
    long long v7 = *(NSObject **)a1;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *((_WORD *)a2 + 4) = 0;
      return;
    }
    long long v7 = *a2;
LABEL_10:
    dispatch_release(v7);
    return;
  }
  uint32_t v8 = (const char *)(*(void *)(*a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
  if (v8 == (const char *)((unint64_t)"N3ctu12DispatchSlotIZN20ActivationController16setupEvents_syncEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)
    || !strcmp(v8, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN20ActivationController16setupEvents_syncEvE3$_0EE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    *a2 = a1;
  }
  else
  {
    *a2 = 0;
  }
}

void sub_100A82C2C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = (char *)off_101A34440 + 1;
  uint64_t v3 = v1;
  operator new();
}

void sub_100A82D4C()
{
}

uint64_t sub_100A82D80(uint64_t a1)
{
  sub_1006EBD74(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100A83014(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_100A82E04(uint64_t result, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        a2[4] = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"ZN20ActivationController16setupEvents_syncEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"ZN20ActivationController16setupEvents_syncEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    *(void *)a2 = *(void *)result;
  }
  return result;
}

void sub_100A82E9C(uint64_t *a1, char *a2)
{
  uint64_t v3 = *a1;
  *(_OWORD *)uint64_t v4 = 0u;
  long long v5 = 0u;
  rest::ResetPayload::ResetPayload();
  sub_10003ED78((std::string *)v4, a2);
  sub_100A7AAE8(v3, v4);
}

void sub_100A82F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A82F54(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        char v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100A82FF0(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100A83000(_Unwind_Exception *a1)
{
}

uint64_t *sub_100A83014(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100A83068(void *a1)
{
  *a1 = off_101A34470;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A830B4(void *a1)
{
  *a1 = off_101A34470;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100A83120(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100A831D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100A831E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100A83208()
{
}

void *sub_100A83274(void *a1)
{
  *a1 = off_101A344C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100A832C0(void *a1)
{
  *a1 = off_101A344C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100A8332C()
{
}

void sub_100A8339C()
{
}

__n128 sub_100A833B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A34500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A83404(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A34500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A8343C(void *a1)
{
  *(_OWORD *)uint64_t v5 = 0u;
  long long v6 = 0u;
  rest::ResetPayload::ResetPayload();
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, v5);
  if (SBYTE7(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_100A83500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A83534(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A83574()
{
}

void sub_100A83584()
{
}

__n128 sub_100A83598(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A34580;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A835EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A34580;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A83624(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v6 = a1[3];
  long long v7 = (void *)(a1[1] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t))(*v7 + v5);
  }

  return v5(v7, v4);
}

uint64_t sub_100A836A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A836E8()
{
}

uint64_t sub_100A836F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A83740(uint64_t a1)
{
  sub_100A849B8((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100A83780(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100A83878(a1, v3);
}

void sub_100A83848(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A83878(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100A83970(a1, a2);
}

void sub_100A83958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100A83970(uint64_t *a1, void *a2)
{
}

void sub_100A839E4()
{
}

uint64_t *sub_100A83A08(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_10081B4C0(a1, a2, 1, 2);
}

void sub_100A83B04()
{
}

void sub_100A83B28(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A34620;
  operator new();
}

void sub_100A83C3C(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100A83CA4(uint64_t a1)
{
  sub_100A84058(a1);

  operator delete();
}

BOOL sub_100A83CDC(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100A840C8((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100A83D8C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A83DBC(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100A83DE8(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100A83E14@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100A83E70(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A83EDC(&v2);
}

void sub_100A83EC8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A83EDC(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A83F4C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100A83F74(v1);
  __cxa_rethrow();
}

void sub_100A83F60(_Unwind_Exception *a1)
{
}

uint64_t sub_100A83F74(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100A849B8((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100A83FD4()
{
}

uint64_t sub_100A83FE8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100A849B8((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100A84040()
{
  return 0;
}

uint64_t sub_100A84048()
{
  return 0;
}

uint64_t sub_100A84050()
{
  return 0;
}

uint64_t sub_100A84058(uint64_t a1)
{
  *(void *)a1 = off_101A34620;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100A840C8(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_10081B7A0((uint64_t *)result + 4); ; i += 6)
    {
      __n128 result = (atomic_uint **)sub_10081B7A0(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100A841AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A841CC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A84238(&v2);
}

void sub_100A84224(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A84238(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A842A8(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100A842E0(_Unwind_Exception *a1)
{
}

void sub_100A842F8()
{
}

uint64_t sub_100A8430C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A8433C()
{
  return 0;
}

uint64_t sub_100A84344()
{
  return 0;
}

uint64_t sub_100A8434C()
{
  return 0;
}

NSObject **sub_100A84354(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t *sub_100A843A4(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100A848F8((uint64_t)v4, result);
    sub_100A848F8(v3, a2);
    sub_100A848F8((uint64_t)a2, (uint64_t *)v4);
    return sub_100A849B8((uint64_t *)v4);
  }
  return result;
}

void sub_100A8440C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100A84420(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100A84354((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100A84A0C(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFviEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFviEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100A844F8(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1 && (uint64_t v2 = _Block_copy(v1)) != 0 && (v3 = _Block_copy(v2), (v4 = v3) != 0))
  {
    uint64_t v5 = _Block_copy(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      long long v7 = _Block_copy(v5);
      uint32_t v8 = v7;
      if (v7)
      {
        uint64_t v9 = _Block_copy(v7);
        uint64_t v10 = v9;
        if (v9)
        {
          uint64_t v11 = _Block_copy(v9);
          unsigned int v12 = v11;
          if (v11)
          {
            *(void *)&long long v14 = _Block_copy(v11);
            _Block_release(v12);
          }
          else
          {
            *(void *)&long long v14 = 0;
          }
          _Block_release(v10);
        }
        else
        {
          *(void *)&long long v14 = 0;
        }
        _Block_release(v8);
      }
      else
      {
        *(void *)&long long v14 = 0;
      }
      char v13 = off_101A34768;
      _Block_release(v6);
    }
    else
    {
      char v13 = off_101A34768;
      *(void *)&long long v14 = 0;
    }
    _Block_release(v4);
  }
  else
  {
    char v13 = off_101A34768;
    *(void *)&long long v14 = 0;
  }
  operator new();
}

void sub_100A84738()
{
}

uint64_t sub_100A84788(uint64_t a1)
{
  sub_10081B9B0(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100A849B8(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_100A8480C(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint32_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFviEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFviEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100A848E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100A848F8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100A84994(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100A849A4(_Unwind_Exception *a1)
{
}

uint64_t *sub_100A849B8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100A84A0C(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

uint64_t sub_100A84A48(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_100A84A98()
{
}

__n128 sub_100A84AAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A347B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A84B00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A347B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A84B38(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A84B80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A84BC0()
{
}

void sub_100A84BD0()
{
}

__n128 sub_100A84BE4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A34838;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A84C38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A34838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A84C70(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100A84D68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A84DA8()
{
}

void sub_100A84DB8()
{
}

void *sub_100A84DCC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A348B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A84E14(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A348B8;
  a2[1] = v2;
  return result;
}

void sub_100A84E40(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/is_activation_ticket_updated");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100A84EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100A84F38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A84F78()
{
}

uint64_t sub_100A84F84(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100A84F94(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A84FB0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100A84FC0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100A85018(uint64_t a1)
{
  uint64_t v2 = a1;
  sub_100068A94(&v3);
  (*(void (**)(void))(*(void *)v3 + 144))();
  if (v4) {
    sub_10004D2C8(v4);
  }
  return sub_100A84FC0(&v2);
}

void sub_100A8509C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100A84FC0(&a10);
  _Unwind_Resume(a1);
}

void sub_100A850C8()
{
}

void *sub_100A850DC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A34970;
  result[1] = v3;
  return result;
}

uint64_t sub_100A85124(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A34970;
  a2[1] = v2;
  return result;
}

void sub_100A85150(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I BAA prefetch for update baseband : %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100A8520C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A8524C()
{
}

void sub_100A8525C()
{
}

void *sub_100A85270(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A349F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A852B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A349F0;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A852E4(uint64_t result, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v2 = *(void *)(result + 8);
    uint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Ticket refetch failed, requesting reactivation", v6, 2u);
    }
    uint64_t v4 = *(void *)(v2 + 152);
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 400))(*(void *)(v2 + 112));
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 16))(v4, v5);
  }
  return result;
}

uint64_t sub_100A853B0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A853F0()
{
}

void sub_100A85400()
{
}

void *sub_100A85414(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A34A70;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8545C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A34A70;
  a2[1] = v2;
  return result;
}

void sub_100A85488(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100A85568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A855A8()
{
}

void sub_100A855B4(uint64_t a1)
{
  uint64_t v1 = a1;
  *(unsigned char *)(**(void **)a1 + 133) = 1;
  operator delete();
}

void sub_100A85600(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 152))(*(void *)(v2 + 112));
  uint64_t v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    uint64_t v6 = "false";
    if (v3 == 3) {
      long long v7 = "true";
    }
    else {
      long long v7 = "false";
    }
    if (*((unsigned char *)v1 + 8)) {
      uint64_t v6 = "true";
    }
    *(_DWORD *)uint64_t buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ticket rejected (%s) activated (%s)", buf, 0x16u);
  }
  BasebandBootStrategy = (capabilities::ct *)capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v5);
  if (BasebandBootStrategy == 2
    || (BasebandBootStrategy = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(v2 + 112) + 152))(*(void *)(v2 + 112)),
        BasebandBootStrategy))
  {
    if (capabilities::ct::getProvisioningProfileSupport(BasebandBootStrategy) == 1
      && *((unsigned char *)v1 + 8)
      && v3 != 3
      && (*(unsigned int (**)(void))(**(void **)(v2 + 112) + 440))(*(void *)(v2 + 112)) == 2)
    {
      *(void *)uint64_t buf = off_101A34970;
      *(void *)&uint8_t buf[8] = v2;
      unsigned int v12 = buf;
      sub_100A794DC((void *)v2, 1, (uint64_t)buf);
      sub_100060644(buf);
    }
    if (!*((unsigned char *)v1 + 8) && v3 != 3)
    {
      uint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Removing stored postponement ticket", buf, 2u);
      }
      DevicePersistentSaveValue(kPostponementTicketPlist, 0);
      DevicePersistentSaveValue(kPostponementTicketObliterated, kCFBooleanTrue);
      uint64_t v10 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Removing cached postponement ticket", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(v2 + 112) + 72))(*(void *)(v2 + 112));
    }
  }
  operator delete();
}

void sub_100A858D0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  operator delete();
}

CFStringRef sub_100A8590C(int a1)
{
  CFStringRef v1 = @"PhoneNumber?";
  if (a1 == 2) {
    CFStringRef v1 = @"PhoneNumber2";
  }
  if (a1 == 1) {
    return @"PhoneNumber";
  }
  else {
    return v1;
  }
}

uint64_t sub_100A85938(uint64_t a1, void *a2, NSObject **a3, char *a4, long long *a5, uint64_t a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, a4);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unsigned int v12 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v18, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  char v13 = (capabilities::ct *)sub_10091EB50((uint64_t)v19, a6);
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v13) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v19);
  *(void *)a1 = off_101A34AF0;
  *(void *)(a1 + 56) = *a2;
  uint64_t v14 = a2[1];
  *(void *)(a1 + 64) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  int v15 = (unsigned char *)(a1 + 88);
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(v15, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v16 = *a5;
    *(void *)(a1 + 104) = *((void *)a5 + 2);
    *(_OWORD *)int v15 = v16;
  }
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = a4;
  *(_DWORD *)(a1 + 135) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  return a1;
}

void sub_100A85BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

uint64_t sub_100A85CB8(uint64_t a1)
{
  *(void *)a1 = off_101A34AF0;
  sub_10003FB28(a1 + 168, *(void **)(a1 + 176));
  sub_1000346F8(a1 + 144, *(void **)(a1 + 152));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 128);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A85D8C(void *a1, uint64_t a2, uint64_t a3, CFDataRef *a4, uint64_t a5)
{
  *a1 = 0;
  a1[1] = 0;
  sub_10012A4F0(a1);
  BytePtr = (UInt8 *)CFDataGetBytePtr(*a4);
  size_t Length = CFDataGetLength(*a4);
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v21 = 0;
  sub_1000D95C8(__dst, BytePtr, Length);
  int v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_1001E7940(&v17, BytePtr, (uint64_t)&BytePtr[Length], Length);
  (*(void (**)(void, void **))(*(void *)*a1 + 56))(*a1, &v17);
  (*(void (**)(void, void))(*(void *)*a1 + 8))(*a1, *(void *)(a2 + 24));
  uint64_t v11 = *a1;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 1174405120;
  CFTypeRef v22[2] = sub_100A8605C;
  v22[3] = &unk_101A34B40;
  v22[4] = a2;
  sub_100A86C84((uint64_t)v23, a5);
  (*(void (**)(uint64_t, void *))(*(void *)v11 + 16))(v11, v22);
  unsigned int v12 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Issuing HTTP Request", buf, 2u);
  }
  uint64_t v13 = *a1;
  __p[1] = 0;
  uint64_t v15 = 0;
  __p[0] = 0;
  (*(void (**)(uint64_t, void **))(*(void *)v13 + 40))(v13, __p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  sub_100A86C00(v23);
  if (v17)
  {
    uint64_t v18 = v17;
    operator delete(v17);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100A85FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100A86C00(v27);
  if (a18) {
    operator delete(a18);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v26 + 8);
  if (v29) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(a1);
}

void sub_100A8605C(uint64_t a1, uint64_t *a2)
{
  int v3 = *(void **)(a1 + 32);
  uint64_t v4 = (std::__shared_weak_count *)v3[10];
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      long long v7 = v6;
      if (v3[9])
      {
        uint32_t v8 = v3[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I HTTP Request for data is complete", buf, 2u);
        }
        uint64_t v9 = (std::__shared_weak_count *)a2[1];
        uint64_t v11 = *a2;
        unsigned int v12 = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v10 = *(void *)(a1 + 64);
        if (!v10) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v10 + 48))(v10, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100A86150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100A86170(uint64_t a1, uint64_t a2)
{
  return sub_100A86C84(a1 + 40, a2 + 40);
}

void *sub_100A8617C(uint64_t a1)
{
  return sub_100A86C00((void *)(a1 + 40));
}

uint64_t sub_100A86184(uint64_t a1, long long *a2)
{
  uint64_t v5 = (os_log_t *)(a1 + 40);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 112);
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Reporting %s information to the server", (uint8_t *)&buf, 0xCu);
  }
  unsigned int v7 = *(_DWORD *)(a1 + 192);
  if (v7 >= 4)
  {
    uint64_t v13 = *v5;
    uint64_t v12 = 4;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109376;
      DWORD1(buf) = v7;
      WORD4(buf) = 1024;
      *(_DWORD *)((char *)&buf + 10) = 4;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N Request failure count %u has already reached the max %u", (uint8_t *)&buf, 0xEu);
    }
  }
  else
  {
    uint32_t v8 = *(std::__shared_weak_count **)(a1 + 80);
    if (v8)
    {
      uint64_t v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        uint64_t v10 = *(void *)(a1 + 72);
        if (v10)
        {
          if (*(unsigned char *)(a1 + 136))
          {
            uint64_t v11 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Response is still pending, sending the request later", (uint8_t *)&buf, 2u);
            }
            uint64_t v12 = 5;
          }
          else
          {
            CFTypeRef cf = 0;
            (*(void (**)(CFTypeRef *__return_ptr, uint64_t, long long *))(*(void *)a1 + 40))(&cf, a1, a2);
            if (cf) {
              long long v16 = sub_10008324C;
            }
            else {
              long long v16 = 0;
            }
            if (v16)
            {
              long long buf = 0uLL;
              uint64_t v35 = 0;
              sub_100105D20(v5, a1 + 88, (uint64_t *)&buf);
              uint64_t v17 = HIBYTE(v35);
              if (v35 < 0) {
                uint64_t v17 = *((void *)&buf + 1);
              }
              if (v17)
              {
                CFTypeRef v29 = cf;
                if (cf) {
                  CFRetain(cf);
                }
                if (*((char *)a2 + 23) < 0)
                {
                  sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
                }
                else
                {
                  long long __p = *a2;
                  uint64_t v26 = *((void *)a2 + 2);
                }
                uint64_t v27 = v10;
                CFBooleanRef v28 = v9;
                atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
                uint64_t v33 = 0;
                OsLogContext v20 = operator new(0x38uLL);
                void *v20 = off_101A34C40;
                v20[1] = a1;
                uint64_t v21 = v20 + 2;
                if (SHIBYTE(v26) < 0)
                {
                  sub_10004FC84(v21, (void *)__p, *((unint64_t *)&__p + 1));
                }
                else
                {
                  *(_OWORD *)uint64_t v21 = __p;
                  void v20[4] = v26;
                }
                __int16 v22 = v28;
                v20[5] = v27;
                v20[6] = v22;
                if (v22) {
                  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v33 = v20;
                sub_100A85D8C(v30, a1, (uint64_t)&buf, (CFDataRef *)&v29, (uint64_t)v32);
                long long v23 = *(_OWORD *)v30;
                memset(v30, 0, sizeof(v30));
                BOOL v24 = *(std::__shared_weak_count **)(a1 + 128);
                *(_OWORD *)(a1 + 120) = v23;
                if (v24)
                {
                  sub_10004D2C8(v24);
                  if (*(void *)&v30[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&v30[8]);
                  }
                }
                sub_100A86C00(v32);
                if (v28) {
                  sub_10004D2C8(v28);
                }
                if (SHIBYTE(v26) < 0) {
                  operator delete((void *)__p);
                }
                sub_100030068(&v29);
                *(unsigned char *)(a1 + 136) = 1;
                uint64_t v12 = 5;
              }
              else
              {
                uint64_t v19 = *v5;
                if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)int v30 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Failed to create activity URL of the server", v30, 2u);
                }
                uint64_t v12 = 1;
              }
              if (SHIBYTE(v35) < 0) {
                operator delete((void *)buf);
              }
            }
            else
            {
              uint64_t v18 = *v5;
              if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Failed to create XML Data for sending to server", (uint8_t *)&buf, 2u);
              }
              uint64_t v12 = 1;
            }
            sub_100030068(&cf);
          }
LABEL_17:
          sub_10004D2C8(v9);
          return v12;
        }
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    uint64_t v14 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Could not get parent", (uint8_t *)&buf, 2u);
    }
    uint64_t v12 = 0;
    if (v9) {
      goto LABEL_17;
    }
  }
  return v12;
}

void sub_100A865C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,__int16 a21,char a22,char a23)
{
  operator delete(v24);
  sub_1000D0AFC((uint64_t)&a10);
  sub_100030068(&a16);
  if (*(char *)(v25 - 57) < 0) {
    operator delete(*(void **)(v25 - 80));
  }
  sub_100030068(&a20);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_100A86644(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = sub_100A8692C(a1);
    uint64_t v4 = "false";
    if (v3) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    int v6 = *(unsigned __int8 *)(a1 + 138);
    if (*(unsigned char *)(a1 + 137)) {
      unsigned int v7 = "true";
    }
    else {
      unsigned int v7 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)CFBooleanRef v28 = v5;
    *(_WORD *)&v28[8] = 2080;
    if (v6) {
      uint64_t v4 = "true";
    }
    *(void *)&v28[10] = v7;
    __int16 v29 = 2080;
    int v30 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Service Provisioned: %s, CS Registered: %s, PS Registered: %s", buf, 0x20u);
  }
  uint32_t v8 = *(void **)(a1 + 168);
  if (v8 != (void *)(a1 + 176))
  {
    do
    {
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v8 + 8));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)(v8 + 5));
        IntCFDictionaryRef Value = MCC::getIntValue((MCC *)buf);
        MCCAndMNC::getMnc(v19, (MCCAndMNC *)(v8 + 5));
        int IntegerWidth = MNC::getIntegerWidth((MNC *)v19);
        MCCAndMNC::getMnc(v17, (MCCAndMNC *)(v8 + 5));
        int v12 = MCC::getIntValue((MCC *)v17);
        *(_DWORD *)uint64_t v21 = 67109632;
        int v22 = IntValue;
        __int16 v23 = 1024;
        int v24 = IntegerWidth;
        __int16 v25 = 1024;
        int v26 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I MCC: %03d, MNC: %0.*d", v21, 0x14u);
        if (v18 < 0) {
          operator delete((void *)v17[1]);
        }
        if (v20 < 0) {
          operator delete((void *)v19[1]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(*(void **)&v28[4]);
        }
      }
      uint64_t v13 = (void *)v8[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          uint32_t v8 = v14;
        }
        while (!v15);
      }
      uint32_t v8 = v14;
    }
    while (v14 != (void *)(a1 + 176));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
}

void sub_100A868D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A8692C(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v2 = v12;
  if (v12 == v13) {
    return 0;
  }
  while ((v14(*v2) & 1) == 0)
  {
    if (++v2 == v13)
    {
      uint64_t v2 = v13;
      break;
    }
  }
  if (v2 == v13) {
    return 0;
  }
  int v3 = (void *)(a1 + 152);
  while (1)
  {
    uint64_t v4 = *v3;
    if (*v3)
    {
      signed int v5 = *v2;
      int v6 = v3;
      do
      {
        signed int v7 = *(_DWORD *)(v4 + 28);
        BOOL v8 = v7 < v5;
        if (v7 >= v5) {
          uint64_t v9 = (uint64_t *)v4;
        }
        else {
          uint64_t v9 = (uint64_t *)(v4 + 8);
        }
        if (!v8) {
          int v6 = (void *)v4;
        }
        uint64_t v4 = *v9;
      }
      while (*v9);
      if (v6 != v3 && v5 >= *((_DWORD *)v6 + 7) && *((unsigned char *)v6 + 32)) {
        return 1;
      }
    }
    uint64_t v10 = v2 + 1;
    uint64_t v2 = v13;
    if (v10 != v13)
    {
      uint64_t v2 = v10;
      while ((v14(*v2) & 1) == 0)
      {
        if (++v2 == v13)
        {
          uint64_t v2 = v13;
          break;
        }
      }
    }
    if (v2 == v13) {
      return 0;
    }
  }
}

void sub_100A86A3C(uint64_t a1, int a2)
{
  int v8 = a2;
  uint64_t v2 = a1 + 168;
  MCCAndMNC::MCCAndMNC();
  sub_100A86ABC(v2, &v8, (MCC *)v3);
  if (v7 < 0) {
    operator delete(__p);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
}

void sub_100A86AA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10013C44C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A86ABC(uint64_t a1, int *a2, MCC *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3)
  {
    uint64_t v5 = a1 + 8;
    return sub_100A875C8((uint64_t **)a1, (uint64_t *)v5, a2, a2, a3);
  }
  int v4 = *a2;
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < v4;
    if (v6 >= v4) {
      int v8 = (uint64_t *)v3;
    }
    else {
      int v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 8 || v4 < *(_DWORD *)(v5 + 32)) {
    return sub_100A875C8((uint64_t **)a1, (uint64_t *)v5, a2, a2, a3);
  }
  MCC::operator=();
  MCC::operator=();
  return (uint64_t *)v5;
}

uint64_t sub_100A86B64(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t result = sub_100A87768(a1 + 168, &v4);
  if (!*(void *)(a1 + 184))
  {
    int v5 = v4;
    int v6 = &v5;
    uint64_t result = (uint64_t)sub_10005CE78((uint64_t **)(a1 + 144), &v5, (uint64_t)&unk_10144E20E, &v6);
    *(unsigned char *)(result + 32) = 0;
    *(_WORD *)(a1 + 137) = 0;
    *(_DWORD *)(a1 + 192) = 0;
  }
  return result;
}

void sub_100A86BE0()
{
}

uint64_t sub_100A86BF4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void *sub_100A86C00(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100A86C84(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100A86D1C(uint64_t a1)
{
  *(void *)a1 = off_101A34C40;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100A86D78(uint64_t a1)
{
  *(void *)a1 = off_101A34C40;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100A86DF4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A34C40;
  sub_1000EAD04(v2 + 1, v1);
  return v2;
}

void sub_100A86E48(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100A86E5C(uint64_t a1, void *a2)
{
  *a2 = off_101A34C40;
  return sub_1000EAD04(a2 + 1, a1 + 8);
}

void sub_100A86E88(uint64_t a1)
{
}

void sub_100A86E90(void *a1)
{
  sub_1000EAD74((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A86ECC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(v5 + 112);
    (*(void (**)(xpc_object_t *__return_ptr, uint64_t))(*(void *)v4 + 64))(object, v4);
    if (v47 >= 0) {
      int v8 = object;
    }
    else {
      int v8 = (xpc_object_t *)object[0];
    }
    uint64_t v39 = v3;
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    ctu::Http::asString();
    if (v45 >= 0) {
      uint64_t v10 = &v44;
    }
    else {
      uint64_t v10 = v44;
    }
    v38 = v10;
    int v37 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    int v11 = v9;
    int v12 = v8;
    uint64_t v13 = v7;
    uint64_t v14 = (ctu::Http *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    ctu::Http::asString((uint64_t *)v42, v14, v15);
    int v16 = v43;
    uint64_t v17 = (void **)v42[0];
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v4 + 48))(__p, v4);
    char v18 = v42;
    if (v16 < 0) {
      char v18 = v17;
    }
    if (v41 >= 0) {
      uint64_t v19 = __p;
    }
    else {
      uint64_t v19 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136316674;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v12;
    *(_WORD *)&unsigned char buf[22] = 1024;
    LODWORD(v49) = v11;
    WORD2(v49) = 2080;
    *(void *)((char *)&v49 + 6) = v38;
    HIWORD(v49) = 1024;
    int v50 = v37;
    *(_WORD *)uint64_t v51 = 2080;
    *(void *)&v51[2] = v18;
    __int16 v52 = 2080;
    CFTypeRef v53 = v19;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s data HTTP response: '%s', Result: %d (%s), Status: %d (%s), Response: '%s'", buf, 0x40u);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v3 = v39;
    if (v43 < 0) {
      operator delete(v42[0]);
    }
    if (v45 < 0) {
      operator delete(v44);
    }
    if (v47 < 0) {
      operator delete(object[0]);
    }
  }
  else if (!v4)
  {
    int v22 = *(_DWORD *)(v5 + 192) + 1;
    *(_DWORD *)(v5 + 192) = v22;
    int v23 = -1;
    goto LABEL_32;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 16))(v4) == 1
    && (*(unsigned int (**)(uint64_t))(*(void *)v4 + 24))(v4) == 200)
  {
    if (*(char *)(a1 + 39) >= 0) {
      char v20 = (const char *)(a1 + 16);
    }
    else {
      char v20 = *(const char **)(a1 + 16);
    }
    object[0] = xpc_string_create(v20);
    if (!object[0]) {
      object[0] = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 64))(v5, object);
    xpc_release(object[0]);
    object[0] = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10012A79C;
    *(void *)&long long v49 = &unk_1019A2128;
    *((void *)&v49 + 1) = v5;
    sub_10012A5BC((wis::MetricFactory *)0x8010A);
    goto LABEL_34;
  }
  int v22 = *(_DWORD *)(v5 + 192) + 1;
  *(_DWORD *)(v5 + 192) = v22;
  int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
LABEL_32:
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_10012A900;
  *(void *)&long long v49 = &unk_1019A2148;
  *((void *)&v49 + 1) = v5;
  int v50 = v22;
  *(_DWORD *)uint64_t v51 = v23;
  sub_10012A5BC((wis::MetricFactory *)0x800E9);
  int v24 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(void *)(v5 + 112);
    int v26 = *(_DWORD *)(v5 + 192);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v25;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v26;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s request to the server failed, current failure count: %d", buf, 0x12u);
  }
LABEL_34:
  ServiceMap = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)(v5 + 56));
  CFBooleanRef v28 = ServiceMap;
  if (v29 < 0)
  {
    int v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v29;
  uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
  if (v33)
  {
    uint64_t v35 = v33[3];
    BOOL v34 = (std::__shared_weak_count *)v33[4];
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v28);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v34);
      char v36 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v28);
  BOOL v34 = 0;
  char v36 = 1;
LABEL_42:
  *(_DWORD *)(v5 + 196) = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 88))(v35);
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  *(unsigned char *)(v5 + 136) = 0;
  (*(void (**)(void, const char *))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), "Checking for any pending events");
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100A874C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t object,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A8757C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A875BC()
{
}

uint64_t *sub_100A875C8(uint64_t **a1, uint64_t *a2, int *a3, _DWORD *a4, MCC *a5)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  int v8 = sub_1000262C0(a1, a2, &v14, &v13, a3);
  int v9 = (uint64_t *)*v8;
  if (!*v8)
  {
    uint64_t v10 = (uint64_t **)v8;
    memset(v12, 0, sizeof(v12));
    sub_100A8767C((uint64_t)a1, a4, a5, v12);
    sub_100046C38(a1, (uint64_t)v14, v10, v12[0]);
    int v9 = v12[0];
    v12[0] = 0;
    sub_10003FD44((uint64_t)v12, 0);
  }
  return v9;
}

_DWORD *sub_100A8767C@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, MCC *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  int v8 = operator new(0x68uLL);
  *a4 = v8;
  a4[1] = v7;
  *((unsigned char *)a4 + 16) = 0;
  uint64_t result = sub_100A876F8(v8 + 8, a2, a3);
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_100A876E0(_Unwind_Exception *a1)
{
  sub_10003FD44(v1, 0);
  _Unwind_Resume(a1);
}

_DWORD *sub_100A876F8(_DWORD *a1, _DWORD *a2, MCC *a3)
{
  *a1 = *a2;
  uint64_t v5 = (MCC *)(a1 + 10);
  MCC::MCC((MCC *)(a1 + 2), a3);
  MCC::MCC(v5, (MCC *)((char *)a3 + 32));
  return a1;
}

void sub_100A8774C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A87768(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_10006C514((uint64_t **)a1, (uint64_t *)v4);
  sub_10003FB84(v4 + 32);
  operator delete((void *)v4);
  return 1;
}

void RegistrationEventHandler::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A878E4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_100A87930(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v65, *(Registry **)(a1 + 48));
  uint64_t v2 = a1 + 64;
  ctu::RestModule::connect();
  if (v66) {
    sub_10004D2C8(v66);
  }
  int v3 = (uint64_t (***)())(a1 + 80);
  unsigned int v67 = off_101A34F28;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 80))
  {
    uint64_t v4 = *(uint64_t (****)())(a1 + 104);
    if (v4 == v3)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A34F28;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v3)[3])(a1 + 80, &v67);
      (*(void (**)(void))(**(void **)(a1 + 104) + 32))(*(void *)(a1 + 104));
      *(void *)(a1 + 104) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 80);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 80) = off_101A34F28;
      *(void *)(a1 + 88) = v2;
      v69 = v4;
    }
    *(void *)(a1 + 104) = v3;
  }
  sub_100A8E2CC(&v67);
  int v5 = *(capabilities::ct **)(a1 + 104);
  if (v5) {
    int v5 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v5 + 48))(v5, a1 + 112);
  }
  if (capabilities::ct::supportsGemini(v5))
  {
    unsigned int v67 = off_101A34FB8;
    v68 = (void *)(a1 + 64);
    v69 = &v67;
    sub_100A8EBE8(&v67, (void *)(a1 + 1024));
    sub_100A8DABC(&v67);
    uint64_t v6 = *(void *)(a1 + 1048);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 1056);
    }
  }
  unsigned int v67 = off_101A35048;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_100A8EBE8(&v67, (void *)(a1 + 192));
  sub_100A8DABC(&v67);
  uint64_t v7 = *(void *)(a1 + 216);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 224);
  }
  unsigned int v67 = off_101A350C8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_100A8F0F4(&v67, (void *)(a1 + 1856));
  sub_100A8E148(&v67);
  int v8 = *(capabilities::ct **)(a1 + 1880);
  if (v8) {
    int v8 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v8 + 48))(v8, a1 + 1888);
  }
  if (capabilities::ct::supportsGemini(v8))
  {
    unsigned int v67 = off_101A35158;
    v68 = (void *)(a1 + 64);
    v69 = &v67;
    sub_100A8F0F4(&v67, (void *)(a1 + 1896));
    sub_100A8E148(&v67);
    uint64_t v9 = *(void *)(a1 + 1920);
    if (v9) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48))(v9, a1 + 1928);
    }
  }
  uint64_t v10 = (uint64_t (***)())(a1 + 136);
  unsigned int v67 = off_101A351D8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 136))
  {
    int v11 = *(uint64_t (****)())(a1 + 160);
    if (v11 == v10)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A351D8;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v10)[3])(a1 + 136, &v67);
      (*(void (**)(void))(**(void **)(a1 + 160) + 32))(*(void *)(a1 + 160));
      *(void *)(a1 + 160) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 136);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 136) = off_101A351D8;
      *(void *)(a1 + 144) = v2;
      v69 = v11;
    }
    *(void *)(a1 + 160) = v10;
  }
  sub_100A8E248(&v67);
  uint64_t v12 = *(void *)(a1 + 160);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a1 + 168);
  }
  sub_100A894E0((void *)(a1 + 1936), a1 + 64);
  uint64_t v13 = (uint64_t (***)())(a1 + 1984);
  unsigned int v67 = off_101A352F8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 1984))
  {
    uint64_t v14 = *(uint64_t (****)())(a1 + 2008);
    if (v14 == v13)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A352F8;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v13)[3])(a1 + 1984, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2008) + 32))(*(void *)(a1 + 2008));
      *(void *)(a1 + 2008) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 1984);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 1984) = off_101A352F8;
      *(void *)(a1 + 1992) = v2;
      v69 = v14;
    }
    *(void *)(a1 + 2008) = v13;
  }
  sub_100A8E040(&v67);
  uint64_t v15 = *(void *)(a1 + 2008);
  if (v15) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, a1 + 2016);
  }
  unsigned int v67 = off_101A35388;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_10041CA0C(&v67, (void *)(a1 + 2040));
  sub_10041A760(&v67);
  uint64_t v16 = *(void *)(a1 + 2064);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 48))(v16, a1 + 2072);
  }
  unsigned int v67 = off_101A35408;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_10041CA0C(&v67, (void *)(a1 + 2096));
  sub_10041A760(&v67);
  uint64_t v17 = *(void *)(a1 + 2120);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, a1 + 2128);
  }
  unsigned int v67 = off_101A35488;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_10041CA0C(&v67, (void *)(a1 + 2152));
  sub_10041A760(&v67);
  uint64_t v18 = *(void *)(a1 + 2176);
  if (v18) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 48))(v18, a1 + 2184);
  }
  unsigned int v67 = off_101A35508;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_10041CA0C(&v67, (void *)(a1 + 2208));
  sub_10041A760(&v67);
  uint64_t v19 = *(void *)(a1 + 2232);
  if (v19) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, a1 + 2240);
  }
  char v20 = (uint64_t (***)())(a1 + 2264);
  unsigned int v67 = off_101A35588;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2264))
  {
    uint64_t v21 = *(uint64_t (****)())(a1 + 2288);
    if (v21 == v20)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35588;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v20)[3])(a1 + 2264, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2288) + 32))(*(void *)(a1 + 2288));
      *(void *)(a1 + 2288) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2264);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2264) = off_101A35588;
      *(void *)(a1 + 2272) = v2;
      v69 = v21;
    }
    *(void *)(a1 + 2288) = v20;
  }
  sub_100A8DFBC(&v67);
  uint64_t v22 = *(void *)(a1 + 2288);
  if (v22) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 48))(v22, a1 + 2296);
  }
  int v23 = (uint64_t (***)())(a1 + 2320);
  unsigned int v67 = off_101A35618;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2320))
  {
    int v24 = *(uint64_t (****)())(a1 + 2344);
    if (v24 == v23)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35618;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v23)[3])(a1 + 2320, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2344) + 32))(*(void *)(a1 + 2344));
      *(void *)(a1 + 2344) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2320);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2320) = off_101A35618;
      *(void *)(a1 + 2328) = v2;
      v69 = v24;
    }
    *(void *)(a1 + 2344) = v23;
  }
  sub_100A8DF38(&v67);
  uint64_t v25 = *(void *)(a1 + 2344);
  if (v25) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 48))(v25, a1 + 2352);
  }
  int v26 = (uint64_t (***)())(a1 + 2376);
  unsigned int v67 = off_101A356A8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2376))
  {
    uint64_t v27 = *(uint64_t (****)())(a1 + 2400);
    if (v27 == v26)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A356A8;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v26)[3])(a1 + 2376, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2400) + 32))(*(void *)(a1 + 2400));
      *(void *)(a1 + 2400) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2376);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2376) = off_101A356A8;
      *(void *)(a1 + 2384) = v2;
      v69 = v27;
    }
    *(void *)(a1 + 2400) = v26;
  }
  sub_100A8DEB4(&v67);
  uint64_t v28 = *(void *)(a1 + 2400);
  if (v28) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v28 + 48))(v28, a1 + 2408);
  }
  uint64_t v29 = (uint64_t (***)())(a1 + 2432);
  unsigned int v67 = off_101A35738;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2432))
  {
    int v30 = *(uint64_t (****)())(a1 + 2456);
    if (v30 == v29)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35738;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v29)[3])(a1 + 2432, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2456) + 32))(*(void *)(a1 + 2456));
      *(void *)(a1 + 2456) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2432);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2432) = off_101A35738;
      *(void *)(a1 + 2440) = v2;
      v69 = v30;
    }
    *(void *)(a1 + 2456) = v29;
  }
  sub_100A8DE30(&v67);
  uint64_t v31 = *(void *)(a1 + 2456);
  if (v31) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 48))(v31, a1 + 2464);
  }
  unsigned int v67 = off_101A357C8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_100A9163C(&v67, (void *)(a1 + 2488));
  sub_100A8DDAC(&v67);
  uint64_t v32 = *(void *)(a1 + 2512);
  if (v32) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v32 + 48))(v32, a1 + 2520);
  }
  unsigned int v67 = off_101A35858;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_100A9163C(&v67, (void *)(a1 + 2544));
  sub_100A8DDAC(&v67);
  uint64_t v33 = *(void *)(a1 + 2568);
  if (v33) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v33 + 48))(v33, a1 + 2576);
  }
  BOOL v34 = (uint64_t (***)())(a1 + 2600);
  unsigned int v67 = off_101A358D8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2600))
  {
    uint64_t v35 = *(uint64_t (****)())(a1 + 2624);
    if (v35 == v34)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A358D8;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v34)[3])(a1 + 2600, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2624) + 32))(*(void *)(a1 + 2624));
      *(void *)(a1 + 2624) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2600);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2600) = off_101A358D8;
      *(void *)(a1 + 2608) = v2;
      v69 = v35;
    }
    *(void *)(a1 + 2624) = v34;
  }
  sub_100A8DD28(&v67);
  uint64_t v36 = *(void *)(a1 + 2624);
  if (v36) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v36 + 48))(v36, a1 + 2632);
  }
  int v37 = (uint64_t (***)())(a1 + 2656);
  unsigned int v67 = off_101A35968;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2656))
  {
    v38 = *(uint64_t (****)())(a1 + 2680);
    if (v38 == v37)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35968;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v37)[3])(a1 + 2656, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2680) + 32))(*(void *)(a1 + 2680));
      *(void *)(a1 + 2680) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2656);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2656) = off_101A35968;
      *(void *)(a1 + 2664) = v2;
      v69 = v38;
    }
    *(void *)(a1 + 2680) = v37;
  }
  sub_100A8DCA4(&v67);
  uint64_t v39 = *(void *)(a1 + 2680);
  if (v39) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 48))(v39, a1 + 2688);
  }
  unsigned int v67 = off_101A359F8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  sub_100A92018(&v67, (void *)(a1 + 2712));
  sub_100A8DBC4(&v67);
  uint64_t v40 = *(void *)(a1 + 2736);
  if (v40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v40 + 48))(v40, a1 + 2744);
  }
  char v41 = (uint64_t (***)())(a1 + 2768);
  unsigned int v67 = off_101A35A88;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2768))
  {
    uint64_t v42 = *(uint64_t (****)())(a1 + 2792);
    if (v42 == v41)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35A88;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v41)[3])(a1 + 2768, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2792) + 32))(*(void *)(a1 + 2792));
      *(void *)(a1 + 2792) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2768);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2768) = off_101A35A88;
      *(void *)(a1 + 2776) = v2;
      v69 = v42;
    }
    *(void *)(a1 + 2792) = v41;
  }
  sub_100A8DB40(&v67);
  uint64_t v43 = *(void *)(a1 + 2792);
  if (v43) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v43 + 48))(v43, a1 + 2800);
  }
  v44 = (uint64_t (***)())(a1 + 2824);
  unsigned int v67 = off_101A35B18;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2824))
  {
    char v45 = *(uint64_t (****)())(a1 + 2848);
    if (v45 == v44)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35B18;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v44)[3])(a1 + 2824, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2848) + 32))(*(void *)(a1 + 2848));
      *(void *)(a1 + 2848) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2824);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2824) = off_101A35B18;
      *(void *)(a1 + 2832) = v2;
      v69 = v45;
    }
    *(void *)(a1 + 2848) = v44;
  }
  sub_100A8E3D4(&v67);
  uint64_t v46 = *(void *)(a1 + 2848);
  if (v46) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v46 + 48))(v46, a1 + 2856);
  }
  char v47 = (uint64_t (***)())(a1 + 2880);
  unsigned int v67 = off_101A35BA8;
  v68 = (void *)(a1 + 64);
  v69 = &v67;
  if (&v67 != (uint64_t (***)())(a1 + 2880))
  {
    v48 = *(uint64_t (****)())(a1 + 2904);
    if (v48 == v47)
    {
      uint64_t v73 = a1 + 64;
      uint64_t v74 = 0;
      unint64_t v72 = off_101A35BA8;
      v69 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v47)[3])(a1 + 2880, &v67);
      (*(void (**)(void))(**(void **)(a1 + 2904) + 32))(*(void *)(a1 + 2904));
      *(void *)(a1 + 2904) = 0;
      v69 = &v67;
      ((void (*)(uint64_t (***)(), uint64_t))v72[3])(&v72, a1 + 2880);
      ((void (*)(uint64_t (***)()))v72[4])(&v72);
    }
    else
    {
      *(void *)(a1 + 2880) = off_101A35BA8;
      *(void *)(a1 + 2888) = v2;
      v69 = v48;
    }
    *(void *)(a1 + 2904) = v47;
  }
  sub_100A8E350(&v67);
  uint64_t v49 = *(void *)(a1 + 2904);
  if (v49) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v49 + 48))(v49, a1 + 2912);
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)a1 + 40))(a1, 3, 0, 0);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 48))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, 3, 0xFFFFFFFFLL, 0xFFFFFFFFLL);
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)&v67);
  (*(void (**)(uint64_t, uint64_t, uint64_t (***)(), uint64_t, void, void))(*(void *)a1 + 80))(a1, 3, &v67, 11, 0, 0);
  if (v71 < 0) {
    operator delete(v70);
  }
  if (SHIBYTE(v69) < 0) {
    operator delete(v68);
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 128))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 136))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, 3, 11);
  MCC::MCC((MCC *)v62);
  MNC::MNC((MNC *)v59);
  (*(void (**)(uint64_t, uint64_t, char *, char *))(*(void *)a1 + 264))(a1, 3, v62, v59);
  if (v61 < 0) {
    operator delete(__p);
  }
  if (v64 < 0) {
    operator delete(v63);
  }
  MCC::MCC((MCC *)v56);
  (*(void (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 280))(a1, 3, v56);
  if (v58 < 0) {
    operator delete(v57);
  }
  MNC::MNC((MNC *)v53);
  (*(void (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 288))(a1, 3, v53);
  if (v55 < 0) {
    operator delete(v54);
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 256))(a1, 3, 0);
  (*(void (**)(uint64_t, uint64_t, void, uint64_t, void, void))(*(void *)a1 + 160))(a1, 3, 0, 11, 0, 0);
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 168))(a1, 3, 0, 11);
  int v50 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)a1 + 96))(a1, 3, &v50, 0);
  if (v50)
  {
    uint64_t v51 = v50;
    operator delete(v50);
  }
}

void sub_100A89408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A894E0(void *a1, uint64_t a2)
{
  v4[0] = off_101A35268;
  v4[1] = a2;
  v4[3] = v4;
  sub_100A8FB58(v4, a1);
  sub_100A8E0C4(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

uint64_t sub_100A895A0(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

uint64_t RegistrationEventHandler::RegistrationEventHandler(uint64_t a1, void *a2, dispatch_object_t *a3, void *a4)
{
  int v8 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v62, kCtLoggingSystemName, "reg.evt");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v61, &v62);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)v61);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v61);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v62);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A34D08;
  *(void *)(a1 + 32) = *a4;
  uint64_t v9 = a4[1];
  *(void *)(a1 + 40) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 56) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "Registration Event Handler");
  char v58 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v58) {
    dispatch_release(v58);
  }
  if (v60 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = a1 + 120;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 216) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 224));
  *(void *)(a1 + 1048) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 1056));
  *(void *)(a1 + 1880) = 0;
  *(_DWORD *)(a1 + 1887) = 0;
  *(void *)(a1 + 1920) = 0;
  *(_DWORD *)(a1 + 1927) = 0;
  *(void *)(a1 + 1968) = 0;
  *(void *)(a1 + 1960) = 0;
  *(unsigned char *)(a1 + 1976) = 0;
  *(void *)(a1 + 2008) = 0;
  sub_100A92CFC((uint64_t *)(a1 + 2016), (uint64_t)&rest::kDefaultCipherDomains);
  *(void *)(a1 + 2064) = 0;
  sub_10005DF14((uint64_t *)(a1 + 2072), (uint64_t)&rest::kDefaultNetworkScanState);
  *(void *)(a1 + 2120) = 0;
  *(void *)(a1 + 2144) = 0;
  *(void *)(a1 + 2136) = 0;
  *(void *)(a1 + 2128) = a1 + 2136;
  *(void *)(a1 + 2176) = 0;
  *(void *)(a1 + 2200) = 0;
  *(void *)(a1 + 2192) = 0;
  *(void *)(a1 + 2184) = a1 + 2192;
  *(void *)(a1 + 2232) = 0;
  *(void *)(a1 + 2256) = 0;
  *(void *)(a1 + 2248) = 0;
  *(void *)(a1 + 2240) = a1 + 2248;
  *(void *)(a1 + 2288) = 0;
  *(void *)(a1 + 2312) = 0;
  *(void *)(a1 + 2304) = 0;
  *(void *)(a1 + 2296) = a1 + 2304;
  *(void *)(a1 + 2344) = 0;
  *(void *)(a1 + 2368) = 0;
  *(void *)(a1 + 2360) = 0;
  *(void *)(a1 + 2352) = a1 + 2360;
  *(void *)(a1 + 2400) = 0;
  *(void *)(a1 + 2424) = 0;
  *(void *)(a1 + 2416) = 0;
  *(void *)(a1 + 2408) = a1 + 2416;
  *(void *)(a1 + 2456) = 0;
  *(void *)(a1 + 2472) = 0;
  *(void *)(a1 + 2480) = 0;
  *(void *)(a1 + 2464) = a1 + 2472;
  *(void *)(a1 + 2512) = 0;
  sub_10005DFF8((uint64_t *)(a1 + 2520), (uint64_t)&rest::kDefaultLastVisiblePlmns);
  *(void *)(a1 + 2568) = 0;
  *(void *)(a1 + 2592) = 0;
  *(void *)(a1 + 2584) = 0;
  *(void *)(a1 + 2576) = a1 + 2584;
  *(void *)(a1 + 2624) = 0;
  int v11 = (uint64_t **)(a1 + 2640);
  *(void *)(a1 + 2648) = 0;
  *(void *)(a1 + 2640) = 0;
  *(void *)(a1 + 2632) = a1 + 2640;
  uint64_t v12 = (void *)rest::kDefaultLastVisibleMccs;
  if ((_UNKNOWN *)rest::kDefaultLastVisibleMccs != (_UNKNOWN *)((char *)&rest::kDefaultLastVisibleMccs + 8))
  {
    do
    {
      uint64_t v13 = *v11;
      uint64_t v14 = (uint64_t *)(a1 + 2640);
      if (*(uint64_t ***)(a1 + 2632) == v11) {
        goto LABEL_18;
      }
      uint64_t v15 = *v11;
      uint64_t v16 = (uint64_t *)(a1 + 2640);
      if (v13)
      {
        do
        {
          uint64_t v14 = v15;
          uint64_t v15 = (uint64_t *)v15[1];
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v14 = (uint64_t *)v16[2];
          BOOL v17 = *v14 == (void)v16;
          uint64_t v16 = v14;
        }
        while (v17);
      }
      int v18 = *((_DWORD *)v12 + 8);
      if (*((_DWORD *)v14 + 8) < v18)
      {
LABEL_18:
        if (v13) {
          uint64_t v19 = (uint64_t **)v14;
        }
        else {
          uint64_t v19 = (uint64_t **)(a1 + 2640);
        }
        if (v13) {
          char v20 = (uint64_t **)(v14 + 1);
        }
        else {
          char v20 = (uint64_t **)(a1 + 2640);
        }
        if (*v20) {
          goto LABEL_35;
        }
      }
      else
      {
        char v20 = (uint64_t **)(a1 + 2640);
        uint64_t v19 = (uint64_t **)(a1 + 2640);
        if (v13)
        {
          uint64_t v21 = *v11;
          while (1)
          {
            while (1)
            {
              uint64_t v19 = (uint64_t **)v21;
              int v22 = *((_DWORD *)v21 + 8);
              if (v22 <= v18) {
                break;
              }
              uint64_t v21 = *v19;
              char v20 = v19;
              if (!*v19) {
                goto LABEL_34;
              }
            }
            if (v22 >= v18) {
              goto LABEL_35;
            }
            uint64_t v21 = v19[1];
            if (!v21)
            {
              char v20 = v19 + 1;
              break;
            }
          }
        }
      }
LABEL_34:
      uint64_t v63 = 0;
      int v23 = (uint64_t *)operator new(0x48uLL);
      v62.var1.fRef = (os_log_s *)(a1 + 2640);
      *((_DWORD *)v23 + 8) = *((_DWORD *)v12 + 8);
      MCC::MCC((MCC *)(v23 + 5), (const MCC *)(v12 + 5));
      sub_100046C38((uint64_t **)(a1 + 2632), (uint64_t)v19, v20, v23);
LABEL_35:
      int v24 = (void *)v12[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v12[2];
          BOOL v17 = *v25 == (void)v12;
          uint64_t v12 = v25;
        }
        while (!v17);
      }
      uint64_t v12 = v25;
    }
    while (v25 != (void *)((char *)&rest::kDefaultLastVisibleMccs + 8));
  }
  *(void *)(a1 + 2680) = 0;
  int v26 = (uint64_t **)(a1 + 2696);
  *(void *)(a1 + 2704) = 0;
  *(void *)(a1 + 2696) = 0;
  *(void *)(a1 + 2688) = a1 + 2696;
  uint64_t v27 = (void *)rest::kDefaultLastVisibleMncs;
  if ((_UNKNOWN *)rest::kDefaultLastVisibleMncs != (_UNKNOWN *)((char *)&rest::kDefaultLastVisibleMncs + 8))
  {
    uint64_t v28 = 0;
    uint64_t v29 = (uint64_t **)(a1 + 2696);
    while (1)
    {
      int v30 = (uint64_t *)(a1 + 2696);
      if (v29 == v26) {
        goto LABEL_49;
      }
      uint64_t v31 = v28;
      uint64_t v32 = (uint64_t *)(a1 + 2696);
      if (v28)
      {
        do
        {
          int v30 = v31;
          uint64_t v31 = (uint64_t *)v31[1];
        }
        while (v31);
      }
      else
      {
        do
        {
          int v30 = (uint64_t *)v32[2];
          BOOL v17 = *v30 == (void)v32;
          uint64_t v32 = v30;
        }
        while (v17);
      }
      int v33 = *((_DWORD *)v27 + 8);
      if (*((_DWORD *)v30 + 8) < v33)
      {
LABEL_49:
        if (v28) {
          BOOL v34 = (uint64_t **)v30;
        }
        else {
          BOOL v34 = (uint64_t **)(a1 + 2696);
        }
        if (v28) {
          uint64_t v35 = (uint64_t **)(v30 + 1);
        }
        else {
          uint64_t v35 = (uint64_t **)(a1 + 2696);
        }
        if (!*v35)
        {
LABEL_65:
          v38 = (uint64_t *)operator new(0x48uLL);
          *((_DWORD *)v38 + 8) = *((_DWORD *)v27 + 8);
          MCC::MCC((MCC *)(v38 + 5), (const MCC *)(v27 + 5));
          sub_100046C38((uint64_t **)(a1 + 2688), (uint64_t)v34, v35, v38);
        }
      }
      else
      {
        uint64_t v35 = (uint64_t **)(a1 + 2696);
        BOOL v34 = (uint64_t **)(a1 + 2696);
        if (!v28) {
          goto LABEL_65;
        }
        uint64_t v36 = v28;
        while (1)
        {
          while (1)
          {
            BOOL v34 = (uint64_t **)v36;
            int v37 = *((_DWORD *)v36 + 8);
            if (v37 <= v33) {
              break;
            }
            uint64_t v36 = *v34;
            uint64_t v35 = v34;
            if (!*v34) {
              goto LABEL_65;
            }
          }
          if (v37 >= v33) {
            break;
          }
          uint64_t v36 = v34[1];
          if (!v36)
          {
            uint64_t v35 = v34 + 1;
            goto LABEL_65;
          }
        }
      }
      uint64_t v39 = (void *)v27[1];
      if (v39)
      {
        do
        {
          uint64_t v40 = v39;
          uint64_t v39 = (void *)*v39;
        }
        while (v39);
      }
      else
      {
        do
        {
          uint64_t v40 = (void *)v27[2];
          BOOL v17 = *v40 == (void)v27;
          uint64_t v27 = v40;
        }
        while (!v17);
      }
      if (v40 == (void *)((char *)&rest::kDefaultLastVisibleMncs + 8)) {
        break;
      }
      uint64_t v28 = *v26;
      uint64_t v29 = *(uint64_t ***)(a1 + 2688);
      uint64_t v27 = v40;
    }
  }
  *(void *)(a1 + 2736) = 0;
  sub_10098AC2C((uint64_t *)(a1 + 2744), (uint64_t)&rest::kDefaultTrackingAreaUpdateTimers);
  *(void *)(a1 + 2792) = 0;
  char v41 = (uint64_t **)(a1 + 2808);
  *(void *)(a1 + 2816) = 0;
  *(void *)(a1 + 2808) = 0;
  *(void *)(a1 + 2800) = a1 + 2808;
  uint64_t v42 = (void *)rest::kDefaultNetworkRejects;
  if ((_UNKNOWN *)rest::kDefaultNetworkRejects != (_UNKNOWN *)((char *)&rest::kDefaultNetworkRejects + 8))
  {
    uint64_t v43 = 0;
    v44 = (uint64_t **)(a1 + 2808);
    while (1)
    {
      int v45 = *((_DWORD *)v42 + 7);
      uint64_t v46 = (uint64_t *)(a1 + 2808);
      if (v44 == v41) {
        goto LABEL_81;
      }
      char v47 = v43;
      v48 = (uint64_t *)(a1 + 2808);
      if (v43)
      {
        do
        {
          uint64_t v46 = v47;
          char v47 = (uint64_t *)v47[1];
        }
        while (v47);
      }
      else
      {
        do
        {
          uint64_t v46 = (uint64_t *)v48[2];
          BOOL v17 = *v46 == (void)v48;
          v48 = v46;
        }
        while (v17);
      }
      if (*((_DWORD *)v46 + 7) < v45)
      {
LABEL_81:
        if (v43) {
          uint64_t v49 = (uint64_t **)v46;
        }
        else {
          uint64_t v49 = (uint64_t **)(a1 + 2808);
        }
        if (v43) {
          int v50 = (uint64_t **)(v46 + 1);
        }
        else {
          int v50 = (uint64_t **)(a1 + 2808);
        }
        if (!*v50)
        {
LABEL_97:
          CFTypeRef v53 = (char *)operator new(0x28uLL);
          uint64_t v54 = *(void *)((char *)v42 + 28);
          *((_DWORD *)v53 + 9) = *((_DWORD *)v42 + 9);
          *(void *)(v53 + 28) = v54;
          sub_100046C38((uint64_t **)(a1 + 2800), (uint64_t)v49, v50, (uint64_t *)v53);
        }
      }
      else
      {
        int v50 = (uint64_t **)(a1 + 2808);
        uint64_t v49 = (uint64_t **)(a1 + 2808);
        if (!v43) {
          goto LABEL_97;
        }
        uint64_t v51 = v43;
        while (1)
        {
          while (1)
          {
            uint64_t v49 = (uint64_t **)v51;
            int v52 = *((_DWORD *)v51 + 7);
            if (v52 <= v45) {
              break;
            }
            uint64_t v51 = *v49;
            int v50 = v49;
            if (!*v49) {
              goto LABEL_97;
            }
          }
          if (v52 >= v45) {
            break;
          }
          uint64_t v51 = v49[1];
          if (!v51)
          {
            int v50 = v49 + 1;
            goto LABEL_97;
          }
        }
      }
      char v55 = (void *)v42[1];
      if (v55)
      {
        do
        {
          v56 = v55;
          char v55 = (void *)*v55;
        }
        while (v55);
      }
      else
      {
        do
        {
          v56 = (void *)v42[2];
          BOOL v17 = *v56 == (void)v42;
          uint64_t v42 = v56;
        }
        while (!v17);
      }
      if (v56 == (void *)((char *)&rest::kDefaultNetworkRejects + 8)) {
        break;
      }
      uint64_t v43 = *v41;
      v44 = *(uint64_t ***)(a1 + 2800);
      uint64_t v42 = v56;
    }
  }
  *(void *)(a1 + 2848) = 0;
  sub_100A92D54((uint64_t *)(a1 + 2856), (uint64_t)&rest::kDefaultImsPreferenceStates);
  *(void *)(a1 + 2904) = 0;
  *(void *)(a1 + 2928) = 0;
  *(void *)(a1 + 2920) = 0;
  *(void *)(a1 + 2912) = a1 + 2920;
  return a1;
}

void sub_100A89D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, ctu::OsLogLogger *a20,dispatch_object_t object,dispatch_object_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_100A8E3D4((void *)v28 + 353);
  sub_100A89F64(a9);
  sub_100A89FA4(a10);
  sub_100A89FE4(a11);
  sub_100A8A020(a12);
  sub_100A8A060((uint64_t)v28 + 2544);
  sub_100A8A060(a13);
  sub_100A8A0A0((uint64_t)v28 + 2432);
  sub_100A8A0E0((uint64_t)v28 + 2376);
  sub_100A8A120((uint64_t)v28 + 2320);
  sub_100A8A160((uint64_t)v28 + 2264);
  sub_100417F2C((uint64_t)v28 + 2208);
  sub_100417F2C((uint64_t)v28 + 2152);
  sub_100417F2C((uint64_t)v28 + 2096);
  sub_100417F2C(a14);
  sub_100A8A1A0(a15);
  sub_100A8E0C4((void *)v28 + 242);
  sub_100A8E148(a16);
  sub_100A8E148(a17);
  sub_100A8E1CC(a18);
  sub_100A8E1CC(a19);
  sub_100A8A1E0(v29 - 40);
  sub_100A8A220(v29 - 96);
  uint64_t v31 = (std::__shared_weak_count *)*((void *)v28 + 9);
  if (v31) {
    sub_10004D2C8(v31);
  }
  uint64_t v32 = (std::__shared_weak_count *)*((void *)v28 + 7);
  if (v32) {
    sub_10004D2C8(v32);
  }
  int v33 = (std::__shared_weak_count *)*((void *)v28 + 5);
  if (v33) {
    sub_10004D2C8(v33);
  }
  BOOL v34 = (std::__shared_weak_count *)*((void *)v28 + 3);
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  ctu::OsLogLogger::~OsLogLogger(a20);
  RegistrationEventInterface::~RegistrationEventInterface(v28);
  _Unwind_Resume(a1);
}

void *sub_100A89F64(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DB40((void *)a1);
}

void *sub_100A89FA4(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DBC4((void *)a1);
}

void *sub_100A89FE4(uint64_t a1)
{
  sub_100A8DC48(*(char **)(a1 + 40));

  return sub_100A8DCA4((void *)a1);
}

void *sub_100A8A020(uint64_t a1)
{
  sub_100030EE0(a1 + 32, *(char **)(a1 + 40));

  return sub_100A8DD28((void *)a1);
}

void *sub_100A8A060(uint64_t a1)
{
  sub_10003FB28(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DDAC((void *)a1);
}

void *sub_100A8A0A0(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DE30((void *)a1);
}

void *sub_100A8A0E0(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_100A8DEB4((void *)a1);
}

void *sub_100A8A120(uint64_t a1)
{
  sub_10003FB28(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DF38((void *)a1);
}

void *sub_100A8A160(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8DFBC((void *)a1);
}

void *sub_100A8A1A0(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8E040((void *)a1);
}

void *sub_100A8A1E0(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8E248((void *)a1);
}

void *sub_100A8A220(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A8E2CC((void *)a1);
}

void sub_100A8A260(uint64_t a1)
{
  *(void *)a1 = off_101A34D08;
  uint64_t v2 = (void *)(a1 + 2880);
  sub_1000346F8(a1 + 2912, *(void **)(a1 + 2920));
  sub_100A8E350(v2);
  sub_10026CF54(a1 + 2856, *(void **)(a1 + 2864));
  sub_100A8E3D4((void *)(a1 + 2824));
  sub_1000346F8(a1 + 2800, *(void **)(a1 + 2808));
  sub_100A8DB40((void *)(a1 + 2768));
  sub_1000346F8(a1 + 2744, *(void **)(a1 + 2752));
  sub_100A8DBC4((void *)(a1 + 2712));
  sub_100A8DC48(*(char **)(a1 + 2696));
  sub_100A8DCA4((void *)(a1 + 2656));
  sub_100030EE0(a1 + 2632, *(char **)(a1 + 2640));
  sub_100A8DD28((void *)(a1 + 2600));
  sub_10003FB28(a1 + 2576, *(void **)(a1 + 2584));
  sub_100A8DDAC((void *)(a1 + 2544));
  sub_10003FB28(a1 + 2520, *(void **)(a1 + 2528));
  sub_100A8DDAC((void *)(a1 + 2488));
  sub_1000346F8(a1 + 2464, *(void **)(a1 + 2472));
  sub_100A8DE30((void *)(a1 + 2432));
  sub_10005CD2C(a1 + 2408, *(char **)(a1 + 2416));
  sub_100A8DEB4((void *)(a1 + 2376));
  sub_10003FB28(a1 + 2352, *(void **)(a1 + 2360));
  sub_100A8DF38((void *)(a1 + 2320));
  sub_1000346F8(a1 + 2296, *(void **)(a1 + 2304));
  sub_100A8DFBC((void *)(a1 + 2264));
  sub_1000346F8(a1 + 2240, *(void **)(a1 + 2248));
  sub_10041A760((void *)(a1 + 2208));
  sub_1000346F8(a1 + 2184, *(void **)(a1 + 2192));
  sub_10041A760((void *)(a1 + 2152));
  sub_1000346F8(a1 + 2128, *(void **)(a1 + 2136));
  sub_10041A760((void *)(a1 + 2096));
  sub_1000346F8(a1 + 2072, *(void **)(a1 + 2080));
  sub_10041A760((void *)(a1 + 2040));
  sub_1000346F8(a1 + 2016, *(void **)(a1 + 2024));
  sub_100A8E040((void *)(a1 + 1984));
  sub_100A8E0C4((void *)(a1 + 1936));
  sub_100A8E148((void *)(a1 + 1896));
  sub_100A8E148((void *)(a1 + 1856));
  sub_100A8E1CC(a1 + 1024);
  sub_100A8E1CC(a1 + 192);
  sub_1000346F8(a1 + 168, *(void **)(a1 + 176));
  sub_100A8E248((void *)(a1 + 136));
  sub_1000346F8(a1 + 112, *(void **)(a1 + 120));
  sub_100A8E2CC((void *)(a1 + 80));
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  RegistrationEventInterface::~RegistrationEventInterface((RegistrationEventInterface *)a1);
}

void sub_100A8A4D8(uint64_t a1)
{
  sub_100A8A260(a1);

  operator delete();
}

uint64_t sub_100A8A510(uint64_t a1, int a2, uint64_t a3)
{
  char v3 = a3;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 32) + 80))(*(void *)(a1 + 32), a3);
  sub_100358C28((uint64_t)&event::registration::emergencyCallbackModeChanged, v3);
  v7[0] = 1;
  v7[1] = a1 + 1936;
  *(_DWORD *)(a1 + 1968) = a2;
  *(_DWORD *)(a1 + 1972) = 1;
  *(unsigned char *)(a1 + 1976) = v3;
  return sub_100A92F74((uint64_t)v7);
}

uint64_t sub_100A8A5A4(uint64_t a1, int a2, char a3, char a4)
{
  int v20 = a2;
  uint64_t v18 = 1;
  uint64_t v19 = a1 + 2096;
  uint64_t v16 = 1;
  uint64_t v17 = a1 + 2152;
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    uint64_t v7 = v13;
    uint64_t v6 = v14;
    if (v13 != v14)
    {
      int v8 = v15;
      while ((v15(*v7) & 1) == 0)
      {
        if (++v7 == v14)
        {
          uint64_t v7 = v14;
          break;
        }
      }
      uint64_t v9 = v14;
      while (v7 != v9)
      {
        int v12 = 0;
        int v12 = *v7;
        uint64_t v21 = &v12;
        *((unsigned char *)sub_10005CE78((uint64_t **)(v19 + 32), &v12, (uint64_t)&unk_10144E20E, &v21) + 32) = a3;
        uint64_t v21 = &v12;
        *((unsigned char *)sub_10005CE78((uint64_t **)(v17 + 32), &v12, (uint64_t)&unk_10144E20E, &v21) + 32) = a4;
        uint64_t v10 = v7 + 1;
        uint64_t v7 = v6;
        if (v10 != v6)
        {
          uint64_t v7 = v10;
          while ((v8(*v7) & 1) == 0)
          {
            if (++v7 == v6)
            {
              uint64_t v7 = v6;
              break;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v13 = &v20;
    *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2128), &v20, (uint64_t)&unk_10144E20E, &v13) + 32) = a3;
    uint64_t v13 = &v20;
    *((unsigned char *)sub_10005CE78((uint64_t **)(v17 + 32), &v20, (uint64_t)&unk_10144E20E, &v13) + 32) = a4;
  }
  sub_100A9303C((uint64_t)&v16);
  return sub_100A92FD8((uint64_t)&v18);
}

void sub_100A8A748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100A9303C((uint64_t)va);
  sub_100A92FD8((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8A774(uint64_t a1, int a2, int a3)
{
  int v18 = a2;
  uint64_t v16 = 1;
  uint64_t v17 = a1 + 2208;
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    int v5 = v13;
    uint64_t v4 = v14;
    if (v13 != v14)
    {
      uint64_t v6 = v15;
      while ((v15(*v5) & 1) == 0)
      {
        if (++v5 == v14)
        {
          int v5 = v14;
          break;
        }
      }
      uint64_t v7 = v14;
      while (v5 != v7)
      {
        int v12 = 0;
        int v12 = *v5;
        uint64_t v19 = &v12;
        *((unsigned char *)sub_10005CE78((uint64_t **)(v17 + 32), &v12, (uint64_t)&unk_10144E20E, &v19) + 32) = a3;
        uint64_t v8 = v5 + 1;
        int v5 = v4;
        if (v8 != v4)
        {
          int v5 = v8;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == v4)
            {
              int v5 = v4;
              break;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v13 = &v18;
    *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2240), &v18, (uint64_t)&unk_10144E20E, &v13) + 32) = a3;
    if (v18 == 1)
    {
      uint64_t v9 = (uint64_t *)&event::registration::dataNotAttached;
      if (a3) {
        uint64_t v9 = (uint64_t *)&event::registration::dataAttached;
      }
      uint64_t v10 = (uint64_t *)sub_100161CDC(v9 + 1);
      sub_10035414C(v10);
    }
  }
  return sub_100A930A0((uint64_t)&v16);
}

void sub_100A8A8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A930A0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8A90C(uint64_t a1, int a2, int a3, int a4)
{
  int v41 = a2;
  uint64_t v39 = 1;
  uint64_t v40 = a1 + 2264;
  if (a2 == 1)
  {
    if (a4 <= 0) {
      uint64_t v7 = "SIM Slot_1: Data mode changed to NoData";
    }
    else {
      uint64_t v7 = "SIM Slot_1: Data mode changed";
    }
LABEL_29:
    *(void *)&long long v49 = _os_activity_create((void *)&_mh_execute_header, v7, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    os_activity_scope_enter((os_activity_t)v49, &state);
    os_activity_scope_leave(&state);
    sub_100687EB8((void **)&v49);
    state.opaque[0] = (uint64_t)&v41;
    uint64_t v14 = sub_10072F848((uint64_t **)(v40 + 32), &v41, (uint64_t)&unk_10144E20E, &state);
    *((_DWORD *)v14 + 8) = a3;
    *((_DWORD *)v14 + 9) = a4;
    if (v41 == 1)
    {
      uint64_t v15 = (uint64_t *)sub_100A93168(&event::registration::dataModeChanged[1]);
      int v47 = a4;
      int v48 = a3;
      long long v46 = 0uLL;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      os_activity_scope_state_s state = (os_activity_scope_state_s)0;
      long long v52 = 0u;
      uint64_t v16 = (pthread_mutex_t *)sub_100060E64(v15 + 3);
      sub_100061F70(&state, v16);
      uint64_t v17 = v15[1];
      if (v17)
      {
        if (atomic_load_explicit((atomic_uint *volatile)(v17 + 8), memory_order_acquire) == 1) {
          sub_100A931AC(v15, &state, 0, 1);
        }
        uint64_t v18 = *v15;
        uint64_t v19 = v15[1];
        if (v19) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v19 + 8), 1u, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v18 = *v15;
      }
      long long v20 = v46;
      *(void *)&long long v46 = v18;
      *((void *)&v46 + 1) = v19;
      long long v49 = v20;
      sub_10000A740((atomic_uint **)&v49 + 1);
      sub_10000A6C8(*((pthread_mutex_t **)&v62 + 1));
      sub_10000A5F8(&state);
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      os_activity_scope_state_s state = (os_activity_scope_state_s)0;
      uint64_t v66 = 0;
      uint64_t v67 = 10;
      v68 = &state.opaque[1];
      uint64_t v69 = 0;
      uint64_t v70 = &v48;
      char v71 = &v47;
      uint64_t v72 = 0;
      uint64_t v73 = 0;
      uint64_t v21 = (uint64_t *)sub_100A93260((uint64_t *)&v46);
      uint64_t v22 = sub_100A934D0(v21);
      v45[0] = &state;
      v45[1] = v15;
      v45[2] = v22;
      uint64_t v23 = sub_100A93260((uint64_t *)&v46);
      sub_100060EA8((uint64_t *)(v23 + 16));
      int v24 = (uint64_t *)sub_100A93260((uint64_t *)&v46);
      uint64_t v25 = *(void *)(sub_100A934D0(v24) + 8);
      int v26 = (uint64_t *)sub_100A93260((uint64_t *)&v46);
      uint64_t v27 = sub_100A934D0(v26);
      *(void *)&long long v43 = v25;
      *((void *)&v43 + 1) = v27;
      *(void *)&long long v44 = &state;
      *((void *)&v44 + 1) = v27;
      sub_100A935AC((uint64_t *)&v43);
      uint64_t v28 = (uint64_t *)sub_100A93260((uint64_t *)&v46);
      uint64_t v29 = sub_100A934D0(v28);
      int v30 = (uint64_t *)sub_100A93260((uint64_t *)&v46);
      uint64_t v31 = sub_100A934D0(v30);
      v42[0] = v29;
      v42[1] = v31;
      v42[2] = (uint64_t)&state;
      v42[3] = v31;
      sub_100A935AC(v42);
      long long v49 = v43;
      long long v50 = v44;
      uint64_t v32 = v42[0];
      uint64_t v33 = v43;
      if ((void)v43 != v42[0])
      {
        BOOL v34 = (unsigned char *)v50;
        BOOL v35 = *(unsigned char *)v50 == 0;
        do
        {
          if (v35)
          {
            uint64_t v36 = sub_100A933E0((uint64_t *)(v33 + 16));
            uint64_t v37 = sub_100A9348C((uint64_t *)(v36 + 32));
            sub_100A93514((void *)(v37 + 24));
            if (!*v34) {
              *BOOL v34 = 1;
            }
          }
          if (!*(unsigned char *)v50) {
            __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
          }
          *(void *)&long long v49 = *(void *)(v49 + 8);
          sub_100A935AC((uint64_t *)&v49);
          BOOL v34 = (unsigned char *)v50;
          if (*(unsigned char *)v50) {
            *(unsigned char *)long long v50 = 0;
          }
          uint64_t v33 = v49;
          BOOL v35 = 1;
        }
        while ((void)v49 != v32);
      }
      sub_100A93928(v45);
      sub_100A941E4((uint64_t)&state);
      sub_10000A740((atomic_uint **)&v46 + 1);
    }
    return sub_100A93104((uint64_t)&v39);
  }
  if (a2 == 2)
  {
    if (a4 <= 0) {
      uint64_t v7 = "SIM Slot_2: Data mode changed to NoData";
    }
    else {
      uint64_t v7 = "SIM Slot_2: Data mode changed";
    }
    goto LABEL_29;
  }
  if (a2 != 3)
  {
    if (a4 <= 0) {
      uint64_t v7 = "SIM Slot_Unknown: Data mode changed to NoData";
    }
    else {
      uint64_t v7 = "SIM Slot_Unknown: Data mode changed";
    }
    goto LABEL_29;
  }
  if (a4 <= 0) {
    uint64_t v6 = "SIM Slot_All: Data mode changed to NoData";
  }
  else {
    uint64_t v6 = "SIM Slot_All: Data mode changed";
  }
  *(void *)&long long v49 = _os_activity_create((void *)&_mh_execute_header, v6, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter((os_activity_t)v49, &state);
  os_activity_scope_leave(&state);
  sub_100687EB8((void **)&v49);
  subscriber::makeSimSlotRange();
  uint64_t v9 = (_DWORD *)state.opaque[0];
  uint64_t v8 = state.opaque[1];
  if (state.opaque[0] != state.opaque[1])
  {
    uint64_t v10 = (uint64_t (*)(void))v52;
    while ((v10(*v9) & 1) == 0)
    {
      if (++v9 == (_DWORD *)v8)
      {
        uint64_t v9 = (_DWORD *)v8;
        break;
      }
    }
    uint64_t v11 = state.opaque[1];
    while (v9 != (_DWORD *)v11)
    {
      LODWORD(v43) = 0;
      LODWORD(v43) = *v9;
      *(void *)&long long v49 = &v43;
      int v12 = sub_10072F848((uint64_t **)(v40 + 32), (int *)&v43, (uint64_t)&unk_10144E20E, (_DWORD **)&v49);
      *((_DWORD *)v12 + 8) = a3;
      *((_DWORD *)v12 + 9) = a4;
      uint64_t v13 = v9 + 1;
      uint64_t v9 = (_DWORD *)v8;
      if (v13 != (_DWORD *)v8)
      {
        uint64_t v9 = v13;
        while ((v10(*v9) & 1) == 0)
        {
          if (++v9 == (_DWORD *)v8)
          {
            uint64_t v9 = (_DWORD *)v8;
            break;
          }
        }
      }
    }
  }
  return sub_100A93104((uint64_t)&v39);
}

void sub_100A8AE7C(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100A8AEF0);
}

void sub_100A8AEA8()
{
}

void sub_100A8AEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,atomic_uint *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t sub_100A8AEF8(uint64_t a1, int a2, char a3)
{
  int v16 = a2;
  uint64_t v14 = 1;
  uint64_t v15 = a1 + 2040;
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    int v5 = v11;
    uint64_t v4 = v12;
    if (v11 != v12)
    {
      uint64_t v6 = v13;
      while ((v13(*v5) & 1) == 0)
      {
        if (++v5 == v12)
        {
          int v5 = v12;
          break;
        }
      }
      uint64_t v7 = v12;
      while (v5 != v7)
      {
        int v10 = 0;
        int v10 = *v5;
        uint64_t v17 = &v10;
        *((unsigned char *)sub_10005CE78((uint64_t **)(v15 + 32), &v10, (uint64_t)&unk_10144E20E, &v17) + 32) = a3;
        uint64_t v8 = v5 + 1;
        int v5 = v4;
        if (v8 != v4)
        {
          int v5 = v8;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == v4)
            {
              int v5 = v4;
              break;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v11 = &v16;
    *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2072), &v16, (uint64_t)&unk_10144E20E, &v11) + 32) = a3;
  }
  return sub_100A942D8((uint64_t)&v14);
}

void sub_100A8B03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A942D8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8B060(uint64_t a1, int a2, int a3)
{
  int v16 = a2;
  uint64_t v14 = 1;
  uint64_t v15 = a1 + 80;
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    int v5 = (int *)v11;
    uint64_t v4 = (int *)v12;
    if (v11 != v12)
    {
      uint64_t v6 = v13;
      while ((v13(*v5) & 1) == 0)
      {
        if (++v5 == (int *)v12)
        {
          int v5 = (int *)v12;
          break;
        }
      }
      uint64_t v7 = (int *)v12;
      if (v5 != (int *)v12)
      {
        do
        {
          int v10 = 0;
          int v10 = *v5;
          uint64_t v17 = (unsigned int *)&v10;
          *((_DWORD *)sub_10030B04C((uint64_t **)(v15 + 32), &v10, (uint64_t)&unk_10144E20E, &v17) + 8) = a3;
          uint64_t v8 = v5 + 1;
          int v5 = v4;
          if (v8 != v4)
          {
            int v5 = v8;
            while ((v6(*v5) & 1) == 0)
            {
              if (++v5 == v4)
              {
                int v5 = v4;
                break;
              }
            }
          }
        }
        while (v5 != v7);
      }
    }
  }
  else
  {
    uint64_t v11 = (unsigned int *)&v16;
    *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 112), &v16, (uint64_t)&unk_10144E20E, &v11) + 8) = a3;
  }
  return sub_100A9433C((uint64_t)&v14);
}

void sub_100A8B1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A9433C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8B1C8(uint64_t a1, int a2, uint64_t a3, int a4, char a5, char a6)
{
  v35[0] = a2;
  v32[0] = 1;
  long long v33 = 0u;
  uint64_t v34 = 0;
  v32[1] = a1 + 2320;
  sub_1005BD15C((uint64_t *)&v33, a1 + 2352);
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    uint64_t v9 = v29;
    uint64_t v8 = v30;
    if (v29 != (int *)v30)
    {
      int v10 = v31;
      while ((v31(*v9) & 1) == 0)
      {
        if (++v9 == (int *)v30)
        {
          uint64_t v9 = (int *)v30;
          break;
        }
      }
      uint64_t v11 = v30;
      while (v9 != (int *)v11)
      {
        int v28 = 0;
        int v28 = *v9;
        int v12 = v28;
        MCC::MCC((MCC *)v20, (const MCC *)a3);
        MCC::MCC((MCC *)&v23, (const MCC *)(a3 + 32));
        int v26 = a4;
        LOBYTE(v27) = a5;
        HIBYTE(v27) = a6;
        uint64_t v13 = sub_100A9451C((uint64_t)&v33, v12, &v28);
        MCC::operator=();
        MCC::operator=();
        *((_DWORD *)v13 + 26) = v26;
        *((_WORD *)v13 + 54) = v27;
        if (v25 < 0) {
          operator delete(__p);
        }
        if (v22 < 0) {
          operator delete(v21);
        }
        uint64_t v14 = (unsigned int *)(v9 + 1);
        uint64_t v9 = (int *)v8;
        if (v14 != v8)
        {
          uint64_t v9 = (int *)v14;
          while ((v10(*v9) & 1) == 0)
          {
            if (++v9 == (int *)v8)
            {
              uint64_t v9 = (int *)v8;
              break;
            }
          }
        }
      }
    }
  }
  else
  {
    MCC::MCC((MCC *)v20, (const MCC *)a3);
    MCC::MCC((MCC *)&v23, (const MCC *)(a3 + 32));
    int v26 = a4;
    LOBYTE(v27) = a5;
    HIBYTE(v27) = a6;
    uint64_t v15 = sub_100A9451C((uint64_t)&v33, a2, v35);
    MCC::operator=();
    MCC::operator=();
    *((_DWORD *)v15 + 26) = v26;
    *((_WORD *)v15 + 54) = v27;
    if (v25 < 0) {
      operator delete(__p);
    }
    if (v22 < 0) {
      operator delete(v21);
    }
  }
  return sub_100A943A0((uint64_t)v32);
}

void sub_100A8B428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100A943A0((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8B47C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v21 = 1;
  uint64_t v22 = a1 + 2824;
  subscriber::makeSimSlotRange();
  uint64_t v7 = v18;
  uint64_t v6 = v19;
  if (v18 != v19)
  {
    uint64_t v8 = v20;
    while ((v20(*v7) & 1) == 0)
    {
      if (++v7 == v19)
      {
        uint64_t v7 = v19;
        break;
      }
    }
    uint64_t v9 = v19;
    while (v7 != v9)
    {
      int v17 = 0;
      int v17 = *v7;
      long long v14 = 0uLL;
      uint64_t v15 = 0;
      sub_1003FB56C(&v14, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      int v16 = a4;
      uint64_t v23 = &v17;
      int v10 = sub_10072EFDC((uint64_t **)(v22 + 32), &v17, (uint64_t)&unk_10144E20E, &v23);
      uint64_t v11 = v10[5];
      if (v11)
      {
        v10[6] = v11;
        operator delete(v11);
        v10[5] = 0;
        v10[6] = 0;
        v10[7] = 0;
      }
      *(_OWORD *)(v10 + 5) = v14;
      v10[7] = v15;
      *((_DWORD *)v10 + 16) = v16;
      int v12 = v7 + 1;
      uint64_t v7 = v6;
      if (v12 != v6)
      {
        uint64_t v7 = v12;
        while ((v8(*v7) & 1) == 0)
        {
          if (++v7 == v6)
          {
            uint64_t v7 = v6;
            break;
          }
        }
      }
    }
  }
  return sub_100A94634((uint64_t)&v21);
}

void sub_100A8B5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t sub_100A8B620(uint64_t a1, int a2, int a3)
{
  int v17 = a2;
  uint64_t v15 = 1;
  uint64_t v16 = a1 + 136;
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    int v5 = (_DWORD *)state.opaque[0];
    uint64_t v4 = state.opaque[1];
    if (state.opaque[0] != state.opaque[1])
    {
      uint64_t v6 = v14;
      while ((v14(*v5) & 1) == 0)
      {
        if (++v5 == (_DWORD *)state.opaque[1])
        {
          int v5 = (_DWORD *)state.opaque[1];
          break;
        }
      }
      uint64_t v7 = state.opaque[1];
LABEL_8:
      while (v5 != (_DWORD *)v7)
      {
        LODWORD(v12) = 0;
        LODWORD(v12) = *v5;
        *((_DWORD *)sub_1001DA584((uint64_t **)(v16 + 32), (int)v12, (unsigned int *)&v12) + 8) = a3;
        uint64_t v8 = v5 + 1;
        int v5 = (_DWORD *)v4;
        if (v8 != (_DWORD *)v4)
        {
          int v5 = v8;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == (_DWORD *)v4)
            {
              int v5 = (_DWORD *)v4;
              goto LABEL_8;
            }
          }
        }
      }
    }
    int v10 = "SIM Slot_All: Registration status update";
  }
  else
  {
    *((_DWORD *)sub_1001DA584((uint64_t **)(a1 + 168), a2, (unsigned int *)&v17) + 8) = a3;
    if (a2 == 2)
    {
      if ((a3 & 0xFFFFFFFE) == 4)
      {
        int v10 = "SIM Slot_2: Registration status update to Registered";
      }
      else if (a3 == 6)
      {
        int v10 = "SIM Slot_2: Registration status update to EmergencyOnly";
      }
      else if ((a3 & 0xFFFFFFFD) == 1)
      {
        int v10 = "SIM Slot_2: Registration status update to NotRegistered";
      }
      else
      {
        int v10 = "SIM Slot_2: Registration status update";
      }
    }
    else if (a2 == 1)
    {
      if ((a3 & 0xFFFFFFFE) == 4)
      {
        int v10 = "SIM Slot_1: Registration status update to Registered";
      }
      else if (a3 == 6)
      {
        int v10 = "SIM Slot_1: Registration status update to EmergencyOnly";
      }
      else if ((a3 & 0xFFFFFFFD) == 1)
      {
        int v10 = "SIM Slot_1: Registration status update to NotRegistered";
      }
      else
      {
        int v10 = "SIM Slot_1: Registration status update";
      }
    }
    else
    {
      int v10 = "SIM Slot_Unknown: Registration status update";
    }
  }
  int v12 = _os_activity_create((void *)&_mh_execute_header, v10, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v12, &state);
  os_activity_scope_leave(&state);
  sub_100687EB8((void **)&v12);
  return sub_100A94698((uint64_t)&v15);
}

void sub_100A8B858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100A94698((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A8B87C(uint64_t a1, int a2, char a3, char a4)
{
  if (a2 == 2)
  {
    *(unsigned char *)(a1 + 1928) = a3;
    *(unsigned char *)(a1 + 1929) = a4;
    *(unsigned char *)(a1 + 1930) = 0;
    uint64_t v4 = *(void *)(a1 + 1920);
    if (!v4) {
      return;
    }
    int v5 = *(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48);
    uint64_t v6 = a1 + 1928;
    goto LABEL_7;
  }
  if (a2 == 1)
  {
    *(unsigned char *)(a1 + 1888) = a3;
    *(unsigned char *)(a1 + 1889) = a4;
    *(unsigned char *)(a1 + 1890) = 0;
    uint64_t v4 = *(void *)(a1 + 1880);
    if (!v4) {
      return;
    }
    int v5 = *(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48);
    uint64_t v6 = a1 + 1888;
LABEL_7:
    v5(v4, v6);
    return;
  }
  uint64_t v7 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v8 = 136315138;
    uint64_t v9 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unhandled slot %s for RAT selection update", (uint8_t *)&v8, 0xCu);
  }
}

void sub_100A8B9F4(uint64_t a1, int a2)
{
  if (a2 == 2)
  {
    *(_WORD *)(a1 + 1928) = 0;
    *(unsigned char *)(a1 + 1930) = 1;
    uint64_t v2 = *(void *)(a1 + 1920);
    if (!v2) {
      return;
    }
    char v3 = *(void (**)(uint64_t, uint64_t))(*(void *)v2 + 48);
    uint64_t v4 = a1 + 1928;
    goto LABEL_7;
  }
  if (a2 == 1)
  {
    *(_WORD *)(a1 + 1888) = 0;
    *(unsigned char *)(a1 + 1890) = 1;
    uint64_t v2 = *(void *)(a1 + 1880);
    if (!v2) {
      return;
    }
    char v3 = *(void (**)(uint64_t, uint64_t))(*(void *)v2 + 48);
    uint64_t v4 = a1 + 1888;
LABEL_7:
    v3(v2, v4);
    return;
  }
  int v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    int v6 = 136315138;
    uint64_t v7 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Unhandled slot %s for RAT selection failed", (uint8_t *)&v6, 0xCu);
  }
}

uint64_t sub_100A8BB6C(uint64_t *a1, int a2, int a3)
{
  v52[1] = a1 + 297;
  v52[0] = 1;
  long long v54 = 0;
  uint64_t v55 = 0;
  long long v53 = &v54;
  uint64_t v4 = (void **)a1[301];
  int v5 = (void **)(a1 + 302);
  if (v4 != (void **)(a1 + 302))
  {
    do
    {
      long long v49 = 0;
      int v6 = v54;
      if (v53 == &v54)
      {
        int v8 = &v54;
        if (!v54) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v7 = &v54;
        if (v54)
        {
          do
          {
            int v8 = (uint64_t **)v6;
            int v6 = (uint64_t *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            int v8 = (uint64_t **)v7[2];
            BOOL v9 = *v8 == (uint64_t *)v7;
            uint64_t v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, v4 + 4) & 0x80) == 0)
        {
          int v10 = (uint64_t **)sub_100046ED4((uint64_t)&v53, &v49, v4 + 4);
          goto LABEL_11;
        }
        if (!v54)
        {
LABEL_14:
          long long v49 = &v54;
          int v10 = &v54;
LABEL_15:
          uint64_t v59 = 0;
          uint64_t v11 = (char *)operator new(0x40uLL);
          long long v57 = (uint64_t **)v11;
          long long v58 = (uint64_t *)&v54;
          int v12 = v11 + 32;
          if (*((char *)v4 + 55) < 0)
          {
            sub_10004FC84(v12, v4[4], (unint64_t)v4[5]);
          }
          else
          {
            long long v13 = *((_OWORD *)v4 + 2);
            *((void *)v11 + 6) = v4[6];
            *(_OWORD *)int v12 = v13;
          }
          *((_DWORD *)v11 + 14) = *((_DWORD *)v4 + 14);
          long long v14 = v49;
          *(void *)uint64_t v11 = 0;
          *((void *)v11 + 1) = 0;
          *((void *)v11 + 2) = v14;
          *int v10 = (uint64_t *)v11;
          if (*v53)
          {
            long long v53 = (uint64_t **)*v53;
            uint64_t v11 = (char *)*v10;
          }
          sub_100046C90(v54, (uint64_t *)v11);
          ++v55;
          goto LABEL_21;
        }
      }
      long long v49 = v8;
      int v10 = v8 + 1;
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_21:
      uint64_t v15 = (void **)v4[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void **)v4[2];
          BOOL v9 = *v16 == v4;
          uint64_t v4 = v16;
        }
        while (!v9);
      }
      uint64_t v4 = v16;
    }
    while (v16 != v5);
  }
  long long v58 = 0;
  uint64_t v59 = 0;
  long long v57 = &v58;
  long long v46 = a1 + 6;
  subscriber::makeSimSlotRange();
  int v17 = (unsigned int *)v49;
  uint64_t v18 = (unsigned int *)v50;
  if (v49 != v50)
  {
    uint64_t v19 = v51;
    do
    {
      if (v19(*v17)) {
        goto LABEL_32;
      }
      ++v17;
    }
    while (v17 != v18);
    int v17 = v18;
LABEL_32:
    long long v20 = (unsigned int *)v50;
    while (1)
    {
LABEL_33:
      if (v17 == v20) {
        goto LABEL_65;
      }
      uint64_t v21 = *v17;
      uint64_t v47 = 0;
      int v48 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v46, (Registry *)*v46);
      uint64_t v23 = ServiceMap;
      if (v24 < 0)
      {
        char v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v26 = 5381;
        do
        {
          uint64_t v24 = v26;
          unsigned int v27 = *v25++;
          uint64_t v26 = (33 * v26) ^ v27;
        }
        while (v27);
      }
      std::mutex::lock(ServiceMap);
      long long v56 = (long long *)v24;
      int v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v56);
      if (!v28) {
        break;
      }
      uint64_t v30 = v28[3];
      uint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (!v29) {
        goto LABEL_41;
      }
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      char v31 = 0;
LABEL_42:
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v30 + 8))(&v47, v30, v21);
      if ((v31 & 1) == 0) {
        sub_10004D2C8(v29);
      }
      if (v47)
      {
        uint64_t v32 = (void **)(v47 + 24);
        if (v21 == a2)
        {
          long long v56 = (long long *)(v47 + 24);
          *((_DWORD *)sub_100A94874((uint64_t **)&v57, (void **)(v47 + 24), &v56) + 14) = a3;
        }
        else
        {
          long long v33 = v54;
          if (v54)
          {
            uint64_t v34 = &v54;
            do
            {
              BOOL v35 = v34;
              uint64_t v36 = v33 + 4;
              int v37 = (char)sub_100046FE8(v33 + 4, v32);
              v38 = v33 + 1;
              if (v37 >= 0)
              {
                v38 = v33;
                uint64_t v34 = (uint64_t **)v33;
              }
              long long v33 = (uint64_t *)*v38;
            }
            while (*v38);
            if (v34 != &v54)
            {
              uint64_t v39 = v37 >= 0 ? (void **)v36 : (void **)(v35 + 4);
              if ((sub_100046FE8(v32, v39) & 0x80) == 0)
              {
                int v40 = *((_DWORD *)v34 + 14);
                long long v56 = (long long *)(v47 + 24);
                *((_DWORD *)sub_100A94874((uint64_t **)&v57, (void **)(v47 + 24), &v56) + 14) = v40;
              }
            }
          }
        }
      }
      if (v48) {
        sub_10004D2C8(v48);
      }
      int v41 = v17 + 1;
      int v17 = v18;
      if (v41 != v18)
      {
        int v17 = v41;
        while ((v19(*v17) & 1) == 0)
        {
          if (++v17 == v18)
          {
            int v17 = v18;
            goto LABEL_33;
          }
        }
      }
    }
    uint64_t v30 = 0;
LABEL_41:
    std::mutex::unlock(v23);
    uint64_t v29 = 0;
    char v31 = 1;
    goto LABEL_42;
  }
LABEL_65:
  sub_10005CD2C((uint64_t)&v53, (char *)v54);
  uint64_t v42 = (char *)v58;
  long long v53 = v57;
  long long v54 = v58;
  uint64_t v55 = v59;
  if (v59)
  {
    v58[2] = (uint64_t)&v54;
    long long v57 = &v58;
    long long v58 = 0;
    uint64_t v59 = 0;
    uint64_t v42 = 0;
  }
  else
  {
    long long v53 = &v54;
  }
  sub_10005CD2C((uint64_t)&v57, v42);
  return sub_100A946FC((uint64_t)v52);
}

void sub_100A8BFC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (a7) {
    sub_10004D2C8(a7);
  }
  sub_10005CD2C(v10 - 104, *(char **)(v10 - 96));
  sub_100A946FC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8C048(uint64_t a1, unsigned int a2, __int16 a3)
{
  unsigned int v7 = a2;
  if ((a3 & 0xFF00) != 0)
  {
    unint64_t v6 = a2 | ((unint64_t)a3 << 32);
    uint64_t v11 = 0;
    sub_10001BCA4((int *)&v6, (xpc_object_t *)&v11);
    sub_100058DB0(__p, "/cc/events/cs_voice_support_changed");
    xpc_object_t object = v11;
    uint64_t v11 = (int *)xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(object);
    xpc_object_t object = 0;
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v11);
  }
  __p[0] = (void *)1;
  __p[1] = (void *)(a1 + 2432);
  uint64_t v11 = (int *)&v7;
  *((_WORD *)sub_100A949B8((uint64_t **)(a1 + 2464), (int *)&v7, (uint64_t)&unk_10144E20E, &v11) + 16) = a3;
  return sub_100A94954((uint64_t)__p);
}

void sub_100A8C138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  xpc_release(object);
  if (a18 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v18 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8C18C(uint64_t a1, uint64_t a2, int a3)
{
  v14[0] = 1;
  long long v15 = 0u;
  uint64_t v16 = 0;
  v14[1] = a1 + 2712;
  sub_10098AC2C((uint64_t *)&v15, a1 + 2744);
  subscriber::makeSimSlotRange();
  int v5 = v11;
  uint64_t v4 = v12;
  if (v11 != v12)
  {
    unint64_t v6 = v13;
    while ((v13(*v5) & 1) == 0)
    {
      if (++v5 == v12)
      {
        int v5 = v12;
        break;
      }
    }
    unsigned int v7 = v12;
    while (v5 != v7)
    {
      int v10 = 0;
      int v10 = *v5;
      int v17 = (unsigned int *)&v10;
      *((_DWORD *)sub_10030B04C((uint64_t **)&v15, &v10, (uint64_t)&unk_10144E20E, &v17) + 8) = a3;
      int v8 = v5 + 1;
      int v5 = v4;
      if (v8 != v4)
      {
        int v5 = v8;
        while ((v6(*v5) & 1) == 0)
        {
          if (++v5 == v4)
          {
            int v5 = v4;
            break;
          }
        }
      }
    }
  }
  return sub_100A94A7C((uint64_t)v14);
}

void sub_100A8C2C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A94A7C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A8C2E4(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  uint64_t v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/subscription_changed");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100A8C38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8C3D0(uint64_t a1, int a2, char a3, int a4, char a5, char a6)
{
  if (a2 == 1)
  {
    BOOL v9 = (uint64_t *)event::registration::networkRejectPS[1];
    if (!v9) {
      __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
    }
    char v60 = a3;
    int v59 = a4;
    char v58 = a5;
    char v57 = a6;
    long long v56 = 0uLL;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    int v10 = (pthread_mutex_t *)sub_100060E64(v9 + 3);
    sub_100061F70(&v64, v10);
    uint64_t v11 = v9[1];
    if (v11)
    {
      if (atomic_load_explicit((atomic_uint *volatile)(v11 + 8), memory_order_acquire) == 1)
      {
        uint64_t v12 = v9[1];
        if (!v12 || atomic_load_explicit((atomic_uint *volatile)(v12 + 8), memory_order_acquire) != 1) {
          __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
        }
        long long v13 = (uint64_t *)sub_100A94BA8(*v9);
        uint64_t v14 = sub_100A94FB4(*v13);
        uint64_t v15 = v9[2];
        if (v15 == v14)
        {
          uint64_t v16 = (uint64_t *)sub_100A94BA8(*v9);
          uint64_t v15 = *(void *)(sub_100A94FB4(*v16) + 8);
        }
        *(void *)&long long v61 = v15;
        sub_100A94BE8(v9, (uint64_t **)&v61, 1);
      }
      uint64_t v17 = *v9;
      uint64_t v18 = v9[1];
      if (v18) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v18 + 8), 1u, memory_order_relaxed);
      }
    }
    else
    {
      uint64_t v18 = 0;
      uint64_t v17 = *v9;
    }
    long long v19 = v56;
    *(void *)&long long v56 = v17;
    *((void *)&v56 + 1) = v18;
    long long v61 = v19;
    sub_10000A740((atomic_uint **)&v61 + 1);
    sub_10000A6C8(*((pthread_mutex_t **)&v75 + 1));
    sub_10000A5F8(&v64);
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    uint64_t v79 = 0;
    uint64_t v80 = 10;
    v81 = (char *)&v64 + 8;
    uint64_t v82 = 0;
    v83 = &v60;
    v84 = &v59;
    v85 = &v58;
    v86 = &v57;
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    long long v20 = (uint64_t *)sub_100A94BA8(v56);
    uint64_t v21 = sub_100A94FB4(*v20);
    v55[0] = &v64;
    v55[1] = v9;
    v55[2] = v21;
    uint64_t v22 = sub_100A94BA8(v56);
    sub_100060EA8((uint64_t *)(v22 + 16));
    uint64_t v23 = (uint64_t *)sub_100A94BA8(v56);
    uint64_t v24 = *(void *)(sub_100A94FB4(*v23) + 8);
    char v25 = (uint64_t *)sub_100A94BA8(v56);
    uint64_t v26 = sub_100A94FB4(*v25);
    *(void *)&long long v53 = v24;
    *((void *)&v53 + 1) = v26;
    *(void *)&long long v54 = &v64;
    *((void *)&v54 + 1) = v26;
    sub_100A94FF4((uint64_t *)&v53);
    uint64_t v27 = *(void *)sub_100A94BA8(v56);
    sub_100A94FB4(v27);
    int v28 = (uint64_t *)sub_100A94BA8(v56);
    uint64_t v29 = sub_100A94FB4(*v28);
    v52[0] = v27;
    v52[1] = v29;
    void v52[2] = (uint64_t)&v64;
    v52[3] = v29;
    sub_100A94FF4(v52);
    long long v61 = v53;
    long long v62 = v54;
    uint64_t v30 = v52[0];
    uint64_t v31 = v53;
    if ((void)v53 != v52[0])
    {
      uint64_t v32 = v62;
      int v33 = *(unsigned __int8 *)v62;
      BOOL v34 = *(unsigned char *)v62 == 0;
      do
      {
        if (v34)
        {
          uint64_t v35 = sub_100A94F34(*(void *)(v31 + 16));
          uint64_t v36 = sub_100A94F74(*(void *)(v35 + 32));
          uint64_t v37 = *(void *)(v36 + 24);
          if (!v37)
          {
            std::runtime_error::runtime_error(&v63, "call to empty boost::function");
            v63.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
            sub_100098518(&v63);
          }
          (*(void (**)(uint64_t, void, void, void, void))((v37 & 0xFFFFFFFFFFFFFFFELL) + 8))(v36 + 32, **(unsigned __int8 **)(v32 + 272), **(unsigned int **)(v32 + 280), **(unsigned __int8 **)(v32 + 288), **(unsigned __int8 **)(v32 + 296));
          if (!*(unsigned char *)v32) {
            *(unsigned char *)uint64_t v32 = 1;
          }
        }
        else if (!v33)
        {
          __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
        }
        *(void *)&long long v61 = *(void *)(v31 + 8);
        sub_100A94FF4((uint64_t *)&v61);
        uint64_t v32 = v62;
        if (*(unsigned char *)v62) {
          *(unsigned char *)long long v62 = 0;
        }
        int v33 = 0;
        uint64_t v31 = v61;
        BOOL v34 = 1;
      }
      while ((void)v61 != v30);
    }
    sub_100A953E0(v55);
    sub_100A95BBC((uint64_t)&v64);
    sub_10000A740((atomic_uint **)&v56 + 1);
  }
  *(void *)&long long v61 = 1;
  *((void *)&v61 + 1) = a1 + 2768;
  subscriber::makeSimSlotRange();
  v38 = (int *)*((void *)&v64 + 1);
  uint64_t v39 = (int *)v64;
  if ((void)v64 != *((void *)&v64 + 1))
  {
    int v40 = (uint64_t (*)(void))v65;
    while ((v40(*v39) & 1) == 0)
    {
      if (++v39 == v38)
      {
        uint64_t v39 = v38;
        break;
      }
    }
    int v41 = (int *)*((void *)&v64 + 1);
LABEL_33:
    while (v39 != v41)
    {
      LODWORD(v53) = 0;
      int v42 = *v39;
      LODWORD(v53) = *v39;
      uint64_t v43 = *(void *)(*((void *)&v61 + 1) + 40);
      long long v44 = (uint64_t **)(*((void *)&v61 + 1) + 32);
      if (!v43) {
        goto LABEL_44;
      }
      uint64_t v45 = *((void *)&v61 + 1) + 40;
      do
      {
        int v46 = *(_DWORD *)(v43 + 28);
        BOOL v47 = v46 < v42;
        if (v46 >= v42) {
          int v48 = (uint64_t *)v43;
        }
        else {
          int v48 = (uint64_t *)(v43 + 8);
        }
        if (!v47) {
          uint64_t v45 = v43;
        }
        uint64_t v43 = *v48;
      }
      while (*v48);
      if (v45 != *((void *)&v61 + 1) + 40 && v42 >= *(_DWORD *)(v45 + 28))
      {
        *((unsigned char *)sub_100A95D14(v44, v42, &v53) + 32) = a3;
        long long v49 = sub_100A95D14((uint64_t **)(*((void *)&v61 + 1) + 32), v42, &v53);
      }
      else
      {
LABEL_44:
        long long v49 = sub_100A95D14(v44, v42, &v53);
        *((unsigned char *)v49 + 32) = a3;
        *((unsigned char *)v49 + 33) = 0;
      }
      *((_DWORD *)v49 + 9) = a4;
      long long v50 = v39 + 1;
      uint64_t v39 = v38;
      if (v50 != v38)
      {
        uint64_t v39 = v50;
        while ((v40(*v39) & 1) == 0)
        {
          if (++v39 == v38)
          {
            uint64_t v39 = v38;
            goto LABEL_33;
          }
        }
      }
    }
  }
  return sub_100A95CB0((uint64_t)&v61);
}

void sub_100A8C994()
{
  sub_10000A740(&v0);
  JUMPOUT(0x100A8C9FCLL);
}

void sub_100A8C99C()
{
}

void sub_100A8C9C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_100A8C9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  sub_100A95CB0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A8C9F4(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x100A8C9FCLL);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100A8CA0C(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v20 = 1;
  uint64_t v21 = a1 + 2768;
  subscriber::makeSimSlotRange();
  unint64_t v6 = v17;
  if (v17 != (int *)v18)
  {
    while ((v19(*v6) & 1) == 0)
    {
      if (++v6 == (int *)v18)
      {
        unint64_t v6 = (int *)v18;
        break;
      }
    }
LABEL_5:
    while (v6 != (int *)v18)
    {
      uint64_t v7 = *(void *)(v21 + 40);
      xpc_object_t v8 = (uint64_t **)(v21 + 32);
      int v9 = *v6;
      if (!v7) {
        goto LABEL_16;
      }
      uint64_t v10 = v21 + 40;
      do
      {
        int v11 = *(_DWORD *)(v7 + 28);
        BOOL v12 = v11 < v9;
        if (v11 >= v9) {
          long long v13 = (uint64_t *)v7;
        }
        else {
          long long v13 = (uint64_t *)(v7 + 8);
        }
        if (!v12) {
          uint64_t v10 = v7;
        }
        uint64_t v7 = *v13;
      }
      while (*v13);
      if (v10 != v21 + 40 && v9 >= *(_DWORD *)(v10 + 28))
      {
        *((unsigned char *)sub_100A95D14(v8, v9, v6) + 33) = a3;
        uint64_t v14 = sub_100A95D14((uint64_t **)(v21 + 32), *v6, v6);
      }
      else
      {
LABEL_16:
        uint64_t v14 = sub_100A95D14(v8, v9, v6);
        *((unsigned char *)v14 + 32) = 0;
        *((unsigned char *)v14 + 33) = a3;
      }
      *((_DWORD *)v14 + 9) = a4;
      uint64_t v15 = (unsigned int *)(v6 + 1);
      unint64_t v6 = (int *)v18;
      if (v15 != v18)
      {
        unint64_t v6 = (int *)v15;
        while ((v19(*v6) & 1) == 0)
        {
          if (++v6 == (int *)v18)
          {
            unint64_t v6 = (int *)v18;
            goto LABEL_5;
          }
        }
      }
    }
  }
  return sub_100A95CB0((uint64_t)&v20);
}

void sub_100A8CB54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A95CB0((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_100A8CB78(uint64_t a1, int a2, char a3)
{
  LODWORD(v31) = a2;
  uint64_t v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  sub_10004DE24((uint64_t)&v39);
  int v5 = (void *)subscriber::operator<<();
  sub_10004B96C(v5, (uint64_t)", ", 2);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)&v39 + 8, __p);
  sub_1001AA668(&event::activation::serviceProvisioned[3], (uint64_t *)__p);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(*((void **)&v43 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  unint64_t v6 = (uint64_t *)sub_100A95DC8(&event::activation::serviceProvisioned[1]);
  int v36 = a2;
  char v35 = a3;
  long long v34 = 0uLL;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  uint64_t v7 = (pthread_mutex_t *)sub_100060E64(v6 + 3);
  sub_100061F70(&v39, v7);
  uint64_t v8 = v6[1];
  if (v8)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v8 + 8), memory_order_acquire) == 1) {
      sub_100A95E0C(v6, &v39, 0, 1);
    }
    uint64_t v9 = *v6;
    uint64_t v10 = v6[1];
    if (v10) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = *v6;
  }
  long long v11 = v34;
  *(void *)&long long v34 = v9;
  *((void *)&v34 + 1) = v10;
  *(_OWORD *)long long __p = v11;
  sub_10000A740((atomic_uint **)&__p[1]);
  sub_10000A6C8(*((pthread_mutex_t **)&v50 + 1));
  sub_10000A5F8(&v39);
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  *(void *)&long long v54 = 0;
  *((void *)&v54 + 1) = 10;
  uint64_t v55 = (char *)&v39 + 8;
  uint64_t v56 = 0;
  char v57 = &v36;
  char v58 = &v35;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  BOOL v12 = (uint64_t *)sub_100A95EC0((uint64_t *)&v34);
  v33[0] = &v39;
  v33[1] = v6;
  v33[2] = sub_100A96130(v12);
  uint64_t v13 = sub_100A95EC0((uint64_t *)&v34);
  sub_100060EA8((uint64_t *)(v13 + 16));
  uint64_t v14 = (uint64_t *)sub_100A95EC0((uint64_t *)&v34);
  uint64_t v15 = *(void *)(sub_100A96130(v14) + 8);
  uint64_t v16 = (uint64_t *)sub_100A95EC0((uint64_t *)&v34);
  *(void *)&long long v31 = v15;
  *((void *)&v31 + 1) = sub_100A96130(v16);
  *(void *)&long long v32 = &v39;
  *((void *)&v32 + 1) = *((void *)&v31 + 1);
  sub_100A9620C((uint64_t *)&v31);
  uint64_t v17 = (uint64_t *)sub_100A95EC0((uint64_t *)&v34);
  uint64_t v18 = sub_100A96130(v17);
  long long v19 = (uint64_t *)sub_100A95EC0((uint64_t *)&v34);
  uint64_t v27 = (void *)v18;
  uint64_t v28 = sub_100A96130(v19);
  uint64_t v29 = &v39;
  uint64_t v30 = v28;
  sub_100A9620C((uint64_t *)&v27);
  *(_OWORD *)long long __p = v31;
  long long v38 = v32;
  uint64_t v20 = v27;
  uint64_t v21 = (uint64_t *)v31;
  if ((void *)v31 != v27)
  {
    uint64_t v22 = (unsigned char *)v38;
    BOOL v23 = *(unsigned char *)v38 == 0;
    do
    {
      if (v23)
      {
        uint64_t v24 = sub_100A96040(v21 + 2);
        uint64_t v25 = sub_100A960EC((uint64_t *)(v24 + 32));
        sub_100A96174((void *)(v25 + 24));
        if (!*v22) {
          *uint64_t v22 = 1;
        }
      }
      if (!*(unsigned char *)v38) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      __p[0] = *((void **)__p[0] + 1);
      sub_100A9620C((uint64_t *)__p);
      uint64_t v22 = (unsigned char *)v38;
      if (*(unsigned char *)v38) {
        *(unsigned char *)long long v38 = 0;
      }
      uint64_t v21 = (uint64_t *)__p[0];
      BOOL v23 = 1;
    }
    while (__p[0] != v20);
  }
  sub_100A96588(v33);
  sub_100A96E44((uint64_t)&v39);
  return sub_10000A740((atomic_uint **)&v34 + 1);
}

void sub_100A8D02C(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100A8D180);
}

void sub_100A8D064()
{
}

void sub_100A8D06C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void (__cdecl **a32)(std::stringbuf *__hidden this),uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  _Unwind_Resume(v45);
}

atomic_uint **sub_100A8D188(uint64_t a1, char a2)
{
  return sub_100358C28((uint64_t)&event::registration::cambioMode, a2);
}

void sub_100A8D194()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/e911_state_ready");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A8D234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100A8D278()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/e911_chosen_slot");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A8D314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100A8D358(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  char v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/e911_scan_failed");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100A8D400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100A8D444()
{
  sub_100058DB0(&__p, "/cc/events/e911_state_exit_completed");
  xpc_object_t object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_100A8D4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100A8D4E8(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = &_mh_execute_header;
  if (!a3) {
    uint64_t v3 = 0;
  }
  unint64_t v4 = (unint64_t)v3 | a2;
  xpc_object_t v8 = 0;
  sub_10001BCA4((int *)&v4, &v8);
  sub_100058DB0(&__p, "/cc/events/first_scan_completed");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100A8D598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8D5DC(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 32) + 88))(*(void *)(a1 + 32), a3, a4);
  }
  int v5 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 40);

  return v5();
}

uint64_t sub_100A8D670(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 32) + 96))(*(void *)(a1 + 32), a3, a4);
  }
  int v5 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 104);

  return v5();
}

void sub_100A8D714(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v6 = *(void *)(a3 + 16);
  }
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v4 + 24))(v4, a2, __p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A8D7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A8D7C4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v17 = 1;
  uint64_t v18 = a1 + 1984;
  subscriber::makeSimSlotRange();
  uint64_t v4 = v14;
  if (v14 != v15)
  {
    while ((v16(*v4) & 1) == 0)
    {
      if (++v4 == v15)
      {
        uint64_t v4 = v15;
        break;
      }
    }
LABEL_5:
    while (v4 != v15)
    {
      signed int v5 = *v4;
      uint64_t v7 = v18 + 40;
      uint64_t v6 = *(void *)(v18 + 40);
      if (v6)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v8 = v6;
            signed int v9 = *(_DWORD *)(v6 + 28);
            if (v9 <= v5) {
              break;
            }
            uint64_t v6 = *(void *)v8;
            uint64_t v10 = (uint64_t **)v8;
            if (!*(void *)v8) {
              goto LABEL_14;
            }
          }
          if (v9 >= v5) {
            break;
          }
          uint64_t v6 = *(void *)(v8 + 8);
          if (!v6)
          {
            uint64_t v10 = (uint64_t **)(v8 + 8);
            goto LABEL_14;
          }
        }
      }
      else
      {
        uint64_t v10 = (uint64_t **)(v18 + 40);
        uint64_t v8 = v18 + 40;
LABEL_14:
        long long v11 = (uint64_t *)operator new(0x28uLL);
        *((_DWORD *)v11 + 7) = v5;
        *((_DWORD *)v11 + 8) = 0;
        sub_100046C38((uint64_t **)(v7 - 8), v8, v10, v11);
        uint64_t v8 = (uint64_t)v11;
      }
      *(_DWORD *)(v8 + 32) = a3;
      BOOL v12 = v4 + 1;
      uint64_t v4 = v15;
      if (v12 != v15)
      {
        uint64_t v4 = v12;
        while ((v16(*v4) & 1) == 0)
        {
          if (++v4 == v15)
          {
            uint64_t v4 = v15;
            goto LABEL_5;
          }
        }
      }
    }
  }
  return sub_100A96F38((uint64_t)&v17);
}

void sub_100A8D910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100A96F38((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8D930(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = subscriber::asString();
    uint64_t v8 = asStringBool(*(unsigned char *)a3);
    *(_DWORD *)uint64_t v16 = 136315394;
    *(void *)&v16[4] = v7;
    *(_WORD *)&v16[12] = 2080;
    *(void *)&v16[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Updating EmergencySupport REST for %s, limited: %s", v16, 0x16u);
  }
  *(void *)uint64_t v16 = 1;
  *(void *)&v16[8] = a1 + 2880;
  uint64_t v9 = *(void *)(a1 + 2920);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v10 = v9;
        int v11 = *(_DWORD *)(v9 + 28);
        if (v11 <= a2) {
          break;
        }
        uint64_t v9 = *(void *)v10;
        BOOL v12 = (uint64_t **)v10;
        if (!*(void *)v10) {
          goto LABEL_11;
        }
      }
      if (v11 >= a2) {
        break;
      }
      uint64_t v9 = *(void *)(v10 + 8);
      if (!v9)
      {
        BOOL v12 = (uint64_t **)(v10 + 8);
        goto LABEL_11;
      }
    }
  }
  else
  {
    BOOL v12 = (uint64_t **)(a1 + 2920);
    uint64_t v10 = a1 + 2920;
LABEL_11:
    uint64_t v13 = operator new(0x30uLL);
    v13[7] = a2;
    *((void *)v13 + 4) = 0x200000000;
    v13[10] = 2;
    sub_100046C38((uint64_t **)(a1 + 2912), v10, v12, (uint64_t *)v13);
    uint64_t v10 = (uint64_t)v13;
  }
  uint64_t v14 = *a3;
  *(_DWORD *)(v10 + 40) = *((_DWORD *)a3 + 2);
  *(void *)(v10 + 32) = v14;
  return sub_100A96F9C((uint64_t)v16);
}

void sub_100A8DAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100A8DABC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DB40(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DBC4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100A8DC48(char *a1)
{
  if (a1)
  {
    sub_100A8DC48(*(void *)a1);
    sub_100A8DC48(*((void *)a1 + 1));
    if (a1[71] < 0) {
      operator delete(*((void **)a1 + 6));
    }
    operator delete(a1);
  }
}

void *sub_100A8DCA4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DD28(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DDAC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DE30(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DEB4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DF38(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8DFBC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E040(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E0C4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E148(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E1CC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 816) && *(char *)(a1 + 783) < 0) {
    operator delete(*(void **)(a1 + 760));
  }
  sub_10002B2D8(a1 + 632);
  sub_10002B28C(a1 + 488);
  sub_10002B1F4(a1 + 352);
  sub_10002B1A8(a1 + 248);
  sub_10002B1A8(a1 + 144);
  sub_10002B240(a1 + 48);

  return sub_100A8DABC((void *)a1);
}

void *sub_100A8E248(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E2CC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E350(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A8E3D4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100A8E458(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A8E4D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A8E514(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A8E54C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A8E57C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A8E5C4()
{
}

void *sub_100A8E5D8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A34F28;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8E620(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A34F28;
  a2[1] = v2;
  return result;
}

void sub_100A8E64C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  signed int v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      BOOL v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      int v14 = *((_DWORD *)v6 + 8);
      uint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v14, v15, v16);
      long long __p = &v29;
      BOOL v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      uint64_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          long long v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          long long v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/rat");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_100A8E924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8E9DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8EA1C()
{
}

void sub_100A8EA2C()
{
}

void *sub_100A8EA40(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A34FB8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8EA88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A34FB8;
  a2[1] = v2;
  return result;
}

void sub_100A8EAB4(uint64_t a1, const RegisteredNetworkInfo *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2);
  sub_100058DB0(&__p, "/cc/props/reg_net_info2");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A8EB58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8EB9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8EBDC()
{
}

void *sub_100A8EBE8(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A8EE50(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A8EE60()
{
}

void *sub_100A8EE74(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35048;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8EEBC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35048;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A8EEE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8EF28()
{
}

void sub_100A8EF38()
{
}

void *sub_100A8EF4C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A350C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8EF94(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A350C8;
  a2[1] = v2;
  return result;
}

void sub_100A8EFC0()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/reg_rat_selection1");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A8F064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8F0A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8F0E8()
{
}

void *sub_100A8F0F4(void *result, void *a2)
{
  if (a2 != result)
  {
    xpc_object_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A8F35C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A8F36C()
{
}

void *sub_100A8F380(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35158;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8F3C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35158;
  a2[1] = v2;
  return result;
}

void sub_100A8F3F4()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/reg_rat_selection2");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A8F498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A8F4DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8F51C()
{
}

void sub_100A8F52C()
{
}

void *sub_100A8F540(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A351D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8F588(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A351D8;
  a2[1] = v2;
  return result;
}

void sub_100A8F5B4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      BOOL v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      int v14 = *((_DWORD *)v6 + 8);
      uint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v14, v15, v16);
      long long __p = &v29;
      BOOL v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      uint64_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          long long v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          long long v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/registration_status");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_100A8F88C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A8F944(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8F984()
{
}

void sub_100A8F994()
{
}

void *sub_100A8F9A8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35268;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8F9F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35268;
  a2[1] = v2;
  return result;
}

void sub_100A8FA1C()
{
}

uint64_t sub_100A8FA24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A8FA64()
{
}

void sub_100A8FA70()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/props/emergency_callback_mode");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A8FB14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void *sub_100A8FB58(void *result, void *a2)
{
  if (a2 != result)
  {
    xpc_object_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A8FDC0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A8FDD0()
{
}

void *sub_100A8FDE4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A352F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A8FE2C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A352F8;
  a2[1] = v2;
  return result;
}

void sub_100A8FE58(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      BOOL v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      int v14 = *((_DWORD *)v6 + 8);
      uint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v14, v15, v16);
      long long __p = &v29;
      BOOL v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      uint64_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          long long v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          long long v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/cipher_domains");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_100A90130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A901E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A90228()
{
}

void sub_100A90238()
{
}

void *sub_100A9024C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35388;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90294(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35388;
  a2[1] = v2;
  return result;
}

void sub_100A902C0(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/reg_network_scan");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A90364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A903A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A903E8()
{
}

void sub_100A903F8()
{
}

void *sub_100A9040C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35408;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90454(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35408;
  a2[1] = v2;
  return result;
}

void sub_100A90480(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/reg_cs_attached");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A90524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A90568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A905A8()
{
}

void sub_100A905B8()
{
}

void *sub_100A905CC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35488;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90614(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35488;
  a2[1] = v2;
  return result;
}

void sub_100A90640(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/reg_ps_attached");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A906E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A90728(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A90768()
{
}

void sub_100A90778()
{
}

void *sub_100A9078C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35508;
  result[1] = v3;
  return result;
}

uint64_t sub_100A907D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35508;
  a2[1] = v2;
  return result;
}

void sub_100A90800(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/reg_data_attached");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A908A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A908E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A90928()
{
}

void sub_100A90938()
{
}

void *sub_100A9094C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35588;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90994(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35588;
  a2[1] = v2;
  return result;
}

void sub_100A909C0(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10072F6DC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/reg_data_modes");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A90A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A90AA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A90AE8()
{
}

void sub_100A90AF8()
{
}

void *sub_100A90B0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35618;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90B54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35618;
  a2[1] = v2;
  return result;
}

void sub_100A90B80(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      BOOL v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      long long __p = &v26;
      BOOL v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/reg_serving_network");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100A90E48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A90F00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A90F40()
{
}

void sub_100A90F50()
{
}

void *sub_100A90F64(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A356A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A90FAC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A356A8;
  a2[1] = v2;
  return result;
}

void sub_100A90FD8(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v26;
      BOOL v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      int v11 = *((_DWORD *)v6 + 14);
      uint64_t v12 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v22, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      BOOL v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/ims_voice_support");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100A912A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A91358(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91398()
{
}

void sub_100A913A8()
{
}

void *sub_100A913BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35738;
  result[1] = v3;
  return result;
}

uint64_t sub_100A91404(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35738;
  a2[1] = v2;
  return result;
}

void sub_100A91430(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10073195C(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/cs_voice_support");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A914D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A91518(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91558()
{
}

void sub_100A91568()
{
}

void *sub_100A9157C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A357C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A915C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A357C8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A915F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91630()
{
}

void *sub_100A9163C(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A918A4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A918B4()
{
}

void *sub_100A918C8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35858;
  result[1] = v3;
  return result;
}

uint64_t sub_100A91910(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35858;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A9193C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A9197C()
{
}

void sub_100A9198C()
{
}

void *sub_100A919A0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A358D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A919E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A358D8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A91A14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91A54()
{
}

void sub_100A91A64()
{
}

void *sub_100A91A78(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35968;
  result[1] = v3;
  return result;
}

uint64_t sub_100A91AC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35968;
  a2[1] = v2;
  return result;
}

uint64_t sub_100A91AEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91B2C()
{
}

void sub_100A91B3C()
{
}

void *sub_100A91B50(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A359F8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A91B98(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A359F8;
  a2[1] = v2;
  return result;
}

void sub_100A91BC4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100A91CF8(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/tracking_area_update_timers");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A91C68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A91CAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A91CEC()
{
}

void sub_100A91CF8(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v8 = (int *)*a1;
  uint64_t v6 = (int *)(a1 + 1);
  uint64_t v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_100A91E64(v7 + 7, &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      xpc_object_t v9 = (int *)*((void *)v7 + 1);
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          xpc_object_t v9 = *(int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (int *)*((void *)v7 + 2);
          BOOL v11 = *(void *)v10 == (void)v7;
          uint64_t v7 = v10;
        }
        while (!v11);
      }
      uint64_t v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100A91E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_100A91E64(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v15, (ctu::rest::detail *)v7, v8, v9);
  uint64_t v13 = &v17;
  xpc_object_t v14 = "first";
  sub_100035E70((uint64_t)&v13, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v11 = xpc_int64_create(a1[1]);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  uint64_t v13 = &v17;
  xpc_object_t v14 = "second";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v10 = v17;
  *a2 = v17;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_100A92000(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void *sub_100A92018(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A92280(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A92290()
{
}

void *sub_100A922A4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35A88;
  result[1] = v3;
  return result;
}

uint64_t sub_100A922EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35A88;
  a2[1] = v2;
  return result;
}

void sub_100A92318(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      BOOL v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      long long __p = &v26;
      BOOL v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          xpc_object_t v6 = v16;
        }
        while (!v17);
      }
      xpc_object_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/network_rejects");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100A925E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A92698(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A926D8()
{
}

void sub_100A926E8()
{
}

void *sub_100A926FC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35B18;
  result[1] = v3;
  return result;
}

uint64_t sub_100A92744(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35B18;
  a2[1] = v2;
  return result;
}

void sub_100A92770(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10072EBE0(a2, &v5);
  sub_100058DB0(&__p, "cc/props/ims_preference_states");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A92814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A92858(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A92898()
{
}

void sub_100A928A8()
{
}

void *sub_100A928BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A35BA8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A92904(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A35BA8;
  a2[1] = v2;
  return result;
}

void sub_100A92930(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      BOOL v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      long long __p = &v26;
      BOOL v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          xpc_object_t v6 = v16;
        }
        while (!v17);
      }
      xpc_object_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/ims_emergency_support");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100A92BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A92CB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A92CF0()
{
}

uint64_t *sub_100A92CFC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A92D3C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A92D54(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100A92DAC(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A92D94(_Unwind_Exception *a1)
{
  sub_10026CF54(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A92DAC(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    xpc_object_t v4 = a2;
    xpc_object_t v5 = (uint64_t **)result;
    xpc_object_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100A92E38(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      int v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          xpc_object_t v8 = v7;
          int v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          xpc_object_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          xpc_object_t v4 = v8;
        }
        while (!v9);
      }
      xpc_object_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100A92E38(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v9 = 0;
  xpc_object_t v10 = 0;
  xpc_object_t v6 = (uint64_t **)sub_1000262C0(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100A92EC8((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

void *sub_100A92EC8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  int v7 = operator new(0x48uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  v7[8] = *(_DWORD *)a2;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 7) = 0;
  *((void *)v7 + 5) = 0;
  uint64_t result = sub_1003FB56C((void *)v7 + 5, *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 2);
  v7[16] = *(_DWORD *)(a2 + 32);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A92F58(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_10026EA0C(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_100A92F74(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A92FD8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A9303C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A930A0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A93104(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A93168(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_100A931AC(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_100A93260(a1);
  uint64_t v10 = sub_100A934D0(v9);
  int v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_100A93260(a1);
    int v11 = *(uint64_t **)(sub_100A934D0(v12) + 8);
  }
  xpc_object_t v14 = v11;
  return sub_100A932A4(a1, a2, a3, &v14, a4);
}

uint64_t sub_100A93260(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100A932A4(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  xpc_object_t v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_100A93260(a1);
  uint64_t result = (uint64_t *)sub_100A934D0(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100A933E0(result + 2);
        sub_100A93424(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100A933E0(result + 2) + 24))
      {
        xpc_object_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_100A93260(a1);
        uint64_t v17 = sub_100A934D0(v16);
        uint64_t v18 = sub_100A933E0(v22 + 2);
        xpc_object_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      xpc_object_t v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_100A93260(a1);
      BOOL v20 = (uint64_t *)sub_100A934D0(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100A933E0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100A93424(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    xpc_object_t v6 = (uint64_t *)sub_100A9348C(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100A9348C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100A934D0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100A93514(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100A93598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100A935AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100A938E8(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100A933E0((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        xpc_object_t v8 = *(_DWORD **)sub_100A9348C((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_100A9348C(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_100A9348C(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100A933E0((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100A933E0((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100A938E8(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100A93890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A938E8(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100A93928(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_100A93260(v2);
    if (sub_100A934D0(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_100A93260(v2);
      uint64_t v9 = *(uint64_t **)(sub_100A934D0(v7) + 8);
      sub_100A932A4(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100A93A94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100A93AF0(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100A93BB0(&v2, a2);
}

uint64_t sub_100A93B6C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100A93BB0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A93C1C(&v2);
}

void sub_100A93C08(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A93C1C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A93C8C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100A93CA0(_Unwind_Exception *a1)
{
}

void sub_100A93CB8()
{
}

uint64_t sub_100A93CCC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100A93D30()
{
  return 0;
}

uint64_t sub_100A93D38()
{
  return 0;
}

uint64_t sub_100A93D40()
{
  return 0;
}

void sub_100A93D48()
{
}

void sub_100A93DC4()
{
}

uint64_t sub_100A93DE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100A93F74((uint64_t *)a1, a2);
  sub_100A93FE0((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      long long v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          long long v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          uint64_t v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100A93F4C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A93F74(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100A93FCC(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A93FE0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100A94030(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100A94048(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A940B4(&v2);
}

void sub_100A940A0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A940B4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A94124(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100A94138(_Unwind_Exception *a1)
{
}

void sub_100A94150()
{
}

uint64_t sub_100A94164(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100A941CC()
{
  return 0;
}

uint64_t sub_100A941D4()
{
  return 0;
}

uint64_t sub_100A941DC()
{
  return 0;
}

uint64_t sub_100A941E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100A942B8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A942D8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A9433C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A943A0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      uint64_t v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && rest::operator==())
      {
        long long v5 = (void *)v3[1];
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            long long v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_10003FB28((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    long long v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10003FB28(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_100A9451C(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t *)(a1 + 8);
  long long v5 = *(uint64_t **)(a1 + 8);
  BOOL v7 = (uint64_t **)(a1 + 8);
  uint64_t v8 = (uint64_t **)(a1 + 8);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        long long v5 = *v8;
        BOOL v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      long long v5 = v8[1];
      if (!v5)
      {
        BOOL v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v14 = 0;
    uint64_t v10 = (char *)operator new(0x70uLL);
    v13[0] = (uint64_t *)v10;
    v13[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *((void *)v10 + 13) = 0;
    *(_OWORD *)(v10 + 40) = 0u;
    MCCAndMNC::MCCAndMNC((MCCAndMNC *)(v10 + 40));
    *((_DWORD *)v10 + 26) = 11;
    *((_WORD *)v10 + 54) = 0;
    LOBYTE(v14) = 1;
    long long v11 = v13[0];
    sub_100046C38((uint64_t **)a1, (uint64_t)v8, v7, v13[0]);
    v13[0] = 0;
    sub_10003FD44((uint64_t)v13, 0);
    return v11;
  }
  return (uint64_t *)v8;
}

void sub_100A9461C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003FD44((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100A94634(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A94698(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A946FC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (unsigned __int8 *)v2[4];
      if (v3 == (unsigned __int8 *)(v2 + 5)) {
        goto LABEL_24;
      }
      uint64_t v4 = *(unsigned __int8 **)(a1 + 16);
      while (sub_10001D294(v3 + 32, v4 + 32) && *((_DWORD *)v3 + 14) == *((_DWORD *)v4 + 14))
      {
        long long v5 = (unsigned __int8 *)*((void *)v3 + 1);
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            long long v5 = *(unsigned __int8 **)v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (unsigned __int8 *)*((void *)v6 + 2);
            BOOL v7 = *(void *)v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 1);
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = *(unsigned __int8 **)v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (unsigned __int8 *)*((void *)v4 + 2);
            BOOL v7 = *(void *)v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == (unsigned __int8 *)(v2 + 5)) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_10005CD2C((uint64_t)(v2 + 4), (char *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    long long v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

char *sub_100A94874(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v12 = 0;
  long long v5 = (void **)sub_100046ED4((uint64_t)a1, &v12, a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    BOOL v7 = (uint64_t **)v5;
    uint64_t v8 = *a3;
    uint64_t v6 = (char *)operator new(0x40uLL);
    int v9 = v6 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v9, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *((void *)v6 + 6) = *((void *)v8 + 2);
      *(_OWORD *)int v9 = v10;
    }
    *((_DWORD *)v6 + 14) = 0;
    sub_100046C38(a1, v12, v7, (uint64_t *)v6);
  }
  return v6;
}

void sub_100A94938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  sub_1000C6EE8(v10, v9);
  _Unwind_Resume(a1);
}

uint64_t sub_100A94954(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_100A949B8(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  BOOL v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        BOOL v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        BOOL v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    long long v11 = operator new(0x28uLL);
    v11[7] = **a4;
    *((_WORD *)v11 + 16) = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_100A94A7C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      long long v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v4 + 8) == *((_DWORD *)v5 + 8);
        if (!v6) {
          break;
        }
        BOOL v7 = (void *)v4[1];
        int v8 = v4;
        if (v7)
        {
          do
          {
            uint64_t v4 = v7;
            BOOL v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            int v8 = v4;
          }
          while (!v6);
        }
        int v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            int v10 = v9;
            int v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            int v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            long long v5 = v10;
          }
          while (!v6);
        }
        long long v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_100A94BA8(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_100A94BE8(uint64_t *a1, uint64_t **a2, int a3)
{
  uint64_t v3 = a1[1];
  if (!v3 || atomic_load_explicit((atomic_uint *volatile)(v3 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v5 = a1;
  BOOL v6 = *a2;
  BOOL v7 = (uint64_t *)sub_100A94BA8(*a1);
  uint64_t result = sub_100A94FB4(*v7);
  if ((uint64_t *)result != v6)
  {
    unsigned int v9 = 0;
    unsigned int v10 = a3 - 1;
    uint64_t v11 = v6;
    long long v38 = v5;
    do
    {
      if (*(unsigned char *)(sub_100A94F34(v11[2]) + 24))
      {
        BOOL v6 = (uint64_t *)v11[1];
      }
      else
      {
        uint64_t v12 = *(uint64_t **)sub_100A94BA8(*v5);
        sub_100A94FB4((uint64_t)v12);
        uint64_t v13 = sub_100A94F34(v11[2]);
        if (v11 == v12) {
          __assert_rtn("erase", "slot_groups.hpp", 148, "it != _list.end()");
        }
        uint64_t v14 = v12 + 4;
        uint64_t v15 = (void *)v12[4];
        if (!v15) {
          goto LABEL_45;
        }
        uint64_t v16 = v13 + 64;
        long long v39 = (uint64_t **)(v12 + 3);
        uint64_t v17 = v12 + 4;
        do
        {
          BOOL v18 = sub_100162ED8((uint64_t)(v12 + 6), (uint64_t)(v15 + 4), v16);
          long long v19 = v15 + 1;
          if (!v18)
          {
            long long v19 = v15;
            uint64_t v17 = v15;
          }
          uint64_t v15 = (void *)*v19;
        }
        while (*v19);
        if (v17 == v14) {
LABEL_45:
        }
          __assert_rtn("erase", "slot_groups.hpp", 150, "map_it != _group_map.end()");
        if (sub_100162ED8((uint64_t)(v12 + 7), (uint64_t)(v17 + 4), v16)
          || sub_100162ED8((uint64_t)(v12 + 7), v16, (uint64_t)(v17 + 4)))
        {
          __assert_rtn("erase", "slot_groups.hpp", 151, "weakly_equivalent(map_it->first, key)");
        }
        if ((uint64_t *)v17[6] == v11)
        {
          uint64_t v37 = v11[1];
          long long v20 = (void *)*v14;
          long long v21 = v12;
          if (*v14)
          {
            long long v22 = v12 + 4;
            do
            {
              BOOL v23 = sub_100162ED8((uint64_t)(v12 + 6), v16, (uint64_t)(v20 + 4));
              long long v24 = v20 + 1;
              if (v23)
              {
                long long v24 = v20;
                long long v22 = v20;
              }
              long long v20 = (void *)*v24;
            }
            while (*v24);
            long long v21 = v12;
            if (v22 != v14) {
              long long v21 = (uint64_t *)v22[6];
            }
          }
          if ((uint64_t *)v37 == v21)
          {
            long long v29 = (uint64_t *)v17[1];
            long long v30 = v17;
            if (v29)
            {
              do
              {
                long long v31 = v29;
                long long v29 = (uint64_t *)*v29;
              }
              while (v29);
            }
            else
            {
              do
              {
                long long v31 = (uint64_t *)v30[2];
                BOOL v32 = *v31 == (void)v30;
                long long v30 = v31;
              }
              while (!v32);
            }
            if (*v39 == v17) {
              int *v39 = v31;
            }
            int v33 = (uint64_t *)v12[4];
            --v12[5];
            sub_10005EE6C(v33, v17);
            operator delete(v17);
          }
          else
          {
            uint64_t v40 = 0;
            long long v25 = (void **)sub_100162E38((uint64_t)v39, &v40, v16);
            long long v26 = *v25;
            if (!*v25)
            {
              long long v27 = (uint64_t **)v25;
              long long v26 = operator new(0x38uLL);
              int v28 = *(_DWORD *)(v16 + 8);
              v26[4] = *(void *)v16;
              *((_DWORD *)v26 + 10) = v28;
              v26[6] = 0;
              sub_100046C38(v39, v40, v27, v26);
            }
            v26[6] = v37;
          }
        }
        uint64_t v34 = *v11;
        BOOL v6 = (uint64_t *)v11[1];
        *(void *)(v34 + 8) = v6;
        *(void *)v11[1] = v34;
        --v12[2];
        sub_10000A740((atomic_uint **)v11 + 3);
        operator delete(v11);
        long long v5 = v38;
      }
      ++v9;
      char v35 = (uint64_t *)sub_100A94BA8(*v5);
      uint64_t result = sub_100A94FB4(*v35);
      BOOL v36 = v6 != (uint64_t *)result && v10 >= v9;
      uint64_t v11 = v6;
    }
    while (v36);
  }
  v5[2] = (uint64_t)v6;
  return result;
}

uint64_t sub_100A94F34(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_100A94F74(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100A94FB4(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100A94FF4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100A95318(v3);
      sub_10000A4EC(&v18, v3);
      uint64_t v4 = *(void *)(*a1 + 16);
      sub_100A94F34(v4);
      long long v5 = *(_DWORD ***)(v4 + 32);
      if (v5)
      {
        uint64_t v6 = a1[2];
        BOOL v7 = *v5;
        if (v7 != *(_DWORD **)(sub_100A94F74((uint64_t)v5) + 8))
        {
          int v8 = (void *)(v6 + 8);
          while (1)
          {
            memset(v30, 0, sizeof(v30));
            sub_100060B10(v7, (uint64_t)v30);
            if (sub_100060A68((uint64_t)v7)) {
              break;
            }
            sub_100062188(v8, (uint64_t)v30);
            sub_1000624B4((uint64_t)v30);
            v7 += 6;
            if (v7 == *(_DWORD **)(sub_100A94F74(*(void *)(v4 + 32)) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v4 + 24))
          {
            *(unsigned char *)(v4 + 24) = 0;
            sub_100060D70((atomic_uint **)v4, &v18);
          }
          sub_1000624B4((uint64_t)v30);
        }
      }
LABEL_12:
      uint64_t v9 = sub_100A94F34(*(void *)(*a1 + 16));
      uint64_t v10 = a1[2];
      if (*(unsigned char *)(v9 + 24)) {
        ++*(_DWORD *)(v10 + 304);
      }
      else {
        ++*(_DWORD *)(v10 + 308);
      }
      uint64_t v11 = sub_100A94F34(*(void *)(*a1 + 16));
      if (!*(unsigned char *)(v11 + 24)
        || (uint64_t v12 = *(void *)(v11 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v12 + 8), memory_order_acquire))
      {
        int v13 = 1;
      }
      else
      {
        sub_100A95358(a1, &v18, *a1);
        int v13 = 0;
      }
      (*(void (**)(void))(**((void **)&v29 + 1) + 32))(*((void *)&v29 + 1));
      sub_10000A5F8(&v18);
      uint64_t v1 = *a1;
      uint64_t v14 = a1[1];
      if (!v13) {
        break;
      }
      uint64_t v15 = *(void *)(v1 + 8);
      *a1 = v15;
      if (v15 == v14)
      {
        uint64_t v1 = v14;
        goto LABEL_24;
      }
    }
    if (v1 == v14)
    {
LABEL_24:
      uint64_t v16 = a1[3];
      if (v16 != v1)
      {
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        uint64_t v17 = *(void *)(v16 + 16);
        sub_100A95318(v17);
        sub_10000A4EC(&v18, v17);
        sub_100A95358(a1, &v18, a1[1]);
        (*(void (**)(void))(**((void **)&v29 + 1) + 32))(*((void *)&v29 + 1));
        sub_10000A5F8(&v18);
      }
    }
  }
}

void sub_100A952C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A95318(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100A95358(void *a1, void *a2, uint64_t a3)
{
  a1[3] = a3;
  uint64_t v3 = a1[2];
  if (a1[1] == a3)
  {
    uint64_t result = *(atomic_uint ***)(v3 + 312);
    if (result) {
      uint64_t result = sub_100060D70(result, a2);
    }
    *(void *)(v3 + 312) = 0;
  }
  else
  {
    uint64_t v4 = *(void *)(a3 + 16);
    uint64_t result = *(atomic_uint ***)(v3 + 312);
    if (result) {
      uint64_t result = sub_100060D70(result, a2);
    }
    *(void *)(v3 + 312) = v4;
    if (v4)
    {
      int v6 = *(_DWORD *)(v4 + 28);
      if (!v6) {
        __assert_rtn("inc_slot_refcount", "connection.hpp", 114, "m_slot_refcount != 0");
      }
      *(_DWORD *)(v4 + 28) = v6 + 1;
    }
  }
  return result;
}

void *sub_100A953E0(void *a1)
{
  if (*(_DWORD *)(*a1 + 308) > *(_DWORD *)(*a1 + 304))
  {
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v2 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v3 + 3);
    sub_100061F70(v10, v4);
    long long v5 = (uint64_t *)sub_100A94BA8(*v3);
    if (sub_100A94FB4(*v5) == v2)
    {
      uint64_t v6 = v3[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      BOOL v7 = (uint64_t *)sub_100A94BA8(*v3);
      uint64_t v9 = *(uint64_t **)(sub_100A94FB4(*v7) + 8);
      sub_100A94BE8(v3, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100A95978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    sub_10016267C(a12);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_100A95998(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v10);
    sub_100161F10((uint64_t)va);
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A959B4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100695D20(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100A959D4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v2);
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100A959F0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  operator delete(a12, 0x20C40DC1BFBCFLL);
  JUMPOUT(0x100A95A84);
}

void sub_100A959FC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100161F10((uint64_t)va);
  sub_10006A6AC(a1);
}

void sub_100A95A28(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100A95A8CLL);
}

void sub_100A95A98()
{
}

uint64_t sub_100A95AAC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100A95B10()
{
  return 0;
}

uint64_t sub_100A95B18()
{
  return 0;
}

uint64_t sub_100A95B20()
{
  return 0;
}

void sub_100A95B2C()
{
}

uint64_t sub_100A95B40(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10005D144(*(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100A95BA4()
{
  return 0;
}

uint64_t sub_100A95BAC()
{
  return 0;
}

uint64_t sub_100A95BB4()
{
  return 0;
}

uint64_t sub_100A95BBC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 312);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 312), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100A95C90(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A95CB0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_100A95D14(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  long long v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        long long v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      long long v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x28uLL);
    v9[7] = *a3;
    *((void *)v9 + 4) = 0xB00000000;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_100A95DC8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_100A95E0C(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_100A95EC0(a1);
  uint64_t v10 = sub_100A96130(v9);
  long long v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_100A95EC0(a1);
    long long v11 = *(uint64_t **)(sub_100A96130(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_100A95F04(a1, a2, a3, &v14, a4);
}

uint64_t sub_100A95EC0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100A95F04(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_100A95EC0(a1);
  uint64_t result = (uint64_t *)sub_100A96130(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100A96040(result + 2);
        sub_100A96084(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100A96040(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_100A95EC0(a1);
        uint64_t v17 = sub_100A96130(v16);
        uint64_t v18 = sub_100A96040(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_100A95EC0(a1);
      long long v20 = (uint64_t *)sub_100A96130(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100A96040(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100A96084(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_100A960EC(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100A960EC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100A96130(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100A96174(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100A961F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100A9620C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_100A96548(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_100A96040((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        int v8 = *(_DWORD **)sub_100A960EC((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_100A960EC(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_100A960EC(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_100A96040((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 288);
      }
      else {
        ++*(_DWORD *)(v11 + 292);
      }
      uint64_t v12 = sub_100A96040((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_1001C36EC(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_100A96548(v18);
        sub_10000A4EC(&v19, v18);
        sub_1001C36EC(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_100A964F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A96548(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_100A96588(void *a1)
{
  if (*(_DWORD *)(*a1 + 292) > *(_DWORD *)(*a1 + 288))
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_100A95EC0(v2);
    if (sub_100A96130(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_100A95EC0(v2);
      uint64_t v9 = *(uint64_t **)(sub_100A96130(v7) + 8);
      sub_100A95F04(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_100A966F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100A96750(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100A96810(&v2, a2);
}

uint64_t sub_100A967CC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100A96810(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A9687C(&v2);
}

void sub_100A96868(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A9687C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A968EC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100A96900(_Unwind_Exception *a1)
{
}

void sub_100A96918()
{
}

uint64_t sub_100A9692C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100A96990()
{
  return 0;
}

uint64_t sub_100A96998()
{
  return 0;
}

uint64_t sub_100A969A0()
{
  return 0;
}

void sub_100A969A8()
{
}

void sub_100A96A24()
{
}

uint64_t sub_100A96A48(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100A96BD4((uint64_t *)a1, a2);
  sub_100A96C40((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      long long v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          long long v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          uint64_t v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100A96BAC(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A96BD4(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100A96C2C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A96C40(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100A96C90(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100A96CA8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A96D14(&v2);
}

void sub_100A96D00(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A96D14(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A96D84(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100A96D98(_Unwind_Exception *a1)
{
}

void sub_100A96DB0()
{
}

uint64_t sub_100A96DC4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100A96E2C()
{
  return 0;
}

uint64_t sub_100A96E34()
{
  return 0;
}

uint64_t sub_100A96E3C()
{
  return 0;
}

uint64_t sub_100A96E44(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100A96F18(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A96F38(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A96F9C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_100A97000()
{
}

void sub_100A97088(uint64_t a1, char *a2, xpc_object_t *a3)
{
  sub_100058DB0(&v7, a2);
  uint64_t v4 = std::string::insert(&v7, 0, "com.apple.Telephony.", 0x14uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  std::string::size_type v9 = v4->__r_.__value_.__r.__words[2];
  long long v8 = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  xpc_object_t object = *a3;
  if (*a3) {
    xpc_retain(*a3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  analytics_send_exploding_event_lazy();
  xpc_release(object);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
}

void sub_100A97198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  xpc_release(object);
  if (*(char *)(v19 - 25) < 0) {
    operator delete(*(void **)(v19 - 48));
  }
  _Unwind_Resume(a1);
}

xpc_object_t sub_100A971DC(uint64_t a1)
{
  xpc_object_t v1 = *(xpc_object_t *)(a1 + 32);
  if (v1) {
    xpc_retain(*(xpc_object_t *)(a1 + 32));
  }
  else {
    xpc_object_t v1 = xpc_null_create();
  }
  xpc_object_t v2 = xpc_null_create();
  xpc_release(v2);
  return v1;
}

void sub_100A97224(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

xpc_object_t sub_100A97240(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 32);
  *(void *)(a1 + 32) = v3;
  if (v3) {
    return xpc_retain(v3);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 32) = result;
  return result;
}

void sub_100A97280(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
}

void sub_100A972B0(uint64_t a1, char *a2, uint64_t a3, xpc_object_t *a4)
{
  sub_100058DB0(&v8, a2);
  long long v5 = std::string::insert(&v8, 0, "com.apple.Telephony.", 0x14uLL);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  std::string::size_type v10 = v5->__r_.__value_.__r.__words[2];
  long long v9 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
  xpc_object_t object = *a4;
  if (*a4) {
    xpc_retain(*a4);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  analytics_send_exploding_event_lazy();
  xpc_release(object);
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
}

void sub_100A973CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  xpc_release(object);
  if (*(char *)(v21 - 41) < 0) {
    operator delete(*(void **)(v21 - 64));
  }
  _Unwind_Resume(a1);
}

xpc_object_t sub_100A97410(uint64_t a1)
{
  xpc_object_t v1 = *(char **)(a1 + 32);
  xpc_object_t values = *(xpc_object_t *)(a1 + 40);
  keys = v1;
  xpc_object_t v2 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v2 || (xpc_object_t v2 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v2);
      xpc_object_t v3 = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v2 = 0;
  }
  xpc_release(v2);
  xpc_object_t v4 = xpc_null_create();
  xpc_release(v4);
  return v3;
}

void sub_100A974E0(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

xpc_object_t sub_100A97520(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = *(void **)(a2 + 40);
  *(void *)(a1 + 40) = v3;
  if (v3) {
    return xpc_retain(v3);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100A97560(uint64_t a1)
{
  *(void *)(a1 + 40) = 0;
}

void sub_100A97590(uint64_t a1, char *a2, int a3)
{
  if (a3 == 1)
  {
    uint64_t v6 = 0;
    std::string v7 = 0;
    Registry::getWisServerConnection(&v6, *(Registry **)(a1 + 8));
    if (v6)
    {
      sub_100058DB0(&__p, a2);
      wis::WISServerConnection::RegisterCallbackForTimer();
      if (v5 < 0) {
        operator delete(__p);
      }
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
}

void sub_100A97670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(v19 - 40);
  if (v21) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A976A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }
  (*(void (**)(uint64_t, void **))(v2 + 16))(v2, __p);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A97718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100A97734()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (1000 * v1.tv_sec + v1.tv_usec / 0x3E8uLL) / 0x3E8;
}

void sub_100A97798(TelephonyAnalyticsInterface *this)
{
  *(void *)this = off_101A35E88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  TelephonyAnalyticsInterface::~TelephonyAnalyticsInterface(this);
}

void sub_100A977F4(TelephonyAnalyticsInterface *this)
{
  *(void *)this = off_101A35E88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  TelephonyAnalyticsInterface::~TelephonyAnalyticsInterface(this);

  operator delete();
}

void sub_100A97864(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A978CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A97908(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A97940(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A97970(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A979BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

BOOL sub_100A97A10(int a1, uint64_t *a2, uint64_t a3)
{
  if (a1) {
    std::string v7 = &__kCFBooleanFalse;
  }
  else {
    std::string v7 = &__kCFBooleanTrue;
  }
  CFStringRef v13 = @"supportsSGP";
  CFStringRef v14 = @"iosVersion";
  v15[0] = v7;
  if (*((char *)a2 + 23) >= 0) {
    std::string v8 = a2;
  }
  else {
    std::string v8 = (uint64_t *)*a2;
  }
  long long v9 = +[NSString stringWithFormat:@"%s", v8, v13, v14, v15[0]];
  v15[1] = v9;
  std::string::size_type v10 = +[NSDictionary dictionaryWithObjects:v15 forKeys:&v13 count:2];

  BOOL v11 = sub_100A97B4C((uint64_t)v10, a3);
  return v11;
}

void sub_100A97B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A97B4C(uint64_t a1, uint64_t a2)
{
  id v13 = 0;
  xpc_object_t v3 = +[NSJSONSerialization dataWithJSONObject:a1 options:0 error:&v13];
  id v4 = v13;
  if (v4)
  {
    sub_100A98214();
    char v5 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      id v6 = [v4 description];
      id v7 = [v6 UTF8String];
      *(_DWORD *)long long buf = 136315138;
      id v15 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Serialization Error: %s", buf, 0xCu);
    }
  }
  else
  {
    id v8 = v3;
    long long v9 = (char *)[v8 bytes];
    std::string::size_type v10 = *(char **)(a2 + 8);
    BOOL v11 = (char *)[v8 length];
    sub_10016A4CC(a2, v10, v9, &v11[(void)v9], (int64_t)v11);
  }

  return v4 == 0;
}

void sub_100A97CA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A97CD4(void *a1, uint64_t a2, uint64_t **a3)
{
  if (*a1) {
    id v6 = sub_10008324C;
  }
  else {
    id v6 = 0;
  }
  if (v6)
  {
    uint64_t v36 = 0;
    long long v27 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v25 = 0;
    if (v25) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = v27 == 0;
    }
    if (v7 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      uint64_t v17 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Decoding failure", buf, 2u);
      }
      int v16 = 1;
    }
    else
    {
      id v24 = [v27 objectForKey:@"sessionId"];
      if (v24 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        long long v23 = [v27 objectForKey:@"serviceDiscovery"];
        if (v23 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          sub_100058DB0(buf, (char *)[v24 UTF8String]);
          if (*(char *)(a2 + 23) < 0) {
            operator delete(*(void **)a2);
          }
          *(_OWORD *)a2 = *(_OWORD *)buf;
          *(void *)(a2 + 16) = v35;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          long long v33 = 0u;
          id v8 = v23;
          id v9 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
          if (v9)
          {
            uint64_t v10 = *(void *)v31;
            do
            {
              for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v31 != v10) {
                  objc_enumerationMutation(v8);
                }
                uint64_t v12 = *(void **)(*((void *)&v30 + 1) + 8 * i);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  id v13 = [v8 objectForKey:v12];
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    sub_100058DB0(buf, (char *)[v13 UTF8String]);
                    sub_100058DB0(__p, (char *)[v12 UTF8String]);
                    uint64_t v37 = __p;
                    CFStringRef v14 = sub_100327F4C(a3, __p, (uint64_t)&unk_10144E20E, (_OWORD **)&v37);
                    id v15 = (char *)v14 + 56;
                    if (*((char *)v14 + 79) < 0) {
                      operator delete(*(void **)v15);
                    }
                    *(_OWORD *)id v15 = *(_OWORD *)buf;
                    *((void *)v15 + 2) = v35;
                    HIBYTE(v35) = 0;
                    buf[0] = 0;
                    if (v29 < 0)
                    {
                      operator delete(__p[0]);
                      if (SHIBYTE(v35) < 0) {
                        operator delete(*(void **)buf);
                      }
                    }
                  }
                }
              }
              id v9 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
            }
            while (v9);
          }

          int v16 = 0;
        }
        else
        {
          sub_100A98214();
          uint64_t v21 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Missing key: serviceDiscovery", buf, 2u);
          }
          int v16 = 1;
        }

        long long v20 = v24;
      }
      else
      {
        sub_100A98214();
        uint64_t v19 = qword_101B0FD28;
        long long v20 = v24;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing key: sessionId", buf, 2u);
        }
        int v16 = 1;
      }
    }
  }
  else
  {
    sub_100A98214();
    uint64_t v18 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    int v16 = 1;
  }
  return v16 == 0;
}

void sub_100A98160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  _Unwind_Resume(a1);
}

void sub_100A98214()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0FD30))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0FD28, kCtLoggingSystemName, "sub.helper");
    __cxa_guard_release(&qword_101B0FD30);
  }
}

void sub_100A98294(_Unwind_Exception *a1)
{
}

BOOL sub_100A982AC(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *((unsigned __int8 *)a1 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = a1[1];
  }
  if (!v8 || *a2 == a2[1])
  {
    BOOL v15 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v18 = 0;
    ctu::base64::encode();
    v19[0] = @"sessionId";
    if (*((char *)a1 + 23) >= 0) {
      id v9 = a1;
    }
    else {
      id v9 = (uint64_t *)*a1;
    }
    uint64_t v10 = +[NSString stringWithFormat:@"%s", v9];
    v20[0] = v10;
    v19[1] = @"lpaSignedRequest";
    BOOL v11 = __p;
    if (v18 < 0) {
      BOOL v11 = (void **)__p[0];
    }
    uint64_t v12 = +[NSString stringWithFormat:@"%s", v11];
    v20[1] = v12;
    v19[2] = @"action";
    id v13 = +[NSString stringWithFormat:@"%s", encodeProfileAction()];
    v20[2] = v13;
    CFStringRef v14 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:3];

    BOOL v15 = sub_100A97B4C((uint64_t)v14, a4);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  return v15;
}

void sub_100A98478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A984CC(void *a1, uint64_t a2, uint64_t *a3)
{
  if (*a1) {
    BOOL v7 = sub_10008324C;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    uint64_t v96 = 0;
    uint64_t v8 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v9 = 0;
    if (v9) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = v8 == 0;
    }
    long long v73 = v9;
    if (v10 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      uint64_t v34 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
      }
      LODWORD(v35) = 1;
    }
    else
    {
      id v68 = [v8 objectForKey:@"sessionId"];
      if (v68 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        sub_100058DB0(buf, (char *)[v68 UTF8String]);
        if (*(char *)(a2 + 23) < 0) {
          operator delete(*(void **)a2);
        }
        *(_OWORD *)a2 = *(_OWORD *)buf;
        *(void **)(a2 + 16) = v82[0];
        long long v61 = [v8 objectForKey:@"profileOptions"];
        if (v61)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            long long v94 = 0u;
            long long v95 = 0u;
            long long v92 = 0u;
            long long v93 = 0u;
            obuint64_t j = v61;
            id v11 = [obj countByEnumeratingWithState:&v92 objects:v98 count:16];
            if (v11)
            {
              uint64_t v12 = 0;
              uint64_t v70 = *(void *)v93;
              for (uint64_t i = *(void *)v93; ; uint64_t i = *(void *)v93)
              {
                if (i != v70) {
                  objc_enumerationMutation(obj);
                }
                CFStringRef v14 = *(void **)(*((void *)&v92 + 1) + 8 * v12);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  BOOL v15 = [v14 objectForKey:@"smDpUrl"];
                  if (v15)
                  {
                    objc_opt_class();
                    if (objc_opt_isKindOfClass())
                    {
                      unint64_t v16 = a3[1];
                      unint64_t v17 = a3[2];
                      if (v16 >= v17)
                      {
                        uint64_t v21 = 0x6F96F96F96F96F97 * ((uint64_t)(v16 - *a3) >> 3);
                        unint64_t v22 = v21 + 1;
                        if ((unint64_t)(v21 + 1) > 0xD20D20D20D20D2) {
                          sub_10006A748();
                        }
                        unint64_t v23 = 0x6F96F96F96F96F97 * ((uint64_t)(v17 - *a3) >> 3);
                        if (2 * v23 > v22) {
                          unint64_t v22 = 2 * v23;
                        }
                        if (v23 >= 0x69069069069069) {
                          unint64_t v24 = 0xD20D20D20D20D2;
                        }
                        else {
                          unint64_t v24 = v22;
                        }
                        *(void *)&long long v83 = a3 + 2;
                        if (v24) {
                          id v25 = (char *)sub_10030C27C((uint64_t)(a3 + 2), v24);
                        }
                        else {
                          id v25 = 0;
                        }
                        long long v26 = &v25[312 * v21];
                        *(void *)long long buf = v25;
                        *(void *)&uint8_t buf[8] = v26;
                        v82[1] = &v25[312 * v24];
                        *((_OWORD *)v26 + 2) = 0u;
                        *((_OWORD *)v26 + 3) = 0u;
                        *((_OWORD *)v26 + 4) = 0u;
                        *((_OWORD *)v26 + 5) = 0u;
                        *((_OWORD *)v26 + 6) = 0u;
                        *((_OWORD *)v26 + 7) = 0u;
                        *((_OWORD *)v26 + 8) = 0u;
                        *((_OWORD *)v26 + 9) = 0u;
                        *((_OWORD *)v26 + 10) = 0u;
                        *((_OWORD *)v26 + 11) = 0u;
                        *((_OWORD *)v26 + 12) = 0u;
                        *((_OWORD *)v26 + 13) = 0u;
                        *((_OWORD *)v26 + 14) = 0u;
                        *((_OWORD *)v26 + 15) = 0u;
                        *((_OWORD *)v26 + 16) = 0u;
                        *((_OWORD *)v26 + 17) = 0u;
                        *((_OWORD *)v26 + 18) = 0u;
                        *((void *)v26 + 38) = 0;
                        *(_OWORD *)long long v26 = 0u;
                        *((_OWORD *)v26 + 1) = 0u;
                        v82[0] = v26 + 312;
                        sub_10030F708(a3, buf);
                        uint64_t v18 = a3[1];
                        sub_10030F890((uint64_t)buf);
                      }
                      else
                      {
                        *(void *)(v16 + 304) = 0;
                        *(_OWORD *)(v16 + 272) = 0u;
                        *(_OWORD *)(v16 + 288) = 0u;
                        *(_OWORD *)(v16 + 240) = 0u;
                        *(_OWORD *)(v16 + 256) = 0u;
                        *(_OWORD *)(v16 + 208) = 0u;
                        *(_OWORD *)(v16 + 224) = 0u;
                        *(_OWORD *)(v16 + 176) = 0u;
                        *(_OWORD *)(v16 + 192) = 0u;
                        *(_OWORD *)(v16 + 144) = 0u;
                        *(_OWORD *)(v16 + 160) = 0u;
                        *(_OWORD *)(v16 + 112) = 0u;
                        *(_OWORD *)(v16 + 128) = 0u;
                        *(_OWORD *)(v16 + 80) = 0u;
                        *(_OWORD *)(v16 + 96) = 0u;
                        *(_OWORD *)(v16 + 48) = 0u;
                        *(_OWORD *)(v16 + 64) = 0u;
                        *(_OWORD *)(v16 + 16) = 0u;
                        *(_OWORD *)(v16 + 32) = 0u;
                        *(_OWORD *)unint64_t v16 = 0u;
                        uint64_t v18 = v16 + 312;
                        a3[1] = v16 + 312;
                      }
                      a3[1] = v18;
                      id v67 = [v14 objectForKey:@"eventId"];
                      id v72 = v15;
                      sub_10003ED78((std::string *)(v18 - 312), (char *)[v72 UTF8String]);
                      if (v67)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          sub_10003ED78((std::string *)(v18 - 288), (char *)[v67 UTF8String]);
                        }
                      }
                      id v66 = [v14 objectForKey:@"carrier"];
                      if (v66)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          sub_10003ED78((std::string *)(v18 - 264), (char *)[v66 UTF8String]);
                        }
                      }
                      long long v65 = [v14 objectForKey:@"type"];
                      if (v65)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          *(unsigned char *)(v18 - 192) = [v65 isEqualToString:@"provisioning"];
                        }
                      }
                      id v64 = [v14 objectForKey:@"iccidHash"];
                      if (v64)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          sub_10003ED78((std::string *)(v18 - 240), (char *)[v64 UTF8String]);
                        }
                      }
                      id v63 = [v14 objectForKey:@"eventType"];
                      if (v63)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          sub_10003ED78((std::string *)(v18 - 216), (char *)[v63 UTF8String]);
                        }
                      }
                      long long v62 = [v14 objectForKey:@"isOda"];
                      if (v62)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          *(unsigned char *)(v18 - 191) = [v62 BOOLValue];
                        }
                      }
                      if (*(unsigned char *)(v18 - 191))
                      {
                        long long v69 = [v14 objectForKey:@"esimInstallDetails"];
                        objc_opt_class();
                        if ((objc_opt_isKindOfClass() & (v69 != 0)) == 0)
                        {
                          sub_100A98214();
                          uint64_t v55 = qword_101B0FD28;
                          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (esimInstallDetailObj element)", buf, 2u);
                          }

                          LODWORD(v35) = 1;
                          goto LABEL_151;
                        }
                        *(_OWORD *)v90 = 0u;
                        long long v91 = 0u;
                        long long v88 = 0u;
                        *(_OWORD *)v89 = 0u;
                        *(_OWORD *)v86 = 0u;
                        *(_OWORD *)uint64_t v87 = 0u;
                        *(_OWORD *)v84 = 0u;
                        long long v85 = 0u;
                        *(_OWORD *)uint64_t v82 = 0u;
                        long long v83 = 0u;
                        *(_OWORD *)long long buf = 0u;
                        id v60 = [v69 objectForKey:@"iccid"];
                        if (v60)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)buf, (char *)[v60 UTF8String]);
                          }
                        }
                        id v59 = [v69 objectForKey:@"sourceIccid"];
                        if (v59)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)&v82[1], (char *)[v59 UTF8String]);
                          }
                        }
                        id v58 = [v69 objectForKey:@"phoneNumber"];
                        if (v58)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)v84, (char *)[v58 UTF8String]);
                          }
                        }
                        id v57 = [v69 objectForKey:@"tetherActionType"];
                        if (v57)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass())
                          {
                            __p[0] = 0;
                            __p[1] = 0;
                            uint64_t v80 = 0;
                            sub_100058DB0(__p, (char *)[v57 UTF8String]);
                            DWORD2(v85) = 0;
                            std::locale::locale(&v78);
                            BOOL v27 = sub_100A99698((char *)__p, &v78);
                            std::locale::~locale(&v78);
                            if (v27)
                            {
                              int v28 = 1;
                              goto LABEL_75;
                            }
                            std::locale::locale(&v78);
                            BOOL v29 = sub_100A99780((char *)__p, &v78);
                            std::locale::~locale(&v78);
                            if (v29)
                            {
                              int v28 = 2;
LABEL_75:
                              DWORD2(v85) = v28;
                            }
                            if (SHIBYTE(v80) < 0) {
                              operator delete(__p[0]);
                            }
                          }
                        }
                        id v56 = [v69 objectForKey:@"mcc"];
                        if (v56)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)v86, (char *)[v56 UTF8String]);
                          }
                        }
                        long long v30 = [v69 objectForKey:@"mnc"];
                        if (v30)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)&v87[1], (char *)[v30 UTF8String]);
                          }
                        }
                        long long v31 = [v69 objectForKey:@"gid1"];
                        if (v31)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)v89, (char *)[v31 UTF8String]);
                          }
                        }
                        long long v32 = [v69 objectForKey:@"gid2"];
                        if (v32)
                        {
                          objc_opt_class();
                          if (objc_opt_isKindOfClass()) {
                            sub_10003ED78((std::string *)&v90[1], (char *)[v32 UTF8String]);
                          }
                        }
                        long long v33 = (std::string *)(v18 - 184);
                        if (*(unsigned char *)(v18 - 8))
                        {
                          std::string::operator=(v33, (const std::string *)buf);
                          std::string::operator=((std::string *)(v18 - 160), (const std::string *)&v82[1]);
                          std::string::operator=((std::string *)(v18 - 136), (const std::string *)v84);
                          *(_DWORD *)(v18 - 112) = DWORD2(v85);
                          std::string::operator=((std::string *)(v18 - 104), (const std::string *)v86);
                          std::string::operator=((std::string *)(v18 - 80), (const std::string *)&v87[1]);
                          std::string::operator=((std::string *)(v18 - 56), (const std::string *)v89);
                          std::string::operator=((std::string *)(v18 - 32), (const std::string *)&v90[1]);
                        }
                        else
                        {
                          sub_10030C55C((char *)v33, (long long *)buf);
                          *(unsigned char *)(v18 - 8) = 1;
                        }

                        if (SHIBYTE(v91) < 0) {
                          operator delete(v90[1]);
                        }
                        if (SHIBYTE(v90[0]) < 0) {
                          operator delete(v89[0]);
                        }
                        if (SHIBYTE(v88) < 0) {
                          operator delete(v87[1]);
                        }
                        if (SHIBYTE(v87[0]) < 0) {
                          operator delete(v86[0]);
                        }
                        if (SBYTE7(v85) < 0) {
                          operator delete(v84[0]);
                        }
                        if (SHIBYTE(v83) < 0) {
                          operator delete(v82[1]);
                        }
                        if (SHIBYTE(v82[0]) < 0) {
                          operator delete(*(void **)buf);
                        }
                      }
                      goto LABEL_109;
                    }
                  }
                  sub_100A98214();
                  long long v20 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (smdpUrl)", buf, 2u);
                  }
                }
                else
                {
                  sub_100A98214();
                  uint64_t v19 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (profileOption element)", buf, 2u);
                  }
                }
LABEL_109:
                if (++v12 >= (unint64_t)v11)
                {
                  id v11 = [obj countByEnumeratingWithState:&v92 objects:v98 count:16];
                  if (!v11) {
                    break;
                  }
                  uint64_t v12 = 0;
                }
              }
            }
          }
        }
        uint64_t v35 = [v8 objectForKey:@"defaultSmdpUrls"];
        obuint64_t j = v35;
        if (v35)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            long long v76 = 0u;
            long long v77 = 0u;
            long long v74 = 0u;
            long long v75 = 0u;
            id v72 = v35;
            id v39 = [v72 countByEnumeratingWithState:&v74 objects:v97 count:16];
            if (v39)
            {
              uint64_t v40 = 0;
              uint64_t v41 = *(void *)v75;
              for (uint64_t j = *(void *)v75; ; uint64_t j = *(void *)v75)
              {
                if (j != v41) {
                  objc_enumerationMutation(v72);
                }
                long long v43 = *(void **)(*((void *)&v74 + 1) + 8 * v40);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  unint64_t v44 = a3[1];
                  unint64_t v45 = a3[2];
                  if (v44 >= v45)
                  {
                    uint64_t v48 = 0x6F96F96F96F96F97 * ((uint64_t)(v44 - *a3) >> 3);
                    unint64_t v49 = v48 + 1;
                    if ((unint64_t)(v48 + 1) > 0xD20D20D20D20D2) {
                      sub_10006A748();
                    }
                    unint64_t v50 = 0x6F96F96F96F96F97 * ((uint64_t)(v45 - *a3) >> 3);
                    if (2 * v50 > v49) {
                      unint64_t v49 = 2 * v50;
                    }
                    if (v50 >= 0x69069069069069) {
                      unint64_t v51 = 0xD20D20D20D20D2;
                    }
                    else {
                      unint64_t v51 = v49;
                    }
                    *(void *)&long long v83 = a3 + 2;
                    if (v51) {
                      long long v52 = (char *)sub_10030C27C((uint64_t)(a3 + 2), v51);
                    }
                    else {
                      long long v52 = 0;
                    }
                    long long v53 = &v52[312 * v48];
                    *(void *)long long buf = v52;
                    *(void *)&uint8_t buf[8] = v53;
                    v82[1] = &v52[312 * v51];
                    *((_OWORD *)v53 + 2) = 0u;
                    *((_OWORD *)v53 + 3) = 0u;
                    *((_OWORD *)v53 + 4) = 0u;
                    *((_OWORD *)v53 + 5) = 0u;
                    *((_OWORD *)v53 + 6) = 0u;
                    *((_OWORD *)v53 + 7) = 0u;
                    *((_OWORD *)v53 + 8) = 0u;
                    *((_OWORD *)v53 + 9) = 0u;
                    *((_OWORD *)v53 + 10) = 0u;
                    *((_OWORD *)v53 + 11) = 0u;
                    *((_OWORD *)v53 + 12) = 0u;
                    *((_OWORD *)v53 + 13) = 0u;
                    *((_OWORD *)v53 + 14) = 0u;
                    *((_OWORD *)v53 + 15) = 0u;
                    *((_OWORD *)v53 + 16) = 0u;
                    *((_OWORD *)v53 + 17) = 0u;
                    *((_OWORD *)v53 + 18) = 0u;
                    *((void *)v53 + 38) = 0;
                    *(_OWORD *)long long v53 = 0u;
                    *((_OWORD *)v53 + 1) = 0u;
                    v82[0] = v53 + 312;
                    sub_10030F708(a3, buf);
                    uint64_t v46 = a3[1];
                    sub_10030F890((uint64_t)buf);
                  }
                  else
                  {
                    *(void *)(v44 + 304) = 0;
                    *(_OWORD *)(v44 + 272) = 0u;
                    *(_OWORD *)(v44 + 288) = 0u;
                    *(_OWORD *)(v44 + 240) = 0u;
                    *(_OWORD *)(v44 + 256) = 0u;
                    *(_OWORD *)(v44 + 208) = 0u;
                    *(_OWORD *)(v44 + 224) = 0u;
                    *(_OWORD *)(v44 + 176) = 0u;
                    *(_OWORD *)(v44 + 192) = 0u;
                    *(_OWORD *)(v44 + 144) = 0u;
                    *(_OWORD *)(v44 + 160) = 0u;
                    *(_OWORD *)(v44 + 112) = 0u;
                    *(_OWORD *)(v44 + 128) = 0u;
                    *(_OWORD *)(v44 + 80) = 0u;
                    *(_OWORD *)(v44 + 96) = 0u;
                    *(_OWORD *)(v44 + 48) = 0u;
                    *(_OWORD *)(v44 + 64) = 0u;
                    *(_OWORD *)(v44 + 16) = 0u;
                    *(_OWORD *)(v44 + 32) = 0u;
                    *(_OWORD *)unint64_t v44 = 0u;
                    uint64_t v46 = v44 + 312;
                    a3[1] = v44 + 312;
                  }
                  a3[1] = v46;
                  sub_10003ED78((std::string *)(v46 - 312), (char *)[v43 UTF8String]);
                }
                else
                {
                  sub_100A98214();
                  long long v47 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (defaultSmdp element)", buf, 2u);
                  }
                }
                if (++v40 >= (unint64_t)v39)
                {
                  id v39 = [v72 countByEnumeratingWithState:&v74 objects:v97 count:16];
                  if (!v39) {
                    break;
                  }
                  uint64_t v40 = 0;
                }
              }
            }
            LODWORD(v35) = 0;
LABEL_151:
          }
          else
          {
            LODWORD(v35) = 0;
          }
        }

        long long v38 = v68;
      }
      else
      {
        sub_100A98214();
        uint64_t v37 = qword_101B0FD28;
        long long v38 = v68;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Element not found or invalid type (sessionId)", buf, 2u);
        }
        LODWORD(v35) = 1;
      }
    }
  }
  else
  {
    sub_100A98214();
    uint64_t v36 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    LODWORD(v35) = 1;
  }
  return v35 == 0;
}

void sub_100A99464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,uint64_t a31,void *a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,std::locale a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A99698(char *a1, const std::locale *a2)
{
  std::locale::locale(&v13, a2);
  int v3 = a1[23];
  uint64_t v4 = *((void *)a1 + 1);
  if (v3 >= 0)
  {
    uint64_t v5 = v3;
  }
  else
  {
    a1 = *(char **)a1;
    uint64_t v5 = v4;
  }
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5 - 1;
    if ((unint64_t)(v5 - 1) >= 6) {
      uint64_t v7 = 6;
    }
    uint64_t v8 = v7 + 1;
    while (sub_100326220(&v13, &a1[v6], &aDelayed[v6]))
    {
      if (v8 == ++v6)
      {
        BOOL v9 = v6 == 7;
        BOOL v10 = &a1[v6];
        goto LABEL_12;
      }
    }
    BOOL v11 = 0;
  }
  else
  {
    BOOL v9 = 0;
    BOOL v10 = a1;
LABEL_12:
    BOOL v11 = v10 == &a1[v5] && v9;
  }
  std::locale::~locale(&v13);
  return v11;
}

void sub_100A9976C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

BOOL sub_100A99780(char *a1, const std::locale *a2)
{
  std::locale::locale(&v13, a2);
  int v3 = a1[23];
  uint64_t v4 = *((void *)a1 + 1);
  if (v3 >= 0)
  {
    uint64_t v5 = v3;
  }
  else
  {
    a1 = *(char **)a1;
    uint64_t v5 = v4;
  }
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v5 - 1;
    if ((unint64_t)(v5 - 1) >= 2) {
      uint64_t v7 = 2;
    }
    uint64_t v8 = v7 + 1;
    while (sub_100326220(&v13, &a1[v6], &aNow[v6]))
    {
      if (v8 == ++v6)
      {
        BOOL v9 = v6 == 3;
        BOOL v10 = &a1[v6];
        goto LABEL_12;
      }
    }
    BOOL v11 = 0;
  }
  else
  {
    BOOL v9 = 0;
    BOOL v10 = a1;
LABEL_12:
    BOOL v11 = v10 == &a1[v5] && v9;
  }
  std::locale::~locale(&v13);
  return v11;
}

void sub_100A99854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

BOOL sub_100A99868(int a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v13 = 0;
  ctu::base64::encode();
  CFStringRef v6 = @"lpaSignedRequest";
  if (a1) {
    CFStringRef v6 = @"signedIdMapInfo";
  }
  CFStringRef v14 = v6;
  if (v13 >= 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  uint64_t v8 = +[NSString stringWithFormat:@"%s", v7];
  BOOL v15 = v8;
  BOOL v9 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];

  BOOL v10 = sub_100A97B4C((uint64_t)v9, a3);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  return v10;
}

void sub_100A99998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A999D4(void *a1, CFAbsoluteTime *a2, const void **a3)
{
  if (*a1) {
    uint64_t v5 = sub_10008324C;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    sub_100A98214();
    unint64_t v45 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    int v43 = 1;
    goto LABEL_112;
  }
  uint64_t v89 = 0;
  long long v73 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
  id v69 = 0;
  if (v69) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v73 == 0;
  }
  if (v6 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    sub_100A98214();
    unint64_t v44 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
    }
    int v43 = 1;
    goto LABEL_111;
  }
  long long v65 = [v73 objectForKey:@"expiryDate"];
  if (!v65 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    sub_100A98214();
    uint64_t v46 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Element not found or invalid type (expiryDate)", buf, 2u);
    }
    int v43 = 1;
    goto LABEL_110;
  }
  id v59 = [v73 objectForKey:@"carrierOptions"];
  if (!v59 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    sub_100A98214();
    long long v47 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      unint64_t v49 = "Element not found or invalid type (carrierOptions)";
      goto LABEL_116;
    }
LABEL_108:
    int v43 = 1;
    goto LABEL_109;
  }
  if (!sub_100A9A91C(v65, a2))
  {
    sub_100A98214();
    long long v47 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      unint64_t v49 = "Expiry time parsing failure";
LABEL_116:
      _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, v49, buf, 2u);
      goto LABEL_108;
    }
    goto LABEL_108;
  }
  id v50 = objc_alloc_init((Class)NSMutableArray);
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  obuint64_t j = v59;
  id v63 = [obj countByEnumeratingWithState:&v85 objects:v93 count:16];
  if (!v63) {
    goto LABEL_93;
  }
  uint64_t v62 = *(void *)v86;
  do
  {
    id v66 = 0;
    do
    {
      if (*(void *)v86 != v62) {
        objc_enumerationMutation(obj);
      }
      uint64_t v7 = *(void **)(*((void *)&v85 + 1) + 8 * (void)v66);
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v64 = [v7 objectForKey:@"carrierDisplayName"];
        if (!v64 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          sub_100A98214();
          uint64_t v12 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - skipping (carrierDisplayName)", buf, 2u);
          }
          goto LABEL_78;
        }
        uint64_t v8 = [v7 objectForKey:@"planPurchaseEndpoint"];
        long long v54 = v8;
        if (v8)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            goto LABEL_28;
          }
        }
        sub_100A98214();
        BOOL v9 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - (plan purchase end point)", buf, 2u);
        }
        if (v8)
        {
LABEL_28:
          id v61 = v8;
          BOOL v10 = [v7 objectForKey:@"planPurchaseEndpointType"];
          if (v10 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
          {
            id v60 = v10;
          }
          else
          {
            sub_100A98214();
            uint64_t v13 = qword_101B0FD28;
            id v60 = @"websheet";
            if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - Default (planPurchaseEndpointType)", buf, 2u);
              id v60 = @"websheet";
            }
          }

          goto LABEL_38;
        }
        uint64_t v36 = [v7 objectForKey:@"addOnPlanPurchaseEndpoint"];
        if (!v36 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          sub_100A98214();
          uint64_t v37 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - (addOnPlanPurchaseEndpoint)", buf, 2u);
          }
        }
        id v61 = v36;
        long long v38 = [v7 objectForKey:@"addOnPlanPurchaseEndpointType"];
        if (v38 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          id v60 = v38;
        }
        else
        {
          sub_100A98214();
          id v39 = qword_101B0FD28;
          id v60 = @"websheet";
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - Default (addOnPlanPurchaseEndpointType)", buf, 2u);
            id v60 = @"websheet";
          }
        }

        if (!v36)
        {
          id v61 = 0;
LABEL_77:

LABEL_78:
          goto LABEL_79;
        }
LABEL_38:
        CFStringRef v14 = [v7 objectForKey:@"supportsApplePay"];
        long long v53 = v14;
        if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          unsigned int v52 = [v14 BOOLValue];
        }
        else {
          unsigned int v52 = 0;
        }
        id v56 = [v7 objectForKey:@"warningText"];
        if (!v56 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          sub_100A98214();
          BOOL v15 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - skipping (warning text)", buf, 2u);
          }
        }
        id v57 = [v7 objectForKey:@"planPurchaseOptions"];
        if (v57 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          uint64_t v51 = sub_100A9A9B8(v57);
        }
        else
        {
          sub_100A98214();
          unint64_t v16 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - (planPurchaseOptions)", buf, 2u);
          }
          uint64_t v51 = 0;
        }
        long long v76 = objc_opt_new();
        uint64_t v55 = [v7 objectForKey:@"bundle"];
        if (v55 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          long long v83 = 0u;
          long long v84 = 0u;
          long long v81 = 0u;
          long long v82 = 0u;
          id v67 = v55;
          id v71 = [v67 countByEnumeratingWithState:&v81 objects:v92 count:16];
          if (v71)
          {
            uint64_t v70 = *(void *)v82;
            do
            {
              for (uint64_t i = 0; i != v71; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v82 != v70) {
                  objc_enumerationMutation(v67);
                }
                long long v74 = [*(id *)(*((void *)&v81 + 1) + 8 * i) objectForKey:@"supportedSims"];
                if (v74)
                {
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    long long v79 = 0u;
                    long long v80 = 0u;
                    long long v77 = 0u;
                    long long v78 = 0u;
                    id v17 = v74;
                    id v18 = [v17 countByEnumeratingWithState:&v77 objects:v91 count:16];
                    if (v18)
                    {
                      uint64_t v19 = *(void *)v78;
                      do
                      {
                        for (uint64_t j = 0; j != v18; uint64_t j = (char *)j + 1)
                        {
                          if (*(void *)v78 != v19) {
                            objc_enumerationMutation(v17);
                          }
                          uint64_t v21 = *(void **)(*((void *)&v77 + 1) + 8 * (void)j);
                          unint64_t v22 = sub_100A9AA28(v21, @"mcc");
                          unint64_t v23 = sub_100A9AA28(v21, @"mnc");
                          unint64_t v24 = sub_100A9AA28(v21, @"gid1");
                          id v25 = sub_100A9AA28(v21, @"gid2");
                          long long v26 = sub_100A9AA28(v21, @"iccidPrefix");
                          id v27 = [objc_alloc((Class)CTPlanIdentifier) initWithIccid:v26 carrierName:0 phoneNumber:0 countryCode:0 label:0 mcc:v22 mnc:v23 gid1:v24 gid2:v25];
                          [v76 addObject:v27];
                        }
                        id v18 = [v17 countByEnumeratingWithState:&v77 objects:v91 count:16];
                      }
                      while (v18);
                    }
                  }
                }
              }
              id v71 = [v67 countByEnumeratingWithState:&v81 objects:v92 count:16];
            }
            while (v71);
          }

          sub_100A98214();
          uint64_t v28 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            id v29 = [v76 count];
            *(_DWORD *)long long buf = 134217984;
            *(void *)&uint8_t buf[4] = v29;
            long long v30 = v28;
            long long v31 = "#I Decoded %lu bundle details";
            uint32_t v32 = 12;
            goto LABEL_75;
          }
        }
        else
        {
          sub_100A98214();
          uint64_t v33 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            long long v30 = v33;
            long long v31 = "#I Element not found or invalid type - skipping (bundle)";
            uint32_t v32 = 2;
LABEL_75:
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, buf, v32);
          }
        }
        id v34 = [objc_alloc((Class)CTCarrierSignupPlan) initWithName:v64 url:v61 type:v60 option:v51 identifiers:v76];
        id v35 = [objc_alloc((Class)CTCellularPlanCarrierItem) initWithName:v64 plan:v34 url:v61 applePaySupported:v52 responseType:v60 warningText:v56 purchaseOption:v57];
        [v50 addObject:v35];

        goto LABEL_77;
      }
      sub_100A98214();
      BOOL v11 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - skipping (carrier element)", buf, 2u);
      }
LABEL_79:
      id v66 = (char *)v66 + 1;
    }
    while (v66 != v63);
    id v40 = [obj countByEnumeratingWithState:&v85 objects:v93 count:16];
    id v63 = v40;
  }
  while (v40);
LABEL_93:

  if ([v50 count])
  {
    *(void *)long long buf = v50;
    sub_1002824E4(a3, (CFTypeRef *)buf);
  }
  sub_100A98214();
  uint64_t v41 = qword_101B0FD28;
  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
  {
    id v42 = [v50 count];
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v42;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Decoded %lu carrier items", buf, 0xCu);
  }

  int v43 = 0;
LABEL_109:

LABEL_110:
LABEL_111:

LABEL_112:
  return v43 == 0;
}

void sub_100A9A6BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9A91C(void *a1, CFAbsoluteTime *a2)
{
  int v3 = a1;
  uint64_t v4 = (__CFDateFormatter *)qword_101B0FD18;
  if (!qword_101B0FD18)
  {
    qword_101B0FD18 = (uint64_t)CFDateFormatterCreate(kCFAllocatorDefault, 0, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat((CFDateFormatterRef)qword_101B0FD18, @"yyyy-MM-dd'T'HH:mm:ssz");
    uint64_t v4 = (__CFDateFormatter *)qword_101B0FD18;
  }
  BOOL v5 = CFDateFormatterGetAbsoluteTimeFromString(v4, v3, 0, a2) != 0;

  return v5;
}

void sub_100A9A9A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A9A9B8(void *a1)
{
  id v1 = a1;
  if ([v1 isEqual:@"ALLOW_ON_BOOTSTRAP"])
  {
    uint64_t v2 = 1;
  }
  else if ([v1 isEqual:@"DISALLOW_ON_BOOTSTRAP"])
  {
    uint64_t v2 = 2;
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_100A9AA18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100A9AA28(void *a1, uint64_t a2)
{
  uint64_t v2 = [a1 objectForKey:a2];
  if (v2 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void sub_100A9AA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9AAAC(uint64_t a1, uint64_t **a2, void *a3, uint64_t a4)
{
  if (*a3 == a3[1])
  {
    sub_100A98214();
    long long v26 = qword_101B0FD28;
    BOOL v25 = 0;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Mandatory parameters missing (signedPayload)", buf, 2u);
      BOOL v25 = 0;
    }
  }
  else
  {
    uint64_t v29 = a4;
    id v31 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v7 = *a2;
    uint64_t v8 = a2[1];
    if (*a2 != v8)
    {
      do
      {
        if (!*((unsigned char *)v7 + 24)) {
          goto LABEL_26;
        }
        char v9 = *((unsigned char *)v7 + 23);
        if (v9 < 0)
        {
          if (!v7[1]) {
            goto LABEL_26;
          }
        }
        else if (!*((unsigned char *)v7 + 23))
        {
          goto LABEL_26;
        }
        if (*((char *)v7 + 55) < 0)
        {
          if (!v7[5]) {
            goto LABEL_26;
          }
        }
        else if (!*((unsigned char *)v7 + 55))
        {
          goto LABEL_26;
        }
        if (*((char *)v7 + 79) < 0)
        {
          if (v7[8])
          {
LABEL_14:
            v35[0] = @"iccid";
            BOOL v10 = v7;
            if (v9 < 0) {
              BOOL v10 = (uint64_t *)*v7;
            }
            BOOL v11 = +[NSString stringWithFormat:@"%s", v10];
            uint64_t v12 = v7 + 4;
            v36[0] = v11;
            v35[1] = @"mcc";
            if (*((char *)v7 + 55) < 0) {
              uint64_t v12 = (void *)*v12;
            }
            uint64_t v13 = +[NSString stringWithFormat:@"%s", v12];
            CFStringRef v14 = v7 + 7;
            v36[1] = v13;
            void v35[2] = @"mnc";
            if (*((char *)v7 + 79) < 0) {
              CFStringRef v14 = (void *)*v14;
            }
            BOOL v15 = +[NSString stringWithFormat:@"%s", v14];
            v36[2] = v15;
            int v35[3] = @"gid1";
            unint64_t v16 = v7 + 10;
            if (*((char *)v7 + 103) < 0) {
              unint64_t v16 = (void *)*v16;
            }
            id v17 = +[NSString stringWithFormat:@"%s", v16];
            v36[3] = v17;
            v35[4] = @"gid2";
            id v18 = v7 + 13;
            if (*((char *)v7 + 127) < 0) {
              id v18 = (void *)*v18;
            }
            uint64_t v19 = +[NSString stringWithFormat:@"%s", v18];
            v36[4] = v19;
            long long v20 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:5];

            [v31 addObject:v20];
            goto LABEL_28;
          }
        }
        else if (*((unsigned char *)v7 + 79))
        {
          goto LABEL_14;
        }
LABEL_26:
        sub_100A98214();
        uint64_t v21 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Mandatory parameters missing", buf, 2u);
        }
LABEL_28:
        v7 += 16;
      }
      while (v7 != v8);
    }
    if ([v31 count])
    {
      *(void *)long long buf = 0;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      ctu::base64::encode();
      id v22 = objc_alloc_init((Class)NSMutableDictionary);
      [v22 setObject:v31 forKeyedSubscript:@"simAddonMetadata"];
      unint64_t v23 = buf;
      if (v34 < 0) {
        unint64_t v23 = *(uint8_t **)buf;
      }
      unint64_t v24 = +[NSString stringWithFormat:@"%s", v23];
      [v22 setObject:v24 forKeyedSubscript:@"lpaSignedRequest"];

      BOOL v25 = sub_100A97B4C((uint64_t)v22, v29);
      if (SHIBYTE(v34) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      sub_100A98214();
      id v27 = qword_101B0FD28;
      BOOL v25 = 0;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Mandatory parameters missing (simAddonMetadata)", buf, 2u);
        BOOL v25 = 0;
      }
    }
  }
  return v25;
}

void sub_100A9AEE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9AF8C(void *a1, uint64_t a2)
{
  if (*a1) {
    id v3 = sub_10008324C;
  }
  else {
    id v3 = 0;
  }
  if (v3)
  {
    uint64_t v58 = 0;
    uint64_t v51 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v4 = 0;
    if (v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v51 == 0;
    }
    uint64_t v48 = v4;
    if (v5 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      uint64_t v34 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Top level decoding failure", (uint8_t *)&buf, 2u);
      }
      int v35 = 1;
    }
    else
    {
      uint64_t v46 = [v51 objectForKey:@"simAddonMetadataEval"];
      if (v46 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        id v6 = v46;
        id v7 = [v6 countByEnumeratingWithState:&v54 objects:v59 count:16];
        if (v7)
        {
          uint64_t v8 = 0;
          long long v47 = (uint64_t **)(a2 + 8);
          uint64_t v9 = *(void *)v55;
          for (uint64_t i = *(void *)v55; ; uint64_t i = *(void *)v55)
          {
            if (i != v9) {
              objc_enumerationMutation(v6);
            }
            BOOL v11 = *(void **)(*((void *)&v54 + 1) + 8 * v8);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              uint64_t v12 = [v11 objectForKey:@"iccid"];
              if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
              {
                uint64_t v13 = (char *)[v12 UTF8String];
                sub_100058DB0(__p, v13);
                CFStringRef v14 = (uint64_t **)(a2 + 8);
                BOOL v15 = *v47;
                unint64_t v16 = (uint64_t **)(a2 + 8);
                if (!*v47) {
                  goto LABEL_32;
                }
                unint64_t v16 = (uint64_t **)(a2 + 8);
                while (1)
                {
                  while (1)
                  {
                    CFStringRef v14 = (uint64_t **)v15;
                    id v17 = v15 + 4;
                    if ((sub_100046FE8(__p, (void **)v15 + 4) & 0x80) == 0) {
                      break;
                    }
                    BOOL v15 = *v14;
                    unint64_t v16 = v14;
                    if (!*v14) {
                      goto LABEL_32;
                    }
                  }
                  if ((sub_100046FE8(v17, __p) & 0x80) == 0) {
                    break;
                  }
                  unint64_t v16 = v14 + 1;
                  BOOL v15 = v14[1];
                  if (!v15) {
                    goto LABEL_32;
                  }
                }
                long long v20 = *v16;
                if (!*v16)
                {
LABEL_32:
                  uint64_t v61 = 1;
                  long long v20 = (uint64_t *)operator new(0x158uLL);
                  *((void *)&buf + 1) = a2 + 8;
                  *((_OWORD *)v20 + 2) = *(_OWORD *)__p;
                  v20[6] = v53;
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v53 = 0;
                  *(_OWORD *)(v20 + 9) = 0u;
                  *(_OWORD *)(v20 + 11) = 0u;
                  *(_OWORD *)(v20 + 13) = 0u;
                  *(_OWORD *)(v20 + 15) = 0u;
                  *(_OWORD *)(v20 + 17) = 0u;
                  *(_OWORD *)(v20 + 19) = 0u;
                  *(_OWORD *)(v20 + 21) = 0u;
                  *(_OWORD *)(v20 + 23) = 0u;
                  *(_OWORD *)(v20 + 25) = 0u;
                  *(_OWORD *)(v20 + 27) = 0u;
                  *(_OWORD *)(v20 + 29) = 0u;
                  *(_OWORD *)(v20 + 31) = 0u;
                  *(_OWORD *)(v20 + 33) = 0u;
                  *(_OWORD *)(v20 + 35) = 0u;
                  *(_OWORD *)(v20 + 7) = 0u;
                  *(_OWORD *)(v20 + 37) = 0u;
                  *(_OWORD *)(v20 + 39) = 0u;
                  *(_OWORD *)(v20 + 41) = 0u;
                  sub_100046C38((uint64_t **)a2, (uint64_t)v14, v16, v20);
                  *(void *)&long long buf = 0;
                  sub_10034AAE4((uint64_t)&buf, 0);
                }
                if (SHIBYTE(v53) < 0) {
                  operator delete(__p[0]);
                }
                sub_10003ED78((std::string *)(v20 + 7), v13);
                uint64_t v21 = [v11 objectForKey:@"result"];
                if (v21 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                {
                  sub_10003ED78((std::string *)(v20 + 31), (char *)[v21 UTF8String]);
                  id v45 = [v11 objectForKey:@"gid1"];
                  if (v45 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    sub_10003ED78((std::string *)(v20 + 25), (char *)[v45 UTF8String]);
                    id v44 = [v11 objectForKey:@"gid2"];
                    if (v44 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                    {
                      sub_10003ED78((std::string *)(v20 + 28), (char *)[v44 UTF8String]);
                      id v43 = [v11 objectForKey:@"mcc"];
                      if (v43 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                      {
                        sub_10003ED78((std::string *)(v20 + 19), (char *)[v43 UTF8String]);
                        id v42 = [v11 objectForKey:@"mnc"];
                        if (v42 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                        {
                          sub_10003ED78((std::string *)(v20 + 22), (char *)[v42 UTF8String]);
                          uint64_t v41 = [v11 objectForKey:@"presentOnDevice"];
                          if (v41 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                          {
                            *((unsigned char *)v20 + 272) = [v41 BOOLValue];
                            id v22 = [v11 objectForKey:@"addOnPlanEndpoint"];
                            if (v22)
                            {
                              objc_opt_class();
                              if (objc_opt_isKindOfClass())
                              {
                                *(void *)&long long buf = [v22 UTF8String];
                                sub_1000791C0((std::string *)(v20 + 35), (char **)&buf);
                              }
                            }
                            unint64_t v23 = objc_msgSend(v11, "objectForKey:", @"addOnPlanEndpointType", v41);
                            if (v23)
                            {
                              objc_opt_class();
                              if (objc_opt_isKindOfClass())
                              {
                                *(void *)&long long buf = [v23 UTF8String];
                                sub_1000791C0((std::string *)v20 + 13, (char **)&buf);
                              }
                            }
                          }
                          else
                          {
                            sub_100A98214();
                            uint64_t v33 = qword_101B0FD28;
                            if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                            {
                              LODWORD(buf) = 136315138;
                              *(void *)((char *)&buf + 4) = v13;
                              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (is Present On Device)", (uint8_t *)&buf, 0xCu);
                            }
                          }

                          uint32_t v32 = v42;
                        }
                        else
                        {
                          sub_100A98214();
                          id v31 = qword_101B0FD28;
                          uint32_t v32 = v42;
                          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                          {
                            LODWORD(buf) = 136315138;
                            *(void *)((char *)&buf + 4) = v13;
                            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (mnc)", (uint8_t *)&buf, 0xCu);
                          }
                        }

                        long long v30 = v43;
                      }
                      else
                      {
                        sub_100A98214();
                        uint64_t v29 = qword_101B0FD28;
                        long long v30 = v43;
                        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                        {
                          LODWORD(buf) = 136315138;
                          *(void *)((char *)&buf + 4) = v13;
                          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (mcc)", (uint8_t *)&buf, 0xCu);
                        }
                      }

                      uint64_t v28 = v44;
                    }
                    else
                    {
                      sub_100A98214();
                      id v27 = qword_101B0FD28;
                      uint64_t v28 = v44;
                      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                      {
                        LODWORD(buf) = 136315138;
                        *(void *)((char *)&buf + 4) = v13;
                        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (gid2)", (uint8_t *)&buf, 0xCu);
                      }
                    }

                    long long v26 = v45;
                  }
                  else
                  {
                    sub_100A98214();
                    BOOL v25 = qword_101B0FD28;
                    long long v26 = v45;
                    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(buf) = 136315138;
                      *(void *)((char *)&buf + 4) = v13;
                      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (gid1)", (uint8_t *)&buf, 0xCu);
                    }
                  }
                }
                else
                {
                  sub_100A98214();
                  unint64_t v24 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf) = 136315138;
                    *(void *)((char *)&buf + 4) = v13;
                    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I iccid %s Element not found or invalid type - (result)", (uint8_t *)&buf, 0xCu);
                  }
                }
              }
              else
              {
                sub_100A98214();
                uint64_t v19 = qword_101B0FD28;
                if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - skipping (iccid)", (uint8_t *)&buf, 2u);
                }
              }
            }
            else
            {
              sub_100A98214();
              id v18 = qword_101B0FD28;
              if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type - skipping (carrier element)", (uint8_t *)&buf, 2u);
              }
            }
            if (++v8 >= (unint64_t)v7)
            {
              id v7 = [v6 countByEnumeratingWithState:&v54 objects:v59 count:16];
              if (!v7) {
                break;
              }
              uint64_t v8 = 0;
            }
          }
        }

        sub_100A98214();
        id v39 = qword_101B0FD28;
        int v35 = 0;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v40 = *(void *)(a2 + 16);
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v40;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Decoded %lu add-on options", (uint8_t *)&buf, 0xCu);
          int v35 = 0;
        }
      }
      else
      {
        sub_100A98214();
        uint64_t v37 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (addOnOptions)", (uint8_t *)&buf, 2u);
        }
        int v35 = 1;
      }
    }
  }
  else
  {
    sub_100A98214();
    uint64_t v36 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I No data", (uint8_t *)&buf, 2u);
    }
    int v35 = 1;
  }
  return v35 == 0;
}

void sub_100A9B9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9BB04(uint64_t *a1, void *a2, void *a3, uint64_t *a4, uint64_t a5)
{
  if (*a2 == a2[1] || *a3 == a3[1])
  {
    BOOL v20 = 0;
  }
  else
  {
    v24[0] = 0;
    v24[1] = 0;
    uint64_t v25 = 0;
    ctu::base64::encode();
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    ctu::base64::encode();
    v26[0] = @"smdpUrl";
    if (*((char *)a1 + 23) >= 0) {
      BOOL v11 = a1;
    }
    else {
      BOOL v11 = (uint64_t *)*a1;
    }
    uint64_t v12 = +[NSString stringWithFormat:@"%s", v11];
    v27[0] = v12;
    v26[1] = @"storeMetadata";
    uint64_t v13 = v24;
    if (v25 < 0) {
      uint64_t v13 = (void **)v24[0];
    }
    CFStringRef v14 = +[NSString stringWithFormat:@"%s", v13];
    v27[1] = v14;
    v26[2] = @"action";
    if (*((char *)a4 + 23) >= 0) {
      BOOL v15 = a4;
    }
    else {
      BOOL v15 = (uint64_t *)*a4;
    }
    unint64_t v16 = +[NSString stringWithFormat:@"%s", v15];
    v27[2] = v16;
    void v26[3] = @"lpaSignedRequest";
    id v17 = __p;
    if (v23 < 0) {
      id v17 = (void **)__p[0];
    }
    id v18 = +[NSString stringWithFormat:@"%s", v17];
    v27[3] = v18;
    uint64_t v19 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:4];

    BOOL v20 = sub_100A97B4C((uint64_t)v19, a5);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
  }
  return v20;
}

void sub_100A9BD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A9BDB4(void *a1, uint64_t a2, int a3)
{
  if (*a1) {
    id v7 = sub_10008324C;
  }
  else {
    id v7 = 0;
  }
  if (v7)
  {
    uint64_t v22 = 0;
    uint64_t v8 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v9 = 0;
    if (v9) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = v8 == 0;
    }
    if (v10 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      uint64_t v13 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Top level decoding failure", (uint8_t *)__p, 2u);
      }
      BOOL v12 = 0;
      int v14 = 1;
    }
    else
    {
      BOOL v11 = [v8 objectForKey:@"result"];
      if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        BOOL v12 = ![v11 caseInsensitiveCompare:@"Allowed"]
           || ![v11 caseInsensitiveCompare:@"Warning"];
        if (a3 && ![v11 caseInsensitiveCompare:@"Unknown"]) {
          BOOL v12 = 1;
        }
        id v18 = [v8 objectForKey:@"description"];
        if (v18)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            sub_100058DB0(__p, (char *)[v18 UTF8String]);
            sub_10008BE4C(a2, (long long *)__p);
            if (v21 < 0) {
              operator delete(__p[0]);
            }
          }
        }

        int v14 = 0;
      }
      else
      {
        sub_100A98214();
        id v17 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (result)", (uint8_t *)__p, 2u);
        }
        BOOL v12 = 0;
        int v14 = 1;
      }
    }
    BOOL v16 = v12;
  }
  else
  {
    sub_100A98214();
    BOOL v15 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No data", (uint8_t *)__p, 2u);
    }
    BOOL v16 = 0;
    int v14 = 1;
  }
  return !v14 && v16;
}

void sub_100A9C08C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

BOOL sub_100A9C0E4(uint64_t *a1, uint64_t *a2, uint64_t *a3, void *a4, uint64_t a5)
{
  if (*a4 != a4[1])
  {
    id v34 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
    if (*a2 != v9)
    {
      do
      {
        char v10 = *(unsigned char *)(v8 + 55);
        if (v10 < 0)
        {
          if (!*(void *)(v8 + 40)) {
            goto LABEL_20;
          }
        }
        else if (!*(unsigned char *)(v8 + 55))
        {
          goto LABEL_20;
        }
        if (*(char *)(v8 + 79) < 0)
        {
          if (*(void *)(v8 + 64))
          {
LABEL_11:
            BOOL v11 = (void *)(v8 + 32);
            v38[0] = @"mcc";
            if (v10 < 0) {
              BOOL v11 = (void *)*v11;
            }
            BOOL v12 = +[NSString stringWithFormat:@"%s", v11];
            uint64_t v13 = (void *)(v8 + 56);
            v39[0] = v12;
            v38[1] = @"mnc";
            if (*(char *)(v8 + 79) < 0) {
              uint64_t v13 = (void *)*v13;
            }
            int v14 = +[NSString stringWithFormat:@"%s", v13];
            v39[1] = v14;
            v38[2] = @"gid1";
            BOOL v15 = (void *)(v8 + 80);
            if (*(char *)(v8 + 103) < 0) {
              BOOL v15 = (void *)*v15;
            }
            BOOL v16 = +[NSString stringWithFormat:@"%s", v15];
            v39[2] = v16;
            v38[3] = @"gid2";
            id v17 = (void *)(v8 + 104);
            if (*(char *)(v8 + 127) < 0) {
              id v17 = (void *)*v17;
            }
            id v18 = +[NSString stringWithFormat:@"%s", v17];
            v39[3] = v18;
            uint64_t v19 = +[NSDictionary dictionaryWithObjects:v39 forKeys:v38 count:4];

            [v34 addObject:v19];
          }
        }
        else if (*(unsigned char *)(v8 + 79))
        {
          goto LABEL_11;
        }
LABEL_20:
        v8 += 128;
      }
      while (v8 != v9);
    }
    if (![v34 count])
    {
      sub_100A98214();
      uint64_t v25 = qword_101B0FD28;
      BOOL v24 = 0;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Mandatory parameters missing (appMetadata)", buf, 2u);
        BOOL v24 = 0;
      }
      goto LABEL_40;
    }
    *(void *)long long buf = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    ctu::base64::encode();
    id v20 = objc_alloc_init((Class)NSMutableDictionary);
    [v20 setObject:v34 forKeyedSubscript:@"appMetadata"];
    char v21 = +[NSString stringWithFormat:@"%s", buf];
    [v20 setObject:v21 forKeyedSubscript:@"lpaSignedRequest"];

    uint64_t v22 = a1;
    if (*((char *)a1 + 23) < 0)
    {
      if (!a1[1]) {
        goto LABEL_32;
      }
      uint64_t v22 = (uint64_t *)*a1;
    }
    else if (!*((unsigned char *)a1 + 23))
    {
LABEL_32:
      id v27 = a3;
      if (*((char *)a3 + 23) < 0)
      {
        if (!a3[1]) {
          goto LABEL_38;
        }
        id v27 = (uint64_t *)*a3;
      }
      else if (!*((unsigned char *)a3 + 23))
      {
LABEL_38:
        uint64_t v29 = +[NSNumber numberWithBool:1];
        [v20 setObject:v29 forKeyedSubscript:@"verbose"];

        BOOL v24 = sub_100A97B4C((uint64_t)v20, a5);
        if (SHIBYTE(v37) < 0) {
          operator delete(*(void **)buf);
        }
LABEL_40:

        goto LABEL_41;
      }
      uint64_t v28 = +[NSString stringWithFormat:@"%s", v27];
      [v20 setObject:v28 forKeyedSubscript:@"iccidPrefix"];

      goto LABEL_38;
    }
    long long v26 = +[NSString stringWithFormat:@"%s", v22];
    [v20 setObject:v26 forKeyedSubscript:@"smdpUrl"];

    goto LABEL_32;
  }
  sub_100A98214();
  uint64_t v23 = qword_101B0FD28;
  BOOL v24 = 0;
  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Mandatory parameters missing (signedPayload)", buf, 2u);
    BOOL v24 = 0;
  }
LABEL_41:
  return v24;
}

void sub_100A9C544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100A9C5FC(void *a1, uint64_t **a2)
{
  if (*a1) {
    id v3 = sub_10008324C;
  }
  else {
    id v3 = 0;
  }
  if (v3)
  {
    uint64_t v45 = 0;
    uint64_t v28 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v4 = 0;
    LOBYTE(v5) = (_BYTE)v4;
    if (v4) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v28 == 0;
    }
    long long v26 = v4;
    if (v6 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      id v17 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
      }
      LOBYTE(v5) = 0;
      int v16 = 1;
      goto LABEL_92;
    }
    id v7 = [v28 objectForKey:@"appMetadataEval"];
    uint64_t v23 = v7;
    if (v7)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        id v8 = v7;
        obuint64_t j = v8;
        id v9 = [v8 countByEnumeratingWithState:&v31 objects:v47 count:16];
        if (v9)
        {
          uint64_t v10 = *(void *)v32;
          uint64_t v22 = &v43[1];
          do
          {
            for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v32 != v10) {
                objc_enumerationMutation(obj);
              }
              BOOL v12 = *(void **)(*((void *)&v31 + 1) + 8 * i);
              uint64_t v13 = objc_msgSend(v12, "objectForKey:", @"mcc", v22);
              if (v13 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
              {
                int v14 = [v12 objectForKey:@"mnc"];
                if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                {
                  BOOL v15 = [v12 objectForKey:@"gid1"];
                  if (v15 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    id v29 = [v12 objectForKey:@"gid2"];
                    if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                    {
                      BOOL v24 = [v12 objectForKey:@"result"];
                      if (v24 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                      {
                        LOBYTE(v5) = ![v24 caseInsensitiveCompare:@"Allowed"]
                                  || ![v24 caseInsensitiveCompare:@"Warning"];
                        *(_OWORD *)id v43 = 0u;
                        long long v44 = 0u;
                        long long v41 = 0u;
                        *(_OWORD *)id v42 = 0u;
                        *(_OWORD *)id v39 = 0u;
                        *(_OWORD *)uint64_t v40 = 0u;
                        *(_OWORD *)long long buf = 0u;
                        long long v38 = 0u;
                        sub_100058DB0(v39, (char *)[v13 UTF8String]);
                        sub_100058DB0(&v40[1], (char *)[v14 UTF8String]);
                        sub_100058DB0(v42, (char *)[v15 UTF8String]);
                        sub_100058DB0(v22, (char *)[v29 UTF8String]);
                        sub_100A9CFA4((const void **)buf, __p);
                        uint64_t v46 = __p;
                        *((unsigned char *)sub_100AA102C(a2, __p, (_OWORD **)&v46) + 56) = (_BYTE)v5;
                        if (v36 < 0) {
                          operator delete(__p[0]);
                        }
                        if (SHIBYTE(v44) < 0) {
                          operator delete(v43[1]);
                        }
                        if (SHIBYTE(v43[0]) < 0) {
                          operator delete(v42[0]);
                        }
                        if (SHIBYTE(v41) < 0) {
                          operator delete(v40[1]);
                        }
                        if (SHIBYTE(v40[0]) < 0) {
                          operator delete(v39[0]);
                        }
                        if (BYTE8(v38) && SBYTE7(v38) < 0) {
                          operator delete(*(void **)buf);
                        }
                      }
                      else
                      {
                        sub_100A98214();
                        BOOL v5 = qword_101B0FD28;
                        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Missing result", buf, 2u);
                        }
                      }
                    }
                    else
                    {
                      sub_100A98214();
                      BOOL v5 = qword_101B0FD28;
                      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Missing gid2", buf, 2u);
                      }
                    }
                  }
                  else
                  {
                    sub_100A98214();
                    BOOL v5 = qword_101B0FD28;
                    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Missing gid1", buf, 2u);
                    }
                  }
                }
                else
                {
                  sub_100A98214();
                  BOOL v5 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Missing mnc", buf, 2u);
                  }
                }
              }
              else
              {
                sub_100A98214();
                BOOL v5 = qword_101B0FD28;
                if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Missing mcc", buf, 2u);
                }
              }
            }
            id v8 = obj;
            id v9 = [obj countByEnumeratingWithState:&v31 objects:v47 count:16];
          }
          while (v9);
        }
        int v16 = 0;
        goto LABEL_91;
      }
    }
    sub_100A98214();
    uint64_t v19 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (appMetadataEval)", buf, 2u);
    }
    id v8 = [v28 objectForKey:@"result"];
    if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      if (![v8 caseInsensitiveCompare:@"Allowed"]
        || ![v8 caseInsensitiveCompare:@"Warning"])
      {
        *(_OWORD *)id v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        *(_OWORD *)id v42 = 0u;
        *(_OWORD *)id v39 = 0u;
        *(_OWORD *)uint64_t v40 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v38 = 0u;
        sub_100A9CFA4((const void **)buf, __p);
        uint64_t v46 = __p;
        *((unsigned char *)sub_100AA102C(a2, __p, (_OWORD **)&v46) + 56) = 1;
        if (v36 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v44) < 0) {
          operator delete(v43[1]);
        }
        if (SHIBYTE(v43[0]) < 0) {
          operator delete(v42[0]);
        }
        if (SHIBYTE(v41) < 0) {
          operator delete(v40[1]);
        }
        if (SHIBYTE(v40[0]) < 0) {
          operator delete(v39[0]);
        }
        if (BYTE8(v38) && SBYTE7(v38) < 0) {
          operator delete(*(void **)buf);
        }
        LOBYTE(v5) = 1;
        goto LABEL_90;
      }
    }
    else
    {
      sub_100A98214();
      id v20 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (result)", buf, 2u);
      }
    }
    LOBYTE(v5) = 0;
LABEL_90:
    int v16 = 1;
LABEL_91:

LABEL_92:
    goto LABEL_93;
  }
  sub_100A98214();
  id v18 = qword_101B0FD28;
  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
  }
  LOBYTE(v5) = 0;
  int v16 = 1;
LABEL_93:
  return v5 & 1 | (v16 == 0);
}

void sub_100A9CE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_1002DE420((uint64_t)&a36);

  _Unwind_Resume(a1);
}

void sub_100A9CFA4(const void **a1@<X0>, void *a2@<X8>)
{
  id v3 = a2;
  if (*((unsigned char *)a1 + 24))
  {
    if (*((char *)a1 + 23) >= 0) {
      size_t v4 = *((unsigned __int8 *)a1 + 23);
    }
    else {
      size_t v4 = (size_t)a1[1];
    }
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    sub_1000C140C((uint64_t)a2, v4 + 1);
    if (*((char *)v3 + 23) < 0) {
      id v3 = (void *)*v3;
    }
    if (v4)
    {
      if (*((char *)a1 + 23) >= 0) {
        BOOL v5 = a1;
      }
      else {
        BOOL v5 = *a1;
      }
      memmove(v3, v5, v4);
    }
    *(_WORD *)((char *)v3 + v4) = 44;
  }
  else
  {
    std::operator+<char>();
    BOOL v6 = std::string::append(&v30, ",", 1uLL);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    int v8 = *((char *)a1 + 79);
    if (v8 >= 0) {
      id v9 = (const std::string::value_type *)(a1 + 7);
    }
    else {
      id v9 = (const std::string::value_type *)a1[7];
    }
    if (v8 >= 0) {
      std::string::size_type v10 = *((unsigned __int8 *)a1 + 79);
    }
    else {
      std::string::size_type v10 = (std::string::size_type)a1[8];
    }
    BOOL v11 = std::string::append(&v31, v9, v10);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    uint64_t v13 = std::string::append(&v32, ",", 1uLL);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    int v15 = *((char *)a1 + 103);
    if (v15 >= 0) {
      int v16 = (const std::string::value_type *)(a1 + 10);
    }
    else {
      int v16 = (const std::string::value_type *)a1[10];
    }
    if (v15 >= 0) {
      std::string::size_type v17 = *((unsigned __int8 *)a1 + 103);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)a1[11];
    }
    id v18 = std::string::append(&v33, v16, v17);
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    id v20 = std::string::append(&v34, ",", 1uLL);
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    BOOL v24 = (const std::string::value_type *)a1[13];
    uint64_t v23 = a1 + 13;
    uint64_t v22 = v24;
    int v25 = *((char *)v23 + 23);
    if (v25 >= 0) {
      long long v26 = (const std::string::value_type *)v23;
    }
    else {
      long long v26 = v22;
    }
    if (v25 >= 0) {
      std::string::size_type v27 = *((unsigned __int8 *)v23 + 23);
    }
    else {
      std::string::size_type v27 = (std::string::size_type)v23[1];
    }
    uint64_t v28 = std::string::append(&v35, v26, v27);
    long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v3[2] = *((void *)&v28->__r_.__value_.__l + 2);
    *(_OWORD *)id v3 = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100A9D1FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v35 - 41) < 0) {
    operator delete(*(void **)(v35 - 64));
  }
  if (*(char *)(v35 - 73) < 0) {
    operator delete(*(void **)(v35 - 96));
  }
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100A9D290(int a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (*a3 == a3[1])
  {
    BOOL v15 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v18 = 0;
    ctu::base64::encode();
    v20[0] = @"requestHandOff";
    v19[0] = @"action";
    v19[1] = @"kSessionId";
    if (*((char *)a2 + 23) >= 0) {
      id v9 = a2;
    }
    else {
      id v9 = (uint64_t *)*a2;
    }
    std::string::size_type v10 = +[NSString stringWithFormat:@"%s", v9];
    CFStringRef v11 = @"lpaSignedRequest";
    v20[1] = v10;
    if (a1) {
      CFStringRef v11 = @"signedIdMapInfo";
    }
    v19[2] = v11;
    long long v12 = __p;
    if (v18 < 0) {
      long long v12 = (void **)__p[0];
    }
    uint64_t v13 = +[NSString stringWithFormat:@"%s", v12];
    v20[2] = v13;
    long long v14 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:3];

    BOOL v15 = sub_100A97B4C((uint64_t)v14, a4);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  return v15;
}

void sub_100A9D42C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A9D474(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1) {
    long long v7 = sub_10008324C;
  }
  else {
    long long v7 = 0;
  }
  if (v7)
  {
    uint64_t v21 = 0;
    int v8 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v9 = 0;
    if (v9) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = v8 == 0;
    }
    if (v10 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      long long v14 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v19) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Top level decoding failure", (uint8_t *)&v19, 2u);
      }
      int v13 = 1;
    }
    else
    {
      CFStringRef v11 = [v8 objectForKey:@"handoffToken"];
      if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        long long v12 = [v8 objectForKey:@"podIdentifier"];
        if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          sub_100058DB0(&v19, (char *)[v11 UTF8String]);
          if (*(char *)(a2 + 23) < 0) {
            operator delete(*(void **)a2);
          }
          *(_OWORD *)a2 = v19;
          *(void *)(a2 + 16) = v20;
          sub_100058DB0(&v19, (char *)[v12 UTF8String]);
          if (*(char *)(a3 + 23) < 0) {
            operator delete(*(void **)a3);
          }
          int v13 = 0;
          *(_OWORD *)a3 = v19;
          *(void *)(a3 + 16) = v20;
        }
        else
        {
          sub_100A98214();
          std::string::size_type v17 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v19) = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (podIdentifier)", (uint8_t *)&v19, 2u);
          }
          int v13 = 1;
        }
      }
      else
      {
        sub_100A98214();
        int v16 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v19) = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (handoffToken)", (uint8_t *)&v19, 2u);
        }
        int v13 = 1;
      }
    }
  }
  else
  {
    sub_100A98214();
    BOOL v15 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No data", (uint8_t *)&v19, 2u);
    }
    int v13 = 1;
  }
  return v13 == 0;
}

void sub_100A9D770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9D7B8(int a1, void *a2, uint64_t **a3, uint64_t a4)
{
  if (*a2 == a2[1])
  {
    sub_100A98214();
    long long v19 = qword_101B0FD28;
    if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
LABEL_16:
      BOOL v18 = 0;
      goto LABEL_17;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v20 = "Empty signed payload";
LABEL_19:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, (uint8_t *)__p, 2u);
    goto LABEL_16;
  }
  if (*a3 == a3[1])
  {
    sub_100A98214();
    long long v19 = qword_101B0FD28;
    if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v20 = "Missing Iccids";
    goto LABEL_19;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v23 = 0;
  ctu::base64::encode();
  id v9 = objc_alloc_init((Class)NSMutableArray);
  BOOL v10 = *a3;
  CFStringRef v11 = a3[1];
  if (*a3 != v11)
  {
    do
    {
      long long v12 = v10;
      if (*((char *)v10 + 23) < 0) {
        long long v12 = (uint64_t *)*v10;
      }
      int v13 = +[NSString stringWithFormat:@"%s", v12];
      [v9 addObject:v13];

      v10 += 3;
    }
    while (v10 != v11);
  }
  CFStringRef v14 = @"lpaSignedRequest";
  if (a1) {
    CFStringRef v14 = @"signedIdMapInfo";
  }
  v24[0] = v14;
  BOOL v15 = __p;
  if (v23 < 0) {
    BOOL v15 = (void **)__p[0];
  }
  int v16 = +[NSString stringWithFormat:@"%s", v15];
  v24[1] = @"iccids";
  v25[0] = v16;
  v25[1] = v9;
  std::string::size_type v17 = +[NSDictionary dictionaryWithObjects:v25 forKeys:v24 count:2];

  BOOL v18 = sub_100A97B4C((uint64_t)v17, a4);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
LABEL_17:
  return v18;
}

void sub_100A9DA14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A9DA6C(void *a1, uint64_t *a2)
{
  if (*a1) {
    size_t v4 = sub_10008324C;
  }
  else {
    size_t v4 = 0;
  }
  if (v4)
  {
    v98 = a2;
    uint64_t v125 = 0;
    v100 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v97 = 0;
    if (v97) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v100 == 0;
    }
    if (v5 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      long long v82 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
      }
      uint64_t v83 = 0;
    }
    else
    {
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      obuint64_t j = v100;
      id v103 = [obj countByEnumeratingWithState:&v121 objects:v140 count:16];
      if (v103)
      {
        uint64_t v109 = 0;
        *(void *)&long long v6 = 67109120;
        long long v88 = v6;
        uint64_t v101 = *(void *)v122;
        for (uint64_t i = *(void *)v122; ; uint64_t i = *(void *)v122)
        {
          if (i != v101) {
            objc_enumerationMutation(obj);
          }
          int v8 = *(void **)(*((void *)&v121 + 1) + 8 * v109);
          id v9 = objc_msgSend(v8, "objectForKey:", @"responseDetails", v88);
          v107 = v9;
          if (v9)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              sub_100A98214();
              BOOL v10 = qword_101B0FD28;
              if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
              {
                id v20 = [v9 UTF8String];
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v20;
                _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Response details: %s", buf, 0xCu);
              }
            }
          }
          v110 = [v8 objectForKey:@"responseCode"];
          id v108 = [v8 objectForKey:@"carrier"];
          id v106 = [v8 objectForKey:@"ICCID"];
          v105 = [v8 objectForKey:@"planStatus"];
          if (!v110 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            sub_100A98214();
            uint64_t v12 = qword_101B0FD28;
            if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR)) {
              goto LABEL_38;
            }
            *(_WORD *)long long buf = 0;
            CFStringRef v14 = v12;
            BOOL v15 = "Missing response code";
            goto LABEL_49;
          }
          unsigned int v11 = [v110 intValue];
          if (v11 != 2500 && v11 != 2404)
          {
            if (v11 != 2000)
            {
              sub_100A98214();
              uint64_t v16 = qword_101B0FD28;
              if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR)) {
                goto LABEL_38;
              }
              unsigned int v17 = [v110 intValue];
              *(_DWORD *)long long buf = v88;
              *(_DWORD *)&uint8_t buf[4] = v17;
              CFStringRef v14 = v16;
              BOOL v15 = "Invalid response code: %d";
              uint32_t v18 = 8;
              goto LABEL_50;
            }
            if (!v105 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              sub_100A98214();
              uint64_t v19 = qword_101B0FD28;
              if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR)) {
                goto LABEL_38;
              }
              *(_WORD *)long long buf = 0;
              CFStringRef v14 = v19;
              BOOL v15 = "Missing plan status";
LABEL_49:
              uint32_t v18 = 2;
LABEL_50:
              _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, buf, v18);
              goto LABEL_38;
            }
          }
          if (!v108
            || (objc_opt_class(), (objc_opt_isKindOfClass() & (v106 != 0)) != 1)
            || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            sub_100A98214();
            uint64_t v13 = qword_101B0FD28;
            if (!os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR)) {
              goto LABEL_38;
            }
            *(_WORD *)long long buf = 0;
            CFStringRef v14 = v13;
            BOOL v15 = "Missing carrier or ICCID ";
            goto LABEL_49;
          }
          uint64_t v134 = 0;
          uint64_t v131 = 2;
          memset(v130, 0, sizeof(v130));
          long long v129 = 0u;
          memset(buf, 0, sizeof(buf));
          uint64_t v133 = 0;
          long long v132 = 0uLL;
          long long v135 = 0u;
          long long v136 = 0u;
          long long v137 = 0u;
          long long v138 = 0u;
          long long v139 = 0u;
          sub_100058DB0(v141, (char *)[v106 UTF8String]);
          if ((char)buf[31] < 0) {
            operator delete(*(void **)&buf[8]);
          }
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v141;
          *(void *)&unsigned char buf[24] = *(void *)&v141[16];
          sub_100058DB0(v141, (char *)[v108 UTF8String]);
          if (SHIBYTE(v130[3]) < 0) {
            operator delete(*(void **)&v130[1]);
          }
          *(_OWORD *)&v130[1] = *(_OWORD *)v141;
          v130[3] = *(CFAbsoluteTime *)&v141[16];
          id v95 = [v8 objectForKey:@"planDescription"];
          if (v95)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              sub_100058DB0(v141, (char *)[v95 UTF8String]);
              if (SHIBYTE(v133) < 0) {
                operator delete((void *)v132);
              }
              long long v132 = *(_OWORD *)v141;
              uint64_t v133 = *(void *)&v141[16];
            }
            else
            {
              sub_100A98214();
              uint64_t v21 = qword_101B0FD28;
              if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
              {
                long long v81 = &buf[8];
                if ((buf[31] & 0x80u) != 0) {
                  long long v81 = *(uint8_t **)&buf[8];
                }
                *(_DWORD *)v141 = 136315138;
                *(void *)&v141[4] = v81;
                _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid object type for plan description: %s", v141, 0xCu);
              }
            }
          }
          if (v105)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              if ([v105 isEqualToString:@"NotSubscribed"])
              {
                int v22 = 4;
LABEL_62:
                LODWORD(v134) = v22;
                goto LABEL_63;
              }
              if ([v105 isEqualToString:@"Subscribed"])
              {
                int v22 = 1;
                goto LABEL_62;
              }
              if ([v105 isEqualToString:@"Depleted"])
              {
                int v22 = 2;
                goto LABEL_62;
              }
              if ([v105 isEqualToString:@"Throttled"])
              {
                int v22 = 3;
                goto LABEL_62;
              }
            }
          }
LABEL_63:
          uint64_t v96 = [v8 objectForKey:@"planType"];
          if (v96)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              if ([v96 isEqualToString:@"PrePaid"])
              {
                char v23 = 0;
              }
              else
              {
                if (![v96 isEqualToString:@"PostPaid"]) {
                  goto LABEL_70;
                }
                char v23 = 1;
              }
              LOBYTE(v131) = v23;
            }
          }
LABEL_70:
          id v94 = [v8 objectForKey:@"accountURL"];
          if (!v94) {
            goto LABEL_73;
          }
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            sub_10003ED78((std::string *)&v135, (char *)[v94 UTF8String]);
LABEL_73:
            uint64_t v89 = [v8 objectForKey:@"autoRenew"];
            if (v89)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                LOBYTE(v129) = [v89 intValue] != 0;
              }
            }
            v90 = [v8 objectForKey:@"billingStartDate"];
            if (v90)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0 && !sub_100A9A91C(v90, (CFAbsoluteTime *)&v129 + 1))
              {
                sub_100A98214();
                BOOL v24 = qword_101B0FD28;
                if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v141 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Failed to decode time (billingStartDate)", v141, 2u);
                }
              }
            }
            long long v91 = [v8 objectForKey:@"billingEndDate"];
            if (v91)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0 && !sub_100A9A91C(v91, v130))
              {
                sub_100A98214();
                int v25 = qword_101B0FD28;
                if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v141 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to decode time (billingEndDate)", v141, 2u);
                }
              }
            }
            long long v92 = [v8 objectForKey:@"timestamp"];
            if (v92)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0 && !sub_100A9A91C(v92, (CFAbsoluteTime *)&v136 + 1))
              {
                sub_100A98214();
                long long v26 = qword_101B0FD28;
                if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v141 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to decode time (TimeStamp)", v141, 2u);
                }
              }
            }
            long long v93 = [v8 objectForKey:@"dataUsage"];
            if (v93)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                long long v120 = 0u;
                long long v118 = 0u;
                long long v119 = 0u;
                long long v117 = 0u;
                id v104 = v93;
                id v27 = [v104 countByEnumeratingWithState:&v117 objects:v127 count:16];
                if (!v27) {
                  goto LABEL_131;
                }
                uint64_t v28 = *(void *)v118;
                while (1)
                {
                  long long v29 = 0;
                  do
                  {
                    if (*(void *)v118 != v28) {
                      objc_enumerationMutation(v104);
                    }
                    std::string v30 = *(void **)(*((void *)&v117 + 1) + 8 * (void)v29);
                    if (v30)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass())
                      {
                        std::string v31 = [v30 objectForKey:@"dataUsed"];
                        std::string v32 = [v30 objectForKey:@"dataCapacity"];
                        std::string v33 = [v30 objectForKey:@"dataCategory"];
                        if (v31
                          && (objc_opt_class(), (objc_opt_isKindOfClass() & (v32 != 0)) == 1)
                          && (objc_opt_class(), (objc_opt_isKindOfClass() & (v33 != 0)) == 1)
                          && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                        {
                          std::string v34 = (_OWORD *)v139;
                          if ((unint64_t)v139 >= *((void *)&v139 + 1))
                          {
                            unint64_t v41 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v139 - *((void *)&v138 + 1)) >> 3);
                            unint64_t v42 = v41 + 1;
                            if (v41 + 1 > 0x666666666666666) {
                              sub_10006A748();
                            }
                            if (0x999999999999999ALL
                               * ((uint64_t)(*((void *)&v139 + 1) - *((void *)&v138 + 1)) >> 3) > v42)
                              unint64_t v42 = 0x999999999999999ALL
                                  * ((uint64_t)(*((void *)&v139 + 1) - *((void *)&v138 + 1)) >> 3);
                            if (0xCCCCCCCCCCCCCCCDLL
                               * ((uint64_t)(*((void *)&v139 + 1) - *((void *)&v138 + 1)) >> 3) >= 0x333333333333333)
                              unint64_t v43 = 0x666666666666666;
                            else {
                              unint64_t v43 = v42;
                            }
                            v143 = (char *)&v139 + 8;
                            if (v43) {
                              long long v44 = (char *)sub_10005ED10((uint64_t)&v139 + 8, v43);
                            }
                            else {
                              long long v44 = 0;
                            }
                            uint64_t v45 = &v44[40 * v41];
                            *(void *)v141 = v44;
                            *(void *)&v141[8] = v45;
                            v142 = &v44[40 * v43];
                            *((void *)v45 + 4) = 0;
                            *(_OWORD *)uint64_t v45 = 0u;
                            *((_OWORD *)v45 + 1) = 0u;
                            *(void *)&v141[16] = v45 + 40;
                            sub_100AA0BF4((uint64_t *)&v138 + 1, v141);
                            uint64_t v35 = (char *)v139;
                            sub_100AA0D94((uint64_t)v141);
                          }
                          else
                          {
                            *(void *)(v139 + 32) = 0;
                            uint64_t v35 = (char *)v34 + 40;
                            *std::string v34 = 0u;
                            v34[1] = 0u;
                          }
                          *(void *)&long long v139 = v35;
                          [v32 doubleValue];
                          *((void *)v35 - 4) = v46;
                          [v31 doubleValue];
                          *((void *)v35 - 5) = v47;
                          sub_100058DB0(v141, (char *)[v33 UTF8String]);
                          uint64_t v48 = (void **)(v35 - 24);
                          if (*(v35 - 1) < 0) {
                            operator delete(*v48);
                          }
                          long long v49 = *(_OWORD *)v141;
                          *((void *)v35 - 1) = *(void *)&v141[16];
                          *(_OWORD *)uint64_t v48 = v49;
                          sub_100A98214();
                          uint64_t v50 = qword_101B0FD28;
                          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                          {
                            if (*(v35 - 1) < 0) {
                              uint64_t v48 = (void **)*v48;
                            }
                            uint64_t v51 = *((void *)v35 - 5);
                            unsigned int v52 = (char *)*((void *)v35 - 4);
                            *(_DWORD *)v141 = 136315650;
                            *(void *)&v141[4] = v48;
                            *(_WORD *)&v141[12] = 2048;
                            *(void *)&v141[14] = v51;
                            *(_WORD *)&v141[22] = 2048;
                            v142 = v52;
                            long long v38 = v50;
                            id v39 = "Data Usage - %s %f/%f";
                            uint32_t v40 = 32;
LABEL_113:
                            _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v39, v141, v40);
                          }
                        }
                        else
                        {
                          sub_100A98214();
                          uint64_t v37 = qword_101B0FD28;
                          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)v141 = 0;
                            long long v38 = v37;
                            id v39 = "Data usage incorrect";
                            uint32_t v40 = 2;
                            goto LABEL_113;
                          }
                        }

                        id v9 = v107;
                        goto LABEL_110;
                      }
                    }
                    sub_100A98214();
                    char v36 = qword_101B0FD28;
                    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)v141 = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Data usage dictionary not found", v141, 2u);
                    }
LABEL_110:
                    long long v29 = (char *)v29 + 1;
                  }
                  while (v27 != v29);
                  id v53 = [v104 countByEnumeratingWithState:&v117 objects:v127 count:16];
                  id v27 = v53;
                  if (!v53)
                  {
LABEL_131:

                    break;
                  }
                }
              }
            }
            long long v54 = [v8 objectForKey:@"homeCountryIso"];
            if (v54)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                long long v115 = 0u;
                long long v116 = 0u;
                long long v113 = 0u;
                long long v114 = 0u;
                id v55 = v54;
                id v56 = [v55 countByEnumeratingWithState:&v113 objects:v126 count:16];
                if (v56)
                {
                  uint64_t v57 = *(void *)v114;
                  do
                  {
                    for (uint64_t j = 0; j != v56; uint64_t j = (char *)j + 1)
                    {
                      if (*(void *)v114 != v57) {
                        objc_enumerationMutation(v55);
                      }
                      id v59 = *(void **)(*((void *)&v113 + 1) + 8 * (void)j);
                      if (v59)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass())
                        {
                          sub_100058DB0(&v111, (char *)[v59 UTF8String]);
                          id v60 = (_OWORD *)*((void *)&v137 + 1);
                          if (*((void *)&v137 + 1) >= (unint64_t)v138)
                          {
                            unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v137 + 1) - v137) >> 3);
                            unint64_t v63 = v62 + 1;
                            if (v62 + 1 > 0xAAAAAAAAAAAAAAALL) {
                              sub_1000D8578();
                            }
                            if (0x5555555555555556 * ((uint64_t)(v138 - v137) >> 3) > v63) {
                              unint64_t v63 = 0x5555555555555556 * ((uint64_t)(v138 - v137) >> 3);
                            }
                            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v138 - v137) >> 3) >= 0x555555555555555) {
                              unint64_t v64 = 0xAAAAAAAAAAAAAAALL;
                            }
                            else {
                              unint64_t v64 = v63;
                            }
                            v143 = (char *)&v138;
                            if (v64) {
                              long long v65 = (char *)sub_10004812C((uint64_t)&v138, v64);
                            }
                            else {
                              long long v65 = 0;
                            }
                            id v66 = &v65[24 * v62];
                            *(void *)v141 = v65;
                            *(void *)&v141[8] = v66;
                            v142 = &v65[24 * v64];
                            long long v67 = v111;
                            *((void *)v66 + 2) = v112;
                            *(_OWORD *)id v66 = v67;
                            uint64_t v112 = 0;
                            long long v111 = 0uLL;
                            *(void *)&v141[16] = v66 + 24;
                            sub_100048204((uint64_t *)&v137, v141);
                            uint64_t v68 = *((void *)&v137 + 1);
                            sub_100048174((uint64_t)v141);
                            *((void *)&v137 + 1) = v68;
                            if (SHIBYTE(v112) < 0) {
                              operator delete((void *)v111);
                            }
                          }
                          else
                          {
                            long long v61 = v111;
                            *(void *)(*((void *)&v137 + 1) + 16) = v112;
                            *id v60 = v61;
                            *((void *)&v137 + 1) = (char *)v60 + 24;
                          }
                        }
                      }
                    }
                    id v56 = [v55 countByEnumeratingWithState:&v113 objects:v126 count:16];
                  }
                  while (v56);
                }
              }
            }
            unint64_t v70 = v98[1];
            unint64_t v69 = v98[2];
            if (v70 >= v69)
            {
              unint64_t v73 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v70 - *v98) >> 3);
              unint64_t v74 = v73 + 1;
              if (v73 + 1 > 0x147AE147AE147AELL) {
                sub_10006A748();
              }
              unint64_t v75 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v69 - *v98) >> 3);
              if (2 * v75 > v74) {
                unint64_t v74 = 2 * v75;
              }
              if (v75 >= 0xA3D70A3D70A3D7) {
                unint64_t v76 = 0x147AE147AE147AELL;
              }
              else {
                unint64_t v76 = v74;
              }
              v143 = (char *)(v98 + 2);
              if (v76) {
                long long v77 = (char *)sub_10030FA44((uint64_t)(v98 + 2), v76);
              }
              else {
                long long v77 = 0;
              }
              *(void *)v141 = v77;
              *(void *)&v141[8] = &v77[200 * v73];
              *(void *)&v141[16] = *(void *)&v141[8];
              v142 = &v77[200 * v76];
              sub_10030FB14(*(uint64_t *)&v141[8], (uint64_t)buf);
              id v72 = v98;
              *(void *)&v141[16] += 200;
              sub_100AA0E24(v98, v141);
              uint64_t v71 = v98[1];
              sub_100AA0F8C((uint64_t)v141);
            }
            else
            {
              sub_10030FB14(v98[1], (uint64_t)buf);
              uint64_t v71 = v70 + 200;
              id v72 = v98;
              v98[1] = v71;
            }
            v72[1] = v71;

            long long v79 = v94;
            goto LABEL_174;
          }
          sub_100A98214();
          long long v78 = qword_101B0FD28;
          long long v79 = v94;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
          {
            long long v80 = &buf[8];
            if ((buf[31] & 0x80u) != 0) {
              long long v80 = *(uint8_t **)&buf[8];
            }
            *(_DWORD *)v141 = 136315138;
            *(void *)&v141[4] = v80;
            _os_log_error_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "Invalid object type for account URL, skipping for ICCID: %s", v141, 0xCu);
          }
LABEL_174:

          *(void *)v141 = (char *)&v138 + 8;
          sub_10030FEEC((void ***)v141);
          *(void *)v141 = &v137;
          sub_100047F64((void ***)v141);
          if (SBYTE7(v136) < 0) {
            operator delete((void *)v135);
          }
          if (SHIBYTE(v133) < 0) {
            operator delete((void *)v132);
          }
          if (SHIBYTE(v130[3]) < 0) {
            operator delete(*(void **)&v130[1]);
          }
          if ((char)buf[31] < 0) {
            operator delete(*(void **)&buf[8]);
          }
LABEL_38:

          if (++v109 >= (unint64_t)v103)
          {
            id v103 = [obj countByEnumeratingWithState:&v121 objects:v140 count:16];
            if (!v103) {
              break;
            }
            uint64_t v109 = 0;
          }
        }
      }

      sub_100A98214();
      long long v85 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v86 = 0x8F5C28F5C28F5C29 * ((v98[1] - *v98) >> 3);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v86;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I Decoded %lu subscription details", buf, 0xCu);
      }
      uint64_t v83 = 1;
    }
  }
  else
  {
    sub_100A98214();
    long long v84 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    uint64_t v83 = 0;
  }
  return v83;
}

void sub_100A9EDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,void *a30,void *a31,void *a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,void *a45,void *a46,void *a47,uint64_t a48,void *a49)
{
  sub_100A9F044((uint64_t)&STACK[0x330]);
  _Unwind_Resume(a1);
}

uint64_t sub_100A9F044(uint64_t a1)
{
  id v3 = (void **)(a1 + 176);
  sub_10030FEEC(&v3);
  id v3 = (void **)(a1 + 152);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

BOOL sub_100A9F0D0(void *a1, uint64_t a2)
{
  if (*a1 == a1[1])
  {
    BOOL v7 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v10 = 0;
    ctu::base64::encode();
    CFStringRef v11 = @"lpaSignedRequest";
    BOOL v5 = +[NSString stringWithFormat:@"%s", __p];
    uint64_t v12 = v5;
    long long v6 = +[NSDictionary dictionaryWithObjects:&v12 forKeys:&v11 count:1];

    BOOL v7 = sub_100A97B4C((uint64_t)v6, a2);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
  return v7;
}

void sub_100A9F1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A9F234(void *a1, std::string *a2, std::string *a3)
{
  if (*a1) {
    BOOL v7 = sub_10008324C;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    int v8 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v9 = 0;
    if (v9) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = v8 == 0;
    }
    if (v10 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      CFStringRef v14 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
      }
      uint64_t v13 = 0;
    }
    else
    {
      CFStringRef v11 = [v8 objectForKey:@"sessionId"];
      if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        uint64_t v12 = [v8 objectForKey:@"token"];
        if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          sub_10003ED78(a2, (char *)[v11 UTF8String]);
          sub_10003ED78(a3, (char *)[v12 UTF8String]);
          uint64_t v13 = 1;
        }
        else
        {
          sub_100A98214();
          unsigned int v17 = qword_101B0FD28;
          uint64_t v13 = 0;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (pushToken)", buf, 2u);
            uint64_t v13 = 0;
          }
        }
      }
      else
      {
        sub_100A98214();
        uint64_t v16 = qword_101B0FD28;
        uint64_t v13 = 0;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (session)", buf, 2u);
          uint64_t v13 = 0;
        }
      }
    }
  }
  else
  {
    sub_100A98214();
    BOOL v15 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    uint64_t v13 = 0;
  }
  return v13;
}

void sub_100A9F4F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A9F534(uint64_t **a1@<X0>, void *a2@<X8>)
{
  if (a1[1] == *a1)
  {
    *a2 = 0;
  }
  else
  {
    uint64_t v16 = v4;
    BOOL v5 = objc_opt_new();
    long long v6 = *a1;
    BOOL v7 = a1[1];
    if (*a1 != v7)
    {
      do
      {
        if (!*((unsigned char *)v6 + 120))
        {
          if ((*((char *)v6 + 23) & 0x80000000) == 0)
          {
            int v8 = v6;
            if (!*((unsigned char *)v6 + 23)) {
              goto LABEL_24;
            }
LABEL_9:
            id v9 = +[NSString stringWithUTF8String:v8];
            BOOL v10 = v6 + 3;
            if (*((char *)v6 + 47) < 0)
            {
              if (!v6[4]) {
                goto LABEL_15;
              }
              BOOL v10 = (void *)*v10;
            }
            else if (!*((unsigned char *)v6 + 47))
            {
LABEL_15:
              CFStringRef v11 = 0;
LABEL_16:
              uint64_t v12 = v6 + 6;
              if (*((char *)v6 + 71) < 0)
              {
                if (!v6[7]) {
                  goto LABEL_22;
                }
                uint64_t v12 = (void *)*v12;
              }
              else if (!*((unsigned char *)v6 + 71))
              {
LABEL_22:
                uint64_t v13 = 0;
                goto LABEL_23;
              }
              uint64_t v13 = +[NSString stringWithUTF8String:v12];
LABEL_23:
              id v14 = [objc_alloc((Class)CTPendingPlan) initWithSmdpURL:v9 matchingID:v11];
              id v15 = [objc_alloc((Class)CTDisplayPlan) initWithPlan:v14 status:1 attributes:0 isPhysical:0 carrierName:v13 phoneNumber:0 label:0];
              [v5 addObject:v15];

              goto LABEL_24;
            }
            CFStringRef v11 = +[NSString stringWithUTF8String:v10];
            goto LABEL_16;
          }
          if (v6[1])
          {
            int v8 = (uint64_t *)*v6;
            goto LABEL_9;
          }
        }
LABEL_24:
        v6 += 39;
      }
      while (v6 != v7);
    }
    sub_100044D34(a2, v5);

    size_t v4 = v16;
  }
}

void sub_100A9F700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100A9F74C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *((unsigned __int8 *)a1 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = a1[1];
  }
  if (!v8 || *a2 == a2[1])
  {
    BOOL v15 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v18 = 0;
    ctu::base64::encode();
    v19[0] = @"sessionId";
    if (*((char *)a1 + 23) >= 0) {
      id v9 = a1;
    }
    else {
      id v9 = (uint64_t *)*a1;
    }
    BOOL v10 = +[NSString stringWithFormat:@"%s", v9];
    v20[0] = v10;
    v19[1] = @"lpaSignedRequest";
    CFStringRef v11 = __p;
    if (v18 < 0) {
      CFStringRef v11 = (void **)__p[0];
    }
    uint64_t v12 = +[NSString stringWithFormat:@"%s", v11];
    v20[1] = v12;
    v19[2] = @"action";
    uint64_t v13 = +[NSString stringWithFormat:@"%s", encodeCarrierSetupAction()];
    v20[2] = v13;
    id v14 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:3];

    BOOL v15 = sub_100A97B4C((uint64_t)v14, a4);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  return v15;
}

void sub_100A9F918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A9F96C(void *a1, uint64_t a2, char **a3)
{
  if (*a1) {
    BOOL v7 = sub_10008324C;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    uint64_t v72 = 0;
    uint64_t v8 = +[NSJSONSerialization JSONObjectWithData:options:error:](NSJSONSerialization, "JSONObjectWithData:options:error:");
    id v67 = 0;
    if (v67) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = v8 == 0;
    }
    if (v9 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      sub_100A98214();
      long long v49 = qword_101B0FD28;
      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Top level decoding failure", buf, 2u);
      }
      uint64_t v50 = 0;
    }
    else
    {
      id v64 = [v8 objectForKey:@"sessionId"];
      if (v64 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        sub_100058DB0(buf, (char *)[v64 UTF8String]);
        if (*(char *)(a2 + 23) < 0) {
          operator delete(*(void **)a2);
        }
        *(_OWORD *)a2 = *(_OWORD *)buf;
        *(void *)(a2 + 16) = *(void *)&buf[16];
        sub_100A98214();
        BOOL v10 = qword_101B0FD28;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            CFStringRef v11 = (void *)a2;
          }
          else {
            CFStringRef v11 = *(void **)a2;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I sessionId [%s]", buf, 0xCu);
        }
        uint64_t v58 = [v8 objectForKey:@"setupOptions"];
        if (v58)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            long long v70 = 0u;
            long long v71 = 0u;
            long long v68 = 0u;
            long long v69 = 0u;
            obuint64_t j = v58;
            id v12 = [obj countByEnumeratingWithState:&v68 objects:v76 count:16];
            if (v12)
            {
              uint64_t v14 = 0;
              *(void *)&long long v13 = 136315906;
              long long v55 = v13;
              uint64_t v65 = *(void *)v69;
              for (uint64_t i = *(void *)v69; ; uint64_t i = *(void *)v69)
              {
                if (i != v65) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v16 = *(void **)(*((void *)&v68 + 1) + 8 * v14);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  unsigned int v17 = [v16 objectForKey:@"setupUrl"];
                  if (v17 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    uint64_t v18 = (std::string *)a3[1];
                    unint64_t v19 = (unint64_t)a3[2];
                    if ((unint64_t)v18 >= v19)
                    {
                      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)v18 - *a3) >> 6);
                      unint64_t v24 = v23 + 1;
                      if (v23 + 1 > 0x155555555555555) {
                        sub_10006A748();
                      }
                      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)*a3) >> 6);
                      if (2 * v25 > v24) {
                        unint64_t v24 = 2 * v25;
                      }
                      if (v25 >= 0xAAAAAAAAAAAAAALL) {
                        unint64_t v26 = 0x155555555555555;
                      }
                      else {
                        unint64_t v26 = v24;
                      }
                      v75[0] = a3 + 2;
                      if (v26) {
                        id v27 = (char *)sub_10034036C((uint64_t)(a3 + 2), v26);
                      }
                      else {
                        id v27 = 0;
                      }
                      uint64_t v28 = &v27[192 * v23];
                      *(void *)long long buf = v27;
                      *(void *)&uint8_t buf[8] = v28;
                      long long v29 = &v27[192 * v26];
                      unint64_t v74 = v29;
                      *(_OWORD *)uint64_t v28 = 0u;
                      *((_OWORD *)v28 + 1) = 0u;
                      *((_OWORD *)v28 + 2) = 0u;
                      *((_OWORD *)v28 + 3) = 0u;
                      *((_OWORD *)v28 + 4) = 0u;
                      *((_OWORD *)v28 + 5) = 0u;
                      *((_OWORD *)v28 + 6) = 0u;
                      *((_OWORD *)v28 + 7) = 0u;
                      *((_OWORD *)v28 + 8) = 0u;
                      *((_OWORD *)v28 + 9) = 0u;
                      *((_OWORD *)v28 + 10) = 0u;
                      *((_OWORD *)v28 + 11) = 0u;
                      id v20 = (std::string *)(v28 + 192);
                      *(void *)&uint8_t buf[16] = v28 + 192;
                      std::string v31 = *a3;
                      unint64_t v30 = (unint64_t)a3[1];
                      if ((char *)v30 == *a3)
                      {
                        int64x2_t v40 = vdupq_n_s64(v30);
                      }
                      else
                      {
                        do
                        {
                          long long v32 = *(_OWORD *)(v30 - 192);
                          *((void *)v28 - 22) = *(void *)(v30 - 176);
                          *((_OWORD *)v28 - 12) = v32;
                          *(void *)(v30 - 184) = 0;
                          *(void *)(v30 - 176) = 0;
                          *(void *)(v30 - 192) = 0;
                          long long v33 = *(_OWORD *)(v30 - 168);
                          *((void *)v28 - 19) = *(void *)(v30 - 152);
                          *(_OWORD *)(v28 - 168) = v33;
                          *(void *)(v30 - 160) = 0;
                          *(void *)(v30 - 152) = 0;
                          *(void *)(v30 - 168) = 0;
                          long long v34 = *(_OWORD *)(v30 - 144);
                          *((void *)v28 - 16) = *(void *)(v30 - 128);
                          *((_OWORD *)v28 - 9) = v34;
                          *(void *)(v30 - 136) = 0;
                          *(void *)(v30 - 128) = 0;
                          *(void *)(v30 - 144) = 0;
                          long long v35 = *(_OWORD *)(v30 - 120);
                          *((void *)v28 - 13) = *(void *)(v30 - 104);
                          *(_OWORD *)(v28 - 120) = v35;
                          *(void *)(v30 - 120) = 0;
                          *(void *)(v30 - 112) = 0;
                          *(void *)(v30 - 104) = 0;
                          long long v36 = *(_OWORD *)(v30 - 96);
                          *((void *)v28 - 10) = *(void *)(v30 - 80);
                          *((_OWORD *)v28 - 6) = v36;
                          *(void *)(v30 - 96) = 0;
                          *(void *)(v30 - 88) = 0;
                          *(void *)(v30 - 80) = 0;
                          long long v37 = *(_OWORD *)(v30 - 72);
                          *((void *)v28 - 7) = *(void *)(v30 - 56);
                          *(_OWORD *)(v28 - 72) = v37;
                          *(void *)(v30 - 72) = 0;
                          *(void *)(v30 - 64) = 0;
                          *(void *)(v30 - 56) = 0;
                          long long v38 = *(_OWORD *)(v30 - 48);
                          *((void *)v28 - 4) = *(void *)(v30 - 32);
                          *((_OWORD *)v28 - 3) = v38;
                          *(void *)(v30 - 48) = 0;
                          *(void *)(v30 - 40) = 0;
                          *(void *)(v30 - 32) = 0;
                          long long v39 = *(_OWORD *)(v30 - 24);
                          *((void *)v28 - 1) = *(void *)(v30 - 8);
                          *(_OWORD *)(v28 - 24) = v39;
                          v28 -= 192;
                          *(void *)(v30 - 24) = 0;
                          *(void *)(v30 - 16) = 0;
                          *(void *)(v30 - 8) = 0;
                          v30 -= 192;
                        }
                        while ((char *)v30 != v31);
                        int64x2_t v40 = *(int64x2_t *)a3;
                        id v20 = *(std::string **)&buf[16];
                        long long v29 = v74;
                      }
                      *a3 = v28;
                      a3[1] = (char *)v20;
                      *(int64x2_t *)&uint8_t buf[8] = v40;
                      unint64_t v41 = a3[2];
                      a3[2] = v29;
                      unint64_t v74 = v41;
                      *(void *)long long buf = v40.i64[0];
                      sub_100AA0FDC((uint64_t)buf);
                    }
                    else
                    {
                      *(_OWORD *)&v18[6].__r_.__value_.__r.__words[2] = 0u;
                      *(_OWORD *)&v18[7].__r_.__value_.__r.__words[1] = 0u;
                      *(_OWORD *)&v18[5].__r_.__value_.__r.__words[1] = 0u;
                      *(_OWORD *)&v18[6].__r_.__value_.__l.__data_ = 0u;
                      *(_OWORD *)&v18[4].__r_.__value_.__l.__data_ = 0u;
                      *(_OWORD *)&v18[4].__r_.__value_.__r.__words[2] = 0u;
                      *(_OWORD *)&v18[2].__r_.__value_.__r.__words[2] = 0u;
                      *(_OWORD *)&v18[3].__r_.__value_.__r.__words[1] = 0u;
                      *(_OWORD *)&v18[1].__r_.__value_.__r.__words[1] = 0u;
                      *(_OWORD *)&v18[2].__r_.__value_.__l.__data_ = 0u;
                      *(_OWORD *)&v18->__r_.__value_.__l.__data_ = 0u;
                      *(_OWORD *)&v18->__r_.__value_.__r.__words[2] = 0u;
                      id v20 = v18 + 8;
                      a3[1] = (char *)&v18[8];
                    }
                    a3[1] = (char *)v20;
                    sub_10003ED78(v20 - 3, (char *)[v17 UTF8String]);
                    [v16 objectForKey:@"carrier"];
                    id v59 = v20 - 8;
                    id v63 = (id)objc_claimAutoreleasedReturnValue();
                    if (v63)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v59, (char *)[v63 UTF8String]);
                      }
                    }
                    objc_msgSend(v16, "objectForKey:", @"imsiPrefix", v55);
                    id v62 = (id)objc_claimAutoreleasedReturnValue();
                    if (v62)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v20 - 7, (char *)[v62 UTF8String]);
                      }
                    }
                    id v61 = [v16 objectForKey:@"gid1"];
                    if (v61)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v20 - 6, (char *)[v61 UTF8String]);
                      }
                    }
                    id v60 = [v16 objectForKey:@"gid2"];
                    if (v60)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v20 - 5, (char *)[v60 UTF8String]);
                      }
                    }
                    unint64_t v42 = [v16 objectForKey:@"setupType"];
                    if (v42)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v20 - 4, (char *)[v42 UTF8String]);
                      }
                    }
                    unint64_t v43 = [v16 objectForKey:@"handoffToken"];
                    if (v43)
                    {
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        sub_10003ED78(v20 - 2, (char *)[v43 UTF8String]);
                      }
                    }
                    long long v44 = [v16 objectForKey:@"esimInstallDetails"];
                    if (v44 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                    {
                      id v57 = [v44 objectForKey:@"phoneNumber"];
                      if (v57)
                      {
                        objc_opt_class();
                        if (objc_opt_isKindOfClass()) {
                          sub_10003ED78(v20 - 1, (char *)[v57 UTF8String]);
                        }
                      }
                      sub_100A98214();
                      log = qword_101B0FD28;
                      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                      {
                        if (SHIBYTE(v20[-8].__r_.__value_.__r.__words[2]) < 0) {
                          id v59 = (std::string *)v59->__r_.__value_.__r.__words[0];
                        }
                        data = v20 - 3;
                        uint64_t v46 = (std::string::__raw *)&v20[-4];
                        if (SHIBYTE(v20[-4].__r_.__value_.__r.__words[2]) < 0) {
                          uint64_t v46 = (std::string::__raw *)v46->__words[0];
                        }
                        if (SHIBYTE(v20[-3].__r_.__value_.__r.__words[2]) < 0) {
                          data = (std::string *)v20[-3].__r_.__value_.__l.__data_;
                        }
                        uint64_t v47 = (std::string::__raw *)&v20[-1];
                        if (SHIBYTE(v20[-1].__r_.__value_.__r.__words[2]) < 0) {
                          uint64_t v47 = (std::string::__raw *)v47->__words[0];
                        }
                        *(_DWORD *)long long buf = v55;
                        *(void *)&uint8_t buf[4] = v59;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v46;
                        *(_WORD *)&unsigned char buf[22] = 2080;
                        unint64_t v74 = (char *)data;
                        LOWORD(v75[0]) = 2080;
                        *(void *)((char *)v75 + 2) = v47;
                        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I fCarrierName [%s] fSetupType [%s] fSetupURL [%s] fPhoneNumber [%s]", buf, 0x2Au);
                      }
                    }
                    else
                    {
                      sub_100A98214();
                      uint64_t v48 = qword_101B0FD28;
                      if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (esimInstallDetailObj element)", buf, 2u);
                      }
                    }
                  }
                  else
                  {
                    sub_100A98214();
                    int v22 = qword_101B0FD28;
                    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (setupUrl)", buf, 2u);
                    }
                  }
                }
                else
                {
                  sub_100A98214();
                  uint64_t v21 = qword_101B0FD28;
                  if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Element not found or invalid type (setupOption element)", buf, 2u);
                  }
                }
                if (++v14 >= (unint64_t)v12)
                {
                  id v12 = [obj countByEnumeratingWithState:&v68 objects:v76 count:16];
                  if (!v12) {
                    break;
                  }
                  uint64_t v14 = 0;
                }
              }
            }
          }
        }

        uint64_t v50 = 1;
        id v53 = v64;
      }
      else
      {
        sub_100A98214();
        unsigned int v52 = qword_101B0FD28;
        id v53 = v64;
        if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Element not found or invalid type (sessionId)", buf, 2u);
        }
        uint64_t v50 = 0;
      }
    }
  }
  else
  {
    sub_100A98214();
    uint64_t v51 = qword_101B0FD28;
    if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "No data", buf, 2u);
    }
    uint64_t v50 = 0;
  }
  return v50;
}

void sub_100AA03D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void sub_100AA0500(const std::string **a1@<X0>, char a2@<W1>, void *a3@<X8>)
{
  if (a1[1] == *a1)
  {
    *a3 = 0;
  }
  else
  {
    long long v29 = a3;
    uint64_t v5 = objc_opt_new();
    long long v6 = *a1;
    CFTypeRef cf = (void *)v5;
    long long v33 = (uint64_t *)a1[1];
    if (*a1 != (const std::string *)v33)
    {
      do
      {
        uint64_t v7 = HIBYTE(v6[1].__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v6[1].__r_.__value_.__r.__words[2]) < 0) {
          unint64_t size = v6[1].__r_.__value_.__l.__size_;
        }
        else {
          unint64_t size = HIBYTE(v6[1].__r_.__value_.__r.__words[2]);
        }
        BOOL v9 = (std::string::__raw *)&v6[1];
        if (size <= 3)
        {
          sub_100A98214();
          BOOL v10 = qword_101B0FD28;
          if (os_log_type_enabled((os_log_t)qword_101B0FD28, OS_LOG_TYPE_ERROR))
          {
            if (SHIBYTE(v6[1].__r_.__value_.__r.__words[2]) < 0) {
              BOOL v9 = (std::string::__raw *)v9->__words[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid imsiPrefix [%s]", (uint8_t *)&buf, 0xCu);
          }
          goto LABEL_72;
        }
        if (SHIBYTE(v6->__r_.__value_.__r.__words[2]) < 0)
        {
          if (v6->__r_.__value_.__l.__size_)
          {
            CFStringRef v11 = (uint64_t *)v6->__r_.__value_.__r.__words[0];
LABEL_16:
            long long v34 = +[NSString stringWithUTF8String:v11];
            uint64_t v7 = HIBYTE(v6[1].__r_.__value_.__r.__words[2]);
            goto LABEL_18;
          }
        }
        else
        {
          CFStringRef v11 = (uint64_t *)v6;
          if (*((unsigned char *)&v6->__r_.__value_.__s + 23)) {
            goto LABEL_16;
          }
        }
        long long v34 = 0;
LABEL_18:
        if ((v7 & 0x80) != 0)
        {
          if (!v6[1].__r_.__value_.__l.__size_)
          {
LABEL_33:
            long long v13 = 0;
            if ((v7 & 0x80) == 0) {
              goto LABEL_26;
            }
            goto LABEL_34;
          }
        }
        else if (!v7)
        {
          goto LABEL_33;
        }
        std::string::basic_string(&buf, v6 + 1, 0, 3uLL, (std::allocator<char> *)&v35);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        long long v13 = +[NSString stringWithUTF8String:p_buf];
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        uint64_t v7 = HIBYTE(v6[1].__r_.__value_.__r.__words[2]);
        if ((v7 & 0x80) == 0)
        {
LABEL_26:
          if (!v7) {
            goto LABEL_35;
          }
          goto LABEL_27;
        }
LABEL_34:
        if (!v6[1].__r_.__value_.__l.__size_)
        {
LABEL_35:
          BOOL v15 = 0;
          goto LABEL_36;
        }
LABEL_27:
        std::string::basic_string(&buf, v6 + 1, 3uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v35);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v14 = &buf;
        }
        else {
          uint64_t v14 = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        BOOL v15 = +[NSString stringWithUTF8String:v14];
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
LABEL_36:
        uint64_t v16 = (std::string::__raw *)&v6[2];
        if (SHIBYTE(v6[2].__r_.__value_.__r.__words[2]) < 0)
        {
          if (v6[2].__r_.__value_.__l.__size_)
          {
            uint64_t v16 = (std::string::__raw *)v16->__words[0];
LABEL_41:
            unsigned int v17 = +[NSString stringWithUTF8String:v16];
            goto LABEL_43;
          }
        }
        else if (*((unsigned char *)&v6[2].__r_.__value_.__s + 23))
        {
          goto LABEL_41;
        }
        unsigned int v17 = 0;
LABEL_43:
        uint64_t v18 = (std::string::__raw *)&v6[3];
        if (SHIBYTE(v6[3].__r_.__value_.__r.__words[2]) < 0)
        {
          if (v6[3].__r_.__value_.__l.__size_)
          {
            uint64_t v18 = (std::string::__raw *)v18->__words[0];
LABEL_48:
            unint64_t v19 = +[NSString stringWithUTF8String:v18];
            goto LABEL_50;
          }
        }
        else if (*((unsigned char *)&v6[3].__r_.__value_.__s + 23))
        {
          goto LABEL_48;
        }
        unint64_t v19 = 0;
LABEL_50:
        id v20 = (std::string::__raw *)&v6[5];
        if (SHIBYTE(v6[5].__r_.__value_.__r.__words[2]) < 0)
        {
          if (v6[5].__r_.__value_.__l.__size_)
          {
            id v20 = (std::string::__raw *)v20->__words[0];
LABEL_55:
            uint64_t v21 = +[NSString stringWithUTF8String:v20];
            goto LABEL_57;
          }
        }
        else if (*((unsigned char *)&v6[5].__r_.__value_.__s + 23))
        {
          goto LABEL_55;
        }
        uint64_t v21 = 0;
LABEL_57:
        int v22 = (std::string::__raw *)&v6[6];
        if (SHIBYTE(v6[6].__r_.__value_.__r.__words[2]) < 0)
        {
          if (v6[6].__r_.__value_.__l.__size_)
          {
            int v22 = (std::string::__raw *)v22->__words[0];
LABEL_62:
            unint64_t v23 = +[NSString stringWithUTF8String:v22];
            goto LABEL_64;
          }
        }
        else if (*((unsigned char *)&v6[6].__r_.__value_.__s + 23))
        {
          goto LABEL_62;
        }
        unint64_t v23 = 0;
LABEL_64:
        unint64_t v24 = (std::string::__raw *)&v6[7];
        if (SHIBYTE(v6[7].__r_.__value_.__r.__words[2]) < 0)
        {
          if (!v6[7].__r_.__value_.__l.__size_)
          {
LABEL_70:
            unint64_t v25 = 0;
            goto LABEL_71;
          }
          unint64_t v24 = (std::string::__raw *)v24->__words[0];
        }
        else if (!*((unsigned char *)&v6[7].__r_.__value_.__s + 23))
        {
          goto LABEL_70;
        }
        unint64_t v25 = +[NSString stringWithUTF8String:v24];
LABEL_71:
        LOBYTE(v28) = a2;
        id v26 = [objc_alloc((Class)CTODAPlan) initWithSetupUrl:v21 mcc:v13 mnc:v15 gid1:v17 gid2:v19 handoffToken:v23 inBuddy:v28];
        id v27 = [objc_alloc((Class)CTDisplayPlan) initWithPlan:v26 status:1 attributes:16 isPhysical:0 carrierName:v34 phoneNumber:v25 label:0];
        [cf addObject:v27];

LABEL_72:
        v6 += 8;
      }
      while (v6 != (const std::string *)v33);
    }
    sub_100044D34(v29, cf);
  }
}

void sub_100AA0958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  _Unwind_Resume(a1);
}

BOOL sub_100AA0A28(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v7 = *((unsigned __int8 *)a1 + 23);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = a1[1];
  }
  if (!v7 || *a2 == a2[1])
  {
    BOOL v13 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v16 = 0;
    ctu::base64::encode();
    v17[0] = @"sessionId";
    if (*((char *)a1 + 23) >= 0) {
      uint64_t v8 = a1;
    }
    else {
      uint64_t v8 = (uint64_t *)*a1;
    }
    BOOL v9 = +[NSString stringWithFormat:@"%s", v8];
    v17[1] = @"lpaSignedRequest";
    v18[0] = v9;
    BOOL v10 = __p;
    if (v16 < 0) {
      BOOL v10 = (void **)__p[0];
    }
    CFStringRef v11 = +[NSString stringWithFormat:@"%s", v10];
    v18[1] = v11;
    id v12 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:2];

    BOOL v13 = sub_100A97B4C((uint64_t)v12, a3);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[0]);
    }
  }
  return v13;
}

void sub_100AA0BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AA0BF4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100AA0C6C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100AA0C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v13 = a6;
  *((void *)&v13 + 1) = a7;
  long long v12 = v13;
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = &v13;
  v11[3] = 1;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(_OWORD *)(v7 - 40) = *(_OWORD *)(a3 - 40);
      long long v8 = *(_OWORD *)(a3 - 24);
      *(void *)(v7 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      uint64_t v7 = *((void *)&v13 + 1) - 40;
      *((void *)&v13 + 1) -= 40;
      a3 -= 40;
    }
    while (a3 != a5);
    uint64_t v9 = v13;
  }
  sub_100AA0D14((uint64_t)v11);
  return v9;
}

uint64_t sub_100AA0D14(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100AA0D4C(a1);
  }
  return a1;
}

void sub_100AA0D4C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    v1 += 40;
  }
}

uint64_t sub_100AA0D94(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100AA0DCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_100AA0E24(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 200;
    v4 -= 200;
    sub_100AA0EB8(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

__n128 sub_100AA0EB8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v3;
  long long v4 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v4;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
  long long v5 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v5;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 88) = 0;
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  long long v6 = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v6;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  __n128 result = *(__n128 *)(a2 + 176);
  *(__n128 *)(a1 + 176) = result;
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  return result;
}

uint64_t sub_100AA0F8C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 200;
    sub_10030FF90(i - 200);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100AA0FDC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 192;
    sub_10030A7F8(i - 192);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

_OWORD *sub_100AA102C(uint64_t **a1, void **a2, _OWORD **a3)
{
  uint64_t v11 = 0;
  long long v5 = (void **)sub_100046ED4((uint64_t)a1, &v11, a2);
  long long v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    long long v6 = operator new(0x40uLL);
    uint64_t v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    v8[1] = 0;
    v8[2] = 0;
    *uint64_t v8 = 0;
    *((unsigned char *)v6 + 56) = 0;
    sub_100046C38(a1, v11, v7, (uint64_t *)v6);
  }
  return v6;
}

void sub_100AA10C0()
{
}

void sub_100AA10E8(void *a1@<X8>)
{
  v3[0] = off_101A36408;
  v3[3] = v3;
  inactive = dispatch_workloop_create_inactive("SettingsController");
  sub_100136200((uint64_t)v3, (uint64_t)inactive);
  dispatch_activate(inactive);
  sub_1001362D0(v3);
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100AA1984(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, PersonalitiesTracker *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,dispatch_object_t object,dispatch_object_t a32,dispatch_object_t a33,dispatch_object_t a34,dispatch_object_t a35,dispatch_object_t a36,dispatch_object_t a37)
{
  sub_10008863C((void *)(v37 - 128));
  operator delete();
}

const char *sub_100AA1DA8(int a1)
{
  uint64_t v1 = "set.?";
  if (a1 == 2) {
    uint64_t v1 = "set.2";
  }
  if (a1 == 1) {
    return "set.1";
  }
  else {
    return v1;
  }
}

void *sub_100AA1DD4(uint64_t a1)
{
  sub_10019D614(a1 + 32, *(void **)(a1 + 40));

  return sub_100AAA184((void *)a1);
}

void *sub_100AA1E14(uint64_t a1)
{
  sub_100087ED0(a1 + 32, *(void **)(a1 + 40));

  return sub_100AAA208((void *)a1);
}

void sub_100AA1E54(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA1F54(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100AA2054(uint64_t a1)
{
  *(void *)a1 = off_101A36170;
  sub_10010C0E0(a1 + 664, *(void **)(a1 + 672));
  sub_10005D144(*(void **)(a1 + 648));
  sub_10019D614(a1 + 616, *(void **)(a1 + 624));
  sub_100AAA184((void *)(a1 + 584));
  sub_100087ED0(a1 + 560, *(void **)(a1 + 568));
  sub_100087ED0(a1 + 536, *(void **)(a1 + 544));
  sub_100AAA208((void *)(a1 + 504));
  sub_10005D144(*(void **)(a1 + 488));
  sub_10005D144(*(void **)(a1 + 464));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 288));
  sub_1000346F8(a1 + 256, *(void **)(a1 + 264));
  sub_100088048(a1 + 232, *(void **)(a1 + 240));
  sub_1000346F8(a1 + 208, *(void **)(a1 + 216));
  sub_100087F94(a1 + 184, *(void **)(a1 + 192));
  long long v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 144);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 128);
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 112);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 64);
  if (v9) {
    sub_10004D2C8(v9);
  }
  SettingsInterface::~SettingsInterface((SettingsInterface *)a1);
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100AA21DC(uint64_t a1)
{
  sub_100AA2054(a1);

  operator delete();
}

void sub_100AA2214(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  v8[0] = 0;
  v8[1] = 0;
  uint64_t v9 = 0;
  if (a4) {
    long long v5 = a4;
  }
  else {
    long long v5 = "";
  }
  sub_100058DB0(v8, v5);
  if (SHIBYTE(v9) < 0)
  {
    sub_10004FC84(__p, v8[0], (unint64_t)v8[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v8;
    __p[2] = v9;
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA23B4(uint64_t a1, int a2, int a3, char *a4, uint64_t a5)
{
  v11[0] = 0;
  v11[1] = 0;
  long long v12 = 0;
  if (a4) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = "";
  }
  sub_100058DB0(v11, v9);
  uint64_t v13 = a1;
  int v14 = a2;
  int v15 = a3;
  if (SHIBYTE(v12) < 0)
  {
    sub_10004FC84(__p, v11[0], (unint64_t)v11[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v11;
    __p[2] = v12;
  }
  sub_1000DFC90((uint64_t)&v17, a5);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA25D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5)
{
  long long v11 = 0uLL;
  long long v12 = 0;
  if (a5) {
    uint64_t v7 = a5;
  }
  else {
    uint64_t v7 = "";
  }
  sub_100058DB0(&v11, v7);
  sub_10009DB3C((uint64_t)&v9, a4);
  if (SHIBYTE(v12) < 0)
  {
    sub_10004FC84(__p, (void *)v11, *((unint64_t *)&v11 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = v11;
    __p[2] = v12;
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA27B8(_Unwind_Exception *a1)
{
  sub_100087E24(v1);
  if (*(char *)(v2 - 81) < 0) {
    operator delete(*(void **)(v2 - 104));
  }
  _Unwind_Resume(a1);
}

void sub_100AA27EC(uint64_t a1, int a2, int a3, uint64_t a4, char *a5, uint64_t a6)
{
  v13[0] = 0;
  v13[1] = 0;
  int v14 = 0;
  if (a5) {
    long long v11 = a5;
  }
  else {
    long long v11 = "";
  }
  sub_100058DB0(v13, v11);
  uint64_t v15 = a1;
  int v16 = a2;
  int v17 = a3;
  sub_10009DB3C((uint64_t)&v18, a4);
  if (SHIBYTE(v14) < 0)
  {
    sub_10004FC84(__p, v13[0], (unint64_t)v13[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v13;
    __p[2] = v14;
  }
  sub_1000DFC90((uint64_t)&v20, a6);
  long long v12 = *(std::__shared_weak_count **)(a1 + 16);
  if (v12)
  {
    if (std::__shared_weak_count::lock(v12)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  sub_100087E24(v41);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100AA2A88(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2B78(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2CC4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100AA2CDC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100AACA58((uint64_t)&v7, a3);
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2E28(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100AA2E40(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  sub_100AACD94((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA2F80(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100AA2F98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  __int16 v24 = 0;
  char v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)a1 + 256))();
  if (v4) {
    CSIPhoneNumber::CSIPhoneNumber();
  }
  else {
    CSIPhoneNumber::CSIPhoneNumber(&v11);
  }
  *(void *)a3 = *(void *)&v11.var0;
  uint64_t v5 = (void **)(a3 + 8);
  if (*(char *)(a3 + 31) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)uint64_t v5 = *(_OWORD *)v11.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a3 + 24) = *((void *)&v11.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v11.var2.__r_.__value_.var0.var1 + 23) = 0;
  v11.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  uint64_t v6 = (void **)(a3 + 32);
  if (*(char *)(a3 + 55) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = *(_OWORD *)&v11.var2.__r_.var0;
  *(void *)(a3 + 48) = v12;
  HIBYTE(v12) = 0;
  LOBYTE(v11.var2.__r_.var0) = 0;
  *(_DWORD *)(a3 + 56) = v13;
  *(unsigned char *)(a3 + 60) = v14;
  int v7 = (void **)(a3 + 64);
  if (*(char *)(a3 + 87) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)int v7 = __p;
  *(void *)(a3 + 80) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(__p) = 0;
  int v8 = (_OWORD *)(a3 + 88);
  if (*(char *)(a3 + 111) < 0)
  {
    operator delete(*(void **)(a3 + 88));
    int v9 = SHIBYTE(v16);
    *int v8 = v17;
    *(void *)(a3 + 104) = v18;
    HIBYTE(v18) = 0;
    LOBYTE(v17) = 0;
    *(_OWORD *)(a3 + 112) = v19;
    *(unsigned char *)(a3 + 128) = v20;
    if (v9 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    *int v8 = v17;
    *(void *)(a3 + 104) = v18;
    HIBYTE(v18) = 0;
    LOBYTE(v17) = 0;
    *(_OWORD *)(a3 + 112) = v19;
    *(unsigned char *)(a3 + 128) = v20;
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(*(void **)&v11.var2.__r_.var0);
  }
  if (*((char *)&v11.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v11.var2.__r_.__value_.var0.var1.__data_);
  }
  if (SBYTE7(v22) < 0) {
    operator delete((void *)v21);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v25);
  }
  return v4;
}

void sub_100AA31C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  if (*(char *)(v1 - 49) < 0) {
    operator delete(*(void **)(v1 - 72));
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA31F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA32F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v7 = *(_OWORD *)a3;
    void v7[2] = *(void **)(a3 + 16);
  }
  sub_10009DB3C((uint64_t)&v8, a4);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA34C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 + 39) < 0) {
    operator delete(*v17);
  }
  sub_10006A6AC(a1);
}

void sub_100AA3504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10009DB3C((uint64_t)&v6, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA36DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA36F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10009DB3C((uint64_t)&v5, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA3854(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100AAD70C;
  v8[3] = &unk_101A367F8;
  v8[4] = a1 + 8;
  v8[5] = v6;
  int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005B11C;
    int v13 = &unk_101A367D8;
    char v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005A3B8;
    int v13 = &unk_101A367B8;
    char v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16 != 0;
}

uint64_t sub_100AA3994(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 256);
  uint64_t v3 = (void *)(result + 264);
  if (v2 != (void *)(result + 264))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        goto LABEL_15;
      }
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 7)) {
        goto LABEL_15;
      }
      __n128 result = operator==();
      if ((result & 1) == 0) {
        break;
      }
LABEL_16:
      char v16 = (void *)v2[1];
      if (v16)
      {
        do
        {
          long long v17 = v16;
          char v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          long long v17 = (void *)v2[2];
          BOOL v18 = *v17 == (void)v2;
          uint64_t v2 = v17;
        }
        while (!v18);
      }
      uint64_t v2 = v17;
      if (v17 == v3) {
        return result;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 7);
LABEL_15:
    unsigned int v12 = ConnectionAvailabilityContainer::available();
    uint64_t v13 = ConnectionAvailabilityContainer::error() != 94;
    (*(void (**)(void, uint64_t, unint64_t))(**(void **)(v4 + 104) + 72))(*(void *)(v4 + 104), v7, v12 | (unint64_t)(v13 << 8));
    unsigned int v14 = ConnectionAvailabilityContainer::available();
    uint64_t v15 = ConnectionAvailabilityContainer::error() != 94;
    __n128 result = (*(uint64_t (**)(void, uint64_t, unint64_t))(**(void **)(v4 + 104) + 80))(*(void *)(v4 + 104), v7, v14 | (unint64_t)(v15 << 8));
    goto LABEL_16;
  }
  return result;
}

void sub_100AA3B20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA3C10(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  void v7[2] = a3;
  void v7[3] = a4;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100AADCAC;
  v9[3] = &unk_101A36818;
  v9[4] = a1 + 8;
  v9[5] = v7;
  BOOL v10 = v9;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005B11C;
    unsigned int v14 = &unk_101A367D8;
    uint64_t v15 = &v17;
    char v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005A3B8;
    unsigned int v14 = &unk_101A367B8;
    uint64_t v15 = &v17;
    char v16 = &v10;
    dispatch_sync(v4, &block);
  }
  return v17 != 0;
}

void sub_100AA3D50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA3E44(uint64_t a1, int a2, int a3, int a4)
{
  int v9 = a3;
  int v10 = a2;
  int v8 = a4;
  v7[0] = a1;
  v7[1] = &v10;
  void v7[2] = &v9;
  void v7[3] = &v8;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100AADF50;
  v11[3] = &unk_101A36838;
  void v11[4] = a1 + 8;
  v11[5] = v7;
  uint64_t v12 = v11;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_10005B11C;
    char v16 = &unk_101A367D8;
    char v17 = &v19;
    BOOL v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_10005A3B8;
    char v16 = &unk_101A367B8;
    char v17 = &v19;
    BOOL v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

void sub_100AA3F90(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  int v10 = a4;
  int v11 = a5;
  int v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA4108(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  int v10 = a4;
  int v11 = a2;
  int v9 = a5;
  v8[0] = a1;
  v8[1] = &v11;
  v8[2] = a3;
  v8[3] = &v10;
  v8[4] = &v9;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_100AAE23C;
  v12[3] = &unk_101A36858;
  v12[4] = a1 + 8;
  v12[5] = v8;
  uint64_t v13 = v12;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    char v20 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    char v16 = sub_10005B11C;
    char v17 = &unk_101A367D8;
    BOOL v18 = &v20;
    char v19 = &v13;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v20 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    char v16 = sub_10005A3B8;
    char v17 = &unk_101A367B8;
    BOOL v18 = &v20;
    char v19 = &v13;
    dispatch_sync(v5, &block);
  }
  return v20 != 0;
}

void sub_100AA4258(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  int v11 = a5;
  int v12 = a6;
  int v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA43D8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA44CC(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100AAE7E4;
  void v7[3] = &unk_101A36878;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_10005B11C;
    int v12 = &unk_101A367D8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_10005A3B8;
    int v12 = &unk_101A367B8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_100AA4608(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA470C(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v8 = a4;
  int v9 = a2;
  v7[0] = a1;
  v7[1] = &v9;
  void v7[2] = a3;
  void v7[3] = &v8;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100AAEAD8;
  void v10[3] = &unk_101A36898;
  v10[4] = a1 + 8;
  v10[5] = v7;
  int v11 = v10;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10005B11C;
    char v15 = &unk_101A367D8;
    char v16 = &v18;
    char v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10005A3B8;
    char v15 = &unk_101A367B8;
    char v16 = &v18;
    char v17 = &v11;
    dispatch_sync(v4, &block);
  }
  return v18 != 0;
}

void sub_100AA4850(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA4944(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v8 = a4;
  int v9 = a2;
  v7[0] = a1;
  v7[1] = &v9;
  void v7[2] = a3;
  void v7[3] = &v8;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100AAEEB4;
  void v10[3] = &unk_101A368B8;
  v10[4] = a1 + 8;
  v10[5] = v7;
  int v11 = v10;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10005B11C;
    char v15 = &unk_101A367D8;
    char v16 = &v18;
    char v17 = &v11;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint64_t v14 = sub_10005A3B8;
    char v15 = &unk_101A367B8;
    char v16 = &v18;
    char v17 = &v11;
    dispatch_sync(v4, &block);
  }
  return v18 != 0;
}

void sub_100AA4A88(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100AA4B78(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100AAF170;
  v8[3] = &unk_101A368D8;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_10005B11C;
    uint64_t v13 = &unk_101A367D8;
    uint64_t v14 = &v16;
    char v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_10005A3B8;
    uint64_t v13 = &unk_101A367B8;
    uint64_t v14 = &v16;
    char v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16 != 0;
}

void sub_100AA4CB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA4DBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, int a6, int a7)
{
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  memset(&v16, 0, sizeof(v16));
  if (a4)
  {
    sub_10009DB3C((uint64_t)&v16, a4);
    if (!a5) {
      goto LABEL_4;
    }
  }
  else
  {
    CSIPhoneNumber::CSIPhoneNumber(&v16, "");
    if (!a5)
    {
LABEL_4:
      sub_10009DB3C((uint64_t)&v12, (uint64_t)&v16);
      char v13 = (char)a5;
      int v14 = a6;
      int v15 = a7;
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 16);
      if (v11)
      {
        if (std::__shared_weak_count::lock(v11)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  LOBYTE(a5) = *a5;
  goto LABEL_4;
}

void sub_100AA5040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

BOOL sub_100AA5058(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, unsigned char *a5, int a6, int a7)
{
  int v29 = a6;
  int v30 = a2;
  int v28 = a7;
  CSIPhoneNumber::CSIPhoneNumber(&v18);
  *(void *)a4 = *(void *)&v18.var0;
  uint64_t v11 = (void **)(a4 + 8);
  if (*(char *)(a4 + 31) < 0) {
    operator delete(*v11);
  }
  *(_OWORD *)uint64_t v11 = *(_OWORD *)v18.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a4 + 24) = *((void *)&v18.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v18.var2.__r_.__value_.var0.var1 + 23) = 0;
  v18.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  uint64_t v12 = (void **)(a4 + 32);
  if (*(char *)(a4 + 55) < 0) {
    operator delete(*v12);
  }
  *(_OWORD *)uint64_t v12 = *(_OWORD *)&v18.var2.__r_.var0;
  *(void *)(a4 + 48) = v19;
  HIBYTE(v19) = 0;
  LOBYTE(v18.var2.__r_.var0) = 0;
  *(_DWORD *)(a4 + 56) = v20;
  *(unsigned char *)(a4 + 60) = v21;
  char v13 = (void **)(a4 + 64);
  if (*(char *)(a4 + 87) < 0) {
    operator delete(*v13);
  }
  *(_OWORD *)char v13 = __p;
  *(void *)(a4 + 80) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(__p) = 0;
  int v14 = (_OWORD *)(a4 + 88);
  if (*(char *)(a4 + 111) < 0)
  {
    operator delete(*(void **)(a4 + 88));
    int v15 = SHIBYTE(v23);
    _OWORD *v14 = v24;
    *(void *)(a4 + 104) = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    *(_OWORD *)(a4 + 112) = v26;
    *(unsigned char *)(a4 + 128) = v27;
    if (v15 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    _OWORD *v14 = v24;
    *(void *)(a4 + 104) = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    *(_OWORD *)(a4 + 112) = v26;
    *(unsigned char *)(a4 + 128) = v27;
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(*(void **)&v18.var2.__r_.var0);
  }
  if (*((char *)&v18.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v18.var2.__r_.__value_.var0.var1.__data_);
  }
  *a3 = 0;
  *a5 = 0;
  *(void *)&v18.var0 = a1;
  v18.var2.__r_.__value_.var0.var1.__data_ = (char *)&v30;
  v18.var2.__r_.__value_.var0.var1.__size_ = (unint64_t)a3;
  *((void *)&v18.var2.__r_.__value_.var0.var1 + 2) = a4;
  *(void *)&v18.var2.__r_.var0 = a5;
  v18.var2.var0 = (int64_t)&v29;
  long long v19 = &v28;
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 0x40000000;
  v31[2] = sub_100AAF90C;
  v31[3] = &unk_101A368F8;
  v31[4] = a1 + 8;
  v31[5] = &v18;
  long long v32 = v31;
  CSIPhoneNumber v16 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v39 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000;
    char v35 = sub_10005B11C;
    long long v36 = &unk_101A367D8;
    uint64_t v37 = &v39;
    long long v38 = &v32;
    dispatch_async_and_wait(v16, &block);
  }
  else
  {
    char v39 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v34 = 0x40000000;
    char v35 = sub_10005A3B8;
    long long v36 = &unk_101A367B8;
    uint64_t v37 = &v39;
    long long v38 = &v32;
    dispatch_sync(v16, &block);
  }
  return v39 != 0;
}

uint64_t sub_100AA5334(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100AAFB18;
  void v7[3] = &unk_101A36918;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned __int16 v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100AAFD58;
    uint64_t v12 = &unk_101A36958;
    char v13 = &v15;
    int v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned __int16 v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100AAFD1C;
    uint64_t v12 = &unk_101A36938;
    char v13 = &v15;
    int v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_100AA5468(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_10033571C((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA55B4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

BOOL sub_100AA55CC(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100AB005C;
  v8[3] = &unk_101A36978;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005B11C;
    char v13 = &unk_101A367D8;
    int v14 = &v16;
    unsigned __int16 v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005A3B8;
    char v13 = &unk_101A367B8;
    int v14 = &v16;
    unsigned __int16 v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16 != 0;
}

uint64_t sub_100AA570C(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v2 = v21;
  if (v21 != v22)
  {
    while ((v23(*v2) & 1) == 0)
    {
      if (++v2 == v22)
      {
        uint64_t v2 = v22;
        break;
      }
    }
    if (v2 != v22)
    {
      uint64_t v3 = (uint64_t *)(a1 + 648);
      do
      {
        int v4 = *v2;
        uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *v2);
        int v6 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v7 = sub_100036EA4(a1, v4);
          int v8 = "Device Type unknown";
          if (v7 <= 3) {
            int v8 = off_101A37158[v7];
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v25 = (uint64_t)v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device type: %s", buf, 0xCu);
          int v6 = *v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000FA5F4(*(uint64_t **)(a1 + 464), v4);
          uint64_t v9 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v25 = v9;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fSimTypeGw: %s", buf, 0xCu);
          int v6 = *v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000FA5F4(*(uint64_t **)(a1 + 488), v4);
          uint64_t v10 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v25 = v10;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fSimType1x: %s", buf, 0xCu);
        }
        uint64_t v11 = *v3;
        if (!*v3) {
          goto LABEL_25;
        }
        uint64_t v12 = a1 + 648;
        do
        {
          int v13 = *(_DWORD *)(v11 + 28);
          BOOL v14 = v13 < v4;
          if (v13 >= v4) {
            unsigned __int16 v15 = (uint64_t *)v11;
          }
          else {
            unsigned __int16 v15 = (uint64_t *)(v11 + 8);
          }
          if (!v14) {
            uint64_t v12 = v11;
          }
          uint64_t v11 = *v15;
        }
        while (*v15);
        if ((uint64_t *)v12 == v3 || v4 < *(_DWORD *)(v12 + 28)) {
LABEL_25:
        }
          uint64_t v12 = a1 + 648;
        char v16 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          if ((uint64_t *)v12 == v3)
          {
            CSIPhoneNumber v18 = "-";
          }
          else
          {
            uint64_t v17 = *(int *)(v12 + 32);
            CSIPhoneNumber v18 = "???";
            if (v17 <= 2) {
              CSIPhoneNumber v18 = off_101A37178[v17];
            }
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v25 = (uint64_t)v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I fLastPhoneNumberEventsLocation: %s", buf, 0xCu);
        }
        long long v19 = v2 + 1;
        uint64_t v2 = v22;
        if (v19 != v22)
        {
          uint64_t v2 = v19;
          while ((v23(*v2) & 1) == 0)
          {
            if (++v2 == v22)
            {
              uint64_t v2 = v22;
              break;
            }
          }
        }
      }
      while (v2 != v22);
    }
  }
  uint64_t result = *(void *)(a1 + 120);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 184))(result);
  }
  return result;
}

void sub_100AA5A3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 184);
  uint64_t v3 = (void *)(a1 + 192);
  if (v2 != (void *)(a1 + 192))
  {
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        goto LABEL_25;
      }
      int v7 = *((_DWORD *)v2 + 8);
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8) || (rest::operator==() & 1) == 0)
      {
LABEL_25:
        if (*((unsigned char *)v2 + 40))
        {
          uint64_t v12 = *((unsigned int *)v2 + 8);
          sub_100AA7304((void **)a1, v12, "handleCarrierBundlesSetup_sync");
          int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = asString();
            uint64_t v15 = asString();
            *(_DWORD *)std::string buf = 136315394;
            uint64_t v20 = v14;
            __int16 v21 = 2080;
            uint64_t v22 = v15;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle change type (%s) technology type (%s)", buf, 0x16u);
          }
        }
      }
      char v16 = (void *)v2[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          char v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v2[2];
          BOOL v18 = *v17 == (void)v2;
          uint64_t v2 = v17;
        }
        while (!v18);
      }
      uint64_t v2 = v17;
    }
    while (v17 != v3);
  }
}

void sub_100AA5C1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 208);
  uint64_t v3 = (void *)(a1 + 216);
  if (v2 != (void *)(a1 + 216))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        break;
      }
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 7)) {
        break;
      }
      unsigned int v12 = *((_DWORD *)v2 + 8);
      if (v12 != *((_DWORD *)v8 + 8)) {
        goto LABEL_14;
      }
LABEL_18:
      uint64_t v15 = (void *)v2[1];
      if (v15)
      {
        do
        {
          char v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          char v16 = (void *)v2[2];
          BOOL v17 = *v16 == (void)v2;
          uint64_t v2 = v16;
        }
        while (!v17);
      }
      uint64_t v2 = v16;
      if (v16 == v3) {
        return;
      }
    }
    unsigned int v12 = *((_DWORD *)v2 + 8);
LABEL_14:
    sub_100AA7304((void **)a1, *((unsigned int *)v2 + 7), "handleDeviceTypesChanged_sync");
    int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = "Device Type unknown";
      if (v12 <= 3) {
        uint64_t v14 = off_101A37158[v12];
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I device type changed %s", buf, 0xCu);
    }
    goto LABEL_18;
  }
}

void sub_100AA5DF8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 232);
  uint64_t v3 = (void *)(a1 + 240);
  if (v2 != (void *)(a1 + 240))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 8);
      if (!*v5) {
        goto LABEL_15;
      }
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if ((BasicSimInfo::operator==() & 1) == 0) {
        break;
      }
LABEL_50:
      __int16 v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          __int16 v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v22 = (void *)v2[2];
          BOOL v17 = *v22 == (void)v2;
          uint64_t v2 = v22;
        }
        while (!v17);
      }
      uint64_t v2 = v22;
      if (v22 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_15:
    sub_10002E664((uint64_t)&v23, (uint64_t)(v2 + 5));
    if (subscriber::isSimSettled())
    {
      if (subscriber::isSimReady()) {
        (*(void (**)(void, void))(**(void **)(a1 + 104) + 296))(*(void *)(a1 + 104), v23);
      }
      if (subscriber::isSimAbsent())
      {
        sub_100AA8658(a1, v7, 1, 0, v24);
        sub_100AA8658(a1, v7, 2, 0, v24);
      }
      int v13 = (unsigned int *)v25;
      unsigned int v12 = v26;
      if (v25 == v26) {
        goto LABEL_37;
      }
      char v14 = 0;
      do
      {
        while (1)
        {
          uint64_t v15 = *v13;
          uint64_t SimCardForSimApp = subscriber::getSimCardForSimApp();
          BOOL v17 = (SimCardForSimApp & 0xFF00000000) != 0 && SimCardForSimApp == 1;
          if (v17) {
            sub_100AA8658(a1, v7, 1, v15, v24);
          }
          uint64_t v18 = subscriber::getSimCardForSimApp();
          if ((v18 & 0xFF00000000) == 0 || v18 != 2) {
            break;
          }
          sub_100AA8658(a1, v7, 2, v15, v24);
          ++v13;
          char v14 = 1;
          if (v13 == v12) {
            goto LABEL_38;
          }
        }
        ++v13;
      }
      while (v13 != v12);
      if ((v14 & 1) == 0) {
LABEL_37:
      }
        sub_100AA8658(a1, v7, 2, 0, 1);
LABEL_38:
      *(void *)std::string buf = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      sub_100AA9708(a1, v7, (uint64_t)buf, 0);
      uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I sim updated", buf, 2u);
      }
    }
    if (v35 < 0) {
      operator delete(__p);
    }
    if (v33 < 0) {
      operator delete(v32);
    }
    if (v31 < 0) {
      operator delete(v30);
    }
    if (v29 < 0) {
      operator delete(v28);
    }
    *(void *)std::string buf = &v27;
    sub_10002E39C((void ***)buf);
    if (v25)
    {
      long long v26 = (unsigned int *)v25;
      operator delete(v25);
    }
    goto LABEL_50;
  }
}

void sub_100AA611C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  *(void *)(v43 - 96) = v42;
  sub_10002E39C((void ***)(v43 - 96));
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AA618C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 312))();
}

void sub_100AA61BC(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/bound_sims");
  v4[0] = off_101A36E48;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100AA6270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AA629C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a2 + 24) == 2 && !*(unsigned char *)(*(void *)a3 + 49))
  {
    uint64_t v29 = 1;
    long long v31 = 0u;
    uint64_t v32 = 0;
    uint64_t v30 = a1 + 504;
    uint64_t v6 = sub_1009F8104((uint64_t *)&v31, a1 + 536);
    sub_100AB2C88((uint64_t **)v6, *(_DWORD *)(*(void *)a3 + 52));
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)a3 + 52));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = (const char *)(*(void *)a3 + 24);
      uint64_t v9 = *(unsigned __int8 *)(*(void *)a3 + 47);
      int v10 = (char)v9;
      if ((v9 & 0x80u) != 0) {
        uint64_t v9 = *(void *)(*(void *)a3 + 32);
      }
      if (v10 < 0) {
        int v8 = *(const char **)(*(void *)a3 + 24);
      }
      if (!v9) {
        int v8 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v34 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I cleaning phone_numbers for [%s]", buf, 0xCu);
    }
    sub_100AB2C88((uint64_t **)(a1 + 560), *(_DWORD *)(*(void *)a3 + 52));
    sub_100AB2B0C((uint64_t)&v29);
  }
  uint64_t result = *(void *)(a1 + 88);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 128))(result, a2, a3);
  }
  if (*(unsigned char *)(a2 + 24) == 6 && !*(unsigned char *)(*(void *)a3 + 49))
  {
    uint64_t v29 = 1;
    long long v31 = 0u;
    uint64_t v32 = 0;
    uint64_t v30 = a1 + 584;
    sub_100AB2D6C((uint64_t)&v31, (void *)(a1 + 616));
    uint64_t v12 = *((void *)&v31 + 1);
    if (*((void *)&v31 + 1))
    {
      int v13 = (void **)(*(void *)a3 + 24);
      char v14 = (uint64_t *)&v31 + 1;
      do
      {
        uint64_t v15 = v14;
        char v16 = (void **)(v12 + 32);
        int v17 = (char)sub_100046FE8((void *)(v12 + 32), v13);
        uint64_t v18 = (uint64_t **)(v12 + 8);
        if (v17 >= 0) {
          long long v19 = (uint64_t *)v12;
        }
        else {
          long long v19 = (uint64_t *)(v12 + 8);
        }
        if (v17 >= 0) {
          char v14 = (uint64_t *)v12;
        }
        uint64_t v12 = *v19;
      }
      while (*v19);
      if (v14 != (uint64_t *)((char *)&v31 + 8))
      {
        if (v17 < 0) {
          char v16 = (void **)(v15 + 4);
        }
        if ((sub_100046FE8(v13, v16) & 0x80) == 0)
        {
          uint64_t v20 = (uint64_t **)(v15 + 1);
          if (v17 >= 0) {
            uint64_t v20 = v18;
          }
          __int16 v21 = *v20;
          if (*v20)
          {
            do
            {
              uint64_t v22 = v21;
              __int16 v21 = (uint64_t *)*v21;
            }
            while (v21);
          }
          else
          {
            unsigned int v23 = v14;
            do
            {
              uint64_t v22 = (uint64_t *)v23[2];
              BOOL v24 = *v22 == (void)v23;
              unsigned int v23 = v22;
            }
            while (!v24);
          }
          if ((uint64_t *)v31 == v14) {
            *(void *)&long long v31 = v22;
          }
          --v32;
          sub_10005EE6C(*((uint64_t **)&v31 + 1), v14);
          sub_10019D670((uint64_t)v16);
          operator delete(v14);
        }
      }
    }
    uint64_t v25 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)a3 + 52));
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      long long v26 = (const char *)(*(void *)a3 + 24);
      uint64_t v27 = *(unsigned __int8 *)(*(void *)a3 + 47);
      int v28 = (char)v27;
      if ((v27 & 0x80u) != 0) {
        uint64_t v27 = *(void *)(*(void *)a3 + 32);
      }
      if (v28 < 0) {
        long long v26 = *(const char **)(*(void *)a3 + 24);
      }
      if (!v27) {
        long long v26 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v34 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I cleaning personalized_phone_numbers for [%s]", buf, 0xCu);
    }
    return sub_100AB2F60((uint64_t)&v29);
  }
  return result;
}

void sub_100AA662C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100AA6658(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = PersonalityIDToSimSlot();
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
  uint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_100592B3C(a2, &__p);
    uint64_t v7 = __p.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &__p : *(CSIPhoneNumber **)&__p.var0;
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I received P-Associated-URI: %s", buf, 0xCu);
    if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      operator delete(*(void **)&__p.var0);
    }
  }
  uint64_t v8 = *(void *)(a1 + 544);
  if (!v8) {
    goto LABEL_23;
  }
  uint64_t v9 = a1 + 544;
  do
  {
    int v10 = *(_DWORD *)(v8 + 32);
    BOOL v11 = v10 < (int)v4;
    if (v10 >= (int)v4) {
      uint64_t v12 = (uint64_t *)v8;
    }
    else {
      uint64_t v12 = (uint64_t *)(v8 + 8);
    }
    if (!v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = *v12;
  }
  while (*v12);
  if (v9 != a1 + 544 && (int)v4 >= *(_DWORD *)(v9 + 32) && *(unsigned char *)(v9 + 120))
  {
    if (*(int *)(v9 + 88) >= 5)
    {
      int v13 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        char v14 = (void *)(v9 + 64);
        if (*(char *)(v9 + 87) < 0) {
          char v14 = (void *)*v14;
        }
        uint64_t v15 = (char *)asString();
        __p.var0 = 136315394;
        *(void *)&__p.var1 = v14;
        WORD2(__p.var2.__r_.__value_.var0.var1.__data_) = 2080;
        *(char **)((char *)&__p.var2.__r_.__value_.var0.var1.__data_ + 6) = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Current trusted phone number has higher priority: %s (%s). Not updating.", (uint8_t *)&__p, 0x16u);
      }
      return;
    }
    memset(&__dst, 0, sizeof(__dst));
    if (*(char *)(v9 + 119) < 0) {
      sub_10004FC84(&__dst, *(void **)(v9 + 96), *(void *)(v9 + 104));
    }
    else {
      std::string __dst = *(std::string *)(v9 + 96);
    }
    int v17 = (const std::string *)(v9 + 40);
    *(_OWORD *)std::string buf = 0u;
    long long v73 = 0u;
    CSIPhoneNumber::CSIPhoneNumber();
    CSIPhoneNumber::getFullNumber((uint64_t *)buf, &__p);
    DWORD2(v73) = 0;
    if (v71 < 0) {
      operator delete(v70);
    }
    if (v69 < 0) {
      operator delete(v68);
    }
    if (v67 < 0) {
      operator delete(*(void **)&__p.var2.__r_.var0);
    }
    if (*((char *)&__p.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
    }
    *(_OWORD *)id v61 = 0u;
    long long v62 = 0u;
    CSIPhoneNumber::CSIPhoneNumber();
    int v18 = *(_DWORD *)(v9 + 88);
    CSIPhoneNumber::getFullNumber((uint64_t *)v61, &__p);
    DWORD2(v62) = v18;
    if (v71 < 0) {
      operator delete(v70);
    }
    if (v69 < 0) {
      operator delete(v68);
    }
    if (v67 < 0) {
      operator delete(*(void **)&__p.var2.__r_.var0);
    }
    if (*((char *)&__p.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
    }
    uint64_t v20 = *(const std::string **)(a2 + 48);
    long long v19 = *(uint64_t **)(a2 + 56);
    __int16 v21 = *v5;
    BOOL v22 = os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT);
    if (v20 == (const std::string *)v19)
    {
      if (v22)
      {
        p_dst = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        __p.var0 = 136315138;
        *(void *)&__p.var1 = p_dst;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I P-Associated-URI was revoked, adjusting trusted phone number: %s", (uint8_t *)&__p, 0xCu);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        __dst.__r_.__value_.__l.__size_ = 0;
        uint64_t v51 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
        uint64_t v51 = &__dst;
      }
      v51->__r_.__value_.__s.__data_[0] = 0;
    }
    else
    {
      if (v22)
      {
        std::string::size_type v23 = v9 + 40;
        if (*(char *)(v9 + 63) < 0) {
          std::string::size_type v23 = v17->__r_.__value_.__r.__words[0];
        }
        __p.var0 = 136315138;
        *(void *)&__p.var1 = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Parsing P-Associated-URI, own phone number: %s", (uint8_t *)&__p, 0xCu);
        uint64_t v20 = *(const std::string **)(a2 + 48);
        long long v19 = *(uint64_t **)(a2 + 56);
      }
      if (v20 == (const std::string *)v19)
      {
        memset(&v60, 0, sizeof(v60));
      }
      else
      {
        do
        {
          if (SHIBYTE(v20->__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v25 = (const std::string *)v20->__r_.__value_.__r.__words[0];
            unint64_t size = (char *)v20->__r_.__value_.__l.__size_;
          }
          else
          {
            unint64_t size = (char *)HIBYTE(v20->__r_.__value_.__r.__words[2]);
            uint64_t v25 = v20;
          }
          *(void *)&__p.var0 = v25;
          __p.var2.__r_.__value_.var0.var1.__data_ = size;
          if (sub_100235858(&__p, "tel:", 4uLL))
          {
            if (SHIBYTE(v20->__r_.__value_.__r.__words[2]) < 0) {
              std::string::size_type v52 = v20->__r_.__value_.__l.__size_;
            }
            else {
              std::string::size_type v52 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
            }
            std::string::basic_string(&v60, v20, 4uLL, v52 - 4, (std::allocator<char> *)&__p);
            goto LABEL_154;
          }
          ++v20;
        }
        while (v20 != (const std::string *)v19);
        uint64_t v27 = *(const std::string **)(a2 + 48);
        long long v26 = *(uint64_t **)(a2 + 56);
        memset(&v60, 0, sizeof(v60));
        uint64_t v58 = v26;
        if (v27 != (const std::string *)v26)
        {
          while (2)
          {
            if (SHIBYTE(v27->__r_.__value_.__r.__words[2]) < 0)
            {
              uint64_t v29 = (const std::string *)v27->__r_.__value_.__r.__words[0];
              int v28 = (char *)v27->__r_.__value_.__l.__size_;
            }
            else
            {
              int v28 = (char *)HIBYTE(v27->__r_.__value_.__r.__words[2]);
              uint64_t v29 = v27;
            }
            *(void *)&__p.var0 = v29;
            __p.var2.__r_.__value_.var0.var1.__data_ = v28;
            if (!sub_100235858(&__p, "sip:", 4uLL) || std::string::find(v27, 64, 0) == -1) {
              goto LABEL_139;
            }
            memset(&__p, 0, 24);
            std::string::size_type v30 = std::string::find(v27, 64, 0);
            std::string::basic_string((std::string *)&__p, v27, 4uLL, v30 - 4, (std::allocator<char> *)v59);
            if ((*(char *)(v9 + 63) & 0x80000000) == 0)
            {
              if (*(unsigned char *)(v9 + 63))
              {
                memset(v59, 0, 24);
                if (v17->__r_.__value_.__s.__data_[0] != 43)
                {
                  *(_OWORD *)id v59 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
                  *(void *)&v59[16] = *((void *)&v17->__r_.__value_.__l + 2);
                  goto LABEL_77;
                }
LABEL_68:
                std::string::basic_string((std::string *)v59, v17, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v64);
                goto LABEL_77;
              }
LABEL_69:
              if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0)
              {
                if (__p.var2.__r_.__value_.var0.var1.__data_)
                {
                  p_p = *(CSIPhoneNumber **)&__p.var0;
                  goto LABEL_74;
                }
              }
              else if (__p.var2.__r_.__value_.var0.var0.__data_[15])
              {
                p_p = &__p;
LABEL_74:
                if (LOBYTE(p_p->var0) == 43) {
                  std::string::operator=(&v60, (const std::string *)&__p);
                }
              }
LABEL_126:
              if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
              {
                if (!v60.__r_.__value_.__l.__size_) {
                  goto LABEL_132;
                }
                uint64_t v46 = (std::string *)v60.__r_.__value_.__r.__words[0];
LABEL_131:
                BOOL v47 = v46->__r_.__value_.__s.__data_[0] == 43;
                int v48 = 4 * v47;
              }
              else
              {
                if (*((unsigned char *)&v60.__r_.__value_.__s + 23))
                {
                  uint64_t v46 = &v60;
                  goto LABEL_131;
                }
LABEL_132:
                LOBYTE(v47) = 0;
                int v48 = 0;
              }
              if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                operator delete(*(void **)&__p.var0);
              }
              if (v48) {
                BOOL v49 = v47;
              }
              else {
                BOOL v49 = 0;
              }
              if (v49) {
                goto LABEL_154;
              }
LABEL_139:
              if (++v27 == (const std::string *)v58) {
                goto LABEL_154;
              }
              continue;
            }
            break;
          }
          unint64_t v31 = *(void *)(v9 + 48);
          if (!v31) {
            goto LABEL_69;
          }
          memset(v59, 0, 24);
          if (*v17->__r_.__value_.__l.__data_ == 43) {
            goto LABEL_68;
          }
          sub_10004FC84(v59, v17->__r_.__value_.__l.__data_, v31);
LABEL_77:
          memset(&v64, 0, sizeof(v64));
          if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0)
          {
            if (!__p.var2.__r_.__value_.var0.var1.__data_ || **(unsigned char **)&__p.var0 != 43)
            {
              sub_10004FC84(&v64, *(void **)&__p.var0, (unint64_t)__p.var2.__r_.__value_.var0.var1.__data_);
              goto LABEL_85;
            }
          }
          else if (!__p.var2.__r_.__value_.var0.var0.__data_[15] || LOBYTE(__p.var0) != 43)
          {
            *(_OWORD *)&v64.__r_.__value_.__l.__data_ = *(_OWORD *)&__p.var0;
            v64.__r_.__value_.__r.__words[2] = __p.var2.__r_.__value_.var0.var1.__size_;
LABEL_85:
            int v33 = __p.var2.__r_.__value_.var0.var0.__data_[15];
            data = __p.var2.__r_.__value_.var0.var1.__data_;
            if (__p.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
              unint64_t v35 = __p.var2.__r_.__value_.var0.var0.__data_[15];
            }
            else {
              unint64_t v35 = (unint64_t)__p.var2.__r_.__value_.var0.var1.__data_;
            }
            uint64_t v36 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
            char v37 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
            if (v35 < 5) {
              goto LABEL_121;
            }
            if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v38 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v38 = v64.__r_.__value_.__l.__size_;
            }
            uint64_t v39 = v59[23];
            if (v59[23] < 0) {
              uint64_t v39 = *(void *)&v59[8];
            }
            if (v38 == v39)
            {
              if (v59[23] >= 0) {
                int64x2_t v40 = v59;
              }
              else {
                int64x2_t v40 = *(unsigned __int8 **)v59;
              }
              if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
                if (*((unsigned char *)&v64.__r_.__value_.__s + 23))
                {
                  uint64_t v41 = &v64;
                  while (v41->__r_.__value_.__s.__data_[0] == *v40)
                  {
                    uint64_t v41 = (std::string *)((char *)v41 + 1);
                    ++v40;
                    if (!--v36) {
                      goto LABEL_105;
                    }
                  }
                  int v17 = (const std::string *)(v9 + 40);
                  goto LABEL_121;
                }
LABEL_105:
                if (*(char *)(v9 + 63) < 0)
                {
                  int v17 = (const std::string *)(v9 + 40);
                  if (!*(void *)(v9 + 48)) {
                    goto LABEL_111;
                  }
                  uint64_t v43 = *(unsigned char **)(v9 + 40);
                }
                else
                {
                  int v17 = (const std::string *)(v9 + 40);
                  uint64_t v43 = (unsigned char *)(v9 + 40);
                  if (!*(unsigned char *)(v9 + 63))
                  {
LABEL_111:
                    long long v44 = v17;
                    if (v33 < 0)
                    {
                      if (data)
                      {
                        uint64_t v45 = *(CSIPhoneNumber **)&__p.var0;
                        goto LABEL_117;
                      }
                    }
                    else if (v33)
                    {
                      uint64_t v45 = &__p;
LABEL_117:
                      if (LOBYTE(v45->var0) == 43) {
                        long long v44 = (const std::string *)&__p;
                      }
                      else {
                        long long v44 = v17;
                      }
                    }
LABEL_120:
                    std::string::operator=(&v60, v44);
                    char v37 = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                    goto LABEL_121;
                  }
                }
                long long v44 = v17;
                if (*v43 != 43) {
                  goto LABEL_111;
                }
                goto LABEL_120;
              }
              uint64_t v42 = (void *)v64.__r_.__value_.__r.__words[0];
              if (!memcmp(v64.__r_.__value_.__l.__data_, v40, v64.__r_.__value_.__l.__size_)) {
                goto LABEL_105;
              }
LABEL_123:
              operator delete(v42);
              int v17 = (const std::string *)(v9 + 40);
            }
            else
            {
LABEL_121:
              if (v37 < 0)
              {
                uint64_t v42 = (void *)v64.__r_.__value_.__r.__words[0];
                goto LABEL_123;
              }
            }
            if ((v59[23] & 0x80000000) != 0) {
              operator delete(*(void **)v59);
            }
            goto LABEL_126;
          }
          std::string::basic_string(&v64, (const std::string *)&__p, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v65);
          goto LABEL_85;
        }
      }
LABEL_154:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      std::string __dst = v60;
      std::string::size_type v53 = HIBYTE(v60.__r_.__value_.__r.__words[2]);
      int v54 = SHIBYTE(v60.__r_.__value_.__r.__words[2]);
      if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v53 = v60.__r_.__value_.__l.__size_;
      }
      long long v55 = *v5;
      if (v53)
      {
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          id v56 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          if (v54 >= 0) {
            id v56 = &__dst;
          }
          __p.var0 = 136315138;
          *(void *)&__p.var1 = v56;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Trusted phone number: %s", (uint8_t *)&__p, 0xCu);
        }
      }
      else if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p.var0) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Not able to parse P-Associated-URI. Revoking IMS trusted number", (uint8_t *)&__p, 2u);
      }
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v57 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v57 = __dst.__r_.__value_.__l.__size_;
    }
    if (v57)
    {
      CSIPhoneNumber::CSIPhoneNumber();
      CSIPhoneNumber::getFullNumber((uint64_t *)v59, &__p);
      *(_DWORD *)&v59[24] = 4;
    }
    else
    {
      memset(v59, 0, sizeof(v59));
    }
    sub_100AA8F5C(a1, v4, a2, (const std::string *)buf, (std::string *)v61, 1, (uint64_t)v59);
    if ((v59[23] & 0x80000000) != 0) {
      operator delete(*(void **)v59);
    }
    if (v57)
    {
      if (v71 < 0) {
        operator delete(v70);
      }
      if (v69 < 0) {
        operator delete(v68);
      }
      if (v67 < 0) {
        operator delete(*(void **)&__p.var2.__r_.var0);
      }
      if (*((char *)&__p.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
      }
    }
    if (SBYTE7(v62) < 0) {
      operator delete(v61[0]);
    }
    if (SBYTE7(v73) < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  else
  {
LABEL_23:
    char v16 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.var0) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "P-Associated-URI received, but there is no OwnPhoneNumber - dropping", (uint8_t *)&__p, 2u);
    }
  }
}

void sub_100AA7008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (*(char *)(v51 - 121) < 0) {
    operator delete(*(void **)(v51 - 144));
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA7110(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA7214(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA7304(void **a1, uint64_t a2, char *a3)
{
  (*(void (**)(void *))(*a1[13] + 40))(a1[13]);
  sub_100AA7388((uint64_t)a1, a2, 2, a3);

  sub_100AA7798(a1, a2);
}

void sub_100AA7388(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  int v7 = sub_100036424(a1, a2);
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v9 = v8;
  int v10 = (uint64_t **)(a1 + 648);
  BOOL v11 = *(uint64_t **)(a1 + 648);
  if (!v11) {
    goto LABEL_11;
  }
  uint64_t v12 = a1 + 648;
  uint64_t v13 = *(void *)(a1 + 648);
  do
  {
    int v14 = *(_DWORD *)(v13 + 28);
    BOOL v15 = v14 < (int)a2;
    if (v14 >= (int)a2) {
      char v16 = (uint64_t *)v13;
    }
    else {
      char v16 = (uint64_t *)(v13 + 8);
    }
    if (!v15) {
      uint64_t v12 = v13;
    }
    uint64_t v13 = *v16;
  }
  while (*v16);
  if ((uint64_t **)v12 != v10 && *(_DWORD *)(v12 + 28) <= (int)a2) {
    unsigned int v17 = *(_DWORD *)(v12 + 32);
  }
  else {
LABEL_11:
  }
    unsigned int v17 = 0;
  if (v7 != v17)
  {
    int v18 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      if (v17 > 2) {
        long long v19 = "???";
      }
      else {
        long long v19 = off_101A37178[v17];
      }
      uint64_t v20 = off_101A37178[v7];
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v36 = (uint64_t)v19;
      __int16 v37 = 2080;
      std::string::size_type v38 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Location for Phone Number events changed: %s -> %s.", buf, 0x16u);
      BOOL v11 = *v10;
    }
  }
  __int16 v21 = (uint64_t **)(a1 + 648);
  if (v11)
  {
    do
    {
      while (1)
      {
        __int16 v21 = (uint64_t **)v11;
        int v22 = *((_DWORD *)v11 + 7);
        if (v22 <= (int)a2) {
          break;
        }
        BOOL v11 = (uint64_t *)*v11;
        int v10 = v21;
        if (!*v21) {
          goto LABEL_27;
        }
      }
      if (v22 >= (int)a2)
      {
        uint64_t v25 = v11;
        goto LABEL_30;
      }
      BOOL v11 = (uint64_t *)v11[1];
    }
    while (v11);
    int v10 = v21 + 1;
  }
LABEL_27:
  uint64_t v25 = operator new(0x28uLL);
  v25[7] = a2;
  v25[8] = 0;
  *(void *)uint64_t v25 = 0;
  *((void *)v25 + 1) = 0;
  *((void *)v25 + 2) = v21;
  *int v10 = (uint64_t *)v25;
  uint64_t v23 = **(void **)(a1 + 640);
  BOOL v24 = (uint64_t *)v25;
  if (v23)
  {
    *(void *)(a1 + 640) = v23;
    BOOL v24 = *v10;
  }
  sub_100046C90(*(uint64_t **)(a1 + 648), v24);
  ++*(void *)(a1 + 656);
LABEL_30:
  v25[8] = v7;
  if (v7 == 2)
  {
    if (a3 != 1 || v17 != 2)
    {
      std::string::size_type v30 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = asString();
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v36 = v31;
        __int16 v37 = 2080;
        std::string::size_type v38 = a4;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Using Phonebook to trigger Phone Number related events. Src: %s, Reason: %s", buf, 0x16u);
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 120))(*(void *)(a1 + 88), a2);
    }
  }
  else if (v7 == 1)
  {
    if (a3 || v17 != 1)
    {
      uint64_t v26 = *(void *)(a1 + 120);
      uint64_t v27 = *v9;
      int v28 = *v9;
      if (v26)
      {
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = asString();
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v36 = v29;
          __int16 v37 = 2080;
          std::string::size_type v38 = a4;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Using CDMA Settings to trigger Phone Number related events. Src: %s, Reason: %s", buf, 0x16u);
          uint64_t v26 = *(void *)(a1 + 120);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v26 + 168))(v26, a2);
      }
      else if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v32 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = asString();
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v36 = v33;
      __int16 v37 = 2080;
      std::string::size_type v38 = a4;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N Phone number fetched, uncertain how to trigger Phone Number related events. Src: %s, Reason: %s", buf, 0x16u);
    }
  }
}

void sub_100AA7798(void **a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void *))(*a1[19] + 40))(a1[19]) == 1)
  {
    uint64_t v4 = *(void (**)(void))(*a1[13] + 304);
    v4();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services are not supported, not processing any events related", v6, 2u);
    }
  }
}

void sub_100AA78AC(uint64_t a1, char a2, char a3)
{
  char v7 = a2;
  char v6 = a3;
  v5[0] = a1;
  v5[1] = &v7;
  void v5[2] = &v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB1F20;
  block[3] = &unk_101A36FB8;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  char v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

void sub_100AA7948(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = a3;
  v5[0] = a1;
  v5[1] = &v7;
  void v5[2] = &v6;
  uint64_t v7 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB2034;
  block[3] = &unk_101A36FD8;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  char v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

void sub_100AA79E0(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = a3;
  v5[0] = a1;
  v5[1] = &v7;
  void v5[2] = &v6;
  uint64_t v7 = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB2148;
  block[3] = &unk_101A36FF8;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  char v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

void sub_100AA7A78(uint64_t a1, uint64_t a2)
{
  v4[0] = a1;
  v4[1] = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB225C;
  block[3] = &unk_101A37018;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100AA7B00(uint64_t a1, uint64_t a2)
{
  v4[0] = a1;
  v4[1] = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB2368;
  block[3] = &unk_101A37038;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100AA7B88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  v5[0] = a1;
  v5[1] = &v7;
  void v5[2] = &v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB2474;
  block[3] = &unk_101A37058;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

void sub_100AA7C20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  v5[0] = a1;
  v5[1] = &v7;
  void v5[2] = &v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB2534;
  block[3] = &unk_101A37078;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

void sub_100AA7CB8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100AA7DB0(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100AB26A8;
  v8[3] = &unk_101A37098;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  uint64_t v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_100AB26F8;
    uint64_t v13 = &unk_101A370D8;
    int v14 = &v16;
    BOOL v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_100AB26BC;
    uint64_t v13 = &unk_101A370B8;
    int v14 = &v16;
    BOOL v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16;
}

uint64_t sub_100AA7EE8(uint64_t a1, uint64_t a2, const std::string *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  int v7 = v6;
  char v8 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if (v8 < 0)
  {
    int v11 = *(unsigned __int8 *)a3->__r_.__value_.__l.__data_;
    if (v11 != 35 && v11 != 42) {
      goto LABEL_20;
    }
    unint64_t size = (unsigned __int8 *)a3->__r_.__value_.__l.__size_;
  }
  else
  {
    int v9 = a3->__r_.__value_.__s.__data_[0];
    if (v9 != 35 && v9 != 42) {
      goto LABEL_20;
    }
    unint64_t size = (unsigned __int8 *)HIBYTE(a3->__r_.__value_.__r.__words[2]);
  }
  uint64_t v12 = size - 1;
  if ((*((unsigned char *)&a3->__r_.__value_.__s + 23) & 0x80) != 0)
  {
    uint64_t v13 = (std::string *)a3->__r_.__value_.__r.__words[0];
    if (v12[a3->__r_.__value_.__r.__words[0]] == 35)
    {
      int v14 = (unsigned __int8 *)a3->__r_.__value_.__l.__size_;
      if (!v14) {
        goto LABEL_37;
      }
      goto LABEL_14;
    }
LABEL_20:
    int v18 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v48.__r_.__value_.__l.__data_) = 0;
      long long v19 = "#I Not an MMI as it does NOT start with * or # or end with #";
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if (v12[(void)a3] != 35) {
    goto LABEL_20;
  }
  uint64_t v13 = (std::string *)a3;
  int v14 = (unsigned __int8 *)HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if (!*((unsigned char *)&a3->__r_.__value_.__s + 23)) {
    goto LABEL_37;
  }
LABEL_14:
  BOOL v15 = &v14[(void)v13];
  unsigned int v16 = (unsigned __int8 *)v13;
LABEL_15:
  uint64_t v17 = 0;
  while (*v16 != a0123456789[v17])
  {
    if (++v17 == 10)
    {
      if (++v16 == v15) {
        goto LABEL_37;
      }
      goto LABEL_15;
    }
  }
  if (v16 == v15 || (std::string::size_type v20 = v16 - (unsigned __int8 *)v13, v16 - (unsigned __int8 *)v13 == -1))
  {
LABEL_37:
    int v18 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v48.__r_.__value_.__l.__data_) = 0;
      long long v19 = "#I Failed to find the service code start";
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if (v8 >= 0) {
    __int16 v21 = a3;
  }
  else {
    __int16 v21 = (const std::string *)a3->__r_.__value_.__r.__words[0];
  }
  if (v8 >= 0) {
    std::string::size_type v22 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v22 = a3->__r_.__value_.__l.__size_;
  }
  if (v22 <= v20) {
    goto LABEL_48;
  }
  uint64_t v23 = (unsigned __int8 *)v21 + v20;
  BOOL v24 = (unsigned __int8 *)v21 + v22;
  while (2)
  {
    for (uint64_t i = 0; i != 2; ++i)
    {
      if (*v23 == asc_101644D89[i])
      {
        if (v23 == v24) {
          goto LABEL_48;
        }
        uint64_t v26 = (unsigned __int8 *)(v23 - (unsigned __int8 *)v21);
        if (v26 == (unsigned __int8 *)-1) {
          goto LABEL_48;
        }
        memset(&v48, 0, sizeof(v48));
        std::string::basic_string(&v48, a3, v20, (std::string::size_type)&v26[-v20], (std::allocator<char> *)&v45);
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v27 = &v48;
        }
        else {
          uint64_t v27 = (std::string *)v48.__r_.__value_.__r.__words[0];
        }
        int v28 = (capabilities::ct *)atoi((const char *)v27);
        unsigned int v29 = v28;
        if (v28 != 7)
        {
          if (v28 == 6)
          {
            std::string::size_type v30 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v45) = 0;
              uint64_t v31 = "#I SIM card can be present, processing to show IMEI";
LABEL_62:
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&v45, 2u);
              goto LABEL_63;
            }
            goto LABEL_63;
          }
LABEL_65:
          uint64_t v37 = *(void *)(a1 + 240);
          if (!v37) {
            goto LABEL_80;
          }
          uint64_t v38 = a1 + 240;
          do
          {
            int v39 = *(_DWORD *)(v37 + 32);
            BOOL v40 = v39 < (int)a2;
            if (v39 >= (int)a2) {
              uint64_t v41 = (uint64_t *)v37;
            }
            else {
              uint64_t v41 = (uint64_t *)(v37 + 8);
            }
            if (!v40) {
              uint64_t v38 = v37;
            }
            uint64_t v37 = *v41;
          }
          while (*v41);
          if (v38 != a1 + 240 && *(_DWORD *)(v38 + 32) <= (int)a2 && (subscriber::isSimPresent() & 1) != 0)
          {
            if (v29 <= 0x34 && (uint64_t v42 = (uint64_t *)(1 << v29), ((1 << v29) & 0x10040000000030) != 0))
            {
              uint64_t v43 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v45) = 0;
                uint64_t v32 = 2;
                _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I SIM card Related MMIs", (uint8_t *)&v45, 2u);
              }
              else
              {
                uint64_t v32 = 2;
              }
            }
            else
            {
              sub_100AA844C(*(Registry **)(a1 + 56), &v45, v42);
              if ((*(unsigned int (**)(void *, uint64_t))(*(void *)v45 + 40))(v45, a2) == 1) {
                uint64_t v32 = 2;
              }
              else {
                uint64_t v32 = 3;
              }
              if (v46) {
                sub_10004D2C8(v46);
              }
            }
          }
          else
          {
LABEL_80:
            long long v44 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v45) = 0;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I No SIM card present, not handling MMI or USSD", (uint8_t *)&v45, 2u);
            }
            uint64_t v32 = 3;
          }
          goto LABEL_83;
        }
        capabilities::ct::SARValue((uint64_t *)&v45, v28);
        if (v47 < 0)
        {
          uint64_t v36 = v46;
          operator delete(v45);
          if (!v36) {
            goto LABEL_65;
          }
        }
        else if (!v47)
        {
          goto LABEL_65;
        }
        std::string::size_type v30 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v45) = 0;
          uint64_t v31 = "#I Regulatory MMI, SAR value present, handling it";
          goto LABEL_62;
        }
LABEL_63:
        uint64_t v32 = 1;
LABEL_83:
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v48.__r_.__value_.__l.__data_);
        }
        goto LABEL_52;
      }
    }
    if (++v23 != v24) {
      continue;
    }
    break;
  }
LABEL_48:
  int v18 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v48.__r_.__value_.__l.__data_) = 0;
    long long v19 = "#I Failed to find the end position of the service code";
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v48, 2u);
  }
LABEL_51:
  uint64_t v32 = 3;
LABEL_52:
  uint64_t v33 = *v7;
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    if ((v32 - 1) > 2) {
      uint64_t v34 = "MMIValidity::kUnknown";
    }
    else {
      uint64_t v34 = off_101A37190[(int)v32 - 1];
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I MMI validity result: %s", (uint8_t *)&v48, 0xCu);
  }
  return v32;
}

void sub_100AA840C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AA844C(Registry *this@<X1>, void *a2@<X0>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v13);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    int v11 = 0;
  }
  std::mutex::unlock(v5);
  *a2 = v12;
  a2[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
}

BOOL sub_100AA8518(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100AB2734;
  v8[3] = &unk_101A370F8;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  unsigned int v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005B11C;
    unint64_t v13 = &unk_101A367D8;
    int v14 = &v16;
    BOOL v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10005A3B8;
    unint64_t v13 = &unk_101A367B8;
    int v14 = &v16;
    BOOL v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16 != 0;
}

void sub_100AA8658(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v11 = *(void *)(a1 + 464);
  if (!v11) {
    goto LABEL_11;
  }
  uint64_t v12 = (os_log_t *)v10;
  uint64_t v13 = a1 + 464;
  do
  {
    int v14 = *(_DWORD *)(v11 + 28);
    BOOL v15 = v14 < (int)a2;
    if (v14 >= (int)a2) {
      char v16 = (uint64_t *)v11;
    }
    else {
      char v16 = (uint64_t *)(v11 + 8);
    }
    if (!v15) {
      uint64_t v13 = v11;
    }
    uint64_t v11 = *v16;
  }
  while (*v16);
  if (v13 == a1 + 464 || *(_DWORD *)(v13 + 28) > (int)a2)
  {
LABEL_11:
    uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v29 = 136315138;
    uint64_t v30 = subscriber::asString();
    uint64_t v23 = "Cannot find slot %s for GW type!!";
LABEL_26:
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v23, (uint8_t *)&v29, 0xCu);
    return;
  }
  uint64_t v18 = *(void *)(a1 + 488);
  if (!v18) {
    goto LABEL_23;
  }
  uint64_t v19 = a1 + 488;
  do
  {
    int v20 = *(_DWORD *)(v18 + 28);
    BOOL v21 = v20 < (int)a2;
    if (v20 >= (int)a2) {
      std::string::size_type v22 = (uint64_t *)v18;
    }
    else {
      std::string::size_type v22 = (uint64_t *)(v18 + 8);
    }
    if (!v21) {
      uint64_t v19 = v18;
    }
    uint64_t v18 = *v22;
  }
  while (*v22);
  if (v19 != a1 + 488 && *(_DWORD *)(v19 + 28) <= (int)a2)
  {
    if (a3 == 2)
    {
      uint64_t v24 = *(void *)(a1 + 120);
      if (v24)
      {
        if (*(_DWORD *)(v19 + 32) | a4) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v24 + 176))(v24, a2, a5);
        }
      }
    }
    if (subscriber::isSimReady())
    {
      if (a3 == 1)
      {
        if (*(_DWORD *)(v13 + 32) != a4)
        {
          uint64_t v25 = *v12;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            int v29 = 136315394;
            uint64_t v30 = subscriber::asString();
            __int16 v31 = 2080;
            uint64_t v32 = subscriber::asString();
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I GW SIM type is changing from %s to %s", (uint8_t *)&v29, 0x16u);
          }
          *(_DWORD *)(v13 + 32) = a4;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 104) + 64))(*(void *)(a1 + 104), a2, a4);
        }
      }
      else if (a3 == 2 && *(_DWORD *)(v19 + 32) != a4)
      {
        uint64_t v27 = *v12;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = 136315394;
          uint64_t v30 = subscriber::asString();
          __int16 v31 = 2080;
          uint64_t v32 = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I 1x SIM type is changing from %s to %s", (uint8_t *)&v29, 0x16u);
        }
        *(_DWORD *)(v19 + 32) = a4;
      }
      sub_100AA7304((void **)a1, a2, "handleSimState_sync");
    }
    else if (subscriber::isSimAbsent())
    {
      if (a3 == 1)
      {
        if (*(_DWORD *)(v13 + 32))
        {
          uint64_t v26 = *v12;
          if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
          {
            int v29 = 136315394;
            uint64_t v30 = subscriber::asString();
            __int16 v31 = 2080;
            uint64_t v32 = subscriber::asString();
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I GW SIM type is changing from %s to %s", (uint8_t *)&v29, 0x16u);
          }
          *(_DWORD *)(v13 + 32) = 0;
          (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 104) + 64))(*(void *)(a1 + 104), a2, 0);
        }
      }
      else if (a3 == 2 && *(_DWORD *)(v19 + 32))
      {
        int v28 = *v12;
        if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = 136315394;
          uint64_t v30 = subscriber::asString();
          __int16 v31 = 2080;
          uint64_t v32 = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I 1x SIM type is changing from %s to %s", (uint8_t *)&v29, 0x16u);
        }
        *(_DWORD *)(v19 + 32) = 0;
      }
    }
  }
  else
  {
LABEL_23:
    uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v29 = 136315138;
      uint64_t v30 = subscriber::asString();
      uint64_t v23 = "Cannot find slot %s for 1x type!!";
      goto LABEL_26;
    }
  }
}

void sub_100AA8B48(uint64_t a1, int a2)
{
  int v5 = a2;
  v4[0] = a1;
  v4[1] = &v5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB289C;
  block[3] = &unk_101A37118;
  block[4] = a1 + 8;
  block[5] = v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100AA8BD8(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = a3;
  void v5[2] = &v6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100AB29D4;
  block[3] = &unk_101A37138;
  block[4] = a1 + 8;
  block[5] = v5;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
}

BOOL sub_100AA8C6C(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 240);
  uint64_t v2 = a1 + 240;
  uint64_t v3 = v4;
  memset(v13, 0, 38);
  memset(&v13[5], 0, 96);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 != v2 && *(_DWORD *)(v5 + 32) <= a2)
  {
    uint64_t v11 = *(_DWORD **)(v5 + 56);
    uint64_t v12 = *(_DWORD **)(v5 + 64);
    if (v11 != v12)
    {
      while ((*v11 - 1) >= 2)
      {
        if (++v11 == v12)
        {
          uint64_t v11 = v12;
          break;
        }
      }
    }
    BOOL v9 = v11 != v12;
  }
  else
  {
LABEL_11:
    BOOL v9 = 0;
  }
  int v14 = (void **)&v13[1];
  sub_10002E39C(&v14);
  return v9;
}

uint64_t sub_100AA8D58(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100036CF4(a1, a2);
  uint64_t v6 = v4;
  if (v4 == 1) {
    return v6;
  }
  if (v4 != 2) {
    return 0;
  }
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 56));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v22);
  if (!v13)
  {
    uint64_t v15 = 0;
    goto LABEL_11;
  }
  uint64_t v15 = v13[3];
  int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
LABEL_11:
    std::mutex::unlock(v8);
    int v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
LABEL_12:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 96))(&cf, v15, a2, 1, @"PhoneNumberIsVoiceMailNumber", kCFBooleanFalse, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  uint64_t v17 = (BOOL *)cf;
  LOBYTE(v22) = 0;
  if (cf && (CFTypeID v18 = CFGetTypeID(cf), v18 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v22, v17, v19);
    if ((_BYTE)v22) {
      uint64_t v6 = 2;
    }
    else {
      uint64_t v6 = 3;
    }
  }
  else
  {
    uint64_t v6 = 3;
  }
  sub_1000577C4(&cf);
  return v6;
}

void sub_100AA8EFC(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AA8F28(uint64_t a1, unint64_t a2)
{
  return (*(uint64_t (**)(void, unint64_t, unint64_t))(**(void **)(a1 + 104) + 320))(*(void *)(a1 + 104), a2, HIDWORD(a2));
}

void sub_100AA8F5C(uint64_t a1, uint64_t a2, uint64_t a3, const std::string *a4, std::string *a5, BOOL a6, uint64_t a7)
{
  uint64_t v11 = a2;
  unsigned int v72 = a2;
  uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  __str = a5;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = v66;
    asString();
    id v59 = a4;
    if (SBYTE7(v67) < 0) {
      int v14 = (void **)v66[0];
    }
    uint64_t v15 = &v71;
    asString();
    if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v15 = (std::string *)v71.__r_.__value_.__r.__words[0];
    }
    BOOL v16 = a6;
    uint64_t v17 = asStringBool(a6);
    asString();
    if (v70 >= 0) {
      CFTypeID v18 = __p;
    }
    else {
      CFTypeID v18 = (void **)__p[0];
    }
    uint64_t v19 = *(unsigned __int8 *)(a3 + 23);
    BOOL v20 = (v19 & 0x80u) != 0;
    if ((v19 & 0x80u) != 0) {
      uint64_t v19 = *(void *)(a3 + 8);
    }
    if (v20) {
      BOOL v21 = *(const char **)a3;
    }
    else {
      BOOL v21 = (const char *)a3;
    }
    if (v19) {
      unint64_t v22 = v21;
    }
    else {
      unint64_t v22 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136316162;
    unint64_t v74 = v14;
    __int16 v75 = 2080;
    unint64_t v76 = v15;
    __int16 v77 = 2080;
    uint64_t v78 = v17;
    __int16 v79 = 2080;
    long long v80 = v18;
    __int16 v81 = 2080;
    long long v82 = v22;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I update of phone number: %s' : '%s', attempted: %s, trusted: %s, accountId: %s", buf, 0x34u);
    if (v70 < 0) {
      operator delete(__p[0]);
    }
    a6 = v16;
    if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v71.__r_.__value_.__l.__data_);
    }
    a4 = v59;
    if (SBYTE7(v67) < 0) {
      operator delete(v66[0]);
    }
  }
  v66[0] = (void *)1;
  long long v67 = 0u;
  uint64_t v68 = 0;
  v66[1] = (void *)(a1 + 504);
  sub_1009F8104((uint64_t *)&v67, a1 + 536);
  if (!a6)
  {
    uint64_t v45 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I make sure phone_numbers don't keep phone number", buf, 2u);
    }
    sub_100AB2C88((uint64_t **)&v67, v11);
    goto LABEL_97;
  }
  memset(&v71, 0, sizeof(v71));
  sub_100058DB0(&v71, "");
  uint64_t v23 = *(void *)(a1 + 240);
  if (v23)
  {
    uint64_t v24 = a1 + 240;
    do
    {
      int v25 = *(_DWORD *)(v23 + 32);
      BOOL v26 = v25 < (int)v11;
      if (v25 >= (int)v11) {
        uint64_t v27 = (uint64_t *)v23;
      }
      else {
        uint64_t v27 = (uint64_t *)(v23 + 8);
      }
      if (!v26) {
        uint64_t v24 = v23;
      }
      uint64_t v23 = *v27;
    }
    while (*v27);
    if (v24 != a1 + 240 && *(_DWORD *)(v24 + 32) <= (int)v11) {
      std::string::operator=(&v71, (const std::string *)(v24 + 112));
    }
  }
  int v28 = *(void **)(a1 + 664);
  if (v28 == (void *)(a1 + 672))
  {
LABEL_58:
    uint64_t v40 = v72;
    uint64_t v41 = sub_100AB31E8((uint64_t **)&v67, v72, &v72);
    std::string::operator=((std::string *)(v41 + 5), a4);
    std::string::operator=((std::string *)(v41 + 8), __str);
    uint64_t v42 = __str;
    int data = (int)__str[1].__r_.__value_.__l.__data_;
    *((_DWORD *)v41 + 22) = data;
    *((unsigned char *)v41 + 120) = a6;
    if (data == 5)
    {
      long long v44 = (std::string *)(v41 + 12);
    }
    else
    {
      if (!*(_DWORD *)(a7 + 24))
      {
        if (*((char *)v41 + 119) < 0)
        {
          *(unsigned char *)v41[12] = 0;
          v41[13] = 0;
        }
        else
        {
          *((unsigned char *)v41 + 96) = 0;
          *((unsigned char *)v41 + 119) = 0;
        }
LABEL_76:
        std::string::size_type v53 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v40);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          int v54 = __p;
          asString();
          if (v70 < 0) {
            int v54 = (void **)__p[0];
          }
          asString();
          if (v65 >= 0) {
            long long v55 = (std::string *)&v64;
          }
          else {
            long long v55 = (std::string *)v64;
          }
          uint64_t v56 = asStringBool(1);
          asString();
          if (v63 >= 0) {
            std::string::size_type v57 = &v62;
          }
          else {
            std::string::size_type v57 = (void **)v62;
          }
          *(_DWORD *)std::string buf = 136315906;
          unint64_t v74 = v54;
          __int16 v75 = 2080;
          unint64_t v76 = v55;
          __int16 v77 = 2080;
          uint64_t v78 = v56;
          __int16 v79 = 2080;
          long long v80 = v57;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I setting phone_numbers to '%s', '%s', attempted: %s, trusted: %s", buf, 0x2Au);
          if (v63 < 0) {
            operator delete(v62);
          }
          if (v65 < 0) {
            operator delete(v64);
          }
          if (v70 < 0) {
            operator delete(__p[0]);
          }
        }
        goto LABEL_94;
      }
      long long v44 = (std::string *)(v41 + 12);
      uint64_t v42 = (const std::string *)a7;
    }
    std::string::operator=(v44, v42);
    goto LABEL_76;
  }
  uint64_t v29 = HIBYTE(v71.__r_.__value_.__r.__words[2]);
  long long v30 = *(_OWORD *)&v71.__r_.__value_.__l.__data_;
  if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v71.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v71.__r_.__value_.__l.__size_;
  }
  while (1)
  {
    uint64_t v32 = *((unsigned __int8 *)v28 + 79);
    int v33 = (char)v32;
    if ((v32 & 0x80u) != 0) {
      uint64_t v32 = v28[8];
    }
    if (size != v32) {
      goto LABEL_52;
    }
    uint64_t v34 = v33 >= 0 ? (unsigned __int8 *)(v28 + 7) : (unsigned __int8 *)v28[7];
    if ((v29 & 0x80) != 0) {
      break;
    }
    if (!v29) {
      goto LABEL_63;
    }
    unint64_t v35 = &v71;
    uint64_t v36 = v29;
    while (v35->__r_.__value_.__s.__data_[0] == *v34)
    {
      unint64_t v35 = (std::string *)((char *)v35 + 1);
      ++v34;
      if (!--v36) {
        goto LABEL_63;
      }
    }
LABEL_52:
    uint64_t v37 = (void *)v28[1];
    if (v37)
    {
      do
      {
        uint64_t v38 = v37;
        uint64_t v37 = (void *)*v37;
      }
      while (v37);
    }
    else
    {
      do
      {
        uint64_t v38 = (void *)v28[2];
        BOOL v39 = *v38 == (void)v28;
        int v28 = v38;
      }
      while (!v39);
    }
    int v28 = v38;
    if (v38 == (void *)(a1 + 672)) {
      goto LABEL_58;
    }
  }
  if (memcmp((const void *)v30, v34, *((size_t *)&v30 + 1))) {
    goto LABEL_52;
  }
LABEL_63:
  uint64_t v46 = v72;
  char v47 = sub_100AB31E8((uint64_t **)&v67, v72, &v72);
  std::string v48 = *(void **)(a1 + 536);
  if (v48 != (void *)(a1 + 544))
  {
    BOOL v49 = v47;
    uint64_t v50 = (std::string *)(v47 + 5);
    while (*((_DWORD *)v48 + 8) == v46)
    {
      uint64_t v51 = (void *)v48[1];
      if (v51)
      {
        do
        {
          std::string::size_type v52 = v51;
          uint64_t v51 = (void *)*v51;
        }
        while (v51);
      }
      else
      {
        do
        {
          std::string::size_type v52 = (void *)v48[2];
          BOOL v39 = *v52 == (void)v48;
          std::string v48 = v52;
        }
        while (!v39);
      }
      std::string v48 = v52;
      if (v52 == (void *)(a1 + 544)) {
        goto LABEL_94;
      }
    }
    uint64_t v58 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v46);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Offload SIM setting phone_numbers of MNOS", buf, 2u);
    }
    std::string::operator=(v50, (const std::string *)(v48 + 5));
    std::string::operator=((std::string *)(v49 + 8), (const std::string *)(v48 + 8));
    *((_DWORD *)v49 + 22) = *((_DWORD *)v48 + 22);
    std::string::operator=((std::string *)v49 + 4, (const std::string *)v48 + 4);
    *((unsigned char *)v49 + 120) = *((unsigned char *)v48 + 120);
  }
LABEL_94:
  if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v71.__r_.__value_.__l.__data_);
  }
  uint64_t v11 = v72;
LABEL_97:
  sub_100AB2B0C((uint64_t)v66);
  sub_100AA9708(a1, v11, a3, 1);
}

void sub_100AA9650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  sub_100AB2B0C((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_100AA9708(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v52 = a2;
  memset(&__dst, 0, sizeof(__dst));
  if (*(char *)(a3 + 23) < 0) {
    sub_10004FC84(&__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __dst = *(std::string *)a3;
  }
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    uint64_t v39 = *(void *)(a1 + 240);
    if (v39)
    {
      uint64_t v40 = a1 + 240;
      do
      {
        int v41 = *(_DWORD *)(v39 + 32);
        BOOL v42 = v41 < (int)a2;
        if (v41 >= (int)a2) {
          uint64_t v43 = (uint64_t *)v39;
        }
        else {
          uint64_t v43 = (uint64_t *)(v39 + 8);
        }
        if (!v42) {
          uint64_t v40 = v39;
        }
        uint64_t v39 = *v43;
      }
      while (*v43);
      if (v40 != a1 + 240 && *(_DWORD *)(v40 + 32) <= (int)a2)
      {
        if (*(char *)(v40 + 135) < 0)
        {
          sub_10004FC84(v48, *(void **)(v40 + 112), *(void *)(v40 + 120));
        }
        else
        {
          *(_OWORD *)std::string v48 = *(_OWORD *)(v40 + 112);
          *(void *)&long long v49 = *(void *)(v40 + 128);
        }
        std::string::operator=(&__dst, (const std::string *)v48);
        if (SBYTE7(v49) < 0) {
          operator delete(*(void **)v48);
        }
      }
    }
  }
  if (a4)
  {
    uint64_t v8 = (uint64_t **)(a1 + 560);
    sub_100AB2C88((uint64_t **)(a1 + 560), a2);
    uint64_t v9 = *(void *)(a1 + 544);
    if (v9)
    {
      uint64_t v10 = a1 + 544;
      do
      {
        int v11 = *(_DWORD *)(v9 + 32);
        BOOL v12 = v11 < (int)a2;
        if (v11 >= (int)a2) {
          uint64_t v13 = (uint64_t *)v9;
        }
        else {
          uint64_t v13 = (uint64_t *)(v9 + 8);
        }
        if (!v12) {
          uint64_t v10 = v9;
        }
        uint64_t v9 = *v13;
      }
      while (*v13);
      if (v10 != a1 + 544 && *(_DWORD *)(v10 + 32) <= (int)a2)
      {
        if (isReal())
        {
          *(void *)std::string v48 = 1;
          long long v49 = 0u;
          uint64_t v50 = 0;
          *(void *)&v48[8] = a1 + 584;
          int v14 = (uint64_t **)sub_100AB2D6C((uint64_t)&v49, (void *)(a1 + 616));
          __p[0] = &__dst;
          uint64_t v15 = sub_100AB30DC(v14, (void **)&__dst.__r_.__value_.__l.__data_, (long long **)__p);
          std::string::operator=((std::string *)(v15 + 7), (const std::string *)(v10 + 40));
          std::string::operator=((std::string *)(v15 + 10), (const std::string *)(v10 + 64));
          *((_DWORD *)v15 + 26) = *(_DWORD *)(v10 + 88);
          std::string::operator=((std::string *)(v15 + 14), (const std::string *)(v10 + 96));
          *((unsigned char *)v15 + 136) = *(unsigned char *)(v10 + 120);
          BOOL v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v52);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            long long v18 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
            rest::asString();
            if ((v17 & 0x80u) == 0) {
              uint64_t v19 = v17;
            }
            else {
              uint64_t v19 = *((void *)&v18 + 1);
            }
            p_dst = &__dst;
            if ((v17 & 0x80u) != 0) {
              p_dst = (std::string *)v18;
            }
            if (v19) {
              BOOL v21 = (const char *)p_dst;
            }
            else {
              BOOL v21 = "<invalid>";
            }
            if (v47 >= 0) {
              unint64_t v22 = __p;
            }
            else {
              unint64_t v22 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136315394;
            int v54 = v21;
            __int16 v55 = 2080;
            uint64_t v56 = v22;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I setting personalized_phone_numbers for [%s] '%s'", buf, 0x16u);
            if (v47 < 0) {
              operator delete(__p[0]);
            }
          }
LABEL_59:
          sub_100AB2F60((uint64_t)v48);
          goto LABEL_75;
        }
        long long v44 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string v48 = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I adding cached value to fPhoneNumberQueuedUpdate", v48, 2u);
        }
        uint64_t v45 = sub_100AB31E8(v8, a2, &v52);
        std::string::operator=((std::string *)(v45 + 5), (const std::string *)(v10 + 40));
        std::string::operator=((std::string *)(v45 + 8), (const std::string *)(v10 + 64));
        *((_DWORD *)v45 + 22) = *(_DWORD *)(v10 + 88);
        std::string::operator=((std::string *)v45 + 4, (const std::string *)(v10 + 96));
        *((unsigned char *)v45 + 120) = *(unsigned char *)(v10 + 120);
      }
    }
  }
  else if (isReal())
  {
    uint64_t v23 = *(void *)(a1 + 568);
    if (v23)
    {
      uint64_t v24 = (uint64_t **)(a1 + 560);
      uint64_t v25 = a1 + 568;
      do
      {
        int v26 = *(_DWORD *)(v23 + 32);
        BOOL v27 = v26 < (int)a2;
        if (v26 >= (int)a2) {
          int v28 = (uint64_t *)v23;
        }
        else {
          int v28 = (uint64_t *)(v23 + 8);
        }
        if (!v27) {
          uint64_t v25 = v23;
        }
        uint64_t v23 = *v28;
      }
      while (*v28);
      if (v25 != a1 + 568 && *(_DWORD *)(v25 + 32) <= (int)a2)
      {
        *(void *)std::string v48 = 1;
        long long v49 = 0u;
        uint64_t v50 = 0;
        *(void *)&v48[8] = a1 + 584;
        uint64_t v29 = (uint64_t **)sub_100AB2D6C((uint64_t)&v49, (void *)(a1 + 616));
        __p[0] = &__dst;
        long long v30 = sub_100AB30DC(v29, (void **)&__dst.__r_.__value_.__l.__data_, (long long **)__p);
        std::string::operator=((std::string *)(v30 + 7), (const std::string *)(v25 + 40));
        std::string::operator=((std::string *)(v30 + 10), (const std::string *)(v25 + 64));
        *((_DWORD *)v30 + 26) = *(_DWORD *)(v25 + 88);
        std::string::operator=((std::string *)(v30 + 14), (const std::string *)(v25 + 96));
        *((unsigned char *)v30 + 136) = *(unsigned char *)(v25 + 120);
        int v31 = v52;
        uint64_t v32 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v52);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          long long v34 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          rest::asString();
          if ((v33 & 0x80u) == 0) {
            uint64_t v35 = v33;
          }
          else {
            uint64_t v35 = *((void *)&v34 + 1);
          }
          uint64_t v36 = &__dst;
          if ((v33 & 0x80u) != 0) {
            uint64_t v36 = (std::string *)v34;
          }
          if (v35) {
            uint64_t v37 = (const char *)v36;
          }
          else {
            uint64_t v37 = "<invalid>";
          }
          if (v47 >= 0) {
            uint64_t v38 = __p;
          }
          else {
            uint64_t v38 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136315394;
          int v54 = v37;
          __int16 v55 = 2080;
          uint64_t v56 = v38;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I updating personalized_phone_numbers for [%s] '%s'", buf, 0x16u);
          if (v47 < 0) {
            operator delete(__p[0]);
          }
        }
        sub_100AB2C88(v24, v31);
        goto LABEL_59;
      }
    }
  }
LABEL_75:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_100AA9C94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100AA9D08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v11 = *(_OWORD *)a3;
    v11[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)BOOL v12 = *(_OWORD *)a4;
    v12[2] = *(void **)(a4 + 16);
  }
  int v13 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)CSIPhoneNumber __p = *(_OWORD *)a5;
    __p[2] = *(void **)(a5 + 16);
  }
  int v15 = *(_DWORD *)(a5 + 24);
  char v16 = a6;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AA9F7C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v22 + 63) < 0) {
    operator delete(*v23);
  }
  if (*(char *)(v22 + 39) < 0) {
    operator delete(*v24);
  }
  sub_10006A6AC(a1);
}

void sub_100AA9FF0(uint64_t a1, int a2, int a3)
{
  if (a2 == a3) {
    return;
  }
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v6 = "invalid from slot";
LABEL_12:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, buf, 2u);
    return;
  }
  if (subscriber::isValidSimSlot())
  {
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v6 = "invalid to slot";
    goto LABEL_12;
  }
}

uint64_t sub_100AAA17C()
{
  return 1;
}

void *sub_100AAA184(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100AAA208(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100AAA290()
{
}

void *sub_100AAA2A4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A36408;
  return result;
}

void sub_100AAA2DC(uint64_t a1, void *a2)
{
  *a2 = off_101A36408;
}

void sub_100AAA304(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_100AAA310(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AAA350()
{
}

void sub_100AAA360(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AAA398(uint64_t a1)
{
}

uint64_t sub_100AAA3B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100AAA3F8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100AAA424(ServiceManager::Service *this)
{
  *(void *)this = off_101A36580;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100AAA480(ServiceManager::Service *this)
{
  *(void *)this = off_101A36580;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100AAA4F0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SettingsController");
}

unsigned char *sub_100AAA500@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100AAA540(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100AA1E54(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100AA1E54(v4, 0);
}

uint64_t sub_100AAA5C4()
{
  return 1;
}

uint64_t sub_100AAA5CC()
{
  return 1;
}

uint64_t sub_100AAA5D4()
{
  return 2;
}

void sub_100AAA5DC(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  uint64_t v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
    sub_100AA1F54(v4, v5);
  }
  sub_100AA1F54(v4, 0);
}

void sub_100AAA678(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AAA758(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AAA86C(ServiceManager::Service *this)
{
  *(void *)this = off_101A36580;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100AAA8C8(ServiceManager::Service *this)
{
  *(void *)this = off_101A36580;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100AAA938()
{
  return 0;
}

uint64_t sub_100AAA940()
{
  return 0;
}

void sub_100AAA950()
{
}

uint64_t sub_100AAA964(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100AAA970(uint64_t *result, int a2, _DWORD *a3, int *a4)
{
  uint64_t v6 = result;
  uint64_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (void *)v7;
        int v10 = *(_DWORD *)(v7 + 28);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        uint64_t v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        uint64_t v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = result + 1;
LABEL_9:
    int v11 = operator new(0x28uLL);
    int v12 = *a4;
    v11[7] = *a3;
    v11[8] = v12;
    *(void *)int v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    *uint64_t v8 = (uint64_t *)v11;
    uint64_t v13 = *(void *)*v6;
    if (v13)
    {
      uint64_t *v6 = v13;
      int v14 = *v8;
    }
    else
    {
      int v14 = (uint64_t *)v11;
    }
    uint64_t result = sub_100046C90((uint64_t *)v6[1], v14);
    ++v6[2];
  }
  return result;
}

uint64_t *sub_100AAAA3C(void **a1)
{
  char v1 = *a1;
  int v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 21));
  uint64_t v4 = v2[11];
  uint64_t v5 = v1[1];
  *(void *)std::string buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 16))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  uint64_t v6 = v2[13];
  uint64_t v7 = v1[1];
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 16))(v6, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v8 = v2[15];
  if (v8)
  {
    uint64_t v9 = v1[1];
    dispatch_group_t object = v9;
    if (v9)
    {
      dispatch_retain(v9);
      dispatch_group_enter(v9);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v8 + 16))(v8, &object);
    if (object)
    {
      dispatch_group_leave(object);
      if (object) {
        dispatch_release(object);
      }
    }
  }
  uint64_t v10 = v2[17];
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  sub_100088C88((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100AAAC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, dispatch_group_t a12, dispatch_group_t a13)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AAAC98(NSObject ***a1)
{
  char v1 = *a1;
  id v59 = a1;
  std::string v60 = v1;
  uint64_t v2 = *v1;
  isa = (*v1)[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, isa, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = (std::__shared_weak_count *)v2[2].isa;
  if (!v4) {
    goto LABEL_89;
  }
  Class v5 = v2[11].isa;
  Class v6 = v2[1].isa;
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    goto LABEL_89;
  }
  uint64_t v8 = v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  Class v68 = 0;
  char v69 = 0;
  uint64_t v9 = std::__shared_weak_count::lock(v8);
  uint64_t v10 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else {
    Class v6 = 0;
  }
  Class v68 = v6;
  char v69 = v9;
  std::__shared_weak_count::__release_weak(v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v13 = v1[1];
  int v12 = v1 + 1;
  int v11 = v13;
  dispatch_group_t group = v13;
  if (v13)
  {
    dispatch_retain(v11);
    dispatch_group_enter(group);
  }
  (*(void (**)(Class, Class *, dispatch_group_t *))(*(void *)v5 + 24))(v5, &v68, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v69) {
    std::__shared_weak_count::__release_weak(v69);
  }
  int v14 = (std::__shared_weak_count *)v2[2].isa;
  if (!v14) {
    goto LABEL_89;
  }
  Class v15 = v2[13].isa;
  Class v16 = v2[1].isa;
  uint64_t v17 = std::__shared_weak_count::lock(v14);
  if (!v17) {
    goto LABEL_89;
  }
  long long v18 = v17;
  atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  Class v65 = 0;
  id v66 = 0;
  uint64_t v19 = std::__shared_weak_count::lock(v18);
  BOOL v20 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else {
    Class v16 = 0;
  }
  Class v65 = v16;
  id v66 = v19;
  std::__shared_weak_count::__release_weak(v18);
  if (v20) {
    sub_10004D2C8(v20);
  }
  BOOL v21 = *v12;
  dispatch_group_t object = v21;
  if (v21)
  {
    dispatch_retain(v21);
    dispatch_group_enter(object);
  }
  (*(void (**)(Class, Class *, dispatch_group_t *))(*(void *)v15 + 24))(v15, &v65, &object);
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  if (v66) {
    std::__shared_weak_count::__release_weak(v66);
  }
  Class v23 = v2[15].isa;
  if (v23)
  {
    uint64_t v24 = (std::__shared_weak_count *)v2[2].isa;
    if (v24)
    {
      Class v25 = v2[1].isa;
      int v26 = std::__shared_weak_count::lock(v24);
      if (v26)
      {
        BOOL v27 = v26;
        atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        int v28 = std::__shared_weak_count::lock(v27);
        if (v28)
        {
          uint64_t v29 = v28;
          atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          Class v62 = v25;
          char v63 = v28;
          std::__shared_weak_count::__release_weak(v27);
          sub_10004D2C8(v29);
        }
        else
        {
          Class v62 = 0;
          char v63 = 0;
          std::__shared_weak_count::__release_weak(v27);
        }
        long long v30 = *v12;
        dispatch_group_t v61 = v30;
        if (v30)
        {
          dispatch_retain(v30);
          dispatch_group_enter(v30);
        }
        (*(void (**)(Class, Class *, dispatch_group_t *))(*(void *)v23 + 24))(v23, &v62, &v61);
        if (v61)
        {
          dispatch_group_leave(v61);
          if (v61) {
            dispatch_release(v61);
          }
        }
        if (v63) {
          std::__shared_weak_count::__release_weak(v63);
        }
        goto LABEL_44;
      }
    }
LABEL_89:
    sub_100088B9C();
  }
LABEL_44:
  Class v31 = v2[17].isa;
  if (v31) {
    (*(void (**)(Class))(*(void *)v31 + 16))(v31);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v22, (Registry *)v2[7].isa);
  uint64_t v33 = ServiceMap;
  if (v34 < 0)
  {
    uint64_t v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v36 = 5381;
    do
    {
      uint64_t v34 = v36;
      unsigned int v37 = *v35++;
      uint64_t v36 = (33 * v36) ^ v37;
    }
    while (v37);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v34;
  uint64_t v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
  if (v38)
  {
    uint64_t v40 = (objc_class *)v38[3];
    uint64_t v39 = (std::__shared_weak_count *)v38[4];
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v33);
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v39);
      goto LABEL_54;
    }
  }
  else
  {
    uint64_t v40 = 0;
  }
  std::mutex::unlock(v33);
  uint64_t v39 = 0;
LABEL_54:
  int v41 = (std::__shared_weak_count *)v2[20].isa;
  v2[19].isa = v40;
  v2[20].isa = (Class)v39;
  if (v41) {
    sub_10004D2C8(v41);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  BOOL v42 = (uint8_t *)operator new(0x20uLL);
  uint64_t v43 = (objc_class *)&v2[21];
  *(void *)BOOL v42 = off_101A369A8;
  *((void *)v42 + 1) = v2;
  *((void *)v42 + 2) = sub_100AA570C;
  *((void *)v42 + 3) = 0;
  __int16 v77 = v42;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  long long v44 = (uint8_t *)operator new(0x28uLL);
  *(void *)long long v44 = off_101A36A28;
  *((void *)v44 + 1) = v2 + 23;
  *((void *)v44 + 2) = v2;
  *((void *)v44 + 3) = sub_100AA5A3C;
  *((void *)v44 + 4) = 0;
  __int16 v77 = v44;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/device_types");
  uint64_t v45 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v45 = off_101A36AA8;
  *((void *)v45 + 1) = v2 + 26;
  *((void *)v45 + 2) = v2;
  *((void *)v45 + 3) = sub_100AA5C1C;
  *((void *)v45 + 4) = 0;
  __int16 v77 = v45;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  uint64_t v46 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v46 = off_101A36B28;
  *((void *)v46 + 1) = v2 + 29;
  *((void *)v46 + 2) = v2;
  *((void *)v46 + 3) = sub_100AA5DF8;
  *((void *)v46 + 4) = 0;
  __int16 v77 = v46;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/connection_availability");
  char v47 = (uint8_t *)operator new(0x28uLL);
  *(void *)char v47 = off_101A36BA8;
  *((void *)v47 + 1) = v2 + 32;
  *((void *)v47 + 2) = v2;
  *((void *)v47 + 3) = sub_100AA3994;
  *((void *)v47 + 4) = 0;
  __int16 v77 = v47;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/setting_session_complete");
  std::string v48 = (uint8_t *)operator new(0x20uLL);
  *(void *)std::string v48 = off_101A36C28;
  *((void *)v48 + 1) = v2;
  *((void *)v48 + 2) = sub_100AA618C;
  *((void *)v48 + 3) = 0;
  __int16 v77 = v48;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/setting_session_error");
  long long v49 = (uint8_t *)operator new(0x20uLL);
  *(void *)long long v49 = off_101A36CA8;
  *((void *)v49 + 1) = v2;
  *((void *)v49 + 2) = sub_100AA8F28;
  *((void *)v49 + 3) = 0;
  __int16 v77 = v49;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  uint64_t v50 = (uint8_t *)&v2[73];
  *(void *)std::string buf = off_101A36D28;
  unint64_t v76 = (std::__shared_weak_count *)&v2[21];
  __int16 v77 = buf;
  if (buf != (uint8_t *)&v2[73])
  {
    uint64_t v51 = (uint8_t *)v2[76].isa;
    if (v51 == v50)
    {
      unsigned int v72 = v2 + 21;
      uint64_t v73 = 0;
      CSIPhoneNumber __p = off_101A36D28;
      __int16 v77 = 0;
      (*(void (**)(NSObject *, uint8_t *))(*(void *)v50 + 24))(v2 + 73, buf);
      (*(void (**)(Class))(*(void *)v2[76].isa + 32))(v2[76].isa);
      v2[76].isa = 0;
      __int16 v77 = buf;
      (*((void (**)(void **, NSObject *))__p + 3))(&__p, v2 + 73);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      v2[73].isa = (Class)off_101A36D28;
      v2[74].isa = v43;
      __int16 v77 = v51;
    }
    v2[76].isa = (Class)v50;
  }
  sub_100AAA184(buf);
  Class v52 = v2[76].isa;
  if (v52) {
    (*(void (**)(Class, NSObject *))(*(void *)v52 + 48))(v52, v2 + 77);
  }
  std::string::size_type v53 = (uint8_t *)&v2[63];
  *(void *)std::string buf = off_101A36DB8;
  unint64_t v76 = (std::__shared_weak_count *)&v2[21];
  __int16 v77 = buf;
  if (buf != (uint8_t *)&v2[63])
  {
    int v54 = (uint8_t *)v2[66].isa;
    if (v54 == v53)
    {
      unsigned int v72 = v2 + 21;
      uint64_t v73 = 0;
      CSIPhoneNumber __p = off_101A36DB8;
      __int16 v77 = 0;
      (*(void (**)(NSObject *, uint8_t *))(*(void *)v53 + 24))(v2 + 63, buf);
      (*(void (**)(Class))(*(void *)v2[66].isa + 32))(v2[66].isa);
      v2[66].isa = 0;
      __int16 v77 = buf;
      (*((void (**)(void **, NSObject *))__p + 3))(&__p, v2 + 63);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      v2[63].isa = (Class)off_101A36DB8;
      v2[64].isa = v43;
      __int16 v77 = v54;
    }
    v2[66].isa = (Class)v53;
  }
  sub_100AAA208(buf);
  Class v55 = v2[66].isa;
  if (v55) {
    (*(void (**)(Class, NSObject *))(*(void *)v55 + 48))(v55, v2 + 67);
  }
  sub_100AA61BC((uint64_t)&v2[83]);
  uint64_t v56 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v56 = off_101A36EC8;
  *((void *)v56 + 1) = v2;
  *((void *)v56 + 2) = sub_100AA629C;
  *((void *)v56 + 3) = 0;
  __int16 v77 = v56;
  uint64_t v74 = 0;
  v70[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v70);
  sub_10010040C(&__p);
  sub_100100388(buf);
  sub_100058DB0(&__p, "/cc/events/p_associated_uri_changed");
  std::string::size_type v57 = (uint8_t *)operator new(0x20uLL);
  *(void *)std::string::size_type v57 = off_101A36F48;
  *((void *)v57 + 1) = v2;
  *((void *)v57 + 2) = sub_100AA6658;
  *((void *)v57 + 3) = 0;
  __int16 v77 = v57;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)buf, (Registry *)v2[7].isa);
  ctu::RestModule::connect();
  if (v76) {
    sub_10004D2C8(v76);
  }
  sub_100088C88((uint64_t *)&v60);
  return sub_100046B58((uint64_t *)&v59);
}

void sub_100AAB848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, dispatch_group_t group, uint64_t a16, std::__shared_weak_count *a17, dispatch_group_t object, uint64_t a19, uint64_t a20,dispatch_group_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100AAB98C(void **a1)
{
  char v1 = *a1;
  Class v5 = a1;
  Class v6 = v1;
  uint64_t v2 = *(void *)(*v1 + 104);
  if (v2)
  {
    uint64_t v3 = v1[1];
    dispatch_group_t group = v3;
    if (v3)
    {
      dispatch_retain(v3);
      dispatch_group_enter(v3);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 56))(v2, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  sub_100088C88((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100AABA34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100AABA68(uint64_t **a1)
{
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 88) + 32))(*(void *)(v1 + 88));
  (*(void (**)(void))(**(void **)(v1 + 104) + 32))(*(void *)(v1 + 104));
  uint64_t v2 = *(void *)(v1 + 120);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = *(void *)(v1 + 136);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  operator delete();
}

void sub_100AABB60()
{
}

uint64_t *sub_100AABB8C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    *(void *)std::string buf = off_101A36628;
    uint64_t v10 = v2;
    uint64_t v11 = v4;
    int v12 = buf;
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
    sub_100060644(buf);
  }
  else
  {
    Class v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not selecting", buf, 2u);
    }
    (*(void (**)(void, void))(**(void **)(v2 + 72) + 304))(*(void *)(v2 + 72), *(unsigned int *)(v1 + 8));
  }
  sub_100AABD3C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AABD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AABD3C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_100AABD98()
{
}

__n128 sub_100AABDAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A36628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100AABDF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AABE28(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_100AABE70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AABEB0()
{
}

uint64_t *sub_100AABEBC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v5 = *(unsigned int *)(v1 + 8);
    uint64_t v4 = *(unsigned int *)(v1 + 12);
    sub_1000DFC90((uint64_t)buf, v1 + 40);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 40))(v3, v5, v4, v1 + 16, buf);
    sub_100060644(buf);
  }
  else
  {
    Class v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not selecting", buf, 2u);
    }
    sub_1000607A8(v1 + 40, 0);
  }
  sub_100AAC038(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100AAC00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AAC038(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 40));
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100AAC098(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    *(void *)std::string buf = off_101A366A8;
    uint64_t v10 = v2;
    uint64_t v11 = v4;
    int v12 = buf;
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    sub_100060644(buf);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not writing", buf, 2u);
    }
    (*(void (**)(void, void))(**(void **)(v2 + 72) + 304))(*(void *)(v2 + 72), *(unsigned int *)(v1 + 8));
  }
  sub_100AAC24C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AAC220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AAC24C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 175) < 0) {
      operator delete(*(void **)(v1 + 152));
    }
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_100AAC2E8()
{
}

__n128 sub_100AAC2FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A366A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100AAC348(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A366A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AAC378(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_100AAC3C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AAC400()
{
}

uint64_t *sub_100AAC40C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v5 = *(unsigned int *)(v1 + 8);
    uint64_t v4 = *(unsigned int *)(v1 + 12);
    sub_1000DFC90((uint64_t)buf, v1 + 176);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 48))(v3, v5, v4, v1 + 16, v1 + 152, buf);
    sub_100060644(buf);
  }
  else
  {
    Class v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not writing", buf, 2u);
    }
    sub_1000607A8(v1 + 176, 0);
  }
  sub_100AAC58C(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100AAC560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AAC58C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 176));
    if (*(char *)(v1 + 175) < 0) {
      operator delete(*(void **)(v1 + 152));
    }
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_100AAC62C(uint64_t **a1)
{
  Class v6 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (sub_100AA8C6C(v2, *((_DWORD *)*a1 + 2)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = *((unsigned int *)v1 + 2);
    *(void *)std::string buf = off_101A36728;
    uint64_t v8 = v2;
    uint64_t v9 = v4;
    uint64_t v10 = buf;
    (*(void (**)(uint64_t))(*(void *)v3 + 56))(v3);
    sub_100060644(buf);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not fetching", buf, 2u);
    }
  }
  operator delete();
}

void sub_100AAC780()
{
}

void sub_100AAC7C0()
{
}

__n128 sub_100AAC7D4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A36728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100AAC820(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AAC850(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_100AAC898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AAC8D8()
{
}

uint64_t *sub_100AAC8E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    sub_1000DFC90((uint64_t)buf, v1 + 16);
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 56))(v3, v4, buf);
    sub_100060644(buf);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, not fetching", buf, 2u);
    }
    sub_1000607A8(v1 + 16, 0);
  }
  sub_10041FB18(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AACA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t sub_100AACA58(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100AACAF0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100AACB70(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    sub_100AACA58((uint64_t)buf, v1 + 16);
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 64))(v3, v4, buf);
    sub_1002AE148(buf);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, count is 0", buf, 2u);
    }
    sub_100AACD38(v1 + 16, 0, 0);
  }
  sub_100AACCE8(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AACCBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AACCE8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1002AE148((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100AACD38(uint64_t a1, char a2, int a3)
{
  char v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_100AACD94(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100AACE2C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100AACEAC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_100AA8C6C(*(void *)v1, *(_DWORD *)(v1 + 8)))
  {
    uint64_t v3 = *(void *)(v2 + 88);
    uint64_t v4 = v1 + 16;
    uint64_t v6 = *(unsigned int *)(v1 + 8);
    uint64_t v5 = *(unsigned int *)(v1 + 12);
    sub_100AACD94((uint64_t)buf, v4);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 72))(v3, v6, v5, buf);
    sub_1002AEBA8(buf);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N CDMA based or unknown, Phonebook model does not apply, no entry", buf, 2u);
    }
    sub_1002AE1CC((uint64_t)buf);
    sub_100AAD098(v1 + 16, 0);
    sub_100039D40((uint64_t)buf);
  }
  sub_100AAD048(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100AAD00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t *sub_100AAD048(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1002AEBA8((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100AAD098(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t *sub_100AAD0EC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(*v1 + 136);
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)v1[2];
    uint64_t v7 = v1[1];
    uint64_t v8 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 40))(v2, &v7);
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  else
  {
    xpc_object_t object = xpc_int64_create(22);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    uint64_t v7 = v1[1];
    uint64_t v8 = (std::__shared_weak_count *)"kPosixError";
    sub_100035E70((uint64_t)&v7, &object, &v10);
    xpc_release(v10);
    xpc_object_t v10 = 0;
    xpc_release(object);
  }
  sub_10024F798((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100AAD1E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10024F798(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AAD208(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_100036424(*(void *)v1, *(unsigned int *)(v1 + 8));
  if (v3 == 2)
  {
    char v4 = *(void **)(v2 + 88);
    uint64_t v5 = (void (**)(void *, void))(*v4 + 88);
    goto LABEL_6;
  }
  if (v3 == 1)
  {
    char v4 = *(void **)(v2 + 120);
    if (v4)
    {
      uint64_t v5 = (void (**)(void *, void))(*v4 + 152);
LABEL_6:
      (*v5)(v4, *(unsigned int *)(v1 + 8));
      goto LABEL_11;
    }
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Don't know where to set the phone number", buf, 2u);
    }
  }
LABEL_11:
  sub_100AAD3E0(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100AAD3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AAD3E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 151) < 0) {
      operator delete(*(void **)(v1 + 128));
    }
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100AAD478(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v3 = a1;
  uint64_t v4 = v1;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(*(void *)v1 + 88) + 96))(*(void *)(*(void *)v1 + 88), v1 + 8, v1 + 24);
  sub_100AAD500(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100AAD4E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AAD500(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 135) < 0) {
      operator delete(*(void **)(v1 + 112));
    }
    if (*(char *)(v1 + 111) < 0) {
      operator delete(*(void **)(v1 + 88));
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100AAD594(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_100AA8D58(*(void *)v1, *(unsigned int *)(v1 + 8));
  if (v3 == 3)
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(v2 + 88) + 112))(*(void *)(v2 + 88), *(unsigned int *)(v1 + 8), v1 + 16);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "kLocationUnknown";
      if (v3 == 2) {
        uint64_t v5 = "kDevicePhoneNumber";
      }
      if (v3 == 1) {
        uint64_t v5 = "kBasebandNV";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Setting voice mail number is not supported with VM location %s", buf, 0xCu);
    }
  }
  sub_1006E15A8(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AAD6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100AAD70C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = sub_100AA8D58(*(void *)v1, **(unsigned int **)(v1 + 8));
  switch(v3)
  {
    case 3:
      uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v2 + 88) + 104);
      return v5();
    case 2:
      v40[0] = 0;
      v40[1] = 0;
      uint64_t v41 = 0;
      __int16 v39 = 0;
      char v38 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      *(_OWORD *)uint64_t v34 = 0u;
      long long v35 = 0u;
      uint64_t v7 = sub_100036208(v2, **(unsigned int **)(v1 + 8), (uint64_t)v40, (uint64_t)&v36, (uint64_t)v34, (uint64_t)&v39 + 1, (uint64_t)&v39, (uint64_t)&v38);
      if (v7) {
        CSIPhoneNumber::CSIPhoneNumber();
      }
      else {
        CSIPhoneNumber::CSIPhoneNumber(&v24);
      }
      uint64_t v9 = *(void *)(v1 + 16);
      *(void *)uint64_t v9 = *(void *)&v24.var0;
      uint64_t v10 = (void **)(v9 + 8);
      if (*(char *)(v9 + 31) < 0) {
        operator delete(*v10);
      }
      long long v11 = *(_OWORD *)v24.var2.__r_.__value_.var0.var0.__data_;
      *(void *)(v9 + 24) = *((void *)&v24.var2.__r_.__value_.var0.var1 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      *((unsigned char *)&v24.var2.__r_.__value_.var0.var1 + 23) = 0;
      v24.var2.__r_.__value_.var0.var0.__data_[0] = 0;
      int v12 = (void **)(v9 + 32);
      if (*(char *)(v9 + 55) < 0) {
        operator delete(*v12);
      }
      long long v13 = *(_OWORD *)&v24.var2.__r_.var0;
      *(void *)(v9 + 48) = v25;
      *(_OWORD *)int v12 = v13;
      HIBYTE(v25) = 0;
      LOBYTE(v24.var2.__r_.var0) = 0;
      char v14 = v27;
      *(_DWORD *)(v9 + 56) = v26;
      *(unsigned char *)(v9 + 60) = v14;
      Class v15 = (void **)(v9 + 64);
      if (*(char *)(v9 + 87) < 0) {
        operator delete(*v15);
      }
      long long v16 = __p;
      *(void *)(v9 + 80) = v29;
      *(_OWORD *)Class v15 = v16;
      HIBYTE(v29) = 0;
      LOBYTE(__p) = 0;
      uint64_t v17 = (_OWORD *)(v9 + 88);
      if (*(char *)(v9 + 111) < 0)
      {
        operator delete(*(void **)(v9 + 88));
        int v21 = SHIBYTE(v29);
        long long v22 = v30;
        *(void *)(v9 + 104) = v31;
        _OWORD *v17 = v22;
        HIBYTE(v31) = 0;
        LOBYTE(v30) = 0;
        char v23 = v33;
        *(_OWORD *)(v9 + 112) = v32;
        *(unsigned char *)(v9 + 128) = v23;
        if (v21 < 0) {
          operator delete((void *)__p);
        }
      }
      else
      {
        long long v18 = v30;
        *(void *)(v9 + 104) = v31;
        _OWORD *v17 = v18;
        HIBYTE(v31) = 0;
        LOBYTE(v30) = 0;
        char v19 = v33;
        *(_OWORD *)(v9 + 112) = v32;
        *(unsigned char *)(v9 + 128) = v19;
      }
      if (SHIBYTE(v25) < 0) {
        operator delete(*(void **)&v24.var2.__r_.var0);
      }
      if (*((char *)&v24.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(v24.var2.__r_.__value_.var0.var1.__data_);
      }
      if (SBYTE7(v35) < 0) {
        operator delete(v34[0]);
      }
      if (SBYTE7(v37) < 0) {
        operator delete((void *)v36);
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(v40[0]);
      }
      return v7;
    case 1:
      uint64_t v4 = *(void *)(v2 + 120);
      if (v4)
      {
        uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 160);
        return v5();
      }
      BOOL v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(v1 + 8));
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v24.var0) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", (uint8_t *)&v24, 2u);
      }
      return 0;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(v1 + 8));
  uint64_t v7 = 0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v24.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Don't know where to get the voice mail number", (uint8_t *)&v24, 2u);
    return 0;
  }
  return v7;
}

void sub_100AADAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v32 - 89) < 0) {
    operator delete(*(void **)(v32 - 112));
  }
  if (*(char *)(v32 - 49) < 0) {
    operator delete(*(void **)(v32 - 72));
  }
  _Unwind_Resume(exception_object);
}

void sub_100AADB28(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if ((*(unsigned int (**)(void *, void))(*v2[19] + 40))(v2[19], *((unsigned int *)*a1 + 2)) == 1)
  {
    (*(void (**)(void *, void, void))(*v2[13] + 88))(v2[13], *((unsigned int *)v1 + 2), 0);
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch Caller ID Restriction", buf, 2u);
    }
    (*(void (**)(void *, void, void))(*v2[9] + 168))(v2[9], *((unsigned int *)v1 + 2), 0);
  }
  operator delete();
}

void sub_100AADC80()
{
}

uint64_t sub_100AADCAC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    int v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 96);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get Caller ID Restriction", v6, 2u);
    }
    return 0;
  }
}

void sub_100AADDCC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if ((*(unsigned int (**)(void *, void))(*v2[19] + 40))(v2[19], *((unsigned int *)*a1 + 2)) == 1)
  {
    (*(void (**)(void *, void, void, void))(*v2[13] + 104))(v2[13], *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3), 0);
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot save Caller ID Restriction", buf, 2u);
    }
    (*(void (**)(void *, void, void))(*v2[9] + 176))(v2[9], *((unsigned int *)v1 + 2), 0);
  }
  operator delete();
}

void sub_100AADF24()
{
}

uint64_t sub_100AADF50(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    int v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 112);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, don't know availability of call barring", v6, 2u);
    }
    return 0;
  }
}

uint64_t *sub_100AAE078(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void ***)v1;
  if ((*(unsigned int (**)(void, void))(**(void **)(*(void *)v1 + 152) + 40))(*(void *)(*(void *)v1 + 152), v1[2]) == 1)
  {
    (*(void (**)(void *, void, unsigned int *, void, void, void))(*v2[13] + 120))(v2[13], v1[2], v1 + 4, v1[10], v1[11], 0);
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], v1[2]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch call barring", buf, 2u);
    }
    (*(void (**)(void *, void, void, void))(*v2[9] + 112))(v2[9], v1[2], v1[11], v1[10]);
  }
  sub_100AAE1E4((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100AAE1C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AAE1E4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100AAE23C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    int v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 128);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get call barring", v6, 2u);
    }
    return 0;
  }
}

uint64_t *sub_100AAE364(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void ***)v1;
  if ((*(unsigned int (**)(void, void))(**(void **)(*(void *)v1 + 152) + 40))(*(void *)(*(void *)v1 + 152), v1[2]) == 1)
  {
    (*(void (**)(void *, void, void, unsigned int *, void, void, void))(*v2[13] + 136))(v2[13], v1[2], *((unsigned __int8 *)v1 + 12), v1 + 4, v1[10], v1[11], 0);
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], v1[2]);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot save call waiting", buf, 2u);
    }
    (*(void (**)(void *, void, void, void, void))(*v2[9] + 120))(v2[9], v1[2], v1[11], 0, v1[10]);
  }
  sub_100AAE4D8((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100AAE4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AAE4D8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_100AAE530(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 152) + 40))(*(void *)(v2 + 152), *((unsigned int *)*a1 + 2));
  if (v3)
  {
    if (v3 != 2)
    {
      if (v3 == 1) {
        (*(void (**)(void, void, void, void))(**(void **)(v2 + 104) + 152))(*(void *)(v2 + 104), *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3), 0);
      }
      goto LABEL_13;
    }
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device is in CDMA mode, forwarding the fetch Call Waiting", v11, 2u);
    }
    uint64_t v7 = *(void **)(v2 + 120);
    if (!v7)
    {
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v10, 2u);
      }
LABEL_13:
      operator delete();
    }
    uint64_t v5 = (void (**)(void))(*v7 + 120);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch call waiting", buf, 2u);
    }
    uint64_t v5 = (void (**)(void))(**(void **)(v2 + 72) + 56);
  }
  (*v5)();
  goto LABEL_13;
}

void sub_100AAE7B8()
{
}

BOOL sub_100AAE7E4(uint64_t a1)
{
  return (*(unsigned int (**)(void, void))(**(void **)(**(void **)(a1 + 40) + 152) + 40))(*(void *)(**(void **)(a1 + 40) + 152), **(unsigned int **)(*(void *)(a1 + 40) + 8)) != 2;
}

void sub_100AAE834(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 152) + 40))(*(void *)(v2 + 152), *((unsigned int *)*a1 + 3));
  if (v3)
  {
    if (v3 == 2)
    {
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 3));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device is in CDMA mode, forwarding the save Call Waiting", v11, 2u);
      }
      uint64_t v6 = *(void *)(v2 + 120);
      uint64_t v7 = *((unsigned int *)v1 + 3);
      if (v6)
      {
        (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)v6 + 136))(v6, v7, *((unsigned __int8 *)v1 + 8), *((unsigned int *)v1 + 4));
      }
      else
      {
        uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v10, 2u);
        }
      }
    }
    else if (v3 == 1)
    {
      (*(void (**)(void, void, void, void, void))(**(void **)(v2 + 104) + 160))(*(void *)(v2 + 104), *((unsigned int *)v1 + 3), *((unsigned __int8 *)v1 + 8), *((unsigned int *)v1 + 4), 0);
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 3));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot save call waiting", buf, 2u);
    }
    (*(void (**)(void, void, void, void))(**(void **)(v2 + 72) + 64))(*(void *)(v2 + 72), *((unsigned int *)v1 + 3), *((unsigned int *)v1 + 4), 0);
  }
  operator delete();
}

void sub_100AAEAAC()
{
}

uint64_t sub_100AAEAD8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = (*(uint64_t (**)(void, void))(**(void **)(*v1 + 152) + 40))(*(void *)(*v1 + 152), *(unsigned int *)v1[1]);
  if (!v3)
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)v1[1]);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    *(_WORD *)int v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get call waiting", v12, 2u);
    return 0;
  }
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v2 + 104) + 168);
      return v4();
    }
    return 0;
  }
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)v1[1]);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Device is in CDMA mode, forwarding get Call Waiting", buf, 2u);
  }
  uint64_t v9 = *(void *)(v2 + 120);
  uint64_t v10 = *(unsigned int *)v1[1];
  if (v9) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v9 + 128))(v9, v10, v1[2], *(unsigned int *)v1[3]);
  }
  long long v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
  uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)long long v13 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v13, 2u);
    return 0;
  }
  return result;
}

void sub_100AAED34(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if ((*(unsigned int (**)(void *, void))(*v2[19] + 40))(v2[19], *((unsigned int *)*a1 + 2)) == 1)
  {
    (*(void (**)(void *, void, void, void))(*v2[13] + 176))(v2[13], *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3), 0);
  }
  else
  {
    int v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch Line Presentation", buf, 2u);
    }
    (*(void (**)(void *, void, void))(*v2[9] + 208))(v2[9], *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
  }
  operator delete();
}

void sub_100AAEE88()
{
}

uint64_t sub_100AAEEB4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    int v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 184);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get Line Presentation", v6, 2u);
    }
    return 0;
  }
}

void sub_100AAEFD8(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if ((*(unsigned int (**)(void *, void))(*v2[19] + 40))(v2[19], *((unsigned int *)*a1 + 2)) == 1)
  {
    int v3 = (void (**)(void))(*v2[13] + 200);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch Connected Line Restriction", buf, 2u);
    }
    int v3 = (void (**)(void))(*v2[9] + 216);
  }
  (*v3)();
  operator delete();
}

void sub_100AAF144()
{
}

uint64_t sub_100AAF170(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    int v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 208);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get Connected Line Restriction", v6, 2u);
    }
    return 0;
  }
}

void sub_100AAF28C(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)*a1;
  int v3 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 152) + 40))(*(void *)(v2 + 152), (*a1)[2]);
  if (v3)
  {
    if (v3 != 2)
    {
      if (v3 == 1) {
        (*(void (**)(void, void, void, void, void))(**(void **)(v2 + 104) + 216))(*(void *)(v2 + 104), v1[2], v1[3], v1[4], 0);
      }
      goto LABEL_13;
    }
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device is in CDMA mode, forwarding the fetch Call Forwarding", v11, 2u);
    }
    BOOL v7 = *(void **)(v2 + 120);
    if (!v7)
    {
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v10, 2u);
      }
LABEL_13:
      operator delete();
    }
    uint64_t v5 = (void (**)(void))(*v7 + 96);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot fetch call forwarding", buf, 2u);
    }
    uint64_t v5 = (void (**)(void))(**(void **)(v2 + 72) + 16);
  }
  (*v5)();
  goto LABEL_13;
}

void sub_100AAF518()
{
}

uint64_t *sub_100AAF544(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 152) + 40))(*(void *)(*(void *)v1 + 152), *(unsigned int *)(v1 + 8));
  if (v3)
  {
    if (v3 == 2)
    {
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Device is in CDMA mode, forwarding the save Call Forwarding", buf, 2u);
      }
      uint64_t v9 = *(void *)(v2 + 120);
      uint64_t v10 = *(unsigned int *)(v1 + 8);
      if (v9)
      {
        (*(void (**)(uint64_t, uint64_t, void, uint64_t, void, void, void))(*(void *)v9 + 112))(v9, v10, *(unsigned __int8 *)(v1 + 12), v1 + 16, *(unsigned __int8 *)(v1 + 152), *(unsigned int *)(v1 + 156), *(unsigned int *)(v1 + 160));
      }
      else
      {
        long long v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
        }
      }
    }
    else if (v3 == 1)
    {
      uint64_t v4 = *(void *)(v2 + 104);
      uint64_t v5 = *(unsigned int *)(v1 + 8);
      int v6 = *(unsigned __int8 *)(v1 + 12);
      sub_10009DB3C((uint64_t)buf, v1 + 16);
      (*(void (**)(uint64_t, uint64_t, BOOL, uint8_t *, void, void, void, void))(*(void *)v4 + 232))(v4, v5, v6 != 0, buf, *(unsigned __int8 *)(v1 + 152), *(unsigned int *)(v1 + 156), *(unsigned int *)(v1 + 160), 0);
      if (v23 < 0) {
        operator delete(__p);
      }
      if (v21 < 0) {
        operator delete(v20);
      }
      if (v19 < 0) {
        operator delete(v18);
      }
      if (v17 < 0) {
        operator delete(v16);
      }
    }
  }
  else
  {
    BOOL v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot save call forwarding", buf, 2u);
    }
    (*(void (**)(void, void, void, void, void))(**(void **)(v2 + 72) + 24))(*(void *)(v2 + 72), *(unsigned int *)(v1 + 8), *(unsigned int *)(v1 + 156), *(unsigned int *)(v1 + 160), 0);
  }
  sub_100AAF884(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100AAF820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_100AAF884(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AAF884(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100AAF90C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = (*(uint64_t (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]);
  if (v3)
  {
    if (v3 == 2)
    {
      uint64_t v7 = *((void *)v2 + 15);
      if (v7)
      {
        uint64_t v4 = *(uint64_t (**)(void))(*(void *)v7 + 104);
        return v4();
      }
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
    else if (v3 == 1)
    {
      uint64_t v4 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 240);
      return v4();
    }
  }
  else
  {
    int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get call forwarding", v9, 2u);
    }
  }
  return 0;
}

uint64_t sub_100AAFB18(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *((void *)*v1 + 19);
  if (v3)
  {
    int v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 40))(v3, *v1[1]);
    if (v4)
    {
      if (v4 != 2)
      {
        if (v4 == 1)
        {
          int v5 = (*(uint64_t (**)(void, void))(**((void **)v2 + 13) + 248))(*((void *)v2 + 13), *v1[1]);
LABEL_14:
          int v8 = 1;
          return v5 | (v8 << 8);
        }
LABEL_13:
        int v5 = 0;
        goto LABEL_14;
      }
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
      int v5 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_14;
      }
      __int16 v14 = 0;
      uint64_t v10 = "#N CDMA based device, not handling the API call to know whether call forwarding is active or not";
      long long v11 = (uint8_t *)&v14;
    }
    else
    {
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
      int v5 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_14;
      }
      __int16 v13 = 0;
      uint64_t v10 = "#N Supp Services is not supported, don't know call forwarding status";
      long long v11 = (uint8_t *)&v13;
    }
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, v11, 2u);
    goto LABEL_13;
  }
  int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  int v5 = 0;
  int v8 = 0;
  if (v7)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Capabilities handler not ready when querying for unconditional call forwarding active", buf, 2u);
    int v5 = 0;
    int v8 = 0;
  }
  return v5 | (v8 << 8);
}

uint64_t sub_100AAFD1C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100AAFD58(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_100AAFD94(unsigned int **a1)
{
  uint64_t v1 = *a1;
  int v12 = a1;
  __int16 v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 152);
  if (!v3)
  {
    BOOL v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Capabilities handler not ready when querying for unconditional call forwarding active", buf, 2u);
    }
    __int16 v8 = 0;
    goto LABEL_15;
  }
  int v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 40))(v3, v1[2]);
  switch(v4)
  {
    case 0:
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v10 = "#N Supp Services is not supported, don't know call forwarding status";
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
      }
LABEL_14:
      __int16 v8 = 256;
LABEL_15:
      sub_100335978((uint64_t)(v1 + 4), v8);
      break;
    case 2:
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v10 = "#N CDMA based device, not handling the API call to know whether call forwarding is active or not";
        goto LABEL_13;
      }
      goto LABEL_14;
    case 1:
      uint64_t v5 = *(void *)(v2 + 104);
      uint64_t v6 = v1[2];
      sub_10033571C((uint64_t)buf, (uint64_t)(v1 + 4));
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v5 + 256))(v5, v6, buf);
      sub_1000F25E0(buf);
      break;
  }
  sub_100AB000C((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100AAFFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100AB000C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000F25E0((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100AB005C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  if ((*(unsigned int (**)(void, void))(**((void **)*v1 + 19) + 40))(*((void *)*v1 + 19), *v1[1]) == 1)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**((void **)v2 + 13) + 272);
    return v3();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), *v1[1]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Supp Services is not supported, cannot get Calling Name Presentation", v6, 2u);
    }
    return 0;
  }
}

void sub_100AB0184()
{
}

__n128 sub_100AB0198(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A369A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AB01EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A369A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AB0224(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100AB026C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB02AC()
{
}

void sub_100AB02BC()
{
}

__n128 sub_100AB02D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A36A28;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AB0324(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36A28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AB035C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  __int16 v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100AB041C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AB0434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB0474()
{
}

void sub_100AB0484()
{
}

__n128 sub_100AB0498(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A36AA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AB04EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36AA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AB0524(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  long long v11 = (void **)*v3;
  int v12 = v5;
  __int16 v13 = (void *)v3[2];
  if (v13)
  {
    void v5[2] = &v12;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    long long v11 = &v12;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  __int16 v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  uint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    v12[2] = v10;
    long long v11 = &v12;
    int v12 = 0;
    __int16 v13 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10[0]);
  sub_1000346F8((uint64_t)&v11, v12);
}

void sub_100AB0620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_100AB064C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB068C()
{
}

void sub_100AB069C()
{
}

__n128 sub_100AB06B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A36B28;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AB0704(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36B28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AB073C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  long long v18 = (void **)v3->__r_.__value_.__r.__words[0];
  char v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    long long v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  char v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      __int16 v8 = (void **)v6[1];
      uint64_t v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          __int16 v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          uint64_t v9 = (void ***)v6;
        }
        while (!v10);
      }
      long long v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          long long v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  __int16 v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  Class v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    __int16 v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  long long v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100AB0900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB0948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB0988()
{
}

void sub_100AB0998()
{
}

__n128 sub_100AB09AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A36BA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AB0A00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36BA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AB0A38(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1005BEA0C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  __int16 v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100AB0AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AB0B10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB0B50()
{
}

void sub_100AB0B60()
{
}

__n128 sub_100AB0B74(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A36C28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AB0BC8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36C28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AB0C00(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  long long v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100AB0CE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB0D24()
{
}

void sub_100AB0D34()
{
}

__n128 sub_100AB0D48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A36CA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AB0D9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36CA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AB0DD4(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    long long v16 = "first";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_type_t type = xpc_get_type(v17);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      unsigned int v19 = 0;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v19, (int *)&v17, v8);
      unsigned int v6 = v19;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      unsigned int v6 = xpc::dyn_cast_or_default((xpc *)&v17, 0, (uint64_t)v8);
    }
    else
    {
      unsigned int v6 = 0;
    }
    xpc_release(v17);
    p_xpc_object_t object = &object;
    long long v16 = "second";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_type_t v9 = xpc_get_type(v17);
    if (v9 == (xpc_type_t)&_xpc_type_string)
    {
      unsigned int v19 = 0;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v19, (int *)&v17, v10);
      uint64_t v5 = v19;
    }
    else if (v9 == (xpc_type_t)&_xpc_type_BOOL {
           || v9 == (xpc_type_t)&_xpc_type_int64
    }
           || v9 == (xpc_type_t)&_xpc_type_uint64)
    {
      uint64_t v5 = xpc::dyn_cast_or_default((xpc *)&v17, 0, (uint64_t)v10);
    }
    else
    {
      uint64_t v5 = 0;
    }
    xpc_release(v17);
  }
  else
  {
    uint64_t v5 = 0;
    unsigned int v6 = 0;
  }
  xpc_release(object);
  long long v11 = (uint64_t (*)(void *, unint64_t))a1[2];
  uint64_t v12 = a1[3];
  unsigned int v13 = (void *)(a1[1] + (v12 >> 1));
  if (v12) {
    long long v11 = *(uint64_t (**)(void *, unint64_t))(*v13 + v11);
  }
  return v11(v13, v6 | (unint64_t)(v5 << 32));
}

void sub_100AB0FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

uint64_t sub_100AB1038(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB1078()
{
}

void sub_100AB1088()
{
}

void *sub_100AB109C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A36D28;
  result[1] = v3;
  return result;
}

uint64_t sub_100AB10E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A36D28;
  a2[1] = v2;
  return result;
}

void sub_100AB1110(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  unsigned int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      rest::write_rest_value();
      long long __p = &v23;
      xpc_object_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          unsigned int v6 = v13;
        }
        while (!v14);
      }
      unsigned int v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/personalized_phone_numbers");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_100AB13C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB1480(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB14C0()
{
}

void sub_100AB14D0()
{
}

void *sub_100AB14E4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A36DB8;
  result[1] = v3;
  return result;
}

uint64_t sub_100AB152C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A36DB8;
  a2[1] = v2;
  return result;
}

void sub_100AB1558(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  unsigned int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      xpc_object_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      long long __p = &v26;
      xpc_object_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          unsigned int v6 = v16;
        }
        while (!v17);
      }
      unsigned int v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/phone_numbers");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100AB1820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB18D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB1918()
{
}

void sub_100AB1928()
{
}

void *sub_100AB193C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A36E48;
  result[1] = v3;
  return result;
}

uint64_t sub_100AB1984(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A36E48;
  a2[1] = v2;
  return result;
}

void sub_100AB19B0(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100AB19B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB19F8()
{
}

void sub_100AB1A08()
{
}

__n128 sub_100AB1A1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A36EC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AB1A70(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36EC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AB1AA8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  unsigned int v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    xpc_object_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100AB1AF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB1B38()
{
}

void sub_100AB1B48()
{
}

__n128 sub_100AB1B5C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A36F48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AB1BB0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A36F48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AB1BE8(void *a1, xpc_object_t *a2)
{
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)unsigned int v6 = 0u;
  *(_OWORD *)long long __p = 0u;
  sub_100592850((uint64_t)v6, a2);
  uint64_t v3 = (void (*)(void *, void **))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(void (**)(void *, void **))(*v5 + v3);
  }
  v3(v5, v6);
  int v11 = (void **)&v9;
  sub_100047F64(&v11);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v6[0]);
  }
}

void sub_100AB1CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  *(void *)(v21 - 24) = v20;
  sub_100047F64((void ***)(v21 - 24));
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AB1CE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB1D20()
{
}

void sub_100AB1D2C(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Phone number status has changed, triggering phone number related events", buf, 2u);
  }
  sub_100AA7388(v2, *((unsigned int *)v1 + 2), *((_DWORD *)v1 + 3), (char *)v1[2]);
  operator delete();
}

void sub_100AB1DFC()
{
}

void sub_100AB1E28(void ****a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Supp Services status has changed, triggering events related events", buf, 2u);
  }
  sub_100AA7798(v2, *((unsigned int *)v1 + 2));
  operator delete();
}

void sub_100AB1EF4()
{
}

void sub_100AB1F20(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (sub_100036EA4(v1, 1) == 3)
  {
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 40);
      v3();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not CDMA based, not processing set SPC", v6, 2u);
    }
  }
}

void sub_100AB2034(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (sub_100036EA4(v1, 1) == 3)
  {
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 48);
      v3();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not CDMA based, not processing sending SPC to baseband", v6, 2u);
    }
  }
}

void sub_100AB2148(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (sub_100036EA4(v1, 1) == 3)
  {
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 56);
      v3();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not CDMA based, not processing sending AKEY to baseband", v6, 2u);
    }
  }
}

void sub_100AB225C(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (sub_100036EA4(v1, 1) == 3)
  {
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 64);
      v3();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not CDMA based, not processing service provisioning MDN", v6, 2u);
    }
  }
}

void sub_100AB2368(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (sub_100036EA4(v1, 1) == 3)
  {
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 72);
      v3();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Not CDMA based, not setting service provisioning MIN", v6, 2u);
    }
  }
}

void sub_100AB2474(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)v1 + 120);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 80);
    v3();
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(void *)v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v5, 2u);
    }
  }
}

void sub_100AB2534(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)v1 + 120);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 88);
    v3();
  }
  else
  {
    uint64_t v4 = *(NSObject **)(*(void *)v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "CDMASettings Interface not available", v5, 2u);
    }
  }
}

void sub_100AB25F4(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 104) + 288))(*(void *)(**(void **)a1 + 104), *(unsigned int *)(*(void *)a1 + 8), *(unsigned __int8 *)(*(void *)a1 + 12));
  operator delete();
}

void sub_100AB267C()
{
}

uint64_t sub_100AB26A8(uint64_t a1)
{
  return sub_100AA7EE8(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(const std::string **)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_100AB26BC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100AB26F8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100AB2734(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  if (sub_100AA7EE8(*(void *)v1, **(unsigned int **)(v1 + 8), *(const std::string **)(v1 + 16)) == 3)
  {
    uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(v1 + 8));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(uint64_t **)(v1 + 16);
      if (*((char *)v4 + 23) < 0) {
        uint64_t v4 = (uint64_t *)*v4;
      }
      int v7 = 136315138;
      long long v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Not a valid MMI (%s) to handle", (uint8_t *)&v7, 0xCu);
    }
    return 0;
  }
  else
  {
    unsigned int v6 = *(uint64_t (**)(void))(**(void **)(v2 + 104) + 280);
    return v6();
  }
}

void sub_100AB289C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)v1, *(Registry **)(*(void *)v1 + 56));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  long long v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (v8)
  {
    uint64_t v10 = v8[3];
    long long v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  long long v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void))(*(void *)v10 + 272))(v10, **(unsigned int **)(v1 + 8));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100AB29B4(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AB29D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)v1, *(Registry **)(*(void *)v1 + 56));
  char v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  long long v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (v8)
  {
    uint64_t v10 = v8[3];
    long long v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  long long v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, void))(*(void *)v10 + 280))(v10, *(void *)(v1 + 8), **(unsigned int **)(v1 + 16));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100AB2AEC(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AB2B0C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      char v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      unint64_t v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && rest::operator==())
      {
        uint64_t v5 = (void *)v3[1];
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            char v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            char v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        long long v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            long long v9 = v8;
            long long v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            long long v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            unint64_t v4 = v9;
          }
          while (!v7);
        }
        unint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_100087ED0((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    char v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_100087ED0(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_100AB2C88(uint64_t **a1, int a2)
{
  unint64_t v4 = (uint64_t *)(a1 + 1);
  char v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v3;
    do
    {
      int v7 = *((_DWORD *)v6 + 8);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        long long v9 = (uint64_t **)v6;
      }
      else {
        long long v9 = (uint64_t **)(v6 + 1);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((_DWORD *)v5 + 8) <= a2)
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          char v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_10005EE6C(v3, v5);
      sub_100087F2C((uint64_t)(v5 + 4));
      operator delete(v5);
    }
  }
}

uint64_t sub_100AB2D6C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  char v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  unint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      xpc_object_t v19 = 0;
      uint64_t v6 = *(uint64_t **)(a1 + 8);
      if (*(uint64_t **)a1 == v3)
      {
        BOOL v8 = v3;
        if (!v6) {
          goto LABEL_14;
        }
      }
      else
      {
        int v7 = v3;
        if (v6)
        {
          do
          {
            BOOL v8 = v6;
            uint64_t v6 = (uint64_t *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            BOOL v8 = (uint64_t *)v7[2];
            BOOL v9 = *v8 == (void)v7;
            int v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, (void **)v5 + 4) & 0x80) == 0)
        {
          uint64_t v10 = (uint64_t **)sub_100046ED4(a1, &v19, (void **)v5 + 4);
          goto LABEL_11;
        }
        if (!*v3)
        {
LABEL_14:
          xpc_object_t v19 = v3;
          uint64_t v10 = (uint64_t **)v3;
LABEL_15:
          uint64_t v18 = 0;
          char v11 = (uint64_t *)operator new(0x90uLL);
          uint64_t v12 = v11;
          v17[0] = v11;
          v17[1] = v3;
          if (*((char *)v5 + 55) < 0)
          {
            sub_10004FC84((unsigned char *)v11 + 32, (void *)v5[4], v5[5]);
          }
          else
          {
            long long v13 = *((_OWORD *)v5 + 2);
            void v11[6] = v5[6];
            *((_OWORD *)v11 + 2) = v13;
          }
          sub_100897414((char *)v12 + 56, (long long *)(v5 + 7));
          LOBYTE(v18) = 1;
          sub_100046C38((uint64_t **)a1, (uint64_t)v19, v10, v17[0]);
          v17[0] = 0;
          sub_1001A7358((uint64_t)v17, 0);
          goto LABEL_19;
        }
      }
      xpc_object_t v19 = v8;
      uint64_t v10 = (uint64_t **)(v8 + 1);
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_19:
      uint64_t v14 = (void *)v5[1];
      if (v14)
      {
        do
        {
          xpc_object_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          xpc_object_t v15 = (void *)v5[2];
          BOOL v9 = *v15 == (void)v5;
          uint64_t v5 = v15;
        }
        while (!v9);
      }
      uint64_t v5 = v15;
    }
    while (v15 != v4);
  }
  return a1;
}

void sub_100AB2F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1001A7358((uint64_t)&a9, 0);
  sub_10019D614(v9, *(void **)(v9 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100AB2F60(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      char v3 = (unsigned __int8 *)v2[4];
      if (v3 == (unsigned __int8 *)(v2 + 5)) {
        goto LABEL_24;
      }
      unint64_t v4 = *(unsigned __int8 **)(a1 + 16);
      while (sub_10001D294(v3 + 32, v4 + 32) && rest::operator==())
      {
        uint64_t v5 = (unsigned __int8 *)*((void *)v3 + 1);
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            char v3 = v5;
            uint64_t v5 = *(unsigned __int8 **)v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            char v3 = (unsigned __int8 *)*((void *)v6 + 2);
            BOOL v7 = *(void *)v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        BOOL v8 = (unsigned __int8 *)*((void *)v4 + 1);
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            BOOL v8 = *(unsigned __int8 **)v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (unsigned __int8 *)*((void *)v4 + 2);
            BOOL v7 = *(void *)v9 == (void)v4;
            unint64_t v4 = v9;
          }
          while (!v7);
        }
        unint64_t v4 = v9;
        if (v3 == (unsigned __int8 *)(v2 + 5)) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_10019D614((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    char v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10019D614(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_100AB30DC(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v16 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v16, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    BOOL v7 = v5;
    BOOL v8 = *a3;
    uint64_t v15 = 0;
    uint64_t v9 = (char *)operator new(0x90uLL);
    v14[0] = v9;
    v14[1] = a1 + 1;
    uint64_t v10 = v9 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v10, *(void **)v8, *((void *)v8 + 1));
      uint64_t v12 = (uint64_t *)v14[0];
    }
    else
    {
      long long v11 = *v8;
      *((void *)v9 + 6) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = (uint64_t *)v9;
    }
    *((void *)v9 + 17) = 0;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_OWORD *)(v9 + 104) = 0u;
    *(_OWORD *)(v9 + 88) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    LOBYTE(v15) = 1;
    sub_100046C38(a1, v16, v7, v12);
    uint64_t v6 = (uint64_t *)v14[0];
    v14[0] = 0;
    sub_1001A7358((uint64_t)v14, 0);
  }
  return v6;
}

void sub_100AB31D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t **sub_100AB31E8(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  BOOL v7 = a1 + 1;
  BOOL v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        BOOL v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        BOOL v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 1;
    uint64_t v10 = (char *)operator new(0x80uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 4sub_1001A7358((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *((void *)v10 + 15) = 0;
    sub_100046C38(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    sub_10008B8F0((uint64_t)v12, 0);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *sub_100AB32D0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 104);
  *(_OWORD *)long long __p = 0u;
  long long v9 = 0u;
  sub_100AA8F5C(v2, v3, v1 + 16, (const std::string *)(v1 + 40), (std::string *)(v1 + 72), v4, (uint64_t)__p);
  if (SBYTE7(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_100AB3370(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100AB3344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100AB3370(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AB3370(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_100AB33E8(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 104) + 328))(*(void *)(**(void **)a1 + 104), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12));
  operator delete();
}

void sub_100AB346C()
{
}

void CellMonitor::sendBulkHints_sync(capabilities::ct *a1, unsigned int a2, unsigned int a3, CFDictionaryRef *a4)
{
  uint64_t v6 = (uint64_t)a1;
  uint64_t v7 = (capabilities::ct *)capabilities::ct::LASDRecordMaxCount(a1);
  uint64_t v8 = capabilities::ct::LASDRecordMaxCount(v7);
  v249 = (capabilities::ct *)capabilities::ct::LASDRecordMaxCount((capabilities::ct *)v8);
  if (capabilities::ct::LASDRecordMaxCount(v249) < 0) {
    __assert_rtn("sendBulkHints_sync", "CellRegistrationHints.cpp", 30, "capabilities::ct::LASDRecordMaxCount() <= std::numeric_limits<CFIndex>::max()");
  }
  unsigned int v251 = a3;
  v288 = 0;
  v289 = 0;
  unint64_t v290 = 0;
  v285 = 0;
  v286 = 0;
  unint64_t v287 = 0;
  v255 = a4;
  uint64_t v254 = v6;
  v253 = v7;
  if (CFDictionaryContainsKey(*a4, @"C2K"))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*a4, @"C2K");
    CFDictionaryRef v10 = Value;
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 != CFDictionaryGetTypeID()) {
        CFDictionaryRef v10 = 0;
      }
    }
    CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(v10, @"EVDO");
    CFArrayRef v13 = v12;
    if (v12)
    {
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 != CFArrayGetTypeID()) {
        CFArrayRef v13 = 0;
      }
    }
    CFIndex Count = CFArrayGetCount(v13);
    uint64_t v16 = Count;
    if (Count >= 10) {
      uint64_t v17 = 10;
    }
    else {
      uint64_t v17 = Count;
    }
    uint64_t v18 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I CDMA EVDO records %ld", buf, 0xCu);
    }
    v252 = (ctu::cf *)v8;
    if (v16 < 1)
    {
      xpc_object_t v19 = 0;
      uint64_t v21 = 0;
      unint64_t v20 = 0;
    }
    else
    {
      xpc_object_t v19 = 0;
      unint64_t v20 = 0;
      uint64_t v21 = 0;
      CFIndex v22 = 0;
      do
      {
        CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v13, v22);
        CFArrayRef v24 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v25 = CFGetTypeID(ValueAtIndex);
          if (v25 != CFArrayGetTypeID()) {
            CFArrayRef v24 = 0;
          }
        }
        memset(buf, 0, 20);
        xpc_object_t v26 = (unsigned __int8 *)CFArrayGetValueAtIndex(v24, 0);
        char v27 = v26;
        if (v26)
        {
          CFTypeID v28 = CFGetTypeID(v26);
          if (v28 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)buf, v27, v29);
          }
        }
        long long v30 = (unsigned __int16 *)CFArrayGetValueAtIndex(v24, 1);
        uint64_t v31 = v30;
        if (v30)
        {
          CFTypeID v32 = CFGetTypeID(v30);
          if (v32 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf[2], v31, v33);
          }
        }
        CFDataRef v34 = (const __CFData *)CFArrayGetValueAtIndex(v24, 2);
        CFDataRef v35 = v34;
        if (v34)
        {
          CFTypeID v36 = CFGetTypeID(v34);
          if (v36 == CFDataGetTypeID()) {
            CFDataRef v37 = v35;
          }
          else {
            CFDataRef v37 = 0;
          }
        }
        else
        {
          CFDataRef v37 = 0;
        }
        *(_OWORD *)&uint8_t buf[4] = *(_OWORD *)CFDataGetBytePtr(v37);
        if ((unint64_t)v21 >= v20)
        {
          unint64_t v39 = 0xCCCCCCCCCCCCCCCDLL * ((v21 - v19) >> 2) + 1;
          if (v39 > 0xCCCCCCCCCCCCCCCLL) {
            sub_10006A748();
          }
          if (0x999999999999999ALL * ((uint64_t)(v20 - (void)v19) >> 2) > v39) {
            unint64_t v39 = 0x999999999999999ALL * ((uint64_t)(v20 - (void)v19) >> 2);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - (void)v19) >> 2) >= 0x666666666666666) {
            unint64_t v40 = 0xCCCCCCCCCCCCCCCLL;
          }
          else {
            unint64_t v40 = v39;
          }
          if (v40) {
            unint64_t v40 = (unint64_t)sub_100AB5C2C(v40);
          }
          else {
            uint64_t v41 = 0;
          }
          long long v42 = *(_OWORD *)buf;
          unint64_t v43 = v40 + 4 * ((v21 - v19) >> 2);
          *(_DWORD *)(v43 + 16) = *(_DWORD *)&buf[16];
          *(_OWORD *)unint64_t v43 = v42;
          if (v21 == v19)
          {
            uint64_t v46 = (char *)(v40 + 4 * ((v21 - v19) >> 2));
          }
          else
          {
            unint64_t v44 = v40 + 4 * ((v21 - v19) >> 2);
            do
            {
              long long v45 = *(_OWORD *)(v21 - 20);
              uint64_t v46 = (char *)(v44 - 20);
              *(_DWORD *)(v44 - 4) = *((_DWORD *)v21 - 1);
              *(_OWORD *)(v44 - 2sub_1001A7358((uint64_t)&a9, 0) = v45;
              v21 -= 20;
              v44 -= 20;
            }
            while (v21 != v19);
          }
          unint64_t v20 = v40 + 20 * v41;
          uint64_t v21 = (char *)(v43 + 20);
          if (v19) {
            operator delete(v19);
          }
          xpc_object_t v19 = v46;
        }
        else
        {
          long long v38 = *(_OWORD *)buf;
          *((_DWORD *)v21 + 4) = *(_DWORD *)&buf[16];
          *(_OWORD *)uint64_t v21 = v38;
          v21 += 20;
        }
        ++v22;
      }
      while (v22 != v17);
    }
    if (v285)
    {
      v286 = v285;
      operator delete(v285);
    }
    v285 = v19;
    v286 = v21;
    unint64_t v287 = v20;
    CFArrayRef v47 = (const __CFArray *)CFDictionaryGetValue(v10, @"1X");
    CFArrayRef v48 = v47;
    if (v47)
    {
      CFTypeID v49 = CFGetTypeID(v47);
      if (v49 != CFArrayGetTypeID()) {
        CFArrayRef v48 = 0;
      }
    }
    CFIndex v50 = CFArrayGetCount(v48);
    uint64_t v51 = v50;
    if (v50 >= 10) {
      uint64_t v52 = 10;
    }
    else {
      uint64_t v52 = v50;
    }
    std::string::size_type v53 = *(NSObject **)(v254 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v52;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I CDMA 1X records %ld", buf, 0xCu);
    }
    if (v51 < 1)
    {
      int v54 = 0;
      __int16 v77 = 0;
      unint64_t v55 = 0;
    }
    else
    {
      int v54 = 0;
      unint64_t v55 = 0;
      uint64_t v56 = 0;
      CFIndex v57 = 0;
      do
      {
        CFArrayRef v58 = (const __CFArray *)CFArrayGetValueAtIndex(v48, v57);
        CFArrayRef v59 = v58;
        if (v58)
        {
          CFTypeID v60 = CFGetTypeID(v58);
          if (v60 != CFArrayGetTypeID()) {
            CFArrayRef v59 = 0;
          }
        }
        *(void *)std::string buf = 0;
        dispatch_group_t v61 = (unsigned __int8 *)CFArrayGetValueAtIndex(v59, 0);
        Class v62 = v61;
        if (v61)
        {
          CFTypeID v63 = CFGetTypeID(v61);
          if (v63 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)buf, v62, v64);
          }
        }
        Class v65 = (unsigned __int16 *)CFArrayGetValueAtIndex(v59, 1);
        id v66 = v65;
        if (v65)
        {
          CFTypeID v67 = CFGetTypeID(v65);
          if (v67 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf[2], v66, v68);
          }
        }
        char v69 = (unsigned __int16 *)CFArrayGetValueAtIndex(v59, 2);
        char v70 = v69;
        if (v69)
        {
          CFTypeID v71 = CFGetTypeID(v69);
          if (v71 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf[4], v70, v72);
          }
        }
        uint64_t v73 = (unsigned __int16 *)CFArrayGetValueAtIndex(v59, 3);
        uint64_t v74 = v73;
        if (v73)
        {
          CFTypeID v75 = CFGetTypeID(v73);
          if (v75 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf[6], v74, v76);
          }
        }
        if ((unint64_t)v56 >= v55)
        {
          uint64_t v78 = (v56 - v54) >> 3;
          unint64_t v79 = v78 + 1;
          if ((unint64_t)(v78 + 1) >> 61) {
            sub_10006A748();
          }
          if ((uint64_t)(v55 - (void)v54) >> 2 > v79) {
            unint64_t v79 = (uint64_t)(v55 - (void)v54) >> 2;
          }
          if (v55 - (unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v80 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v80 = v79;
          }
          if (v80) {
            unint64_t v80 = (unint64_t)sub_100048350(v80);
          }
          else {
            uint64_t v81 = 0;
          }
          long long v82 = (char *)(v80 + 8 * v78);
          *(void *)long long v82 = *(void *)buf;
          __int16 v77 = v82 + 8;
          while (v56 != v54)
          {
            uint64_t v83 = *((void *)v56 - 1);
            v56 -= 8;
            *((void *)v82 - 1) = v83;
            v82 -= 8;
          }
          unint64_t v55 = v80 + 8 * v81;
          if (v54) {
            operator delete(v54);
          }
          int v54 = v82;
        }
        else
        {
          *(void *)uint64_t v56 = *(void *)buf;
          __int16 v77 = v56 + 8;
        }
        ++v57;
        uint64_t v56 = v77;
      }
      while (v57 != v52);
    }
    if (v288)
    {
      v289 = v288;
      operator delete(v288);
    }
    v288 = v54;
    v289 = v77;
    unint64_t v290 = v55;
    uint64_t v6 = v254;
    uint64_t v8 = (uint64_t)v252;
    uint64_t v7 = v253;
  }
  memset(buf, 0, 24);
  if (CFDictionaryContainsKey(*v255, @"GSM"))
  {
    CFArrayRef v84 = (const __CFArray *)CFDictionaryGetValue(*v255, @"GSM");
    CFArrayRef v85 = v84;
    if (v84)
    {
      CFTypeID v86 = CFGetTypeID(v84);
      if (v86 == CFArrayGetTypeID()) {
        CFArrayRef v87 = v85;
      }
      else {
        CFArrayRef v87 = 0;
      }
    }
    else
    {
      CFArrayRef v87 = 0;
    }
    sub_100AB4D50((unint64_t *)__p, v6, (uint64_t)"GSM", v87, (uint64_t)v7);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v284;
  }
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v284 = 0;
  if (CFDictionaryContainsKey(*v255, @"UMTS"))
  {
    CFArrayRef v88 = (const __CFArray *)CFDictionaryGetValue(*v255, @"UMTS");
    CFArrayRef v89 = v88;
    if (v88)
    {
      CFTypeID v90 = CFGetTypeID(v88);
      if (v90 == CFArrayGetTypeID()) {
        CFArrayRef v91 = v89;
      }
      else {
        CFArrayRef v91 = 0;
      }
    }
    else
    {
      CFArrayRef v91 = 0;
    }
    sub_100AB4D50((unint64_t *)v281, v6, (uint64_t)"UMTS", v91, (uint64_t)v7);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    *(_OWORD *)long long __p = *(_OWORD *)v281;
    unint64_t v284 = v282;
  }
  v281[0] = 0;
  v281[1] = 0;
  unint64_t v282 = 0;
  if (CFDictionaryContainsKey(*v255, @"LTE"))
  {
    CFArrayRef v92 = (const __CFArray *)CFDictionaryGetValue(*v255, @"LTE");
    CFArrayRef v93 = v92;
    if (v92)
    {
      CFTypeID v94 = CFGetTypeID(v92);
      if (v94 == CFArrayGetTypeID()) {
        CFArrayRef v95 = v93;
      }
      else {
        CFArrayRef v95 = 0;
      }
    }
    else
    {
      CFArrayRef v95 = 0;
    }
    CFIndex v96 = CFArrayGetCount(v95);
    if (v96 < v8) {
      uint64_t v8 = v96;
    }
    id v97 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v291 = 134217984;
      *(void *)&v291[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I LTE records %ld", v291, 0xCu);
    }
    if (v8 < 1)
    {
      v102 = 0;
      id v103 = 0;
      unint64_t v104 = 0;
    }
    else
    {
      CFArrayRef v98 = (const __CFArray *)CFArrayGetValueAtIndex(v95, 0);
      CFArrayRef v99 = v98;
      if (v98)
      {
        CFTypeID v100 = CFGetTypeID(v98);
        if (v100 == CFArrayGetTypeID()) {
          CFArrayRef v101 = v99;
        }
        else {
          CFArrayRef v101 = 0;
        }
      }
      else
      {
        CFArrayRef v101 = 0;
      }
      v256 = (ctu::cf *)v8;
      if (CFArrayGetCount(v101) < 6)
      {
        v102 = 0;
        unint64_t v104 = 0;
        v142 = 0;
        unint64_t v143 = 0;
        id v103 = 0;
        for (CFIndex i = 0; (ctu::cf *)i != v256; ++i)
        {
          CFArrayRef v145 = (const __CFArray *)CFArrayGetValueAtIndex(v95, i);
          CFArrayRef v146 = v145;
          if (v145)
          {
            CFTypeID v147 = CFGetTypeID(v145);
            if (v147 != CFArrayGetTypeID()) {
              CFArrayRef v146 = 0;
            }
          }
          memset(v291, 0, sizeof(v291));
          v148 = (unsigned __int16 *)CFArrayGetValueAtIndex(v146, 0);
          v149 = v148;
          if (v148)
          {
            CFTypeID v150 = CFGetTypeID(v148);
            if (v150 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)v291, v149, v151);
            }
          }
          v152 = (unsigned __int16 *)CFArrayGetValueAtIndex(v146, 1);
          v153 = v152;
          if (v152)
          {
            CFTypeID v154 = CFGetTypeID(v152);
            if (v154 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[2], v153, v155);
            }
          }
          v156 = (unsigned int *)CFArrayGetValueAtIndex(v146, 2);
          v157 = v156;
          if (v156)
          {
            CFTypeID v158 = CFGetTypeID(v156);
            if (v158 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[8], v157, v159);
            }
          }
          v160 = (unsigned __int8 *)CFArrayGetValueAtIndex(v146, 3);
          v161 = v160;
          if (v160)
          {
            CFTypeID v162 = CFGetTypeID(v160);
            if (v162 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[4], v161, v163);
            }
          }
          v164 = (unsigned __int8 *)CFArrayGetValueAtIndex(v146, 4);
          v165 = v164;
          if (v164)
          {
            CFTypeID v166 = CFGetTypeID(v164);
            if (v166 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[12], v165, v167);
            }
          }
          if ((unint64_t)v103 >= v143)
          {
            uint64_t v168 = (v103 - v142) >> 4;
            unint64_t v169 = v168 + 1;
            if ((unint64_t)(v168 + 1) >> 60) {
              sub_10006A748();
            }
            if ((uint64_t)(v143 - (void)v142) >> 3 > v169) {
              unint64_t v169 = (uint64_t)(v143 - (void)v142) >> 3;
            }
            if (v143 - (unint64_t)v142 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v170 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v170 = v169;
            }
            if (v170) {
              unint64_t v170 = (unint64_t)sub_1009C886C(v170);
            }
            else {
              uint64_t v171 = 0;
            }
            v172 = (char *)(v170 + 16 * v168);
            *(_OWORD *)v172 = *(_OWORD *)v291;
            v102 = v172;
            while (v103 != v142)
            {
              uint64_t v173 = *((void *)v103 - 2);
              v103 -= 16;
              uint64_t v174 = *(void *)(v103 + 7);
              *((void *)v102 - 2) = v173;
              v102 -= 16;
              *(void *)(v102 + 7) = v174;
            }
            unint64_t v104 = v170 + 16 * v171;
            id v103 = v172 + 16;
            if (v142) {
              operator delete(v142);
            }
            v142 = v102;
            unint64_t v143 = v104;
          }
          else
          {
            *(_OWORD *)id v103 = *(_OWORD *)v291;
            v103 += 16;
          }
        }
      }
      else
      {
        v102 = 0;
        unint64_t v104 = 0;
        unint64_t v105 = 0;
        id v103 = 0;
        for (CFIndex j = 0; (ctu::cf *)j != v256; ++j)
        {
          CFArrayRef v107 = (const __CFArray *)CFArrayGetValueAtIndex(v95, j);
          CFArrayRef v108 = v107;
          if (v107)
          {
            CFTypeID v109 = CFGetTypeID(v107);
            if (v109 != CFArrayGetTypeID()) {
              CFArrayRef v108 = 0;
            }
          }
          memset(v291, 0, sizeof(v291));
          v110 = (unsigned __int16 *)CFArrayGetValueAtIndex(v108, 0);
          long long v111 = v110;
          if (v110)
          {
            CFTypeID v112 = CFGetTypeID(v110);
            if (v112 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)v291, v111, v113);
            }
          }
          long long v114 = (unsigned __int16 *)CFArrayGetValueAtIndex(v108, 1);
          long long v115 = v114;
          if (v114)
          {
            CFTypeID v116 = CFGetTypeID(v114);
            if (v116 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[2], v115, v117);
            }
          }
          long long v118 = (unsigned int *)CFArrayGetValueAtIndex(v108, 2);
          long long v119 = v118;
          if (v118)
          {
            CFTypeID v120 = CFGetTypeID(v118);
            if (v120 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[8], v119, v121);
            }
          }
          long long v122 = (unsigned __int8 *)CFArrayGetValueAtIndex(v108, 3);
          long long v123 = v122;
          if (v122)
          {
            CFTypeID v124 = CFGetTypeID(v122);
            if (v124 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[4], v123, v125);
            }
          }
          v126 = (unsigned __int8 *)CFArrayGetValueAtIndex(v108, 4);
          v127 = v126;
          if (v126)
          {
            CFTypeID v128 = CFGetTypeID(v126);
            if (v128 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[12], v127, v129);
            }
          }
          if (!v291[14]) {
            v291[14] = 1;
          }
          v291[13] = 0;
          v130 = (unsigned __int8 *)CFArrayGetValueAtIndex(v108, 5);
          uint64_t v131 = v130;
          if (v130)
          {
            CFTypeID v132 = CFGetTypeID(v130);
            if (v132 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v291[13], v131, v133);
            }
          }
          if ((unint64_t)v103 >= v105)
          {
            uint64_t v134 = (v103 - v102) >> 4;
            unint64_t v135 = v134 + 1;
            if ((unint64_t)(v134 + 1) >> 60) {
              sub_10006A748();
            }
            if ((uint64_t)(v105 - (void)v102) >> 3 > v135) {
              unint64_t v135 = (uint64_t)(v105 - (void)v102) >> 3;
            }
            if (v105 - (unint64_t)v102 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v136 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v136 = v135;
            }
            if (v136) {
              unint64_t v136 = (unint64_t)sub_1009C886C(v136);
            }
            else {
              uint64_t v137 = 0;
            }
            long long v138 = (_OWORD *)(v136 + 16 * v134);
            *long long v138 = *(_OWORD *)v291;
            long long v139 = v138;
            while (v103 != v102)
            {
              uint64_t v140 = *((void *)v103 - 2);
              v103 -= 16;
              uint64_t v141 = *(void *)(v103 + 7);
              *((void *)v139-- - 2) = v140;
              *(void *)((char *)v139 + 7) = v141;
            }
            unint64_t v104 = v136 + 16 * v137;
            id v103 = (char *)(v138 + 1);
            if (v102) {
              operator delete(v102);
            }
            v102 = (char *)v139;
            unint64_t v105 = v104;
          }
          else
          {
            *(_OWORD *)id v103 = *(_OWORD *)v291;
            v103 += 16;
          }
        }
      }
    }
    if (v281[0])
    {
      v281[1] = v281[0];
      operator delete(v281[0]);
    }
    v281[0] = v102;
    v281[1] = v103;
    unint64_t v282 = v104;
    uint64_t v6 = v254;
    uint64_t v7 = v253;
  }
  memset(v291, 0, sizeof(v291));
  unint64_t v292 = 0;
  if (CFDictionaryContainsKey(*v255, @"TDSCDMA"))
  {
    CFArrayRef v175 = (const __CFArray *)CFDictionaryGetValue(*v255, @"TDSCDMA");
    CFArrayRef v176 = v175;
    if (v175)
    {
      CFTypeID v177 = CFGetTypeID(v175);
      if (v177 == CFArrayGetTypeID()) {
        CFArrayRef v178 = v176;
      }
      else {
        CFArrayRef v178 = 0;
      }
    }
    else
    {
      CFArrayRef v178 = 0;
    }
    sub_100AB4D50((unint64_t *)v279, v6, (uint64_t)"TDS", v178, (uint64_t)v7);
    if (*(void *)v291)
    {
      *(void *)&v291[8] = *(void *)v291;
      operator delete(*(void **)v291);
    }
    *(_OWORD *)v291 = *(_OWORD *)v279;
    unint64_t v292 = v280;
  }
  v279[0] = 0;
  v279[1] = 0;
  unint64_t v280 = 0;
  if (CFDictionaryContainsKey(*v255, @"NR"))
  {
    CFArrayRef v179 = (const __CFArray *)CFDictionaryGetValue(*v255, @"NR");
    CFArrayRef v180 = v179;
    if (v179)
    {
      CFTypeID v181 = CFGetTypeID(v179);
      if (v181 == CFArrayGetTypeID()) {
        CFArrayRef v182 = v180;
      }
      else {
        CFArrayRef v182 = 0;
      }
    }
    else
    {
      CFArrayRef v182 = 0;
    }
    CFIndex v183 = CFArrayGetCount(v182);
    if (v183 >= (uint64_t)v249) {
      uint64_t v184 = (uint64_t)v249;
    }
    else {
      uint64_t v184 = v183;
    }
    v185 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v294 = 134217984;
      *(void *)&v294[4] = v184;
      _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, "#I NR records %ld", v294, 0xCu);
    }
    if (v184 < 1)
    {
      v186 = 0;
      v188 = 0;
      unint64_t v187 = 0;
    }
    else
    {
      v186 = 0;
      unint64_t v187 = 0;
      v188 = 0;
      for (CFIndex k = 0; k != v184; ++k)
      {
        CFArrayRef v190 = (const __CFArray *)CFArrayGetValueAtIndex(v182, k);
        CFArrayRef v191 = v190;
        if (v190)
        {
          CFTypeID v192 = CFGetTypeID(v190);
          if (v192 != CFArrayGetTypeID()) {
            CFArrayRef v191 = 0;
          }
        }
        memset(v294, 0, sizeof(v294));
        int v295 = 0;
        v193 = (unsigned __int16 *)CFArrayGetValueAtIndex(v191, 0);
        v194 = v193;
        if (v193)
        {
          CFTypeID v195 = CFGetTypeID(v193);
          if (v195 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)v294, v194, v196);
          }
        }
        v197 = (unsigned __int16 *)CFArrayGetValueAtIndex(v191, 1);
        v198 = v197;
        if (v197)
        {
          CFTypeID v199 = CFGetTypeID(v197);
          if (v199 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v294[2], v198, v200);
          }
        }
        v201 = (unsigned int *)CFArrayGetValueAtIndex(v191, 2);
        v202 = v201;
        if (v201)
        {
          CFTypeID v203 = CFGetTypeID(v201);
          if (v203 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v294[8], v202, v204);
          }
        }
        v205 = (unsigned __int16 *)CFArrayGetValueAtIndex(v191, 3);
        v206 = v205;
        if (v205)
        {
          CFTypeID v207 = CFGetTypeID(v205);
          if (v207 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v294[4], v206, v208);
          }
        }
        v209 = (unsigned __int16 *)CFArrayGetValueAtIndex(v191, 4);
        v210 = v209;
        if (v209)
        {
          CFTypeID v211 = CFGetTypeID(v209);
          if (v211 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v294[12], v210, v212);
          }
        }
        v213 = (unsigned __int8 *)CFArrayGetValueAtIndex(v191, 5);
        v214 = v213;
        if (v213)
        {
          CFTypeID v215 = CFGetTypeID(v213);
          if (v215 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v294[14], v214, v216);
          }
        }
        v217 = (unsigned int *)CFArrayGetValueAtIndex(v191, 6);
        v218 = v217;
        if (v217)
        {
          CFTypeID v219 = CFGetTypeID(v217);
          if (v219 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v295, v218, v220);
          }
        }
        if ((unint64_t)v188 >= v187)
        {
          unint64_t v222 = 0xCCCCCCCCCCCCCCCDLL * ((v188 - v186) >> 2) + 1;
          if (v222 > 0xCCCCCCCCCCCCCCCLL) {
            sub_10006A748();
          }
          if (0x999999999999999ALL * ((uint64_t)(v187 - (void)v186) >> 2) > v222) {
            unint64_t v222 = 0x999999999999999ALL * ((uint64_t)(v187 - (void)v186) >> 2);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v187 - (void)v186) >> 2) >= 0x666666666666666) {
            unint64_t v223 = 0xCCCCCCCCCCCCCCCLL;
          }
          else {
            unint64_t v223 = v222;
          }
          if (v223) {
            unint64_t v223 = (unint64_t)sub_100AB5C2C(v223);
          }
          else {
            uint64_t v224 = 0;
          }
          long long v225 = *(_OWORD *)v294;
          unint64_t v226 = v223 + 4 * ((v188 - v186) >> 2);
          *(_DWORD *)(v226 + 16) = v295;
          *(_OWORD *)unint64_t v226 = v225;
          if (v188 == v186)
          {
            v229 = (unsigned char *)(v223 + 4 * ((v188 - v186) >> 2));
          }
          else
          {
            unint64_t v227 = v223 + 4 * ((v188 - v186) >> 2);
            do
            {
              long long v228 = *(_OWORD *)(v188 - 20);
              v229 = (unsigned char *)(v227 - 20);
              *(_DWORD *)(v227 - 4) = *((_DWORD *)v188 - 1);
              *(_OWORD *)(v227 - 2sub_1001A7358((uint64_t)&a9, 0) = v228;
              v188 -= 20;
              v227 -= 20;
            }
            while (v188 != v186);
          }
          unint64_t v187 = v223 + 20 * v224;
          v188 = (char *)(v226 + 20);
          if (v186) {
            operator delete(v186);
          }
          v186 = v229;
        }
        else
        {
          long long v221 = *(_OWORD *)v294;
          *((_DWORD *)v188 + 4) = v295;
          *(_OWORD *)v188 = v221;
          v188 += 20;
        }
      }
    }
    if (v279[0])
    {
      v279[1] = v279[0];
      operator delete(v279[0]);
    }
    v279[0] = v186;
    v279[1] = v188;
    unint64_t v280 = v187;
    uint64_t v6 = v254;
  }
  if (CFDictionaryContainsKey(*v255, @"Bootstrap"))
  {
    v230 = (BOOL *)CFDictionaryGetValue(*v255, @"Bootstrap");
    v231 = v230;
    v294[0] = 0;
    if (v230)
    {
      CFTypeID v232 = CFGetTypeID(v230);
      if (v232 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)v294, v231, v233);
      }
    }
    BOOL v234 = v294[0] != 0;
  }
  else
  {
    BOOL v234 = 0;
  }
  uint64_t v235 = *(void *)(v6 + 80);
  v277 = 0;
  v278 = 0;
  v276 = 0;
  v236 = v288;
  int64_t v237 = v289 - v288;
  if (v289 != v288)
  {
    if (v237 < 0) {
      sub_10006A748();
    }
    v276 = sub_100048350(v237 >> 3);
    v278 = (char *)v276 + 8 * v238;
    memmove(v276, v236, v237);
    v277 = (char *)v276 + 8 * (v237 >> 3);
  }
  v273 = 0;
  v274 = 0;
  v275 = 0;
  v239 = v285;
  int64_t v240 = v286 - v285;
  if (v286 != v285)
  {
    if (0xCCCCCCCCCCCCCCCDLL * (v240 >> 2) > 0xCCCCCCCCCCCCCCCLL) {
      sub_10006A748();
    }
    v273 = sub_100AB5C2C(0xCCCCCCCCCCCCCCCDLL * (v240 >> 2));
    v275 = (char *)v273 + 20 * v241;
    memmove(v273, v239, v240);
    v274 = (char *)v273 + 4 * (v240 >> 2);
  }
  v270 = 0;
  v271 = 0;
  uint64_t v272 = 0;
  sub_100AB5C74(&v270, *(const void **)buf, *(uint64_t *)&buf[8], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 1));
  v267 = 0;
  v268 = 0;
  uint64_t v269 = 0;
  sub_100AB5C74(&v267, __p[0], (uint64_t)__p[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 1));
  v264 = 0;
  v265 = 0;
  v266 = 0;
  v242 = v281[0];
  int64_t v243 = (char *)v281[1] - (char *)v281[0];
  if (v281[1] != v281[0])
  {
    if (v243 < 0) {
      sub_10006A748();
    }
    v264 = sub_1009C886C(v243 >> 4);
    v266 = (char *)v264 + 16 * v244;
    memmove(v264, v242, v243 - 1);
    v265 = (char *)v264 + 16 * (v243 >> 4);
  }
  v261 = 0;
  v262 = 0;
  uint64_t v263 = 0;
  sub_100AB5C74(&v261, *(const void **)v291, *(uint64_t *)&v291[8], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)&v291[8] - *(void *)v291) >> 1));
  v258 = 0;
  v259 = 0;
  v260 = 0;
  v245 = v279[0];
  int64_t v246 = (char *)v279[1] - (char *)v279[0];
  if (v279[1] != v279[0])
  {
    if (0xCCCCCCCCCCCCCCCDLL * (v246 >> 2) > 0xCCCCCCCCCCCCCCCLL) {
      sub_10006A748();
    }
    v258 = sub_100AB5C2C(0xCCCCCCCCCCCCCCCDLL * (v246 >> 2));
    v260 = (char *)v258 + 20 * v247;
    memmove(v258, v245, v246);
    v259 = (char *)v258 + 4 * (v246 >> 2);
  }
  (*(void (**)(uint64_t, void, void, BOOL, void **, void **, void **, void **, void **, void **, void **))(*(void *)v235 + 48))(v235, v251, a2, v234, &v276, &v273, &v270, &v267, &v264, &v261, &v258);
  if (v258)
  {
    v259 = (char *)v258;
    operator delete(v258);
  }
  if (v261)
  {
    v262 = v261;
    operator delete(v261);
  }
  if (v264)
  {
    v265 = (char *)v264;
    operator delete(v264);
  }
  if (v267)
  {
    v268 = v267;
    operator delete(v267);
  }
  if (v270)
  {
    v271 = v270;
    operator delete(v270);
  }
  if (v273)
  {
    v274 = (char *)v273;
    operator delete(v273);
  }
  if (v276)
  {
    v277 = (char *)v276;
    operator delete(v276);
  }
  memset(v294, 0, sizeof(v294));
  CellMonitor::getModel_sync(v254, v251, v294);
  if (*(void *)v294)
  {
    (*(void (**)(void, char **, char **, uint8_t *, void **, void **, uint8_t *, void **))(**(void **)v294 + 120))(*(void *)v294, &v288, &v285, buf, __p, v281, v291, v279);
  }
  else
  {
    v248 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v254 + 56) + 16))(*(void *)(v254 + 56), v251);
    if (os_log_type_enabled(v248, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v257 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v248, OS_LOG_TYPE_ERROR, "Could not get model for recording time of last bulk hints", v257, 2u);
    }
  }
  if (*(void *)&v294[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v294[8]);
  }
  if (v279[0])
  {
    v279[1] = v279[0];
    operator delete(v279[0]);
  }
  if (*(void *)v291)
  {
    *(void *)&v291[8] = *(void *)v291;
    operator delete(*(void **)v291);
  }
  if (v281[0])
  {
    v281[1] = v281[0];
    operator delete(v281[0]);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v285)
  {
    v286 = v285;
    operator delete(v285);
  }
  if (v288)
  {
    v289 = v288;
    operator delete(v288);
  }
}

void sub_100AB4B40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54)
{
  uint64_t v56 = *(std::__shared_weak_count **)(v54 - 120);
  if (v56) {
    sub_10004D2C8(v56);
  }
  if (__p) {
    operator delete(__p);
  }
  CFIndex v57 = *(void **)(v54 - 192);
  if (v57)
  {
    *(void *)(v54 - 184) = v57;
    operator delete(v57);
  }
  if (a49) {
    operator delete(a49);
  }
  if (a53) {
    operator delete(a53);
  }
  CFArrayRef v58 = *(void **)(v54 - 160);
  if (v58)
  {
    *(void *)(v54 - 152) = v58;
    operator delete(v58);
  }
  CFArrayRef v59 = *(void **)(v54 - 240);
  if (v59)
  {
    *(void *)(v54 - 232) = v59;
    operator delete(v59);
  }
  CFTypeID v60 = *(void **)(v54 - 216);
  if (v60)
  {
    *(void *)(v54 - 208) = v60;
    operator delete(v60);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AB4D50(unint64_t *a1, uint64_t a2, uint64_t a3, CFArrayRef theArray, uint64_t a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v8 = 0;
  if (a5 >= 1)
  {
    CFIndex v50 = Count;
    if (Count >= 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      CFIndex v52 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v52);
        CFDictionaryRef v11 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 == CFDictionaryGetTypeID()) {
            CFDictionaryRef v13 = v11;
          }
          else {
            CFDictionaryRef v13 = 0;
          }
        }
        else
        {
          CFDictionaryRef v13 = 0;
        }
        *(_WORD *)&uint8_t buf[8] = 0;
        *(void *)std::string buf = 0;
        CFDictionaryRef Value = (unsigned __int16 *)CFDictionaryGetValue(v13, @"MCC");
        uint64_t v15 = Value;
        if (Value)
        {
          CFTypeID v16 = CFGetTypeID(Value);
          if (v16 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)buf, v15, v17);
          }
        }
        uint64_t v18 = (unsigned __int16 *)CFDictionaryGetValue(v13, @"MNC");
        xpc_object_t v19 = v18;
        if (v18)
        {
          CFTypeID v20 = CFGetTypeID(v18);
          if (v20 == CFNumberGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&buf[2], v19, v21);
          }
        }
        CFArrayRef v22 = (const __CFArray *)CFDictionaryGetValue(v13, @"UARFCN");
        CFArrayRef v23 = v22;
        if (v22)
        {
          CFTypeID v24 = CFGetTypeID(v22);
          if (v24 == CFArrayGetTypeID()) {
            CFArrayRef v25 = v23;
          }
          else {
            CFArrayRef v25 = 0;
          }
        }
        else
        {
          CFArrayRef v25 = 0;
        }
        uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 0;
        CFIndex v26 = CFArrayGetCount(v25);
        if (v26 >= 1 && v9 < a5)
        {
          CFIndex v27 = 0;
          do
          {
            CFTypeID v28 = (unsigned __int16 *)CFArrayGetValueAtIndex(v25, v27);
            CFNumberRef v29 = v28;
            if (v28)
            {
              CFTypeID v30 = CFGetTypeID(v28);
              if (v30 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&buf[6], v29, v31);
              }
            }
            unint64_t v32 = a1[2];
            if ((unint64_t)v8 >= v32)
            {
              CFDataRef v34 = (_WORD *)*a1;
              unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)v8 - *a1) >> 1);
              unint64_t v36 = v35 + 1;
              if (v35 + 1 > 0x1999999999999999) {
                sub_10006A748();
              }
              unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v32 - (void)v34) >> 1);
              if (2 * v37 > v36) {
                unint64_t v36 = 2 * v37;
              }
              if (v37 >= 0xCCCCCCCCCCCCCCCLL) {
                unint64_t v38 = 0x1999999999999999;
              }
              else {
                unint64_t v38 = v36;
              }
              if (v38) {
                unint64_t v38 = (unint64_t)sub_100AB5D1C(v38);
              }
              else {
                uint64_t v39 = 0;
              }
              uint64_t v40 = *(void *)buf;
              unint64_t v41 = v38 + 10 * v35;
              *(_WORD *)(v41 + 8) = *(_WORD *)&buf[8];
              *(void *)unint64_t v41 = v40;
              if (v8 == v34)
              {
                long long v45 = v8;
                unint64_t v42 = v38 + 10 * v35;
              }
              else
              {
                unint64_t v42 = v38 + 10 * v35;
                do
                {
                  uint64_t v43 = *(void *)(v8 - 5);
                  v8 -= 5;
                  __int16 v44 = v8[4];
                  *(void *)(v42 - 1sub_1001A7358((uint64_t)&a9, 0) = v43;
                  v42 -= 10;
                  *(_WORD *)(v42 + 8) = v44;
                }
                while (v8 != v34);
                long long v45 = (void *)*a1;
              }
              uint64_t v8 = (_WORD *)(v41 + 10);
              *a1 = v42;
              a1[1] = v41 + 10;
              a1[2] = v38 + 10 * v39;
              if (v45) {
                operator delete(v45);
              }
            }
            else
            {
              uint64_t v33 = *(void *)buf;
              v8[4] = *(_WORD *)&buf[8];
              *(void *)uint64_t v8 = v33;
              v8 += 5;
            }
            a1[1] = (unint64_t)v8;
            ++v9;
            ++v27;
          }
          while (v27 < v26 && v9 < a5);
        }
        ++v52;
      }
      while (v52 < v50 && v9 < a5);
    }
  }
  uint64_t v46 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)v8 - *a1) >> 1);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = a3;
    __int16 v54 = 2048;
    unint64_t v55 = v47;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %s records %ld", buf, 0x16u);
  }
}

void sub_100AB5110(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CellMonitor::sendStatusHint_sync(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 80);
    memset(v4, 0, sizeof(v4));
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v2 + 56))(v2, 3, a2, v4);
    *(void *)std::string buf = v4;
    sub_100AB5D64((void ***)buf);
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Unsupported LASD status hint: %s", buf, 0xCu);
    }
  }
}

void sub_100AB5230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_100AB5D64(&a13);
  _Unwind_Resume(a1);
}

void CellMonitor::lapsMccsFetched(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  __p[1] = 0;
  uint64_t v5 = 0;
  __p[0] = 0;
  sub_1003A10E0(__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, v3);
  operator new();
}

void non-virtual thunk to'CellMonitor::lapsMccsFetched(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void CellMonitor::lapsPlmnsFetched(uint64_t a1, uint64_t a2, int **a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  __p[1] = 0;
  uint64_t v5 = 0;
  __p[0] = 0;
  sub_1003A2684((char *)__p, *a3, a3[1], a3[1] - *a3);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, v3);
  operator new();
}

void non-virtual thunk to'CellMonitor::lapsPlmnsFetched(uint64_t a1, uint64_t a2, int **a3)
{
}

void CellMonitor::lapsCellInfoFetched(uint64_t a1, int a2, int a3, MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
  MCC::MCC((MCC *)&v11, a4);
  MCC::MCC((MCC *)&v12, a5);
  uint64_t v13 = a6;
  uint64_t v14 = a7;
  v15[0] = 0;
  v15[1] = 0;
  sub_10003E168(v15, (void *)(a1 + 8));
  operator new();
}

void sub_100AB5644(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 47) < 0) {
    operator delete(*(void **)(v17 + 24));
  }
  sub_10006A6AC(a1);
}

void non-virtual thunk to'CellMonitor::lapsCellInfoFetched(uint64_t a1, int a2, int a3, MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
}

void CellMonitor::lapsBorderInfoFetched(uint64_t a1, int a2, int a3, MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
  MCC::MCC((MCC *)&v11, a4);
  MCC::MCC((MCC *)&v12, a5);
  uint64_t v13 = a6;
  uint64_t v14 = a7;
  v15[0] = 0;
  v15[1] = 0;
  sub_10003E168(v15, (void *)(a1 + 8));
  operator new();
}

void sub_100AB57F4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 47) < 0) {
    operator delete(*(void **)(v17 + 24));
  }
  sub_10006A6AC(a1);
}

void non-virtual thunk to'CellMonitor::lapsBorderInfoFetched(uint64_t a1, int a2, int a3, MCC *a4, const MCC *a5, uint64_t a6, uint64_t a7)
{
}

const void **sub_100AB583C(uint64_t a1, unsigned __int8 a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = 0;
  CFDataRef v34 = 0;
  CellMonitor::getModel_sync(a1, a3, &v33);
  if (v33) {
    ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v33->__vftable[2].__on_zero_shared_weak)(v33, a4, a5, a6, a7, a8);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  v32[0] = 0;
  uint64_t v31 = a2;
  v32[1] = (const void *)a3;
  ServiceMap = (std::mutex *)Registry::getServiceMap(&v31, *(Registry **)(a1 + 64));
  uint64_t v17 = ServiceMap;
  if ((v18 & 0x8000000000000000) != 0)
  {
    xpc_object_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v33 = (std::__shared_weak_count *)v18;
  CFArrayRef v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v33);
  if (v22)
  {
    unint64_t v24 = v22[3];
    CFArrayRef v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      if (!v24) {
        goto LABEL_11;
      }
LABEL_15:
      (*(void (**)(std::__shared_weak_count **__return_ptr, unint64_t, const char *, uint64_t))(*(void *)v24 + 8))(&v33, v24, "LASD cells fetched", 20);
      unint64_t v24 = (unint64_t)v33;
      CFIndex v26 = v34;
      if (v25) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }
  else
  {
    unint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  CFArrayRef v23 = 0;
  char v25 = 1;
  if (v24) {
    goto LABEL_15;
  }
LABEL_11:
  CFIndex v26 = 0;
  if ((v25 & 1) == 0) {
LABEL_16:
  }
    sub_10004D2C8(v23);
LABEL_17:
  sub_10003E168(&v33, (void *)(a1 + 8));
  CFTypeID v28 = v33;
  CFIndex v27 = v34;
  if (v34)
  {
    atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v27);
  }
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v41 = 0;
  sub_10014DD94((char *)&v31, &v41);
  sub_100058DB0(&__p, "/cc/requests/lasd_search");
  xpc_object_t object = v41;
  xpc_object_t v41 = xpc_null_create();
  LOBYTE(v33) = a2;
  CFDataRef v34 = v28;
  unint64_t v35 = v27;
  unint64_t v36 = v24;
  unint64_t v37 = v26;
  uint64_t v43 = 0;
  CFNumberRef v29 = operator new(0x30uLL);
  *(void *)CFNumberRef v29 = off_101A372B8;
  v29[8] = a2;
  *((void *)v29 + 2) = v28;
  *((void *)v29 + 3) = v27;
  CFDataRef v34 = 0;
  unint64_t v35 = 0;
  *((void *)v29 + 4) = v24;
  *((void *)v29 + 5) = v26;
  unint64_t v36 = 0;
  unint64_t v37 = 0;
  uint64_t v43 = v29;
  ctu::RestModule::sendRequest();
  sub_10003F600(v42);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v40 < 0) {
    operator delete(__p);
  }
  xpc_release(v41);
  if (v26) {
    sub_10004D2C8(v26);
  }
  return sub_100057D78(v32);
}

void sub_100AB5B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  sub_100057D78(v29);
  _Unwind_Resume(a1);
}

void *sub_100AB5C2C(unint64_t a1)
{
  if (a1 >= 0xCCCCCCCCCCCCCCDLL) {
    sub_10006A7CC();
  }
  return operator new(20 * a1);
}

void *sub_100AB5C74(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v4 = result;
    if (a4 >= 0x199999999999999ALL) {
      sub_10006A748();
    }
    uint64_t result = sub_100AB5D1C(a4);
    uint64_t v7 = result;
    void *v4 = result;
    v4[1] = result;
    void v4[2] = (char *)result + 10 * v8;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_100AB5D00(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AB5D1C(unint64_t a1)
{
  if (a1 >= 0x199999999999999ALL) {
    sub_10006A7CC();
  }
  return operator new(10 * a1);
}

void sub_100AB5D64(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 64;
        sub_10008820C(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_100AB5DE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFIndex v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 56) + 16))(*(void *)(*(void *)v1 + 56), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(*(void *)(v1 + 24) - *(void *)(v1 + 16)) >> 1;
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Handling %lu MCCs in LASD fetch indicaton", buf, 0xCu);
  }
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef theArray = Mutable;
  uint64_t v6 = *(unsigned __int16 **)(v1 + 16);
  uint64_t v7 = *(unsigned __int16 **)(v1 + 24);
  if (v6 != v7)
  {
    do
    {
      xpc_object_t value = 0;
      uint64_t v8 = *v6;
      __p[0] = 0;
      *(void *)std::string buf = v8;
      CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
      if (v9)
      {
        CFDictionaryRef v10 = __p[0];
        __p[0] = v9;
        *(void *)std::string buf = v10;
        sub_1000570E8((const void **)buf);
      }
      xpc_object_t value = __p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)__p);
      CFArrayAppendValue(theArray, value);
      sub_1000570E8((const void **)&value);
      ++v6;
    }
    while (v6 != v7);
    Mutable = theArray;
  }
  if (CFArrayGetCount(Mutable) >= 1)
  {
    CFDictionaryAddValue(theDict, @"FetchType", @"MCC");
    CFDictionaryAddValue(theDict, @"Parameters", theArray);
    xpc_object_t value = 0;
    CFTypeID v30 = 0;
    uint64_t v31 = 0;
    sub_10004EFE4(__p, (CFTypeRef *)&theDict);
    *(void *)std::string buf = v30;
    CFTypeID v30 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)__p);
    LODWORD(v31) = *(_DWORD *)(v1 + 8);
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v31, *(Registry **)(v2 + 64));
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v18 = v17[3];
      xpc_object_t v19 = (std::__shared_weak_count *)v17[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v20 = 0;
        if (!v18) {
          goto LABEL_15;
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v12);
    xpc_object_t v19 = 0;
    char v20 = 1;
    if (!v18)
    {
LABEL_15:
      unsigned int v21 = 0;
      if (v20) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
LABEL_21:
    (*(void (**)(uint8_t *__return_ptr, uint64_t, const char *, uint64_t))(*(void *)v18 + 8))(buf, v18, "LASD MCCs fetched", 20);
    unsigned int v21 = *(std::__shared_weak_count **)&buf[8];
    uint64_t v18 = *(void *)buf;
    if (v20)
    {
LABEL_23:
      sub_10003E168(buf, (void *)(v2 + 8));
      long long v23 = *(_OWORD *)buf;
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(*((std::__shared_weak_count **)&v23 + 1));
      }
      int v24 = *(_DWORD *)(v1 + 8);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v37 = 0;
      sub_10014DD94((char *)&value, &v37);
      sub_100058DB0(__p, "/cc/requests/lasd_search");
      xpc_object_t object = v37;
      xpc_object_t v37 = xpc_null_create();
      char v25 = (char *)operator new(0x30uLL);
      *(void *)char v25 = off_101A371B8;
      *(_OWORD *)(v25 + 8) = v23;
      *((_DWORD *)v25 + 6) = v24;
      *((void *)v25 + 4) = v18;
      *((void *)v25 + 5) = v21;
      uint64_t v39 = v25;
      ctu::RestModule::sendRequest();
      sub_10003F600(buf);
      xpc_release(object);
      xpc_object_t object = 0;
      if (v36 < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v37);
      if (v21) {
        sub_10004D2C8(v21);
      }
      sub_100057D78((const void **)&v30);
      goto LABEL_32;
    }
LABEL_22:
    sub_10004D2C8(v19);
    goto LABEL_23;
  }
  CFArrayRef v22 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Empty MCC array", buf, 2u);
  }
LABEL_32:
  sub_1000440D4((const void **)&theArray);
  sub_10005717C((const void **)&theDict);
  sub_100AB63B8(&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_100AB6264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, const void *a16, const void *a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t a25,char a26)
{
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  sub_100057D78(v26);
  sub_1000440D4(&a16);
  sub_10005717C(&a17);
  sub_100AB63B8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AB63B8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 16);
    if (v2)
    {
      *(void *)(v1 + 24) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100AB6410(void *a1)
{
  *a1 = off_101A371B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100AB6468(void *a1)
{
  *a1 = off_101A371B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100AB64E0(uint64_t a1)
{
  uint64_t result = operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A371B8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 6) = *(_DWORD *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 40);
  result[4] = *(void *)(a1 + 32);
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100AB655C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A371B8;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
  uint64_t v4 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100AB65B4(uint64_t a1)
{
}

void sub_100AB65BC(void *a1)
{
  sub_100AB6848((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AB65F8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  memset(v15, 0, sizeof(v15));
  sub_10014E648((uint64_t)v15, &object);
  int v12 = v15[0];
  long long v3 = *(_OWORD *)((char *)v15 + 8);
  memset((char *)v15 + 8, 0, 32);
  v13[0] = v3;
  v13[1] = *(_OWORD *)((char *)&v15[1] + 8);
  unsigned int v14 = DWORD2(v15[2]);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(capabilities::ct **)(a1 + 8);
      if (v7)
      {
        if (v12 == 1)
        {
          unsigned int v8 = v14;
          sub_10004EFE4(v16, (CFTypeRef *)v13);
          CellMonitor::sendBulkHints_sync(v7, 0, v8, v16);
          sub_100057D78((const void **)v16);
        }
        else
        {
          uint64_t v9 = *((void *)v7 + 10);
          uint64_t v10 = *(unsigned int *)(a1 + 24);
          memset(v16, 0, sizeof(v16));
          (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 56))(v9, v10);
          uint64_t v17 = v16;
          sub_100AB5D64((void ***)&v17);
        }
      }
      sub_10004D2C8(v6);
    }
  }
  v16[0] = (CFDictionaryRef)((char *)v13 + 8);
  sub_100047F64((void ***)v16);
  sub_1000577C4((const void **)v13);
  v16[0] = (CFDictionaryRef)&v15[1];
  sub_100047F64((void ***)v16);
  sub_1000577C4((const void **)v15 + 1);
  xpc_release(object);
}

void sub_100AB6780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  *(void *)(v16 - 72) = v13;
  sub_100AB5D64((void ***)(v16 - 72));
  sub_10004D2C8(v12);
  *(void *)(v16 - 72) = v15;
  sub_100047F64((void ***)(v16 - 72));
  sub_1000577C4(v11);
  *(void *)(v16 - 72) = v14;
  sub_100047F64((void ***)(v16 - 72));
  sub_1000577C4(v10);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB67FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB683C()
{
}

void sub_100AB6848(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_100AB6898(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFTypeID v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *(void *)v1;
  long long v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 56) + 16))(*(void *)(*(void *)v1 + 56), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(*(void *)(v1 + 24) - *(void *)(v1 + 16)) >> 2;
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Handling %lu PLMNs in LASD fetch indicaton", buf, 0xCu);
  }
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef theArray = Mutable;
  uint64_t v6 = *(unsigned __int16 **)(v1 + 16);
  uint64_t v7 = *(unsigned __int16 **)(v1 + 24);
  if (v6 != v7)
  {
    do
    {
      xpc_object_t value = 0;
      uint64_t v8 = *v6;
      __p[0] = 0;
      *(void *)std::string buf = v8;
      CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
      if (v9)
      {
        uint64_t v10 = __p[0];
        __p[0] = v9;
        *(void *)std::string buf = v10;
        sub_1000570E8((const void **)buf);
      }
      xpc_object_t value = __p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)__p);
      xpc_object_t v40 = 0;
      uint64_t v11 = v6[1];
      __p[0] = 0;
      *(void *)std::string buf = v11;
      CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
      if (v12)
      {
        uint64_t v13 = __p[0];
        __p[0] = v12;
        *(void *)std::string buf = v13;
        sub_1000570E8((const void **)buf);
      }
      xpc_object_t v40 = __p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)__p);
      *(void *)std::string buf = 0;
      *(void *)std::string buf = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)buf, @"MCC", value);
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)buf, @"MNC", v40);
      CFArrayAppendValue(theArray, *(const void **)buf);
      sub_10005717C((const void **)buf);
      sub_1000570E8((const void **)&v40);
      sub_1000570E8((const void **)&value);
      v6 += 2;
    }
    while (v6 != v7);
    Mutable = theArray;
  }
  if (CFArrayGetCount(Mutable) >= 1)
  {
    CFDictionaryAddValue(theDict, @"FetchType", @"PLMN");
    CFDictionaryAddValue(theDict, @"Parameters", theArray);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    xpc_object_t value = (void *)1;
    sub_10004EFE4(__p, (CFTypeRef *)&theDict);
    *(void *)std::string buf = v33;
    uint64_t v33 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)__p);
    LODWORD(v34) = *(_DWORD *)(v1 + 8);
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v34, *(Registry **)(v2 + 64));
    uint64_t v15 = ServiceMap;
    if (v16 < 0)
    {
      uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v16;
    char v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      unsigned int v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        if (!v22) {
          goto LABEL_17;
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    unsigned int v21 = 0;
    char v23 = 1;
    if (!v22)
    {
LABEL_17:
      uint64_t v24 = 0;
      char v25 = 0;
      if (v23) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
LABEL_23:
    (*(void (**)(uint8_t *__return_ptr, uint64_t, const char *, uint64_t))(*(void *)v22 + 8))(buf, v22, "LASD PLMNs fetched", 20);
    char v25 = *(std::__shared_weak_count **)&buf[8];
    uint64_t v24 = *(void *)buf;
    if (v23)
    {
LABEL_25:
      sub_10003E168(buf, (void *)(v2 + 8));
      long long v27 = *(_OWORD *)buf;
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(*((std::__shared_weak_count **)&v27 + 1));
      }
      if (v25) {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v40 = 0;
      sub_10014DD94((char *)&value, &v40);
      sub_100058DB0(__p, "/cc/requests/lasd_search");
      xpc_object_t object = v40;
      xpc_object_t v40 = xpc_null_create();
      char v28 = (char *)operator new(0x28uLL);
      *(void *)char v28 = off_101A37238;
      *(_OWORD *)(v28 + 8) = v27;
      *((void *)v28 + 3) = v24;
      *((void *)v28 + 4) = v25;
      unint64_t v42 = v28;
      ctu::RestModule::sendRequest();
      sub_10003F600(buf);
      xpc_release(object);
      xpc_object_t object = 0;
      if (v39 < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v40);
      if (v25) {
        sub_10004D2C8(v25);
      }
      sub_100057D78((const void **)&v33);
      goto LABEL_34;
    }
LABEL_24:
    sub_10004D2C8(v21);
    goto LABEL_25;
  }
  CFIndex v26 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#N Empty PLMN array", buf, 2u);
  }
LABEL_34:
  sub_1000440D4((const void **)&theArray);
  sub_10005717C((const void **)&theDict);
  sub_100AB6F5C(&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_100AB6DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19, xpc_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,xpc_object_t a27,char a28)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  sub_100057D78(v28);
  sub_1000440D4(&a18);
  sub_10005717C(&a19);
  sub_100AB6F5C(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AB6F5C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 16);
    if (v2)
    {
      *(void *)(v1 + 24) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100AB6FB4(void *a1)
{
  *a1 = off_101A37238;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100AB700C(void *a1)
{
  *a1 = off_101A37238;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100AB7084(void *a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A37238;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_100AB70F8(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A37238;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100AB7148(uint64_t a1)
{
}

void sub_100AB7150(void *a1)
{
  sub_1007DD410((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AB718C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  memset(v39, 0, sizeof(v39));
  sub_10014E648((uint64_t)v39, &object);
  unsigned int v35 = v39[0];
  long long v3 = *(_OWORD *)((char *)v39 + 8);
  memset((char *)v39 + 8, 0, 32);
  long long v36 = v3;
  long long v37 = *(_OWORD *)((char *)&v39[1] + 8);
  unsigned int v38 = DWORD2(v39[2]);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(capabilities::ct **)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = v35;
        if (v35 == 1)
        {
          unsigned int v9 = v38;
          sub_10004EFE4(&v40, (CFTypeRef *)&v36);
          CellMonitor::sendBulkHints_sync(v7, 1u, v9, (CFDictionaryRef *)&v40);
          sub_100057D78((const void **)&v40);
        }
        else
        {
          unint64_t v32 = v5;
          memset(v46, 0, 24);
          uint64_t v10 = *((void *)&v36 + 1);
          uint64_t v11 = v37;
          if (*((void *)&v36 + 1) == (void)v37)
          {
            uint64_t v25 = 0;
            uint64_t v24 = 0;
          }
          else
          {
            do
            {
              MCCAndMNC::MCCAndMNC();
              uint64_t v12 = *((void *)&v46[0] + 1);
              if (*((void *)&v46[0] + 1) >= *(void *)&v46[1])
              {
                uint64_t v14 = (uint64_t)(*((void *)&v46[0] + 1) - *(void *)&v46[0]) >> 6;
                if ((unint64_t)(v14 + 1) >> 58) {
                  sub_10006A748();
                }
                unint64_t v15 = (uint64_t)(*(void *)&v46[1] - *(void *)&v46[0]) >> 5;
                if (v15 <= v14 + 1) {
                  unint64_t v15 = v14 + 1;
                }
                if (*(void *)&v46[1] - *(void *)&v46[0] >= 0x7FFFFFFFFFFFFFC0uLL) {
                  unint64_t v16 = 0x3FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v16 = v15;
                }
                CFTypeID v49 = &v46[1];
                if (v16) {
                  unint64_t v16 = (unint64_t)sub_10016063C(v16);
                }
                else {
                  uint64_t v17 = 0;
                }
                unint64_t v47 = (void ***)v16;
                *(void *)CFArrayRef v48 = v16 + (v14 << 6);
                *(void *)&v48[8] = *(void *)v48;
                *(void *)&uint8_t v48[16] = v16 + (v17 << 6);
                sub_1004C7EE8(*(MCC **)v48, (uint64_t)&v40);
                uint64_t v18 = 0;
                uint64_t v19 = *(void *)v48;
                *(void *)&v48[8] += 64;
                for (long long i = v46[0];
                      *((void *)&i + 1) + v18 != (void)i;
                      sub_1003FB5E8((MCC *)(v18 + v19), v18 + *((void *)&i + 1)))
                {
                  v18 -= 64;
                }
                uint64_t v21 = *(void *)&v46[1];
                uint64_t v33 = *(void *)&v48[8];
                long long v22 = *(_OWORD *)&v48[8];
                long long v23 = v46[0];
                *(void *)&v46[0] = v19 + v18;
                *(_OWORD *)CFArrayRef v48 = v23;
                *(_OWORD *)((char *)v46 + 8) = v22;
                *(void *)&uint8_t v48[16] = v21;
                unint64_t v47 = (void ***)v23;
                sub_100AB76AC((uint64_t)&v47);
                uint64_t v13 = v33;
              }
              else
              {
                sub_1004C7EE8(*((MCC **)&v46[0] + 1), (uint64_t)&v40);
                uint64_t v13 = v12 + 64;
              }
              *((void *)&v46[0] + 1) = v13;
              if (v45 < 0) {
                operator delete(__p);
              }
              if (v43 < 0) {
                operator delete(v41);
              }
              v10 += 24;
            }
            while (v10 != v11);
            uint64_t v8 = v35;
            uint64_t v25 = *((void *)&v46[0] + 1);
            uint64_t v24 = *(void *)&v46[0];
            uint64_t v6 = v32;
          }
          uint64_t v26 = *((void *)v7 + 10);
          uint64_t v27 = v38;
          xpc_object_t v41 = 0;
          unint64_t v42 = 0;
          xpc_object_t v40 = 0;
          unint64_t v47 = &v40;
          uint64_t v28 = v25 - v24;
          if (v25 != v24)
          {
            *(void *)CFArrayRef v48 = 0;
            if (v28 < 0) {
              sub_10006A748();
            }
            CFNumberRef v29 = (void **)sub_10016063C(v28 >> 6);
            uint64_t v30 = 0;
            xpc_object_t v40 = v29;
            xpc_object_t v41 = v29;
            unint64_t v42 = &v29[8 * v31];
            do
            {
              sub_100AB76FC((MCC *)&v29[v30], v24 + v30 * 8);
              v30 += 8;
            }
            while (v24 + v30 * 8 != v25);
            xpc_object_t v41 = &v29[v30];
            uint64_t v6 = v32;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, void ***))(*(void *)v26 + 56))(v26, v27, v8, &v40);
          unint64_t v47 = &v40;
          sub_100AB5D64((void ***)&v47);
          unint64_t v47 = (void ***)v46;
          sub_100AB5D64((void ***)&v47);
        }
      }
      sub_10004D2C8(v6);
    }
  }
  xpc_object_t v40 = (void **)&v36 + 1;
  sub_100047F64(&v40);
  sub_1000577C4((const void **)&v36);
  xpc_object_t v40 = (void **)&v39[1];
  sub_100047F64(&v40);
  sub_1000577C4((const void **)v39 + 1);
  xpc_release(object);
}

void sub_100AB751C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10, const void **a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  *(void *)(v44 - 136) = v42;
  sub_100AB5D64((void ***)(v44 - 136));
  *(void *)(v44 - 144) = v44 - 176;
  sub_100AB5D64((void ***)(v44 - 144));
  sub_10004D2C8(a12);
  *(void *)(v44 - 176) = a9;
  sub_100047F64((void ***)(v44 - 176));
  sub_1000577C4(a10);
  *(void *)(v44 - 176) = v43;
  sub_100047F64((void ***)(v44 - 176));
  sub_1000577C4(a11);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB7660(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB76A0()
{
}

uint64_t sub_100AB76AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    sub_10008820C(i - 64);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

MCC *sub_100AB76FC(MCC *a1, uint64_t a2)
{
  MCC::MCC(a1, (const MCC *)a2);
  MCC::MCC((MCC *)(v4 + 32), (const MCC *)(a2 + 32));
  return a1;
}

void sub_100AB7734(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100AB7750(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100AB583C(*(void *)v1, 2u, *(_DWORD *)(v1 + 8), *(unsigned int *)(v1 + 12), v1 + 16, v1 + 48, *(void *)(v1 + 80), *(void *)(v1 + 88));
  sub_100AB77C4(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100AB77A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AB77C4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100AB782C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100AB583C(*(void *)v1, 3u, *(_DWORD *)(v1 + 8), *(unsigned int *)(v1 + 12), v1 + 16, v1 + 48, *(void *)(v1 + 80), *(void *)(v1 + 88));
  sub_100AB77C4(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100AB7884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_100AB78A0(void *a1)
{
  *a1 = off_101A372B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100AB78F8(void *a1)
{
  *a1 = off_101A372B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

unsigned char *sub_100AB7970(uint64_t a1)
{
  uint64_t result = operator new(0x30uLL);
  *(void *)uint64_t result = off_101A372B8;
  result[8] = *(unsigned char *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 2) = *(void *)(a1 + 16);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100AB79EC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A372B8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 16) = *(void *)(result + 16);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100AB7A44(uint64_t a1)
{
}

void sub_100AB7A4C(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AB7A88(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  memset(v15, 0, sizeof(v15));
  sub_10014E648((uint64_t)v15, &object);
  int v12 = v15[0];
  long long v3 = *(_OWORD *)((char *)v15 + 8);
  memset((char *)v15 + 8, 0, 32);
  v13[0] = v3;
  v13[1] = *(_OWORD *)((char *)&v15[1] + 8);
  unsigned int v14 = DWORD2(v15[2]);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(capabilities::ct **)(a1 + 16);
      if (v7)
      {
        if (v12 == 1)
        {
          char v8 = *(unsigned char *)(a1 + 8);
          unsigned int v9 = v14;
          sub_10004EFE4(v16, (CFTypeRef *)v13);
          CellMonitor::sendBulkHints_sync(v7, v8, v9, v16);
          sub_100057D78((const void **)v16);
        }
        else
        {
          uint64_t v10 = *((void *)v7 + 10);
          memset(v16, 0, sizeof(v16));
          (*(void (**)(uint64_t, void))(*(void *)v10 + 56))(v10, v14);
          uint64_t v17 = v16;
          sub_100AB5D64((void ***)&v17);
        }
      }
      sub_10004D2C8(v6);
    }
  }
  v16[0] = (CFDictionaryRef)((char *)v13 + 8);
  sub_100047F64((void ***)v16);
  sub_1000577C4((const void **)v13);
  v16[0] = (CFDictionaryRef)&v15[1];
  sub_100047F64((void ***)v16);
  sub_1000577C4((const void **)v15 + 1);
  xpc_release(object);
}

void sub_100AB7C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  *(void *)(v16 - 72) = v13;
  sub_100AB5D64((void ***)(v16 - 72));
  sub_10004D2C8(v12);
  *(void *)(v16 - 72) = v15;
  sub_100047F64((void ***)(v16 - 72));
  sub_1000577C4(v11);
  *(void *)(v16 - 72) = v14;
  sub_100047F64((void ***)(v16 - 72));
  sub_1000577C4(v10);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100AB7C90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AB7CD0()
{
}

void sub_100AB7CDC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100AB7D48()
{
}

uint64_t sub_100AB7D6C(uint64_t a1, unsigned int a2)
{
  if (a2 > 3) {
    uint64_t v4 = "set.mdl.forwarding.1";
  }
  else {
    uint64_t v4 = off_101A37428[a2];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, v4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = a1 + 32;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = a2;
  return a1;
}

void sub_100AB7E1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_100AB7E40(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  sub_100AB9030(a1 + 24, *(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

void sub_100AB7E9C(os_log_t *a1, int a2, uint64_t a3)
{
  int v5 = 0;
  int v24 = a2;
  unsigned int v6 = *(unsigned __int8 *)(a3 + 2);
  uint64_t v7 = (uint64_t **)(a1 + 3);
  __str = (std::string *)(a3 + 8);
  int v8 = 1;
  do
  {
    unsigned int v9 = v8;
    if ((v8 & v6) == 0)
    {
      os_log_t v11 = *a1;
      if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      *(_DWORD *)std::string buf = 67109376;
      unsigned int v26 = v6;
      __int16 v27 = 1024;
      unsigned int v28 = v9;
      int v12 = v11;
      uint64_t v13 = "#I The service class is not matching, Service Class %d, Current Bit Mask %d";
      uint32_t v14 = 14;
      goto LABEL_13;
    }
    if (v8 < 2u)
    {
      sub_100AB90A4(v7, a2, &v24);
      unsigned int v10 = 0;
LABEL_10:
      uint64_t v17 = sub_100AB90A4(v7, a2, &v24);
      char v18 = *(unsigned char *)(a3 + 2);
      uint64_t v19 = &v17[5 * v10];
      *((_WORD *)v19 + 2sub_1001A7358((uint64_t)&a9, 0) = *(_WORD *)a3;
      *((unsigned char *)v19 + 42) = v18;
      std::string::operator=((std::string *)v19 + 2, __str);
      *((unsigned char *)v19 + 72) = *(unsigned char *)(a3 + 32);
      BYTE2(sub_100AB90A4(v7, a2, &v24)[5 * v10 + 5]) = v8;
      LOBYTE(sub_100AB90A4(v7, a2, &v24)[5 * v10 + 5]) = 1;
      goto LABEL_14;
    }
    unsigned int v15 = -1;
    do
    {
      ++v15;
      BOOL v16 = v9 > 3;
      v9 >>= 1;
    }
    while (v16);
    sub_100AB90A4(v7, a2, &v24);
    unsigned int v10 = v15 + 1;
    if (v15 <= 6) {
      goto LABEL_10;
    }
    os_log_t v20 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      unsigned int v26 = v15 + 1;
      int v12 = v20;
      uint64_t v13 = "#I setCallFwdServiceParam: invalid argument '%d' may cause array out of bound";
      uint32_t v14 = 8;
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, buf, v14);
    }
LABEL_14:
    int v8 = 2 << v5++;
  }
  while (v5 != 8);
  *(_DWORD *)std::string buf = 0;
  sub_100AB90A4(v7, 0, buf);
  *(_DWORD *)std::string buf = 0;
  if (*((unsigned char *)sub_100AB90A4(v7, 0, buf) + 40))
  {
    *(_DWORD *)std::string buf = 0;
    BOOL v21 = *((unsigned __int8 *)sub_100AB90A4(v7, 0, buf) + 41) == 1;
    sub_100AB8128((uint64_t)a1, v21);
  }
}

void sub_100AB8128(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 != a2)
  {
    int v5 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v6 = "true";
      if (v3) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (!a2) {
        unsigned int v6 = "false";
      }
      int v8 = 136315394;
      unsigned int v9 = v7;
      __int16 v10 = 2080;
      os_log_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Updating unconditional call forwarding from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 48) = a2;
  }
  sub_100AB8540(a1, (const std::string *)(a1 + 56));
}

BOOL sub_100AB8218(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  int v17 = a2;
  if ((a3 & (a3 - 1)) != 0) {
    __TUAssertTrigger();
  }
  if (v5 < 2)
  {
    int v8 = (uint64_t **)(a1 + 24);
    sub_100AB90A4((uint64_t **)(a1 + 24), a2, &v17);
    unsigned int v9 = 0;
LABEL_8:
    int v12 = &sub_100AB90A4(v8, a2, &v17)[5 * v9];
    char v13 = *((unsigned char *)v12 + 42);
    *(_WORD *)a4 = *((_WORD *)v12 + 20);
    *(unsigned char *)(a4 + 2) = v13;
    std::string::operator=((std::string *)(a4 + 8), (const std::string *)v12 + 2);
    *(unsigned char *)(a4 + 32) = *((unsigned char *)v12 + 72);
    return LOBYTE(sub_100AB90A4(v8, a2, &v17)[5 * v9 + 5]) != 0;
  }
  unsigned int v10 = -1;
  do
  {
    ++v10;
    BOOL v11 = v5 > 3;
    v5 >>= 1;
  }
  while (v11);
  int v8 = (uint64_t **)(a1 + 24);
  sub_100AB90A4((uint64_t **)(a1 + 24), a2, &v17);
  unsigned int v9 = v10 + 1;
  if (v10 <= 6) {
    goto LABEL_8;
  }
  unsigned int v15 = *(NSObject **)a1;
  BOOL v16 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v16)
  {
    *(_DWORD *)std::string buf = 67109120;
    unsigned int v19 = v10 + 1;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N getCallFwdServiceParam: invalid argument '%d' may cause array out of bound", buf, 8u);
    return 0;
  }
  return result;
}

void sub_100AB83B4(uint64_t a1, int a2, unsigned int a3)
{
  int v12 = a2;
  unsigned int v6 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    int v14 = a2;
    __int16 v15 = 1024;
    unsigned int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalidating cached entry for reason: %d class: %d", buf, 0xEu);
  }
  if ((a3 & (a3 - 1)) != 0) {
    __TUAssertTrigger();
  }
  if (a3 < 2)
  {
    uint64_t v7 = (uint64_t **)(a1 + 24);
    sub_100AB90A4((uint64_t **)(a1 + 24), a2, &v12);
    unsigned int v8 = 0;
LABEL_11:
    LOBYTE(sub_100AB90A4(v7, a2, &v12)[5 * v8 + 5]) = 0;
    return;
  }
  unsigned int v9 = -1;
  do
  {
    ++v9;
    BOOL v10 = a3 > 3;
    a3 >>= 1;
  }
  while (v10);
  uint64_t v7 = (uint64_t **)(a1 + 24);
  sub_100AB90A4((uint64_t **)(a1 + 24), a2, &v12);
  if (v9 <= 6)
  {
    unsigned int v8 = v9 + 1;
    goto LABEL_11;
  }
  BOOL v11 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N invalidateEntry: - invalid argument", buf, 2u);
  }
}

void sub_100AB8540(uint64_t a1, const std::string *a2)
{
  v7[0] = 0;
  v7[1] = 0;
  uint64_t v8 = 0;
  sub_10102024C(*(_DWORD *)(a1 + 80), v7);
  std::string::operator=((std::string *)(a1 + 56), a2);
  uint64_t v4 = (uint64_t **)sub_100365D74();
  std::operator+<char>();
  sub_1002266A4(v4, &__p, a1 + 56);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unsigned int v5 = (uint64_t **)sub_100365D74();
  std::operator+<char>();
  sub_1002264FC(v5, &__p, (unsigned __int8 *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
}

void sub_100AB8620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AB8660(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100AB86CC()
{
}

uint64_t sub_100AB86F0(uint64_t a1, unsigned int a2)
{
  if (a2 > 3) {
    uint64_t v4 = "set.mdl.barring.1";
  }
  else {
    uint64_t v4 = off_101A37448[a2];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, v4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = a1 + 32;
  *(_DWORD *)(a1 + 48) = a2;
  return a1;
}

void sub_100AB8794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_100AB87B8(uint64_t a1)
{
  sub_1000346F8(a1 + 24, *(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

void sub_100AB8804(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    v20[0] = 67109632;
    v20[1] = a4;
    __int16 v21 = 1024;
    unsigned int v22 = a2;
    __int16 v23 = 1024;
    int v24 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting %d for Barring Type %d and Call Class %d", (uint8_t *)v20, 0x14u);
  }
  BOOL v10 = (uint64_t **)(a1 + 32);
  unsigned int v9 = *(uint64_t **)(a1 + 32);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        BOOL v11 = v9;
        unsigned int v12 = *((_DWORD *)v9 + 7);
        if (v12 == a2) {
          break;
        }
        if (v12 <= a2)
        {
          if (v12 >= a2) {
            char v16 = 1;
          }
          else {
            char v16 = -1;
          }
          if ((v16 & 0x80) == 0) {
            goto LABEL_26;
          }
          goto LABEL_20;
        }
LABEL_14:
        unsigned int v9 = (uint64_t *)*v11;
        BOOL v10 = (uint64_t **)v11;
        if (!*v11) {
          goto LABEL_23;
        }
      }
      unsigned int v13 = *((_DWORD *)v11 + 8);
      BOOL v14 = v13 == a3;
      if (v13 > a3) {
        goto LABEL_14;
      }
      if (v13 >= a3) {
        char v15 = 1;
      }
      else {
        char v15 = -1;
      }
      if (v14) {
        char v15 = 0;
      }
      if ((v15 & 0x80) == 0)
      {
LABEL_26:
        int v17 = (char *)v11;
        goto LABEL_27;
      }
LABEL_20:
      unsigned int v9 = (uint64_t *)v11[1];
      if (!v9)
      {
        BOOL v10 = (uint64_t **)(v11 + 1);
        goto LABEL_23;
      }
    }
  }
  BOOL v11 = (uint64_t *)(a1 + 32);
LABEL_23:
  int v17 = (char *)operator new(0x28uLL);
  *(void *)(v17 + 28) = a2 | (unint64_t)(a3 << 32);
  v17[36] = 0;
  *(void *)int v17 = 0;
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = v11;
  *BOOL v10 = (uint64_t *)v17;
  uint64_t v18 = **(void **)(a1 + 24);
  unsigned int v19 = (uint64_t *)v17;
  if (v18)
  {
    *(void *)(a1 + 24) = v18;
    unsigned int v19 = *v10;
  }
  sub_100046C90(*(uint64_t **)(a1 + 32), v19);
  ++*(void *)(a1 + 40);
LABEL_27:
  v17[36] = a4;
}

uint64_t sub_100AB89AC(uint64_t a1, unsigned int a2, unsigned int a3, unsigned char *a4)
{
  uint64_t v8 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = 67109376;
    unsigned int v30 = a2;
    __int16 v31 = 1024;
    unsigned int v32 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Getting setting for Barring Type %d and Call Class %d", (uint8_t *)&v29, 0xEu);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (!v9) {
    goto LABEL_35;
  }
  uint64_t v10 = a1 + 32;
  do
  {
    unsigned int v11 = *(_DWORD *)(v9 + 28);
    BOOL v12 = v11 == a2;
    if (v11 >= a2) {
      char v13 = 1;
    }
    else {
      char v13 = -1;
    }
    if (v12)
    {
      unsigned int v14 = *(_DWORD *)(v9 + 32);
      BOOL v15 = v14 == a3;
      char v13 = v14 >= a3 ? 1 : -1;
      if (v15) {
        char v13 = 0;
      }
    }
    BOOL v16 = (v13 & 0x80) == 0;
    if (v13 < 0) {
      int v17 = (uint64_t *)(v9 + 8);
    }
    else {
      int v17 = (uint64_t *)v9;
    }
    if (v16) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v17;
  }
  while (*v17);
  if (a1 + 32 == v10) {
    goto LABEL_35;
  }
  unsigned int v18 = *(_DWORD *)(v10 + 28);
  BOOL v19 = v18 == a2;
  if (v18 <= a2) {
    char v20 = 1;
  }
  else {
    char v20 = -1;
  }
  if (v19)
  {
    unsigned int v21 = *(_DWORD *)(v10 + 32);
    BOOL v22 = v21 == a3;
    BOOL v23 = v21 > a3;
    char v20 = -1;
    if (!v23) {
      char v20 = 1;
    }
    if (v22) {
      char v20 = 0;
    }
  }
  if (v20 < 0)
  {
LABEL_35:
    __int16 v27 = *(NSObject **)a1;
    BOOL v28 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v28)
    {
      LOWORD(v29) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Could not find", (uint8_t *)&v29, 2u);
      return 0;
    }
  }
  else
  {
    unsigned int v24 = *(unsigned __int8 *)(v10 + 36);
    *a4 = v24;
    uint64_t v25 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = 67109120;
      unsigned int v30 = v24;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Barring enabled %d", (uint8_t *)&v29, 8u);
    }
    return 1;
  }
  return result;
}

void sub_100AB8B90(uint64_t a1)
{
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = 0;
  sub_10102024C(*(_DWORD *)(a1 + 80), v12);
  uint64_t v2 = sub_100365D74();
  std::operator+<char>();
  uint64_t v3 = (void *)(a1 + 56);
  sub_100226284(v2, &__p, (std::string *)(a1 + 56));
  if (v17 < 0) {
    operator delete(__p);
  }
  uint64_t v4 = sub_100365D74();
  std::operator+<char>();
  BOOL v5 = sub_1002260B0(v4, &__p, (BOOL *)(a1 + 48));
  if (v17 < 0) {
    operator delete(__p);
  }
  os_log_t v6 = *(os_log_t *)a1;
  BOOL v7 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_13;
    }
    int v8 = *(unsigned __int8 *)(a1 + 48);
    if (*(char *)(a1 + 79) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = v8;
    __int16 v15 = 2080;
    BOOL v16 = v3;
    uint64_t v9 = "#I Retrieved call forwarding status %d, with ICCID %s from CSI Data";
    uint64_t v10 = v6;
    uint32_t v11 = 18;
  }
  else
  {
    if (!v7) {
      goto LABEL_13;
    }
    LOWORD(__p) = 0;
    uint64_t v9 = "#I No saved call forwarding status in CSI Data";
    uint64_t v10 = v6;
    uint32_t v11 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&__p, v11);
LABEL_13:
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_100AB8D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AB8D70(uint64_t a1, const std::string *a2)
{
  uint64_t v4 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  size_t size = a2->__r_.__value_.__l.__size_;
  if ((v4 & 0x80u) == 0) {
    std::string::size_type v6 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v6 = a2->__r_.__value_.__l.__size_;
  }
  uint64_t v7 = *(unsigned __int8 *)(a1 + 79);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a1 + 64);
  }
  if (v6 == v7)
  {
    if (v8 >= 0) {
      uint64_t v9 = (unsigned __int8 *)(a1 + 56);
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)(a1 + 56);
    }
    if ((v4 & 0x80) != 0)
    {
      uint64_t result = memcmp(a2->__r_.__value_.__l.__data_, v9, size);
      if (!result) {
        return result;
      }
    }
    else
    {
      if (!v4) {
        return 0;
      }
      for (uint64_t i = a2; i->__r_.__value_.__s.__data_[0] == *v9; uint64_t i = (const std::string *)((char *)i + 1))
      {
        ++v9;
        if (!--v4) {
          return 0;
        }
      }
    }
  }
  BOOL v12 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I ICCID has changed, erasing the call forward setting saved data", (uint8_t *)v13, 2u);
  }
  *(unsigned char *)(a1 + 48) = 0;
  sub_100AB8540(a1, a2);
  return 1;
}

void sub_100AB8E74(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100AB8F00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100AB8FE0((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_100AB8F1C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100AB8F54(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100AB7E40(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100AB8F9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100AB8FE0(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100AB7E40(result);
    operator delete();
  }
  return result;
}

void sub_100AB9030(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100AB9030(a1, *a2);
    sub_100AB9030(a1, a2[1]);
    uint64_t v4 = 40;
    do
    {
      if (SHIBYTE(a2[v4 + 3]) < 0) {
        operator delete((void *)a2[v4 + 1]);
      }
      v4 -= 5;
    }
    while (v4 * 8);
    operator delete(a2);
  }
}

uint64_t **sub_100AB90A4(uint64_t **a1, int a2, _DWORD *a3)
{
  std::string::size_type v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        std::string::size_type v6 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= a2) {
        return v7;
      }
      BOOL v5 = v7[1];
    }
    while (v5);
    std::string::size_type v6 = v7 + 1;
  }
  else
  {
    uint64_t v7 = a1 + 1;
  }
LABEL_10:
  uint64_t v9 = (char *)operator new(0x168uLL);
  BOOL v12 = v9;
  uint64_t v10 = 0;
  *((_DWORD *)v9 + 8) = *a3;
  *(_OWORD *)(v9 + 4sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(v9 + 296) = 0u;
  *(_OWORD *)(v9 + 312) = 0u;
  *(_OWORD *)(v9 + 328) = 0u;
  *(_OWORD *)(v9 + 344) = 0u;
  *(_OWORD *)(v9 + 56) = 0u;
  *(_OWORD *)(v9 + 72) = 0u;
  *(_OWORD *)(v9 + 88) = 0u;
  *(_OWORD *)(v9 + 104) = 0u;
  *(_OWORD *)(v9 + 12sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(v9 + 136) = 0u;
  *(_OWORD *)(v9 + 152) = 0u;
  *(_OWORD *)(v9 + 168) = 0u;
  *(_OWORD *)(v9 + 184) = 0u;
  *(_OWORD *)(v9 + 20sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(v9 + 216) = 0u;
  *(_OWORD *)(v9 + 232) = 0u;
  *(_OWORD *)(v9 + 248) = 0u;
  *(_OWORD *)(v9 + 264) = 0u;
  *(_OWORD *)(v9 + 28sub_1001A7358((uint64_t)&a9, 0) = 0u;
  do
  {
    uint32_t v11 = &v9[v10];
    *((_WORD *)v11 + 2sub_1001A7358((uint64_t)&a9, 0) = 0;
    v11[42] = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 8) = 0;
    *((void *)v11 + 6) = 0;
    v10 += 40;
    v11[72] = 0;
  }
  while (v10 != 320);
  sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
  return (uint64_t **)v12;
}

void sub_100AB91CC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100AB9258(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100AB9338((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_100AB9274(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100AB92AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100AB87B8(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100AB92F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100AB9338(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100AB87B8(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100AB9388(uint64_t a1, uint64_t a2, int a3)
{
  BOOL v5 = "sig.moots.?";
  if (a3 == 2) {
    BOOL v5 = "sig.moots.2";
  }
  if (a3 == 1) {
    std::string::size_type v6 = "sig.moots.1";
  }
  else {
    std::string::size_type v6 = v5;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v18, kCtLoggingSystemName, v6);
  SignalStrengthModel::SignalStrengthModel();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)a1 = off_101A37478;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 128) = 0xC033000000000000;
  *(void *)(a1 + 144) = 0xC061400000000000;
  *(void *)(a1 + 16sub_1001A7358((uint64_t)&a9, 0) = 0xC05A800000000000;
  *(void *)(a1 + 176) = 0xC061400000000000;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 20sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 208) = off_101A375C0;
  *(void *)(a1 + 24sub_1001A7358((uint64_t)&a9, 0) = 0x3FE0000000000000;
  __asm { FMOV            V1.2D, #-19.0 }
  *(_OWORD *)(a1 + 224) = _Q1;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 248) = off_101A375C0;
  *(void *)(a1 + 264) = 0xC061400000000000;
  *(_OWORD *)(a1 + 272) = xmmword_101536F30;
  double v12 = 0.09375;
  if (*(unsigned char *)(a1 + 61)) {
    double v12 = 0.5;
  }
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 288) = off_101A375C0;
  *(double *)(a1 + 32sub_1001A7358((uint64_t)&a9, 0) = v12;
  *(int64x2_t *)(a1 + 304) = vdupq_n_s64(0xC05A800000000000);
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 328) = off_101A375C0;
  *(void *)(a1 + 344) = 0xC033000000000000;
  *(_OWORD *)(a1 + 352) = xmmword_101536F40;
  *(void *)(a1 + 40sub_1001A7358((uint64_t)&a9, 0) = 0;
  uint64_t v13 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 368) = v13;
  *(void *)(a1 + 376) = v13 + 16;
  *(void *)(a1 + 384) = v13;
  *(void *)(a1 + 392) = v13;
  *(void *)(a1 + 44sub_1001A7358((uint64_t)&a9, 0) = 0;
  unsigned int v14 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 408) = v14;
  *(void *)(a1 + 416) = v14 + 16;
  *(void *)(a1 + 424) = v14;
  *(void *)(a1 + 432) = v14;
  *(void *)(a1 + 48sub_1001A7358((uint64_t)&a9, 0) = 0;
  __int16 v15 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 448) = v15;
  *(void *)(a1 + 456) = v15 + 16;
  *(void *)(a1 + 464) = v15;
  *(void *)(a1 + 472) = v15;
  *(_WORD *)(a1 + 488) = 0;
  *(unsigned char *)(a1 + 49sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 496) = a1 + 504;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 528) = 0;
  *(void *)(a1 + 52sub_1001A7358((uint64_t)&a9, 0) = a1 + 528;
  *(void *)(a1 + 56sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 544) = a1 + 552;
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 568) = a1 + 576;
  *(void *)&long long v16 = 0x100000001;
  *((void *)&v16 + 1) = 0x100000001;
  *(void *)(a1 + 64sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 632) = a1 + 640;
  *(void *)(a1 + 672) = 0;
  *(void *)(a1 + 664) = 0;
  *(void *)(a1 + 656) = a1 + 664;
  *(void *)(a1 + 68sub_1001A7358((uint64_t)&a9, 0) = 0x100000001;
  *(_OWORD *)(a1 + 592) = v16;
  *(_OWORD *)(a1 + 608) = xmmword_101536F50;
  *(_DWORD *)(a1 + 624) = 0;
  *(_DWORD *)(a1 + 688) = a3;
  *(void *)(a1 + 104) |= 1uLL;
  return a1;
}

void sub_100AB9630(_Unwind_Exception *a1)
{
  sub_100ABB244(v2);
  sub_100ABB244((uint64_t)v1 + 368);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 15);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  SignalStrengthModel::~SignalStrengthModel(v1);
  _Unwind_Resume(a1);
}

void sub_100AB9684(uint64_t a1)
{
  *(void *)a1 = off_101A37478;
  sub_1000346F8(a1 + 656, *(void **)(a1 + 664));
  sub_1000346F8(a1 + 632, *(void **)(a1 + 640));
  sub_1000346F8(a1 + 568, *(void **)(a1 + 576));
  sub_1000346F8(a1 + 544, *(void **)(a1 + 552));
  sub_1000346F8(a1 + 520, *(void **)(a1 + 528));
  sub_1000346F8(a1 + 496, *(void **)(a1 + 504));
  sub_100ABB244(a1 + 448);
  sub_100ABB244(a1 + 408);
  sub_100ABB244(a1 + 368);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SignalStrengthModel::~SignalStrengthModel((SignalStrengthModel *)a1);
}

uint64_t *sub_100AB9748(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_100AB9B0C(*(void *)(a1 + 24), *(std::__shared_weak_count **)(v1 + 32), v1);
  sub_100AB9DA4(v1);
  sub_100AB9E24(v1);
  unsigned int v3 = 1;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 520), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC059000000000000;
  unsigned int v3 = 2;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 520), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC057C00000000000;
  unsigned int v3 = 3;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 520), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC055400000000000;
  unsigned int v3 = 4;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 520), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC052C00000000000;
  unsigned int v3 = 1;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 496), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC02E000000000000;
  unsigned int v3 = 2;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 496), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC02A000000000000;
  unsigned int v3 = 3;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 496), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC026000000000000;
  unsigned int v3 = 4;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 496), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC022000000000000;
  unsigned int v3 = 1;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 544), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC05A400000000000;
  unsigned int v3 = 2;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 544), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC056800000000000;
  unsigned int v3 = 3;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 544), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC052C00000000000;
  unsigned int v3 = 4;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 544), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0xC050400000000000;
  unsigned int v3 = 1;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 568), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0x4018000000000000;
  unsigned int v3 = 2;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 568), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0x402E000000000000;
  unsigned int v3 = 3;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 568), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0x4034000000000000;
  unsigned int v3 = 4;
  uint64_t v4 = &v3;
  sub_100ABC158((uint64_t **)(v1 + 568), &v3, (uint64_t)&unk_10144E20E, &v4)[5] = (uint64_t *)0x403E000000000000;
  unsigned int v3 = 2;
  v1 += 632;
  uint64_t v4 = &v3;
  *((_DWORD *)sub_100ABCA70((uint64_t **)v1, &v3, (uint64_t)&unk_10144E20E, &v4) + 8) = 8;
  unsigned int v3 = 3;
  uint64_t v4 = &v3;
  *((_DWORD *)sub_100ABCA70((uint64_t **)v1, &v3, (uint64_t)&unk_10144E20E, &v4) + 8) = 5;
  unsigned int v3 = 4;
  uint64_t v4 = &v3;
  *((_DWORD *)sub_100ABCA70((uint64_t **)v1, &v3, (uint64_t)&unk_10144E20E, &v4) + 8) = 5;
  unsigned int v3 = 5;
  uint64_t v4 = &v3;
  uint64_t result = sub_100ABCA70((uint64_t **)v1, &v3, (uint64_t)&unk_10144E20E, &v4);
  *((_DWORD *)result + 8) = 8;
  return result;
}

void sub_100AB9B0C(uint64_t a1, std::__shared_weak_count *a2, uint64_t a3)
{
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = 0;
  long long v14 = 0uLL;
  double v6 = *(double *)(a3 + 128);
  double v7 = 1.0;
  if (*(unsigned char *)(a3 + 488)) {
    BOOL v8 = v6 < -8.0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && *(double *)(a3 + 160) >= -70.0)
  {
    int v12 = 0;
    double v11 = v6 + 9.0;
    sub_100ABB420(&v12, &v11);
    double v7 = (double)v12;
    if ((double)v12 < 1.0) {
      double v7 = 1.0;
    }
  }
  long long v14 = *(unint64_t *)&v7;
  uint64_t v13 = 1;
  sub_100ABB280(a1, 0x100000001, (uint64_t)&v13);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = 0;
  long long v14 = 0uLL;
  double v9 = 1.0;
  if (*(unsigned char *)(a3 + 488))
  {
    if (*(double *)(a3 + 128) >= -8.0)
    {
      double v10 = *(double *)(a3 + 160);
      if (v10 >= -70.0)
      {
        int v12 = 0;
        double v11 = v10 + 71.0;
        sub_100ABB420(&v12, &v11);
        double v9 = (double)v12;
        if ((double)v12 < 1.0) {
          double v9 = 1.0;
        }
      }
    }
  }
  long long v14 = *(unint64_t *)&v9;
  uint64_t v13 = 1;
  sub_100ABB280(a1, 1, (uint64_t)&v13);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = 0;
  long long v14 = 0uLL;
  sub_100ABB280(a1, 0x200000001, (uint64_t)&v13);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v14 = xmmword_101536F60;
  uint64_t v13 = 1;
  sub_100ABB280(a1, 0x500000001, (uint64_t)&v13);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v14 = xmmword_101536F60;
  uint64_t v13 = 1;
  sub_100ABB280(a1, 0x600000001, (uint64_t)&v13);
  if (a2)
  {
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
  }
}

void sub_100AB9D3C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AB9DA4(uint64_t a1)
{
  unint64_t v2 = 0xC061400000000000;
  uint64_t v3 = 2;
  uint64_t v4 = &v2;
  uint64_t v5 = a1 + 368;
  sub_100ABC274((void *)(a1 + 368), 2, 2, &v3);
  unint64_t v2 = 0xC05A800000000000;
  uint64_t v3 = 2;
  uint64_t v4 = &v2;
  uint64_t v5 = a1 + 408;
  sub_100ABC274((void *)(a1 + 408), 2, 2, &v3);
}

void sub_100AB9E24(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) >= 2u)
  {
    unint64_t v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I resetStepUpTrend", buf, 2u);
    }
  }
  uint64_t v3 = 0;
  *(void *)std::string buf = 2;
  uint64_t v5 = &v3;
  uint64_t v6 = a1 + 448;
  sub_100ABC274((void *)(a1 + 448), 2, 2, (uint64_t *)buf);
}

uint64_t sub_100AB9EB8(uint64_t a1, uint64_t a2, double a3)
{
  if (a2 != 1)
  {
    if (*(_DWORD *)(a1 + 16) >= 3u)
    {
      uint64_t v6 = *(NSObject **)(a1 + 8);
      BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
      uint64_t v4 = 0;
      if (!v7) {
        return v4;
      }
      asString();
      if (v14 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)std::string buf = 136315394;
      long long v16 = p_p;
      __int16 v17 = 2048;
      double v18 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Input rejected of wrong type: %s = %f", buf, 0x16u);
      if (v14 < 0) {
        operator delete(__p);
      }
    }
    return 0;
  }
  uint64_t v4 = 0;
  switch(HIDWORD(a2))
  {
    case 0:
      if (a3 >= -35.0) {
        return 0;
      }
      double v5 = -138.0;
      if (a3 >= -138.0) {
        double v5 = a3;
      }
      *(double *)(a1 + 144) = v5;
      uint64_t v4 = 1;
      *(unsigned char *)(a1 + 152) = 1;
      break;
    case 1:
      if (a3 >= 0.0) {
        return 0;
      }
      double v9 = -31.5;
      if (a3 >= -31.5) {
        double v9 = a3;
      }
      *(double *)(a1 + 128) = v9;
      uint64_t v4 = 1;
      *(unsigned char *)(a1 + 136) = 1;
      break;
    case 5:
      double v11 = -138.0;
      if (a3 >= -138.0 && a3 <= -21.0) {
        double v11 = a3;
      }
      *(double *)(a1 + 176) = v11;
      uint64_t v4 = 1;
      *(unsigned char *)(a1 + 184) = 1;
      break;
    case 6:
      uint64_t v4 = 0;
      if (a3 < 48.0 && a3 >= 0.0)
      {
        *(double *)(a1 + 192) = a3;
        uint64_t v4 = 1;
        *(unsigned char *)(a1 + 20sub_1001A7358((uint64_t)&a9, 0) = 1;
      }
      break;
    default:
      return v4;
  }
  return v4;
}

void sub_100ABA0C4(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 489);
  if (v2 != a2)
  {
    double v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "true";
      if (v2) {
        BOOL v7 = "true";
      }
      else {
        BOOL v7 = "false";
      }
      if (!a2) {
        uint64_t v6 = "false";
      }
      int v8 = 136315394;
      double v9 = v7;
      __int16 v10 = 2080;
      double v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Step up going from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 489) = a2;
  }
}

double sub_100ABA1A8(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

uint64_t sub_100ABA1B0(void *a1, double *a2, uint64_t a3)
{
  uint64_t v3 = a1 + 1;
  uint64_t v4 = (void *)*a1;
  if ((void *)*a1 == a1 + 1) {
    return 5;
  }
  while (1)
  {
    unsigned int v12 = *((_DWORD *)v4 + 8);
    double v11 = *((double *)v4 + 5);
    (*(void (**)(uint64_t, double *, unsigned int *))(a3 + 16))(a3, &v11, &v12);
    if (*a2 < v11) {
      break;
    }
    BOOL v7 = (void *)v4[1];
    if (v7)
    {
      do
      {
        int v8 = v7;
        BOOL v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        int v8 = (void *)v4[2];
        BOOL v9 = *v8 == (void)v4;
        uint64_t v4 = v8;
      }
      while (!v9);
    }
    uint64_t v4 = v8;
    if (v8 == v3) {
      return 5;
    }
  }
  return v12;
}

void sub_100ABA278(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = *a3;
  if (*a3 >= 2)
  {
    double v6 = 0.5;
    if (v5 < *(_DWORD *)(v4 + 592)) {
      double v6 = -0.5;
    }
    *a2 = *a2 + v6;
  }
  if (*(_DWORD *)(v4 + 16) >= 0x14u)
  {
    BOOL v7 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = *a2;
      int v9 = *(_DWORD *)(v4 + 592);
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I in = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

void sub_100ABA374(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = *a3;
  if (*a3 >= 2)
  {
    double v6 = 2.0;
    if (v5 < *(_DWORD *)(v4 + 596)) {
      double v6 = -2.0;
    }
    *a2 = *a2 + v6;
  }
  if (*(_DWORD *)(v4 + 16) >= 0x14u)
  {
    BOOL v7 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = *a2;
      int v9 = *(_DWORD *)(v4 + 596);
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I in = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

void sub_100ABA470(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = *a3;
  if (*a3 >= 2)
  {
    double v6 = 2.0;
    if (v5 < *(_DWORD *)(v4 + 600)) {
      double v6 = -2.0;
    }
    *a2 = *a2 + v6;
  }
  if (*(_DWORD *)(v4 + 16) >= 0x14u)
  {
    BOOL v7 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = *a2;
      int v9 = *(_DWORD *)(v4 + 600);
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I in = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

void sub_100ABA56C(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = *a3;
  if (*a3 >= 2)
  {
    double v6 = -0.5;
    if (v5 > *(_DWORD *)(v4 + 604)) {
      double v6 = 0.5;
    }
    *a2 = *a2 + v6;
  }
  if (*(_DWORD *)(v4 + 16) >= 0x14u)
  {
    BOOL v7 = *(NSObject **)(v4 + 8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = *a2;
      int v9 = *(_DWORD *)(v4 + 604);
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I in = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

uint64_t sub_100ABA668()
{
  return 1000;
}

void sub_100ABA670(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I reset", v5, 2u);
  }
  SignalStrengthModel::reset((SignalStrengthModel *)a1, a2);
  sub_100ABA0C4(a1, 0);
  *(unsigned char *)(a1 + 49sub_1001A7358((uint64_t)&a9, 0) = 0;
  sub_100AB9DA4(a1);
  sub_100AB9E24(a1);
  *(void *)(a1 + 128) = 0xC033000000000000;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0xC061400000000000;
  *(unsigned char *)(a1 + 152) = 0;
  *(void *)(a1 + 16sub_1001A7358((uint64_t)&a9, 0) = 0xC05A800000000000;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0xC061400000000000;
  *(unsigned char *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 20sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 232) = *(void *)(a1 + 224);
  *(_DWORD *)(a1 + 22sub_1001A7358((uint64_t)&a9, 0) = *(_DWORD *)(a1 + 216);
  *(void *)(a1 + 272) = *(void *)(a1 + 264);
  *(_DWORD *)(a1 + 26sub_1001A7358((uint64_t)&a9, 0) = *(_DWORD *)(a1 + 256);
  *(void *)(a1 + 312) = *(void *)(a1 + 304);
  *(_DWORD *)(a1 + 30sub_1001A7358((uint64_t)&a9, 0) = *(_DWORD *)(a1 + 296);
  *(void *)(a1 + 352) = *(void *)(a1 + 344);
  *(_DWORD *)(a1 + 34sub_1001A7358((uint64_t)&a9, 0) = *(_DWORD *)(a1 + 336);
  *(void *)(a1 + 592) = 0x100000001;
  if (a2)
  {
    *(_DWORD *)(a1 + 68sub_1001A7358((uint64_t)&a9, 0) = *(_DWORD *)(a1 + 684);
    *(_DWORD *)(a1 + 684) = *(_DWORD *)(a1 + 608);
  }
  *(void *)(a1 + 62sub_1001A7358((uint64_t)&a9, 0) = 0;
  sub_100AB9B0C(*(void *)(a1 + 24), *(std::__shared_weak_count **)(a1 + 32), a1);
}

double sub_100ABA7B8(uint64_t a1)
{
  double result = *(double *)(a1 + 16);
  *(double *)(a1 + 24) = result;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_100ABA7CC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 684);
}

void sub_100ABA7D4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100ABA8F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ABA910(uint64_t a1)
{
  return *(unsigned int *)(a1 + 688);
}

uint64_t sub_100ABA918(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

unsigned int *sub_100ABA920(unsigned int *a1, unsigned int a2)
{
  *a1 = a2;
  if (!a2)
  {
    __TUAssertTrigger();
    a2 = *a1;
  }
  if (a2 >= 6) {
    __TUAssertTrigger();
  }
  return a1;
}

uint64_t *sub_100ABA970(uint64_t **a1, int *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v10 = 0;
  double v6 = sub_1003BA42C((uint64_t)a1, &v10, a2);
  BOOL v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    double v8 = (uint64_t **)v6;
    BOOL v7 = (uint64_t *)operator new(0x30uLL);
    void v7[4] = **a4;
    void v7[5] = 0;
    sub_100046C38(a1, v10, v8, v7);
  }
  return v7;
}

void sub_100ABA9FC()
{
}

uint64_t sub_100ABAA10(uint64_t result, double *a2, _DWORD *a3)
{
  if (*(_DWORD *)(result + 12) == *(_DWORD *)(result + 8)) {
    double v3 = *a2;
  }
  else {
    double v3 = (1.0 - *(double *)(result + 32)) * *(double *)(result + 24) + *(double *)(result + 32) * *a2;
  }
  *(double *)(result + 24) = v3;
  *(_DWORD *)(result + 12) = *a3;
  return result;
}

void *sub_100ABAA50(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
  {
    std::logic_error::logic_error(&v3, "circular_buffer");
    sub_100ABAAF8(&v3);
  }
  if (!a2) {
    return 0;
  }

  return operator new(8 * a2);
}

void sub_100ABAAE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::length_error a9)
{
}

void sub_100ABAAF8(const std::logic_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100ABAB54((uint64_t)exception, a1);
}

void sub_100ABAB40(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ABAB54(uint64_t a1, const std::logic_error *a2)
{
  *(void *)a1 = &off_10199A898;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_101A37668;
  *(void *)(a1 + 8) = off_101A37698;
  *(void *)(a1 + 24) = off_101A376C0;
  return a1;
}

uint64_t sub_100ABAC00(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::length_error::~length_error((std::length_error *)(a1 + 8));
  return a1;
}

void sub_100ABAC54()
{
}

void sub_100ABAE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100098B6C(&a9);
  sub_100098B6C(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_100ABAE98(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100ABB108((uint64_t)exception, a1);
}

void sub_100ABAEE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100ABAEF4(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::length_error::~length_error((std::length_error *)(a1 + 8));

  operator delete();
}

void sub_100ABAF68(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));

  std::length_error::~length_error((std::length_error *)a1);
}

void sub_100ABAFC4(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::length_error::~length_error((std::length_error *)a1);

  operator delete();
}

void sub_100ABB03C(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);

  std::length_error::~length_error((std::length_error *)a1 - 1);
}

void sub_100ABB094(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);
  std::length_error::~length_error((std::length_error *)a1 - 1);

  operator delete();
}

uint64_t sub_100ABB108(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10199A898;
  std::logic_error::logic_error((std::logic_error *)(a1 + 8), (const std::logic_error *)(a2 + 8));
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_10199A8F0;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v5;
  *(void *)a1 = &off_101A37668;
  *(void *)(a1 + 8) = off_101A37698;
  *(void *)(a1 + 24) = off_101A376C0;
  return a1;
}

void sub_100ABB230(_Unwind_Exception *a1)
{
  std::length_error::~length_error(v1);
  _Unwind_Resume(a1);
}

void sub_100ABB244(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = *(void **)a1;
  uint64_t v6 = v3 - v2;
  unint64_t v7 = (unint64_t)(v3 - (void)v5) >> 3;
  if (v4 < v6 >> 3) {
    unint64_t v7 = 0;
  }
  *(void *)(a1 + 16) = v2 + 8 * (v4 - v7);
  if (v5) {
    operator delete(v5);
  }
}

__n128 sub_100ABB280(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = a2;
  __n128 v10 = *(__n128 *)a3;
  uint64_t v11 = *(void *)(a3 + 16);
  long long v5 = sub_100ABB318((uint64_t **)(a1 + 8), (int *)&v9, (uint64_t)&v9);
  if (v7)
  {
    *(unsigned char *)a1 = 1;
  }
  else
  {
    double v8 = (__n128 *)(v5 + 40);
    if ((sub_100ABB3B0((uint64_t)(v5 + 40), a3) & 1) == 0)
    {
      *(unsigned char *)a1 = 1;
      __n128 result = *(__n128 *)a3;
      v8[1].n128_u64[0] = *(void *)(a3 + 16);
      *double v8 = result;
    }
  }
  return result;
}

char *sub_100ABB318(uint64_t **a1, int *a2, uint64_t a3)
{
  uint64_t v9 = 0;
  long long v5 = sub_1003BA42C((uint64_t)a1, &v9, a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    char v7 = (uint64_t **)v5;
    uint64_t v6 = (char *)operator new(0x40uLL);
    *((void *)v6 + 4) = *(void *)a3;
    *(_OWORD *)(v6 + 4sub_1001A7358((uint64_t)&a9, 0) = *(_OWORD *)(a3 + 8);
    *((void *)v6 + 7) = *(void *)(a3 + 24);
    sub_100046C38(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

uint64_t sub_100ABB3B0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100054998((void *)a2, 0, a2, 2u, (void *)a1);
  if (result) {
    return *(double *)(a2 + 8) == *(double *)(a1 + 8) && *(double *)(a2 + 16) == *(double *)(a1 + 16);
  }
  return result;
}

_DWORD *sub_100ABB420(_DWORD *result, double *a2)
{
  double v2 = *a2;
  if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
    sub_100ABB4D8("boost::math::round<%1%>(%1%)", "Value %1% can not be represented in the target integer type.");
  }
  double v3 = 0.0;
  if (v2 <= -0.5 || v2 >= 0.5)
  {
    if (v2 <= 0.0)
    {
      double v3 = floor(v2);
      double v5 = v2 - v3;
      double v6 = 1.0;
    }
    else
    {
      double v3 = ceil(v2);
      double v5 = v3 - v2;
      double v6 = -1.0;
    }
    double v7 = v3 + v6;
    if (v5 > 0.5) {
      double v3 = v7;
    }
  }
  *uint64_t result = (int)v3;
  return result;
}

void sub_100ABB4D8(char *a1, char *a2)
{
  double v2 = "Unknown function operating on type %1%";
  if (a1) {
    double v2 = a1;
  }
  if (a2) {
    double v3 = a2;
  }
  else {
    double v3 = "Cause unknown: error caused by bad argument with value %1%";
  }
  memset(&v14, 0, sizeof(v14));
  sub_100058DB0(&v14, v2);
  memset(&v13, 0, sizeof(v13));
  sub_100058DB0(&v13, v3);
  memset(&v12, 0, sizeof(v12));
  sub_100058DB0(&v12, "Error in function ");
  sub_100ABB6B4(&v14, "%1%", "double");
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v14;
  }
  else {
    uint64_t v4 = (std::string *)v14.__r_.__value_.__r.__words[0];
  }
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
  }
  std::string::append(&v12, (const std::string::value_type *)v4, size);
  std::string::append(&v12, ": ", 2uLL);
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  sub_100ABB7FC(v10);
  if (v11 >= 0) {
    double v6 = (const char *)v10;
  }
  else {
    double v6 = (const char *)v10[0];
  }
  sub_100ABB6B4(&v13, "%1%", v6);
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    double v7 = &v13;
  }
  else {
    double v7 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v8 = HIBYTE(v13.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v8 = v13.__r_.__value_.__l.__size_;
  }
  std::string::append(&v12, (const std::string::value_type *)v7, v8);
  v9.__vftable = 0;
  v9.__imp_.__imp_ = 0;
  std::runtime_error::runtime_error(&v9, &v12);
  v9.__vftable = (std::runtime_error_vtbl *)&off_101A376E0;
  sub_100ABB9D0(&v9);
}

void sub_100ABB638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::runtime_error a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::runtime_error::~runtime_error(&a9);
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v27 - 17) < 0) {
    operator delete(*(void **)(v27 - 40));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ABB6B4(std::string *a1, char *__s, const char *a3)
{
  size_t v6 = strlen(__s);
  size_t v7 = strlen(a3);
  int v8 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
  if (v8 >= 0) {
    std::runtime_error v9 = (uint64_t *)a1;
  }
  else {
    std::runtime_error v9 = (uint64_t *)a1->__r_.__value_.__r.__words[0];
  }
  if (v8 >= 0) {
    std::string::size_type size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = a1->__r_.__value_.__l.__size_;
  }
  uint64_t result = strlen(__s);
  int64_t v12 = result;
  std::string::size_type v13 = 0;
  while (!v12)
  {
LABEL_18:
    if (v13 != -1)
    {
      size_t v19 = strlen(a3);
      std::string::replace(a1, v13, v6, a3, v19);
      v13 += v7;
      int v20 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
      std::runtime_error v9 = v20 >= 0 ? (uint64_t *)a1 : (uint64_t *)a1->__r_.__value_.__r.__words[0];
      std::string::size_type size = v20 >= 0 ? HIBYTE(a1->__r_.__value_.__r.__words[2]) : a1->__r_.__value_.__l.__size_;
      uint64_t result = strlen(__s);
      int64_t v12 = result;
      if (size >= v13) {
        continue;
      }
    }
    return result;
  }
  uint64_t result = (uint64_t)v9 + v13;
  std::string::size_type v14 = (std::string::size_type)v9 + size;
  int64_t v15 = size - v13;
  if ((uint64_t)(size - v13) >= v12)
  {
    int v16 = *__s;
    do
    {
      int64_t v17 = v15 - v12;
      if (v17 == -1) {
        break;
      }
      uint64_t result = (uint64_t)memchr((void *)result, v16, v17 + 1);
      if (!result) {
        break;
      }
      uint64_t v18 = result;
      uint64_t result = memcmp((const void *)result, __s, v12);
      if (!result)
      {
        if (v18 == v14) {
          return result;
        }
        std::string::size_type v13 = v18 - (void)v9;
        goto LABEL_18;
      }
      uint64_t result = v18 + 1;
      int64_t v15 = v14 - (v18 + 1);
    }
    while (v15 >= v12);
  }
  return result;
}

uint64_t sub_100ABB7FC@<X0>(void *a1@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  long long v4 = 0u;
  sub_10004BD84((uint64_t)&v4);
  *(void *)((char *)&v5[1] + *(void *)(*(void *)&v5[0] - 24)) = 17;
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v5 + 8, a1);
  *(void *)((char *)&v5[-1]
  *(void *)&v5[0] = v2;
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100ABB9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100ABB9D0(const std::runtime_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100ABBA68((uint64_t)exception, a1);
}

void sub_100ABBA18(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100ABBA30(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);

  operator delete();
}

uint64_t sub_100ABBA68(uint64_t a1, const std::runtime_error *a2)
{
  *(void *)a1 = &off_10199A898;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &off_101A37768;
  *(void *)(a1 + 8) = off_101A37798;
  *(void *)(a1 + 24) = off_101A377C0;
  return a1;
}

uint64_t sub_100ABBB14(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

void sub_100ABBB68()
{
}

void sub_100ABBD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100098B6C(&a9);
  sub_100098B6C(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_100ABBDAC(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  sub_100ABC01C((uint64_t)exception, a1);
}

void sub_100ABBDF4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100ABBE08(uint64_t a1)
{
  *(void *)(a1 + 24) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  operator delete();
}

void sub_100ABBE7C(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));

  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

void sub_100ABBED8(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);

  operator delete();
}

void sub_100ABBF50(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);

  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
}

void sub_100ABBFA8(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);

  operator delete();
}

uint64_t sub_100ABC01C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10199A898;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(void *)(a1 + 8) = &off_101A376E0;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &off_10199A8F0;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v5;
  *(void *)a1 = &off_101A37768;
  *(void *)(a1 + 8) = off_101A37798;
  *(void *)(a1 + 24) = off_101A377C0;
  return a1;
}

void sub_100ABC144(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_100ABC158(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  long long v7 = a1 + 1;
  size_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        long long v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        size_t v6 = *v9;
        long long v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      size_t v6 = v9[1];
      if (!v6)
      {
        long long v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v9 = a1 + 1;
LABEL_10:
    long long v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void *sub_100ABC21C(void *result, void *a2)
{
  uint64_t v2 = (void *)*result;
  double v3 = (void *)result[1];
  uint64_t v4 = result[4];
  if (v4 == ((uint64_t)v3 - *result) >> 3)
  {
    if (v3 != v2)
    {
      long long v5 = (void *)result[3];
      void *v5 = *a2;
      size_t v6 = v5 + 1;
      if (v6 != v3) {
        uint64_t v2 = v6;
      }
      result[2] = v2;
      result[3] = v2;
    }
  }
  else
  {
    long long v7 = (void *)result[3];
    void *v7 = *a2;
    unsigned int v8 = v7 + 1;
    if (v8 != v3) {
      uint64_t v2 = v8;
    }
    result[3] = v2;
    result[4] = v4 + 1;
  }
  return result;
}

void sub_100ABC274(void *a1, int64_t a2, int64_t a3, uint64_t *a4)
{
  unsigned int v8 = (void *)*a1;
  if (a2 == (uint64_t)(a1[1] - *a1) >> 3)
  {
    uint64_t v9 = *a4;
    if (*a4)
    {
      uint64_t v10 = 0;
      long long v11 = (void *)a4[1];
      do
        v8[v10++] = *v11;
      while (v9 != v10);
    }
  }
  else
  {
    long long v12 = sub_100ABAA50((uint64_t)a1, a2);
    unsigned int v8 = v12;
    uint64_t v13 = *a4;
    if (*a4)
    {
      long long v14 = (void *)a4[1];
      long long v15 = v12;
      do
      {
        *v15++ = *v14;
        --v13;
      }
      while (v13);
    }
    sub_100ABB244((uint64_t)a1);
    *a1 = v8;
    a1[1] = &v8[a2];
  }
  if (a2 <= a3) {
    int64_t v16 = a2;
  }
  else {
    int64_t v16 = 0;
  }
  a1[2] = v8;
  a1[3] = &v8[a3 - v16];
  a1[4] = a3;
}

uint64_t *sub_100ABC340(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100ABC398(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_100ABC380(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100ABC398(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    long long v5 = (uint64_t **)result;
    size_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100ABC424(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      long long v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          unsigned int v8 = v7;
          long long v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100ABC424(uint64_t **a1, uint64_t *a2, unsigned int *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  long long v11 = 0;
  size_t v6 = sub_100ABC4B0(a1, a2, &v11, &v10, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    long long v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_100ABC4B0(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  long long v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unsigned int v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    unsigned int v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          long long v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          long long v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        long long v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      long long v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    long long v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      long long v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    size_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      size_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unsigned int v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          long long v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        long long v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      unsigned int v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void sub_100ABC658(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v2 = a2;
  operator new();
}

void sub_100ABC6DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100ABC7D4((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_100ABC6F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100ABC730(uint64_t a1)
{
}

uint64_t sub_100ABC738(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_100ABC77C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1000346F8(a2, *(void **)(a2 + 8));
    operator delete();
  }
}

uint64_t *sub_100ABC7D4(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    sub_1000346F8(v2, *(void **)(v2 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100ABC838(_DWORD *a1, _DWORD *a2, int a3, unsigned int a4)
{
  long long v5 = a2;
  unsigned int v7 = a1 + 19;
  unsigned int v8 = a1[19];
  unsigned int v9 = *a2;
  int v10 = *a2 - v8;
  if (*a2 > v8) {
    int v11 = 1;
  }
  else {
    int v11 = 2;
  }
  if (v9 == v8) {
    int v12 = 0;
  }
  else {
    int v12 = v11;
  }
  if (a3)
  {
    a1[4] = v12;
    uint64_t v13 = a1 + 4;
    if (v9 != v8)
    {
      BOOL v14 = a1 + 3;
      ++a1[3];
      goto LABEL_10;
    }
LABEL_23:
    uint64_t result = 0;
    a1[3] = 0;
    a1[4] = 0;
    return result;
  }
  if (v9 == v8) {
    goto LABEL_23;
  }
  int v25 = v12;
  unsigned int v18 = a1[3] + 1;
  unsigned int v24 = a1 + 3;
  a1[3] = v18;
  uint64_t v13 = a1 + 4;
  int v19 = a1[4];
  unsigned int v20 = sub_100ABC9FC((uint64_t)a1, a1 + 19, v19);
  if (v19 == v11)
  {
    BOOL v21 = v18 >= v20;
    long long v5 = a2;
    int v12 = v25;
    BOOL v14 = v24;
    if (!v21) {
      return 0;
    }
  }
  else
  {
    a1[3] = 0;
    a1[4] = v11;
    int v23 = sub_100ABC9FC((uint64_t)a1, v7, v11);
    uint64_t result = 0;
    long long v5 = a2;
    int v12 = v25;
    BOOL v14 = v24;
    if (v23) {
      return result;
    }
  }
LABEL_10:
  if (v10 >= 0) {
    unsigned int v15 = v10;
  }
  else {
    unsigned int v15 = -v10;
  }
  if (v15 >= a4) {
    unsigned int v16 = a4;
  }
  else {
    unsigned int v16 = v15;
  }
  a1[18] = v8;
  if (v9 <= v8)
  {
    for (; v16; --v16)
    {
      if (v8 <= 1)
      {
        __TUAssertTrigger();
        unsigned int v8 = *v7;
      }
      unsigned int *v7 = --v8;
    }
  }
  else
  {
    for (; v16; --v16)
    {
      if (v8 >= 5)
      {
        __TUAssertTrigger();
        unsigned int v8 = *v7;
      }
      unsigned int *v7 = ++v8;
    }
  }
  if (v8 == *v5) {
    int v22 = 0;
  }
  else {
    int v22 = v12;
  }
  _DWORD *v14 = 0;
  *uint64_t v13 = v22;
  return 1;
}

uint64_t sub_100ABC9FC(uint64_t a1, unsigned int *a2, int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a1 + 48;
  if (a3 != 1) {
    uint64_t v3 = a1 + 24;
  }
  uint64_t v4 = 4;
  if (a3 == 1) {
    uint64_t v4 = 8;
  }
  uint64_t result = *(unsigned int *)(a1 + v4);
  uint64_t v8 = *(void *)(v3 + 8);
  uint64_t v6 = v3 + 8;
  uint64_t v7 = v8;
  if (v8)
  {
    unsigned int v9 = *a2;
    uint64_t v10 = v6;
    do
    {
      unsigned int v11 = *(_DWORD *)(v7 + 28);
      BOOL v12 = v11 >= v9;
      if (v11 >= v9) {
        uint64_t v13 = (uint64_t *)v7;
      }
      else {
        uint64_t v13 = (uint64_t *)(v7 + 8);
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }
    while (*v13);
    if (v10 != v6 && v9 >= *(_DWORD *)(v10 + 28)) {
      return *(unsigned int *)(v10 + 32);
    }
  }
  return result;
}

uint64_t *sub_100ABCA70(uint64_t **a1, unsigned int *a2, uint64_t a3, unsigned int **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unsigned int v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v9 = a1 + 1;
LABEL_10:
    unsigned int v11 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v11 + 28) = **a4;
    sub_100046C38(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void SignalStrengthController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100ABD30C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, ctu::OsLogLogger *a12, SignalStrengthModelDelegateInterface *a13, LinkQualityMetricModelDelegateInterface *a14, uint64_t a15, dispatch_object_t a16, dispatch_object_t object, uint64_t a18, dispatch_object_t a19, dispatch_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_100ABD668(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  if (v12) {
    dispatch_release(v12);
  }
  JUMPOUT(0x100ABD5B0);
}

const char *sub_100ABD6AC(int a1)
{
  uint64_t v1 = "sig.?";
  if (a1 == 2) {
    uint64_t v1 = "sig.2";
  }
  if (a1 == 1) {
    return "sig.1";
  }
  else {
    return v1;
  }
}

void *sub_100ABD6D8(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100AC2210((void *)a1);
}

void sub_100ABD718(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100ABD818(uint64_t a1)
{
  *(void *)a1 = off_101A37858;
  uint64_t v2 = (LinkQualityMetricModelDelegateInterface *)(a1 + 8);
  *(void *)(a1 + 8) = off_101A378C8;
  uint64_t v3 = (SignalStrengthModelDelegateInterface *)(a1 + 16);
  *(void *)(a1 + 16) = off_101A378F0;
  sub_100ABDA18(a1);
  uint64_t v4 = *(NSObject **)(a1 + 440);
  if (v4) {
    dispatch_release(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 432);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 416);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100160A84((atomic_uint **)(a1 + 384));
  uint64_t v7 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  sub_100119D90(*(void **)(a1 + 360));
  sub_10003FB28(a1 + 328, *(void **)(a1 + 336));
  sub_100087F94(a1 + 296, *(void **)(a1 + 304));
  sub_10026CF54(a1 + 272, *(void **)(a1 + 280));
  sub_1000346F8(a1 + 224, *(void **)(a1 + 232));
  sub_1000346F8(a1 + 200, *(void **)(a1 + 208));
  sub_1000346F8(a1 + 176, *(void **)(a1 + 184));
  sub_1000346F8(a1 + 152, *(void **)(a1 + 160));
  sub_100AC2210((void *)(a1 + 120));
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 112);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  unsigned int v10 = *(std::__shared_weak_count **)(a1 + 80);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));
  sub_100087E88((void *)(a1 + 24));
  SignalStrengthModelDelegateInterface::~SignalStrengthModelDelegateInterface(v3);
  LinkQualityMetricModelDelegateInterface::~LinkQualityMetricModelDelegateInterface(v2);

  SignalStrengthInterface::~SignalStrengthInterface((SignalStrengthInterface *)a1);
}

uint64_t sub_100ABDA18(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 376)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v5 = 136315138;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stopping timer (has timer=%s)", (uint8_t *)&v5, 0xCu);
  }
  uint64_t result = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_100ABDB04(uint64_t a1)
{
}

void sub_100ABDB0C(uint64_t a1)
{
}

void sub_100ABDB14(uint64_t a1)
{
  sub_100ABD818(a1);

  operator delete();
}

void sub_100ABDB4C(uint64_t a1)
{
  sub_100ABD818(a1 - 8);

  operator delete();
}

void sub_100ABDB88(uint64_t a1)
{
  sub_100ABD818(a1 - 16);

  operator delete();
}

uint64_t sub_100ABDBC4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 296);
  uint64_t v3 = (void *)(result + 304);
  if (v2 != (void *)(result + 304))
  {
    uint64_t v4 = result;
    int v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      unsigned int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          unsigned int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_22;
      }
      uint64_t result = rest::operator==();
      if ((result & 1) == 0)
      {
        unsigned int v19 = *((_DWORD *)v2 + 8);
        unsigned int v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 64) + 16))(*(void *)(v4 + 64), v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v25 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Received Operator Bundle setup: %s", buf, 0xCu);
        }
        uint64_t result = (uint64_t)sub_1000389F8(*(uint64_t **)(v4 + 360), v19);
        uint64_t v22 = *(void *)(*(void *)result + 8);
        uint64_t v23 = *(void *)(*(void *)result + 16);
        while (v22 != v23)
        {
          uint64_t result = (*(uint64_t (**)(void))(**(void **)(v22 + 8) + 88))(*(void *)(v22 + 8));
          v22 += 24;
        }
      }
LABEL_14:
      BOOL v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          BOOL v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          uint64_t v2 = v13;
        }
        while (!v14);
      }
      uint64_t v2 = v13;
      if (v13 == v3) {
        return result;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_22:
    unsigned int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 64) + 16))(*(void *)(v4 + 64), v7);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v25 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Received Operator Bundle setup: %s", buf, 0xCu);
    }
    uint64_t result = (uint64_t)sub_1000389F8(*(uint64_t **)(v4 + 360), v7);
    uint64_t v17 = *(void *)(*(void *)result + 8);
    uint64_t v18 = *(void *)(*(void *)result + 16);
    while (v17 != v18)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v17 + 8) + 88))(*(void *)(v17 + 8));
      v17 += 24;
    }
    goto LABEL_14;
  }
  return result;
}

void sub_100ABDE7C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  uint64_t v7 = *sub_1000389F8(*(uint64_t **)(a1 + 360), a2);
  unsigned int v8 = sub_1000389F8(*(uint64_t **)(a1 + 360), a2);
  if (a3 > 0xA) {
    int v9 = 1;
  }
  else {
    int v9 = dword_101539A4C[a3];
  }
  uint64_t v10 = *v8;
  uint64_t v11 = sub_1000389F8(*(uint64_t **)(a1 + 360), a2);
  BOOL v12 = *(int **)(*v11 + 8);
  uint64_t v13 = *(int **)(*v11 + 16);
  if (v12 != v13)
  {
    while (*v12 != v9)
    {
      v12 += 6;
      if (v12 == v13) {
        goto LABEL_14;
      }
    }
  }
  if (v12 == v13)
  {
LABEL_14:
    uint64_t v16 = 0;
    unsigned int v15 = 0;
    goto LABEL_15;
  }
  int v14 = *v12;
  uint64_t v16 = *((void *)v12 + 1);
  unsigned int v15 = (std::__shared_weak_count *)*((void *)v12 + 2);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v14)
  {
LABEL_15:
    BOOL v17 = v16 != 0;
    if (!v15) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  BOOL v17 = 1;
  if (v15) {
LABEL_16:
  }
    sub_10004D2C8(v15);
LABEL_17:
  if (v17) {
    int v18 = v9;
  }
  else {
    int v18 = 1;
  }
  unsigned int v19 = *(int **)(v7 + 8);
  unsigned int v20 = *(int **)(v7 + 16);
  if (v19 != v20)
  {
    while (*v19 != v18)
    {
      v19 += 6;
      if (v19 == v20) {
        goto LABEL_27;
      }
    }
  }
  if (v19 == v20)
  {
LABEL_27:
    int v21 = 0;
    uint64_t v23 = 0;
    uint64_t v22 = 0;
  }
  else
  {
    int v21 = *v19;
    uint64_t v23 = (SignalStrengthModel *)*((void *)v19 + 1);
    uint64_t v22 = (std::__shared_weak_count *)*((void *)v19 + 2);
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  if (v21 == *(_DWORD *)(v10 + 32) && v23 == *(SignalStrengthModel **)(v10 + 40))
  {
    uint64_t v27 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = 136315138;
      uint64_t v29 = asString();
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Ignoring RAT change %s", (uint8_t *)&v28, 0xCu);
    }
  }
  else
  {
    sub_100ABDA18(a1);
    *(_DWORD *)(v10 + 32) = v21;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v24 = *(std::__shared_weak_count **)(v10 + 48);
    *(void *)(v10 + 4sub_1001A7358((uint64_t)&a9, 0) = v23;
    *(void *)(v10 + 48) = v22;
    if (v24)
    {
      sub_10004D2C8(v24);
      uint64_t v23 = *(SignalStrengthModel **)(v10 + 40);
    }
    SignalStrengthModel::setForceNotificationOnNextHeartbeat(v23, 1);
    uint64_t v25 = *v6;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = (*(uint64_t (**)(void))(**(void **)(v10 + 40) + 16))(*(void *)(v10 + 40));
      int v28 = 136315138;
      uint64_t v29 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Selected model: %s", (uint8_t *)&v28, 0xCu);
    }
    if (isSet())
    {
      sub_1000388F4(a1, a2, 1);
      sub_100ABE874(a1);
      sub_100ABE2A0(a1, a2);
    }
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
}

void sub_100ABE18C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ABE1AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100025E5C(&v10, a1, a2);
  uint64_t v6 = v10;
  if (v10)
  {
    *(unsigned char *)(v10 + 56) = 0;
    uint64_t v7 = *(void *)(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 16);
    while (v7 != v8)
    {
      (*(void (**)(void, uint64_t))(**(void **)(v7 + 8) + 40))(*(void *)(v7 + 8), a3);
      v7 += 24;
    }
    sub_100ABEB54(a1, a2);
  }
  int v9 = v11;
  if (v11)
  {
    sub_10004D2C8(v9);
  }
}

void sub_100ABE284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ABE2A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Polling for latest values", v6, 2u);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 408) + 40))(*(void *)(a1 + 408), a2);
}

void sub_100ABE364(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 352);
  uint64_t v4 = (void *)(a1 + 360);
  if (v3 != (void *)(a1 + 360))
  {
    int v5 = (uint64_t *)(a2 + 8);
    uint64_t v6 = (uint64_t *)(a1 + 184);
    do
    {
      uint64_t v7 = *((unsigned int *)v3 + 8);
      uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), v7);
      int v9 = v8;
      uint64_t v10 = *v5;
      if (*v5)
      {
        do
        {
          if (*(_DWORD *)(v10 + 28) >= (int)v7) {
            uint64_t v11 = (uint64_t *)v10;
          }
          else {
            uint64_t v11 = (uint64_t *)(v10 + 8);
          }
          uint64_t v10 = *v11;
        }
        while (*v11);
      }
      uint64_t v12 = *v6;
      if (!*v6) {
        goto LABEL_18;
      }
      uint64_t v13 = a1 + 184;
      do
      {
        int v14 = *(_DWORD *)(v12 + 28);
        BOOL v15 = v14 < (int)v7;
        if (v14 >= (int)v7) {
          uint64_t v16 = (uint64_t *)v12;
        }
        else {
          uint64_t v16 = (uint64_t *)(v12 + 8);
        }
        if (!v15) {
          uint64_t v13 = v12;
        }
        uint64_t v12 = *v16;
      }
      while (*v16);
      if ((uint64_t *)v13 != v6 && *(_DWORD *)(v13 + 28) <= (int)v7) {
        unsigned int v17 = *(_DWORD *)(v13 + 32);
      }
      else {
LABEL_18:
      }
        unsigned int v17 = 11;
      int v18 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = asString();
        uint64_t v20 = asString();
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v56 = v19;
        __int16 v57 = 2080;
        uint64_t v58 = v20;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Handling RAT changed from %s to %s", buf, 0x16u);
      }
      sub_100ABDE7C(a1, v7, v17);
      int v21 = *(SignalStrengthModel **)(*sub_1000389F8(*(uint64_t **)(a1 + 360), v7) + 40);
      if (*((_DWORD *)v21 + 16) != v17)
      {
        *((_DWORD *)v21 + 16) = v17;
        SignalStrengthModel::setImmediateMode(v21);
        uint64_t v22 = *v9;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Resetting state due to RAT change", buf, 2u);
        }
        sub_100ABE1AC(a1, v7, 0);
        sub_100ABE2A0(a1, v7);
      }
      uint64_t v23 = isSet();
      uint64_t v24 = *v4;
      if (*v4)
      {
        uint64_t v25 = v23;
        uint64_t v26 = v4;
        do
        {
          int v27 = *(_DWORD *)(v24 + 32);
          BOOL v28 = v27 < (int)v7;
          if (v27 >= (int)v7) {
            uint64_t v29 = (uint64_t *)v24;
          }
          else {
            uint64_t v29 = (uint64_t *)(v24 + 8);
          }
          if (!v28) {
            uint64_t v26 = (void *)v24;
          }
          uint64_t v24 = *v29;
        }
        while (*v29);
        if (v26 != v4 && *((_DWORD *)v26 + 8) <= (int)v7)
        {
          uint64_t v30 = v26[5];
          uint64_t v31 = *(void *)(v30 + 80);
          unsigned int v32 = *(std::__shared_weak_count **)(v30 + 88);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v31) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 56))(v31, v25);
          }
          if (v32) {
            sub_10004D2C8(v32);
          }
        }
        uint64_t v33 = *v4;
        if (*v4)
        {
          uint64_t v34 = v4;
          do
          {
            int v35 = *(_DWORD *)(v33 + 32);
            BOOL v36 = v35 < (int)v7;
            if (v35 >= (int)v7) {
              long long v37 = (uint64_t *)v33;
            }
            else {
              long long v37 = (uint64_t *)(v33 + 8);
            }
            if (!v36) {
              uint64_t v34 = (void *)v33;
            }
            uint64_t v33 = *v37;
          }
          while (*v37);
          if (v34 != v4 && *((_DWORD *)v34 + 8) <= (int)v7)
          {
            uint64_t v38 = v34[5];
            uint64_t v39 = *(void *)(v38 + 96);
            xpc_object_t v40 = *(std::__shared_weak_count **)(v38 + 104);
            if (v40) {
              atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v39) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v39 + 56))(v39, v25);
            }
            if (v40) {
              sub_10004D2C8(v40);
            }
          }
          uint64_t v41 = *v4;
          if (*v4)
          {
            uint64_t v42 = v4;
            do
            {
              int v43 = *(_DWORD *)(v41 + 32);
              BOOL v44 = v43 < (int)v7;
              if (v43 >= (int)v7) {
                char v45 = (uint64_t *)v41;
              }
              else {
                char v45 = (uint64_t *)(v41 + 8);
              }
              if (!v44) {
                uint64_t v42 = (void *)v41;
              }
              uint64_t v41 = *v45;
            }
            while (*v45);
            if (v42 != v4 && *((_DWORD *)v42 + 8) <= (int)v7)
            {
              uint64_t v46 = v42[5];
              uint64_t v47 = *(void *)(v46 + 112);
              CFArrayRef v48 = *(std::__shared_weak_count **)(v46 + 120);
              if (v48) {
                atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (v47) {
                (*(void (**)(uint64_t, uint64_t))(*(void *)v47 + 56))(v47, v25);
              }
              if (v48) {
                sub_10004D2C8(v48);
              }
            }
          }
        }
      }
      CFTypeID v49 = (void *)v3[1];
      if (v49)
      {
        do
        {
          CFIndex v50 = v49;
          CFTypeID v49 = (void *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          CFIndex v50 = (void *)v3[2];
          BOOL v51 = *v50 == (void)v3;
          uint64_t v3 = v50;
        }
        while (!v51);
      }
      uint64_t v3 = v50;
    }
    while (v50 != v4);
  }
  CFIndex v52 = *(void **)(a1 + 176);
  if (v52 != (void *)(a1 + 184))
  {
    while ((isSet() & 1) == 0)
    {
      std::string::size_type v53 = (void *)v52[1];
      if (v53)
      {
        do
        {
          __int16 v54 = v53;
          std::string::size_type v53 = (void *)*v53;
        }
        while (v53);
      }
      else
      {
        do
        {
          __int16 v54 = (void *)v52[2];
          BOOL v51 = *v54 == (void)v52;
          CFIndex v52 = v54;
        }
        while (!v51);
      }
      CFIndex v52 = v54;
      if (v54 == (void *)(a1 + 184)) {
        return;
      }
    }
    if (!*(void *)(a1 + 376))
    {
      sub_100ABE874(a1);
    }
  }
}

void sub_100ABE84C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ABE874(uint64_t a1)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 352);
  uint64_t v3 = (uint64_t **)(a1 + 360);
  uint64_t v4 = 1000;
  if (v2 != (uint64_t **)(a1 + 360))
  {
    do
    {
      int v5 = sub_1000389F8(*v3, *((_DWORD *)v2 + 8));
      uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(*v5 + 40) + 32))(*(void *)(*v5 + 40));
      if (v6 < v4) {
        uint64_t v4 = v6;
      }
      uint64_t v7 = v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = (uint64_t **)v7;
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (uint64_t **)v2[2];
          BOOL v9 = *v8 == (uint64_t *)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = v8;
    }
    while (v8 != v3);
  }
  uint64_t v10 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Heartbeat interval %lld ms", buf, 0xCu);
  }
  *(_OWORD *)std::string buf = 0uLL;
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 72));
  uint64_t v11 = *(void *)buf;
  sub_100058DB0(__p, "signal strength heartbeat");
  uint64_t v12 = *(NSObject **)(a1 + 40);
  dispatch_object_t object = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1000387DC;
  aBlock[3] = &unk_101A37910;
  aBlock[4] = a1;
  unsigned int v17 = _Block_copy(aBlock);
  sub_10038ECF0(v11, (uint64_t)__p, 0, 1000 * v4, &object, &v17);
  uint64_t v13 = v21;
  uint64_t v21 = 0;
  uint64_t v14 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    uint64_t v15 = v21;
    uint64_t v21 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  if (v17) {
    _Block_release(v17);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_100ABEAEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ABEB54(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  sub_100025E5C(&v27, a1, a2);
  uint64_t v5 = v27;
  if (!v27)
  {
    os_log_t v9 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_35;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v10 = "#N Unexpected slot received";
    uint64_t v11 = v9;
    uint32_t v12 = 2;
    goto LABEL_34;
  }
  uint64_t v6 = *(void *)(v27 + 40);
  uint64_t v7 = *(void *)(v6 + 48);
  if ((v7 & 5) != 0)
  {
    if ((v7 & 2) != 0 || !*(unsigned char *)(v6 + 40)) {
      int v8 = 1;
    }
    else {
      int v8 = *(unsigned char *)(v6 + 104) & 1;
    }
  }
  else
  {
    int v8 = 0;
  }
  int v13 = *(unsigned __int8 *)(v27 + 57);
  if (*(unsigned char *)(v27 + 58))
  {
    os_log_t v14 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_35;
    }
    uint64_t v15 = "false";
    if (v8) {
      uint64_t v16 = "true";
    }
    else {
      uint64_t v16 = "false";
    }
    if (v13) {
      uint64_t v15 = "true";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)uint64_t v30 = v16;
    *(_WORD *)&v30[8] = 2080;
    uint64_t v31 = v15;
    uint64_t v10 = "#I Start/stop in progress. Model requires inputs %s, running %s";
LABEL_33:
    uint64_t v11 = v14;
    uint32_t v12 = 22;
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    goto LABEL_35;
  }
  if ((((v13 != 0) ^ v8) & 1) == 0)
  {
    os_log_t v14 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_35;
    }
    uint64_t v23 = "false";
    if (v8) {
      uint64_t v24 = "true";
    }
    else {
      uint64_t v24 = "false";
    }
    if (v13) {
      uint64_t v23 = "true";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)uint64_t v30 = v24;
    *(_WORD *)&v30[8] = 2080;
    uint64_t v31 = v23;
    uint64_t v10 = "#I No change. Model requires inputs %s, running %s";
    goto LABEL_33;
  }
  sub_100ABEEE0(v27, 1);
  unsigned int v17 = *v4;
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v18)
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)uint64_t v30 = v8;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v13;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Starting driver. Model requires inputs %d, running %d", buf, 0xEu);
    }
    sub_100ABE2A0(a1, a2);
    uint64_t v19 = *(void *)(a1 + 408);
    uint64_t v20 = *(void *)(v5 + 40);
    uint64_t v22 = *(void *)(v20 + 24);
    uint64_t v21 = *(std::__shared_weak_count **)(v20 + 32);
    uint64_t v25 = v22;
    uint64_t v26 = v21;
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v19 + 48))(v19, a2, &v25);
    if (v26) {
      sub_10004D2C8(v26);
    }
  }
  else
  {
    if (v18)
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)uint64_t v30 = 0;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v13;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Stopping driver. Model requires inputs %d, controller is running %d", buf, 0xEu);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 408) + 64))(*(void *)(a1 + 408), a2);
  }
LABEL_35:
  if (v28) {
    sub_10004D2C8(v28);
  }
}

void sub_100ABEEB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ABEEE0(uint64_t a1, int a2)
{
  uint64_t v4 = **(NSObject ***)a1;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "true";
    if (*(unsigned char *)(a1 + 58)) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    if (!a2) {
      uint64_t v5 = "false";
    }
    int v7 = 136315394;
    int v8 = v6;
    __int16 v9 = 2080;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I In progress is changing from %s to %s", (uint8_t *)&v7, 0x16u);
  }
  *(unsigned char *)(a1 + 58) = a2;
}

void sub_100ABEFC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v9[6] = a5;
  aBlocCFIndex k = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100AC52B0;
  v9[3] = &unk_101A37CC8;
  v9[4] = a2;
  v9[5] = a4;
  aBlocCFIndex k = _Block_copy(v9);
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6)
  {
    int v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      int v8 = v7;
      sub_1001644F8(v11, &aBlock, *(dispatch_object_t *)(a2 + 16));
      sub_100164540(&v12, v11);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100ABF200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20)
{
  if (a2)
  {
    sub_100163BC8(v21 - 80);
    uint64_t v23 = *(void *)(v21 - 88);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    std::__shared_weak_count::__release_weak(v20);
    sub_100161C9C((uint64_t)&a19);
    sub_10016578C((uint64_t)&a17);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ABF2B8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 352);
  uint64_t v2 = (void *)(a1 + 360);
  if (v1 != (void *)(a1 + 360))
  {
    do
    {
      uint64_t v4 = v1[5];
      uint64_t v5 = *(void *)(v4 + 8);
      uint64_t v6 = *(void *)(v4 + 16);
      while (v5 != v6)
      {
        SignalStrengthModel::setImmediateMode(*(SignalStrengthModel **)(v5 + 8));
        v5 += 24;
      }
      sub_100ABEB54(a1, *((unsigned int *)v1 + 8));
      int v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v9);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
}

void sub_100ABF35C(uint64_t a1)
{
}

void sub_100ABF368(uint64_t a1)
{
}

void sub_100ABF374(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 67109120;
    v13[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting verbosity to %u", (uint8_t *)v13, 8u);
  }
  uint64_t v5 = *(void **)(a1 + 352);
  uint64_t v6 = (void *)(a1 + 360);
  if (v5 != v6)
  {
    do
    {
      uint64_t v7 = v5[5];
      uint64_t v8 = *(void *)(v7 + 8);
      uint64_t v9 = *(void *)(v7 + 16);
      while (v8 != v9)
      {
        (*(void (**)(void, uint64_t))(**(void **)(v8 + 8) + 96))(*(void *)(v8 + 8), a2);
        v8 += 24;
      }
      uint64_t v10 = (void *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v5[2];
          BOOL v12 = *v11 == (void)v5;
          uint64_t v5 = v11;
        }
        while (!v12);
      }
      uint64_t v5 = v11;
    }
    while (v11 != v6);
  }
}

void sub_100ABF4B4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 152);
  uint64_t v3 = (void *)(a1 + 160);
  if (v2 != (void *)(a1 + 160))
  {
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), *((unsigned int *)v2 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *((_DWORD *)v2 + 8);
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v3sub_1001A7358((uint64_t)&a9, 0) = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Signal bars: %d", buf, 8u);
      }
      uint64_t v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          uint64_t v2 = v7;
        }
        while (!v8);
      }
      uint64_t v2 = v7;
    }
    while (v7 != v3);
  }
  uint64_t v9 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 268)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v30 = (uint64_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Cellular data setting = %s", buf, 0xCu);
  }
  uint64_t v11 = *(void **)(a1 + 352);
  if (v11 != (void *)(a1 + 360))
  {
    do
    {
      uint64_t v12 = v11[5];
      int v13 = **(NSObject ***)v12;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(v12 + 56)) {
          os_log_t v14 = "true";
        }
        else {
          os_log_t v14 = "false";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = (uint64_t)v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fLastHeartBeatAccepted = %s", buf, 0xCu);
        int v13 = **(NSObject ***)v12;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(v12 + 58)) {
          uint64_t v15 = "true";
        }
        else {
          uint64_t v15 = "false";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = (uint64_t)v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fInProgress = %s", buf, 0xCu);
        int v13 = **(NSObject ***)v12;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(v12 + 57)) {
          uint64_t v16 = "true";
        }
        else {
          uint64_t v16 = "false";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = (uint64_t)v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fRunning = %s", buf, 0xCu);
      }
      if (*(_DWORD *)(v12 + 32))
      {
        unsigned int v17 = *(os_log_t **)v12;
      }
      else
      {
        unsigned int v17 = *(os_log_t **)v12;
        if (!*(void *)(v12 + 40))
        {
          os_log_t v28 = *v17;
          if (!os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          *(_WORD *)std::string buf = 0;
          uint64_t v20 = v28;
          uint64_t v21 = "#I No active model";
          uint32_t v22 = 2;
          goto LABEL_36;
        }
      }
      os_log_t v18 = *v17;
      if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = (*(uint64_t (**)(void))(**(void **)(v12 + 40) + 16))(*(void *)(v12 + 40));
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v30 = v19;
        uint64_t v20 = v18;
        uint64_t v21 = "#I Selected model: %s";
        uint32_t v22 = 12;
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, v22);
      }
LABEL_37:
      uint64_t v23 = *(void *)(v12 + 80);
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 64))(v23);
      }
      uint64_t v24 = *(void *)(v12 + 96);
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 64))(v24);
      }
      uint64_t v25 = *(void *)(v12 + 112);
      if (v25) {
        (*(void (**)(uint64_t))(*(void *)v25 + 64))(v25);
      }
      uint64_t v26 = (void *)v11[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v11[2];
          BOOL v8 = *v27 == (void)v11;
          uint64_t v11 = v27;
        }
        while (!v8);
      }
      uint64_t v11 = v27;
    }
    while (v27 != (void *)(a1 + 360));
  }
}

void sub_100ABF910(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 256);
  if (v2 != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "true";
      if (!v2) {
        int v5 = "false";
      }
      int v14 = 136315138;
      uint64_t v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Airplane mode is now %s", (uint8_t *)&v14, 0xCu);
    }
    uint64_t v6 = *(void **)(a1 + 352);
    if (v6 != (void *)(a1 + 360))
    {
      do
      {
        uint64_t v7 = (void *)v6[5];
        uint64_t v8 = v7[10];
        if (v8)
        {
          (*(void (**)(uint64_t, void))(*(void *)v8 + 48))(v8, *(unsigned __int8 *)(a1 + 256));
          uint64_t v7 = (void *)v6[5];
        }
        uint64_t v9 = v7[12];
        if (v9)
        {
          (*(void (**)(uint64_t, void))(*(void *)v9 + 48))(v9, *(unsigned __int8 *)(a1 + 256));
          uint64_t v7 = (void *)v6[5];
        }
        uint64_t v10 = v7[14];
        if (v10) {
          (*(void (**)(uint64_t, void))(*(void *)v10 + 48))(v10, *(unsigned __int8 *)(a1 + 256));
        }
        uint64_t v11 = (void *)v6[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v6[2];
            BOOL v13 = *v12 == (void)v6;
            uint64_t v6 = v12;
          }
          while (!v13);
        }
        uint64_t v6 = v12;
      }
      while (v12 != (void *)(a1 + 360));
    }
  }
}

void sub_100ABFAC0(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 264);
  if ((BYTE4(a2) & 1) != v2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "true";
      if (!v2) {
        int v5 = "false";
      }
      int v14 = 136315138;
      uint64_t v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Radio in reset is now: %s", (uint8_t *)&v14, 0xCu);
    }
    uint64_t v6 = *(void **)(a1 + 352);
    if (v6 != (void *)(a1 + 360))
    {
      do
      {
        uint64_t v7 = (void *)v6[5];
        uint64_t v8 = v7[10];
        if (v8)
        {
          (*(void (**)(uint64_t, void))(*(void *)v8 + 32))(v8, *(unsigned __int8 *)(a1 + 264));
          uint64_t v7 = (void *)v6[5];
        }
        uint64_t v9 = v7[12];
        if (v9)
        {
          (*(void (**)(uint64_t, void))(*(void *)v9 + 32))(v9, *(unsigned __int8 *)(a1 + 264));
          uint64_t v7 = (void *)v6[5];
        }
        uint64_t v10 = v7[14];
        if (v10) {
          (*(void (**)(uint64_t, void))(*(void *)v10 + 32))(v10, *(unsigned __int8 *)(a1 + 264));
        }
        uint64_t v11 = (void *)v6[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v6[2];
            BOOL v13 = *v12 == (void)v6;
            uint64_t v6 = v12;
          }
          while (!v13);
        }
        uint64_t v6 = v12;
      }
      while (v12 != (void *)(a1 + 360));
    }
  }
}

void sub_100ABFC74(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 268);
  if (v2 != a2)
  {
    int v5 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "false";
      if (a2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (v2) {
        uint64_t v6 = "true";
      }
      int v16 = 136315394;
      unsigned int v17 = v7;
      __int16 v18 = 2080;
      uint64_t v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cellular data setting changed from %s to %s", (uint8_t *)&v16, 0x16u);
    }
    uint64_t v8 = *(void **)(a1 + 352);
    if (v8 != (void *)(a1 + 360))
    {
      do
      {
        uint64_t v9 = (void *)v8[5];
        uint64_t v10 = v9[10];
        if (v10)
        {
          (*(void (**)(uint64_t, void))(*(void *)v10 + 40))(v10, *(unsigned __int8 *)(a1 + 268));
          uint64_t v9 = (void *)v8[5];
        }
        uint64_t v11 = v9[12];
        if (v11)
        {
          (*(void (**)(uint64_t, void))(*(void *)v11 + 40))(v11, *(unsigned __int8 *)(a1 + 268));
          uint64_t v9 = (void *)v8[5];
        }
        uint64_t v12 = v9[14];
        if (v12) {
          (*(void (**)(uint64_t, void))(*(void *)v12 + 40))(v12, *(unsigned __int8 *)(a1 + 268));
        }
        BOOL v13 = (void *)v8[1];
        if (v13)
        {
          do
          {
            int v14 = v13;
            BOOL v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            int v14 = (void *)v8[2];
            BOOL v15 = *v14 == (void)v8;
            uint64_t v8 = v14;
          }
          while (!v15);
        }
        uint64_t v8 = v14;
      }
      while (v14 != (void *)(a1 + 360));
    }
  }
}

uint64_t sub_100ABFE3C(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 200);
  uint64_t v3 = (void *)(result + 208);
  if (v2 != (void *)(result + 208))
  {
    uint64_t v4 = result;
    int v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        goto LABEL_13;
      }
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 7))
      {
        int v12 = *((unsigned __int8 *)v2 + 32);
        if (*((unsigned __int8 *)v8 + 32) != v12)
        {
          uint64_t result = subscriber::isValidSimSlot();
          if (result)
          {
            uint64_t v22 = *v5;
            if (!*v5) {
              goto LABEL_24;
            }
            int v14 = v5;
            do
            {
              int v23 = *(_DWORD *)(v22 + 28);
              BOOL v24 = v23 < (int)v7;
              if (v23 >= (int)v7) {
                uint64_t v25 = (uint64_t *)v22;
              }
              else {
                uint64_t v25 = (uint64_t *)(v22 + 8);
              }
              if (!v24) {
                int v14 = (void *)v22;
              }
              uint64_t v22 = *v25;
            }
            while (*v25);
LABEL_22:
            if (v14 != v5 && *((_DWORD *)v14 + 7) <= (int)v7) {
              BOOL v18 = *((unsigned __int8 *)v14 + 32) != 0;
            }
            else {
LABEL_24:
            }
              BOOL v18 = 0;
            uint64_t result = sub_100AC0CC8(v4, v7, v18, v12 != 0);
          }
        }
      }
      else
      {
LABEL_13:
        int v12 = *((unsigned __int8 *)v2 + 32);
        uint64_t result = subscriber::isValidSimSlot();
        if (result)
        {
          uint64_t v13 = *v5;
          if (*v5)
          {
            int v14 = v5;
            do
            {
              int v15 = *(_DWORD *)(v13 + 28);
              BOOL v16 = v15 < (int)v7;
              if (v15 >= (int)v7) {
                unsigned int v17 = (uint64_t *)v13;
              }
              else {
                unsigned int v17 = (uint64_t *)(v13 + 8);
              }
              if (!v16) {
                int v14 = (void *)v13;
              }
              uint64_t v13 = *v17;
            }
            while (*v17);
            goto LABEL_22;
          }
          goto LABEL_24;
        }
      }
      uint64_t v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          int v2 = v20;
        }
        while (!v21);
      }
      int v2 = v20;
    }
    while (v20 != v3);
  }
  return result;
}

void sub_100ABFFCC(uint64_t a1, void *a2)
{
  v56[0] = 0;
  v56[1] = 0;
  unint64_t v55 = (uint64_t *)v56;
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      char v5 = *((unsigned char *)v4 + 109);
      *(void *)std::string buf = v4 + 4;
      *((unsigned char *)sub_10005CE78(&v55, (int *)v4 + 8, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v5;
      uint64_t v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v4[2];
          BOOL v24 = *v7 == (void)v4;
          uint64_t v4 = v7;
        }
        while (!v24);
      }
      uint64_t v4 = v7;
    }
    while (v7 != v3);
  }
  v54[0] = 0;
  v54[1] = 0;
  std::string::size_type v53 = (uint64_t *)v54;
  uint64_t v8 = *(void **)(a1 + 328);
  if (v8 != (void *)(a1 + 336))
  {
    do
    {
      char v9 = *((unsigned char *)v8 + 109);
      *(void *)std::string buf = v8 + 4;
      *((unsigned char *)sub_10005CE78(&v53, (int *)v8 + 8, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v9;
      BOOL v10 = (void *)v8[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v8[2];
          BOOL v24 = *v11 == (void)v8;
          uint64_t v8 = v11;
        }
        while (!v24);
      }
      uint64_t v8 = v11;
    }
    while (v11 != (void *)(a1 + 336));
    int v12 = v53;
    if (v53 != (uint64_t *)v54)
    {
      while (1)
      {
        uint64_t v13 = v56[0];
        uint64_t v14 = *((unsigned int *)v12 + 7);
        if (v56[0])
        {
          int v15 = v56;
          do
          {
            BOOL v16 = v13;
            unsigned int v17 = v15;
            int v18 = *((_DWORD *)v13 + 7);
            uint64_t v19 = v13 + 1;
            if (v18 >= (int)v14)
            {
              uint64_t v19 = v16;
              int v15 = (void **)v16;
            }
            uint64_t v13 = (void *)*v19;
          }
          while (v13);
          if (v15 != v56)
          {
            uint64_t v20 = v18 >= (int)v14 ? v16 : v17;
            if ((int)v14 >= *((_DWORD *)v20 + 7))
            {
              if (v18 < (int)v14) {
                BOOL v16 = v17;
              }
              if (*((unsigned __int8 *)v16 + 32) == *((unsigned __int8 *)v12 + 32)) {
                goto LABEL_62;
              }
            }
          }
        }
        BOOL v21 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), *((unsigned int *)v12 + 7));
        sub_100025E5C(&v61, a1, v14);
        uint64_t v22 = v61;
        if (!v61) {
          break;
        }
        uint64_t v23 = *(void *)(v61 + 40);
        if (*(_DWORD *)(v61 + 32)) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v23 == 0;
        }
        if (v24)
        {
          int v43 = *v21;
          if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Could not find model", buf, 2u);
          }
LABEL_49:
          v64[0] = 0;
          *(void *)std::string buf = 0;
          (*(void (**)(void, uint64_t, uint8_t *))(**(void **)(a1 + 424) + 32))(*(void *)(a1 + 424), v14, buf);
          sub_100AC119C(a1, v14, (uint64_t *)buf);
          goto LABEL_60;
        }
        unsigned int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 48))(v23);
        uint64_t v26 = *v21;
        BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
        if (v27)
        {
          uint64_t v28 = (*(uint64_t (**)(void))(**(void **)(v22 + 40) + 16))(*(void *)(v22 + 40));
          *(_DWORD *)std::string buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v25;
          LOWORD(v64[0]) = 2080;
          *(void *)((char *)v64 + 2) = v28;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Computed base bars of %u from model %s", buf, 0x12u);
        }
        unint64_t v29 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v27);
        if (HIDWORD(v29)) {
          __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 953, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
        }
        uint64_t v30 = (capabilities::ct *)capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v29);
        if (v25 >= v30) {
          unsigned int v31 = v30;
        }
        else {
          unsigned int v31 = v25;
        }
        unint64_t v59 = __PAIR64__(v31, v25);
        int v60 = (int)v30;
        if (capabilities::ct::supportsVoiceCall(v30))
        {
          ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(a1 + 72));
          uint64_t v34 = ServiceMap;
          if (v35 < 0)
          {
            BOOL v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v37 = 5381;
            do
            {
              uint64_t v35 = v37;
              unsigned int v38 = *v36++;
              uint64_t v37 = (33 * v37) ^ v38;
            }
            while (v38);
          }
          std::mutex::lock(ServiceMap);
          *(void *)std::string buf = v35;
          uint64_t v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
          if (v39)
          {
            uint64_t v41 = v39[3];
            xpc_object_t v40 = (std::__shared_weak_count *)v39[4];
            if (v40)
            {
              atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v34);
              atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v40);
              char v52 = 0;
              goto LABEL_56;
            }
          }
          else
          {
            uint64_t v41 = 0;
          }
          std::mutex::unlock(v34);
          xpc_object_t v40 = 0;
          char v52 = 1;
LABEL_56:
          BOOL v44 = (std::__shared_weak_count *)operator new(0x28uLL);
          v44->__shared_weak_owners_ = 0;
          v44->__shared_owners_ = 0;
          v44->__vftable = (std::__shared_weak_count_vtbl *)off_101A38800;
          v44[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
          LODWORD(v44[1].__shared_owners_) = v14;
          unint64_t v57 = v59;
          int v58 = v60;
          atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
          char v45 = *(std::__shared_weak_count **)(a1 + 32);
          if (!v45 || (uint64_t v46 = *(void *)(a1 + 24), (v47 = std::__shared_weak_count::lock(v45)) == 0)) {
            sub_100088B9C();
          }
          CFArrayRef v48 = v47;
          atomic_fetch_add_explicit(&v47->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v47);
          Class v65 = 0;
          CFTypeID v49 = operator new(0x40uLL);
          *CFTypeID v49 = off_101A38850;
          v49[1] = a1;
          *((_DWORD *)v49 + 4) = v14;
          *((_DWORD *)v49 + 7) = v58;
          *(void *)((char *)v49 + 2sub_1001A7358((uint64_t)&a9, 0) = v57;
          v49[4] = v44 + 1;
          v49[5] = v44;
          v49[6] = v46;
          v49[7] = v48;
          Class v65 = v49;
          (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v41 + 56))(v41, v14, buf);
          sub_100060644(buf);
          sub_10004D2C8(v44);
          if ((v52 & 1) == 0) {
            sub_10004D2C8(v40);
          }
          goto LABEL_60;
        }
        (*(void (**)(void, uint64_t, unint64_t *))(**(void **)(a1 + 424) + 32))(*(void *)(a1 + 424), v14, &v59);
        sub_100AC119C(a1, v14, (uint64_t *)&v59);
LABEL_60:
        if (v62) {
          sub_10004D2C8(v62);
        }
LABEL_62:
        CFIndex v50 = (uint64_t *)v12[1];
        if (v50)
        {
          do
          {
            BOOL v51 = v50;
            CFIndex v50 = (uint64_t *)*v50;
          }
          while (v50);
        }
        else
        {
          do
          {
            BOOL v51 = (uint64_t *)v12[2];
            BOOL v24 = *v51 == (void)v12;
            int v12 = v51;
          }
          while (!v24);
        }
        int v12 = v51;
        if (v51 == (uint64_t *)v54) {
          goto LABEL_68;
        }
      }
      uint64_t v42 = *v21;
      if (os_log_type_enabled(*v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Could not find state", buf, 2u);
      }
      goto LABEL_49;
    }
  }
LABEL_68:
  sub_1000346F8((uint64_t)&v53, v54[0]);
  sub_1000346F8((uint64_t)&v55, v56[0]);
}

void sub_100AC0690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14, __int16 a15, char a16, void *a17, uint64_t a18, char a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if ((a14 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  sub_1000346F8((uint64_t)&a16, a17);
  sub_1000346F8((uint64_t)&a19, a20);
  _Unwind_Resume(a1);
}

void sub_100AC0750(uint64_t a1, uint64_t a2)
{
  v15[0] = a1;
  v15[1] = a2;
  int v2 = *(void **)(a1 + 272);
  uint64_t v3 = (void *)(a1 + 280);
  if (v2 != (void *)(a1 + 280))
  {
    uint64_t v4 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v5 = *v4;
      if (!*v4) {
        break;
      }
      uint64_t v6 = *((unsigned int *)v2 + 8);
      uint64_t v7 = v4;
      do
      {
        int v8 = *(_DWORD *)(v5 + 32);
        BOOL v9 = v8 < (int)v6;
        if (v8 >= (int)v6) {
          BOOL v10 = (uint64_t *)v5;
        }
        else {
          BOOL v10 = (uint64_t *)(v5 + 8);
        }
        if (!v9) {
          uint64_t v7 = (void *)v5;
        }
        uint64_t v5 = *v10;
      }
      while (*v10);
      if (v7 == v4 || (int)v6 < *((_DWORD *)v7 + 8)) {
        goto LABEL_16;
      }
      if ((rest::operator==() & 1) == 0)
      {
        uint64_t v6 = *((unsigned int *)v2 + 8);
        uint64_t v11 = (uint64_t)(v2 + 5);
        goto LABEL_17;
      }
LABEL_18:
      int v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          int v2 = v13;
        }
        while (!v14);
      }
      int v2 = v13;
      if (v13 == v3) {
        return;
      }
    }
    uint64_t v6 = *((unsigned int *)v2 + 8);
LABEL_16:
    uint64_t v11 = (uint64_t)(v2 + 5);
LABEL_17:
    sub_100AC79D4(v15, v6, v11);
    goto LABEL_18;
  }
}

void sub_100AC0840(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 96) == a2) {
    return;
  }
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  uint64_t v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Current data SIM has changed evaluating data LQM", (uint8_t *)&v15, 2u);
  }
  uint64_t v5 = *(void *)(a1 + 360);
  if (!v5) {
    goto LABEL_14;
  }
  int v6 = *(_DWORD *)(a1 + 96);
  uint64_t v7 = a1 + 360;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v5;
    }
    else {
      BOOL v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 == a1 + 360 || *(_DWORD *)(v7 + 32) > v6) {
    goto LABEL_14;
  }
  uint64_t v13 = *(void *)(v7 + 40);
  uint64_t v14 = *(void *)(v13 + 112);
  uint64_t v11 = *(std::__shared_weak_count **)(v13 + 120);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!v14) {
      goto LABEL_15;
    }
    uint64_t v15 = v14;
    BOOL v16 = v11;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_25:
    sub_100AC189C(a1, (uint64_t)&v15);
  }
  if (v14)
  {
    uint64_t v15 = *(void *)(v13 + 112);
    BOOL v16 = 0;
    goto LABEL_25;
  }
LABEL_14:
  uint64_t v11 = 0;
LABEL_15:
  int v12 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v15) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Unable to retrieve model when updating data LQM", (uint8_t *)&v15, 2u);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100AC09CC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AC09EC(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 248)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v18 = 136315138;
    uint64_t v19 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received display status: is_on %s", (uint8_t *)&v18, 0xCu);
  }
  uint64_t v4 = *(void **)(a1 + 352);
  if (v4 != (void *)(a1 + 360))
  {
    while (1)
    {
      uint64_t v5 = v4[5];
      uint64_t v6 = *(void *)(v5 + 8);
      uint64_t v7 = *(void *)(v5 + 16);
      if (v6 != v7) {
        break;
      }
LABEL_16:
      sub_100ABEB54(a1, *((unsigned int *)v4 + 8));
      uint64_t v15 = (void *)v4[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v4[2];
          BOOL v17 = *v16 == (void)v4;
          uint64_t v4 = v16;
        }
        while (!v17);
      }
      uint64_t v4 = v16;
      if (v16 == (void *)(a1 + 360)) {
        return;
      }
    }
    int v8 = *(unsigned __int8 *)(a1 + 248);
    while (1)
    {
      uint64_t v9 = *(void *)(v6 + 8);
      if (v8)
      {
        uint64_t v11 = *(void *)(v9 + 48);
        BOOL v10 = (unint64_t *)(v9 + 48);
        unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFDLL;
      }
      else
      {
        uint64_t v13 = *(void *)(v9 + 48);
        BOOL v10 = (unint64_t *)(v9 + 48);
        unint64_t v12 = v13 & 0xFFFFFFFFFFFFFFFDLL;
        if (*(_DWORD *)(a1 + 252) != 2)
        {
          uint64_t v14 = 0;
          goto LABEL_13;
        }
      }
      uint64_t v14 = 2;
LABEL_13:
      *BOOL v10 = v14 | v12;
      v6 += 24;
      if (v6 == v7) {
        goto LABEL_16;
      }
    }
  }
}

void sub_100AC0B64(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = 136315138;
    uint64_t v18 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received carplay connected: %s", (uint8_t *)&v17, 0xCu);
  }
  uint64_t v3 = *(void **)(a1 + 352);
  if (v3 != (void *)(a1 + 360))
  {
    while (1)
    {
      uint64_t v4 = v3[5];
      uint64_t v5 = *(void *)(v4 + 8);
      uint64_t v6 = *(void *)(v4 + 16);
      if (v5 != v6) {
        break;
      }
LABEL_13:
      sub_100ABEB54(a1, *((unsigned int *)v3 + 8));
      uint64_t v14 = (void *)v3[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v3[2];
          BOOL v16 = *v15 == (void)v3;
          uint64_t v3 = v15;
        }
        while (!v16);
      }
      uint64_t v3 = v15;
      if (v15 == (void *)(a1 + 360)) {
        return;
      }
    }
    int v7 = *(unsigned __int8 *)(a1 + 248);
    while (1)
    {
      uint64_t v8 = *(void *)(v5 + 8);
      if (v7)
      {
        uint64_t v10 = *(void *)(v8 + 48);
        uint64_t v9 = (unint64_t *)(v8 + 48);
        unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFFDLL;
      }
      else
      {
        uint64_t v12 = *(void *)(v8 + 48);
        uint64_t v9 = (unint64_t *)(v8 + 48);
        unint64_t v11 = v12 & 0xFFFFFFFFFFFFFFFDLL;
        if (*(_DWORD *)(a1 + 252) != 2)
        {
          uint64_t v13 = 0;
          goto LABEL_10;
        }
      }
      uint64_t v13 = 2;
LABEL_10:
      unint64_t *v9 = v13 | v11;
      v5 += 24;
      if (v5 == v6) {
        goto LABEL_13;
      }
    }
  }
}

uint64_t sub_100AC0CC8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  uint64_t v9 = *v8;
  BOOL v10 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    unint64_t v11 = "false";
    if (a3) {
      uint64_t v12 = "true";
    }
    else {
      uint64_t v12 = "false";
    }
    if (a4) {
      unint64_t v11 = "true";
    }
    int v27 = 136315394;
    uint64_t v28 = v12;
    __int16 v29 = 2080;
    uint64_t v30 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I CS attached is changing from %s to %s", (uint8_t *)&v27, 0x16u);
  }
  if (a4 && (a3 & 1) == 0 && capabilities::ct::supportsVoiceCall((capabilities::ct *)v10))
  {
    uint64_t v13 = *(void *)(a1 + 184);
    if (!v13) {
      goto LABEL_21;
    }
    uint64_t v14 = a1 + 184;
    do
    {
      int v15 = *(_DWORD *)(v13 + 28);
      BOOL v16 = v15 < (int)a2;
      if (v15 >= (int)a2) {
        int v17 = (uint64_t *)v13;
      }
      else {
        int v17 = (uint64_t *)(v13 + 8);
      }
      if (!v16) {
        uint64_t v14 = v13;
      }
      uint64_t v13 = *v17;
    }
    while (*v17);
    if (v14 != a1 + 184 && *(_DWORD *)(v14 + 28) <= (int)a2) {
      BOOL v18 = *(_DWORD *)(v14 + 32) != 10;
    }
    else {
LABEL_21:
    }
      BOOL v18 = 1;
    uint64_t v19 = *v8;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = "false";
      if (v18) {
        uint64_t v20 = "true";
      }
      int v27 = 136315138;
      uint64_t v28 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Resetting model state since device became CS attached. Clear system state: %s", (uint8_t *)&v27, 0xCu);
    }
    sub_100ABE1AC(a1, a2, v18);
  }
  BOOL v21 = sub_1000389F8(*(uint64_t **)(a1 + 360), a2);
  uint64_t v22 = *(void *)(*v21 + 8);
  uint64_t v23 = *(void *)(*v21 + 16);
  while (v22 != v23)
  {
    uint64_t v24 = *(void *)(v22 + 8);
    SignalStrengthModel::setForceNotificationOnNextHeartbeat((SignalStrengthModel *)v24, 1);
    if (a4)
    {
      SignalStrengthModel::setImmediateMode((SignalStrengthModel *)v24);
      *(unsigned char *)(v24 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
      unint64_t v25 = *(void *)(v24 + 48) | 1;
    }
    else
    {
      unint64_t v25 = *(void *)(v24 + 48) & 0xFFFFFFFFFFFFFFFELL;
    }
    *(void *)(v24 + 48) = v25;
    v22 += 24;
  }
  sub_100ABEB54(a1, a2);
  return sub_100ABE2A0(a1, a2);
}

void sub_100AC0F20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC1010(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  if (*a3)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    if (v5)
    {
      if (*(void *)(v4 + 48))
      {
        uint64_t v6 = (std::__shared_weak_count *)operator new(0x50uLL);
        v6->__shared_weak_owners_ = 0;
        v6->__shared_owners_ = 0;
        v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A385B0;
        int v7 = *(_DWORD *)(v4 + 8);
        v6[1].__vftable = *(std::__shared_weak_count_vtbl **)v4;
        LODWORD(v6[1].__shared_owners_) = v7;
        v6[1].__shared_weak_owners_ = v5;
        *(void *)(v4 + 16) = 0;
        sub_1002BB5AC((uint64_t)&v6[2], v4 + 24);
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v6);
      }
    }
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  if (v8)
  {
    if (std::__shared_weak_count::lock(v8)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100AC119C(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 160;
  uint64_t v5 = *(void *)(a1 + 160);
  v13[0] = 1;
  v13[1] = a1 + 120;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        int v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *(void *)v7;
        uint64_t v9 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = *(void *)(v7 + 8);
      if (!v5)
      {
        uint64_t v9 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = (uint64_t **)(a1 + 160);
    uint64_t v7 = a1 + 160;
LABEL_9:
    BOOL v10 = operator new(0x30uLL);
    v10[7] = a2;
    *((void *)v10 + 4) = 0;
    v10[10] = 0;
    sub_100046C38((uint64_t **)(v6 - 8), v7, v9, (uint64_t *)v10);
    uint64_t v7 = (uint64_t)v10;
  }
  uint64_t v11 = *a3;
  *(_DWORD *)(v7 + 4sub_1001A7358((uint64_t)&a9, 0) = *((_DWORD *)a3 + 2);
  *(void *)(v7 + 32) = v11;
  return sub_100AC8FE4((uint64_t)v13);
}

void sub_100AC1274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100AC1288(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100AC9048((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC13BC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AC13CC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100AC9048((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC1514(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AC1524(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100AC9408((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC166C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AC167C(uint64_t a1, int a2, void *a3)
{
  uint64_t v5 = (void *)a3[3];
  if (v5)
  {
    if (v5 == a3)
    {
      int v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      int v8 = (void *)(*(uint64_t (**)(void *))(*v5 + 16))(v5);
    }
  }
  else
  {
    int v8 = 0;
  }
  int v9 = a2;
  int v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC1880(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AC189C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)a2 + 88))();
  uint64_t v5 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), v4);
  (*(void (**)(void))(**(void **)a2 + 72))();
  int v6 = *v5;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Data LQM is being updated to: %s", buf, 0xCu);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7)
  {
    int v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      p_shared_weak_owners = &v8->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC1A68(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AC1A74(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC1B90(uint64_t a1, uint64_t a2)
{
}

void sub_100AC1B98(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v5 = (*(uint64_t (**)(void))(**(void **)a2 + 72))();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_100025E5C(&v11, a1, v5);
  uint64_t v6 = v11;
  if (v11)
  {
    uint64_t v7 = *a3;
    if (*a3 && *(void *)(v7 + 16))
    {
      uint64_t v8 = a3[1];
      *a3 = 0;
      a3[1] = 0;
      int v9 = *(std::__shared_weak_count **)(v6 + 72);
      *(void *)(v6 + 64) = v7;
      *(void *)(v6 + 72) = v8;
      if (!v9) {
        goto LABEL_8;
      }
    }
    else
    {
      int v9 = *(std::__shared_weak_count **)(v11 + 72);
      *(void *)(v11 + 64) = 0;
      *(void *)(v6 + 72) = 0;
      if (!v9) {
        goto LABEL_8;
      }
    }
    sub_10004D2C8(v9);
  }
LABEL_8:
  BOOL v10 = v12;
  if (v12)
  {
    sub_10004D2C8(v10);
  }
}

void sub_100AC1C68(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void sub_100AC1C70(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)a2 + 72))();
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), v3);
  sub_100025E5C(&v38, a1, v3);
  uint64_t v5 = v38;
  if (!v38)
  {
    uint64_t v26 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find state", buf, 2u);
    }
    goto LABEL_21;
  }
  uint64_t v6 = *(void *)(v38 + 40);
  if (*(_DWORD *)(v38 + 32)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = v6 == 0;
  }
  if (v7)
  {
    int v27 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find model", buf, 2u);
    }
LABEL_21:
    v41[0] = 0;
    *(void *)std::string buf = 0;
    (*(void (**)(void, uint64_t, uint8_t *))(**(void **)(a1 + 424) + 32))(*(void *)(a1 + 424), v3, buf);
    sub_100AC119C(a1, v3, (uint64_t *)buf);
    goto LABEL_32;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
  int v9 = *v4;
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(v5 + 40) + 16))(*(void *)(v5 + 40));
    *(_DWORD *)std::string buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v8;
    LOWORD(v41[0]) = 2080;
    *(void *)((char *)v41 + 2) = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Computed base bars of %u from model %s", buf, 0x12u);
  }
  unint64_t v12 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v10);
  if (HIDWORD(v12)) {
    __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 953, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
  }
  uint64_t v13 = (capabilities::ct *)capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v12);
  if (v8 >= v13) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v8;
  }
  unint64_t v36 = __PAIR64__(v14, v8);
  int v37 = (int)v13;
  if ((capabilities::ct::supportsVoiceCall(v13) & 1) == 0)
  {
    (*(void (**)(void, uint64_t, unint64_t *))(**(void **)(a1 + 424) + 32))(*(void *)(a1 + 424), v3, &v36);
    sub_100AC119C(a1, v3, (uint64_t *)&v36);
    goto LABEL_32;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 72));
  int v17 = ServiceMap;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
  if (v22)
  {
    uint64_t v24 = v22[3];
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v23 = 0;
  char v25 = 1;
LABEL_28:
  uint64_t v28 = (std::__shared_weak_count *)operator new(0x28uLL);
  v28->__shared_weak_owners_ = 0;
  v28->__shared_owners_ = 0;
  v28->__vftable = (std::__shared_weak_count_vtbl *)off_101A38730;
  v28[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  LODWORD(v28[1].__shared_owners_) = v3;
  unint64_t v34 = v36;
  int v35 = v37;
  atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  __int16 v29 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v29 || (uint64_t v30 = *(void *)(a1 + 24), (v31 = std::__shared_weak_count::lock(v29)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v32 = v31;
  atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v31);
  uint64_t v42 = 0;
  uint64_t v33 = operator new(0x40uLL);
  *uint64_t v33 = off_101A38780;
  v33[1] = a1;
  *((_DWORD *)v33 + 4) = v3;
  *((_DWORD *)v33 + 7) = v35;
  *(void *)((char *)v33 + 2sub_1001A7358((uint64_t)&a9, 0) = v34;
  v33[4] = v28 + 1;
  v33[5] = v28;
  v33[6] = v30;
  v33[7] = v32;
  uint64_t v42 = v33;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v24 + 56))(v24, v3, buf);
  sub_100060644(buf);
  sub_10004D2C8(v28);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
LABEL_32:
  if (v39) {
    sub_10004D2C8(v39);
  }
}

void sub_100AC2178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, ...)
{
  va_start(va, a7);
  sub_100060644((uint64_t *)va);
  sub_10004D2C8(v8);
  if ((v9 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  if (a7) {
    sub_10004D2C8(a7);
  }
  _Unwind_Resume(a1);
}

void sub_100AC2208(uint64_t a1, uint64_t a2)
{
}

void *sub_100AC2210(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100AC2294(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  a1[1] = v2;
}

void sub_100AC22E0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100AC2294((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *sub_100AC2334(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100AC23BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AC23F4(uint64_t a1)
{
}

uint64_t sub_100AC2410(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100AC2454(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100AC2480(ServiceManager::Service *this)
{
  *(void *)this = off_101A37A88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100AC24DC(ServiceManager::Service *this)
{
  *(void *)this = off_101A37A88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100AC254C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SignalStrengthController");
}

unsigned char *sub_100AC255C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100AC259C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100ABD718(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100ABD718(v4, 0);
}

uint64_t sub_100AC2620()
{
  return 0;
}

uint64_t sub_100AC2628()
{
  return 1;
}

uint64_t sub_100AC2630()
{
  return 0;
}

void sub_100AC263C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 32);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC271C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 32);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100AC2834()
{
}

uint64_t sub_100AC2848(uint64_t a1)
{
  return *(void *)(a1 + 8) + 56;
}

uint64_t *sub_100AC2854(void **a1)
{
  uint64_t v1 = *a1;
  unsigned int v8 = a1;
  char v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 56);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 408);
  uint64_t v5 = v1[1];
  *(void *)std::string buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  for (uint64_t i = *(void *)(v2 + 392); i != v2 + 384; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 384));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 104));
  sub_100088C88((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100AC296C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
}

void sub_100AC29AC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  subscriber::makeSimSlotRange();
  uint64_t v2 = v42;
  if (v42 != v43)
  {
    while ((v44(*v2) & 1) == 0)
    {
      if (++v2 == v43)
      {
        uint64_t v2 = v43;
        break;
      }
    }
    if (v2 != v43)
    {
      xpc_object_t v40 = (void *)(v1 + 360);
      uint64_t v41 = v1;
      do
      {
        uint64_t v3 = *v2;
        uint64_t v4 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 64) + 16))(*(void *)(v1 + 64), v3);
        uint64_t SignalStrengthPersonality = capabilities::ct::getSignalStrengthPersonality(v4);
        uint64_t v6 = *(NSObject **)v4;
        if (os_log_type_enabled(*(os_log_t *)v4, OS_LOG_TYPE_DEFAULT))
        {
          capabilities::ct::asString();
          BOOL v7 = __p;
          if (v48 < 0) {
            BOOL v7 = (void **)__p[0];
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Creating models with personality %s", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(v48) < 0) {
            operator delete(__p[0]);
          }
        }
        unsigned int v8 = (char *)operator new(0x98uLL);
        *((void *)v8 + 3) = v4;
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = 0;
        *((void *)v8 + 4) = 0;
        char v9 = (uint64_t *)(v8 + 32);
        *(void *)unsigned int v8 = off_101A37B68;
        *((void *)v8 + 5) = 0;
        *((void *)v8 + 6) = 0;
        *((_DWORD *)v8 + 14) = 0;
        *((void *)v8 + 8) = 0;
        *((void *)v8 + 9) = 0;
        *(_DWORD *)(v8 + 79) = 0;
        *(_OWORD *)(v8 + 88) = 0u;
        *(_OWORD *)(v8 + 104) = 0u;
        *(_OWORD *)(v8 + 12sub_1001A7358((uint64_t)&a9, 0) = 0u;
        *(_OWORD *)(v8 + 136) = 0u;
        BOOL v10 = *(std::__shared_weak_count **)(v1 + 32);
        if (!v10
          || (v11 = *(void *)(v1 + 88), v12 = *(void *)(v1 + 24), (uint64_t v13 = std::__shared_weak_count::lock(v10)) == 0))
        {
          sub_100088B9C();
        }
        unsigned int v14 = v13;
        atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        long long buf = 0uLL;
        int v15 = std::__shared_weak_count::lock(v14);
        BOOL v16 = v15;
        if (v15)
        {
          uint64_t v17 = v12 + 16;
          if (!v12) {
            uint64_t v17 = 0;
          }
          atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v17 = 0;
        }
        uint64_t v18 = (std::__shared_weak_count *)*((void *)&buf + 1);
        *(void *)&long long buf = v17;
        *((void *)&buf + 1) = v16;
        if (v18) {
          std::__shared_weak_count::__release_weak(v18);
        }
        std::__shared_weak_count::__release_weak(v14);
        if (v16) {
          sub_10004D2C8(v16);
        }
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, long long *))(*(void *)v11 + 48))(__p, v11, v3, SignalStrengthPersonality, &buf);
        uint64_t v1 = v41;
        if (*v9)
        {
          sub_100AC2294(v9);
          operator delete((void *)*v9);
          uint64_t *v9 = 0;
          *((void *)v8 + 5) = 0;
          *((void *)v8 + 6) = 0;
        }
        *((_OWORD *)v8 + 2) = *(_OWORD *)__p;
        *((void *)v8 + 6) = v48;
        __p[1] = 0;
        uint64_t v48 = 0;
        __p[0] = 0;
        char v45 = __p;
        sub_100AC22E0(&v45);
        if (*((void *)&buf + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&buf + 1));
        }
        (*(void (**)(void **__return_ptr))(**(void **)(v41 + 88) + 32))(__p);
        long long v19 = *(_OWORD *)__p;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v20 = (std::__shared_weak_count *)*((void *)v8 + 14);
        *(_OWORD *)(v8 + 104) = v19;
        if (v20)
        {
          sub_10004D2C8(v20);
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
        }
        (*(void (**)(void **__return_ptr))(**(void **)(v41 + 88) + 16))(__p);
        long long v21 = *(_OWORD *)__p;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v22 = (std::__shared_weak_count *)*((void *)v8 + 16);
        *(_OWORD *)(v8 + 12sub_1001A7358((uint64_t)&a9, 0) = v21;
        if (v22)
        {
          sub_10004D2C8(v22);
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
        }
        uint64_t v23 = *(std::__shared_weak_count **)(v41 + 32);
        if (!v23
          || (uint64_t v24 = *(void *)(v41 + 88),
              uint64_t v25 = *(void *)(v41 + 24),
              (uint64_t v26 = std::__shared_weak_count::lock(v23)) == 0))
        {
          sub_100088B9C();
        }
        int v27 = v26;
        atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        uint64_t v28 = std::__shared_weak_count::lock(v27);
        if (v28)
        {
          __int16 v29 = v28;
          uint64_t v30 = (void **)(v25 + 8);
          if (!v25) {
            uint64_t v30 = 0;
          }
          atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          char v45 = v30;
          uint64_t v46 = v28;
          std::__shared_weak_count::__release_weak(v27);
          sub_10004D2C8(v29);
        }
        else
        {
          char v45 = 0;
          uint64_t v46 = 0;
          std::__shared_weak_count::__release_weak(v27);
        }
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void ***))(*(void *)v24 + 24))(__p, v24, v3, &v45);
        long long v31 = *(_OWORD *)__p;
        __p[0] = 0;
        __p[1] = 0;
        unsigned int v32 = (std::__shared_weak_count *)*((void *)v8 + 18);
        *(_OWORD *)(v8 + 136) = v31;
        if (v32)
        {
          sub_10004D2C8(v32);
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
        }
        if (v46) {
          std::__shared_weak_count::__release_weak(v46);
        }
        uint64_t v33 = v40;
        while (1)
        {
          uint64_t v34 = *v33;
          int v35 = v33;
          if (!*v33) {
            break;
          }
          while (1)
          {
            uint64_t v33 = (void *)v34;
            int v36 = *(_DWORD *)(v34 + 32);
            if (v36 > (int)v3) {
              break;
            }
            if (v36 >= (int)v3)
            {
              sub_10004D2C8((std::__shared_weak_count *)v8);
              goto LABEL_55;
            }
            uint64_t v34 = v33[1];
            if (!v34)
            {
              int v35 = v33 + 1;
              goto LABEL_52;
            }
          }
        }
LABEL_52:
        int v37 = operator new(0x38uLL);
        v37[8] = v3;
        *((void *)v37 + 5) = v8 + 24;
        *((void *)v37 + 6) = v8;
        *(void *)int v37 = 0;
        *((void *)v37 + 1) = 0;
        *((void *)v37 + 2) = v33;
        *int v35 = v37;
        uint64_t v38 = **(void **)(v41 + 352);
        if (v38)
        {
          *(void *)(v41 + 352) = v38;
          int v37 = (_DWORD *)*v35;
        }
        sub_100046C90(*(uint64_t **)(v41 + 360), (uint64_t *)v37);
        ++*(void *)(v41 + 368);
LABEL_55:
        sub_100ABDE7C(v41, v3, 0xFFFFFFFF);
        uint64_t v39 = v2 + 1;
        uint64_t v2 = v43;
        if (v39 != v43)
        {
          uint64_t v2 = v39;
          while ((v44(*v2) & 1) == 0)
          {
            if (++v2 == v43)
            {
              uint64_t v2 = v43;
              break;
            }
          }
        }
      }
      while (v2 != v43);
    }
  }
}

void sub_100AC2F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_100AC2F68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A37B68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AC2F88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A37B68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AC2FDC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 128);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 112);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }
  BOOL v7 = (void **)(a1 + 32);
  sub_100AC22E0(&v7);
}

void sub_100AC3054(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)**a1;
  uint64_t v3 = v2[7];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v5 = v2[3];
  uint64_t v4 = (std::__shared_weak_count *)v2[4];
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      BOOL v7 = v6;
      unsigned int v8 = (std::__shared_weak_count *)operator new(0x30uLL);
      v8->__shared_owners_ = 0;
      v8->__shared_weak_owners_ = 0;
      v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A37BB8;
      v8[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A37C88;
      v8[1].__shared_owners_ = v5;
      v8[1].__shared_weak_owners_ = (uint64_t)v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      v8[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A37C08;
      uint64_t v9 = v2[51];
      BOOL v10 = v1[1];
      dispatch_group_t group = v10;
      if (v10)
      {
        dispatch_retain(v10);
        dispatch_group_enter(v10);
      }
      uint64_t v12 = v8;
      xpc_object_t object = xpc_null_create();
      uint64_t v11 = v8 + 1;
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, dispatch_group_t *, xpc_object_t *, std::__shared_weak_count **))(*(void *)v9 + 16))(v9, &group, &object, &v11);
      if (v12) {
        sub_10004D2C8(v12);
      }
      xpc_release(object);
      xpc_object_t object = 0;
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      sub_100ABEFC0((uint64_t)buf, (uint64_t)(v2 + 3), (uint64_t)event::radio::on, (uint64_t)sub_100ABF2B8, 0);
    }
  }
  sub_100088B9C();
}

void sub_100AC42DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2)
  {
    sub_100163C60((void ***)&a37);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100AC42F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(a15);
  sub_100088C88(&a17);
  sub_100046B58(&a16);
  _Unwind_Resume(a1);
}

void sub_100AC43D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  sub_100160AF8(v7);
  sub_10004D2C8(a7);
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  JUMPOUT(0x100AC4648);
}

void sub_100AC43EC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100AC442C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, atomic_uint **a14)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(a14);
    JUMPOUT(0x100AC4658);
  }
  _Unwind_Resume(a1);
}

void sub_100AC4440(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_100AC5924(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_100AC4460(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_end_catch();
    sub_10000A740(v3);
    *(void *)uint64_t v2 = off_1019A5688;
    sub_100160AF8((atomic_uint **)(v2 + 16));
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_100AC447C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100AC4484);
  }
  _Unwind_Resume(a1);
}

void sub_100AC44A0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100AC44A8);
  }
  _Unwind_Resume(a1);
}

void sub_100AC44E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100AC4660);
}

void sub_100AC44F4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100AC44FCLL);
  }
  _Unwind_Resume(a1);
}

void sub_100AC452C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100AC4534);
  }
  _Unwind_Resume(a1);
}

void sub_100AC4544()
{
}

void sub_100AC4564(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, xpc_object_t object,dispatch_group_t group)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_10004D2C8(a15);
  sub_100088C88(&a17);
  sub_100046B58(&a16);
  JUMPOUT(0x100AC4648);
}

void sub_100AC45A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  sub_10004D2C8(v7);
  sub_100088C88(va1);
  sub_100046B58((uint64_t *)va);
  JUMPOUT(0x100AC4648);
}

void sub_100AC45B0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x100AC4670);
}

void sub_100AC45BC()
{
}

void sub_100AC45C8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void **a57)
{
  if (a2)
  {
    sub_100AC60C0((uint64_t *)&a57);
    sub_100AC60C0(&a37);
    sub_100AC6114((uint64_t)&a35);
    sub_100AC6114((uint64_t)&a33);
    sub_100AC60C0(v57);
    a57 = (void **)&a49;
    sub_100163C60(&a57);
    JUMPOUT(0x100AC4668);
  }
  _Unwind_Resume(a1);
}

void sub_100AC4610(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100161F10(&a57);
  sub_100AC5678(&a49);
  sub_100AC6114(&a31);
  sub_10006A6AC(a1);
}

void sub_100AC4640(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (!a2) {
    JUMPOUT(0x100AC4648);
  }
  sub_10000A740(a14);
  JUMPOUT(0x100AC4658);
}

void sub_100AC4678(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A37BB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AC4698(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A37BB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100AC46EC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100AC4714(SignalStrengthDriverDelegateInterface *this)
{
  *(void *)this = off_101A37C88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SignalStrengthDriverDelegateInterface::~SignalStrengthDriverDelegateInterface(this);
}

void sub_100AC4770(SignalStrengthDriverDelegateInterface *this)
{
  *(void *)this = off_101A37C88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  SignalStrengthDriverDelegateInterface::~SignalStrengthDriverDelegateInterface(this);

  operator delete();
}

void sub_100AC47E0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 32);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100AC492C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 32);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100AC4A74(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = a3[1];
        *a3 = 0;
        a3[1] = 0;
        if (v8) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v9 = *(std::__shared_weak_count **)(v7 + 32);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100AC4BE4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 32);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100AC4D2C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 32);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100AC4E74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v10 = 0;
        sub_10005C928(__p, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
        __p[1] = 0;
        uint64_t v10 = 0;
        __p[0] = 0;
        uint64_t v8 = *(std::__shared_weak_count **)(v7 + 32);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100AC4FD8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100AC4FF0(SignalStrengthDriverDelegateInterface *this)
{
  *(void *)this = off_101A37C88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SignalStrengthDriverDelegateInterface::~SignalStrengthDriverDelegateInterface(this);
}

void sub_100AC504C(SignalStrengthDriverDelegateInterface *this)
{
  *(void *)this = off_101A37C88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  SignalStrengthDriverDelegateInterface::~SignalStrengthDriverDelegateInterface(this);

  operator delete();
}

void sub_100AC50BC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 408) + 24))(*(void *)(v1 + 408));
  subscriber::makeSimSlotRange();
  uint64_t v4 = *(int **)buf;
  uint64_t v3 = v14;
  if (*(int **)buf != v14)
  {
    uint64_t v5 = v15;
    do
    {
      if (v5(*v4)) {
        goto LABEL_8;
      }
      ++v4;
    }
    while (v4 != v3);
    uint64_t v4 = v3;
LABEL_8:
    uint64_t v6 = v14;
LABEL_9:
    while (v4 != v6)
    {
      int v7 = *v4;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      sub_100025E5C(&v11, v1, v7);
      if (v11)
      {
        uint64_t v8 = *(void *)(v11 + 8);
        uint64_t v9 = *(void *)(v11 + 16);
        while (v8 != v9)
        {
          (*(void (**)(void))(**(void **)(v8 + 8) + 80))(*(void *)(v8 + 8));
          v8 += 24;
        }
      }
      if (v12) {
        sub_10004D2C8(v12);
      }
      uint64_t v10 = v4 + 1;
      uint64_t v4 = v3;
      if (v10 != v3)
      {
        uint64_t v4 = v10;
        do
        {
          if (v5(*v4)) {
            goto LABEL_9;
          }
          ++v4;
        }
        while (v4 != v3);
        uint64_t v4 = v3;
      }
    }
  }
  operator delete();
}

void sub_100AC5268()
{
}

uint64_t sub_100AC52B0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 24);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100AC52FC(void *a1)
{
  *a1 = off_101A37CF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100AC5348(void *a1)
{
  *a1 = off_101A37CF8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100AC53B4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100AC5464(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AC547C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100AC549C()
{
}

void *sub_100AC5508(void *a1)
{
  *a1 = off_101A37D48;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AC5554(void *a1)
{
  *a1 = off_101A37D48;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100AC55C0()
{
}

uint64_t sub_100AC562C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 24);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100AC5678(uint64_t a1)
{
  sub_100AC60C0((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100AC56BC(uint64_t a1)
{
  sub_100AC5A08(a1);

  operator delete();
}

BOOL sub_100AC56F4(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_10040BBA8((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_10040BBA8((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_100AC582C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100AC5870(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100AC589C(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100AC58C8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_100AC5924(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100AC60C0((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100AC5984()
{
}

uint64_t sub_100AC5998(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100AC60C0((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100AC59F0()
{
  return 0;
}

uint64_t sub_100AC59F8()
{
  return 0;
}

uint64_t sub_100AC5A00()
{
  return 0;
}

uint64_t sub_100AC5A08(uint64_t a1)
{
  *(void *)a1 = off_101A37DA8;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_100AC5A7C()
{
}

uint64_t sub_100AC5A90(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100AC5AC0()
{
  return 0;
}

uint64_t sub_100AC5AC8()
{
  return 0;
}

uint64_t sub_100AC5AD0()
{
  return 0;
}

NSObject **sub_100AC5AD8(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_100AC5B28(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_100AC5AD8((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100AC6114(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvjEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvjEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100AC5C00(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1 && (uint64_t v2 = _Block_copy(v1)) != 0 && (v3 = _Block_copy(v2), (v4 = v3) != 0))
  {
    uint64_t v5 = _Block_copy(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      long long v7 = _Block_copy(v5);
      uint64_t v8 = v7;
      if (v7)
      {
        uint64_t v9 = _Block_copy(v7);
        uint64_t v10 = v9;
        if (v9)
        {
          uint64_t v11 = _Block_copy(v9);
          uint64_t v12 = v11;
          if (v11)
          {
            *(void *)&long long v14 = _Block_copy(v11);
            _Block_release(v12);
          }
          else
          {
            *(void *)&long long v14 = 0;
          }
          _Block_release(v10);
        }
        else
        {
          *(void *)&long long v14 = 0;
        }
        _Block_release(v8);
      }
      else
      {
        *(void *)&long long v14 = 0;
      }
      uint64_t v13 = off_101A37EF0;
      _Block_release(v6);
    }
    else
    {
      uint64_t v13 = off_101A37EF0;
      *(void *)&long long v14 = 0;
    }
    _Block_release(v4);
  }
  else
  {
    uint64_t v13 = off_101A37EF0;
    *(void *)&long long v14 = 0;
  }
  operator new();
}

void sub_100AC5E40()
{
}

uint64_t sub_100AC5E90(uint64_t a1)
{
  sub_10040BC30(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100AC60C0(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_100AC5F14(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvjEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvjEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_100AC5FF0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_100AC6000(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100AC609C(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_100AC60AC(_Unwind_Exception *a1)
{
}

uint64_t *sub_100AC60C0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100AC6114(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100AC6154()
{
}

__n128 sub_100AC6168(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A37F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100AC61BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A37F20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC61F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100AC623C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC627C()
{
}

void sub_100AC628C()
{
}

__n128 sub_100AC62A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A37FA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC62F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A37FA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC632C(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100AC63C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC6408()
{
}

void sub_100AC6418()
{
}

__n128 sub_100AC642C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A38020;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6480(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38020;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC64B8(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 8);
  read_rest_value();
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }

  return v3(v5, v2);
}

uint64_t sub_100AC653C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC657C()
{
}

void sub_100AC658C()
{
}

__n128 sub_100AC65A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A380A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC65F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A380A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC662C(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100AC66C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC6708()
{
}

void sub_100AC6718()
{
}

__n128 sub_100AC672C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A38120;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6780(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38120;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AC67B8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100AC6878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AC6890(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC68D0()
{
}

void sub_100AC68E0()
{
}

__n128 sub_100AC68F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A381A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6948(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A381A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AC6980(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100AC6A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AC6A58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC6A98()
{
}

void sub_100AC6AA8()
{
}

__n128 sub_100AC6ABC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A38220;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6B10(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38220;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AC6B48(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1005BF770((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10003FB28((uint64_t)&v9, v10);
}

void sub_100AC6C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AC6C20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC6C60()
{
}

void sub_100AC6C70()
{
}

__n128 sub_100AC6C84(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A382A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6CD8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A382A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AC6D10(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10072E934((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10026CF54((uint64_t)&v9, v10);
}

void sub_100AC6DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AC6DE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC6E28()
{
}

void sub_100AC6E38()
{
}

__n128 sub_100AC6E4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A38320;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC6EA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38320;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC6ED8(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100AC6FD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC7010()
{
}

void sub_100AC7020()
{
}

__n128 sub_100AC7034(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A383A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC7088(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A383A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100AC70C0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100AC7180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100AC7198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC71D8()
{
}

void sub_100AC71E8()
{
}

__n128 sub_100AC71FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A38420;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC7250(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38420;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC7288(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }
  return v3(v5);
}

void sub_100AC7334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_100AC7350(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC7390()
{
}

void sub_100AC73A0()
{
}

__n128 sub_100AC73B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A384A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100AC7408(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A384A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100AC7440(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100AC7530(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC7570()
{
}

void sub_100AC7580()
{
}

void *sub_100AC7594(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A38520;
  result[1] = v3;
  return result;
}

uint64_t sub_100AC75DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A38520;
  a2[1] = v2;
  return result;
}

void sub_100AC7608(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value();
      std::string __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      int v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          BOOL v16 = v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          BOOL v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/signal_strength_info");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100AC78D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100AC7988(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AC79C8()
{
}

void sub_100AC79D4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v34 = 0;
  int v35 = 0;
  uint64_t v7 = (capabilities::ct *)sub_100025E5C(&v34, v6, a2);
  uint64_t v8 = v34;
  if (!v34) {
    goto LABEL_46;
  }
  xpc_object_t v9 = *(std::__shared_weak_count **)(v6 + 80);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = a1[1];
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v11 = v10 + 8;
  uint64_t v12 = v13;
  if (!v13) {
    goto LABEL_15;
  }
  uint64_t v14 = v11;
  do
  {
    int v15 = *(_DWORD *)(v12 + 32);
    BOOL v16 = v15 < (int)a2;
    if (v15 >= (int)a2) {
      BOOL v17 = (uint64_t *)v12;
    }
    else {
      BOOL v17 = (uint64_t *)(v12 + 8);
    }
    if (!v16) {
      uint64_t v14 = v12;
    }
    uint64_t v12 = *v17;
  }
  while (*v17);
  if (v14 != v11 && *(_DWORD *)(v14 + 32) <= (int)a2 && (*(unsigned char *)(v14 + 64) & 1) != 0)
  {
    unsigned int v32 = *(_DWORD **)(v14 + 40);
    uint64_t v33 = *(_DWORD **)(v14 + 48);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v32 != v33)
    {
      while (*v32 != 14)
      {
        uint64_t v7 = (capabilities::ct *)capabilities::ct::supports5G(v7);
        if (v7)
        {
          if ((*v32 & 0xFFFFFFFE) == 0x10) {
            break;
          }
        }
        if (++v32 == v33)
        {
          unsigned int v32 = v33;
          break;
        }
      }
    }
    BOOL v18 = v32 != *(_DWORD **)(v14 + 48);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  else
  {
LABEL_15:
    BOOL v18 = 0;
  }
  long long v19 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 64) + 16))(*(void *)(v6 + 64), a2);
  uint64_t v20 = (os_log_t *)v19;
  if (*(unsigned char *)(a3 + 24))
  {
    xpc_object_t v23 = *(_DWORD **)a3;
    xpc_object_t v22 = *(_DWORD **)(a3 + 8);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v23 != v22)
    {
      while (*v23 != 14)
      {
        long long v19 = (capabilities::ct *)capabilities::ct::supports5G(v19);
        if (v19)
        {
          if ((*v23 & 0xFFFFFFFE) == 0x10) {
            break;
          }
        }
        if (++v23 == v22)
        {
          xpc_object_t v23 = v22;
          break;
        }
      }
    }
    xpc_object_t v24 = *(_DWORD **)(a3 + 8);
    BOOL v21 = v23 != v24;
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (((v18 ^ (v23 != v24)) & 1) == 0) {
      goto LABEL_44;
    }
    goto LABEL_30;
  }
  if (v18)
  {
    BOOL v21 = 0;
LABEL_30:
    uint64_t v25 = *v20;
    if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v26 = "false";
      if (v18) {
        int v27 = "true";
      }
      else {
        int v27 = "false";
      }
      if (v21) {
        xpc_object_t v26 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      int v37 = v27;
      __int16 v38 = 2080;
      uint64_t v39 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I IMS voice support is changing from %s to %s", buf, 0x16u);
    }
    uint64_t v28 = *(void *)(v8 + 8);
    uint64_t v29 = *(void *)(v8 + 16);
    while (v28 != v29)
    {
      uint64_t v30 = *(void *)(v28 + 8);
      SignalStrengthModel::setForceNotificationOnNextHeartbeat((SignalStrengthModel *)v30, 1);
      if (v21)
      {
        SignalStrengthModel::setImmediateMode((SignalStrengthModel *)v30);
        *(unsigned char *)(v30 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
        unint64_t v31 = *(void *)(v30 + 48) | 4;
      }
      else
      {
        unint64_t v31 = *(void *)(v30 + 48) & 0xFFFFFFFFFFFFFFFBLL;
      }
      *(void *)(v30 + 48) = v31;
      v28 += 24;
    }
    sub_100ABEB54(v6, a2);
  }
LABEL_44:
  if (v9) {
    sub_10004D2C8(v9);
  }
LABEL_46:
  if (v35) {
    sub_10004D2C8(v35);
  }
}

void sub_100AC7CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AC7D20(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v14 = *a1;
  subscriber::makeSimSlotRange();
  uint64_t v2 = v15;
  if (v15 != v16)
  {
    do
    {
      if (v17(*v2)) {
        goto LABEL_5;
      }
      ++v2;
    }
    while (v2 != v16);
    uint64_t v2 = v16;
LABEL_5:
    while (v2 != v16)
    {
      uint64_t v3 = *v2;
      int v4 = *((unsigned __int8 *)v14 + 12);
      sub_100025E5C(&v18, v1, *v2);
      uint64_t v5 = v18;
      if (v18)
      {
        uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 64) + 16))(*(void *)(v1 + 64), v3);
        int v7 = *(unsigned __int8 *)(v5 + 58);
        uint64_t v8 = *v6;
        BOOL v9 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
        if (v7)
        {
          if (v9)
          {
            *(_DWORD *)long long buf = 67109120;
            LODWORD(v21) = v4;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handleDriverState with %d", buf, 8u);
          }
          sub_100ABEEE0(v5, 0);
          uint64_t v10 = **(NSObject ***)v5;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = "true";
            if (*(unsigned char *)(v5 + 57)) {
              uint64_t v12 = "true";
            }
            else {
              uint64_t v12 = "false";
            }
            *(_DWORD *)long long buf = 136315394;
            if (!v4) {
              uint64_t v11 = "false";
            }
            BOOL v21 = v12;
            __int16 v22 = 2080;
            xpc_object_t v23 = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Running is changing from %s to %s", buf, 0x16u);
          }
          *(unsigned char *)(v5 + 57) = v4;
          sub_100ABEB54(v1, v3);
        }
        else if (v9)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handleDriverState ignored", buf, 2u);
        }
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
      uint64_t v13 = v2 + 1;
      uint64_t v2 = v16;
      if (v13 != v16)
      {
        uint64_t v2 = v13;
        do
        {
          if (v17(*v2)) {
            goto LABEL_27;
          }
          ++v2;
        }
        while (v2 != v16);
        uint64_t v2 = v16;
      }
LABEL_27:
      ;
    }
  }
  operator delete();
}

void sub_100AC7FC4()
{
}

void sub_100AC800C(uint64_t **a1)
{
  if (*((_DWORD *)*a1 + 3) <= 1u)
  {
    sub_100025E5C(&v1, **a1, *((_DWORD *)*a1 + 2));
    if (v1) {
      sub_100ABEEE0(v1, 0);
    }
    if (v2) {
      sub_10004D2C8(v2);
    }
  }
  operator delete();
}

uint64_t *sub_100AC8090(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v7 = a1;
  v8[0] = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  int v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1000389F8(*(uint64_t **)(v2 + 360), v3);
  v8[1] = v5;
  BOOL v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  SignalStrengthModel::handleInput();
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100AC8168(v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100AC812C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100AC8168(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC8168(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100AC81BC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v2 = v4;
  if (v4 != v5)
  {
    do
    {
      if (v6(*v2)) {
        goto LABEL_5;
      }
      ++v2;
    }
    while (v2 != v5);
    uint64_t v2 = v5;
LABEL_5:
    while (v2 != v5)
    {
      sub_100ABE2A0(v1, *v2);
      int v3 = v2 + 1;
      uint64_t v2 = v5;
      if (v3 != v5)
      {
        uint64_t v2 = v3;
        do
        {
          if (v6(*v2)) {
            goto LABEL_5;
          }
          ++v2;
        }
        while (v2 != v5);
        uint64_t v2 = v5;
      }
    }
  }
  operator delete();
}

void sub_100AC82A4()
{
}

void sub_100AC82DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A385B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AC82FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A385B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t *sub_100AC8350(uint64_t a1)
{
  return sub_1002BB67C((uint64_t *)(a1 + 24));
}

uint64_t *sub_100AC835C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v39 = a1;
  uint64_t v40 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  int v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), v3);
  sub_100025E5C(&v41, v2, v3);
  uint64_t v7 = v41;
  if (!v41)
  {
    uint64_t v28 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
LABEL_24:
      *(void *)uint64_t v5 = 0;
      *(_DWORD *)(v5 + 8) = 0;
      goto LABEL_25;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v29 = "Could not find state";
LABEL_39:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 2u);
    goto LABEL_24;
  }
  uint64_t v8 = *(void *)(v41 + 40);
  if (*(_DWORD *)(v41 + 32)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v8 == 0;
  }
  if (v9)
  {
    uint64_t v28 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v29 = "Could not find model";
    goto LABEL_39;
  }
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
  uint64_t v11 = *v6;
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(v7 + 40) + 16))(*(void *)(v7 + 40));
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v10;
    __int16 v44 = 2080;
    uint64_t v45 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Computed base bars of %u from model %s", buf, 0x12u);
  }
  unint64_t v14 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v12);
  if (HIDWORD(v14)) {
    __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 953, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
  }
  int v15 = (capabilities::ct *)capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v14);
  int v16 = (int)v15;
  if (v10 >= v15) {
    unsigned int v17 = v15;
  }
  else {
    unsigned int v17 = v10;
  }
  if ((capabilities::ct::supportsVoiceCall(v15) & 1) == 0)
  {
    *(_DWORD *)uint64_t v5 = v10;
    *(_DWORD *)(v5 + 4) = v17;
    *(_DWORD *)(v5 + 8) = v16;
    goto LABEL_25;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(v2 + 72));
  uint64_t v20 = ServiceMap;
  if (v21 < 0)
  {
    __int16 v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v21;
  uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
  unsigned int v37 = v17;
  if (v25)
  {
    uint64_t v26 = v25[3];
    int v27 = (std::__shared_weak_count *)v25[4];
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      char v38 = 0;
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v20);
  int v27 = 0;
  char v38 = 1;
LABEL_33:
  unint64_t v31 = (std::__shared_weak_count *)operator new(0x28uLL);
  v31->__shared_weak_owners_ = 0;
  v31->__shared_owners_ = 0;
  v31->__vftable = (std::__shared_weak_count_vtbl *)off_101A38600;
  v31[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v31[1].__shared_owners_ = (uint64_t)v4;
  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  unsigned int v32 = *(std::__shared_weak_count **)(v2 + 32);
  if (!v32 || (uint64_t v33 = *(void *)(v2 + 24), (v34 = std::__shared_weak_count::lock(v32)) == 0)) {
    sub_100088B9C();
  }
  int v35 = v34;
  atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v34);
  uint64_t v46 = 0;
  int v36 = operator new(0x40uLL);
  void *v36 = off_101A38650;
  v36[1] = v2;
  *((_DWORD *)v36 + 4) = v3;
  *((_DWORD *)v36 + 5) = v10;
  *((_DWORD *)v36 + 6) = v37;
  *((_DWORD *)v36 + 7) = v16;
  v36[4] = v31 + 1;
  void v36[5] = v31;
  v36[6] = v33;
  v36[7] = v35;
  uint64_t v46 = v36;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v26 + 56))(v26, v3, buf);
  sub_100060644(buf);
  sub_10004D2C8(v31);
  if ((v38 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  int v4 = 0;
LABEL_25:
  if (v42) {
    sub_10004D2C8(v42);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100AC8844(&v40);
  return sub_100046B58((uint64_t *)&v39);
}

void sub_100AC8794(_Unwind_Exception *a1, uint64_t a2, int a3, char a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  BOOL v12 = va_arg(va2, std::__shared_weak_count *);
  sub_100060644((uint64_t *)va2);
  sub_10004D2C8(v4);
  if ((a4 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100AC8844((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC8844(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100AC8898(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A38600;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AC88B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A38600;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AC890C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_100AC8920(void *a1)
{
  *a1 = off_101A38650;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100AC8978(void *a1)
{
  *a1 = off_101A38650;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

char *sub_100AC89F0(uint64_t a1)
{
  __n128 result = (char *)operator new(0x40uLL);
  *(void *)__n128 result = off_101A38650;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *((void *)result + 6) = *(void *)(a1 + 48);
  *((void *)result + 7) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100AC8A74(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A38650;
  long long v2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 56);
  *(void *)(a2 + 48) = *(void *)(result + 48);
  *(void *)(a2 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100AC8AD4(uint64_t a1)
{
}

void sub_100AC8ADC(void *a1)
{
  sub_100AC8D00((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AC8B18(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[6])
      {
        uint64_t v5 = a1[5];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 32);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100AC8CA4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AC8CB4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A386B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100AC8CF4()
{
  return &off_101A386B0;
}

void sub_100AC8D00(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

uint64_t *sub_100AC8D50(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *(void *)v1;
  signed int v3 = *(_DWORD *)(v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 12);
  uint64_t v5 = *(void **)(v1 + 32);
  uint64_t v6 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 64) + 16))(*(void *)(*(void *)v1 + 64), v3);
  unint64_t v7 = capabilities::ct::signalStrengthDisplayMaxValue(v6);
  if (HIDWORD(v7)) {
    __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 904, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
  }
  int v8 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v7);
  if (v4) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = *(unsigned char *)(v2 + 320) == 0;
  }
  if (v9) {
    goto LABEL_7;
  }
  int v12 = v8;
  uint64_t v13 = *(void *)(v2 + 336);
  if (!v13) {
    goto LABEL_19;
  }
  uint64_t v14 = v2 + 336;
  do
  {
    int v15 = *(_DWORD *)(v13 + 32);
    BOOL v16 = v15 < v3;
    if (v15 >= v3) {
      unsigned int v17 = (uint64_t *)v13;
    }
    else {
      unsigned int v17 = (uint64_t *)(v13 + 8);
    }
    if (!v16) {
      uint64_t v14 = v13;
    }
    uint64_t v13 = *v17;
  }
  while (*v17);
  if (v14 != v2 + 336 && *(_DWORD *)(v14 + 32) <= v3 && *(unsigned char *)(v14 + 109))
  {
LABEL_7:
    unsigned int v10 = (_DWORD *)*v5;
    uint64_t v11 = *(void *)(v1 + 16);
    void v10[2] = *(_DWORD *)(v1 + 24);
    *(void *)unsigned int v10 = v11;
  }
  else
  {
LABEL_19:
    uint64_t v20 = *(void *)(v2 + 232);
    uint64_t v19 = v2 + 232;
    uint64_t v18 = v20;
    if (!v20) {
      goto LABEL_33;
    }
    uint64_t v21 = v19;
    do
    {
      int v22 = *(_DWORD *)(v18 + 28);
      BOOL v23 = v22 < v3;
      if (v22 >= v3) {
        unsigned int v24 = (uint64_t *)v18;
      }
      else {
        unsigned int v24 = (uint64_t *)(v18 + 8);
      }
      if (!v23) {
        uint64_t v21 = v18;
      }
      uint64_t v18 = *v24;
    }
    while (*v24);
    if (v21 != v19 && *(_DWORD *)(v21 + 28) <= v3 && *(unsigned char *)(v21 + 32))
    {
      uint64_t v25 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Data-only attached, reporting zero bars", buf, 2u);
      }
      uint64_t v26 = (_DWORD *)*v5;
      *(void *)uint64_t v26 = 0;
      v26[2] = v12;
    }
    else
    {
LABEL_33:
      int v27 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Not CS attached, reporting one bar", buf, 2u);
      }
      uint64_t v28 = (_DWORD *)*v5;
      *uint64_t v28 = 1;
      v28[1] = v12 != 0;
      v28[2] = v12;
    }
  }
  sub_100AC8F90(&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_100AC8F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AC8F90(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100AC8FE4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100AC9048(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100AC90C8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  BOOL v16 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 360);
  if (!v3) {
    goto LABEL_18;
  }
  int v4 = *(_DWORD *)(v2 + 96);
  uint64_t v5 = v2 + 360;
  uint64_t v6 = v2 + 360;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < v4;
    if (v7 >= v4) {
      BOOL v9 = (uint64_t *)v3;
    }
    else {
      BOOL v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 == v5 || *(_DWORD *)(v6 + 32) > v4) {
    goto LABEL_18;
  }
  uint64_t v10 = *(void *)(v6 + 40);
  uint64_t v12 = *(void *)(v10 + 112);
  uint64_t v11 = *(std::__shared_weak_count **)(v10 + 120);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v12)
  {
    int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 72))(v12);
    sub_100AC9240(v1[4], v13);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (!v12) {
LABEL_18:
  }
    sub_100AC9240(v1[4], -1);
  sub_100AC91F0((uint64_t *)&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100AC91C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100AC91F0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC91F0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10022BA88((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100AC9240(uint64_t a1, int a2)
{
  int v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_100AC9290(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 360);
  if (!v3) {
    goto LABEL_18;
  }
  int v4 = *(_DWORD *)(v1 + 8);
  uint64_t v5 = v2 + 360;
  uint64_t v6 = v2 + 360;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < v4;
    if (v7 >= v4) {
      BOOL v9 = (uint64_t *)v3;
    }
    else {
      BOOL v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 == v5 || *(_DWORD *)(v6 + 32) > v4) {
    goto LABEL_18;
  }
  uint64_t v10 = *(void *)(v6 + 40);
  uint64_t v12 = *(void *)(v10 + 96);
  uint64_t v11 = *(std::__shared_weak_count **)(v10 + 104);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v12)
  {
    int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 72))(v12);
    sub_100AC9240(*(void *)(v1 + 40), v13);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (!v12) {
LABEL_18:
  }
    sub_100AC9240(*(void *)(v1 + 40), -1);
  sub_100AC93B8(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100AC9388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100AC93B8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC93B8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10022BA88((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100AC9408(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100AC9488(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 360);
  if (!v3) {
    goto LABEL_20;
  }
  int v4 = *(_DWORD *)(v1 + 8);
  uint64_t v5 = v2 + 360;
  uint64_t v6 = v2 + 360;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < v4;
    if (v7 >= v4) {
      BOOL v9 = (uint64_t *)v3;
    }
    else {
      BOOL v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 == v5 || *(_DWORD *)(v6 + 32) > v4) {
    goto LABEL_20;
  }
  uint64_t v10 = *(void *)(v6 + 40);
  uint64_t v12 = *(void *)(v10 + 80);
  uint64_t v11 = *(std::__shared_weak_count **)(v10 + 88);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v12)
  {
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v12 + 80))(__p, v12);
    uint64_t v13 = *(void *)(v1 + 40);
    if (!v13) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v13 + 48))(v13, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (!v12)
  {
LABEL_20:
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v14 = *(void *)(v1 + 40);
    if (!v14) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v14 + 48))(v14, &v18);
    if (v18)
    {
      uint64_t v19 = v18;
      operator delete(v18);
    }
  }
  sub_100AC965C(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_100AC9604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_100AC965C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC965C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10022BD94((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100AC96AC(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  int v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

uint64_t *sub_100AC9714(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v4 = a1;
  uint64_t v5 = v1;
  sub_100025BE0(&v6, *(void *)v1, *(unsigned int *)(v1 + 40));
  uint64_t v2 = *(void *)(v1 + 32);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100AC97D4(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100AC97A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100AC97D4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100AC2334((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100AC9824(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(void *)(v2 + 360);
  if (v3)
  {
    int v5 = *((_DWORD *)v1 + 2);
    uint64_t v4 = *((unsigned int *)v1 + 3);
    uint64_t v6 = v2 + 360;
    uint64_t v7 = v2 + 360;
    do
    {
      int v8 = *(_DWORD *)(v3 + 32);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        uint64_t v10 = (uint64_t *)v3;
      }
      else {
        uint64_t v10 = (uint64_t *)(v3 + 8);
      }
      if (!v9) {
        uint64_t v7 = v3;
      }
      uint64_t v3 = *v10;
    }
    while (*v10);
    if (v7 != v6 && *(_DWORD *)(v7 + 32) <= v5)
    {
      uint64_t v11 = *(void *)(v7 + 40);
      uint64_t v12 = *(void *)(v11 + 112);
      uint64_t v13 = *(std::__shared_weak_count **)(v11 + 120);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v12) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v4);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
    }
  }
  operator delete();
}

void sub_100AC990C()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_100AC9944(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(void *)(v2 + 360);
  if (v3)
  {
    int v5 = *((_DWORD *)v1 + 2);
    uint64_t v4 = *((unsigned int *)v1 + 3);
    uint64_t v6 = v2 + 360;
    uint64_t v7 = v2 + 360;
    do
    {
      int v8 = *(_DWORD *)(v3 + 32);
      BOOL v9 = v8 < v5;
      if (v8 >= v5) {
        uint64_t v10 = (uint64_t *)v3;
      }
      else {
        uint64_t v10 = (uint64_t *)(v3 + 8);
      }
      if (!v9) {
        uint64_t v7 = v3;
      }
      uint64_t v3 = *v10;
    }
    while (*v10);
    if (v7 != v6 && *(_DWORD *)(v7 + 32) <= v5)
    {
      uint64_t v11 = *(void *)(v7 + 40);
      uint64_t v12 = *(void *)(v11 + 96);
      uint64_t v13 = *(std::__shared_weak_count **)(v11 + 104);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v12) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v4);
      }
      if (v13) {
        sub_10004D2C8(v13);
      }
    }
  }
  operator delete();
}

void sub_100AC9A2C()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

uint64_t *sub_100AC9A64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v15 = 0;
  sub_10005C928(&v15, *(const void **)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 24) - *(void *)(v1 + 16));
  uint64_t v4 = *(void *)(v2 + 360);
  if (v4)
  {
    uint64_t v5 = v2 + 360;
    do
    {
      int v6 = *(_DWORD *)(v4 + 32);
      BOOL v7 = v6 < v3;
      if (v6 >= v3) {
        int v8 = (uint64_t *)v4;
      }
      else {
        int v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    if (v5 != v2 + 360 && *(_DWORD *)(v5 + 32) <= v3)
    {
      uint64_t v9 = *(void *)(v5 + 40);
      uint64_t v11 = *(void *)(v9 + 80);
      uint64_t v10 = *(std::__shared_weak_count **)(v9 + 88);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v11)
      {
        std::string __p = 0;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        sub_10005C928(&__p, v15, (uint64_t)v16, v16 - (unsigned char *)v15);
        (*(void (**)(uint64_t, void **))(*(void *)v11 + 24))(v11, &__p);
        if (__p)
        {
          uint64_t v19 = __p;
          operator delete(__p);
        }
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
  }
  if (v15)
  {
    uint64_t v16 = v15;
    operator delete(v15);
  }
  sub_100AB63B8(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100AC9B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (a11)
  {
    a12 = (uint64_t)a11;
    operator delete(a11);
  }
  sub_100AB63B8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC9BE4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100AC9C38(unsigned int *a1)
{
  int v8 = a1;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_100068A94(&v10);
  if (v10)
  {
    (*(void (**)(uint64_t, void))(*(void *)v10 + 376))(v10, *a1);
  }
  else
  {
    int v3 = (std::__shared_weak_count *)*((void *)a1 + 2);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *((void *)a1 + 1);
        if (v6)
        {
          BOOL v7 = *(NSObject **)(v6 + 56);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Missing C2KRadioModule for sending LQM update!", buf, 2u);
          }
        }
        sub_10004D2C8(v5);
      }
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return sub_100AC9BE4((uint64_t *)&v8);
}

void sub_100AC9D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100AC9BE4(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100AC9D4C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  BOOL v7 = v1;
  uint64_t v2 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v3 = (uint64_t)(v1 + 1);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 88))(v4) == *(_DWORD *)(v2 + 96)) {
    sub_100AC189C(v2, v3);
  }
  sub_100046B58((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100AC9DCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100AC9DE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A38730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AC9E08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A38730;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100AC9E64(void *a1)
{
  *a1 = off_101A38780;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100AC9EBC(void *a1)
{
  *a1 = off_101A38780;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

char *sub_100AC9F34(uint64_t a1)
{
  __n128 result = (char *)operator new(0x40uLL);
  *(void *)__n128 result = off_101A38780;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *((void *)result + 6) = *(void *)(a1 + 48);
  *((void *)result + 7) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100AC9FB8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A38780;
  long long v2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 56);
  *(void *)(a2 + 48) = *(void *)(result + 48);
  *(void *)(a2 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ACA018(uint64_t a1)
{
}

void sub_100ACA020(void *a1)
{
  sub_100AC8D00((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ACA05C(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[6])
      {
        uint64_t v5 = a1[5];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 32);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100ACA1E8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ACA1F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ACA238()
{
}

uint64_t *sub_100ACA244(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v29 = a1;
  uint64_t v30 = v1;
  uint64_t v2 = *v1;
  signed int v3 = *((_DWORD *)v1 + 2);
  int v4 = *((unsigned __int8 *)v1 + 12);
  uint64_t v5 = (int *)v1[4];
  uint64_t v6 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 64) + 16))(*(void *)(*v1 + 64), v3);
  unint64_t v7 = capabilities::ct::signalStrengthDisplayMaxValue(v6);
  if (HIDWORD(v7)) {
    __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 904, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
  }
  int v8 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v7);
  if (v4) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = *(unsigned char *)(v2 + 320) == 0;
  }
  if (v9) {
    goto LABEL_7;
  }
  int v11 = v8;
  uint64_t v12 = *(void *)(v2 + 336);
  if (!v12) {
    goto LABEL_19;
  }
  uint64_t v13 = v2 + 336;
  do
  {
    int v14 = *(_DWORD *)(v12 + 32);
    BOOL v15 = v14 < v3;
    if (v14 >= v3) {
      uint64_t v16 = (uint64_t *)v12;
    }
    else {
      uint64_t v16 = (uint64_t *)(v12 + 8);
    }
    if (!v15) {
      uint64_t v13 = v12;
    }
    uint64_t v12 = *v16;
  }
  while (*v16);
  if (v13 != v2 + 336 && *(_DWORD *)(v13 + 32) <= v3 && *(unsigned char *)(v13 + 109))
  {
LABEL_7:
    uint64_t v10 = *(void *)v5;
    (*(void (**)(void, void, uint64_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], v1 + 2);
    sub_100AC119C(v10, v5[2], v1 + 2);
  }
  else
  {
LABEL_19:
    uint64_t v19 = *(void *)(v2 + 232);
    uint64_t v18 = v2 + 232;
    uint64_t v17 = v19;
    if (!v19) {
      goto LABEL_33;
    }
    uint64_t v20 = v18;
    do
    {
      int v21 = *(_DWORD *)(v17 + 28);
      BOOL v22 = v21 < v3;
      if (v21 >= v3) {
        BOOL v23 = (uint64_t *)v17;
      }
      else {
        BOOL v23 = (uint64_t *)(v17 + 8);
      }
      if (!v22) {
        uint64_t v20 = v17;
      }
      uint64_t v17 = *v23;
    }
    while (*v23);
    if (v20 != v18 && *(_DWORD *)(v20 + 28) <= v3 && *(unsigned char *)(v20 + 32))
    {
      unsigned int v24 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Data-only attached, reporting zero bars", buf, 2u);
      }
      *(void *)long long buf = 0;
      int v32 = v11;
      uint64_t v25 = *(void *)v5;
      (*(void (**)(void, void, uint8_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], buf);
      sub_100AC119C(v25, v5[2], (uint64_t *)buf);
    }
    else
    {
LABEL_33:
      uint64_t v26 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Not CS attached, reporting one bar", buf, 2u);
      }
      *(_DWORD *)long long buf = 1;
      *(_DWORD *)&uint8_t buf[4] = v11 != 0;
      int v32 = v11;
      uint64_t v27 = *(void *)v5;
      (*(void (**)(void, void, uint8_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], buf);
      sub_100AC119C(v27, v5[2], (uint64_t *)buf);
    }
  }
  sub_100AC8F90((uint64_t *)&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_100ACA518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100ACA534(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A38800;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100ACA554(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A38800;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100ACA5B0(void *a1)
{
  *a1 = off_101A38850;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  signed int v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100ACA608(void *a1)
{
  *a1 = off_101A38850;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  signed int v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

char *sub_100ACA680(uint64_t a1)
{
  __n128 result = (char *)operator new(0x40uLL);
  *(void *)__n128 result = off_101A38850;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *((void *)result + 6) = *(void *)(a1 + 48);
  *((void *)result + 7) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100ACA704(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A38850;
  long long v2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(_OWORD *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 56);
  *(void *)(a2 + 48) = *(void *)(result + 48);
  *(void *)(a2 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ACA764(uint64_t a1)
{
}

void sub_100ACA76C(void *a1)
{
  sub_100AC8D00((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ACA7A8(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[6])
      {
        uint64_t v5 = a1[5];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 32);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100ACA934(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ACA944(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A388B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100ACA984()
{
  return &off_101A388B0;
}

uint64_t *sub_100ACA990(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v29 = a1;
  uint64_t v30 = v1;
  uint64_t v2 = *v1;
  signed int v3 = *((_DWORD *)v1 + 2);
  int v4 = *((unsigned __int8 *)v1 + 12);
  uint64_t v5 = (int *)v1[4];
  uint64_t v6 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(*v1 + 64) + 16))(*(void *)(*v1 + 64), v3);
  unint64_t v7 = capabilities::ct::signalStrengthDisplayMaxValue(v6);
  if (HIDWORD(v7)) {
    __assert_rtn("getSignalStrengthInfo_sync", "SignalStrengthController.cpp", 904, "capabilities::ct::signalStrengthDisplayMaxValue() <= std::numeric_limits<uint32_t>::max()");
  }
  int v8 = capabilities::ct::signalStrengthDisplayMaxValue((capabilities::ct *)v7);
  if (v4) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = *(unsigned char *)(v2 + 320) == 0;
  }
  if (v9) {
    goto LABEL_7;
  }
  int v11 = v8;
  uint64_t v12 = *(void *)(v2 + 336);
  if (!v12) {
    goto LABEL_19;
  }
  uint64_t v13 = v2 + 336;
  do
  {
    int v14 = *(_DWORD *)(v12 + 32);
    BOOL v15 = v14 < v3;
    if (v14 >= v3) {
      uint64_t v16 = (uint64_t *)v12;
    }
    else {
      uint64_t v16 = (uint64_t *)(v12 + 8);
    }
    if (!v15) {
      uint64_t v13 = v12;
    }
    uint64_t v12 = *v16;
  }
  while (*v16);
  if (v13 != v2 + 336 && *(_DWORD *)(v13 + 32) <= v3 && *(unsigned char *)(v13 + 109))
  {
LABEL_7:
    uint64_t v10 = *(void *)v5;
    (*(void (**)(void, void, uint64_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], v1 + 2);
    sub_100AC119C(v10, v5[2], v1 + 2);
  }
  else
  {
LABEL_19:
    uint64_t v19 = *(void *)(v2 + 232);
    uint64_t v18 = v2 + 232;
    uint64_t v17 = v19;
    if (!v19) {
      goto LABEL_33;
    }
    uint64_t v20 = v18;
    do
    {
      int v21 = *(_DWORD *)(v17 + 28);
      BOOL v22 = v21 < v3;
      if (v21 >= v3) {
        BOOL v23 = (uint64_t *)v17;
      }
      else {
        BOOL v23 = (uint64_t *)(v17 + 8);
      }
      if (!v22) {
        uint64_t v20 = v17;
      }
      uint64_t v17 = *v23;
    }
    while (*v23);
    if (v20 != v18 && *(_DWORD *)(v20 + 28) <= v3 && *(unsigned char *)(v20 + 32))
    {
      unsigned int v24 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Data-only attached, reporting zero bars", buf, 2u);
      }
      *(void *)long long buf = 0;
      int v32 = v11;
      uint64_t v25 = *(void *)v5;
      (*(void (**)(void, void, uint8_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], buf);
      sub_100AC119C(v25, v5[2], (uint64_t *)buf);
    }
    else
    {
LABEL_33:
      uint64_t v26 = *(NSObject **)v6;
      if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Not CS attached, reporting one bar", buf, 2u);
      }
      *(_DWORD *)long long buf = 1;
      *(_DWORD *)&uint8_t buf[4] = v11 != 0;
      int v32 = v11;
      uint64_t v27 = *(void *)v5;
      (*(void (**)(void, void, uint8_t *))(**(void **)(*(void *)v5 + 424) + 32))(*(void *)(*(void *)v5 + 424), v5[2], buf);
      sub_100AC119C(v27, v5[2], (uint64_t *)buf);
    }
  }
  sub_100AC8F90((uint64_t *)&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_100ACAC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100ACADA8()
{
}

void sub_100ACAE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)SatMsg_IDSOffGridStateManagerObjC;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_100ACB084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ACB220(_Unwind_Exception *a1)
{
  int v4 = v2;
  objc_destroyWeak(v4);

  objc_destroyWeak((id *)(v3 - 32));
  _Unwind_Resume(a1);
}

void sub_100ACB25C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unint64_t v7 = (id *)(a1 + 32);
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v9 = (id **)WeakRetained;
  if (WeakRetained)
  {
    uint64_t v10 = sub_100200FB4(WeakRetained + 2);
    dispatch_assert_queue_V2(v10);

    if (v6)
    {
      int v11 = sub_100200FB4(v9[1]);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "failed to fetchContactsOfType IDSOffGridContactTypeEmergency, error: %@", (uint8_t *)&buf, 0xCu);
      }

      *((unsigned char *)v9 + 24) = 0;
    }
    else
    {
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v20 = 0x4012000000;
      int v21 = sub_100ACB534;
      BOOL v22 = sub_100ACB544;
      BOOL v23 = "";
      uint64_t v12 = (std::__shared_weak_count *)operator new(0x30uLL);
      v12->__shared_owners_ = 0;
      v12->__shared_weak_owners_ = 0;
      v12->__vftable = (std::__shared_weak_count_vtbl *)off_101999A28;
      v12[1].__shared_owners_ = 0;
      v12[1].__shared_weak_owners_ = 0;
      v12[1].__vftable = 0;
      unsigned int v24 = v12 + 1;
      uint64_t v25 = v12;
      [v9 addPrimaryContacts:v5 dst:&v24];
      long long v13 = v18;
      long long v18 = 0uLL;
      int v14 = *(std::__shared_weak_count **)(*((void *)&buf + 1) + 56);
      *(_OWORD *)(*((void *)&buf + 1) + 48) = v13;
      if (v14)
      {
        sub_10004D2C8(v14);
        if (*((void *)&v18 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
        }
      }
      BOOL v15 = [v9 fManager];
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_100ACB554;
      CFDictionaryRef v16[3] = &unk_101A388C8;
      objc_copyWeak(&v17, v7);
      v16[4] = &buf;
      [v15 fetchContactsOfType:2 completion:v16];

      objc_destroyWeak(&v17);
      _Block_object_dispose(&buf, 8);
      if (v25) {
        sub_10004D2C8(v25);
      }
    }
  }
}

void sub_100ACB4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  objc_destroyWeak(v28);

  _Block_object_dispose(&a17, 8);
  if (a24) {
    sub_10004D2C8(a24);
  }

  _Unwind_Resume(a1);
}

__n128 sub_100ACB534(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void sub_100ACB544(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100ACB554(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  int v8 = WeakRetained;
  if (WeakRetained)
  {
    BOOL v9 = sub_100200FB4(WeakRetained + 2);
    dispatch_assert_queue_V2(v9);

    uint64_t v10 = (id *)v8[1];
    if (!v6)
    {
      uint64_t v12 = sub_100200FB4(v10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I IDS contacts initial fetch complete", buf, 2u);
      }

      [v8 addPrimaryContacts:v5 dst:*(void *)(*(void *)(a1 + 32) + 8) + 48];
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
      long long v14 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      BOOL v15 = *(std::__shared_weak_count **)(v13 + 56);
      *(_OWORD *)(v13 + 48) = v14;
      if (v15)
      {
        sub_10004D2C8(v15);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      [v8 setContacts:*(void *)(*(void *)(a1 + 32) + 8) + 48];
      uint64_t v16 = v8;
      sub_100200FB4(v8 + 4);
      id v17 = (id)objc_claimAutoreleasedReturnValue();
      operator new();
    }
    int v11 = sub_100200FB4(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "failed to fetchContactsOfType IDSOffGridContactTypeFamily, error: %@", buf, 0xCu);
    }

    *((unsigned char *)v8 + 24) = 0;
  }
}

void sub_100ACB788(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ACB974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ACBBC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ACBC10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ACBD54(void *a1)
{
  sub_10006A6AC(a1);
}

void sub_100ACC08C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ACC3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_100ACC4E0(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  id v6 = operator new(0x28uLL);
  v6[1] = 0;
  void v6[2] = 0;
  void *v6 = off_101A389C8;
  void v6[3] = off_101A38940;
  v6[4] = 0;
  unint64_t v7 = [SatMsg_IDSOffGridStateManagerObjC alloc];
  int v8 = (std::__shared_weak_count *)a2[1];
  uint64_t v11 = *a2;
  uint64_t v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v9 = [(SatMsg_IDSOffGridStateManagerObjC *)v7 initWithQueue:a1 delegate:&v11];
  uint64_t v10 = (void *)v6[4];
  v6[4] = v9;

  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  *a3 = v6 + 3;
  a3[1] = v6;
}

void sub_100ACC5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100ACC5E0(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  v4[0] = *a2;
  v4[1] = (uint64_t)v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100ACC4E0(a1, v4, a3);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100ACC64C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

id sub_100ACC664@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  id result = *(id *)(a1 + 8);
  if (result) {
    return [result getContacts];
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

id sub_100ACC678(uint64_t a1)
{
  return [*(id *)(a1 + 8) getCachedOffGridMode];
}

id sub_100ACC680(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 8) setOffGridMode:a2 entryPoint:a3];
}

uint64_t sub_100ACC690(uint64_t a1)
{
  return a1;
}

void sub_100ACC6BC(uint64_t a1)
{
  operator delete();
}

id **sub_100ACC708(id *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  if (!v1[24]) {
    [v1 doInitManagerAndFetch];
  }
  return sub_1001217C8(&v3);
}

void sub_100ACC748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001217C8((id **)va);
  _Unwind_Resume(a1);
}

void sub_100ACC75C(id *a1)
{
  int v4 = a1;
  uint64_t v1 = (id *)((char *)*a1 + 16);
  id v2 = *a1;
  sub_100200FB4(v1);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  operator new();
}

id **sub_100ACC824(id *a1)
{
  id v2 = a1;
  *((unsigned char *)*a1 + 24) = 0;
  return sub_1001217C8(&v2);
}

uint64_t *sub_100ACC854(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    id v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_100ACC8B0(void *a1)
{
  long long v14 = a1;
  uint64_t v2 = *a1;
  id v3 = *(std::__shared_weak_count **)(*a1 + 72);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v2 = *a1;
  }
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id v6 = *(std::__shared_weak_count **)(v2 + 72);
  *(void *)(v2 + 64) = v5;
  *(void *)(v2 + 72) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *a1;
  int v8 = *(std::__shared_weak_count **)(*a1 + 48);
  if (v8)
  {
    BOOL v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(v7 + 40);
      if (v11)
      {
        uint64_t v12 = (std::__shared_weak_count *)a1[2];
        uint64_t v15 = a1[1];
        uint64_t v16 = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 8))(v11, &v15);
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v10);
    }
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  return sub_100ACC854((uint64_t *)&v14);
}

void sub_100ACC9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v13);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100ACC854(&a10);
  _Unwind_Resume(a1);
}

id **sub_100ACC9E0(id *a1)
{
  id v6 = a1;
  [*a1 doInitManagerIfRequired];
  uint64_t v2 = [*a1 fManager];

  if (v2)
  {
    id v3 = *a1;
    uint64_t v4 = [*a1 fManager];
    objc_msgSend(v3, "updateOffGridMode:", objc_msgSend(v4, "offGridMode"));
  }
  return sub_1001217C8(&v6);
}

void sub_100ACCA5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_1001217C8((id **)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ACCA7C(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    objc_destroyWeak((id *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100ACCAD8(uint64_t a1)
{
  uint64_t v13 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = sub_100200FB4(*((id **)WeakRetained + 1));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v5 = *(void *)(a1 + 24);
      if (v5 > 2) {
        id v6 = "???";
      }
      else {
        id v6 = off_101A38A08[v5];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I updateOffGridMode to %s", buf, 0xCu);
    }

    uint64_t v7 = *(void *)(a1 + 24);
    v3[28] = (v7 == 2) | 0x100;
    int v8 = *(std::__shared_weak_count **)(a1 + 16);
    if (v8)
    {
      BOOL v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void (****)(void, BOOL))(a1 + 8);
        if (v11) {
          (**v11)(v11, v7 == 2);
        }
        sub_10004D2C8(v10);
      }
    }
  }

  return sub_100ACCA7C(&v13);
}

void sub_100ACCC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10004D2C8(v3);

  sub_100ACCA7C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ACCC5C(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_100ACCCBC(uint64_t a1)
{
  objc_msgSend(*(id *)a1, "doInitManagerIfRequired", a1);
  id location = 0;
  objc_initWeak(&location, *(id *)a1);
  uint64_t v2 = objc_opt_new();
  id v3 = (uint64_t *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  if (*(char *)(a1 + 39) < 0) {
    uint64_t v4 = *v3;
  }
  unint64_t v5 = +[NSString stringWithUTF8String:v4];
  [v2 setEntryPointSource:v5];

  id v6 = [*(id *)a1 fManager];
  int v7 = *(unsigned __int8 *)(a1 + 8);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3321888768;
  dispatch_object_t v11[2] = sub_100ACCEA0;
  v11[3] = &unk_101A38988;
  objc_copyWeak(&v12, &location);
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    long long __p = *(_OWORD *)v3;
    uint64_t v14 = *(void *)(a1 + 32);
  }
  if (v7) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 1;
  }
  [v6 setOffGridMode:v8 options:v2 completion:v11];

  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  objc_destroyWeak(&v12);

  objc_destroyWeak(&location);
  return sub_100ACCC5C(&v10);
}

void sub_100ACCE3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,id location)
{
  objc_destroyWeak(v23);

  objc_destroyWeak(&location);
  sub_100ACCC5C(&a9);
  _Unwind_Resume(a1);
}

void sub_100ACCEA0(uint64_t a1, unint64_t a2, unint64_t a3, void *a4)
{
  int v7 = a4;
  id WeakRetained = (id **)objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v9 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v10 = WeakRetained[1];
    if (v7)
    {
      uint64_t v11 = sub_100200FB4(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = (void *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0) {
          id v12 = (void *)*v12;
        }
        int v16 = 136315394;
        id v17 = v12;
        __int16 v18 = 2112;
        uint64_t v19 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "failed to setOffGridMode for %s, error: %@", (uint8_t *)&v16, 0x16u);
      }
    }
    else
    {
      uint64_t v11 = sub_100200FB4(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = (void *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0) {
          uint64_t v13 = (void *)*v13;
        }
        if (a2 > 2) {
          uint64_t v14 = "???";
        }
        else {
          uint64_t v14 = off_101A38A08[a2];
        }
        if (a3 > 2) {
          uint64_t v15 = "???";
        }
        else {
          uint64_t v15 = off_101A38A20[a3];
        }
        int v16 = 136315650;
        id v17 = v13;
        __int16 v18 = 2080;
        uint64_t v19 = v14;
        __int16 v20 = 2080;
        int v21 = v15;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I setOffGridMode for %s returned: mode = %s, publishStatus = %s", (uint8_t *)&v16, 0x20u);
      }
    }
  }
}

void sub_100ACD054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100ACD074(uint64_t a1, uint64_t a2)
{
  id result = (void *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  long long v3 = *(_OWORD *)(a2 + 40);
  result[2] = *(void *)(a2 + 56);
  *(_OWORD *)id result = v3;
  return result;
}

void sub_100ACD0A8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A389C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100ACD0C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A389C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100ACD11C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 24))();
}

uint64_t sub_100ACD144(uint64_t a1, NSObject **a2, void *a3, void *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "cp.sub");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v8 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v22, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  *(void *)a1 = off_101A38A48;
  *(void *)(a1 + 48) = off_101A38B40;
  *(void *)(a1 + 56) = *a4;
  uint64_t v9 = a4[1];
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *a3;
  uint64_t v10 = a3[1];
  *(void *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void))(*(void *)*a4 + 552))(*a4);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  (**(void (***)(OsLogContext *__return_ptr))*a4)(&v21);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v21.var0);
  id v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, &v22);
  if (v17)
  {
    uint64_t v19 = v17[3];
    __int16 v18 = (std::__shared_weak_count *)v17[4];
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v19 = 0;
    __int16 v18 = 0;
  }
  std::mutex::unlock(v12);
  *(void *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = v19;
  *(void *)(a1 + 128) = v18;
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v18);
  }
  if (v21.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v21.var1.fRef);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 16sub_1001A7358((uint64_t)&a9, 0) = a1 + 168;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 20sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 241) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 279) = 0;
  *(unsigned char *)(a1 + 283) = 1;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  return a1;
}

void sub_100ACD3D4(_Unwind_Exception *a1)
{
  unint64_t v5 = (std::__shared_weak_count *)*((void *)v1 + 14);
  if (v5) {
    sub_10004D2C8(v5);
  }
  id v6 = (std::__shared_weak_count *)*((void *)v1 + 12);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = (std::__shared_weak_count *)*((void *)v1 + 10);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v1 + 8);
  if (v8) {
    sub_10004D2C8(v8);
  }
  CellularPlanSubscriptionControllerInterface::~CellularPlanSubscriptionControllerInterface(v1);
  ctu::OsLogLogger::~OsLogLogger(v3);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100ACD46C(uint64_t a1)
{
  *(void *)a1 = off_101A38A48;
  *(void *)(a1 + 48) = off_101A38B40;
  unsigned int v16 = (void **)(a1 + 408);
  sub_10016A9A4(&v16);
  sub_10030DD28((void *)(a1 + 368));
  uint64_t v2 = *(void **)(a1 + 344);
  if (v2)
  {
    long long v3 = *(void **)(a1 + 352);
    uint64_t v4 = *(void **)(a1 + 344);
    if (v3 != v2)
    {
      do
        long long v3 = sub_100333DB8(v3 - 4);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 344);
    }
    *(void *)(a1 + 352) = v2;
    operator delete(v4);
  }
  sub_10032493C((void *)(a1 + 312));
  unsigned int v16 = (void **)(a1 + 288);
  sub_1000C63B8(&v16);
  uint64_t v5 = *(void *)(a1 + 232);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 240);
    int v7 = *(void **)(a1 + 232);
    if (v6 != v5)
    {
      do
      {
        v6 -= 80;
        sub_100AD37BC(v6);
      }
      while (v6 != v5);
      int v7 = *(void **)(a1 + 232);
    }
    *(void *)(a1 + 24sub_1001A7358((uint64_t)&a9, 0) = v5;
    operator delete(v7);
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  sub_10005CD2C(a1 + 160, *(char **)(a1 + 168));
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 152);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 128);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 112);
  if (v11) {
    sub_10004D2C8(v11);
  }
  id v12 = *(std::__shared_weak_count **)(a1 + 96);
  if (v12) {
    sub_10004D2C8(v12);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(a1 + 80);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 64);
  if (v14) {
    sub_10004D2C8(v14);
  }
  CellularPlanSubscriptionControllerInterface::~CellularPlanSubscriptionControllerInterface((CellularPlanSubscriptionControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100ACD640(uint64_t a1)
{
  return sub_100ACD46C(a1 - 48);
}

void sub_100ACD648(uint64_t a1)
{
  sub_100ACD46C(a1);

  operator delete();
}

void sub_100ACD680(uint64_t a1)
{
  sub_100ACD46C(a1 - 48);

  operator delete();
}

void sub_100ACD6BC(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  double v2 = (*(double (**)(void))(**(void **)(a1 + 88) + 48))(*(void *)(a1 + 88));
  if (v2 <= CFAbsoluteTimeGetCurrent())
  {
    *(unsigned char *)(a1 + 281) = 1;
    (*(void (**)(void, double))(**(void **)(a1 + 88) + 88))(*(void *)(a1 + 88), 0.0);
  }
  else
  {
    sub_100ACD92C(a1, *(uint64_t *)&v2, 1);
  }
  id v12 = 0;
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  (*(void (**)(uint64_t **__return_ptr))(**(void **)(a1 + 88) + 136))(&v12);
  if (v12 != v13)
  {
    long long v3 = *(std::__shared_weak_count **)(a1 + 80);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 72);
        if (v6)
        {
          int v7 = v13;
          if (v12 != v13)
          {
            uint64_t v8 = v12 + 9;
            do
            {
              uint64_t v9 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v10 = v8;
                if (*((char *)v8 + 23) < 0) {
                  uint64_t v10 = (uint64_t *)*v8;
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v10;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Auto fetching consented pending profile (%s)", buf, 0xCu);
              }
              (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 72))(v6, v8 - 9);
              uint64_t v11 = v8 + 30;
              v8 += 39;
            }
            while (v11 != v7);
          }
        }
        sub_10004D2C8(v5);
      }
    }
  }
  *(void *)long long buf = &v12;
  sub_1000C63B8((void ***)buf);
}

void sub_100ACD900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
}

void sub_100ACD92C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
    uint64_t v7 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  *(unsigned char *)(a1 + 281) = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  if (a3)
  {
    uint64_t v9 = 1000000 * (uint64_t)(*(double *)&a2 - Current);
  }
  else
  {
    (*(void (**)(void, double))(**(void **)(a1 + 88) + 88))(*(void *)(a1 + 88), Current + 86400.0);
    uint64_t v9 = 86400000000;
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v10 || (v11 = *(void *)(a1 + 8), (id v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v13 = v12;
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v25);
  Registry::getTimerService(&v27, v25);
  uint64_t v14 = v27;
  sub_100058DB0(__p, "CarrierListWifiTimer");
  uint64_t v15 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_100ACEF90;
  aBlock[3] = &unk_101A38B90;
  aBlock[4] = a1;
  void aBlock[5] = v11;
  __int16 v20 = v13;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  OsLogContext v21 = _Block_copy(aBlock);
  sub_100118A44(v14, (uint64_t)__p, 1, v9, &object, &v21);
  uint64_t v16 = v29;
  uint64_t v29 = 0;
  uint64_t v17 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    uint64_t v18 = v29;
    uint64_t v29 = 0;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
  }
  if (v21) {
    _Block_release(v21);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  std::__shared_weak_count::__release_weak(v13);
}

void sub_100ACDC14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v25 - 64);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v25 - 80);
  if (v28) {
    sub_10004D2C8(v28);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

void sub_100ACDC94(uint64_t a1)
{
  if (!*(void *)(a1 + 144))
  {
    uint64_t v2 = *(void *)(a1 + 56);
    long long v3 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v4 || (uint64_t v5 = *(void *)(a1 + 8), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v7 = v5 + 48;
    if (!v5) {
      uint64_t v7 = 0;
    }
    uint64_t v10 = v7;
    uint64_t v11 = v6;
    (*(void (**)(long long *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v2 + 408))(&v13, v2, &object, &v10);
    long long v8 = v13;
    long long v13 = 0uLL;
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 152);
    *(_OWORD *)(a1 + 144) = v8;
    if (v9)
    {
      sub_10004D2C8(v9);
      if (*((void *)&v13 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
      }
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (object) {
      dispatch_release(object);
    }
  }
}

void sub_100ACDD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ACDDB0(const char *a1)
{
  uint64_t v1 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD38, memory_order_acquire) & 1) == 0)
  {
    int v3 = __cxa_guard_acquire(&qword_101B0FD38);
    uint64_t v1 = a1;
    if (v3)
    {
      uint64_t v5 = 0;
      sub_100AD3C14(&v5);
      uint64_t v4 = v5;
      uint64_t v5 = 0;
      if (v4) {
        sub_1007A8468((uint64_t)&v5, v4);
      }
      __cxa_atexit((void (*)(void *))sub_100ACDEA8, &qword_101B0FD40, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0FD38);
      uint64_t v1 = a1;
    }
  }
  if (qword_101B0FD40) {
    sub_100EE8BC8(qword_101B0FD40, v1);
  }
}

void sub_100ACDE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = a10;
  a10 = 0;
  if (v11) {
    sub_1007A8468((uint64_t)&a10, v11);
  }
  __cxa_guard_abort(&qword_101B0FD38);
  _Unwind_Resume(a1);
}

uint64_t sub_100ACDEA8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ACDED8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v26, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v26 = *(_OWORD *)a2;
    uint64_t v27 = *(void *)(a2 + 16);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v29 = 0;
  sub_10005C928(__p, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  sub_100A86C84((uint64_t)v30, a4);
  unint64_t v8 = a1[30];
  unint64_t v7 = a1[31];
  if (v8 >= v7)
  {
    uint64_t v11 = a1[29];
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - v11) >> 4);
    if (v12 + 1 > 0x333333333333333) {
      sub_10006A748();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - v11) >> 4);
    uint64_t v14 = 2 * v13;
    if (2 * v13 <= v12 + 1) {
      uint64_t v14 = v12 + 1;
    }
    if (v13 >= 0x199999999999999) {
      unint64_t v15 = 0x333333333333333;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 > 0x333333333333333) {
        sub_10006A7CC();
      }
      uint64_t v16 = (char *)operator new(80 * v15);
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v17 = &v16[80 * v12];
    *((void *)v17 + 2) = v27;
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v26;
    uint64_t v18 = &v16[80 * v15];
    v26[1] = 0;
    uint64_t v27 = 0;
    v26[0] = 0;
    *(_OWORD *)(v17 + 24) = *(_OWORD *)__p;
    *((void *)v17 + 5) = v29;
    __p[1] = 0;
    uint64_t v29 = 0;
    __p[0] = 0;
    sub_100AD381C((uint64_t)(v17 + 48), (uint64_t)v30);
    uint64_t v10 = v17 + 80;
    __int16 v20 = (char *)a1[29];
    uint64_t v19 = (char *)a1[30];
    if (v19 == v20)
    {
      a1[29] = v17;
      a1[30] = v10;
      a1[31] = v18;
    }
    else
    {
      uint64_t v21 = 0;
      do
      {
        unint64_t v22 = &v17[v21];
        BOOL v23 = &v19[v21];
        long long v24 = *(_OWORD *)&v19[v21 - 80];
        *((void *)v22 - 8) = *(void *)&v19[v21 - 64];
        *((_OWORD *)v22 - 5) = v24;
        *((void *)v23 - 9) = 0;
        *((void *)v23 - 8) = 0;
        *((void *)v23 - 1sub_1001A7358((uint64_t)&a9, 0) = 0;
        *((void *)v22 - 7) = 0;
        *((void *)v22 - 6) = 0;
        *((void *)v22 - 5) = 0;
        *(_OWORD *)(v22 - 56) = *(_OWORD *)&v19[v21 - 56];
        *((void *)v22 - 5) = *(void *)&v19[v21 - 40];
        *((void *)v23 - 7) = 0;
        *((void *)v23 - 6) = 0;
        *((void *)v23 - 5) = 0;
        sub_100AD381C((uint64_t)&v17[v21 - 32], (uint64_t)&v19[v21 - 32]);
        v21 -= 80;
      }
      while (&v19[v21] != v20);
      uint64_t v19 = (char *)a1[29];
      uint64_t v25 = a1[30];
      a1[29] = &v17[v21];
      a1[30] = v10;
      a1[31] = v18;
      while ((char *)v25 != v19)
      {
        v25 -= 80;
        sub_100AD37BC(v25);
      }
    }
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    long long v9 = *(_OWORD *)v26;
    *(void *)(v8 + 16) = v27;
    *(void *)(v8 + 24) = 0;
    *(_OWORD *)unint64_t v8 = v9;
    v26[1] = 0;
    uint64_t v27 = 0;
    v26[0] = 0;
    *(void *)(v8 + 32) = 0;
    *(void *)(v8 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
    *(_OWORD *)(v8 + 24) = *(_OWORD *)__p;
    *(void *)(v8 + 4sub_1001A7358((uint64_t)&a9, 0) = v29;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v29 = 0;
    sub_100AD381C(v8 + 48, (uint64_t)v30);
    uint64_t v10 = (char *)(v8 + 80);
  }
  a1[30] = v10;
  sub_100A86C00(v30);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
  sub_100ACE240((uint64_t)a1);
}

void sub_100ACE1A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ACE1F4(uint64_t a1)
{
  sub_100A86C00((void *)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100ACE240(uint64_t a1)
{
  if (*(void *)(a1 + 104))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 240) - *(void *)(a1 + 232)) >> 4);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v3;
    uint64_t v4 = "#I Request in-flight, requests enqueued: %lu";
    uint64_t v5 = v2;
    uint32_t v6 = 12;
    goto LABEL_4;
  }
  unint64_t v7 = *(long long **)(a1 + 232);
  if (*(long long **)(a1 + 240) != v7)
  {
    memset(v39, 0, sizeof(v39));
    *(_OWORD *)unsigned int v37 = 0u;
    long long v38 = 0u;
    *(_OWORD *)std::string __dst = 0u;
    if (*((char *)v7 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)v7, *((void *)v7 + 1));
    }
    else
    {
      long long v8 = *v7;
      v37[0] = *((void **)v7 + 2);
      *(_OWORD *)std::string __dst = v8;
    }
    v37[1] = 0;
    long long v38 = 0uLL;
    sub_10005C928(&v37[1], *((const void **)v7 + 3), *((void *)v7 + 4), *((void *)v7 + 4) - *((void *)v7 + 3));
    sub_100A86C84((uint64_t)v39, (uint64_t)(v7 + 3));
    v35[0] = off_101A38D38;
    v35[1] = a1;
    int v35[3] = v35;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    sub_100637AF8(buf, "Content-Type", "application/json");
    sub_100AD389C(v45, "Accept-Encoding", "*");
    sub_1002369E0((uint64_t)&v32, (long long *)buf, 2);
    for (uint64_t i = 0; i != -12; i -= 6)
    {
      uint64_t v11 = &buf[i * 8];
      if (SHIBYTE(v45[i + 5]) < 0) {
        operator delete(*((void **)v11 + 9));
      }
      if ((char)v11[71] < 0) {
        operator delete(*((void **)v11 + 6));
      }
    }
    long long v27 = 0uLL;
    (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)buf);
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)__p);
    if (v19)
    {
      uint64_t v21 = v19[3];
      __int16 v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_25:
        if (SHIBYTE(v37[0]) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v31 = v37[0];
        }
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, void **, uint64_t *))(*(void *)v21 + 16))(&v27, v21, 3, __p, &v32);
        if (SHIBYTE(v31) < 0) {
          operator delete(__p[0]);
        }
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        (*(void (**)(void, void **))(*(void *)v27 + 56))(v27, &v37[1]);
        (*(void (**)(void, void))(*(void *)v27 + 8))(v27, *(void *)(a1 + 24));
        (*(void (**)(void, uint64_t))(*(void *)v27 + 208))(v27, 1);
        (*(void (**)(void, uint64_t))(*(void *)v27 + 120))(v27, 1);
        (*(void (**)(void, double))(*(void *)v27 + 96))(v27, 60.0);
        (*(void (**)(void, uint64_t))(*(void *)v27 + 224))(v27, 60);
        uint64_t v23 = v27;
        sub_100058DB0(buf, "com.apple.CommCenter.CellularPlanProvisioning");
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v23 + 160))(v23, buf);
        if (SHIBYTE(v41) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v24 = v27;
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 1174405120;
        uint64_t v41 = sub_100ACE9A8;
        uint64_t v42 = &unk_101A38B60;
        uint64_t v43 = a1;
        sub_100A86C84((uint64_t)&v44, (uint64_t)v35);
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v24 + 16))(v24, buf);
        v28[1] = 0;
        uint64_t v29 = 0;
        v28[0] = 0;
        (*(void (**)(void, void **))(*(void *)v27 + 40))(v27, v28);
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[0]);
        }
        sub_100ACDDB0("Req");
        sub_100A86C00(&v44);
        sub_10010C0E0((uint64_t)&v32, v33);
        long long v25 = v27;
        long long v27 = 0uLL;
        uint64_t v26 = *(std::__shared_weak_count **)(a1 + 112);
        *(_OWORD *)(a1 + 104) = v25;
        if (v26)
        {
          sub_10004D2C8(v26);
          if (*((void *)&v27 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v27 + 1));
          }
        }
        sub_100A86C00(v35);
        sub_100A86C00(v39);
        if (v37[1])
        {
          *(void **)&long long v38 = v37[1];
          operator delete(v37[1]);
        }
        if (SHIBYTE(v37[0]) < 0) {
          operator delete(__dst[0]);
        }
        return;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    __int16 v20 = 0;
    char v22 = 1;
    goto LABEL_25;
  }
  long long v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v4 = "#I All requests completed";
    uint64_t v5 = v9;
    uint32_t v6 = 2;
LABEL_4:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, buf, v6);
  }
}

void sub_100ACE868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38)
{
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  uint64_t v42 = *(std::__shared_weak_count **)(v40 - 184);
  if (v42) {
    sub_10004D2C8(v42);
  }
  sub_10010C0E0((uint64_t)&a24, a25);
  sub_100A86C00(&a27);
  sub_100ACE1F4((uint64_t)&a31);
  _Unwind_Resume(a1);
}

void sub_100ACE9A8(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    (*(void (**)(CFDataRef *__return_ptr))(*(void *)v4 + 40))(&theData);
    uint64_t v5 = theData ? sub_10008324C : 0;
    sub_100030068((const void **)&theData);
    uint64_t v4 = *a2;
    if (v5)
    {
      (*(void (**)(CFDataRef *__return_ptr))(*(void *)v4 + 40))(&theData);
      BytePtr = CFDataGetBytePtr(theData);
      sub_100030068((const void **)&theData);
      (*(void (**)(CFDataRef *__return_ptr))(*(void *)*a2 + 40))(&theData);
      size_t Length = CFDataGetLength(theData);
      sub_100030068((const void **)&theData);
      CFDataRef theData = 0;
      CFDataRef v13 = 0;
      uint64_t v14 = 0;
      sub_1001E7940(&theData, BytePtr, (uint64_t)&BytePtr[Length], Length);
      sub_100ACDDB0("Rsp");
      if (theData)
      {
        CFDataRef v13 = theData;
        operator delete(theData);
      }
      uint64_t v4 = *a2;
    }
  }
  long long v8 = (std::__shared_weak_count *)a2[1];
  uint64_t v10 = v4;
  uint64_t v11 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a1 + 64);
  if (!v9) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100ACEB50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ACEB94(uint64_t a1, int a2, char a3, char a4, uint64_t a5)
{
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 120) + 208))(&buf);
  BOOL v10 = sub_100A97A10(a2, (uint64_t *)&buf, (uint64_t)&v29);
  BOOL v11 = v10;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if (v11)
    {
LABEL_3:
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 56) + 832))(&v20);
      unint64_t v12 = std::string::append(&v20, "CreateSession", 0xDuLL);
      std::string buf = *v12;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      unsigned int v18 = 0;
      uint64_t v19 = 0;
      long long __p = 0;
      sub_10005C928(&__p, v29, (uint64_t)v30, v30 - (unsigned char *)v29);
      uint64_t v32 = a1;
      LOBYTE(v33) = a3;
      HIBYTE(v33) = a4;
      sub_100AD4044((uint64_t)v34, a5);
      int v36 = 0;
      CFDataRef v13 = operator new(0x38uLL);
      uint64_t v14 = v32;
      *CFDataRef v13 = off_101A38DB8;
      v13[1] = v14;
      *((_WORD *)v13 + 8) = v33;
      sub_100AD4940((uint64_t)(v13 + 3), (uint64_t)v34);
      int v36 = v13;
      sub_100ACDED8((void *)a1, (uint64_t)&buf, (uint64_t)&__p, (uint64_t)v35);
      sub_100A86C00(v35);
      sub_100AD40DC(v34);
      if (__p)
      {
        unsigned int v18 = __p;
        operator delete(__p);
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      {
        uint64_t v15 = (void *)v20.__r_.__value_.__r.__words[0];
LABEL_19:
        operator delete(v15);
        goto LABEL_20;
      }
      goto LABEL_20;
    }
  }
  else if (v10)
  {
    goto LABEL_3;
  }
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to encode create session", (uint8_t *)&buf, 2u);
  }
  sub_100058DB0(v26, "");
  LOBYTE(v24[0]) = 0;
  char v25 = 0;
  v21[0] = 0;
  char v23 = 0;
  sub_100ACEF40(*(void *)(a5 + 24), (uint64_t)v26, (uint64_t)v24, (uint64_t)v21, 0);
  if (v23) {
    sub_10010C0E0((uint64_t)v21, v22);
  }
  if (v25 && v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (v27 < 0)
  {
    uint64_t v15 = v26[0];
    goto LABEL_19;
  }
LABEL_20:
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_100ACEE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_100A86C00((void *)(v39 - 88));
  sub_100AD40DC(v38);
  if (__p) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a18 < 0) {
    operator delete(a13);
  }
  uint64_t v41 = *(void **)(v39 - 160);
  if (v41)
  {
    *(void *)(v39 - 152) = v41;
    operator delete(v41);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ACEF40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  char v6 = a5;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, a3, a4, &v6);
}

void sub_100ACEF90(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        char v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I CarrierListWifiTimer fired!", v10, 2u);
        }
        uint64_t v7 = *(void *)(v3 + 136);
        *(void *)(v3 + 136) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        long long v8 = (capabilities::ct *)(*(uint64_t (**)(void, double))(**(void **)(v3 + 88) + 88))(*(void *)(v3 + 88), 0.0);
        if (*(unsigned char *)(v3 + 280))
        {
          int v9 = capabilities::ct::defaultVinylCardTypeToGSMA(v8);
          v11[3] = 0;
          sub_100ACF104(v3, v9 ^ 1, (uint64_t)v11);
          sub_100313790(v11);
        }
        else
        {
          *(unsigned char *)(v3 + 281) = 1;
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100ACF0E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100313790((uint64_t *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100ACF104(uint64_t a1, int a2, uint64_t a3)
{
  if ((capabilities::ct::supportsSequoia((capabilities::ct *)a1) & 1) == 0)
  {
    if (!*(void *)(a3 + 24)) {
      return;
    }
    uint64_t v21 = 0;
    sub_10031F910(a3, (uint64_t)&v21, 0);
    long long v8 = (const void **)&v21;
    goto LABEL_17;
  }
  if (*(unsigned char *)(a1 + 283) && *(unsigned char *)(a1 + 282))
  {
    char v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E fetch carrier items is blocked : regulatory restriction active", (uint8_t *)&buf, 2u);
    }
    if (*(void *)(a3 + 24))
    {
      uint64_t v20 = 0;
      char v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 848))(*(void *)(a1 + 56));
      sub_10031F910(a3, (uint64_t)&v20, v7);
      long long v8 = (const void **)&v20;
LABEL_17:
      sub_100044D00(v8);
    }
  }
  else
  {
    sub_100058DB0(&buf, "GetCarrierOptions");
    int v9 = sub_100046F68(a1 + 160, (void **)&buf);
    if (v19 < 0) {
      operator delete((void *)buf);
    }
    if ((void **)(a1 + 168) == v9)
    {
      if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 840))(*(void *)(a1 + 56)))
      {
        sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BC8);
        long long buf = 0uLL;
        sub_100AD03C4(&buf, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
        uint64_t v22 = a1;
        char v23 = a2;
        BOOL v11 = (std::__shared_weak_count *)*((void *)&buf + 1);
        long long v24 = buf;
        if (*((void *)&buf + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
        }
        sub_100349184((uint64_t)v25, a3);
        char v27 = 0;
        unint64_t v12 = (char *)operator new(0x48uLL);
        uint64_t v13 = v22;
        *(void *)unint64_t v12 = off_101A39198;
        *((void *)v12 + 1) = v13;
        uint8_t v12[16] = v23;
        *(_OWORD *)(v12 + 24) = v24;
        long long v24 = 0uLL;
        sub_100349184((uint64_t)(v12 + 40), (uint64_t)v25);
        char v27 = v12;
        sub_100ACEB94(a1, a2, 1, 0, (uint64_t)v26);
        sub_100AD40DC(v26);
        sub_100313790(v25);
        if (*((void *)&v24 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v24 + 1));
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      else
      {
        uint64_t v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Missing location", (uint8_t *)&buf, 2u);
        }
        uint64_t v15 = *(void *)(a1 + 88);
        uint64_t v16 = 0;
        (*(void (**)(uint64_t, const void **, double))(*(void *)v15 + 72))(v15, &v16, 0.0);
        sub_100044D00(&v16);
        sub_10031F4D0((uint64_t)v28, a3);
        sub_100AD0BE4(a1, 12, (uint64_t)v28);
        sub_100313790(v28);
      }
    }
    else
    {
      BOOL v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&buf, 2u);
      }
      if (*(void *)(a3 + 24))
      {
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 24))(&v17);
        sub_10031F910(a3, (uint64_t)&v17, 13);
        long long v8 = (const void **)&v17;
        goto LABEL_17;
      }
    }
  }
}

void sub_100ACF4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  sub_100AD40DC(&a33);
  sub_100AD0DEC((uint64_t)&a23);
  if (v33) {
    sub_10004D2C8(v33);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ACF568(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_1001A7358((uint64_t)&a9, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ACF584(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

const void **sub_100ACF594(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  uint64_t v3 = 0;
  (*(void (**)(uint64_t, const void **, double))(*(void *)v1 + 72))(v1, &v3, 0.0);
  return sub_100044D00(&v3);
}

void sub_100ACF5F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100ACF608(uint64_t result)
{
  if (*(char *)(result + 231) < 0)
  {
    **(unsigned char **)(result + 208) = 0;
    *(void *)(result + 216) = 0;
  }
  else
  {
    *(unsigned char *)(result + 208) = 0;
    *(unsigned char *)(result + 231) = 0;
  }
  if (*(char *)(result + 207) < 0)
  {
    **(unsigned char **)(result + 184) = 0;
    *(void *)(result + 192) = 0;
  }
  else
  {
    *(unsigned char *)(result + 184) = 0;
    *(unsigned char *)(result + 207) = 0;
  }
  return result;
}

uint64_t sub_100ACF64C(uint64_t result)
{
  *(void *)(result + 264) = 0;
  return result;
}

capabilities::ct *sub_100ACF654(capabilities::ct *result, int a2, int a3)
{
  uint64_t v3 = (uint64_t)result;
  if (a2)
  {
    char v4 = a3;
    if (*((unsigned char *)result + 280)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = a3 == 0;
    }
    if (!v5 && *((unsigned char *)result + 281))
    {
      int v6 = capabilities::ct::defaultVinylCardTypeToGSMA(result);
      CFDictionaryRef v16[3] = 0;
      sub_100ACF104(v3, v6 ^ 1, (uint64_t)v16);
      sub_100313790(v16);
    }
    if (*(unsigned char *)(v3 + 256))
    {
      (*(void (**)(void **__return_ptr))(**(void **)(v3 + 88) + 40))(__p);
      sub_100ACF910(v3, (uint64_t)__p);
    }
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(v3 + 88) + 152))(*(void *)(v3 + 88));
    if ((unint64_t)(v7 - 1) <= 3)
    {
      long long v8 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v15 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retry provisioning indication - [%lu]", buf, 0xCu);
      }
      v13[0] = off_101A38EB8;
      v13[3] = v13;
      sub_100ACFA5C(v3, 1, (uint64_t)v13);
      sub_100060644(v13);
    }
    id result = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(v3 + 88) + 184))(*(void *)(v3 + 88));
    int v9 = result;
    if ((unint64_t)result - 1 <= 3)
    {
      BOOL v10 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v15 = (uint64_t)v9;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Retry Install Replace Operation Result - [%lu]", buf, 0xCu);
      }
      v12[0] = off_101A38F38;
      v12[1] = v3;
      void v12[3] = v12;
      sub_100ACFCC8(v3, (uint64_t)v12);
      id result = (capabilities::ct *)sub_100060644(v12);
    }
  }
  else
  {
    char v4 = 0;
  }
  *(unsigned char *)(v3 + 28sub_1001A7358((uint64_t)&a9, 0) = v4;
  return result;
}

void sub_100ACF8C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  sub_100313790((void *)(v20 - 72));
  _Unwind_Resume(a1);
}

void sub_100ACF910(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100ACFA5C(uint64_t a1, char a2, uint64_t a3)
{
  *(void *)(a1 + 40sub_1001A7358((uint64_t)&a9, 0) = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 152))(*(void *)(a1 + 88));
  sub_100058DB0(&__p, "ProvisioningActionIndication");
  int v6 = sub_100046F68(a1 + 160, (void **)&__p);
  if (v12 < 0) {
    operator delete((void *)__p);
  }
  if ((void **)(a1 + 168) == v6)
  {
    sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BD8);
    long long __p = 0uLL;
    sub_100AD03C4(&__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
    uint64_t v13 = a1;
    char v14 = a2;
    long long v8 = (std::__shared_weak_count *)*((void *)&__p + 1);
    long long v15 = __p;
    if (*((void *)&__p + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100023950((uint64_t)v16, a3);
    unsigned int v18 = 0;
    int v9 = (char *)operator new(0x48uLL);
    uint64_t v10 = v13;
    *(void *)int v9 = off_101A39398;
    *((void *)v9 + 1) = v10;
    uint8_t v9[16] = v14;
    *(_OWORD *)(v9 + 24) = v15;
    long long v15 = 0uLL;
    sub_100023950((uint64_t)(v9 + 40), (uint64_t)v16);
    unsigned int v18 = v9;
    sub_100ACEB94(a1, 0, 0, 0, (uint64_t)v17);
    sub_100AD40DC(v17);
    sub_100060644(v16);
    if (*((void *)&v15 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "ESIM notification Outstanding request", (uint8_t *)&__p, 2u);
    }
    if (*(void *)(a3 + 24)) {
      sub_1000607A8(a3, 0);
    }
  }
}

void sub_100ACFC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  sub_100AD40DC(&a23);
  sub_100AD1BE0((uint64_t)&a15);
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

void sub_100ACFCC8(uint64_t a1, uint64_t a2)
{
  if (sub_100AD12E0(a1))
  {
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 88) + 168))(__p);
    sub_1003DD450((void **)(a1 + 408));
    *(_OWORD *)(a1 + 408) = *(_OWORD *)__p;
    *(void *)(a1 + 424) = v11;
    __p[1] = 0;
    uint64_t v11 = 0;
    __p[0] = 0;
    char v12 = __p;
    sub_10016A9A4(&v12);
    sub_100058DB0(__p, "notifyEventStatus");
    char v4 = sub_100046F68(a1 + 160, __p);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
    if ((void **)(a1 + 168) == v4)
    {
      sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BE0);
      __p[0] = 0;
      __p[1] = 0;
      sub_100AD03C4(__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
      long long v8 = (std::__shared_weak_count *)__p[1];
      *(void *)&long long v13 = a1;
      *((void **)&v13 + 1) = __p[0];
      char v14 = (std::__shared_weak_count *)__p[1];
      if (__p[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
      }
      sub_100023950((uint64_t)v15, a2);
      uint64_t v17 = 0;
      int v9 = (char *)operator new(0x40uLL);
      *(void *)int v9 = off_101A39498;
      *(_OWORD *)(v9 + 8) = v13;
      *((void *)v9 + 3) = v14;
      *((void *)&v13 + 1) = 0;
      char v14 = 0;
      sub_100023950((uint64_t)(v9 + 32), (uint64_t)v15);
      uint64_t v17 = v9;
      sub_100ACEB94(a1, 0, 0, 1, (uint64_t)v16);
      sub_100AD40DC(v16);
      sub_100060644(v15);
      if (v14) {
        sub_10004D2C8(v14);
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
    }
    else
    {
      BOOL v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "NotifyEventStatus notification Outstanding request", (uint8_t *)__p, 2u);
      }
      if (*(void *)(a2 + 24)) {
LABEL_8:
      }
        sub_1000607A8(a2, 0);
    }
  }
  else
  {
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No Install Replace Operation Result pending", (uint8_t *)__p, 2u);
    }
    uint64_t v7 = *(void *)(a1 + 88);
    __p[0] = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v7 + 176))(v7, __p);
    if (*(void *)(a2 + 24)) {
      goto LABEL_8;
    }
  }
}

void sub_100ACFF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  sub_100AD40DC(&a23);
  sub_100AD1C18((uint64_t)&a16);
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

const void **sub_100ACFFEC(const void **result, __int16 a2)
{
  *((_WORD *)result + 141) = a2;
  if ((a2 & 0xFF00) != 0)
  {
    uint64_t v2 = (uint64_t)result;
    id result = (const void **)capabilities::ct::supportsSequoia((capabilities::ct *)result);
    if (result)
    {
      if (!*(unsigned char *)(v2 + 283)) {
        sub_10016C840();
      }
      if (*(unsigned char *)(v2 + 282))
      {
        return sub_100ACF594(v2);
      }
      else
      {
        int v3 = capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)result);
        void v4[3] = 0;
        sub_100ACF104(v2, v3 ^ 1, (uint64_t)v4);
        return (const void **)sub_100313790(v4);
      }
    }
  }
  return result;
}

void sub_100AD00C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100313790((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100AD00D8(uint64_t a1, int a2, long long **a3)
{
  if (capabilities::ct::supportsSequoia((capabilities::ct *)a1))
  {
    if (a3[1] == *a3)
    {
      int v6 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(buf) = 0;
      uint64_t v7 = "#I No iccids provided";
      goto LABEL_8;
    }
    if (CFAbsoluteTimeGetCurrent() < *(double *)(a1 + 264))
    {
      int v6 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(buf) = 0;
      uint64_t v7 = "#I No updating, too early";
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&buf, 2u);
      return;
    }
    sub_100058DB0(&buf, "GetSubscriptionDetails");
    long long v8 = sub_100046F68(a1 + 160, (void **)&buf);
    if (v16 < 0) {
      operator delete((void *)buf);
    }
    if ((void **)(a1 + 168) == v8)
    {
      sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BC0);
      long long buf = 0uLL;
      sub_100AD03C4(&buf, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
      uint64_t v13 = 0;
      long long v12 = 0uLL;
      sub_1000302C0((char *)&v12, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
      uint64_t v10 = (std::__shared_weak_count *)*((void *)&buf + 1);
      long long v14 = buf;
      if (*((void *)&buf + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
      }
      char v19 = 0;
      uint64_t v11 = (char *)operator new(0x40uLL);
      *(void *)uint64_t v11 = off_101A39008;
      *((void *)v11 + 1) = a1;
      uint8_t v11[16] = a2;
      *(_OWORD *)(v11 + 24) = v12;
      *((void *)v11 + 5) = v13;
      uint64_t v13 = 0;
      long long v12 = 0uLL;
      *((_OWORD *)v11 + 3) = v14;
      long long v14 = 0uLL;
      char v19 = v11;
      sub_100ACEB94(a1, a2, 0, 0, (uint64_t)v18);
      sub_100AD40DC(v18);
      if (*((void *)&v14 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
      }
      uint64_t v17 = (void **)&v12;
      sub_100047F64(&v17);
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
    else
    {
      int v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&buf, 2u);
      }
    }
  }
}

void sub_100AD0368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_100AD40DC((void *)(v23 - 88));
  sub_100AD04E0((uint64_t)&a10);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100AD03C4(void *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  int v6 = operator new(0x30uLL);
  uint64_t v7 = v6;
  v6[1] = 0;
  void v6[2] = 0;
  void *v6 = off_101A38FB8;
  long long v8 = v6 + 3;
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    void v6[3] = a2;
    v6[4] = a3;
    atomic_fetch_add_explicit(&a3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *((unsigned char *)v6 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
    int v9 = std::__shared_weak_count::lock(a3);
    if (v9)
    {
      uint64_t v10 = v9;
      if (*v8) {
        *((unsigned char *)v7 + 4sub_1001A7358((uint64_t)&a9, 0) = (*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 40))(*v8, 1);
      }
      sub_10004D2C8(v10);
    }
    std::__shared_weak_count::__release_weak(a3);
  }
  else
  {
    void v6[3] = a2;
    v6[4] = 0;
    *((unsigned char *)v6 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  }
  *a1 = v8;
  a1[1] = v7;
}

void sub_100AD04AC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v3);
  shared_owners = (std::__shared_weak_count *)v1[1].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  std::__shared_weak_count::__release_weak(v2);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v6);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD04E0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v4 = (void **)(a1 + 16);
  sub_100047F64(&v4);
  return a1;
}

const void **sub_100AD0528(uint64_t a1, char a2, int a3, uint64_t a4)
{
  double Current = CFAbsoluteTimeGetCurrent();
  (*(void (**)(void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88));
  if ((a2 & 1) != 0 || Current >= v9)
  {
    sub_10031F4D0((uint64_t)v16, a4);
    sub_100ACF104(a1, a3, (uint64_t)v16);
    return (const void **)sub_100313790(v16);
  }
  else
  {
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 88) + 24))(&cf);
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v15 = cf;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sent cached carrier items: %@", buf, 0xCu);
    }
    CFTypeRef v12 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10031F910(a4, (uint64_t)&v12, 0);
    sub_100044D00(&v12);
    return sub_100044D00(&cf);
  }
}

void sub_100AD06A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AD06EC(uint64_t a1, uint64_t a2)
{
  sub_1000332B4((uint64_t)v6, a2);
  long long v8 = 0;
  int v3 = operator new(0x30uLL);
  *int v3 = off_101A39118;
  v3[1] = a1;
  sub_10003334C((uint64_t)(v3 + 2), (uint64_t)v6);
  long long v8 = v3;
  sub_100AD07E8(a1, 1, 0, v7);
  sub_10032493C(v7);
  return sub_100033230(v6);
}

void sub_100AD07BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10032493C((uint64_t *)va);
  sub_100033230(v6);
  _Unwind_Resume(a1);
}

void sub_100AD07E8(uint64_t a1, char a2, uint64_t a3, void *a4)
{
  sub_100058DB0(buf, "CheckAvailableOptions");
  long long v8 = sub_100046F68(a1 + 160, (void **)buf);
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
  if ((void **)(a1 + 168) != v8)
  {
    double v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Outstanding request", buf, 2u);
    }
    uint64_t v10 = a4[3];
    if (v10)
    {
      if (*(void *)(a1 + 336))
      {
        uint64_t v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "previous callback exist, drop current request", buf, 2u);
          uint64_t v10 = a4[3];
        }
        *(void *)long long buf = 0;
        char v27 = 0;
        uint64_t v28 = 0;
        sub_100AD1C50(v10, (uint64_t)buf, 0);
        uint64_t v29 = buf;
        sub_1000C63B8((void ***)&v29);
      }
      else
      {
        sub_100AD1CA0((void *)(a1 + 312), a4);
      }
    }
    return;
  }
  if ((a2 & 1) != 0
    || CFAbsoluteTimeGetCurrent() >= *(double *)(a1 + 272)
    || *(void *)(a1 + 296) == *(void *)(a1 + 288))
  {
    long long v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Fetch profiles info. Clearing current list.", buf, 2u);
    }
    uint64_t v16 = *(void *)(a1 + 288);
    for (uint64_t i = *(void *)(a1 + 296); i != v16; sub_1000C643C(i))
      i -= 312;
    *(void *)(a1 + 296) = v16;
    if (!*(void *)(a1 + 336)) {
      sub_100AD1CA0((void *)(a1 + 312), a4);
    }
    sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BE8);
    *(void *)long long buf = 0;
    char v27 = 0;
    sub_100AD03C4(buf, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
    char v18 = capabilities::ct::supportsSequoia(v17);
    uint64_t v20 = *(void **)buf;
    char v19 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v31 = 0;
    uint64_t v21 = operator new(0x48uLL);
    void *v21 = off_101A39598;
    v21[1] = a1;
    *((unsigned char *)v21 + 16) = a3;
    v21[3] = v20;
    uint8_t v21[4] = v19;
    v21[5] = a1;
    v21[6] = a1;
    v21[7] = a1;
    unsigned char v21[8] = a1;
    uint64_t v31 = v21;
    sub_100ACEB94(a1, 0, v18, 0, (uint64_t)v30);
    sub_100AD40DC(v30);
    if (v19) {
      goto LABEL_28;
    }
  }
  else
  {
    CFTypeRef v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Skipping check for profiles and returning current list.", buf, 2u);
    }
    uint64_t v13 = a4[3];
    if (v13)
    {
      sub_100AD1C50(v13, a1 + 288, 0);
      return;
    }
    uint64_t v22 = *(std::__shared_weak_count **)(a1 + 80);
    if (v22)
    {
      uint64_t v23 = std::__shared_weak_count::lock(v22);
      if (v23)
      {
        char v19 = v23;
        uint64_t v24 = *(void *)(a1 + 72);
        if (v24)
        {
          v25[0] = 0;
          v25[176] = 0;
          (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void))(*(void *)v24 + 16))(v24, a3, a1 + 288, v25, 0);
          sub_10030AEBC((uint64_t)v25);
        }
LABEL_28:
        sub_10004D2C8(v19);
      }
    }
  }
}

void sub_100AD0B60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030AEBC((uint64_t)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

const void **sub_100AD0BE4(uint64_t a1, int a2, uint64_t a3)
{
  sub_100058DB0(__p, "GetCarrierOptions");
  sub_1000E9358((uint64_t **)(a1 + 160), (void **)__p);
  if (v15 < 0) {
    operator delete(*(void **)__p);
  }
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 88) + 24))(&cf);
  if (*(void *)(a3 + 24))
  {
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long __p = 138412290;
      *(void *)&__p[4] = cf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sent carrier items: %@", __p, 0xCu);
    }
    CFTypeRef v12 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10031F910(a3, (uint64_t)&v12, a2);
    sub_100044D00(&v12);
  }
  if (!a2)
  {
    sub_100ACD92C(a1, 0, 0);
    long long v8 = *(std::__shared_weak_count **)(a1 + 80);
    if (v8)
    {
      double v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(a1 + 72);
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 96))(v11);
        }
        sub_10004D2C8(v10);
      }
    }
  }
  return sub_100044D00(&cf);
}

void sub_100AD0D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_10004D2C8(v16);
  sub_100044D00(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD0DEC(uint64_t a1)
{
  sub_100313790((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD0E24(uint64_t a1, int a2, uint64_t *a3, uint64_t a4)
{
  if (*(void *)(a4 + 24))
  {
    if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56)) & 1) == 0)
    {
      *((void *)&__p + 1) = 0;
      uint64_t v17 = 0;
      *(void *)&long long __p = (char *)&__p + 8;
      sub_100AD1240(*(void *)(a4 + 24), (uint64_t)&__p, 17);
LABEL_17:
      sub_10034964C((uint64_t)&__p, *((void **)&__p + 1));
      return;
    }
    if (*(unsigned char *)(a1 + 283) && *(unsigned char *)(a1 + 282))
    {
      long long v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E add on carrier option blocked : regulatory restriction active", (uint8_t *)&__p, 2u);
      }
      *((void *)&__p + 1) = 0;
      uint64_t v17 = 0;
      *(void *)&long long __p = (char *)&__p + 8;
      char v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 848))(*(void *)(a1 + 56));
      sub_100AD1240(*(void *)(a4 + 24), (uint64_t)&__p, v9);
      goto LABEL_17;
    }
    sub_100058DB0(&__p, "GetAddOnOptions");
    uint64_t v11 = sub_100046F68(a1 + 160, (void **)&__p);
    if (SHIBYTE(v17) < 0) {
      operator delete((void *)__p);
    }
    if ((void **)(a1 + 168) != v11)
    {
      CFTypeRef v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&__p, 2u);
      }
      *((void *)&__p + 1) = 0;
      uint64_t v17 = 0;
      *(void *)&long long __p = (char *)&__p + 8;
      sub_100AD1240(*(void *)(a4 + 24), (uint64_t)&__p, 13);
      goto LABEL_17;
    }
    sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BD0);
    long long __p = 0uLL;
    sub_100AD03C4(&__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
    uint64_t v19 = a1;
    char v20 = a2;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v21 = 0;
    sub_10030B4A4(&v21, *a3, a3[1], (a3[1] - *a3) >> 7);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)&__p + 1);
    long long v24 = __p;
    if (*((void *)&__p + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_100AD721C((uint64_t)v25, a4);
    char v27 = 0;
    long long v14 = operator new(0x60uLL);
    uint64_t v15 = v19;
    void *v14 = off_101A39298;
    v14[1] = v15;
    *((unsigned char *)v14 + 16) = v20;
    v14[4] = 0;
    v14[5] = 0;
    v14[3] = 0;
    sub_10030B4A4(v14 + 3, v21, v22, (v22 - v21) >> 7);
    *((_OWORD *)v14 + 3) = v24;
    long long v24 = 0uLL;
    sub_100AD721C((uint64_t)(v14 + 8), (uint64_t)v25);
    char v27 = v14;
    sub_100ACEB94(a1, a2, 0, 0, (uint64_t)v26);
    sub_100AD40DC(v26);
    sub_10034AB3C(v25);
    if (*((void *)&v24 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v24 + 1));
    }
    char v18 = (void **)&v21;
    sub_10030B640(&v18);
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "no callback", (uint8_t *)&__p, 2u);
    }
  }
}

void sub_100AD11B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  sub_100AD40DC((void *)(v17 - 104));
  sub_100AD1290((uint64_t)&a16);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD1240(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t sub_100AD1290(uint64_t a1)
{
  sub_10034AB3C((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v4 = (void **)(a1 + 16);
  sub_10030B640(&v4);
  return a1;
}

BOOL sub_100AD12E0(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 88) + 168))(&v3);
  sub_1003DD450((void **)(a1 + 408));
  *(_OWORD *)(a1 + 408) = v3;
  *(void *)(a1 + 424) = v4;
  uint64_t v4 = 0;
  long long v3 = 0uLL;
  BOOL v5 = (void **)&v3;
  sub_10016A9A4(&v5);
  return *(void *)(a1 + 416) != *(void *)(a1 + 408);
}

void sub_100AD137C(void *a1, int __val, int a3, const std::string *a4, const std::string *a5)
{
  *(_OWORD *)uint64_t v46 = 0u;
  long long v47 = 0u;
  *(_OWORD *)&v44[16] = 0u;
  *(_OWORD *)uint64_t v45 = 0u;
  *(_OWORD *)uint64_t v44 = 0u;
  std::to_string(&v48, __val);
  *(_OWORD *)long long __p = *(_OWORD *)&v48.__r_.__value_.__l.__data_;
  *(void *)uint64_t v44 = *((void *)&v48.__r_.__value_.__l + 2);
  std::to_string(&v48, a3);
  char v9 = &v44[8];
  *(std::string *)&v44[8] = v48;
  uint64_t v10 = v45;
  std::string::operator=((std::string *)v45, a4);
  uint64_t v11 = &v46[1];
  std::string::operator=((std::string *)&v46[1], a5);
  uint64_t v13 = a1[51];
  CFTypeRef v12 = (char *)a1[52];
  uint64_t v14 = v13;
  if ((char *)v13 != v12)
  {
    if (v44[7] >= 0) {
      uint64_t v15 = (void *)v44[7];
    }
    else {
      uint64_t v15 = __p[1];
    }
    if (v44[7] >= 0) {
      uint64_t v16 = __p;
    }
    else {
      uint64_t v16 = (void **)__p[0];
    }
    if (v44[31] >= 0) {
      uint64_t v17 = v44[31];
    }
    else {
      uint64_t v17 = *(void *)&v44[16];
    }
    if (v44[31] < 0) {
      char v9 = *(unsigned char **)&v44[8];
    }
    if (SHIBYTE(v46[0]) >= 0) {
      char v18 = (void *)HIBYTE(v46[0]);
    }
    else {
      char v18 = v45[1];
    }
    if (SHIBYTE(v46[0]) < 0) {
      uint64_t v10 = (void **)v45[0];
    }
    uint64_t v19 = HIBYTE(v47);
    if (v47 < 0) {
      uint64_t v19 = v47;
    }
    uint64_t v40 = v19;
    uint64_t v41 = v18;
    if (v47 < 0) {
      uint64_t v11 = (void **)v46[1];
    }
    uint64_t v14 = a1[51];
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 *)(v14 + 23);
      if ((v20 & 0x80u) == 0) {
        uint64_t v21 = (void *)*(unsigned __int8 *)(v14 + 23);
      }
      else {
        uint64_t v21 = *(void **)(v14 + 8);
      }
      if (v21 != v15) {
        goto LABEL_67;
      }
      if ((v20 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v14, v16, *(void *)(v14 + 8))) {
          goto LABEL_67;
        }
      }
      else if (*(unsigned char *)(v14 + 23))
      {
        uint64_t v22 = 0;
        while (*(unsigned __int8 *)(v14 + v22) == *((unsigned __int8 *)v16 + v22))
        {
          if (v20 == ++v22) {
            goto LABEL_34;
          }
        }
        goto LABEL_67;
      }
LABEL_34:
      uint64_t v23 = *(unsigned __int8 *)(v14 + 47);
      if ((v23 & 0x80u) == 0) {
        uint64_t v24 = *(unsigned __int8 *)(v14 + 47);
      }
      else {
        uint64_t v24 = *(void *)(v14 + 32);
      }
      if (v24 != v17) {
        goto LABEL_67;
      }
      if ((v23 & 0x80) != 0)
      {
        if (memcmp(*(const void **)(v14 + 24), v9, *(void *)(v14 + 32))) {
          goto LABEL_67;
        }
      }
      else if (*(unsigned char *)(v14 + 47))
      {
        uint64_t v25 = 0;
        while (*(unsigned __int8 *)(v14 + v25 + 24) == v9[v25])
        {
          if (v23 == ++v25) {
            goto LABEL_45;
          }
        }
        goto LABEL_67;
      }
LABEL_45:
      uint64_t v26 = *(unsigned __int8 *)(v14 + 71);
      if ((v26 & 0x80u) == 0) {
        char v27 = (void *)*(unsigned __int8 *)(v14 + 71);
      }
      else {
        char v27 = *(void **)(v14 + 56);
      }
      if (v27 == v41)
      {
        if ((v26 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v14 + 48), v10, *(void *)(v14 + 56)))
          {
LABEL_56:
            uint64_t v29 = *(unsigned __int8 *)(v14 + 95);
            if ((v29 & 0x80u) == 0) {
              uint64_t v30 = *(unsigned __int8 *)(v14 + 95);
            }
            else {
              uint64_t v30 = *(void *)(v14 + 80);
            }
            if (v30 == v40)
            {
              if ((v29 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v14 + 72), v11, *(void *)(v14 + 80))) {
                  break;
                }
              }
              else
              {
                if (!*(unsigned char *)(v14 + 95)) {
                  break;
                }
                uint64_t v31 = 0;
                while (*(unsigned __int8 *)(v14 + v31 + 72) == *((unsigned __int8 *)v11 + v31))
                {
                  if (v29 == ++v31) {
                    goto LABEL_69;
                  }
                }
              }
            }
          }
        }
        else
        {
          if (!*(unsigned char *)(v14 + 71)) {
            goto LABEL_56;
          }
          uint64_t v28 = 0;
          while (*(unsigned __int8 *)(v14 + v28 + 48) == *((unsigned __int8 *)v10 + v28))
          {
            if (v26 == ++v28) {
              goto LABEL_56;
            }
          }
        }
      }
LABEL_67:
      v14 += 96;
      if ((char *)v14 == v12) {
        goto LABEL_70;
      }
    }
  }
LABEL_69:
  if ((char *)v14 == v12)
  {
LABEL_70:
    unint64_t v32 = a1[53];
    if ((unint64_t)v12 >= v32)
    {
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v12[-v13] >> 5);
      unint64_t v34 = v33 + 1;
      if (v33 + 1 > 0x2AAAAAAAAAAAAAALL) {
        sub_10006A748();
      }
      unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v32 - v13) >> 5);
      if (2 * v35 > v34) {
        unint64_t v34 = 2 * v35;
      }
      if (v35 >= 0x155555555555555) {
        unint64_t v36 = 0x2AAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v36 = v34;
      }
      CFIndex v50 = a1 + 53;
      if (v36) {
        unsigned int v37 = (char *)sub_100157260((uint64_t)(a1 + 53), v36);
      }
      else {
        unsigned int v37 = 0;
      }
      v48.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
      v48.__r_.__value_.__l.__size_ = (std::string::size_type)&v37[96 * v33];
      v48.__r_.__value_.__r.__words[2] = v48.__r_.__value_.__l.__size_;
      CFTypeID v49 = &v37[96 * v36];
      sub_100AD39FC((char *)v48.__r_.__value_.__l.__size_, (long long *)__p);
      v48.__r_.__value_.__r.__words[2] += 96;
      sub_10016A810(a1 + 51, &v48);
      CFTypeRef v12 = (char *)a1[52];
      sub_10016A954((uint64_t)&v48);
    }
    else
    {
      sub_100AD39FC(v12, (long long *)__p);
      v12 += 96;
      a1[52] = v12;
    }
    a1[52] = v12;
    uint64_t v13 = a1[51];
  }
  uint64_t v38 = a1[11];
  memset(v42, 0, sizeof(v42));
  sub_100AD38F0(v42, v13, (uint64_t)v12, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v12[-v13] >> 5));
  (*(void (**)(uint64_t, void **))(*(void *)v38 + 160))(v38, v42);
  v48.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
  sub_10016A9A4((void ***)&v48);
  uint64_t v39 = a1[11];
  v48.__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(uint64_t, std::string *))(*(void *)v39 + 176))(v39, &v48);
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[1]);
  }
  if (SHIBYTE(v46[0]) < 0) {
    operator delete(v45[0]);
  }
  if ((v44[31] & 0x80000000) != 0) {
    operator delete(*(void **)&v44[8]);
  }
  if ((v44[7] & 0x80000000) != 0) {
    operator delete(__p[0]);
  }
}

void sub_100AD1830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  *(void *)(v7 + 416) = v8;
  sub_100169704((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 sub_100AD1884@<Q0>(uint64_t a1@<X0>, std::string *a2@<X8>, __n128 result@<Q0>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  long long v3 = *(long long **)(a1 + 408);
  uint64_t v4 = *(long long **)(a1 + 416);
  if (v3 != v4)
  {
    id result = 0uLL;
    do
    {
      __n128 v44 = result;
      __n128 v45 = result;
      __n128 v42 = result;
      __n128 v43 = result;
      __n128 __dst = result;
      __n128 v41 = result;
      sub_100AD39FC((char *)&__dst, v3);
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v30 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      *(_OWORD *)char v27 = 0u;
      memset(v26, 0, sizeof(v26));
      sub_10004DE24((uint64_t)v26);
      uint64_t v7 = sub_10004B96C(v26, (uint64_t)"{kIccidHashToInstall=", 21);
      if (v44.n128_i8[7] >= 0) {
        uint64_t v8 = &v43;
      }
      else {
        uint64_t v8 = (__n128 *)v43.n128_u64[0];
      }
      if (v44.n128_i8[7] >= 0) {
        uint64_t v9 = v44.n128_u8[7];
      }
      else {
        uint64_t v9 = v43.n128_i64[1];
      }
      uint64_t v10 = sub_10004B96C(v7, (uint64_t)v8, v9);
      uint64_t v11 = sub_10004B96C(v10, (uint64_t)";kEventType=", 12);
      CFTypeRef v12 = sub_10004B96C(v11, (uint64_t)"INSTALLED_AND_REMOVED", 21);
      uint64_t v13 = sub_10004B96C(v12, (uint64_t)";kEventResult=", 14);
      if (v42.n128_i8[15] >= 0) {
        uint64_t v14 = &v41.n128_i8[8];
      }
      else {
        uint64_t v14 = (__int8 *)v41.n128_u64[1];
      }
      if (v42.n128_i8[15] >= 0) {
        uint64_t v15 = v42.n128_u8[15];
      }
      else {
        uint64_t v15 = v42.n128_u64[0];
      }
      uint64_t v16 = sub_10004B96C(v13, (uint64_t)v14, v15);
      uint64_t v17 = sub_10004B96C(v16, (uint64_t)";kIccidHashToRemove=", 20);
      if (v45.n128_i8[15] >= 0) {
        char v18 = &v44.n128_i8[8];
      }
      else {
        char v18 = (__int8 *)v44.n128_u64[1];
      }
      if (v45.n128_i8[15] >= 0) {
        uint64_t v19 = v45.n128_u8[15];
      }
      else {
        uint64_t v19 = v45.n128_u64[0];
      }
      uint64_t v20 = sub_10004B96C(v17, (uint64_t)v18, v19);
      sub_10004B96C(v20, (uint64_t)"},", 2);
      sub_10004BC98((uint64_t)v26 + 8, __p);
      if ((v25 & 0x80u) == 0) {
        uint64_t v21 = __p;
      }
      else {
        uint64_t v21 = (void **)__p[0];
      }
      if ((v25 & 0x80u) == 0) {
        std::string::size_type v22 = v25;
      }
      else {
        std::string::size_type v22 = (std::string::size_type)__p[1];
      }
      std::string::append(a2, (const std::string::value_type *)v21, v22);
      if ((char)v25 < 0) {
        operator delete(__p[0]);
      }
      *(void *)&v26[0] = v5;
      *(void *)((char *)v26 + *(void *)(v5 - 24)) = v6;
      if (SHIBYTE(v28) < 0) {
        operator delete(v27[1]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (v45.n128_i8[15] < 0) {
        operator delete((void *)v44.n128_u64[1]);
      }
      if (v44.n128_i8[7] < 0) {
        operator delete((void *)v43.n128_u64[0]);
      }
      if (v42.n128_i8[15] < 0) {
        operator delete((void *)v41.n128_u64[1]);
      }
      if (v41.n128_i8[7] < 0) {
        operator delete((void *)__dst.n128_u64[0]);
      }
      v3 += 6;
      id result = 0uLL;
    }
    while (v3 != v4);
  }
  return result;
}

void sub_100AD1B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a18);
  sub_100169704(v18 - 208);
  if (*(char *)(a11 + 23) < 0) {
    operator delete(*(void **)a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD1BE0(uint64_t a1)
{
  sub_100060644((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_100AD1C18(uint64_t a1)
{
  sub_100060644((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_100AD1C50(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

void *sub_100AD1CA0(void *a1, void *a2)
{
  long long v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v7 != a1)
  {
    char v4 = v8;
    uint64_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        uint64_t v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        uint64_t v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        uint64_t v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      uint64_t v8 = v7;
    }
    else
    {
      uint64_t v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_10032493C(v7);
  return a1;
}

void sub_100AD1FA4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100AD1FB0(uint64_t a1, char a2, uint64_t a3, void *a4)
{
}

uint64_t sub_100AD1FB8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 128))();
}

uint64_t sub_100AD1FE0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 112))();
}

void sub_100AD2008(uint64_t a1, int a2, uint64_t a3)
{
  if ((capabilities::ct::supportsSequoia((capabilities::ct *)a1) & 1) == 0)
  {
    sub_100058DB0(buf, "");
    sub_100058DB0(__p, "");
    uint64_t v7 = *(void *)(a3 + 24);
    if (!v7) {
      sub_10007B600();
    }
    goto LABEL_9;
  }
  if (*(unsigned char *)(a1 + 283) && *(unsigned char *)(a1 + 282))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E request handoff blocked : regulatory restriction active", buf, 2u);
    }
    sub_100058DB0(buf, "");
    sub_100058DB0(__p, "");
    uint64_t v7 = *(void *)(a3 + 24);
    if (!v7) {
      sub_10007B600();
    }
LABEL_9:
    (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v7 + 48))(v7, buf, __p);
    if (v35 < 0) {
      operator delete(__p[0]);
    }
    if (v37.i8[15] < 0) {
      operator delete(*(void **)buf);
    }
    return;
  }
  if (*(char *)(a1 + 207) < 0)
  {
    if (!*(void *)(a1 + 192)) {
      goto LABEL_24;
    }
  }
  else if (!*(unsigned char *)(a1 + 207))
  {
    goto LABEL_24;
  }
  if (*(char *)(a1 + 231) < 0)
  {
    if (*(void *)(a1 + 216)) {
      goto LABEL_19;
    }
LABEL_24:
    unint64_t v11 = *(void *)(a1 + 352);
    unint64_t v10 = *(void *)(a1 + 360);
    if (v11 < v10)
    {
      sub_100AD3B2C(*(void *)(a1 + 352), a3);
      uint64_t v12 = v11 + 32;
      *(void *)(a1 + 352) = v11 + 32;
LABEL_48:
      *(void *)(a1 + 352) = v12;
      sub_100058DB0(buf, "RequestHandoff");
      long long v29 = sub_100046F68(a1 + 160, (void **)buf);
      if (v37.i8[15] < 0) {
        operator delete(*(void **)buf);
      }
      if ((void **)(a1 + 168) == v29)
      {
        sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BF0);
        *(void *)long long buf = 0;
        v37.i64[0] = 0;
        sub_100AD03C4(buf, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
        long long v32 = *(void **)buf;
        long long v31 = (std::__shared_weak_count *)v37.i64[0];
        if (v37.i64[0]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v37.i64[0] + 8), 1uLL, memory_order_relaxed);
        }
        __n128 v41 = 0;
        long long v33 = operator new(0x28uLL);
        *long long v33 = off_101A39698;
        v33[1] = a1;
        *((unsigned char *)v33 + 16) = a2;
        void v33[3] = v32;
        v33[4] = v31;
        __n128 v41 = v33;
        sub_100ACEB94(a1, a2, 0, 0, (uint64_t)v40);
        sub_100AD40DC(v40);
        if (v31) {
          sub_10004D2C8(v31);
        }
      }
      else
      {
        long long v30 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Outstanding request", buf, 2u);
        }
      }
      return;
    }
    uint64_t v13 = *(void *)(a1 + 344);
    uint64_t v14 = (uint64_t)(v11 - v13) >> 5;
    if ((unint64_t)(v14 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v15 = v10 - v13;
    uint64_t v16 = v15 >> 4;
    if (v15 >> 4 <= (unint64_t)(v14 + 1)) {
      uint64_t v16 = v14 + 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v17 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    uint64_t v39 = a1 + 360;
    if (v17)
    {
      if (v17 >> 59) {
        sub_10006A7CC();
      }
      uint64_t v18 = (char *)operator new(32 * v17);
    }
    else
    {
      uint64_t v18 = 0;
    }
    *(void *)long long buf = v18;
    v37.i64[0] = (uint64_t)&v18[32 * v14];
    long long v38 = &v18[32 * v17];
    sub_100AD3B2C(v37.i64[0], a3);
    uint64_t v19 = v37.i64[0];
    uint64_t v12 = v37.i64[0] + 32;
    v37.i64[1] = v37.i64[0] + 32;
    uint64_t v21 = *(void **)(a1 + 344);
    unint64_t v20 = *(void *)(a1 + 352);
    if ((void *)v20 == v21)
    {
      int64x2_t v27 = vdupq_n_s64(v20);
LABEL_47:
      *(void *)(a1 + 344) = v19;
      *(void *)(a1 + 352) = v12;
      int64x2_t v37 = v27;
      long long v28 = *(char **)(a1 + 360);
      *(void *)(a1 + 36sub_1001A7358((uint64_t)&a9, 0) = v38;
      long long v38 = v28;
      *(void *)long long buf = v27.i64[0];
      sub_100AD3BC4((uint64_t)buf);
      goto LABEL_48;
    }
    std::string::size_type v22 = (void *)(v20 - 8);
    while (1)
    {
      uint64_t v23 = v19 - 32;
      uint64_t v24 = (void *)*v22;
      if (*v22)
      {
        if (v22 - 3 == v24)
        {
          *(void *)(v19 - 8) = v23;
          (*(void (**)(void, uint64_t))(*(void *)*v22 + 24))(*v22, v23);
          goto LABEL_44;
        }
        *(void *)(v19 - 8) = v24;
        unsigned __int8 v25 = v22;
      }
      else
      {
        unsigned __int8 v25 = (void *)(v19 - 8);
      }
      *unsigned __int8 v25 = 0;
LABEL_44:
      uint64_t v26 = v22 - 3;
      v22 -= 4;
      uint64_t v19 = v23;
      if (v26 == v21)
      {
        int64x2_t v27 = *(int64x2_t *)(a1 + 344);
        uint64_t v12 = v37.i64[1];
        uint64_t v19 = v23;
        goto LABEL_47;
      }
    }
  }
  if (!*(unsigned char *)(a1 + 231)) {
    goto LABEL_24;
  }
LABEL_19:
  uint64_t v8 = *(void *)(a3 + 24);
  if (!v8) {
    sub_10007B600();
  }
  uint64_t v9 = *(void (**)(void))(*(void *)v8 + 48);

  v9();
}

void sub_100AD24D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  sub_100AD40DC(&a24);
  if (v24) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(a1);
}

void sub_100AD257C(uint64_t a1, long long *a2, uint64_t a3, long long *a4, uint64_t a5)
{
  sub_100058DB0(&__p, "ProfileEligibilityCheck");
  unint64_t v10 = sub_100046F68(a1 + 160, (void **)&__p);
  if (v18 < 0) {
    operator delete((void *)__p);
  }
  if ((void **)(a1 + 168) == v10)
  {
    sub_100AD548C((uint64_t **)(a1 + 160), off_101A38BF8);
    long long __p = 0uLL;
    sub_100AD03C4(&__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
    uint64_t v19 = a1;
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&v20, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v20 = *a2;
      uint64_t v21 = *((void *)a2 + 2);
    }
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v23 = 0;
    sub_10005C928(v22, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    if (*((char *)a4 + 23) < 0)
    {
      sub_10004FC84(&v24, *(void **)a4, *((void *)a4 + 1));
    }
    else
    {
      long long v24 = *a4;
      uint64_t v25 = *((void *)a4 + 2);
    }
    uint64_t v12 = (std::__shared_weak_count *)*((void *)&__p + 1);
    long long v26 = __p;
    if (*((void *)&__p + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_1000DFC90((uint64_t)v27, a5);
    long long v29 = 0;
    uint64_t v13 = operator new(0x88uLL);
    uint64_t v14 = v13;
    uint64_t v15 = v19;
    *uint64_t v13 = off_101A39798;
    v13[1] = v15;
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84((unsigned char *)v13 + 16, (void *)v20, *((unint64_t *)&v20 + 1));
    }
    else
    {
      *((_OWORD *)v13 + 1) = v20;
      void v13[4] = v21;
    }
    *(_OWORD *)(v14 + 5) = *(_OWORD *)v22;
    v14[7] = v23;
    v22[1] = 0;
    uint64_t v23 = 0;
    v22[0] = 0;
    uint64_t v16 = v14 + 8;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(v16, (void *)v24, *((unint64_t *)&v24 + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v16 = v24;
      v14[10] = v25;
    }
    *(_OWORD *)(v14 + 11) = v26;
    long long v26 = 0uLL;
    sub_100023950((uint64_t)(v14 + 13), (uint64_t)v27);
    long long v29 = v14;
    sub_100ACEB94(a1, 0, 0, 0, (uint64_t)v28);
    sub_100AD40DC(v28);
    sub_100060644(v27);
    if (*((void *)&v26 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v26 + 1));
    }
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)v24);
    }
    if (v22[0])
    {
      v22[1] = v22[0];
      operator delete(v22[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)v20);
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  else
  {
    unint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&__p, 2u);
    }
    sub_1000607A8(a5, 0);
  }
}

void sub_100AD2888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, std::__shared_weak_count *a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32)
{
  char v35 = *(void **)(v32 + 40);
  if (v35)
  {
    *(void *)(v32 + 48) = v35;
    operator delete(v35);
  }
  if (*(char *)(v32 + 39) < 0) {
    operator delete(*v33);
  }
  operator delete((void *)v32);
  sub_100AD296C((uint64_t)&a15);
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD296C(uint64_t a1)
{
  sub_100060644((void *)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  long long v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100AD29D4(uint64_t a1, uint64_t *a2, long long *a3, long long *a4, uint64_t a5)
{
  sub_10033D1E4((uint64_t)&__p, a5);
  uint64_t v9 = a1 + 368;
  if (&__p != (long long *)(a1 + 368))
  {
    unint64_t v10 = p_p;
    uint64_t v11 = *(void *)(a1 + 392);
    if (p_p == &__p)
    {
      if (v11 == v9)
      {
        memset(v30, 0, sizeof(v30));
        (*(void (**)(long long *, void ***))(__p + 24))(&__p, v30);
        (*(void (**)(long long *))(*(void *)p_p + 32))(p_p);
        p_p = 0;
        (*(void (**)(void, long long *))(**(void **)(a1 + 392) + 24))(*(void *)(a1 + 392), &__p);
        (*(void (**)(void))(**(void **)(a1 + 392) + 32))(*(void *)(a1 + 392));
        *(void *)(a1 + 392) = 0;
        p_p = &__p;
        (*((void (**)(void ***, uint64_t))v30[0] + 3))(v30, a1 + 368);
        (*((void (**)(void ***))v30[0] + 4))(v30);
      }
      else
      {
        (*(void (**)(long long *, uint64_t))(__p + 24))(&__p, a1 + 368);
        (*(void (**)(long long *))(*(void *)p_p + 32))(p_p);
        p_p = *(long long **)(a1 + 392);
      }
      *(void *)(a1 + 392) = v9;
    }
    else if (v11 == v9)
    {
      (*(void (**)(uint64_t, long long *))(*(void *)v9 + 24))(a1 + 368, &__p);
      (*(void (**)(void))(**(void **)(a1 + 392) + 32))(*(void *)(a1 + 392));
      *(void *)(a1 + 392) = p_p;
      p_p = &__p;
    }
    else
    {
      p_p = *(long long **)(a1 + 392);
      *(void *)(a1 + 392) = v10;
    }
  }
  sub_10030DD28(&__p);
  sub_100058DB0(&__p, "PreFlightEligibilityCheck");
  uint64_t v12 = sub_100046F68(a1 + 160, (void **)&__p);
  if (v28 < 0) {
    operator delete((void *)__p);
  }
  if ((void **)(a1 + 168) == v12)
  {
    sub_100AD548C((uint64_t **)(a1 + 160), off_101A38C00);
    long long __p = 0uLL;
    sub_100AD03C4(&__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(&v18, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long v18 = *a3;
      uint64_t v19 = *((void *)a3 + 2);
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    sub_10030B4A4(&v20, *a2, a2[1], (a2[1] - *a2) >> 7);
    if (*((char *)a4 + 23) < 0)
    {
      sub_10004FC84(&v22, *(void **)a4, *((void *)a4 + 1));
    }
    else
    {
      long long v22 = *a4;
      uint64_t v23 = *((void *)a4 + 2);
    }
    uint64_t v14 = (std::__shared_weak_count *)*((void *)&__p + 1);
    long long v24 = __p;
    if (*((void *)&__p + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 1uLL, memory_order_relaxed);
    }
    long long v26 = 0;
    uint64_t v15 = operator new(0x68uLL);
    uint64_t v16 = v15;
    void *v15 = off_101A39898;
    v15[1] = a1;
    if (SHIBYTE(v19) < 0)
    {
      sub_10004FC84((unsigned char *)v15 + 16, (void *)v18, *((unint64_t *)&v18 + 1));
    }
    else
    {
      *((_OWORD *)v15 + 1) = v18;
      void v15[4] = v19;
    }
    *(_OWORD *)(v16 + 5) = v20;
    v16[7] = v21;
    uint64_t v21 = 0;
    long long v20 = 0uLL;
    unint64_t v17 = v16 + 8;
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(v17, (void *)v22, *((unint64_t *)&v22 + 1));
    }
    else
    {
      *(_OWORD *)unint64_t v17 = v22;
      v16[10] = v23;
    }
    *(_OWORD *)(v16 + 11) = v24;
    long long v24 = 0uLL;
    long long v26 = v16;
    sub_100ACEB94(a1, 0, 0, 0, (uint64_t)v25);
    sub_100AD40DC(v25);
    if (*((void *)&v24 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v24 + 1));
    }
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)v22);
    }
    v30[0] = (void **)&v20;
    sub_10030B640(v30);
    if (SHIBYTE(v19) < 0) {
      operator delete((void *)v18);
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&__p, 2u);
    }
  }
}

void sub_100AD2EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,std::__shared_weak_count *a29,int a30,__int16 a31,char a32,char a33)
{
  *(void *)(v36 - 96) = v34;
  sub_10030B640((void ***)(v36 - 96));
  if (v33[39] < 0) {
    operator delete(*v35);
  }
  operator delete(v33);
  sub_100AD2FA8((uint64_t)&a9);
  if (a29) {
    sub_10004D2C8(a29);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD2FA8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  char v4 = (void **)(a1 + 32);
  sub_10030B640(&v4);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100AD3010(uint64_t a1, char a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    sub_100058DB0(&__p, "GetCarrierSetup");
    uint64_t v6 = sub_100046F68(a1 + 160, (void **)&__p);
    if (v15 < 0) {
      operator delete((void *)__p);
    }
    if ((void **)(a1 + 168) == v6)
    {
      sub_100AD548C((uint64_t **)(a1 + 160), &off_101A38C08);
      long long __p = 0uLL;
      sub_100AD03C4(&__p, *(void *)(a1 + 72), *(std::__shared_weak_count **)(a1 + 80));
      uint64_t v16 = a1;
      char v17 = a2;
      uint64_t v9 = (std::__shared_weak_count *)*((void *)&__p + 1);
      long long v18 = __p;
      if (*((void *)&__p + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 1uLL, memory_order_relaxed);
      }
      sub_100ADE414((uint64_t)v19, a3);
      uint64_t v21 = 0;
      unint64_t v10 = (char *)operator new(0x48uLL);
      uint64_t v11 = v16;
      *(void *)unint64_t v10 = off_101A39998;
      *((void *)v10 + 1) = v11;
      uint8_t v10[16] = v17;
      *(_OWORD *)(v10 + 24) = v18;
      long long v18 = 0uLL;
      sub_100ADEC24((uint64_t)(v10 + 40), (uint64_t)v19);
      uint64_t v21 = v10;
      sub_100ACEB94(a1, 0, 0, 0, (uint64_t)v20);
      sub_100AD40DC(v20);
      sub_100337EF8(v19);
      if (*((void *)&v18 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
    else
    {
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Outstanding request", (uint8_t *)&__p, 2u);
      }
      uint64_t v13 = 0;
      memset(v12, 0, sizeof(v12));
      sub_100AD32E8(*(void *)(a3 + 24), (uint64_t)&v13, 13);
      *(void *)&long long __p = v12;
      sub_10030A774((void ***)&__p);
      sub_100044D00(&v13);
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No callback", (uint8_t *)&__p, 2u);
    }
  }
}

void sub_100AD3268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  sub_100AD40DC((void *)(v23 - 88));
  sub_100AD3338((uint64_t)&a19);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD32E8(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t sub_100AD3338(uint64_t a1)
{
  sub_100337EF8((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD3370(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 280))
  {
    unint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 152))(*(void *)(a1 + 88));
    if (v2 >= 5)
    {
      unint64_t v3 = v2;
      char v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        unint64_t v11 = v3;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Retry sending provisioning indication by user action - [%lu]", buf, 0xCu);
      }
      v9[0] = off_101A39A98;
      void v9[3] = v9;
      sub_100ACFA5C(a1, 1, (uint64_t)v9);
      sub_100060644(v9);
    }
    unint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 184))(*(void *)(a1 + 88));
    if (v5 >= 5)
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        unint64_t v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Retry sending Install Replace Operation Result by user action - [%lu]", buf, 0xCu);
      }
      v8[0] = off_101A39B18;
      v8[1] = a1;
      v8[3] = v8;
      sub_100ACFCC8(a1, (uint64_t)v8);
      sub_100060644(v8);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No data connectivity", buf, 2u);
    }
  }
}

void sub_100AD3584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100AD35AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 288);
  for (uint64_t i = *(void *)(a1 + 296); i != v3; sub_1000C643C(i))
    i -= 312;
  *(void *)(a1 + 296) = v3;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v11);
  Registry::getNotificationSenderFactory(&v13, v11);
  uint64_t v4 = v13;
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v7);
  Registry::getTimerService(&v9, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t))(*(void *)v4 + 160))(&v15, v4, &v9, a1 + 24);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v5 = v15;
  if (v15)
  {
    sub_100A9F534((uint64_t **)(a1 + 288), &v6);
    (*(void (**)(uint64_t, const void **))(*(void *)v5 + 48))(v5, &v6);
    sub_100044D00(&v6);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100AD3740(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100AD37B4(uint64_t a1, uint64_t a2)
{
}

void sub_100AD37BC(uint64_t a1)
{
  sub_100A86C00((void *)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t sub_100AD381C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100AD389C(void *a1, char *a2, char *a3)
{
  uint64_t v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_100AD38D4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AD38F0(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10019FF04(result, a4);
    id result = (void *)sub_100AD3978((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100AD3958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10016A9A4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD3978(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100AD39FC((char *)(a4 + v7), (long long *)(a2 + v7));
      v7 += 96;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100AD39D8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 96;
    do
    {
      sub_10016A8DC(v4 + v2);
      v2 -= 96;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100AD39FC(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__n128 __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  uint64_t v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return __dst;
}

void sub_100AD3AE0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD3B2C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100AD3BC4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_100333DB8((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100AD3C14(uint64_t *a1)
{
  qword_101B0FD40 = *a1;
  if (qword_101B0FD40) {
    operator new();
  }
  uint64_t result = 0;
  qword_101B0FD48 = 0;
  *a1 = 0;
  return result;
}

void sub_100AD3C98(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AD3CD0(uint64_t a1)
{
}

uint64_t sub_100AD3CD8(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_100AD3D20()
{
}

void *sub_100AD3D34(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A38D38;
  result[1] = v3;
  return result;
}

uint64_t sub_100AD3D7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A38D38;
  a2[1] = v2;
  return result;
}

void sub_100AD3DA8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  long long v4 = *(void **)(a1 + 8);
  uint64_t v5 = v4[29];
  uint64_t v19 = v2;
  long long v20 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(v5 + 72);
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, &v19);
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v7 = v4[29];
  uint64_t v8 = v4[30];
  uint64_t v9 = v7 + 80;
  if (v7 + 80 != v8)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = v7 + v10;
      if (*(char *)(v7 + v10 + 23) < 0) {
        operator delete(*(void **)v11);
      }
      *(_OWORD *)uint64_t v11 = *(_OWORD *)(v11 + 80);
      *(void *)(v11 + 16) = *(void *)(v11 + 96);
      *(unsigned char *)(v11 + 103) = 0;
      *(unsigned char *)(v11 + 8sub_1001A7358((uint64_t)&a9, 0) = 0;
      __n128 v12 = sub_10005C9A4(v11 + 24, (__n128 *)(v11 + 104));
      uint64_t v15 = *(void **)(v11 + 72);
      uint64_t v14 = (void *)(v11 + 72);
      uint64_t v13 = v15;
      uint64_t v16 = v14 - 3;
      void *v14 = 0;
      if (v14 - 3 == v15)
      {
        (*(void (**)(void *, __n128))(*v16 + 32))(v14 - 3, v12);
      }
      else if (v13)
      {
        (*(void (**)(void *, __n128))(*v13 + 40))(v13, v12);
      }
      char v17 = *(void **)(v7 + v10 + 152);
      if (v17)
      {
        if (v14 + 7 == v17)
        {
          void *v14 = v16;
          (*(void (**)(void *, void *, __n128))(v14[7] + 24))(v14 + 7, v14 - 3, v12);
          goto LABEL_19;
        }
        void *v14 = v17;
        uint64_t v14 = (void *)(v9 + 72);
      }
      void *v14 = 0;
LABEL_19:
      v9 += 80;
      v10 += 80;
      if (v7 + v10 + 80 == v8)
      {
        uint64_t v9 = v4[30];
        v7 += v10;
        break;
      }
    }
  }
  while (v9 != v7)
  {
    v9 -= 80;
    sub_100AD37BC(v9);
  }
  v4[30] = v7;
  long long v18 = (std::__shared_weak_count *)v4[14];
  v4[13] = 0;
  v4[14] = 0;
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_100ACE240((uint64_t)v4);
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100AD3FC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD3FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD4038()
{
}

uint64_t sub_100AD4044(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100AD40DC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100AD4160(void *a1)
{
  *a1 = off_101A38DB8;
  sub_100AD40DC(a1 + 3);
  return a1;
}

void sub_100AD41A4(void *a1)
{
  *a1 = off_101A38DB8;
  sub_100AD40DC(a1 + 3);

  operator delete();
}

void *sub_100AD4208(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A38DB8;
  v2[1] = v3;
  *((_WORD *)v2 + 8) = *(_WORD *)(a1 + 16);
  sub_100AD4044((uint64_t)(v2 + 3), a1 + 24);
  return v2;
}

void sub_100AD426C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD4280(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A38DB8;
  uint64_t v2 = *(void *)(a1 + 8);
  *(_WORD *)(a2 + 16) = *(_WORD *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  return sub_100AD4044(a2 + 24, a1 + 24);
}

void *sub_100AD42BC(uint64_t a1)
{
  return sub_100AD40DC((void *)(a1 + 24));
}

void sub_100AD42C4(void *a1)
{
  sub_100AD40DC(a1 + 3);

  operator delete(a1);
}

void sub_100AD4300(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  v33[0] = v4;
  v33[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = sub_100AD49C0((os_log_t *)(v5 + 40), v33);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v6)
  {
    v31[0] = 0;
    v31[1] = 0;
    uint64_t v32 = 0;
    v30[0] = 0;
    v30[1] = 0;
    long long v29 = (uint64_t *)v30;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v28, v4);
    BOOL v7 = sub_100A97CD4(&v28, (uint64_t)v31, &v29);
    sub_100030068(&v28);
    if (v7)
    {
      uint64_t v8 = *(std::__shared_weak_count **)(v5 + 80);
      if (v8)
      {
        uint64_t v9 = std::__shared_weak_count::lock(v8);
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = *(void *)(v5 + 72);
          if (v11)
          {
            int v12 = *(unsigned __int8 *)(a1 + 16);
            (*(void (**)(void **__return_ptr))(**(void **)(v5 + 88) + 40))(v26);
            int v13 = *(unsigned __int8 *)(a1 + 17);
            if (SHIBYTE(v32) < 0)
            {
              sub_10004FC84(__p, v31[0], (unint64_t)v31[1]);
            }
            else
            {
              *(_OWORD *)long long __p = *(_OWORD *)v31;
              uint64_t v35 = v32;
            }
            sub_100346B40((uint64_t)&v36, (uint64_t)&v29);
            *(void *)&long long v39 = v4;
            *((void *)&v39 + 1) = v3;
            if (v3) {
              atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v40 = v5;
            sub_100AD4044((uint64_t)v41, a1 + 24);
            __n128 v44 = 0;
            uint64_t v19 = (char *)operator new(0x70uLL);
            long long v20 = v19;
            *(void *)uint64_t v19 = off_101A38E28;
            *(_OWORD *)(v19 + 8) = *(_OWORD *)__p;
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v21 = v35;
            long long v22 = v36;
            uint64_t v35 = 0;
            *((void *)v19 + 3) = v21;
            *((void *)v19 + 4) = v22;
            uint64_t v23 = v37;
            uint64_t v24 = v38;
            *((void *)v19 + 5) = v37;
            uint64_t v25 = v19 + 40;
            *((void *)v19 + 6) = v24;
            if (v24)
            {
              v23[2] = v25;
              uint64_t v36 = &v37;
              int64x2_t v37 = 0;
              uint64_t v38 = 0;
            }
            else
            {
              *((void *)v19 + 4) = v25;
            }
            *(_OWORD *)(v19 + 56) = v39;
            long long v39 = 0uLL;
            *((void *)v19 + 9) = v40;
            sub_100AD4940((uint64_t)(v19 + 80), (uint64_t)v41);
            __n128 v44 = v20;
            (*(void (**)(uint64_t, BOOL, void **, void **, BOOL, uint64_t *))(*(void *)v11 + 32))(v11, v12 != 0, v31, v26, v13 != 0, &v42);
            sub_1000C6860(&v42);
            sub_100AD40DC(v41);
            if (*((void *)&v39 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
            }
            sub_10010C0E0((uint64_t)&v36, v37);
            if (SHIBYTE(v35) < 0) {
              operator delete(__p[0]);
            }
            if (v27 < 0) {
              operator delete(v26[0]);
            }
          }
          sub_10004D2C8(v10);
        }
      }
    }
    else
    {
      long long v18 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to decode create session response", (uint8_t *)__p, 2u);
      }
      sub_100058DB0(v26, "");
      LOBYTE(__p[0]) = 0;
      LOBYTE(v36) = 0;
      LOBYTE(v42) = 0;
      LOBYTE(v44) = 0;
      sub_100ACEF40(*(void *)(a1 + 48), (uint64_t)v26, (uint64_t)__p, (uint64_t)&v42, 0);
      if ((_BYTE)v44) {
        sub_10010C0E0((uint64_t)&v42, v43);
      }
      if ((_BYTE)v36 && __p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v27 < 0) {
        operator delete(v26[0]);
      }
    }
    sub_10010C0E0((uint64_t)&v29, v30[0]);
  }
  else
  {
    sub_100058DB0(v31, "");
    LOBYTE(__p[0]) = 0;
    LOBYTE(v36) = 0;
    LOBYTE(v42) = 0;
    LOBYTE(v44) = 0;
    if (v4)
    {
      int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
      char v17 = v14 < 1 || v14 == 400 || v14 == 500;
    }
    else
    {
      char v17 = 0;
    }
    sub_100ACEF40(*(void *)(a1 + 48), (uint64_t)v31, (uint64_t)__p, (uint64_t)&v42, v17);
    if ((_BYTE)v44) {
      sub_10010C0E0((uint64_t)&v42, v43);
    }
    if ((_BYTE)v36 && __p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100AD479C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v41);
  sub_10010C0E0((uint64_t)&a17, a20);
  if (a27 < 0) {
    operator delete(a22);
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD48F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD4934()
{
}

uint64_t sub_100AD4940(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

BOOL sub_100AD49C0(os_log_t *a1, void *a2)
{
  if (!*a2)
  {
    os_log_t v5 = *a1;
    BOOL result = os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(__p[0]) = 0;
    BOOL v6 = "No response";
    BOOL v7 = v5;
    uint32_t v8 = 2;
    goto LABEL_15;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))(*a2) != 1)
  {
    uint64_t v9 = *a1;
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    (*(void (**)(void))(*(void *)*a2 + 16))();
    ctu::Http::asString();
    if (v14 >= 0) {
      uint64_t v10 = __p;
    }
    else {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v16 = v10;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Result failure [%{public}s]", buf, 0xCu);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))() == 200) {
    return 1;
  }
  uint64_t v11 = *a1;
  BOOL result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
    LODWORD(__p[0]) = 67109120;
    HIDWORD(__p[0]) = v12;
    BOOL v6 = "Invalid response code: %d";
    BOOL v7 = v11;
    uint32_t v8 = 8;
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v6, (uint8_t *)__p, v8);
    return 0;
  }
  return result;
}

uint64_t sub_100AD4BD8(uint64_t a1)
{
  *(void *)a1 = off_101A38E28;
  sub_100AD40DC((void *)(a1 + 80));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10010C0E0(a1 + 32, *(void **)(a1 + 40));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100AD4C44(uint64_t a1)
{
  *(void *)a1 = off_101A38E28;
  sub_100AD40DC((void *)(a1 + 80));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10010C0E0(a1 + 32, *(void **)(a1 + 40));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_100AD4CD0(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x70uLL);
  *uint64_t v2 = off_101A38E28;
  sub_100AD50D4(v2 + 1, v1);
  return v2;
}

void sub_100AD4D24(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100AD4D38(uint64_t a1, void *a2)
{
  *a2 = off_101A38E28;
  return sub_100AD50D4(a2 + 1, (long long *)(a1 + 8));
}

void sub_100AD4D64(uint64_t a1)
{
}

void sub_100AD4D6C(void *a1)
{
  sub_100AD51A4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD4DA8(uint64_t a1, unsigned __int8 *a2)
{
  *(_OWORD *)long long __p = 0u;
  long long v10 = 0u;
  sub_1000C68E4((unsigned __int8 *)__p, a2);
  int v3 = LOBYTE(__p[0]);
  if (LOBYTE(__p[0]) == 2)
  {
    uint64_t v4 = *(NSObject **)(*(void *)(a1 + 72) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to generate signed payload: %s", (uint8_t *)&buf, 0xCu);
    }
    sub_100058DB0(&__dst, "");
    LOBYTE(buf) = 0;
    char v18 = 0;
    v11[0] = 0;
    char v13 = 0;
    sub_100ACEF40(*(void *)(a1 + 104), (uint64_t)&__dst, (uint64_t)&buf, (uint64_t)v11, 0);
  }
  else
  {
    if (*(char *)(a1 + 31) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 8), *(void *)(a1 + 16));
      int v3 = LOBYTE(__p[0]);
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 8);
      uint64_t v15 = *(void *)(a1 + 24);
    }
    if (v3 != 1)
    {
      if (v3 == 2)
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        BOOL v7 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
      }
      else
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        BOOL v7 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      __cxa_throw(exception, v8, (void (*)(void *))v7);
    }
    long long buf = 0uLL;
    uint64_t v17 = 0;
    sub_10005C928(&buf, __p[1], v10, v10 - (unint64_t)__p[1]);
    char v18 = 1;
    sub_100346B40((uint64_t)v11, a1 + 32);
    char v13 = 1;
    sub_100ACEF40(*(void *)(a1 + 104), (uint64_t)&__dst, (uint64_t)&buf, (uint64_t)v11, 0);
  }
  if (v13) {
    sub_10010C0E0((uint64_t)v11, v12);
  }
  if (v18 && (void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__dst);
  }
  if (LOBYTE(__p[0]) == 1)
  {
    if (__p[1])
    {
      *(void **)&long long v10 = __p[1];
      operator delete(__p[1]);
    }
  }
}

void sub_100AD4FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, int a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a9 == 1)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD5088(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD50C8()
{
}

void *sub_100AD50D4(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_100346B40((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  uint64_t v5 = *((void *)a2 + 7);
  __dst[6] = *((void *)a2 + 6);
  __dst[7] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  __dst[8] = *((void *)a2 + 8);
  sub_100AD4044((uint64_t)(__dst + 9), (uint64_t)a2 + 72);
  return __dst;
}

void sub_100AD5168(_Unwind_Exception *a1)
{
  long long v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10010C0E0(v2, *(void **)(v1 + 32));
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

void sub_100AD51A4(uint64_t a1)
{
  sub_100AD40DC((void *)(a1 + 72));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10010C0E0(a1 + 24, *(void **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
  {
    int v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_100AD5210()
{
}

void *sub_100AD5224()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = off_101A38EB8;
  return result;
}

void sub_100AD525C(uint64_t a1, void *a2)
{
  *a2 = off_101A38EB8;
}

uint64_t sub_100AD5288(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD52C8()
{
}

void sub_100AD52D8()
{
}

void *sub_100AD52EC(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = off_101A38F38;
  result[1] = v3;
  return result;
}

uint64_t sub_100AD5334(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A38F38;
  a2[1] = v2;
  return result;
}

void sub_100AD5360(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 80);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = *(void *)(v2 + 72);
      if (v7)
      {
        if (v4) {
          uint32_t v8 = "Retry_Success";
        }
        else {
          uint32_t v8 = "Retry_Failed";
        }
        sub_100058DB0(__p, v8);
        (*(void (**)(uint64_t, void **))(*(void *)v7 + 104))(v7, __p);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100AD5414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD5440(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD5480()
{
}

void sub_100AD548C(uint64_t **a1, char **a2)
{
  long long __p = 0;
  v7[0] = 0;
  v7[1] = 0;
  sub_1002B00FC((uint64_t)a1, a2, &__p);
  uint64_t v5 = 0;
  uint64_t v3 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v5, (void **)__p + 4);
  if (*v3)
  {
    int v4 = (void **)__p;
    long long __p = 0;
    if (v4) {
      sub_1000C6EE8((uint64_t)v7, v4);
    }
  }
  else
  {
    sub_100046C38(a1, v5, v3, (uint64_t *)__p);
  }
}

void sub_100AD5510(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A38FB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100AD5530(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A38FB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100AD5584(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
    if (v2)
    {
      uint64_t v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        int v4 = v3;
        uint64_t v5 = *(void *)(a1 + 24);
        if (v5) {
          (*(void (**)(uint64_t, void))(*(void *)v5 + 40))(v5, 0);
        }
        sub_10004D2C8(v4);
      }
    }
  }
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
  {
    std::__shared_weak_count::__release_weak(v6);
  }
}

uint64_t sub_100AD5624(uint64_t a1)
{
  *(void *)a1 = off_101A39008;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v4 = (void **)(a1 + 24);
  sub_100047F64(&v4);
  return a1;
}

void sub_100AD5688(uint64_t a1)
{
  *(void *)a1 = off_101A39008;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)(a1 + 24);
  sub_100047F64(&v3);
  operator delete();
}

void *sub_100AD5700(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A39008;
  sub_100AD5C2C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD5754(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD5768(uint64_t a1, void *a2)
{
  *a2 = off_101A39008;
  return sub_100AD5C2C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100AD5794(uint64_t a1)
{
}

void sub_100AD579C(void *a1)
{
  sub_100AD5CA4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD57D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)a2;
  int v6 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  LOBYTE(v21[0]) = 0;
  char v23 = 0;
  int v7 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    uint64_t v22 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v23 = 1;
  }
  LOBYTE(v17) = 0;
  char v20 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v10 = *(void *)(a1 + 8);
    long long v30 = 0;
    long long v31 = 0;
    uint64_t v32 = 0;
    goto LABEL_21;
  }
  uint32_t v8 = (void *)(a4 + 8);
  uint64_t v9 = *(void **)(a4 + 8);
  uint64_t v17 = *(void ***)a4;
  char v18 = v9;
  if (*(void *)(a4 + 16))
  {
    v9[2] = &v18;
    *(void *)a4 = v8;
    *uint32_t v8 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v17 = &v18;
  }
  char v20 = 1;
  uint64_t v10 = *(void *)(a1 + 8);
  long long v30 = 0;
  long long v31 = 0;
  uint64_t v32 = 0;
  if (!v7)
  {
LABEL_21:
    uint64_t v15 = *(NSObject **)(v10 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
    }
    goto LABEL_26;
  }
  if (sub_100A9D7B8(*(unsigned __int8 *)(a1 + 16), v21, (uint64_t **)(a1 + 24), (uint64_t)&v30))
  {
    uint64_t v11 = *(std::__shared_weak_count **)(v10 + 64);
    v27[0] = *(void *)(v10 + 56);
    v27[1] = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v20) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)buf, (uint64_t)v27, "GetSubscriptionDetails", (uint64_t)&v17);
    long long __p = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    sub_10005C928(&__p, v30, (uint64_t)v31, v31 - (unsigned char *)v30);
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v34 = 0;
    char v14 = operator new(0x20uLL);
    void *v14 = off_101A39088;
    v14[1] = v10;
    void v14[2] = v13;
    v14[3] = v12;
    uint64_t v34 = v14;
    sub_100ACDED8((void *)v10, (uint64_t)buf, (uint64_t)&__p, (uint64_t)v33);
    sub_100A86C00(v33);
    if (__p)
    {
      uint64_t v25 = __p;
      operator delete(__p);
    }
    if (v29 < 0) {
      operator delete(*(void **)buf);
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
    goto LABEL_28;
  }
  uint64_t v16 = *(NSObject **)(v10 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
  }
LABEL_26:
  sub_100058DB0(buf, "GetSubscriptionDetails");
  sub_1000E9358((uint64_t **)(v10 + 160), (void **)buf);
  if (v29 < 0) {
    operator delete(*(void **)buf);
  }
LABEL_28:
  if (v30)
  {
    long long v31 = v30;
    operator delete(v30);
  }
  if (v20) {
    sub_10010C0E0((uint64_t)&v17, v18);
  }
  if (v23 && v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100AD5B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_100A86C00((void *)(v31 - 104));
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  long long v33 = *(void **)(v31 - 128);
  if (v33)
  {
    *(void *)(v31 - 12sub_1001A7358((uint64_t)&a9, 0) = v33;
    operator delete(v33);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v30 < 0) {
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD5BE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD5C20()
{
}

uint64_t sub_100AD5C2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)(a1 + 16), (long long *)a2[2], (long long *)a2[3], 0xAAAAAAAAAAAAAAABLL * ((a2[3] - a2[2]) >> 3));
  uint64_t v5 = a2[6];
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = a2[5];
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100AD5CA4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)(a1 + 16);
  sub_100047F64(&v3);
}

void sub_100AD5CE8(uint64_t a1, uint64_t a2, char *__s, uint64_t a4)
{
  sub_100058DB0(&__p, __s);
  uint32_t v8 = sub_100046F68(a4, (void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((void **)(a4 + 8) == v8)
  {
    (*(void (**)(std::string *__return_ptr))(**(void **)a2 + 832))(&__p);
    size_t v11 = strlen(__s);
    uint64_t v12 = std::string::append(&__p, __s, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    *(void *)(a1 + 16) = *((void *)&v12->__r_.__value_.__l + 2);
    *(_OWORD *)a1 = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
  }
  else
  {
    sub_100058DB0(&__p, __s);
    uint64_t v9 = sub_10005DDEC(a4, (void **)&__p.__r_.__value_.__l.__data_);
    if (*(char *)(v9 + 23) < 0)
    {
      sub_10004FC84((unsigned char *)a1, *(void **)v9, *(void *)(v9 + 8));
    }
    else
    {
      long long v10 = *(_OWORD *)v9;
      *(void *)(a1 + 16) = *(void *)(v9 + 16);
      *(_OWORD *)a1 = v10;
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100AD5E1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AD5E40(void *a1)
{
  *a1 = off_101A39088;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD5E8C(void *a1)
{
  *a1 = off_101A39088;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100AD5EF8(uint64_t a1)
{
  BOOL result = (char *)operator new(0x20uLL);
  *(void *)BOOL result = off_101A39088;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100AD5F5C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A39088;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100AD5F9C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100AD5FAC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100AD5FEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  v18[0] = v3;
  v18[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v5 = sub_100AD49C0((os_log_t *)(v4 + 40), v18);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v5)
  {
    std::string __p = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v3 + 40))(&v14, v3);
    char v6 = sub_100A9DA6C(&v14, (uint64_t *)&__p);
    sub_100030068(&v14);
    if (v6)
    {
      *(CFAbsoluteTime *)(v4 + 264) = CFAbsoluteTimeGetCurrent() + 300.0;
      if (v16 != __p)
      {
        int v7 = *(std::__shared_weak_count **)(v4 + 80);
        if (v7)
        {
          uint32_t v8 = std::__shared_weak_count::lock(v7);
          if (v8)
          {
            uint64_t v9 = v8;
            uint64_t v10 = *(void *)(v4 + 72);
            if (v10) {
              (*(void (**)(uint64_t, void **))(*(void *)v10 + 24))(v10, &__p);
            }
            sub_10004D2C8(v9);
          }
        }
      }
    }
    else
    {
      size_t v11 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v12[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid get subscription details response", (uint8_t *)v12, 2u);
      }
    }
    sub_100058DB0(v12, "GetSubscriptionDetails");
    sub_1000E9358((uint64_t **)(v4 + 160), v12);
    if (v13 < 0) {
      operator delete(v12[0]);
    }
    v12[0] = &__p;
    sub_100310018((void ***)v12);
  }
  else
  {
    sub_100058DB0(&__p, "GetSubscriptionDetails");
    sub_1000E9358((uint64_t **)(v4 + 160), &__p);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p);
    }
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100AD61F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_10004D2C8(v23);
  std::string __p = &a17;
  sub_100310018(&__p);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD6298(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD62D8()
{
}

void *sub_100AD62E4(void *a1)
{
  *a1 = off_101A39118;
  sub_100033230(a1 + 2);
  return a1;
}

void sub_100AD6328(void *a1)
{
  *a1 = off_101A39118;
  sub_100033230(a1 + 2);

  operator delete();
}

void *sub_100AD638C(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A39118;
  v2[1] = v3;
  sub_1000332B4((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100AD63E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD63F8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A39118;
  a2[1] = v2;
  return sub_1000332B4((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100AD6428(uint64_t a1)
{
  return sub_100033230((void *)(a1 + 16));
}

void sub_100AD6430(void *a1)
{
  sub_100033230(a1 + 2);

  operator delete(a1);
}

void sub_100AD646C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 80);
  if (v4)
  {
    char v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      int v7 = v6;
      uint64_t v8 = *(void *)(v3 + 72);
      if (v8)
      {
        memset(v11, 0, sizeof(v11));
        sub_10030C19C(v11, *a2, a2[1], 0x6F96F96F96F96F97 * ((a2[1] - *a2) >> 3));
        (*(void (**)(uint64_t, uint64_t **))(*(void *)v8 + 64))(v8, v11);
        CFTypeRef cf = 0;
        sub_100A9F534(v11, &cf);
        CFTypeRef v10 = cf;
        if (cf) {
          CFRetain(cf);
        }
        uint64_t v9 = *(void *)(a1 + 40);
        if (!v9) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v9 + 48))(v9, &v10);
        sub_100044D00(&v10);
        sub_100044D00(&cf);
        CFTypeRef cf = v11;
        sub_1000C63B8((void ***)&cf);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100AD65A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_1000C63B8(&a14);
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD65E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD6628()
{
}

void *sub_100AD6634(void *a1)
{
  *a1 = off_101A39198;
  sub_100313790(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD6684(void *a1)
{
  *a1 = off_101A39198;
  sub_100313790(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100AD66F4(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A39198;
  sub_100AD6C74((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD6748(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD675C(uint64_t a1, void *a2)
{
  *a2 = off_101A39198;
  return sub_100AD6C74((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100AD6788(uint64_t a1)
{
}

void sub_100AD6790(void *a1)
{
  sub_100AD6CE4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD67CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5 = *(void **)a2;
  int v6 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  LOBYTE(v22[0]) = 0;
  char v24 = 0;
  int v7 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v22 = *(_OWORD *)a3;
    uint64_t v23 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v24 = 1;
  }
  LOBYTE(v18) = 0;
  char v21 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    CFTypeRef v10 = *(void **)(a1 + 8);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
LABEL_23:
    uint64_t v15 = v10[5];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
    }
    sub_10031F4D0((uint64_t)v40, a1 + 40);
    sub_100AD0BE4((uint64_t)v10, 5, (uint64_t)v40);
    uint64_t v16 = v40;
    goto LABEL_29;
  }
  uint64_t v8 = (void *)(a4 + 8);
  uint64_t v9 = *(void **)(a4 + 8);
  char v18 = *(void ***)a4;
  uint64_t v19 = v9;
  if (*(void *)(a4 + 16))
  {
    v9[2] = &v19;
    *(void *)a4 = v8;
    *uint64_t v8 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    char v18 = &v19;
  }
  char v21 = 1;
  CFTypeRef v10 = *(void **)(a1 + 8);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (!v7) {
    goto LABEL_23;
  }
  if (!sub_100A99868(*(unsigned __int8 *)(a1 + 16), (uint64_t)v22, (uint64_t)&v31))
  {
    uint64_t v17 = v10[5];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
    }
    sub_10031F4D0((uint64_t)v39, a1 + 40);
    sub_100AD0BE4((uint64_t)v10, 3, (uint64_t)v39);
    uint64_t v16 = v39;
LABEL_29:
    sub_100313790(v16);
    goto LABEL_30;
  }
  size_t v11 = (std::__shared_weak_count *)v10[8];
  v28[0] = v10[7];
  v28[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v21) {
    sub_10016C840();
  }
  sub_100AD5CE8((uint64_t)buf, (uint64_t)v28, "GetCarrierOptions", (uint64_t)&v18);
  std::string __p = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  sub_10005C928(&__p, v31, (uint64_t)v32, v32 - (unsigned char *)v31);
  uint64_t v13 = *(void *)(a1 + 24);
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)&long long v34 = v10;
  *((void *)&v34 + 1) = v13;
  uint64_t v35 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10031F4D0((uint64_t)v36, a1 + 40);
  uint64_t v38 = 0;
  char v14 = (char *)operator new(0x40uLL);
  *(void *)char v14 = off_101A39208;
  *(_OWORD *)(v14 + 8) = v34;
  *((void *)v14 + 3) = v35;
  *((void *)&v34 + 1) = 0;
  uint64_t v35 = 0;
  sub_100349184((uint64_t)(v14 + 32), (uint64_t)v36);
  uint64_t v38 = v14;
  sub_100ACDED8(v10, (uint64_t)buf, (uint64_t)&__p, (uint64_t)v37);
  sub_100A86C00(v37);
  sub_100313790(v36);
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (__p)
  {
    uint64_t v26 = __p;
    operator delete(__p);
  }
  if (v30 < 0) {
    operator delete(*(void **)buf);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
LABEL_30:
  if (v31)
  {
    uint64_t v32 = v31;
    operator delete(v31);
  }
  if (v21) {
    sub_10010C0E0((uint64_t)&v18, v19);
  }
  if (v24 && v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100AD6B48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  sub_100A86C00((void *)(v38 - 168));
  sub_100313790(v36);
  if (a34) {
    sub_10004D2C8(a34);
  }
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v37 < 0) {
    operator delete(v34);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD6C28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD6C68()
{
}

uint64_t sub_100AD6C74(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v3;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10031F4D0(a1 + 32, (uint64_t)(a2 + 4));
  return a1;
}

void sub_100AD6CCC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AD6CE4(uint64_t a1)
{
  sub_100313790((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_100AD6D30(void *a1)
{
  *a1 = off_101A39208;
  sub_100313790(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD6D80(void *a1)
{
  *a1 = off_101A39208;
  sub_100313790(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100AD6DF0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A39208;
  sub_100AD71B4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD6E44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD6E58(uint64_t a1, void *a2)
{
  *a2 = off_101A39208;
  return sub_100AD71B4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AD6E84(uint64_t a1)
{
}

void sub_100AD6E8C(void *a1)
{
  sub_100321E70((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD6EC8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  v14[0] = v4;
  v14[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = sub_100AD49C0((os_log_t *)(v5 + 40), v14);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (!v6)
  {
    sub_10031F4D0((uint64_t)buf, a1 + 32);
    sub_100AD0BE4(v5, 5, (uint64_t)buf);
    sub_100313790(buf);
    if (!v3) {
      return;
    }
    goto LABEL_11;
  }
  double v12 = 0.0;
  CFTypeRef cf = 0;
  (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v11, v4);
  BOOL v7 = sub_100A999D4(&v11, &v12, &cf);
  sub_100030068(&v11);
  if (v7)
  {
    uint64_t v8 = *(void *)(v5 + 88);
    CFTypeRef v10 = cf;
    if (cf) {
      CFRetain(cf);
    }
    (*(void (**)(uint64_t, CFTypeRef *, double))(*(void *)v8 + 72))(v8, &v10, v12);
    sub_100044D00(&v10);
    sub_10031F4D0((uint64_t)buf, a1 + 32);
    sub_100AD0BE4(v5, 0, (uint64_t)buf);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid carrier option response", buf, 2u);
    }
    sub_10031F4D0((uint64_t)buf, a1 + 32);
    sub_100AD0BE4(v5, 5, (uint64_t)buf);
  }
  sub_100313790(buf);
  sub_100044D00(&cf);
  if (v3) {
LABEL_11:
  }
    sub_10004D2C8(v3);
}

void sub_100AD70D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD7168(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD71A8()
{
}

uint64_t sub_100AD71B4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10031F4D0(a1 + 24, a2 + 24);
  return a1;
}

void sub_100AD7204(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD721C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_100AD729C(uint64_t a1)
{
  *(void *)a1 = off_101A39298;
  sub_10034AB3C((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v4 = (void **)(a1 + 24);
  sub_10030B640(&v4);
  return a1;
}

void sub_100AD7304(uint64_t a1)
{
  *(void *)a1 = off_101A39298;
  sub_10034AB3C((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)(a1 + 24);
  sub_10030B640(&v3);
  operator delete();
}

void *sub_100AD7380(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  *uint64_t v2 = off_101A39298;
  sub_100AD7984((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD73D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD73E8(uint64_t a1, void *a2)
{
  *a2 = off_101A39298;
  return sub_100AD7984((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100AD7414(uint64_t a1)
{
}

void sub_100AD741C(void *a1)
{
  sub_100AD7AD0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD7458(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)a2;
  int v6 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  LOBYTE(v21[0]) = 0;
  char v23 = 0;
  int v7 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)char v21 = *(_OWORD *)a3;
    uint64_t v22 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v23 = 1;
  }
  LOBYTE(v17) = 0;
  char v20 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
LABEL_23:
    uint64_t v15 = *(NSObject **)(v10 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
    }
    sub_100058DB0(buf, "GetAddOnOptions");
    sub_1000E9358((uint64_t **)(v10 + 160), (void **)buf);
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)buf);
    }
    char v29 = 0;
    uint64_t v30 = 0;
    *(void *)long long buf = &v29;
    sub_100AD1240(*(void *)(a1 + 88), (uint64_t)buf, 5);
    goto LABEL_33;
  }
  uint64_t v8 = (void *)(a4 + 8);
  uint64_t v9 = *(void **)(a4 + 8);
  uint64_t v17 = *(void ***)a4;
  char v18 = v9;
  if (*(void *)(a4 + 16))
  {
    v9[2] = &v18;
    *(void *)a4 = v8;
    *uint64_t v8 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v17 = &v18;
  }
  char v20 = 1;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (!v7) {
    goto LABEL_23;
  }
  if (!sub_100A9AAAC(*(unsigned __int8 *)(a1 + 16), (uint64_t **)(a1 + 24), v21, (uint64_t)&v31))
  {
    uint64_t v16 = *(NSObject **)(v10 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
    }
    sub_100058DB0(buf, "GetAddOnOptions");
    sub_1000E9358((uint64_t **)(v10 + 160), (void **)buf);
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)buf);
    }
    char v29 = 0;
    uint64_t v30 = 0;
    *(void *)long long buf = &v29;
    sub_100AD1240(*(void *)(a1 + 88), (uint64_t)buf, 3);
LABEL_33:
    sub_10034964C((uint64_t)buf, v29);
    goto LABEL_34;
  }
  size_t v11 = *(std::__shared_weak_count **)(v10 + 64);
  v27[0] = *(void *)(v10 + 56);
  v27[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v20) {
    sub_10016C840();
  }
  sub_100AD5CE8((uint64_t)buf, (uint64_t)v27, "GetAddOnOptions", (uint64_t)&v17);
  std::string __p = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  sub_10005C928(&__p, v31, (uint64_t)v32, v32 - (unsigned char *)v31);
  uint64_t v13 = *(void *)(a1 + 48);
  double v12 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)&long long v34 = v10;
  *((void *)&v34 + 1) = v13;
  uint64_t v35 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100AD7A38((uint64_t)v36, a1 + 64);
  uint64_t v38 = 0;
  char v14 = (char *)operator new(0x40uLL);
  *(void *)char v14 = off_101A39308;
  *(_OWORD *)(v14 + 8) = v34;
  *((void *)v14 + 3) = v35;
  *((void *)&v34 + 1) = 0;
  uint64_t v35 = 0;
  sub_100AD721C((uint64_t)(v14 + 32), (uint64_t)v36);
  uint64_t v38 = v14;
  sub_100ACDED8((void *)v10, (uint64_t)buf, (uint64_t)&__p, (uint64_t)v37);
  sub_100A86C00(v37);
  sub_10034AB3C(v36);
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (__p)
  {
    uint64_t v25 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(*(void **)buf);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
LABEL_34:
  if (v31)
  {
    uint64_t v32 = v31;
    operator delete(v31);
  }
  if (v20) {
    sub_10010C0E0((uint64_t)&v17, v18);
  }
  if (v23 && v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100AD7838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  sub_100A86C00((void *)(v38 - 104));
  sub_10034AB3C(v36);
  if (a34) {
    sub_10004D2C8(a34);
  }
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v37 < 0) {
    operator delete(v34);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD7938(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD7978()
{
}

uint64_t sub_100AD7984(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  sub_10030B4A4((void *)(a1 + 16), a2[2], a2[3], (a2[3] - a2[2]) >> 7);
  uint64_t v5 = a2[6];
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = a2[5];
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100AD7A38(a1 + 56, (uint64_t)(a2 + 7));
  return a1;
}

void sub_100AD7A14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10030B640((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD7A38(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_100AD7AD0(uint64_t a1)
{
  sub_10034AB3C((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)(a1 + 16);
  sub_10030B640(&v3);
}

void *sub_100AD7B1C(void *a1)
{
  *a1 = off_101A39308;
  sub_10034AB3C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD7B6C(void *a1)
{
  *a1 = off_101A39308;
  sub_10034AB3C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100AD7BDC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A39308;
  sub_100AD7FB8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD7C30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD7C44(uint64_t a1, void *a2)
{
  *a2 = off_101A39308;
  return sub_100AD7FB8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AD7C70(uint64_t a1)
{
}

void sub_100AD7C78(void *a1)
{
  sub_100AD8020((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD7CB4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  v16[0] = v4;
  v16[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = sub_100AD49C0((os_log_t *)(v5 + 40), v16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v6)
  {
    char v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = &v14;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v12, v4);
    BOOL v7 = sub_100A9AF8C(&v12, (uint64_t)&v13);
    sub_100030068(&v12);
    if (v7)
    {
      sub_100058DB0(&__p, "GetAddOnOptions");
      sub_1000E9358((uint64_t **)(v5 + 160), &__p);
      if (SHIBYTE(v11) < 0) {
        operator delete(__p);
      }
      sub_100AD1240(*(void *)(a1 + 56), (uint64_t)&v13, 0);
    }
    else
    {
      uint64_t v8 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid addOn carrier option response", (uint8_t *)&__p, 2u);
      }
      sub_100058DB0(&__p, "GetAddOnOptions");
      sub_1000E9358((uint64_t **)(v5 + 160), &__p);
      if (SHIBYTE(v11) < 0) {
        operator delete(__p);
      }
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      std::string __p = &v10;
      sub_100AD1240(*(void *)(a1 + 56), (uint64_t)&__p, 5);
      sub_10034964C((uint64_t)&__p, v10);
    }
  }
  else
  {
    sub_100058DB0(&v13, "GetAddOnOptions");
    sub_1000E9358((uint64_t **)(v5 + 160), &v13);
    if (SHIBYTE(v15) < 0) {
      operator delete(v13);
    }
    char v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = &v14;
    sub_100AD1240(*(void *)(a1 + 56), (uint64_t)&v13, 5);
  }
  sub_10034964C((uint64_t)&v13, v14);
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100AD7EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, void *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17, void *a18, int a19, __int16 a20,char a21,char a22)
{
  sub_10034964C((uint64_t)&__p, a10);
  sub_10034964C((uint64_t)&a17, a18);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD7F6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD7FAC()
{
}

uint64_t sub_100AD7FB8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100AD7A38(a1 + 24, a2 + 24);
  return a1;
}

void sub_100AD8008(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AD8020(uint64_t a1)
{
  sub_10034AB3C((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_100AD806C(void *a1)
{
  *a1 = off_101A39398;
  sub_100060644(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD80BC(void *a1)
{
  *a1 = off_101A39398;
  sub_100060644(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100AD812C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A39398;
  sub_100AD8798((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD8180(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD8194(uint64_t a1, void *a2)
{
  *a2 = off_101A39398;
  return sub_100AD8798((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100AD81C0(uint64_t a1)
{
}

void sub_100AD81C8(void *a1)
{
  sub_100AD8808((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD8204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)char v23 = *(_OWORD *)a2;
  uint64_t v24 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(v20[0]) = 0;
  char v22 = 0;
  int v5 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)char v20 = *(_OWORD *)a3;
    uint64_t v21 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v22 = 1;
  }
  LOBYTE(v16) = 0;
  char v19 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
LABEL_15:
    uint64_t v10 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No signed payload or URLs for eSim install notification.", (uint8_t *)__p, 2u);
    }
    if (*(void *)(a1 + 64)) {
      sub_1000607A8(a1 + 40, 0);
    }
    uint64_t v11 = *(void *)(v8 + 88);
    ++*(void *)(v8 + 400);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 144))(v11, v8 + 400);
    sub_100058DB0(__p, "ProvisioningActionIndication");
    sub_1000E9358((uint64_t **)(v8 + 160), __p);
    goto LABEL_25;
  }
  BOOL v6 = (void *)(a4 + 8);
  BOOL v7 = *(void **)(a4 + 8);
  uint64_t v16 = *(void ***)a4;
  uint64_t v17 = v7;
  if (*(void *)(a4 + 16))
  {
    void v7[2] = &v17;
    *(void *)a4 = v6;
    void *v6 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v16 = &v17;
  }
  char v19 = 1;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (!v5) {
    goto LABEL_15;
  }
  if (sub_100A982AC((uint64_t *)v23, v20, *(unsigned __int8 *)(a1 + 16), (uint64_t)&v31))
  {
    uint64_t v9 = *(std::__shared_weak_count **)(v8 + 64);
    v28[0] = *(void *)(v8 + 56);
    v28[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v19) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)__p, (uint64_t)v28, "CheckAvailableOptions", (uint64_t)&v16);
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    sub_10005C928(&v25, v31, (uint64_t)v32, v32 - (unsigned char *)v31);
    uint64_t v34 = v8;
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(&v35, v23[0], (unint64_t)v23[1]);
    }
    else
    {
      long long v35 = *(_OWORD *)v23;
      uint64_t v36 = v24;
    }
    uint64_t v13 = *(void *)(a1 + 32);
    *(void *)&long long v37 = *(void *)(a1 + 24);
    *((void *)&v37 + 1) = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1000DFC90((uint64_t)v38, a1 + 40);
    uint64_t v40 = 0;
    char v14 = (char *)operator new(0x58uLL);
    uint64_t v15 = v34;
    *(void *)char v14 = off_101A39408;
    *((void *)v14 + 1) = v15;
    *((_OWORD *)v14 + 1) = v35;
    *((void *)v14 + 4) = v36;
    long long v35 = 0uLL;
    uint64_t v36 = 0;
    *(_OWORD *)(v14 + 4sub_1001A7358((uint64_t)&a9, 0) = v37;
    long long v37 = 0uLL;
    sub_100023950((uint64_t)(v14 + 56), (uint64_t)v38);
    uint64_t v40 = v14;
    sub_100ACDED8((void *)v8, (uint64_t)__p, (uint64_t)&v25, (uint64_t)v39);
    sub_100A86C00(v39);
    sub_100060644(v38);
    if (*((void *)&v37 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v37 + 1));
    }
    if (SHIBYTE(v36) < 0) {
      operator delete((void *)v35);
    }
    if (v25)
    {
      uint64_t v26 = v25;
      operator delete(v25);
    }
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    goto LABEL_40;
  }
  double v12 = *(NSObject **)(v8 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to encode eSim install notification.", (uint8_t *)__p, 2u);
  }
  if (*(void *)(a1 + 64)) {
    sub_1000607A8(a1 + 40, 0);
  }
  sub_100058DB0(__p, "ProvisioningActionIndication");
  sub_1000E9358((uint64_t **)(v8 + 160), __p);
LABEL_25:
  if (v30 < 0) {
    operator delete(__p[0]);
  }
LABEL_40:
  if (v31)
  {
    uint64_t v32 = v31;
    operator delete(v31);
  }
  if (v19) {
    sub_10010C0E0((uint64_t)&v16, v17);
  }
  if (v22 && v20[0])
  {
    v20[1] = v20[0];
    operator delete(v20[0]);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[0]);
  }
}

void sub_100AD8648(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46)
{
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (v46) {
    sub_10004D2C8(v46);
  }
  if (a35)
  {
    a36 = (uint64_t)a35;
    operator delete(a35);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD874C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD878C()
{
}

uint64_t sub_100AD8798(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v3;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 32, (uint64_t)(a2 + 4));
  return a1;
}

void sub_100AD87F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AD8808(uint64_t a1)
{
  sub_100060644((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100AD8854(uint64_t a1)
{
  *(void *)a1 = off_101A39408;
  sub_100060644((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100AD88B4(uint64_t a1)
{
  *(void *)a1 = off_101A39408;
  sub_100060644((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100AD8934(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A39408;
  sub_100AD8F00((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD8988(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD899C(uint64_t a1, void *a2)
{
  *a2 = off_101A39408;
  return sub_100AD8F00((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AD89C8(uint64_t a1)
{
}

void sub_100AD89D0(void *a1)
{
  sub_100AD8FB4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD8A0C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  BOOL v6 = (NSObject **)(v5 + 40);
  v27[0] = v4;
  v27[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v7 = sub_100AD49C0((os_log_t *)(v5 + 40), v27);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v7)
  {
    uint64_t v8 = *(void *)(v5 + 88);
    std::string __p = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v8 + 144))(v8, &__p);
    std::string __p = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    memset(v23, 0, sizeof(v23));
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v22, v4);
    BOOL v9 = sub_100A984CC(&v22, (uint64_t)&__p, v23);
    sub_100030068(&v22);
    if (!v9)
    {
      char v19 = *v6;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Server response Decode fail for eSim install notification.", buf, 2u);
      }
      if (*(void *)(a1 + 80)) {
        sub_1000607A8(a1 + 56, 0);
      }
      goto LABEL_41;
    }
    uint64_t v10 = (void *)(a1 + 16);
    char v11 = *(unsigned char *)(a1 + 39);
    if (v11 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 39);
    }
    else {
      uint64_t v12 = *(void *)(a1 + 24);
    }
    uint64_t v13 = HIBYTE(v26);
    int v14 = SHIBYTE(v26);
    if (v26 < 0) {
      uint64_t v13 = v25;
    }
    if (v12 != v13) {
      goto LABEL_30;
    }
    if (v26 >= 0) {
      p_p = (unsigned __int8 *)&__p;
    }
    else {
      p_p = (unsigned __int8 *)__p;
    }
    if ((*(unsigned char *)(a1 + 39) & 0x80) != 0)
    {
      uint64_t v10 = (void *)*v10;
      if (memcmp(v10, p_p, *(void *)(a1 + 24)))
      {
        char v20 = *v6;
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          goto LABEL_31;
        }
        goto LABEL_54;
      }
    }
    else if (*(unsigned char *)(a1 + 39))
    {
      uint64_t v16 = (unsigned __int8 *)(a1 + 16);
      uint64_t v17 = *(unsigned __int8 *)(a1 + 39);
      while (*v16 == *p_p)
      {
        ++v16;
        ++p_p;
        if (!--v17) {
          goto LABEL_37;
        }
      }
LABEL_30:
      char v20 = *v6;
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      if (v11 < 0) {
        uint64_t v10 = (void *)*v10;
      }
      if (v14 >= 0) {
        p_p = (unsigned __int8 *)&__p;
      }
      else {
        p_p = (unsigned __int8 *)__p;
      }
LABEL_54:
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v29 = 2080;
      char v30 = p_p;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Mismatching session id [%s] expecting [%s] for eSim install notification.", buf, 0x16u);
LABEL_31:
      if (*(void *)(a1 + 80)) {
        sub_1000607A8(a1 + 56, 0);
      }
      goto LABEL_41;
    }
LABEL_37:
    uint64_t v21 = *v6;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I provisioningActionIndication_sync: Sent install notification.", buf, 2u);
    }
    if (*(void *)(a1 + 80)) {
      sub_1000607A8(a1 + 56, 1);
    }
LABEL_41:
    sub_100058DB0(buf, "ProvisioningActionIndication");
    sub_1000E9358((uint64_t **)(v5 + 160), (void **)buf);
    if (v31 < 0) {
      operator delete(*(void **)buf);
    }
    *(void *)long long buf = v23;
    sub_1000C63B8((void ***)buf);
    goto LABEL_44;
  }
  if (*(void *)(a1 + 80)) {
    sub_1000607A8(a1 + 56, 0);
  }
  uint64_t v18 = *(void *)(v5 + 88);
  ++*(void *)(v5 + 400);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 144))(v18, v5 + 400);
  sub_100058DB0(&__p, "ProvisioningActionIndication");
  sub_1000E9358((uint64_t **)(v5 + 160), &__p);
LABEL_44:
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100AD8E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,__int16 *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  std::string __p = &a12;
  sub_1000C63B8((void ***)&__p);
  if (a22 < 0) {
    operator delete(a17);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AD8EB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD8EF4()
{
}

uint64_t sub_100AD8F00(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 48, a2 + 48);
  return a1;
}

void sub_100AD8F8C(_Unwind_Exception *exception_object)
{
  long long v4 = *(std::__shared_weak_count **)(v2 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AD8FB4(uint64_t a1)
{
  sub_100060644((void *)(a1 + 48));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    operator delete(v3);
  }
}

void *sub_100AD9010(void *a1)
{
  *a1 = off_101A39498;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD9060(void *a1)
{
  *a1 = off_101A39498;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100AD90D0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A39498;
  sub_100AD97B4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD9124(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD9138(uint64_t a1, void *a2)
{
  *a2 = off_101A39498;
  return sub_100AD97B4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AD9164(uint64_t a1)
{
}

void sub_100AD916C(void *a1)
{
  sub_100322E6C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD91A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)uint64_t v24 = *(_OWORD *)a2;
  uint64_t v25 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(v21[0]) = 0;
  char v23 = 0;
  int v5 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v21 = *(_OWORD *)a3;
    uint64_t v22 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v23 = 1;
  }
  LOBYTE(v17) = 0;
  char v20 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v8 = a1[1];
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
LABEL_15:
    uint64_t v10 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No signed payload or URLs for eSim install replace notification.", (uint8_t *)__p, 2u);
    }
    if (a1[7]) {
      sub_1000607A8((uint64_t)(a1 + 4), 0);
    }
    uint64_t v11 = *(void *)(v8 + 88);
    memset(v32, 0, sizeof(v32));
    sub_100AD38F0(v32, *(void *)(v8 + 408), *(void *)(v8 + 416), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v8 + 416) - *(void *)(v8 + 408)) >> 5));
    (*(void (**)(uint64_t, void **))(*(void *)v11 + 160))(v11, v32);
    __p[0] = v32;
    sub_10016A9A4((void ***)__p);
    uint64_t v12 = *(void *)(v8 + 88);
    ++*(void *)(v8 + 432);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 176))(v12, v8 + 432);
    sub_100058DB0(__p, "notifyEventStatus");
    sub_1000E9358((uint64_t **)(v8 + 160), __p);
    goto LABEL_25;
  }
  BOOL v6 = (void *)(a4 + 8);
  BOOL v7 = *(void **)(a4 + 8);
  uint64_t v17 = *(void ***)a4;
  uint64_t v18 = v7;
  if (*(void *)(a4 + 16))
  {
    void v7[2] = &v18;
    *(void *)a4 = v6;
    void *v6 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v17 = &v18;
  }
  char v20 = 1;
  uint64_t v8 = a1[1];
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  if (!v5) {
    goto LABEL_15;
  }
  if (sub_100AA0A28((uint64_t *)v24, v21, (uint64_t)&v33))
  {
    BOOL v9 = *(std::__shared_weak_count **)(v8 + 64);
    v29[0] = *(void *)(v8 + 56);
    v29[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v20) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)__p, (uint64_t)v29, "notifyEventStatus", (uint64_t)&v17);
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    sub_10005C928(&v26, v33, (uint64_t)v34, v34 - (unsigned char *)v33);
    uint64_t v36 = v8;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&v37, v24[0], (unint64_t)v24[1]);
    }
    else
    {
      long long v37 = *(_OWORD *)v24;
      uint64_t v38 = v25;
    }
    uint64_t v14 = a1[3];
    *(void *)&long long v39 = a1[2];
    *((void *)&v39 + 1) = v14;
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1000DFC90((uint64_t)v40, (uint64_t)(a1 + 4));
    uint64_t v42 = 0;
    uint64_t v15 = (char *)operator new(0x58uLL);
    uint64_t v16 = v36;
    *(void *)uint64_t v15 = off_101A39508;
    *((void *)v15 + 1) = v16;
    *((_OWORD *)v15 + 1) = v37;
    *((void *)v15 + 4) = v38;
    long long v37 = 0uLL;
    uint64_t v38 = 0;
    *(_OWORD *)(v15 + 4sub_1001A7358((uint64_t)&a9, 0) = v39;
    long long v39 = 0uLL;
    sub_100023950((uint64_t)(v15 + 56), (uint64_t)v40);
    uint64_t v42 = v15;
    sub_100ACDED8((void *)v8, (uint64_t)__p, (uint64_t)&v26, (uint64_t)v41);
    sub_100A86C00(v41);
    sub_100060644(v40);
    if (*((void *)&v39 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
    }
    if (SHIBYTE(v38) < 0) {
      operator delete((void *)v37);
    }
    if (v26)
    {
      uint64_t v27 = v26;
      operator delete(v26);
    }
    if (v31 < 0) {
      operator delete(__p[0]);
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    goto LABEL_40;
  }
  uint64_t v13 = *(NSObject **)(v8 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to encode eSim install replace notification.", (uint8_t *)__p, 2u);
  }
  if (a1[7]) {
    sub_1000607A8((uint64_t)(a1 + 4), 0);
  }
  sub_100058DB0(__p, "notifyEventStatus");
  sub_1000E9358((uint64_t **)(v8 + 160), __p);
LABEL_25:
  if (v31 < 0) {
    operator delete(__p[0]);
  }
LABEL_40:
  if (v33)
  {
    uint64_t v34 = v33;
    operator delete(v33);
  }
  if (v20) {
    sub_10010C0E0((uint64_t)&v17, v18);
  }
  if (v23 && v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
}

void sub_100AD9650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38)
{
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD9768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD97A8()
{
}

uint64_t sub_100AD97B4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  return a1;
}

void sub_100AD9804(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD981C(uint64_t a1)
{
  *(void *)a1 = off_101A39508;
  sub_100060644((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100AD987C(uint64_t a1)
{
  *(void *)a1 = off_101A39508;
  sub_100060644((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100AD98FC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A39508;
  sub_100AD9D48((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AD9950(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AD9964(uint64_t a1, void *a2)
{
  *a2 = off_101A39508;
  return sub_100AD9D48((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AD9990(uint64_t a1)
{
}

void sub_100AD9998(void *a1)
{
  sub_100AD8FB4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AD99D4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  long long v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  v17[0] = v3;
  v17[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = sub_100AD49C0((os_log_t *)(v5 + 40), v17);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(v5 + 408);
    uint64_t v8 = *(void *)(v5 + 416);
    if (v8 != v7)
    {
      do
      {
        v8 -= 96;
        sub_10016A8DC(v8);
      }
      while (v8 != v7);
      uint64_t v8 = *(void *)(v5 + 408);
    }
    *(void *)(v5 + 416) = v7;
    uint64_t v9 = *(void *)(v5 + 88);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    *(void *)long long buf = 0;
    sub_100AD38F0(buf, v8, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v8) >> 5));
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 160))(v9, buf);
    __p[0] = buf;
    sub_10016A9A4((void ***)__p);
    uint64_t v10 = *(void *)(v5 + 88);
    *(void *)long long buf = 0;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 176))(v10, buf);
    uint64_t v11 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I installReplaceActionIndication_sync: Sent install replace notification.", buf, 2u);
    }
    if (*(void *)(a1 + 80)) {
      sub_1000607A8(a1 + 56, 1);
    }
    sub_100058DB0(buf, "notifyEventStatus");
    sub_1000E9358((uint64_t **)(v5 + 160), (void **)buf);
    if (SHIBYTE(v20) < 0)
    {
      uint64_t v12 = *(void **)buf;
LABEL_19:
      operator delete(v12);
    }
  }
  else
  {
    if (*(void *)(a1 + 80)) {
      sub_1000607A8(a1 + 56, 0);
    }
    uint64_t v13 = *(void *)(v5 + 88);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    *(void *)long long buf = 0;
    sub_100AD38F0(buf, *(void *)(v5 + 408), *(void *)(v5 + 416), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v5 + 416) - *(void *)(v5 + 408)) >> 5));
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 160))(v13, buf);
    __p[0] = buf;
    sub_10016A9A4((void ***)__p);
    uint64_t v14 = *(void *)(v5 + 88);
    ++*(void *)(v5 + 432);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 176))(v14, v5 + 432);
    sub_100058DB0(__p, "notifyEventStatus");
    sub_1000E9358((uint64_t **)(v5 + 160), __p);
    if (v16 < 0)
    {
      uint64_t v12 = __p[0];
      goto LABEL_19;
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100AD9C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AD9CFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AD9D3C()
{
}

uint64_t sub_100AD9D48(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 48, a2 + 48);
  return a1;
}

void sub_100AD9DD4(_Unwind_Exception *exception_object)
{
  long long v4 = *(std::__shared_weak_count **)(v2 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AD9DFC(void *a1)
{
  *a1 = off_101A39598;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100AD9E48(void *a1)
{
  *a1 = off_101A39598;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

__n128 sub_100AD9EB4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v2 = off_101A39598;
  *((void *)v2 + 1) = v3;
  v2[16] = *(unsigned char *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((void *)v2 + 4) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(v2 + 4sub_1001A7358((uint64_t)&a9, 0) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

__n128 sub_100AD9F2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A39598;
  uint64_t v2 = *(void *)(a1 + 8);
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(__n128 *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = result;
  return result;
}

void sub_100AD9F84(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100AD9F94(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100AD9FD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)uint64_t v27 = *(_OWORD *)a2;
  uint64_t v28 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(v24[0]) = 0;
  char v26 = 0;
  int v5 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v24 = *(_OWORD *)a3;
    uint64_t v25 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v26 = 1;
  }
  LOBYTE(v2sub_1001A7358((uint64_t)&a9, 0) = 0;
  char v23 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v8 = *(void *)(a1 + 8);
    __n128 v43 = 0;
    __n128 v44 = 0;
    uint64_t v45 = 0;
LABEL_17:
    uint64_t v11 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
    }
    *(void *)long long buf = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v12 = *(void *)(a1 + 56);
    uint64_t v13 = *(void *)(v12 + 336);
    if (v13)
    {
      sub_100AD1C50(v13, (uint64_t)buf, 0);
      sub_100ADA588((void *)(v12 + 312));
    }
    goto LABEL_26;
  }
  BOOL v6 = (void *)(a4 + 8);
  uint64_t v7 = *(void **)(a4 + 8);
  uint64_t v20 = *(void ***)a4;
  uint64_t v21 = v7;
  if (*(void *)(a4 + 16))
  {
    void v7[2] = &v21;
    *(void *)a4 = v6;
    void *v6 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v20 = &v21;
  }
  char v23 = 1;
  uint64_t v8 = *(void *)(a1 + 8);
  __n128 v43 = 0;
  __n128 v44 = 0;
  uint64_t v45 = 0;
  if (!v5) {
    goto LABEL_17;
  }
  if (sub_100A982AC((uint64_t *)v27, v24, 0, (uint64_t)&v43))
  {
    uint64_t v9 = *(std::__shared_weak_count **)(v8 + 64);
    v39[0] = *(void *)(v8 + 56);
    v39[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v23) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)buf, (uint64_t)v39, "CheckAvailableOptions", (uint64_t)&v20);
    uint64_t v36 = 0;
    long long v37 = 0;
    uint64_t v38 = 0;
    sub_10005C928(&v36, v43, (uint64_t)v44, v44 - (unsigned char *)v43);
    uint64_t v29 = v8;
    char v30 = *(unsigned char *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 32);
    *(void *)&long long v31 = *(void *)(a1 + 24);
    *((void *)&v31 + 1) = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(&__p, v27[0], (unint64_t)v27[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v27;
      uint64_t v33 = v28;
    }
    long long v34 = *(_OWORD *)(a1 + 40);
    long long v35 = *(_OWORD *)(a1 + 56);
    std::string v48 = 0;
    uint64_t v17 = (char *)operator new(0x60uLL);
    uint64_t v18 = v29;
    *(void *)uint64_t v17 = off_101A39608;
    *((void *)v17 + 1) = v18;
    v17[16] = v30;
    *(_OWORD *)(v17 + 24) = v31;
    long long v31 = 0uLL;
    *(_OWORD *)(v17 + 4sub_1001A7358((uint64_t)&a9, 0) = __p;
    *((void *)v17 + 7) = v33;
    long long __p = 0uLL;
    uint64_t v33 = 0;
    long long v19 = v35;
    *((_OWORD *)v17 + 4) = v34;
    *((_OWORD *)v17 + 5) = v19;
    std::string v48 = v17;
    sub_100ACDED8((void *)v8, (uint64_t)buf, (uint64_t)&v36, (uint64_t)v47);
    sub_100A86C00(v47);
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__p);
    }
    if (*((void *)&v31 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
    }
    if (v36)
    {
      long long v37 = v36;
      operator delete(v36);
    }
    if (SHIBYTE(v42) < 0) {
      operator delete(*(void **)buf);
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    goto LABEL_39;
  }
  uint64_t v14 = *(NSObject **)(v8 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(v15 + 336);
  if (v16)
  {
    sub_100AD1C50(v16, (uint64_t)buf, 0);
    sub_100ADA588((void *)(v15 + 312));
  }
LABEL_26:
  uint64_t v46 = buf;
  sub_1000C63B8((void ***)&v46);
  sub_100058DB0(buf, "CheckAvailableOptions");
  sub_1000E9358((uint64_t **)(v8 + 160), (void **)buf);
  if (SHIBYTE(v42) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_39:
  if (v43)
  {
    __n128 v44 = v43;
    operator delete(v43);
  }
  if (v23) {
    sub_10010C0E0((uint64_t)&v20, v21);
  }
  if (v26 && v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
}

void sub_100ADA430(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39)
{
  if (a27) {
    sub_10004D2C8(a27);
  }
  if (__p)
  {
    a39 = (uint64_t)__p;
    operator delete(__p);
  }
  if (*(char *)(v40 - 121) < 0) {
    operator delete(*(void **)(v40 - 144));
  }
  if (v39) {
    sub_10004D2C8(v39);
  }
  uint64_t v42 = *(void **)(v40 - 120);
  if (v42)
  {
    *(void *)(v40 - 112) = v42;
    operator delete(v42);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ADA53C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADA57C()
{
}

void *sub_100ADA588(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100ADA610(uint64_t a1)
{
  *(void *)a1 = off_101A39608;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADA66C(uint64_t a1)
{
  *(void *)a1 = off_101A39608;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100ADA6E8(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  *uint64_t v2 = off_101A39608;
  sub_100ADB39C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADA73C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADA750(uint64_t a1, void *a2)
{
  *a2 = off_101A39608;
  return sub_100ADB39C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100ADA77C(uint64_t a1)
{
}

void sub_100ADA784(void *a1)
{
  sub_100ADB440((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADA7C0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  BOOL v6 = (os_log_t *)(v5 + 40);
  v97[0] = v4;
  v97[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v7 = sub_100AD49C0((os_log_t *)(v5 + 40), v97);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v7)
  {
    long long __p = 0;
    uint64_t v95 = 0;
    uint64_t v96 = 0;
    CFArrayRef v91 = 0;
    CFArrayRef v92 = 0;
    uint64_t v93 = 0;
    CFArrayRef v88 = 0;
    CFArrayRef v89 = 0;
    unint64_t v90 = 0;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v87, v4);
    BOOL v8 = sub_100A984CC(&v87, (uint64_t)&__p, (uint64_t *)&v91);
    sub_100030068(&v87);
    if (!v8)
    {
      uint64_t v20 = *v6;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E Invalid carrier option response", buf, 2u);
      }
      memset(buf, 0, 24);
      uint64_t v21 = *(void *)(a1 + 80);
      uint64_t v22 = *(void *)(v21 + 336);
      if (v22)
      {
        sub_100AD1C50(v22, (uint64_t)buf, 0);
        sub_100ADA588((void *)(v21 + 312));
      }
      goto LABEL_34;
    }
    uint64_t v9 = (void *)(a1 + 40);
    char v10 = *(unsigned char *)(a1 + 63);
    if (v10 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 63);
    }
    else {
      uint64_t v11 = *(void *)(a1 + 48);
    }
    uint64_t v12 = HIBYTE(v96);
    int v13 = SHIBYTE(v96);
    if (v96 < 0) {
      uint64_t v12 = v95;
    }
    if (v11 != v12) {
      goto LABEL_31;
    }
    if (v96 >= 0) {
      p_p = (unsigned __int8 *)&__p;
    }
    else {
      p_p = (unsigned __int8 *)__p;
    }
    if ((*(unsigned char *)(a1 + 63) & 0x80) != 0)
    {
      uint64_t v9 = (void *)*v9;
      if (memcmp(v9, p_p, *(void *)(a1 + 48)))
      {
        char v23 = *v6;
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
        goto LABEL_145;
      }
    }
    else if (*(unsigned char *)(a1 + 63))
    {
      uint64_t v15 = (unsigned __int8 *)(a1 + 40);
      uint64_t v16 = *(unsigned __int8 *)(a1 + 63);
      while (*v15 == *p_p)
      {
        ++v15;
        ++p_p;
        if (!--v16) {
          goto LABEL_46;
        }
      }
LABEL_31:
      char v23 = *v6;
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_32;
      }
      if (v10 < 0) {
        uint64_t v9 = (void *)*v9;
      }
      if (v13 >= 0) {
        p_p = (unsigned __int8 *)&__p;
      }
      else {
        p_p = (unsigned __int8 *)__p;
      }
LABEL_145:
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = p_p;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Mismatching session id [%s] expecting [%s]", buf, 0x16u);
LABEL_32:
      memset(buf, 0, 24);
      uint64_t v24 = *(void *)(a1 + 80);
      uint64_t v25 = *(void *)(v24 + 336);
      if (v25)
      {
        sub_100AD1C50(v25, (uint64_t)buf, 0);
        sub_100ADA588((void *)(v24 + 312));
      }
LABEL_34:
      *(void *)CFArrayRef v98 = buf;
      sub_1000C63B8((void ***)v98);
      sub_100058DB0(buf, "CheckAvailableOptions");
      sub_1000E9358((uint64_t **)(v5 + 160), (void **)buf);
      if (((char)buf[23] & 0x80000000) == 0)
      {
LABEL_37:
        *(void *)CFArrayRef v98 = &v88;
        sub_1000C63B8((void ***)v98);
        CFArrayRef v88 = &v91;
        sub_1000C63B8((void ***)&v88);
        if ((SHIBYTE(v96) & 0x80000000) == 0) {
          goto LABEL_40;
        }
        long long v19 = __p;
        goto LABEL_39;
      }
      char v26 = *(void **)buf;
LABEL_36:
      operator delete(v26);
      goto LABEL_37;
    }
LABEL_46:
    *(CFAbsoluteTime *)(v5 + 272) = CFAbsoluteTimeGetCurrent() + 900.0;
    uint64_t v28 = v91;
    uint64_t v27 = v92;
    uint64_t v29 = *(std::__shared_weak_count **)(v5 + 80);
    if (v29)
    {
      char v30 = std::__shared_weak_count::lock(v29);
      if (v30)
      {
        long long v31 = v30;
        uint64_t v32 = *(void *)(v5 + 72);
        if (v32)
        {
          uint64_t v83 = v28;
          CFArrayRef v85 = v27;
          long long v34 = v91;
          uint64_t v33 = v92;
          while (v34 != v33)
          {
            if (SHIBYTE(v34[3].__r_.__value_.__r.__words[2]) < 0)
            {
              int data = (std::string *)v34[3].__r_.__value_.__l.__data_;
              std::string::size_type size = v34[3].__r_.__value_.__l.__size_;
            }
            else
            {
              int data = v34 + 3;
              std::string::size_type size = HIBYTE(v34[3].__r_.__value_.__r.__words[2]);
            }
            long long v37 = (std::string *)((char *)data + size);
            while (data != v37)
            {
              data->__r_.__value_.__s.__data_[0] = __tolower(data->__r_.__value_.__s.__data_[0]);
              int data = (std::string *)((char *)data + 1);
            }
            v34 += 13;
          }
          (*(void (**)(uint64_t, std::string **))(*(void *)v32 + 56))(v32, &v91);
          uint64_t v28 = v83;
          uint64_t v27 = v85;
        }
        sub_10004D2C8(v31);
      }
    }
    uint64_t v38 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349312;
      *(void *)&uint8_t buf[4] = 0x6F96F96F96F96F97 * (((char *)v92 - (char *)v91) >> 3);
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(void *)&buf[14] = 0x6F96F96F96F96F97 * (((char *)v27 - (char *)v28) >> 3);
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I checkForProfiles_sync: Found %{public}lu SMDP+ servers. Before filtering: %{public}lu", buf, 0x16u);
    }
    if ((std::string **)(v5 + 288) != &v91) {
      sub_100ADB494(v5 + 288, v91, v92, 0x6F96F96F96F96F97 * (((char *)v92 - (char *)v91) >> 3));
    }
    uint64_t v39 = *(void *)(a1 + 64);
    (*(void (**)(void, std::string **))(**(void **)(v39 + 88) + 96))(*(void *)(v39 + 88), &v91);
    (*(void (**)(void, std::string **))(**(void **)(v39 + 88) + 104))(*(void *)(v39 + 88), &v91);
    memset(buf, 0, 24);
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v39 + 88) + 136))(buf);
    if (*(void *)buf != *(void *)&buf[8]
      && (uint64_t v40 = *(std::__shared_weak_count **)(v39 + 80)) != 0
      && (uint64_t v41 = std::__shared_weak_count::lock(v40)) != 0)
    {
      uint64_t v42 = *(void *)(v39 + 72);
      if (!v42 || (uint64_t v43 = *(void *)&buf[8], *(void *)buf == *(void *)&buf[8]))
      {
        int v48 = 0;
      }
      else
      {
        CFArrayRef v84 = v41;
        uint64_t v44 = *(void *)buf + 72;
        do
        {
          uint64_t v45 = *(NSObject **)(v39 + 40);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v46 = v44;
            if (*(char *)(v44 + 23) < 0) {
              uint64_t v46 = *(void *)v44;
            }
            *(_DWORD *)CFArrayRef v98 = 136315138;
            *(void *)&v98[4] = v46;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Auto fetching consented pending profile (%s)", v98, 0xCu);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v42 + 72))(v42, v44 - 72);
          uint64_t v47 = v44 + 240;
          v44 += 312;
        }
        while (v47 != v43);
        int v48 = 1;
        uint64_t v41 = v84;
      }
      sub_10004D2C8(v41);
    }
    else
    {
      int v48 = 0;
    }
    *(void *)CFArrayRef v98 = buf;
    sub_1000C63B8((void ***)v98);
    CFTypeID v49 = *(void **)(a1 + 88);
    CFIndex v50 = (std::__shared_weak_count *)v49[10];
    if (v50)
    {
      BOOL v51 = std::__shared_weak_count::lock(v50);
      if (v51)
      {
        char v52 = v51;
        int v86 = v48;
        uint64_t v53 = v49[9];
        if (v53)
        {
          int v54 = (*(uint64_t (**)(void))(*(void *)v53 + 80))(v49[9]);
          unint64_t v55 = (capabilities::euicc *)(*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
          if (((v54 | v55) & 1) != 0 || (capabilities::euicc::supportsInstallReplace(v55) & 1) == 0)
          {
            uint64_t v56 = v91;
            unint64_t v57 = (long long *)v92;
            if (v91 != v92)
            {
              do
              {
                std::string::size_type v58 = HIBYTE(v56[4].__r_.__value_.__r.__words[2]);
                int v59 = (char)v58;
                if ((v58 & 0x80u) != 0) {
                  std::string::size_type v58 = v56[4].__r_.__value_.__l.__size_;
                }
                if (v58 == 4
                  && (v59 >= 0 ? (int v60 = v56 + 4) : (int v60 = (std::string *)v56[4].__r_.__value_.__l.__data_),
                      LODWORD(v60->__r_.__value_.__l.__data_) == 825241653))
                {
                  uint64_t v61 = v49[5];
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Removing Install and Replace plan", buf, 2u);
                    unint64_t v57 = (long long *)v92;
                  }
                  sub_10031010C((long long *)&v56[13], v57, (uint64_t)v56);
                  unint64_t v57 = v62;
                  for (uint64_t i = (long long *)v92; i != v57; sub_1000C643C((uint64_t)i))
                    uint64_t i = (long long *)((char *)i - 312);
                  CFArrayRef v92 = (std::string *)v57;
                }
                else
                {
                  v56 += 13;
                }
              }
              while (v56 != (std::string *)v57);
            }
          }
        }
        sub_10004D2C8(v52);
        int v48 = v86;
      }
    }
    if (*(void *)(*(void *)(a1 + 72) + 336))
    {
      CFNumberRef v64 = v91;
      Class v65 = (long long *)v92;
      if (v91 != v92)
      {
        do
        {
          if (v64[5].__r_.__value_.__s.__data_[1]) {
            goto LABEL_105;
          }
          std::string::size_type v66 = HIBYTE(v64[4].__r_.__value_.__r.__words[2]);
          int v67 = (char)v66;
          if ((v66 & 0x80u) != 0) {
            std::string::size_type v66 = v64[4].__r_.__value_.__l.__size_;
          }
          if (v66 == 4
            && (v67 >= 0 ? (CFNumberRef v68 = v64 + 4) : (CFNumberRef v68 = (std::string *)v64[4].__r_.__value_.__l.__data_),
                LODWORD(v68->__r_.__value_.__l.__data_) == 825241653))
          {
LABEL_105:
            v64 += 13;
          }
          else
          {
            char v69 = v89;
            if ((unint64_t)v89 >= v90)
            {
              char v70 = (char *)sub_10033D0C4((uint64_t *)&v88, (long long *)v64);
            }
            else
            {
              sub_10030C34C(v89, (long long *)v64);
              char v70 = v69 + 312;
            }
            CFArrayRef v89 = v70;
            sub_10031010C((long long *)&v64[13], (long long *)v92, (uint64_t)v64);
            Class v65 = v71;
            for (CFIndex j = (long long *)v92; j != v65; sub_1000C643C((uint64_t)j))
              CFIndex j = (long long *)((char *)j - 312);
            CFArrayRef v92 = (std::string *)v65;
          }
        }
        while (v64 != (std::string *)v65);
      }
    }
    if (*(void *)(v5 + 336))
    {
      uint64_t v73 = *(void *)(a1 + 80);
      uint64_t v74 = *(void *)(v73 + 336);
      if (v74)
      {
        if (v48) {
          BOOL v75 = 0;
        }
        else {
          BOOL v75 = v92 == v91;
        }
        char v76 = !v75;
        sub_100AD1C50(v74, (uint64_t)&v88, v76);
        sub_100ADA588((void *)(v73 + 312));
      }
    }
    if (v92 != v91)
    {
      __int16 v77 = *(std::__shared_weak_count **)(v5 + 80);
      if (v77)
      {
        uint64_t v78 = std::__shared_weak_count::lock(v77);
        if (v78)
        {
          unint64_t v79 = v78;
          uint64_t v80 = *(void *)(v5 + 72);
          if (v80)
          {
            uint64_t v81 = *v6;
            if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I Auto install pending ODA plans", buf, 2u);
            }
            uint64_t v82 = *(unsigned __int8 *)(a1 + 16);
            buf[0] = 0;
            buf[176] = 0;
            (*(void (**)(uint64_t, uint64_t, std::string **, uint8_t *, void))(*(void *)v80 + 16))(v80, v82, &v91, buf, 0);
            sub_10030AEBC((uint64_t)buf);
          }
          sub_10004D2C8(v79);
        }
      }
    }
    sub_100058DB0(v98, "CheckAvailableOptions");
    sub_1000E9358((uint64_t **)(v5 + 160), (void **)v98);
    if ((v99 & 0x80000000) == 0) {
      goto LABEL_37;
    }
    char v26 = *(void **)v98;
    goto LABEL_36;
  }
  memset(buf, 0, 24);
  uint64_t v17 = *(void *)(a1 + 80);
  uint64_t v18 = *(void *)(v17 + 336);
  if (v18)
  {
    sub_100AD1C50(v18, (uint64_t)buf, 0);
    sub_100ADA588((void *)(v17 + 312));
  }
  long long __p = buf;
  sub_1000C63B8((void ***)&__p);
  sub_100058DB0(buf, "CheckAvailableOptions");
  sub_1000E9358((uint64_t **)(v5 + 160), (void **)buf);
  if ((char)buf[23] < 0)
  {
    long long v19 = *(void **)buf;
LABEL_39:
    operator delete(v19);
  }
LABEL_40:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100ADB204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, char *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,char **a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  sub_10030AEBC((uint64_t)&a35);
  sub_10004D2C8(v41);
  a28 = &a14;
  sub_1000C63B8((void ***)&a28);
  a14 = &a17;
  sub_1000C63B8((void ***)&a14);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ADB350(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADB390()
{
}

uint64_t sub_100ADB39C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  uint64_t v5 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v6 = (unsigned char *)(a1 + 32);
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84(v6, (void *)a2[4], a2[5]);
  }
  else
  {
    long long v7 = *((_OWORD *)a2 + 2);
    *(void *)(a1 + 48) = a2[6];
    *(_OWORD *)BOOL v6 = v7;
  }
  long long v8 = *(_OWORD *)(a2 + 7);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 9);
  *(_OWORD *)(a1 + 56) = v8;
  return a1;
}

void sub_100ADB428(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ADB440(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100ADB494(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(std::string **)a1;
  if (0x6F96F96F96F96F97 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_100ADB634((void **)a1);
    if (a4 > 0xD20D20D20D20D2) {
      sub_10006A748();
    }
    unint64_t v10 = 0xDF2DF2DF2DF2DF2ELL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x6F96F96F96F96F97 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x69069069069069) {
      unint64_t v11 = 0xD20D20D20D20D2;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10030C224((void *)a1, v11);
    uint64_t v12 = sub_10030C2C8(v8, (uint64_t)__str, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x6F96F96F96F96F97 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    int v13 = (std::string *)((char *)__str + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3));
    sub_100ADB69C((int)&v17, __str, v13, v9);
    uint64_t v12 = sub_10030C2C8(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_100ADB69C((int)&v18, __str, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 312;
      sub_1000C643C(v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_100ADB624(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100ADB62C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100ADB634(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 312;
        sub_1000C643C(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

std::string *sub_100ADB69C(int a1, std::string *__str, std::string *a3, std::string *this)
{
  uint64_t v5 = __str;
  if (__str == a3) {
    return __str;
  }
  BOOL v6 = a3;
  do
  {
    std::string::operator=(this, v5);
    std::string::operator=(this + 1, v5 + 1);
    std::string::operator=(this + 2, v5 + 2);
    std::string::operator=(this + 3, v5 + 3);
    std::string::operator=(this + 4, v5 + 4);
    LOWORD(this[5].__r_.__value_.__l.__data_) = v5[5].__r_.__value_.__l.__data_;
    sub_1003262CC((std::string *)((char *)this + 128), (std::string *)((char *)v5 + 128));
    this += 13;
    v5 += 13;
  }
  while (v5 != v6);
  return v6;
}

void *sub_100ADB744(void *a1)
{
  *a1 = off_101A39698;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADB790(void *a1)
{
  *a1 = off_101A39698;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_100ADB7FC(uint64_t a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A39698;
  result[1] = v3;
  *((unsigned char *)result + 16) = *(unsigned char *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100ADB864(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A39698;
  uint64_t v2 = *(void *)(result + 8);
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ADB8AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100ADB8BC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100ADB8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)long long v31 = *(_OWORD *)a2;
  uint64_t v32 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(v28[0]) = 0;
  char v30 = 0;
  int v5 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v28 = *(_OWORD *)a3;
    uint64_t v29 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v30 = 1;
  }
  LOBYTE(v24) = 0;
  char v27 = 0;
  int v6 = *(unsigned __int8 *)(a4 + 24);
  if (*(unsigned char *)(a4 + 24))
  {
    long long v7 = (void *)(a4 + 8);
    uint64_t v8 = *(void **)(a4 + 8);
    uint64_t v24 = *(void ***)a4;
    uint64_t v25 = v8;
    if (*(void *)(a4 + 16))
    {
      uint64_t v8[2] = &v25;
      *(void *)a4 = v7;
      void *v7 = 0;
      *(void *)(a4 + 16) = 0;
    }
    else
    {
      uint64_t v24 = &v25;
    }
    char v27 = 1;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  unint64_t v11 = *(void **)(v9 + 344);
  unint64_t v10 = *(void **)(v9 + 352);
  if (v11 == v10)
  {
    uint64_t v16 = *(NSObject **)(v9 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "No handoff callback", buf, 2u);
    }
    sub_100058DB0(buf, "RequestHandoff");
    sub_1000E9358((uint64_t **)(v9 + 160), (void **)buf);
  }
  else
  {
    if (v5 && v6)
    {
      if (sub_100A9D290(*(unsigned __int8 *)(a1 + 16), (uint64_t *)v31, v28, (uint64_t)&v39))
      {
        uint64_t v12 = *(std::__shared_weak_count **)(v9 + 64);
        v36[0] = *(void *)(v9 + 56);
        v36[1] = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v27) {
          sub_10016C840();
        }
        sub_100AD5CE8((uint64_t)v37, (uint64_t)v36, "RequestHandoff", (uint64_t)&v24);
        long long __p = 0;
        long long v34 = 0;
        uint64_t v35 = 0;
        sub_10005C928(&__p, v39, (uint64_t)v40, v40 - (unsigned char *)v39);
        uint64_t v14 = *(void *)(a1 + 24);
        uint64_t v13 = *(void *)(a1 + 32);
        if (v13) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v44 = 0;
        uint64_t v15 = operator new(0x20uLL);
        void *v15 = off_101A39708;
        v15[1] = v9;
        uint64_t v15[2] = v14;
        _OWORD v15[3] = v13;
        uint64_t v44 = v15;
        sub_100ACDED8((void *)v9, (uint64_t)v37, (uint64_t)&__p, (uint64_t)buf);
        sub_100A86C00(buf);
        if (__p)
        {
          long long v34 = __p;
          operator delete(__p);
        }
        if (v38 < 0) {
          operator delete(v37[0]);
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
        goto LABEL_54;
      }
      uint64_t v20 = *(NSObject **)(v9 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
      }
      unint64_t v10 = *(void **)(v9 + 344);
      uint64_t v21 = *(void **)(v9 + 352);
      if (v10 != v21)
      {
        do
        {
          sub_100058DB0(buf, "");
          sub_100058DB0(v37, "");
          uint64_t v22 = v10[3];
          if (!v22) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v22 + 48))(v22, buf, v37);
          if (v38 < 0) {
            operator delete(v37[0]);
          }
          if (v43 < 0) {
            operator delete(*(void **)buf);
          }
          v10 += 4;
        }
        while (v10 != v21);
        char v23 = *(void **)(v9 + 344);
        unint64_t v10 = *(void **)(v9 + 352);
        if (v10 != v23)
        {
          do
          {
            v10 -= 4;
            sub_100333DB8(v10);
          }
          while (v10 != v23);
          unint64_t v10 = v23;
        }
      }
    }
    else
    {
      char v17 = *(NSObject **)(v9 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
        unint64_t v11 = *(void **)(v9 + 344);
        unint64_t v10 = *(void **)(v9 + 352);
      }
      if (v11 != v10)
      {
        do
        {
          sub_100058DB0(buf, "");
          sub_100058DB0(v37, "");
          uint64_t v18 = v11[3];
          if (!v18) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v18 + 48))(v18, buf, v37);
          if (v38 < 0) {
            operator delete(v37[0]);
          }
          if (v43 < 0) {
            operator delete(*(void **)buf);
          }
          v11 += 4;
        }
        while (v11 != v10);
        long long v19 = *(void **)(v9 + 344);
        unint64_t v10 = *(void **)(v9 + 352);
        if (v10 != v19)
        {
          do
          {
            v10 -= 4;
            sub_100333DB8(v10);
          }
          while (v10 != v19);
          unint64_t v10 = v19;
        }
      }
    }
    *(void *)(v9 + 352) = v10;
    sub_100058DB0(buf, "RequestHandoff");
    sub_1000E9358((uint64_t **)(v9 + 160), (void **)buf);
  }
  if (v43 < 0) {
    operator delete(*(void **)buf);
  }
LABEL_54:
  if (v39)
  {
    uint64_t v40 = v39;
    operator delete(v39);
  }
  if (v27) {
    sub_10010C0E0((uint64_t)&v24, v25);
  }
  if (v30 && v28[0])
  {
    v28[1] = v28[0];
    operator delete(v28[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
}

void sub_100ADBE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *__p, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 73) < 0) {
    operator delete(*(void **)(v33 - 96));
  }
  uint64_t v35 = *(void **)(v33 - 120);
  if (v35)
  {
    *(void *)(v33 - 112) = v35;
    operator delete(v35);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && __p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ADBF20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADBF60()
{
}

void *sub_100ADBF6C(void *a1)
{
  *a1 = off_101A39708;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADBFB8(void *a1)
{
  *a1 = off_101A39708;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100ADC024(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A39708;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100ADC088(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A39708;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ADC0C8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100ADC0D8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100ADC118(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = (os_log_t *)(v4 + 40);
  if (*(void *)(v4 + 344) != *(void *)(v4 + 352))
  {
    v19[0] = v3;
    v19[1] = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v6 = sub_100AD49C0((os_log_t *)(v4 + 40), v19);
    if (v2) {
      sub_10004D2C8(v2);
    }
    if (v6)
    {
      (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v3 + 40))(&v18, v3);
      BOOL v7 = sub_100A9D474(&v18, v4 + 184, v4 + 208);
      sub_100030068(&v18);
      if (v7) {
        goto LABEL_14;
      }
      uint64_t v8 = *v5;
      if (!os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v9 = "Failed to decode handoff response";
    }
    else
    {
      uint64_t v8 = *v5;
      if (!os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
LABEL_14:
        unint64_t v11 = *v5;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = (void *)(v4 + 184);
          if (*(char *)(v4 + 207) < 0) {
            uint64_t v12 = (void *)*v12;
          }
          uint64_t v13 = (void *)(v4 + 208);
          if (*(char *)(v4 + 231) < 0) {
            uint64_t v13 = (void *)*v13;
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v21 = 2080;
          uint64_t v22 = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Handoff [%s] pod [%s]", buf, 0x16u);
        }
        uint64_t v14 = *(void **)(v4 + 344);
        uint64_t v15 = *(void **)(v4 + 352);
        if (v14 != v15)
        {
          do
          {
            uint64_t v16 = v14[3];
            if (!v16) {
              sub_10007B600();
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 48))(v16, v4 + 184, v4 + 208);
            v14 += 4;
          }
          while (v14 != v15);
          char v17 = *(void **)(v4 + 344);
          uint64_t v14 = *(void **)(v4 + 352);
          if (v14 != v17)
          {
            do
            {
              v14 -= 4;
              sub_100333DB8(v14);
            }
            while (v14 != v17);
            uint64_t v14 = v17;
          }
        }
        *(void *)(v4 + 352) = v14;
        sub_100058DB0(buf, "RequestHandoff");
        sub_1000E9358((uint64_t **)(v4 + 160), (void **)buf);
        goto LABEL_27;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v9 = "Invalid handoff response";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
    goto LABEL_14;
  }
  unint64_t v10 = *v5;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No handoff callbacks", buf, 2u);
  }
  sub_100058DB0(buf, "RequestHandoff");
  sub_1000E9358((uint64_t **)(v4 + 160), (void **)buf);
LABEL_27:
  if (v23 < 0) {
    operator delete(*(void **)buf);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100ADC410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_100030068(&a10);
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ADC46C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADC4AC()
{
}

uint64_t sub_100ADC4B8(uint64_t a1)
{
  *(void *)a1 = off_101A39798;
  sub_100060644((void *)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(void *)(a1 + 48) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100ADC538(uint64_t a1)
{
  *(void *)a1 = off_101A39798;
  sub_100060644((void *)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(void *)(a1 + 48) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100ADC5D8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x88uLL);
  *uint64_t v2 = off_101A39798;
  sub_100ADCD7C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADC62C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADC640(uint64_t a1, void *a2)
{
  *a2 = off_101A39798;
  return sub_100ADCD7C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100ADC66C(uint64_t a1)
{
}

void sub_100ADC674(void *a1)
{
  sub_100ADCEB4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADC6B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  BOOL v6 = *(void **)a2;
  int v7 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  LOBYTE(v35[0]) = 0;
  char v37 = 0;
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)uint64_t v35 = *(_OWORD *)a3;
    uint64_t v36 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v37 = 1;
  }
  LOBYTE(v31) = 0;
  char v34 = 0;
  if (*(unsigned char *)(a4 + 24))
  {
    uint64_t v8 = (void *)(a4 + 8);
    uint64_t v9 = *(void **)(a4 + 8);
    long long v31 = *(void ***)a4;
    uint64_t v32 = v9;
    if (*(void *)(a4 + 16))
    {
      v9[2] = &v32;
      *(void *)a4 = v8;
      *uint64_t v8 = 0;
      *(void *)(a4 + 16) = 0;
    }
    else
    {
      long long v31 = &v32;
    }
    char v34 = 1;
  }
  int v10 = *a5;
  uint64_t v11 = a1[1];
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  (***(void (****)(uint8_t *__return_ptr))(v11 + 56))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)buf);
  uint64_t v14 = ServiceMap;
  if ((v15 & 0x8000000000000000) != 0)
  {
    uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  v51[0] = v15;
  long long v19 = sub_10004D37C(&v14[1].__m_.__sig, v51);
  if (v19)
  {
    uint64_t v21 = v19[3];
    uint64_t v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v20 = 0;
  char v22 = 1;
LABEL_16:
  if (v48) {
    sub_10004D2C8(v48);
  }
  if (!v21
    || (int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 152))(v21), LOBYTE(v21) = v23 == 1, !v10)
    || v23 != 1)
  {
    if (v37 && v34)
    {
      if (sub_100A9BB04(a1 + 2, a1 + 5, v35, a1 + 8, (uint64_t)&v44))
      {
        uint64_t v25 = *(std::__shared_weak_count **)(v11 + 64);
        v41[0] = *(void *)(v11 + 56);
        v41[1] = v25;
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v34) {
          sub_10016C840();
        }
        sub_100AD5CE8((uint64_t)v42, (uint64_t)v41, "ProfileEligibilityCheck", (uint64_t)&v31);
        long long __p = 0;
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        sub_10005C928(&__p, v44, (uint64_t)v45, v45 - (unsigned char *)v44);
        *(void *)long long buf = v11;
        LOBYTE(v48) = v21;
        uint64_t v26 = a1[12];
        *(void *)&long long v49 = a1[11];
        *((void *)&v49 + 1) = v26;
        if (v26) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
        }
        sub_1000DFC90((uint64_t)v50, (uint64_t)(a1 + 13));
        char v52 = 0;
        char v27 = (char *)operator new(0x48uLL);
        uint64_t v28 = *(Registry **)buf;
        *(void *)char v27 = off_101A39808;
        *((void *)v27 + 1) = v28;
        v27[16] = (char)v48;
        *(_OWORD *)(v27 + 24) = v49;
        long long v49 = 0uLL;
        sub_100023950((uint64_t)(v27 + 40), (uint64_t)v50);
        char v52 = v27;
        sub_100ACDED8((void *)v11, (uint64_t)v42, (uint64_t)&__p, (uint64_t)v51);
        sub_100A86C00(v51);
        sub_100060644(v50);
        if (*((void *)&v49 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v49 + 1));
        }
        if (__p)
        {
          uint64_t v39 = __p;
          operator delete(__p);
        }
        if (v43 < 0)
        {
          operator delete(v42[0]);
          if (!v25) {
            goto LABEL_46;
          }
        }
        else if (!v25)
        {
LABEL_46:
          if (v22) {
            goto LABEL_48;
          }
          goto LABEL_47;
        }
        sub_10004D2C8(v25);
        if (v22) {
          goto LABEL_48;
        }
LABEL_47:
        sub_10004D2C8(v20);
        goto LABEL_48;
      }
      char v30 = *(NSObject **)(v11 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
      }
    }
    else
    {
      uint64_t v29 = *(NSObject **)(v11 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
      }
    }
    sub_1000607A8((uint64_t)(a1 + 13), 0);
    sub_100058DB0(buf, "ProfileEligibilityCheck");
    sub_1000E9358((uint64_t **)(v11 + 160), (void **)buf);
    goto LABEL_45;
  }
  uint64_t v24 = *(NSObject **)(v11 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Create session soft failure detected, skipping device eligibility check", buf, 2u);
  }
  sub_1000607A8((uint64_t)(a1 + 13), 1);
  sub_100058DB0(buf, "ProfileEligibilityCheck");
  sub_1000E9358((uint64_t **)(v11 + 160), (void **)buf);
LABEL_45:
  if ((SBYTE7(v49) & 0x80000000) == 0) {
    goto LABEL_46;
  }
  operator delete(*(void **)buf);
  if ((v22 & 1) == 0) {
    goto LABEL_47;
  }
LABEL_48:
  if (v44)
  {
    uint64_t v45 = v44;
    operator delete(v44);
  }
  if (v34) {
    sub_10010C0E0((uint64_t)&v31, v32);
  }
  if (v37 && v35[0])
  {
    v35[1] = v35[0];
    operator delete(v35[0]);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
}

void sub_100ADCC0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,std::__shared_weak_count *a38)
{
  sub_100A86C00((void *)(v44 - 128));
  sub_100060644(v41);
  if (a38) {
    sub_10004D2C8(a38);
  }
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v42 < 0) {
    operator delete(v38);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ADCD30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADCD70()
{
}

uint64_t sub_100ADCD7C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  sub_10005C928((void *)(a1 + 32), *(const void **)(a2 + 32), *(void *)(a2 + 40), *(void *)(a2 + 40) - *(void *)(a2 + 32));
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 96, a2 + 96);
  return a1;
}

void sub_100ADCE5C(_Unwind_Exception *exception_object)
{
  long long v5 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 4sub_1001A7358((uint64_t)&a9, 0) = v5;
    operator delete(v5);
  }
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ADCEB4(uint64_t a1)
{
  sub_100060644((void *)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    long long v4 = *(void **)(a1 + 8);
    operator delete(v4);
  }
}

void *sub_100ADCF30(void *a1)
{
  *a1 = off_101A39808;
  sub_100060644(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADCF80(void *a1)
{
  *a1 = off_101A39808;
  sub_100060644(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100ADCFF0(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A39808;
  sub_100ADD47C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADD044(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADD058(uint64_t a1, void *a2)
{
  *a2 = off_101A39808;
  return sub_100ADD47C((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100ADD084(uint64_t a1)
{
}

void sub_100ADD08C(void *a1)
{
  sub_100AD8808((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADD0C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (os_log_t *)(v5 + 40);
  v24[0] = v4;
  v24[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v7 = sub_100AD49C0((os_log_t *)(v5 + 40), v24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (!v7)
  {
    uint64_t v16 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v22 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Eligibility check error", v22, 2u);
      if (!v4) {
        goto LABEL_29;
      }
    }
    else if (!v4)
    {
      goto LABEL_29;
    }
    int v17 = *(unsigned __int8 *)(a1 + 16);
    int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    if (v17 && (v18 < 1 || v18 == 500 || v18 == 400))
    {
      long long v19 = *v6;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)char v22 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Skipping device eligibility check", v22, 2u);
      }
      char v20 = 1;
      goto LABEL_30;
    }
LABEL_29:
    char v20 = 0;
LABEL_30:
    sub_1000607A8(a1 + 40, v20);
    sub_100058DB0(v22, "ProfileEligibilityCheck");
    sub_1000E9358((uint64_t **)(v5 + 160), (void **)v22);
LABEL_31:
    if (SBYTE7(v23) < 0) {
      operator delete(*(void **)v22);
    }
    goto LABEL_33;
  }
  *(_OWORD *)char v22 = 0u;
  long long v23 = 0u;
  (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v21, v4);
  char v8 = sub_100A9BDB4(&v21, (uint64_t)v22, *(unsigned __int8 *)(a1 + 16));
  sub_100030068(&v21);
  if (v8) {
    goto LABEL_24;
  }
  int v9 = BYTE8(v23);
  int v10 = *v6;
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (!v11) {
      goto LABEL_24;
    }
    uint64_t v12 = v22;
    if (SBYTE7(v23) < 0) {
      uint64_t v12 = *(uint8_t **)v22;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    uint64_t v13 = "#I Profile ineligible, %s";
    uint64_t v14 = v10;
    uint32_t v15 = 12;
  }
  else
  {
    if (!v11) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v13 = "#I Profile ineligible with empty description";
    uint64_t v14 = v10;
    uint32_t v15 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
LABEL_24:
  sub_1000607A8(a1 + 40, v8);
  sub_100058DB0(buf, "ProfileEligibilityCheck");
  sub_1000E9358((uint64_t **)(v5 + 160), (void **)buf);
  if (v26 < 0) {
    operator delete(*(void **)buf);
  }
  if (BYTE8(v23)) {
    goto LABEL_31;
  }
LABEL_33:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100ADD3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ADD430(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADD470()
{
}

uint64_t sub_100ADD47C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v3;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 32, (uint64_t)(a2 + 4));
  return a1;
}

void sub_100ADD4D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ADD4EC(uint64_t a1)
{
  *(void *)a1 = off_101A39898;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v4 = (void **)(a1 + 40);
  sub_10030B640(&v4);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100ADD570(uint64_t a1)
{
  *(void *)a1 = off_101A39898;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v3 = (void **)(a1 + 40);
  sub_10030B640(&v3);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  operator delete();
}

void *sub_100ADD608(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  *uint64_t v2 = off_101A39898;
  sub_100ADDD20((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADD65C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADD670(uint64_t a1, void *a2)
{
  *a2 = off_101A39898;
  return sub_100ADDD20((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100ADD69C(uint64_t a1)
{
}

void sub_100ADD6A4(void *a1)
{
  sub_100ADDE24((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADD6E0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void **)a2;
  int v6 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  LOBYTE(v27[0]) = 0;
  char v29 = 0;
  int v7 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)char v27 = *(_OWORD *)a3;
    uint64_t v28 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v29 = 1;
  }
  LOBYTE(v23) = 0;
  char v26 = 0;
  int v8 = *(unsigned __int8 *)(a4 + 24);
  if (*(unsigned char *)(a4 + 24))
  {
    int v9 = (void *)(a4 + 8);
    int v10 = *(void **)(a4 + 8);
    long long v23 = *(void ***)a4;
    uint64_t v24 = v10;
    if (*(void *)(a4 + 16))
    {
      void v10[2] = &v24;
      *(void *)a4 = v9;
      void *v9 = 0;
      *(void *)(a4 + 16) = 0;
    }
    else
    {
      long long v23 = &v24;
    }
    char v26 = 1;
  }
  uint64_t v11 = a1[1];
  uint64_t v12 = *(void *)(v11 + 392);
  if (!v12)
  {
    int v18 = *(NSObject **)(v11 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No PreFlightEligibilityCheck callback", buf, 2u);
    }
    sub_100058DB0(buf, "PreFlightEligibilityCheck");
    sub_1000E9358((uint64_t **)(v11 + 160), (void **)buf);
    if ((SHIBYTE(v42) & 0x80000000) == 0) {
      goto LABEL_40;
    }
    long long v19 = *(void **)buf;
LABEL_39:
    operator delete(v19);
    goto LABEL_40;
  }
  if (!v7 || !v8)
  {
    char v20 = *(NSObject **)(v11 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
      uint64_t v12 = *(void *)(v11 + 392);
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      *(void *)long long buf = &v41;
      if (!v12) {
        sub_10007B600();
      }
    }
    else
    {
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      *(void *)long long buf = &v41;
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v12 + 48))(v12, buf);
    sub_10005CD2C((uint64_t)buf, v41);
    sub_100ADDE88((void *)(v11 + 368));
    sub_100058DB0(&v37, "PreFlightEligibilityCheck");
    sub_1000E9358((uint64_t **)(v11 + 160), &v37);
    if ((SHIBYTE(v39) & 0x80000000) == 0) {
      goto LABEL_40;
    }
    long long v19 = v37;
    goto LABEL_39;
  }
  char v37 = 0;
  char v38 = 0;
  uint64_t v39 = 0;
  memset(v36, 0, sizeof(v36));
  sub_10030B4A4(v36, a1[5], a1[6], (uint64_t)(a1[6] - a1[5]) >> 7);
  if (!v29) {
    sub_10016C840();
  }
  BOOL v13 = sub_100A9C0E4(a1 + 2, v36, a1 + 8, v27, (uint64_t)&v37);
  *(void *)long long buf = v36;
  sub_10030B640((void ***)buf);
  if (v13)
  {
    uint64_t v14 = *(std::__shared_weak_count **)(v11 + 64);
    v33[0] = *(void *)(v11 + 56);
    v33[1] = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v26) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)v34, (uint64_t)v33, "PreFlightEligibilityCheck", (uint64_t)&v23);
    long long __p = 0;
    long long v31 = 0;
    uint64_t v32 = 0;
    sub_10005C928(&__p, v37, (uint64_t)v38, v38 - (unsigned char *)v37);
    uint64_t v16 = a1[11];
    uint64_t v15 = a1[12];
    if (v15) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    }
    char v43 = 0;
    int v17 = operator new(0x20uLL);
    void *v17 = off_101A39908;
    v17[1] = v11;
    void v17[2] = v16;
    void v17[3] = v15;
    char v43 = v17;
    sub_100ACDED8((void *)v11, (uint64_t)v34, (uint64_t)&__p, (uint64_t)buf);
    sub_100A86C00(buf);
    if (__p)
    {
      long long v31 = __p;
      operator delete(__p);
    }
    if (v35 < 0) {
      operator delete(v34[0]);
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    uint64_t v21 = *(NSObject **)(v11 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to encode", buf, 2u);
    }
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    *(void *)long long buf = &v41;
    uint64_t v22 = *(void *)(v11 + 392);
    if (!v22) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v22 + 48))(v22, buf);
    sub_10005CD2C((uint64_t)buf, v41);
    sub_100ADDE88((void *)(v11 + 368));
    sub_100058DB0(v34, "PreFlightEligibilityCheck");
    sub_1000E9358((uint64_t **)(v11 + 160), v34);
    if (v35 < 0) {
      operator delete(v34[0]);
    }
  }
  long long v19 = v37;
  if (v37)
  {
    char v38 = v37;
    goto LABEL_39;
  }
LABEL_40:
  if (v26) {
    sub_10010C0E0((uint64_t)&v23, v24);
  }
  if (v29 && v27[0])
  {
    v27[1] = v27[0];
    operator delete(v27[0]);
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_100ADDB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  sub_100A86C00((void *)(v31 - 112));
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v33 = *(void **)(v31 - 136);
  if (v33)
  {
    *(void *)(v31 - 128) = v33;
    operator delete(v33);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v30 < 0) {
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ADDCD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADDD14()
{
}

uint64_t sub_100ADDD20(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 48) = 0;
  sub_10030B4A4((void *)(a1 + 32), *(void *)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 7);
  uint64_t v5 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v5 = v6;
  }
  uint64_t v7 = *(void *)(a2 + 88);
  *(void *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100ADDDF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030B640((void ***)va);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }
  _Unwind_Resume(a1);
}

void sub_100ADDE24(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v3 = (void **)(a1 + 32);
  sub_10030B640(&v3);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void *sub_100ADDE88(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ADDF10(void *a1)
{
  *a1 = off_101A39908;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADDF5C(void *a1)
{
  *a1 = off_101A39908;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100ADDFC8(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A39908;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100ADE02C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A39908;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ADE06C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100ADE07C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100ADE0BC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  v16[0] = v3;
  v16[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v5 = sub_100AD49C0((os_log_t *)(v4 + 40), v16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v5)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    BOOL v13 = &v14;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v3 + 40))(&v12, v3);
    char v6 = sub_100A9C5FC(&v12, (uint64_t **)&v13);
    sub_100030068(&v12);
    if ((v6 & 1) == 0)
    {
      uint64_t v7 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v15;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Profile Pre-Flight check eligibility with %ld results", (uint8_t *)&buf, 0xCu);
      }
    }
    sub_10005DD08((uint64_t *)&buf, (uint64_t)&v13);
    uint64_t v8 = *(void *)(v4 + 392);
    if (!v8) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v8 + 48))(v8, &buf);
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
    sub_100ADDE88((void *)(v4 + 368));
    sub_100058DB0(__p, "PreFlightEligibilityCheck");
    sub_1000E9358((uint64_t **)(v4 + 160), __p);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    sub_10005CD2C((uint64_t)&v13, v14);
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    BOOL v13 = &v14;
    uint64_t v9 = *(void *)(v4 + 392);
    if (!v9) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, char ***))(*(void *)v9 + 48))(v9, &v13);
    sub_10005CD2C((uint64_t)&v13, v14);
    sub_100ADDE88((void *)(v4 + 368));
    sub_100058DB0(&buf, "PreFlightEligibilityCheck");
    sub_1000E9358((uint64_t **)(v4 + 160), (void **)&buf);
    if (v18 < 0) {
      operator delete((void *)buf);
    }
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100ADE32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,char *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10005CD2C((uint64_t)&a18, a21);
  if (v30) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(a1);
}

void sub_100ADE3B4()
{
  if (v0)
  {
    sub_10004D2C8(v0);
    JUMPOUT(0x100ADE3A4);
  }
  JUMPOUT(0x100ADE3ACLL);
}

uint64_t sub_100ADE3C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADE408()
{
}

uint64_t sub_100ADE414(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100ADE4AC(void *a1)
{
  *a1 = off_101A39998;
  sub_100337EF8(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100ADE4FC(void *a1)
{
  *a1 = off_101A39998;
  sub_100337EF8(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100ADE56C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A39998;
  sub_100ADECA4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADE5C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADE5D4(uint64_t a1, void *a2)
{
  *a2 = off_101A39998;
  return sub_100ADECA4((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100ADE600(uint64_t a1)
{
}

void sub_100ADE608(void *a1)
{
  sub_100ADED14((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADE644(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)uint64_t v22 = *(_OWORD *)a2;
  uint64_t v23 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(v19[0]) = 0;
  char v21 = 0;
  int v5 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)long long v19 = *(_OWORD *)a3;
    uint64_t v20 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v21 = 1;
  }
  LOBYTE(v15) = 0;
  char v18 = 0;
  if (!*(unsigned char *)(a4 + 24))
  {
    uint64_t v8 = *(void *)(a1 + 8);
    char v34 = 0;
    char v35 = 0;
    uint64_t v36 = 0;
LABEL_15:
    int v10 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No signed payload or URLs", (uint8_t *)__p, 2u);
    }
    uint64_t v33 = 0;
    memset(v32, 0, sizeof(v32));
    sub_100AD32E8(*(void *)(a1 + 64), (uint64_t)&v33, 5);
    __p[0] = v32;
    sub_10030A774((void ***)__p);
    sub_100044D00(&v33);
    sub_100058DB0(__p, "GetCarrierSetup");
    sub_1000E9358((uint64_t **)(v8 + 160), __p);
    goto LABEL_21;
  }
  char v6 = (void *)(a4 + 8);
  uint64_t v7 = *(void **)(a4 + 8);
  uint64_t v15 = *(void ***)a4;
  uint64_t v16 = v7;
  if (*(void *)(a4 + 16))
  {
    void v7[2] = &v16;
    *(void *)a4 = v6;
    void *v6 = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    uint64_t v15 = &v16;
  }
  char v18 = 1;
  uint64_t v8 = *(void *)(a1 + 8);
  char v34 = 0;
  char v35 = 0;
  uint64_t v36 = 0;
  if (!v5) {
    goto LABEL_15;
  }
  if (sub_100A9F74C((uint64_t *)v22, v19, *(unsigned __int8 *)(a1 + 16), (uint64_t)&v34))
  {
    uint64_t v9 = *(std::__shared_weak_count **)(v8 + 64);
    v27[0] = *(void *)(v8 + 56);
    v27[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v18) {
      sub_10016C840();
    }
    sub_100AD5CE8((uint64_t)__p, (uint64_t)v27, "GetCarrierSetup", (uint64_t)&v15);
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    sub_10005C928(&v24, v34, (uint64_t)v35, v35 - (unsigned char *)v34);
    uint64_t v37 = v8;
    char v38 = *(unsigned char *)(a1 + 16);
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(&v39, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      long long v39 = *(_OWORD *)v22;
      uint64_t v40 = v23;
    }
    uint64_t v12 = *(void *)(a1 + 32);
    *(void *)&long long v41 = *(void *)(a1 + 24);
    *((void *)&v41 + 1) = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100ADE414((uint64_t)v42, a1 + 40);
    uint64_t v44 = 0;
    BOOL v13 = (char *)operator new(0x60uLL);
    uint64_t v14 = v37;
    *(void *)BOOL v13 = off_101A39A08;
    *((void *)v13 + 1) = v14;
    uint8_t v13[16] = v38;
    *(_OWORD *)(v13 + 24) = v39;
    *((void *)v13 + 5) = v40;
    long long v39 = 0uLL;
    uint64_t v40 = 0;
    *((_OWORD *)v13 + 3) = v41;
    long long v41 = 0uLL;
    sub_100ADEC24((uint64_t)(v13 + 64), (uint64_t)v42);
    uint64_t v44 = v13;
    sub_100ACDED8((void *)v8, (uint64_t)__p, (uint64_t)&v24, (uint64_t)v43);
    sub_100A86C00(v43);
    sub_100337EF8(v42);
    if (*((void *)&v41 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v41 + 1));
    }
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)v39);
    }
    if (v24)
    {
      uint64_t v25 = v24;
      operator delete(v24);
    }
    if (v31 < 0) {
      operator delete(__p[0]);
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    goto LABEL_36;
  }
  char v11 = *(NSObject **)(v8 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to encode", (uint8_t *)__p, 2u);
  }
  char v29 = 0;
  memset(v28, 0, sizeof(v28));
  sub_100AD32E8(*(void *)(a1 + 64), (uint64_t)&v29, 3);
  __p[0] = v28;
  sub_10030A774((void ***)__p);
  sub_100044D00(&v29);
  sub_100058DB0(__p, "GetCarrierSetup");
  sub_1000E9358((uint64_t **)(v8 + 160), __p);
LABEL_21:
  if (v31 < 0) {
    operator delete(__p[0]);
  }
LABEL_36:
  if (v34)
  {
    char v35 = v34;
    operator delete(v34);
  }
  if (v18) {
    sub_10010C0E0((uint64_t)&v15, v16);
  }
  if (v21 && v19[0])
  {
    v19[1] = v19[0];
    operator delete(v19[0]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
}

void sub_100ADEAA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,void *a42,uint64_t a43)
{
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (a42)
  {
    a43 = (uint64_t)a42;
    operator delete(a42);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ADEBD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADEC18()
{
}

uint64_t sub_100ADEC24(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_100ADECA4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v3;
  uint64_t v4 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100ADE414(a1 + 32, (uint64_t)(a2 + 4));
  return a1;
}

void sub_100ADECFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ADED14(uint64_t a1)
{
  sub_100337EF8((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100ADED60(uint64_t a1)
{
  *(void *)a1 = off_101A39A08;
  sub_100337EF8((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100ADEDC0(uint64_t a1)
{
  *(void *)a1 = off_101A39A08;
  sub_100337EF8((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_100ADEE40(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  *uint64_t v2 = off_101A39A08;
  sub_100ADF564((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100ADEE94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADEEA8(uint64_t a1, void *a2)
{
  *a2 = off_101A39A08;
  return sub_100ADF564((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100ADEED4(uint64_t a1)
{
}

void sub_100ADEEDC(void *a1)
{
  sub_100ADF620((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100ADEF18(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  char v6 = (NSObject **)(v5 + 40);
  v32[0] = v4;
  v32[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v7 = sub_100AD49C0((os_log_t *)(v5 + 40), v32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (!v7)
  {
    *(void *)long long buf = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    char v29 = 0;
    sub_100AD32E8(*(void *)(a1 + 88), (uint64_t)buf, 5);
    uint64_t v26 = &v29;
    sub_10030A774(&v26);
    sub_100044D00((const void **)buf);
    sub_100058DB0(&v26, "GetCarrierSetup");
    sub_1000E9358((uint64_t **)(v5 + 160), (void **)&v26);
    if ((SHIBYTE(v28) & 0x80000000) == 0) {
      goto LABEL_45;
    }
    int v17 = v26;
    goto LABEL_44;
  }
  char v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v25, v4);
  char v8 = sub_100A9F96C(&v25, (uint64_t)&v29, (char **)&v26);
  sub_100030068(&v25);
  if ((v8 & 1) == 0)
  {
    char v18 = *v6;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Invalid carrier setup response", buf, 2u);
    }
    goto LABEL_28;
  }
  uint64_t v9 = (void *)(a1 + 24);
  char v10 = *(unsigned char *)(a1 + 47);
  if (v10 >= 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 32);
  }
  uint64_t v12 = HIBYTE(v31);
  int v13 = SHIBYTE(v31);
  if (v31 < 0) {
    uint64_t v12 = v30;
  }
  if (v11 != v12) {
    goto LABEL_27;
  }
  if (v31 >= 0) {
    uint64_t v14 = (unsigned __int8 *)&v29;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)v29;
  }
  if ((*(unsigned char *)(a1 + 47) & 0x80) != 0)
  {
    uint64_t v9 = (void *)*v9;
    if (memcmp(v9, v14, *(void *)(a1 + 32)))
    {
      long long v19 = *v6;
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      goto LABEL_53;
    }
  }
  else if (*(unsigned char *)(a1 + 47))
  {
    uint64_t v15 = (unsigned __int8 *)(a1 + 24);
    uint64_t v16 = *(unsigned __int8 *)(a1 + 47);
    while (*v15 == *v14)
    {
      ++v15;
      ++v14;
      if (!--v16) {
        goto LABEL_33;
      }
    }
LABEL_27:
    long long v19 = *v6;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    if (v10 < 0) {
      uint64_t v9 = (void *)*v9;
    }
    if (v13 >= 0) {
      uint64_t v14 = (unsigned __int8 *)&v29;
    }
    else {
      uint64_t v14 = (unsigned __int8 *)v29;
    }
LABEL_53:
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Mismatching session id [%s] expecting [%s]", buf, 0x16u);
LABEL_28:
    CFTypeRef cf = 0;
    memset(buf, 0, sizeof(buf));
    sub_100AD32E8(*(void *)(a1 + 88), (uint64_t)&cf, 5);
    __p[0] = buf;
    sub_10030A774((void ***)__p);
    sub_100044D00(&cf);
    sub_100058DB0(__p, "GetCarrierSetup");
    sub_1000E9358((uint64_t **)(v5 + 160), __p);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_42;
  }
LABEL_33:
  CFTypeRef cf = 0;
  sub_100AA0500((const std::string **)&v26, *(unsigned char *)(a1 + 16) == 0, &cf);
  uint64_t v20 = *v6;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((v27 - (uint64_t)v26) >> 6);
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I getCarrierSetup_sync: Found %lu CarrierSetupItems.", buf, 0xCu);
  }
  if (*(void *)(a1 + 88))
  {
    CFTypeRef v21 = cf;
    if (cf) {
      CFRetain(cf);
    }
    memset(buf, 0, sizeof(buf));
    sub_1003403B4(buf, (uint64_t)v26, v27, 0xAAAAAAAAAAAAAAABLL * ((v27 - (uint64_t)v26) >> 6));
    sub_100AD32E8(*(void *)(a1 + 88), (uint64_t)&v21, 0);
    __p[0] = buf;
    sub_10030A774((void ***)__p);
    sub_100044D00(&v21);
  }
  sub_100058DB0(__p, "GetCarrierSetup");
  sub_1000E9358((uint64_t **)(v5 + 160), __p);
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  sub_100044D00(&cf);
LABEL_42:
  __p[0] = &v26;
  sub_10030A774((void ***)__p);
  if ((SHIBYTE(v31) & 0x80000000) == 0) {
    goto LABEL_45;
  }
  int v17 = (void **)v29;
LABEL_44:
  operator delete(v17);
LABEL_45:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100ADF3E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ADF504()
{
  if (v0)
  {
    sub_10004D2C8(v0);
    JUMPOUT(0x100ADF4F4);
  }
  JUMPOUT(0x100ADF4FCLL);
}

uint64_t sub_100ADF518(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADF558()
{
}

uint64_t sub_100ADF564(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  if (*((char *)a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), (void *)a2[2], a2[3]);
  }
  else
  {
    long long v5 = *((_OWORD *)a2 + 1);
    *(void *)(a1 + 32) = a2[4];
    *(_OWORD *)(a1 + 16) = v5;
  }
  uint64_t v6 = a2[6];
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = a2[5];
  *(void *)(a1 + 48) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100ADE414(a1 + 56, (uint64_t)(a2 + 7));
  return a1;
}

void sub_100ADF5F8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ADF620(uint64_t a1)
{
  sub_100337EF8((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 16);
    operator delete(v3);
  }
}

void sub_100ADF680()
{
}

void *sub_100ADF694()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A39A98;
  return result;
}

void sub_100ADF6CC(uint64_t a1, void *a2)
{
  *a2 = off_101A39A98;
}

uint64_t sub_100ADF6F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADF738()
{
}

void sub_100ADF748()
{
}

void *sub_100ADF75C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A39B18;
  result[1] = v3;
  return result;
}

uint64_t sub_100ADF7A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A39B18;
  a2[1] = v2;
  return result;
}

void sub_100ADF7D0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 80);
  if (v3)
  {
    int v4 = *a2;
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(v2 + 72);
      if (v7)
      {
        if (v4) {
          char v8 = "Retry_Success";
        }
        else {
          char v8 = "Retry_Failed";
        }
        sub_100058DB0(__p, v8);
        (*(void (**)(uint64_t, void **))(*(void *)v7 + 104))(v7, __p);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100ADF884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADF8B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ADF8F0()
{
}

uint64_t *sub_100ADF8FC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(*(void *)v1 + 88) + 64))(*(void *)(*(void *)v1 + 88), v1 + 8))
  {
    uint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Token has not changed, aborting", buf, 2u);
    }
    *(unsigned char *)(v2 + 256) = 0;
  }
  else
  {
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 88) + 80))(*(void *)(v2 + 88), v1 + 8);
    sub_100058DB0(buf, "UpdateToken");
    int v4 = sub_100046F68(v2 + 160, (void **)buf);
    if (v16 < 0) {
      operator delete(*(void **)buf);
    }
    if ((void **)(v2 + 168) == v4)
    {
      sub_100AD548C((uint64_t **)(v2 + 160), &off_101A39B88);
      uint64_t v12 = v2;
      if (*(char *)(v1 + 31) < 0)
      {
        sub_10004FC84(&__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
      }
      else
      {
        long long v6 = *(_OWORD *)(v1 + 8);
        uint64_t v14 = *(void *)(v1 + 24);
        long long __p = v6;
      }
      int v17 = 0;
      uint64_t v7 = operator new(0x28uLL);
      uint64_t v8 = v12;
      void *v7 = off_101A39BA0;
      v7[1] = v8;
      *((_OWORD *)v7 + 1) = __p;
      void v7[4] = v14;
      long long __p = 0uLL;
      uint64_t v14 = 0;
      int v17 = v7;
      sub_100ACEB94(v2, 0, 0, 0, (uint64_t)buf);
      sub_100AD40DC(buf);
      if (SHIBYTE(v14) < 0) {
        operator delete((void *)__p);
      }
    }
    else
    {
      long long v5 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Outstanding request - not updating token", buf, 2u);
      }
    }
  }
  sub_1001102C4(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100ADFB58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1001102C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100ADFBB0(uint64_t a1)
{
  *(void *)a1 = off_101A39BA0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100ADFC00(uint64_t a1)
{
  *(void *)a1 = off_101A39BA0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100ADFC70(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A39BA0;
  v2[1] = v3;
  int v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_100ADFCE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100ADFCFC(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_101A39BA0;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_100ADFD4C(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100ADFD60(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_100ADFDA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v5 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  v24[0] = *(_DWORD *)(a2 + 16);
  *(_DWORD *)((char *)v24 + 3) = *(_DWORD *)(a2 + 19);
  int v7 = *(char *)(a2 + 23);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  LOBYTE(__p[0]) = 0;
  char v23 = 0;
  int v8 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v22 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    char v23 = 1;
  }
  LOBYTE(v17) = 0;
  char v20 = 0;
  if (*(unsigned char *)(a4 + 24))
  {
    uint64_t v9 = (void *)(a4 + 8);
    char v10 = *(void **)(a4 + 8);
    int v17 = *(void ***)a4;
    char v18 = v10;
    if (*(void *)(a4 + 16))
    {
      void v10[2] = &v18;
      *(void *)a4 = v9;
      void *v9 = 0;
      *(void *)(a4 + 16) = 0;
    }
    else
    {
      int v17 = &v18;
    }
    char v20 = 1;
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    if (v8)
    {
      if (sub_100A9F0D0(__p, (uint64_t)&v36))
      {
        uint64_t v12 = *(std::__shared_weak_count **)(v11 + 64);
        v33[0] = *(void *)(v11 + 56);
        v33[1] = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v20) {
          sub_10016C840();
        }
        sub_100AD5CE8((uint64_t)buf, (uint64_t)v33, "UpdateToken", (uint64_t)&v17);
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        sub_10005C928(&v30, v36, (uint64_t)v37, v37 - (unsigned char *)v36);
        uint64_t v25 = v11;
        if (v7 < 0)
        {
          sub_10004FC84(&v26, v5, v6);
        }
        else
        {
          *(void *)&long long v26 = v5;
          *((void *)&v26 + 1) = v6;
          LODWORD(v27) = v24[0];
          *(_DWORD *)((char *)&v27 + 3) = *(_DWORD *)((char *)v24 + 3);
          HIBYTE(v27) = v7;
        }
        if (*(char *)(a1 + 39) < 0)
        {
          sub_10004FC84(&v28, *(void **)(a1 + 16), *(void *)(a1 + 24));
        }
        else
        {
          long long v28 = *(_OWORD *)(a1 + 16);
          uint64_t v29 = *(void *)(a1 + 32);
        }
        uint64_t v40 = 0;
        uint64_t v15 = (char *)operator new(0x40uLL);
        uint64_t v16 = v25;
        *(void *)uint64_t v15 = off_101A39C10;
        *((void *)v15 + 1) = v16;
        *((_OWORD *)v15 + 1) = v26;
        *((void *)v15 + 4) = v27;
        long long v26 = 0uLL;
        uint64_t v27 = 0;
        *(_OWORD *)(v15 + 4sub_1001A7358((uint64_t)&a9, 0) = v28;
        *((void *)v15 + 7) = v29;
        long long v28 = 0uLL;
        uint64_t v29 = 0;
        uint64_t v40 = v15;
        sub_100ACDED8((void *)v11, (uint64_t)buf, (uint64_t)&v30, (uint64_t)v39);
        sub_100A86C00(v39);
        if (SHIBYTE(v29) < 0) {
          operator delete((void *)v28);
        }
        if (SHIBYTE(v27) < 0) {
          operator delete((void *)v26);
        }
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }
        if (v35 < 0) {
          operator delete(*(void **)buf);
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      else
      {
        uint64_t v14 = *(NSObject **)(v11 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to encode - ?", buf, 2u);
        }
        sub_100058DB0(buf, "UpdateToken");
        sub_1000E9358((uint64_t **)(v11 + 160), (void **)buf);
        if (v35 < 0) {
          operator delete(*(void **)buf);
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
  }
  int v13 = *(NSObject **)(v11 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No signed payload or URLs", buf, 2u);
  }
  sub_100058DB0(buf, "UpdateToken");
  sub_1000E9358((uint64_t **)(v11 + 160), (void **)buf);
  if (v35 < 0) {
    operator delete(*(void **)buf);
  }
  *(unsigned char *)(v11 + 256) = 1;
LABEL_20:
  if (v36)
  {
    uint64_t v37 = v36;
    operator delete(v36);
  }
  if (v20) {
    sub_10010C0E0((uint64_t)&v17, v18);
  }
  if (v23 && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v7 < 0) {
    operator delete(v5);
  }
}

void sub_100AE01A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a32)
  {
    a33 = (uint64_t)a32;
    operator delete(a32);
  }
  if (*(char *)(v36 - 137) < 0) {
    operator delete(*(void **)(v36 - 160));
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v38 = *(void **)(v36 - 128);
  if (v38)
  {
    *(void *)(v36 - 12sub_1001A7358((uint64_t)&a9, 0) = v38;
    operator delete(v38);
  }
  if (a12) {
    sub_10010C0E0((uint64_t)&a9, a10);
  }
  if (a16 && a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  if (v35 < 0) {
    operator delete(v33);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE029C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AE02DC()
{
}

uint64_t sub_100AE02E8(uint64_t a1)
{
  *(void *)a1 = off_101A39C10;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100AE0348(uint64_t a1)
{
  *(void *)a1 = off_101A39C10;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100AE03C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A39C10;
  sub_100AE0934((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100AE041C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AE0430(uint64_t a1, void *a2)
{
  *a2 = off_101A39C10;
  return sub_100AE0934((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100AE045C(uint64_t a1)
{
}

void sub_100AE0464(void *a1)
{
  sub_10016B57C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100AE04A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  sub_100058DB0(&__p, "UpdateToken");
  sub_1000E9358((uint64_t **)(v5 + 160), (void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unint64_t v6 = (NSObject **)(v5 + 40);
  v31[0] = v4;
  v31[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v7 = sub_100AD49C0((os_log_t *)(v5 + 40), v31);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v7)
  {
    memset(&__p, 0, sizeof(__p));
    memset(&v30, 0, sizeof(v30));
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v4 + 40))(&v29, v4);
    char v8 = sub_100A9F234(&v29, &__p, &v30);
    sub_100030068(&v29);
    if ((v8 & 1) == 0)
    {
      uint64_t v15 = *v6;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
LABEL_30:
        if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v30.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_34;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v16 = "udpatePushToken_sync (response): Failed to decode updatePushToken response";
      goto LABEL_64;
    }
    uint64_t v9 = *(unsigned __int8 *)(a1 + 39);
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 39);
    }
    else {
      uint64_t v10 = *(void *)(a1 + 24);
    }
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (v10 == size)
    {
      uint64_t v12 = (const void **)(a1 + 16);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((v9 & 0x80) == 0)
      {
        if (*(unsigned char *)(a1 + 39))
        {
          while (*(unsigned __int8 *)v12 == p_p->__r_.__value_.__s.__data_[0])
          {
            uint64_t v12 = (const void **)((char *)v12 + 1);
            p_p = (std::string *)((char *)p_p + 1);
            if (!--v9) {
              goto LABEL_37;
            }
          }
          goto LABEL_29;
        }
LABEL_37:
        int v17 = (void *)(a1 + 40);
        uint64_t v18 = *(unsigned __int8 *)(a1 + 63);
        size_t v19 = *(void *)(a1 + 48);
        if ((v18 & 0x80u) == 0) {
          uint64_t v20 = *(unsigned __int8 *)(a1 + 63);
        }
        else {
          uint64_t v20 = *(void *)(a1 + 48);
        }
        std::string::size_type v21 = HIBYTE(v30.__r_.__value_.__r.__words[2]);
        int v22 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
        if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v21 = v30.__r_.__value_.__l.__size_;
        }
        if (v20 == v21)
        {
          if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v23 = &v30;
          }
          else {
            char v23 = (std::string *)v30.__r_.__value_.__r.__words[0];
          }
          if ((v18 & 0x80) != 0)
          {
            int v17 = (void *)*v17;
            if (memcmp(v17, v23, v19))
            {
              long long v26 = *v6;
              if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
                goto LABEL_30;
              }
LABEL_58:
              *(_DWORD *)long long buf = 136315394;
              char v34 = v17;
              __int16 v35 = 2080;
              uint64_t v36 = v23;
              uint64_t v16 = "udpatePushToken_sync (response): Mismatched Push Tokens - expected: [%s] returned [%s]";
              uint64_t v27 = v26;
              uint32_t v28 = 22;
LABEL_65:
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v16, buf, v28);
              goto LABEL_30;
            }
          }
          else if (v18)
          {
            uint64_t v24 = (unsigned __int8 *)v17;
            uint64_t v25 = v18;
            while (*v24 == v23->__r_.__value_.__s.__data_[0])
            {
              ++v24;
              char v23 = (std::string *)((char *)v23 + 1);
              if (!--v25) {
                goto LABEL_62;
              }
            }
            goto LABEL_52;
          }
LABEL_62:
          (*(void (**)(void, std::string *))(**(void **)(v5 + 88) + 120))(*(void *)(v5 + 88), p_p);
          goto LABEL_30;
        }
LABEL_52:
        long long v26 = *v6;
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
          goto LABEL_30;
        }
        if ((v18 & 0x80u) != 0) {
          int v17 = (void *)*v17;
        }
        if (v22 >= 0) {
          char v23 = &v30;
        }
        else {
          char v23 = (std::string *)v30.__r_.__value_.__r.__words[0];
        }
        goto LABEL_58;
      }
      if (!memcmp(*v12, p_p, *(void *)(a1 + 24))) {
        goto LABEL_37;
      }
    }
LABEL_29:
    uint64_t v15 = *v6;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v16 = "udpatePushToken_sync (response): Mismatched SessionId - push token may not be correctly updated";
LABEL_64:
    uint64_t v27 = v15;
    uint32_t v28 = 2;
    goto LABEL_65;
  }
  uint64_t v14 = *v6;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid response", (uint8_t *)&__p, 2u);
  }
  *(unsigned char *)(v5 + 256) = 1;
LABEL_34:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100AE087C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE08E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100AE0928()
{
}

uint64_t sub_100AE0934(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100AE09C8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE09E4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100AE0C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

const char *sub_100AE0CE4()
{
  return "MobileHelperImpl";
}

void sub_100AE0CF0(void *a1@<X0>, const __CFString *a2@<X1>, const __CFString *a3@<X2>, void *a4@<X8>)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v24);
  if (v24)
  {
    uint64_t v21 = v24;
    int v22 = v25;
    CFPropertyListRef v23 = 0;
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = (unint64_t)sub_1006D6D4C((int)&v21, a2, a3, &v23) >> 32;
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v9)
    {
      uint64_t v10 = a1[1];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        long long v26 = 0uLL;
        uint64_t v27 = 0;
        ctu::cf::assign();
        uint64_t v20 = v27;
        *(_OWORD *)size_t v19 = v26;
        int v13 = SHIBYTE(v27);
        uint64_t v14 = (void **)v26;
        long long v26 = 0uLL;
        uint64_t v27 = 0;
        ctu::cf::assign();
        uint64_t v15 = v19;
        if (v13 < 0) {
          uint64_t v15 = v14;
        }
        *(_OWORD *)std::string __p = v26;
        uint64_t v18 = v27;
        uint64_t v16 = __p;
        if (v27 < 0) {
          uint64_t v16 = (void **)v26;
        }
        *(_DWORD *)long long buf = 136315650;
        uint64_t v29 = v15;
        __int16 v30 = 2080;
        uint64_t v31 = v16;
        __int16 v32 = 1024;
        int v33 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not read %s from %s using mobile helper. Error: %d", buf, 0x1Cu);
        if (SHIBYTE(v18) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v20) < 0) {
          operator delete(v19[0]);
        }
      }
      CFPropertyListRef v11 = 0;
    }
    else
    {
      CFPropertyListRef v11 = v23;
    }
    *a4 = v11;
  }
  else
  {
    uint64_t v12 = a1[1];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    *a4 = 0;
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100AE0F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE0F9C(void *a1, const __CFString *a2, const __CFString *a3, const void *a4)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v24);
  if (!v24)
  {
    uint64_t v15 = a1[1];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    goto LABEL_18;
  }
  uint64_t v22 = v24;
  CFPropertyListRef v23 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v9 = (unint64_t)sub_1006D6704((int)&v22, a2, a3, a4) >> 32;
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v9)
  {
    uint64_t v10 = a1[1];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      long long v26 = 0uLL;
      uint64_t v27 = 0;
      ctu::cf::assign();
      uint64_t v21 = v27;
      *(_OWORD *)uint64_t v20 = v26;
      int v11 = SHIBYTE(v27);
      uint64_t v12 = (void **)v26;
      long long v26 = 0uLL;
      uint64_t v27 = 0;
      ctu::cf::assign();
      int v13 = v20;
      if (v11 < 0) {
        int v13 = v12;
      }
      *(_OWORD *)std::string __p = v26;
      uint64_t v19 = v27;
      uint64_t v14 = __p;
      if (v27 < 0) {
        uint64_t v14 = (void **)v26;
      }
      *(_DWORD *)long long buf = 136315650;
      uint64_t v29 = v13;
      __int16 v30 = 2080;
      uint64_t v31 = v14;
      __int16 v32 = 1024;
      int v33 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not set %s in %s using mobile helper %d", buf, 0x1Cu);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v21) < 0) {
        operator delete(v20[0]);
      }
    }
LABEL_18:
    uint64_t v16 = 0;
    goto LABEL_20;
  }
  uint64_t v16 = 1;
LABEL_20:
  if (v25) {
    sub_10004D2C8(v25);
  }
  return v16;
}

void sub_100AE11D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE1238(void *a1@<X0>, const __CFString *a2@<X1>, const __CFString *a3@<X2>, void *a4@<X8>)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v24);
  if (v24)
  {
    uint64_t v21 = v24;
    uint64_t v22 = v25;
    CFPropertyListRef v23 = 0;
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = (unint64_t)sub_1006D7390((int)&v21, a2, a3, &v23) >> 32;
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v9)
    {
      uint64_t v10 = a1[1];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        long long v26 = 0uLL;
        uint64_t v27 = 0;
        ctu::cf::assign();
        uint64_t v20 = v27;
        *(_OWORD *)uint64_t v19 = v26;
        int v13 = SHIBYTE(v27);
        uint64_t v14 = (void **)v26;
        long long v26 = 0uLL;
        uint64_t v27 = 0;
        ctu::cf::assign();
        uint64_t v15 = v19;
        if (v13 < 0) {
          uint64_t v15 = v14;
        }
        *(_OWORD *)std::string __p = v26;
        uint64_t v18 = v27;
        uint64_t v16 = __p;
        if (v27 < 0) {
          uint64_t v16 = (void **)v26;
        }
        *(_DWORD *)long long buf = 136315650;
        uint64_t v29 = v15;
        __int16 v30 = 2080;
        uint64_t v31 = v16;
        __int16 v32 = 1024;
        int v33 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not read %s from app %s using mobile helper. Error: %d", buf, 0x1Cu);
        if (SHIBYTE(v18) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v20) < 0) {
          operator delete(v19[0]);
        }
      }
      CFPropertyListRef v11 = 0;
    }
    else
    {
      CFPropertyListRef v11 = v23;
    }
    *a4 = v11;
  }
  else
  {
    uint64_t v12 = a1[1];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    *a4 = 0;
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100AE1480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE14E4(void *a1@<X0>, uint64_t a2@<X1>, CFTypeRef *a3@<X8>)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  long long v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v24);
  uint64_t v7 = v24;
  if (v24)
  {
    *a3 = 0;
    uint64_t v22 = v7;
    CFPropertyListRef v23 = v25;
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = a3;
    unint64_t v8 = sub_1006D9C08((uint64_t)&v22, a2, (CFPropertyListRef *)&buf);
    int v9 = v8;
    unint64_t v10 = HIDWORD(v8);
    sub_100AE3724((const void **)&buf);
    if (v23) {
      sub_10004D2C8(v23);
    }
    if (v10)
    {
      CFPropertyListRef v11 = a1[1];
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      LODWORD(buf) = 67109376;
      DWORD1(buf) = v9;
      WORD4(buf) = 1024;
      *(_DWORD *)((char *)&buf + 1sub_1001A7358((uint64_t)&a9, 0) = v10;
      uint64_t v12 = "Could not load plist as dictionary through mobile helper: domain=%d error=%d";
      int v13 = v11;
      uint32_t v14 = 14;
      goto LABEL_9;
    }
    if (*a3) {
      uint64_t v16 = sub_100080934;
    }
    else {
      uint64_t v16 = 0;
    }
    if (v16)
    {
      CFTypeID v17 = CFGetTypeID(*a3);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      uint64_t v19 = a1[1];
      if (v17 == TypeID)
      {
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Loaded preference file through mobile helper successfully", (uint8_t *)&buf, 2u);
        }
        goto LABEL_13;
      }
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      CFTypeID v21 = CFGetTypeID(*a3);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v21;
      uint64_t v12 = "Loaded plist through mobile helper, but it wasn't a dictionary: %lu";
      int v13 = v19;
      uint32_t v14 = 12;
    }
    else
    {
      uint64_t v20 = a1[1];
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      LOWORD(buf) = 0;
      uint64_t v12 = "Loaded plist as dictionary through mobile helper, but the result was not set";
      int v13 = v20;
      uint32_t v14 = 2;
    }
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&buf, v14);
    goto LABEL_13;
  }
  uint64_t v15 = a1[1];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "cannot create client", (uint8_t *)&buf, 2u);
  }
  *a3 = 0;
LABEL_13:
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100AE1774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_1000577C4(v12);
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100AE17BC(void *a1, char *a2, char *a3, char *a4)
{
  if (a2 && a3 && a4)
  {
    char v19 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    unint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
    sub_1006D6404(v8, &v17);
    uint64_t v15 = v17;
    uint64_t v16 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = sub_1006D87BC((uint64_t)&v15, a2, a3, a4, &v19);
    if (v16) {
      sub_10004D2C8(v16);
    }
    if (v19 || (unint64_t v10 = HIDWORD(v9), !v10))
    {
      BOOL v12 = v19 != 0;
    }
    else
    {
      CFPropertyListRef v11 = a1[1];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315906;
        CFTypeID v21 = a4;
        __int16 v22 = 2080;
        CFPropertyListRef v23 = a2;
        __int16 v24 = 2080;
        uint64_t v25 = a3;
        __int16 v26 = 1024;
        int v27 = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not copy file %s from %s to %s: %d", buf, 0x26u);
      }
      BOOL v12 = 0;
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
  else
  {
    int v13 = a1[1];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid copyFile arguments", buf, 2u);
    }
    return 0;
  }
  return v12;
}

void sub_100AE1994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE19C0(void *a1, char *a2, char *a3, char *a4)
{
  if (a2 && a3 && a4)
  {
    char v19 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    unint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
    sub_1006D6404(v8, &v17);
    uint64_t v15 = v17;
    uint64_t v16 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = sub_1006D87BC((uint64_t)&v15, a2, a3, a4, &v19);
    if (v16) {
      sub_10004D2C8(v16);
    }
    unint64_t v10 = 0;
    if (!v19)
    {
      unint64_t v11 = HIDWORD(v9);
      if (v11)
      {
        BOOL v12 = a1[1];
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315906;
          CFTypeID v21 = a4;
          __int16 v22 = 2080;
          CFPropertyListRef v23 = a2;
          __int16 v24 = 2080;
          uint64_t v25 = a3;
          __int16 v26 = 1024;
          int v27 = v11;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not copy file %s from %s to %s: %d", buf, 0x26u);
        }
        unint64_t v10 = v11;
      }
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
  else
  {
    int v13 = a1[1];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid copyFile arguments", buf, 2u);
    }
    return 0xFFFFFFFFLL;
  }
  return v10;
}

void sub_100AE1B90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE1BBC(void *a1@<X0>, const void *a2@<X1>, const void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v16);
  if (v16)
  {
    uint64_t v13 = v16;
    uint32_t v14 = v17;
    *(void *)long long buf = 0;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = (unint64_t)sub_1006DA154((uint64_t)&v13, a2, a3, buf) >> 32;
    if (v14) {
      sub_10004D2C8(v14);
    }
    unint64_t v10 = *(const void **)buf;
    if (!v9 && *(void *)buf) {
      goto LABEL_11;
    }
    unint64_t v11 = a1[1];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v18 = 67109120;
      int v19 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "cannot get badges for labels: %d", v18, 8u);
      unint64_t v10 = *(const void **)buf;
      if (!*(void *)buf) {
        goto LABEL_11;
      }
    }
    else if (!v10)
    {
LABEL_11:
      *a4 = v10;
      goto LABEL_15;
    }
    CFRelease(v10);
    unint64_t v10 = 0;
    goto LABEL_11;
  }
  BOOL v12 = a1[1];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
  }
  *a4 = 0;
LABEL_15:
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_100AE1D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE1D98(void *a1@<X0>, const void *a2@<X1>, const void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v16);
  if (v16)
  {
    uint64_t v13 = v16;
    uint32_t v14 = v17;
    *(void *)long long buf = 0;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = (unint64_t)sub_1006DA794((uint64_t)&v13, a2, a3, buf) >> 32;
    if (v14) {
      sub_10004D2C8(v14);
    }
    unint64_t v10 = *(const void **)buf;
    if (!v9 && *(void *)buf) {
      goto LABEL_11;
    }
    unint64_t v11 = a1[1];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v18 = 67109120;
      int v19 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "cannot get localized labels: %d", v18, 8u);
      unint64_t v10 = *(const void **)buf;
      if (!*(void *)buf) {
        goto LABEL_11;
      }
    }
    else if (!v10)
    {
LABEL_11:
      *a4 = v10;
      goto LABEL_15;
    }
    CFRelease(v10);
    unint64_t v10 = 0;
    goto LABEL_11;
  }
  BOOL v12 = a1[1];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
  }
  *a4 = 0;
LABEL_15:
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_100AE1F40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE1F74(void *a1, char *a2, char *a3)
{
  uint64_t v18 = 0;
  int v19 = 0;
  long long v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v18);
  if (!v18)
  {
    BOOL v12 = a1[1];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      unint64_t v9 = "cannot create client";
      unint64_t v10 = v12;
      uint32_t v11 = 2;
      goto LABEL_16;
    }
LABEL_10:
    BOOL v13 = 0;
    goto LABEL_12;
  }
  char v17 = 0;
  uint64_t v15 = v18;
  uint64_t v16 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = (unint64_t)sub_1006DADD4((uint64_t)&v15, a2, a3, &v17) >> 32;
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v7)
  {
    unint64_t v8 = a1[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v21 = v7;
      unint64_t v9 = "cannot remap contacts channel identifier: %d";
      unint64_t v10 = v8;
      uint32_t v11 = 8;
LABEL_16:
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  BOOL v13 = v17 != 0;
LABEL_12:
  if (v19) {
    sub_10004D2C8(v19);
  }
  return v13;
}

void sub_100AE2100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE212C(void *a1)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v2 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v2, &v14);
  if (!v14)
  {
    unint64_t v8 = a1[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "cannot create client";
      long long v6 = v8;
      uint32_t v7 = 2;
      goto LABEL_16;
    }
LABEL_10:
    BOOL v9 = 0;
    goto LABEL_12;
  }
  char v13 = 0;
  uint64_t v11 = v14;
  BOOL v12 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v3 = (unint64_t)sub_1006DB2CC((uint64_t)&v11, &v13) >> 32;
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v3)
  {
    long long v4 = a1[1];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v17 = v3;
      uint64_t v5 = "cannot reset network settings: %d";
      long long v6 = v4;
      uint32_t v7 = 8;
LABEL_16:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, buf, v7);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  BOOL v9 = v13 != 0;
LABEL_12:
  if (v15) {
    sub_10004D2C8(v15);
  }
  return v9;
}

void sub_100AE22A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE22CC(void *a1, char *a2, char *a3)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  long long v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v14);
  if (v14)
  {
    char v13 = 0;
    uint64_t v11 = v14;
    BOOL v12 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1006D970C((uint64_t)&v11, a2, a3, &v13);
    if (v12) {
      sub_10004D2C8(v12);
    }
    BOOL v7 = v13 != 0;
    if (!v13)
    {
      unint64_t v8 = a1[1];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446466;
        int v17 = a2;
        __int16 v18 = 2082;
        int v19 = a3;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to unpack %{public}s to %{public}s", buf, 0x16u);
      }
    }
  }
  else
  {
    BOOL v9 = a1[1];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    BOOL v7 = 0;
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  return v7;
}

void sub_100AE2460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE248C(void *a1, char *a2, char *a3)
{
  uint64_t v17 = 0;
  __int16 v18 = 0;
  long long v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v17);
  if (!v17)
  {
    BOOL v9 = a1[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v10 = "cannot create client";
    uint64_t v11 = v9;
    uint32_t v12 = 2;
LABEL_16:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    goto LABEL_11;
  }
  uint64_t v15 = v17;
  uint64_t v16 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = sub_1006D7F24((uint64_t)&v15, a2, a3);
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (!HIDWORD(v7))
  {
    uint64_t v8 = 1;
    goto LABEL_12;
  }
  char v13 = a1[1];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v20 = a2;
    __int16 v21 = 2080;
    __int16 v22 = a3;
    unint64_t v10 = "Error linking %s to %s";
    uint64_t v11 = v13;
    uint32_t v12 = 22;
    goto LABEL_16;
  }
LABEL_11:
  uint64_t v8 = 0;
LABEL_12:
  if (v18) {
    sub_10004D2C8(v18);
  }
  return v8;
}

void sub_100AE2618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE2644(void *a1, char *a2, char *a3, char *a4)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v16);
  if (v16)
  {
    char v15 = 0;
    uint64_t v13 = v16;
    uint64_t v14 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1006D915C((uint64_t)&v13, a2, a3, a4, &v15);
    if (v14) {
      sub_10004D2C8(v14);
    }
    BOOL v9 = v15 != 0;
    if (!v15)
    {
      unint64_t v10 = a1[1];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446722;
        int v19 = a4;
        __int16 v20 = 2082;
        __int16 v21 = a2;
        __int16 v22 = 2082;
        CFPropertyListRef v23 = a3;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to move file %{public}s from %{public}s to %{public}s", buf, 0x20u);
      }
    }
  }
  else
  {
    uint64_t v11 = a1[1];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    BOOL v9 = 0;
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v9;
}

void sub_100AE27F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE281C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = 0;
  __int16 v20 = 0;
  long long v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v19);
  if (!v19)
  {
    BOOL v9 = a1[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v10 = "cannot create client";
    uint64_t v11 = v9;
    uint32_t v12 = 2;
LABEL_22:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    goto LABEL_11;
  }
  uint64_t v17 = v19;
  __int16 v18 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = sub_1006D83B8((uint64_t)&v17, a2, a3);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (!HIDWORD(v7))
  {
    uint64_t v8 = 1;
    goto LABEL_12;
  }
  uint64_t v13 = a1[1];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = *(void *)a2;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v16 = a3;
    }
    else {
      uint64_t v16 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v22 = v15;
    __int16 v23 = 2080;
    uint64_t v24 = v16;
    unint64_t v10 = "Could not remove file from path: %{public}s and domain: %s";
    uint64_t v11 = v13;
    uint32_t v12 = 22;
    goto LABEL_22;
  }
LABEL_11:
  uint64_t v8 = 0;
LABEL_12:
  if (v20) {
    sub_10004D2C8(v20);
  }
  return v8;
}

void sub_100AE29C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE29F4(void *a1, char *a2, char *a3, char *a4)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v8 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v8, &v18);
  if (!v18)
  {
    uint64_t v14 = a1[1];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
LABEL_11:
    uint64_t v13 = 0;
    goto LABEL_13;
  }
  uint64_t v16 = v18;
  uint64_t v17 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v9 = sub_1006D79D4((uint64_t)&v16, a2, a3, a4);
  int v10 = v9;
  unint64_t v11 = HIDWORD(v9);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v11)
  {
    uint32_t v12 = a1[1];
    uint64_t v13 = 0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    *(_DWORD *)long long buf = 136446722;
    __int16 v21 = a3;
    __int16 v22 = 1024;
    int v23 = v10;
    __int16 v24 = 1024;
    int v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Problem linking preference file %{public}s: domain=%d error=%d", buf, 0x18u);
    goto LABEL_11;
  }
  uint64_t v13 = 1;
LABEL_13:
  if (v19) {
    sub_10004D2C8(v19);
  }
  return v13;
}

void sub_100AE2BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE2BCC(void *a1, char *a2)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  long long v4 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v4, &v13);
  if (v13)
  {
    char v12 = 0;
    uint64_t v10 = v13;
    unint64_t v11 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v5 = (unint64_t)sub_1006DB63C((uint64_t)&v10, a2, &v12) >> 32;
    if (v11) {
      sub_10004D2C8(v11);
    }
    BOOL v6 = v5 == 0;
    if (v5)
    {
      unint64_t v7 = a1[1];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v16 = a2;
        __int16 v17 = 1024;
        int v18 = v5;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Problem creating directory: %{public}s, error=%d", buf, 0x12u);
      }
    }
  }
  else
  {
    uint64_t v8 = a1[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
    BOOL v6 = 0;
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  return v6;
}

void sub_100AE2D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE2D84(void *a1)
{
  uint64_t v11 = 0;
  char v12 = 0;
  uint64_t v2 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v2, &v11);
  if (!v11)
  {
    BOOL v6 = a1[1];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "cannot create client", buf, 2u);
    }
LABEL_11:
    BOOL v5 = 0;
    goto LABEL_13;
  }
  char v10 = 0;
  uint64_t v8 = v11;
  unint64_t v9 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v3 = (unint64_t)sub_1006DBB04((uint64_t)&v8, &v10) >> 32;
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v3)
  {
    long long v4 = a1[1];
    BOOL v5 = 0;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    *(_DWORD *)long long buf = 67109120;
    int v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Error reading automatic bundle update preference: error=%d", buf, 8u);
    goto LABEL_11;
  }
  BOOL v5 = v10 != 0;
LABEL_13:
  if (v12) {
    sub_10004D2C8(v12);
  }
  return v5;
}

void sub_100AE2F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100AE2F34(void *a1, uint64_t a2)
{
  uint64_t v16 = 0;
  __int16 v17 = 0;
  long long v4 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v4, &v16);
  if (!v16)
  {
    char v10 = a1[1];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_18:
      BOOL v8 = 0;
      goto LABEL_19;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v11 = "cannot create mobile helper client";
LABEL_24:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, buf, 2u);
    goto LABEL_18;
  }
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (!v5)
  {
    char v10 = a1[1];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v11 = "Path for fileExists call is empty.";
    goto LABEL_24;
  }
  char v15 = 0;
  uint64_t v13 = v16;
  int v14 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (unint64_t)sub_1006DBE88((uint64_t)&v13, a2, &v15) >> 32;
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v6)
  {
    unint64_t v7 = a1[1];
    BOOL v8 = 0;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v19 = v9;
    __int16 v20 = 1024;
    int v21 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Error when checking if %s exists: Error code: %d", buf, 0x12u);
    goto LABEL_18;
  }
  BOOL v8 = v15 != 0;
LABEL_19:
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v8;
}

void sub_100AE3120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE314C(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v22 = 0;
  int v23 = 0;
  unint64_t v6 = (const char *)(*(uint64_t (**)(void *))(*a1 + 144))(a1);
  sub_1006D6404(v6, &v22);
  if (!v22)
  {
    int v14 = a1[1];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_20:
      *a3 = 0;
      goto LABEL_27;
    }
    *(_WORD *)long long buf = 0;
    char v15 = "cannot create mobile helper client";
LABEL_36:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    goto LABEL_20;
  }
  uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  if (!v7)
  {
    int v14 = a1[1];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_WORD *)long long buf = 0;
    char v15 = "Path for copyAttributes call is empty.";
    goto LABEL_36;
  }
  uint64_t v19 = v22;
  __int16 v20 = v23;
  int v21 = 0;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v8 = (unint64_t)sub_1006DC2E4((uint64_t)&v19, a2, &v21) >> 32;
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v8)
  {
    uint64_t v9 = a1[1];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = a2;
      }
      else {
        uint64_t v10 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v25 = v10;
      __int16 v26 = 1024;
      int v27 = v8;
      uint64_t v11 = "#N Error when copying attributes for %s: Error code: %d";
      char v12 = v9;
      uint32_t v13 = 18;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
    }
  }
  else
  {
    if (v21) {
      uint64_t v16 = sub_100080778;
    }
    else {
      uint64_t v16 = 0;
    }
    if (v16)
    {
      *a3 = v21;
      int v21 = 0;
      goto LABEL_26;
    }
    __int16 v17 = a1[1];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v18 = a2;
      }
      else {
        uint64_t v18 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v25 = v18;
      uint64_t v11 = "#N Copy attributes returned NULL for %s:";
      char v12 = v17;
      uint32_t v13 = 12;
      goto LABEL_15;
    }
  }
  *a3 = 0;
LABEL_26:
  sub_100057D78(&v21);
LABEL_27:
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_100AE33B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, const void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_100057D78(&a12);
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_100AE33E8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  MobileHelperInterface::~MobileHelperInterface((MobileHelperInterface *)a1);
}

void sub_100AE3430(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  MobileHelperInterface::~MobileHelperInterface((MobileHelperInterface *)a1);

  operator delete();
}

void sub_100AE3490(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100AE34C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100AE34F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100AE353C(ServiceManager::Service *this)
{
  *(void *)this = off_101A39E40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100AE3598(ServiceManager::Service *this)
{
  *(void *)this = off_101A39E40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100AE3608@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = (char *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8));

  return sub_100058DB0(a2, v3);
}

unsigned char *sub_100AE3668@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100AE36A4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v2);
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

uint64_t sub_100AE3700()
{
  return 0;
}

uint64_t sub_100AE3708()
{
  return 1;
}

uint64_t sub_100AE3710()
{
  return 0;
}

const void **sub_100AE3724(const void **a1)
{
  uint64_t v2 = (const void **)a1[1];
  if (*a1)
  {
    unint64_t v3 = *v2;
    *uint64_t v2 = *a1;
    unint64_t v6 = v3;
  }
  else
  {
    long long v4 = *v2;
    *uint64_t v2 = 0;
    unint64_t v6 = v4;
  }
  sub_1000577C4(&v6);
  return a1;
}

uint64_t sub_100AE377C(uint64_t a1)
{
  *(void *)a1 = off_101A39EC0;
  sub_100AE6E38(*(void **)(a1 + 40));
  *(void *)a1 = off_101A39F78;
  unint64_t v3 = (void **)(a1 + 8);
  sub_100AE590C(&v3);
  return a1;
}

void sub_100AE37FC(uint64_t a1)
{
  sub_100AE377C(a1);

  operator delete();
}

void sub_100AE3834()
{
}

void sub_100AE388C()
{
}

void sub_100AE38B0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = off_101A39EE0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(_WORD *)(a1 + 84) = 257;
  *(unsigned char *)(a1 + 86) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = "";
  *(void *)(a1 + 104) = "";
  *(_DWORD *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = 2;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 14sub_1001A7358((uint64_t)&a9, 0) = 0;
  operator new();
}

void sub_100AE39BC(_Unwind_Exception *a1)
{
  long long v4 = *(std::__shared_weak_count **)(v1 + 136);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000346F8(v2, *(void **)(v1 + 64));
  sub_10005D144(*(void **)(v1 + 40));
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100AE39F4(uint64_t a1)
{
  *(void *)a1 = off_101A39EE0;
  sub_10005CD2C(a1 + 152, *(char **)(a1 + 160));
  uint64_t v2 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000346F8(a1 + 56, *(void **)(a1 + 64));
  sub_10005D144(*(void **)(a1 + 40));
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100AE3A9C(uint64_t a1)
{
  sub_100AE39F4(a1);

  operator delete();
}

void sub_100AE3AD4(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v6 = *a2;
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = a1;
  long long v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v5 = sub_100AE6FF4(*(void **)(a1 + 144), &v6);
  sub_100AE72B4((unint64_t *)(v5 + 24), 0x24uLL);
  sub_100AE734C((uint64_t *)(v5 + 48), 0x24uLL);
  sub_100AE73F0((void *)(v5 + 72), 0x24uLL);
  sub_100AE7490((uint64_t *)(v5 + 96), 0x24uLL);
  *(unsigned char *)(v5 + 12sub_1001A7358((uint64_t)&a9, 0) = 0;
  os_unfair_lock_unlock(v4);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100AE3B80(os_unfair_lock_s *a1, int a2)
{
  int v7 = a2;
  uint64_t v8 = a1;
  unint64_t v3 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  uint64_t v4 = 0;
  uint64_t v5 = (uint64_t **)&a1[8];
  do
  {
    uint64_t v9 = &v7;
    uint64_t v6 = &sub_100AE8930(v5, &v7, (uint64_t)&unk_10144E20E, &v9)[v4];
    *((_DWORD *)v6 + 8) = 2;
    *((unsigned char *)v6 + 36) = 0;
    ++v4;
  }
  while (v4 != 10);
  os_unfair_lock_unlock(v3);
}

void sub_100AE3C24(uint64_t a1, int a2, unsigned int a3, int a4)
{
  int v9 = a2;
  unsigned int v10 = a3;
  int v11 = a4;
  uint64_t v12 = a1;
  int v7 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (a3 <= 9)
  {
    uint32_t v13 = &v9;
    uint64_t v8 = sub_100AE8930((uint64_t **)(a1 + 32), &v9, (uint64_t)&unk_10144E20E, &v13);
    LODWORD(v8[v10 + 4]) = a4;
  }
  os_unfair_lock_unlock(v7);
}

void sub_100AE3CB8(uint64_t a1, int a2, unsigned int a3, char a4)
{
  if (a3 <= 9)
  {
    int v8 = a2;
    unsigned int v9 = a3;
    char v10 = a4;
    uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
    uint64_t v11 = a1;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
    uint64_t v12 = &v8;
    int v7 = sub_100AE8930((uint64_t **)(a1 + 32), &v8, (uint64_t)&unk_10144E20E, &v12);
    BYTE4(v7[v9 + 4]) = a4;
    os_unfair_lock_unlock(v6);
  }
}

void sub_100AE3D48(os_unfair_lock_s *a1, int a2, _DWORD *a3)
{
  int v9 = a2;
  char v10 = a3;
  uint64_t v11 = a1;
  uint64_t v4 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  uint64_t v5 = 0;
  uint64_t v6 = (uint64_t **)&a1[8];
  uint64_t v7 = 36;
  while (1)
  {
    uint64_t v12 = &v9;
    int v8 = sub_100AE8930(v6, &v9, (uint64_t)&unk_10144E20E, &v12);
    if (!*((unsigned char *)v8 + v7)) {
      break;
    }
    ++v5;
    v7 += 8;
    if (v5 == 10) {
      goto LABEL_6;
    }
  }
  *((unsigned char *)v8 + v7) = 1;
  *char v10 = v5;
LABEL_6:
  os_unfair_lock_unlock(v4);
}

uint64_t sub_100AE3E00(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (a3 > 9) {
    goto LABEL_12;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v8 = a1 + 40;
  uint64_t v7 = v9;
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = v8;
  do
  {
    int v11 = *(_DWORD *)(v7 + 28);
    BOOL v12 = v11 < a2;
    if (v11 >= a2) {
      uint32_t v13 = (uint64_t *)v7;
    }
    else {
      uint32_t v13 = (uint64_t *)(v7 + 8);
    }
    if (!v12) {
      uint64_t v10 = v7;
    }
    uint64_t v7 = *v13;
  }
  while (*v13);
  if (v10 != v8 && (v15 = *(_DWORD *)(v10 + 28), uint64_t v14 = v10 + 28, v15 <= a2)) {
    uint64_t v16 = *(unsigned int *)(v14 + 8 * a3 + 4);
  }
  else {
LABEL_12:
  }
    uint64_t v16 = 2;
  os_unfair_lock_unlock(v6);
  return v16;
}

void sub_100AE3E9C(uint64_t a1, int a2, char a3)
{
  int v6 = a2;
  char v7 = a3;
  uint64_t v8 = a1;
  uint64_t v5 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v9 = &v6;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 56), &v6, (uint64_t)&unk_10144E20E, &v9) + 32) = a3;
  os_unfair_lock_unlock(v5);
}

uint64_t sub_100AE3F1C(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v6 = a1 + 64;
  uint64_t v5 = v7;
  if (v7)
  {
    uint64_t v8 = v6;
    do
    {
      int v9 = *(_DWORD *)(v5 + 28);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        int v11 = (uint64_t *)v5;
      }
      else {
        int v11 = (uint64_t *)(v5 + 8);
      }
      if (!v10) {
        uint64_t v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 == v6 || *(_DWORD *)(v8 + 28) > a2)
    {
      unsigned int v12 = 0;
      LODWORD(v5) = 0;
    }
    else
    {
      unsigned int v12 = *(unsigned __int8 *)(v8 + 32);
      LODWORD(v5) = 1;
    }
  }
  else
  {
    unsigned int v12 = 0;
  }
  uint64_t v13 = v12 | (v5 << 8);
  os_unfair_lock_unlock(v4);
  return v13;
}

void sub_100AE3FBC(os_unfair_lock_s *a1, int a2)
{
  int v4 = a2;
  uint64_t v5 = a1;
  unint64_t v3 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  sub_100AE8A00((uint64_t)&a1[14], &v4);
  os_unfair_lock_unlock(v3);
}

void sub_100AE4010(uint64_t a1, uint64_t *a2, int a3)
{
  int v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v6 = *a2;
  uint64_t v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = a3;
  uint64_t v9 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v5 = sub_100AE6FF4(*(void **)(a1 + 144), &v6);
  sub_100AE8A7C(v5, v8);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100AE4090(uint64_t a1, uint64_t a2, _DWORD *a3, char *a4, uint64_t a5, uint64_t *a6)
{
  int v8 = *(std::__shared_weak_count **)(a2 + 8);
  int v11 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *a3 = *(_DWORD *)(a1 + 80);
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v10 = sub_10003B080(*(void *)(a1 + 144));
    if (a4 != (char *)v10) {
      sub_100AE8CC0(a4, *(char **)v10, *(void *)(v10 + 8), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 3));
    }
    if (a5 != v10 + 24) {
      sub_100AE8E20(a5, *(void *)(v10 + 24), *(void *)(v10 + 32), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v10 + 32) - *(void *)(v10 + 24)) >> 4));
    }
    if (a6 != (uint64_t *)(v10 + 48)) {
      sub_100AE9090(a6, *(long long **)(v10 + 48), *(long long **)(v10 + 56), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v10 + 56) - *(void *)(v10 + 48)) >> 3));
    }
  }
  os_unfair_lock_unlock(v9);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100AE41C4(uint64_t a1, uint64_t a2, int a3, __n128 *a4, uint64_t a5, uint64_t a6)
{
  int v11 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *(_DWORD *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = a3;
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v12 = sub_10003B080(*(void *)(a1 + 144));
    sub_10005C9A4(v12, a4);
    sub_100AE8F80((void **)(v12 + 24));
    *(_OWORD *)(v12 + 24) = *(_OWORD *)a5;
    *(void *)(v12 + 4sub_1001A7358((uint64_t)&a9, 0) = *(void *)(a5 + 16);
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    sub_100AE9224((uint64_t *)(v12 + 48));
    *(_OWORD *)(v12 + 48) = *(_OWORD *)a6;
    *(void *)(v12 + 64) = *(void *)(a6 + 16);
    *(void *)a6 = 0;
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
  }

  os_unfair_lock_unlock(v11);
}

void sub_100AE42A0(uint64_t a1, uint64_t a2, char a3)
{
  int v4 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v5 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144))) {
    *(unsigned char *)(sub_10003B080(*(void *)(a1 + 144)) + 12sub_1001A7358((uint64_t)&a9, 0) = a3;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  if (v5) {
    sub_10004D2C8(v5);
  }
}

BOOL sub_100AE4330(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144))) {
    BOOL v5 = *(unsigned char *)(sub_10003B080(*(void *)(a1 + 144)) + 120) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  os_unfair_lock_unlock(v4);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return v5;
}

void sub_100AE43CC(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  int v8 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_100030B54(*(void *)(a1 + 144), a2)
    && (uint64_t v9 = (void *)sub_100030228(*(void *)(a1 + 144), a2),
        0x86BCA1AF286BCA1BLL * ((uint64_t)(v9[1] - *v9) >> 3) > a3))
  {
    uint64_t v10 = *v9 + 152 * a3;
    long long v11 = *(_OWORD *)(v10 + 112);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(v10 + 96);
    *(_OWORD *)(a4 + 112) = v11;
    *(_OWORD *)(a4 + 128) = *(_OWORD *)(v10 + 128);
    *(void *)(a4 + 144) = *(void *)(v10 + 144);
    long long v12 = *(_OWORD *)(v10 + 48);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(v10 + 32);
    *(_OWORD *)(a4 + 48) = v12;
    long long v13 = *(_OWORD *)(v10 + 80);
    *(_OWORD *)(a4 + 64) = *(_OWORD *)(v10 + 64);
    *(_OWORD *)(a4 + 8sub_1001A7358((uint64_t)&a9, 0) = v13;
    long long v14 = *(_OWORD *)(v10 + 16);
    *(_OWORD *)a4 = *(_OWORD *)v10;
    *(_OWORD *)(a4 + 16) = v14;
  }
  else
  {
    *(unsigned char *)(a4 + 8) = 0;
    *(void *)a4 = 0;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 8sub_1001A7358((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_DWORD *)(a4 + 144) = 0;
  }

  os_unfair_lock_unlock(v8);
}

void sub_100AE44D0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  long long v5 = *(_OWORD *)(a1 + 104);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(a1 + 128);
  *(void *)(a2 + 32) = *(void *)(a1 + 120);
  *(void *)(a2 + 4sub_1001A7358((uint64_t)&a9, 0) = v6;
  uint64_t v7 = *(void *)(a1 + 136);
  *(void *)(a2 + 48) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }

  os_unfair_lock_unlock(v4);
}

void sub_100AE4548(uint64_t a1, long long *a2)
{
  long long v7 = *a2;
  long long v8 = a2[1];
  uint64_t v3 = *((void *)a2 + 5);
  uint64_t v9 = *((void *)a2 + 4);
  int v4 = (std::__shared_weak_count *)*((void *)a2 + 6);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v5 = (os_unfair_lock_s *)(a1 + 24);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
    *(_OWORD *)(a1 + 88) = v7;
    *(_OWORD *)(a1 + 104) = v8;
    *(void *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = v9;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    long long v5 = (os_unfair_lock_s *)(a1 + 24);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
    *(_OWORD *)(a1 + 88) = v7;
    *(_OWORD *)(a1 + 104) = v8;
    *(void *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = v9;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v3;
  *(void *)(a1 + 136) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  os_unfair_lock_unlock(v5);
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100AE4634(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_100030B54(*(void *)(a1 + 144), a2))
  {
    uint64_t v7 = sub_100030228(*(void *)(a1 + 144), a2);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    sub_100AE7A2C(a3, *(long long **)(v7 + 48), *(long long **)(v7 + 56), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v7 + 56) - *(void *)(v7 + 48)) >> 3));
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }

  os_unfair_lock_unlock(v6);
}

void sub_100AE46E0(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_100030B54(*(void *)(a1 + 144), a2))
  {
    uint64_t v7 = sub_100030228(*(void *)(a1 + 144), a2);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    sub_100AE7C24(a3, *(void *)(v7 + 72), *(void *)(v7 + 80), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(v7 + 80) - *(void *)(v7 + 72)) >> 3));
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }

  os_unfair_lock_unlock(v6);
}

void sub_100AE478C(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  long long v8 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_DWORD *)a4 = 1;
  *(void *)(a4 + 8) = "";
  *(void *)(a4 + 16) = "";
  *(_DWORD *)(a4 + 32) = 2;
  *(void *)(a4 + 44) = 0;
  *(void *)(a4 + 36) = 0;
  *(_DWORD *)(a4 + 52) = 0;
  if (sub_100030B54(*(void *)(a1 + 144), a2))
  {
    uint64_t v9 = sub_100030228(*(void *)(a1 + 144), a2);
    if ((a3 & 0x80000000) == 0)
    {
      uint64_t v10 = *(void *)(v9 + 48);
      if (0x6DB6DB6DB6DB6DB7 * ((*(void *)(v9 + 56) - v10) >> 3) > (unint64_t)a3)
      {
        uint64_t v11 = v10 + 56 * a3;
        long long v12 = *(_OWORD *)(v11 + 16);
        *(_OWORD *)a4 = *(_OWORD *)v11;
        *(_OWORD *)(a4 + 16) = v12;
        uint64_t v13 = *(void *)(v11 + 40);
        *(void *)(a4 + 32) = *(void *)(v11 + 32);
        uint64_t v14 = *(void *)(v11 + 48);
        if (v14) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)(a4 + 4sub_1001A7358((uint64_t)&a9, 0) = v13;
        *(void *)(a4 + 48) = v14;
      }
    }
  }

  os_unfair_lock_unlock(v8);
}

void sub_100AE4898(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 8);
  long long v12 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *(_OWORD *)(a4 + 8) = 0u;
  *(void *)(a4 + 72) = 0;
  *(_OWORD *)(a4 + 56) = 0u;
  *(_DWORD *)a4 = -3;
  *(void *)(a4 + 4) = 0;
  *(unsigned char *)(a4 + 12) = 0;
  *(void *)(a4 + 16) = 0x200000002;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 8sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(void *)(a4 + 136) = 0;
  *(void *)(a4 + 128) = a4 + 136;
  *(void *)(a4 + 144) = 0;
  *(_OWORD *)(a4 + 4sub_1001A7358((uint64_t)&a9, 0) = 0u;
  *(void *)(a4 + 7sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v8 = sub_10003B080(*(void *)(a1 + 144));
    if ((a3 & 0x80000000) == 0)
    {
      uint64_t v9 = *(void *)(v8 + 72);
      if (0x86BCA1AF286BCA1BLL * ((*(void *)(v8 + 80) - v9) >> 3) > a3)
      {
        uint64_t v10 = (const std::string *)(v9 + 152 * a3);
        long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
        *(void *)(a4 + 16) = *((void *)&v10->__r_.__value_.__l + 2);
        *(_OWORD *)a4 = v11;
        std::string::operator=((std::string *)(a4 + 24), v10 + 1);
        std::string::operator=((std::string *)(a4 + 48), v10 + 2);
        *(_DWORD *)(a4 + 72) = v10[3].__r_.__value_.__l.__data_;
        *(_WORD *)(a4 + 76) = WORD2(v10[3].__r_.__value_.__r.__words[0]);
        sub_10000C1DC((void *)(a4 + 80), &v10[3].__r_.__value_.__l.__size_);
        if (v10 != (const std::string *)a4) {
          sub_10005DA3C((uint64_t **)(a4 + 128), *(void **)(v9 + 152 * a3 + 128), (void *)(v9 + 152 * a3 + 136));
        }
      }
    }
  }
  os_unfair_lock_unlock(v7);
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100AE4A3C(void *a1)
{
  sub_100AE5B98(v1);
  sub_10006A6AC(a1);
}

void sub_100AE4A54(os_unfair_lock_s *a1, uint64_t a2, unsigned int a3, long long *a4)
{
  long long v5 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v14 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100AE5CBC((uint64_t)&v16, a4);
  uint64_t v25 = a1;
  uint64_t v6 = a1 + 6;
  os_unfair_lock_lock(v6);
  uint64_t v7 = v25;
  if (sub_10003AF4C(*(void *)&v25[36]._os_unfair_lock_opaque))
  {
    uint64_t v8 = sub_10003B080(*(void *)&v7[36]._os_unfair_lock_opaque);
    if ((a3 & 0x80000000) == 0)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v8 + 72);
      if (0x86BCA1AF286BCA1BLL * ((*(void *)(v8 + 80) - v10) >> 3) > a3)
      {
        uint64_t v11 = v10 + 152 * a3;
        long long v12 = v16;
        *(void *)(v11 + 16) = v17;
        *(_OWORD *)uint64_t v11 = v12;
        std::string::operator=((std::string *)(v11 + 24), &v18);
        std::string::operator=((std::string *)(v11 + 48), &__p);
        *(_DWORD *)(v11 + 72) = v20;
        *(_WORD *)(v11 + 76) = v21;
        sub_10000C1DC((void *)(v11 + 80), v22);
        if ((long long *)v11 != &v16) {
          sub_10005DA3C((uint64_t **)(v10 + 152 * a3 + 128), v23, &v24);
        }
      }
      if ((a3 & 0x80000000) == 0)
      {
        uint64_t v13 = *(void *)(v9 + 96);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v9 + 104) - v13) >> 4) > a3) {
          sub_10000C1DC((void *)(v13 + 48 * a3), v22);
        }
      }
    }
  }
  os_unfair_lock_unlock(v6);
  sub_10005D9E0((uint64_t)&v23, v24);
  sub_10005DBA4(v22);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100AE4C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE4C54(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (!sub_100030B54(*(void *)(a1 + 144), a2)
    || (uint64_t v9 = sub_100030228(*(void *)(a1 + 144), a2), (a3 & 0x80000000) != 0)
    || (uint64_t v10 = *(void *)(v9 + 96), 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v9 + 104) - v10) >> 4) <= a3))
  {
    QosFlowsContainerDefault = (void *)getQosFlowsContainerDefault();
  }
  else
  {
    QosFlowsContainerDefault = (void *)(v10 + 48 * a3);
  }
  sub_100AE60F4(a4, QosFlowsContainerDefault);

  os_unfair_lock_unlock(v8);
}

void sub_100AE4D14(os_unfair_lock_s *a1, uint64_t a2, unsigned int a3, void *a4)
{
  long long v5 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v10 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100AE60F4((uint64_t)v12, a4);
  uint64_t v13 = a1;
  uint64_t v6 = a1 + 6;
  os_unfair_lock_lock(v6);
  uint64_t v7 = v13;
  if (sub_10003AF4C(*(void *)&v13[36]._os_unfair_lock_opaque))
  {
    uint64_t v8 = sub_10003B080(*(void *)&v7[36]._os_unfair_lock_opaque);
    if ((a3 & 0x80000000) == 0)
    {
      uint64_t v9 = *(void *)(v8 + 96);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v8 + 104) - v9) >> 4) > a3) {
        sub_10000C1DC((void *)(v9 + 48 * a3), v12);
      }
    }
  }
  os_unfair_lock_unlock(v6);
  sub_10005DBA4(v12);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100AE4DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE4E14(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v5 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v8 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v6 = sub_10003B080(*(void *)(a1 + 144));
    long long v7 = *(_OWORD *)(v6 + 140);
    *(_OWORD *)a3 = *(_OWORD *)(v6 + 124);
    *(_OWORD *)(a3 + 16) = v7;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(v6 + 156);
    *(void *)(a3 + 48) = *(void *)(v6 + 172);
  }
  else
  {
    *(_WORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(unsigned char *)(a3 + 8) = 0;
    *(void *)(a3 + 12) = -4294967285;
    *(_DWORD *)(a3 + 32) = 0;
    *(unsigned char *)(a3 + 36) = 0;
    *(_DWORD *)(a3 + 52) = 0;
    *(void *)(a3 + 2sub_1001A7358((uint64_t)&a9, 0) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
    *(unsigned char *)(a3 + 48) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100AE4EF8(uint64_t a1, uint64_t a2, long long *a3)
{
  int v4 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  uint64_t v10 = *((void *)a3 + 6);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v5 = sub_10003B080(*(void *)(a1 + 144));
    *(_OWORD *)(v5 + 124) = v7;
    *(_OWORD *)(v5 + 14sub_1001A7358((uint64_t)&a9, 0) = v8;
    *(_OWORD *)(v5 + 156) = v9;
    *(void *)(v5 + 172) = v10;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100AE4FBC(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v7 = *(void *)(a1 + 144);
  uint64_t v10 = *(void *)(v7 + 40);
  uint64_t v8 = v7 + 40;
  uint64_t v9 = v10;
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = v8;
  do
  {
    int v12 = *(_DWORD *)(v9 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      uint64_t v14 = (uint64_t *)v9;
    }
    else {
      uint64_t v14 = (uint64_t *)(v9 + 8);
    }
    if (!v13) {
      uint64_t v11 = v9;
    }
    uint64_t v9 = *v14;
  }
  while (*v14);
  if (v11 != v8 && *(_DWORD *)(v11 + 32) <= a2)
  {
    long long v15 = *(_OWORD *)(v11 + 40);
    *(_OWORD *)(a3 + 9) = *(_OWORD *)(v11 + 49);
    *(_OWORD *)a3 = v15;
    sub_100AE6D80((unsigned char *)(a3 + 32), v11 + 72);
    *(_DWORD *)(a3 + 192) = *(_DWORD *)(v11 + 232);
  }
  else
  {
LABEL_11:
    *(unsigned char *)(a3 + 12) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(unsigned char *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 0;
    *(unsigned char *)(a3 + 184) = 0;
    *(_DWORD *)(a3 + 192) = 0;
    *(void *)a3 = 0;
    *(unsigned char *)(a3 + 8) = 0;
  }

  os_unfair_lock_unlock(v6);
}

uint64_t sub_100AE5098(os_unfair_lock_s *a1, int a2, uint64_t a3)
{
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a3;
  *(_OWORD *)&v9[9] = *(_OWORD *)(a3 + 9);
  sub_100AE6D80(v10, a3 + 32);
  int v11 = *(_DWORD *)(a3 + 192);
  int v12 = a1;
  v13[0] = a2;
  os_unfair_lock_lock(a1 + 6);
  uint64_t v6 = (uint64_t **)(*(void *)&v12[36]._os_unfair_lock_opaque + 32);
  uint64_t v14 = v13;
  uint64_t v7 = sub_100AE9874(v6, v13, (uint64_t)&unk_10144E20E, &v14);
  *(_OWORD *)(v7 + 5) = *(_OWORD *)v9;
  *(_OWORD *)((char *)v7 + 49) = *(_OWORD *)&v9[9];
  sub_100AE99F0((uint64_t)(v7 + 9), (uint64_t)v10);
  *((_DWORD *)v7 + 58) = v11;
  os_unfair_lock_unlock(a1 + 6);
  return sub_100AE6DD8((uint64_t)v10);
}

uint64_t sub_100AE5180(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144))) {
    uint64_t v5 = *(unsigned __int8 *)(sub_10003B080(*(void *)(a1 + 144)) + 188);
  }
  else {
    uint64_t v5 = 0;
  }
  os_unfair_lock_unlock(v4);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return v5;
}

void sub_100AE5214(uint64_t a1, uint64_t a2, char a3)
{
  int v4 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v5 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144))) {
    *(unsigned char *)(sub_10003B080(*(void *)(a1 + 144)) + 188) = a3;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  if (v5) {
    sub_10004D2C8(v5);
  }
}

uint64_t sub_100AE52A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144))) {
    uint64_t v5 = *(void *)(sub_10003B080(*(void *)(a1 + 144)) + 180);
  }
  else {
    uint64_t v5 = 0;
  }
  os_unfair_lock_unlock(v4);
  if (v7) {
    sub_10004D2C8(v7);
  }
  return v5;
}

BOOL sub_100AE5338(uint64_t a1, uint64_t a2, BOOL a3, int a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  long long v16 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_10003AF4C(*(void *)(a1 + 144)))
  {
    uint64_t v7 = sub_10003B080(*(void *)(a1 + 144));
    BOOL v8 = *(unsigned __int8 *)(v7 + 180) != a3;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "DataServiceCache");
    uint64_t v9 = *(NSObject **)&v20[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = subscriber::asString();
      uint64_t v11 = asStringBool(*(unsigned char *)(v7 + 180));
      uint64_t v12 = asStringBool(a3);
      uint64_t v13 = asString();
      uint64_t v14 = asString();
      *(_DWORD *)long long buf = 136316162;
      *(void *)int v20 = v10;
      *(_WORD *)&char v20[8] = 2080;
      *(void *)&v20[10] = v11;
      __int16 v21 = 2080;
      uint64_t v22 = v12;
      __int16 v23 = 2080;
      uint64_t v24 = v13;
      __int16 v25 = 2080;
      uint64_t v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "(change states) setInHome(%s): %s ==> %s (dataMode %s ==> %s)", buf, 0x34u);
    }
    *(unsigned char *)(v7 + 18sub_1001A7358((uint64_t)&a9, 0) = a3;
    *(_DWORD *)(v7 + 184) = a4;
  }
  else
  {
    BOOL v8 = 0;
  }
  os_unfair_lock_unlock(v6);
  if (v16) {
    sub_10004D2C8(v16);
  }
  return v8;
}

void sub_100AE5500(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100AE550C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_100030B54(*(void *)(a1 + 144), a2))
  {
    uint64_t v7 = sub_100030228(*(void *)(a1 + 144), a2);
    uint64_t v8 = *(void *)(v7 + 200);
    *a3 = *(void *)(v7 + 192);
    a3[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }

  os_unfair_lock_unlock(v6);
}

void sub_100AE559C(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = (std::__shared_weak_count *)a3[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  if (sub_100030B54(*(void *)(a1 + 144), a2))
  {
    uint64_t v8 = sub_100030228(*(void *)(a1 + 144), a2);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(v8 + 200);
    *(void *)(v8 + 192) = v6;
    *(void *)(v8 + 20sub_1001A7358((uint64_t)&a9, 0) = v5;
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "DataServiceCache");
    uint64_t v10 = *(NSObject **)&v13[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = subscriber::asString();
      int v12 = 136315138;
      *(void *)uint64_t v13 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "setInterfaceAppMapperService was called on a wrong SIM: %s", (uint8_t *)&v12, 0xCu);
    }
  }
  os_unfair_lock_unlock(v7);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100AE56F4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100AE5700(os_unfair_lock_s *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  uint64_t v6 = a1;
  uint64_t v3 = a1 + 6;
  os_unfair_lock_lock(v3);
  sub_100046BAC((uint64_t **)&v6[38], __p, (uint64_t)__p);
  os_unfair_lock_unlock(v3);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

BOOL sub_100AE5794(os_unfair_lock_s *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = *(void *)(a2 + 16);
  }
  uint64_t v9 = a1;
  uint64_t v3 = a1 + 6;
  os_unfair_lock_lock(v3);
  int v4 = v9;
  uint64_t v5 = sub_100046F68((uint64_t)&v9[38], __p);
  os_unfair_lock_unlock(v3);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  return &v4[40] != (os_unfair_lock_s *)v5;
}

uint64_t sub_100AE583C(uint64_t a1)
{
  *(void *)a1 = off_101A39F78;
  uint64_t v3 = (void **)(a1 + 8);
  sub_100AE590C(&v3);
  return a1;
}

void sub_100AE5894(uint64_t a1)
{
  *(void *)a1 = off_101A39F78;
  uint64_t v1 = (void **)(a1 + 8);
  sub_100AE590C(&v1);

  operator delete();
}

void sub_100AE590C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_100AE5990(v4 - 224);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100AE5990(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 216);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 200);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v6 = (void **)(a1 + 96);
  sub_100AE5A24(&v6);
  uint64_t v6 = (void **)(a1 + 72);
  sub_100AE5AA8(&v6);
  uint64_t v6 = (void **)(a1 + 48);
  sub_1002AC5A8(&v6);
  uint64_t v6 = (void **)(a1 + 24);
  sub_100AE5BF0(&v6);
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_100AE5A24(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_10005DBA4((void *)(v4 - 48));
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100AE5AA8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 152;
        sub_100AE5B2C(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100AE5B2C(uint64_t a1)
{
  sub_10005D9E0(a1 + 128, *(void **)(a1 + 136));
  sub_10005DBA4((void *)(a1 + 80));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

uint64_t sub_100AE5B98(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100AE5BF0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        sub_100AE5C74(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100AE5C74(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 48);
  sub_100047F64(&v2);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

uint64_t sub_100AE5CBC(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 48) = v6;
  }
  *(_DWORD *)(a1 + 72) = *((_DWORD *)a2 + 18);
  *(_WORD *)(a1 + 76) = *((_WORD *)a2 + 38);
  sub_100AE60F4(a1 + 80, (void *)a2 + 10);
  sub_100AE5DD4((void *)(a1 + 128), (uint64_t)(a2 + 8));
  return a1;
}

void sub_100AE5D90(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AE5DD4(void *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = a1 + 1;
  sub_100AE5E2C((uint64_t)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100AE5E14(_Unwind_Exception *a1)
{
  sub_10005D9E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100AE5E2C(uint64_t result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    long long v5 = (uint64_t **)result;
    long long v6 = (void *)(result + 8);
    do
    {
      uint64_t result = sub_100AE5EB8(v5, v6, (uint64_t)(v4 + 4), (const TrafficDescriptor *)(v4 + 4));
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_100AE5EB8(uint64_t **a1, void *a2, uint64_t a3, const TrafficDescriptor *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  long long v6 = sub_100AE5F5C(a1, a2, &v12, &v11);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1003817F0((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v12, v8, (uint64_t *)v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_100381864(v10, 0);
  }
  return v7;
}

uint64_t *sub_100AE5F5C(void *a1, void *a2, void *a3, uint64_t *a4)
{
  uint64_t v7 = a1 + 1;
  if (a1 + 1 != a2 && !TrafficDescriptor::operator<())
  {
    if (!TrafficDescriptor::operator<())
    {
      *a3 = a2;
      *a4 = (uint64_t)a2;
      return a4;
    }
    a4 = a2 + 1;
    uint64_t v11 = a2[1];
    if (v11)
    {
      uint64_t v12 = (void *)a2[1];
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      long long v16 = a2;
      do
      {
        uint64_t v13 = (void *)v16[2];
        BOOL v15 = *v13 == (void)v16;
        long long v16 = v13;
      }
      while (!v15);
    }
    if (v13 != v7)
    {
      if (!TrafficDescriptor::operator<()) {
        goto LABEL_28;
      }
      uint64_t v11 = *a4;
    }
    if (v11)
    {
      *a3 = v13;
      return v13;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  if ((void *)*a1 == a2)
  {
    uint64_t v10 = a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v10;
      return v10 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  BOOL v9 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v10 = v9;
      BOOL v9 = (void *)v9[1];
    }
    while (v9);
  }
  else
  {
    uint64_t v14 = a2;
    do
    {
      uint64_t v10 = (void *)v14[2];
      BOOL v15 = *v10 == (void)v14;
      uint64_t v14 = v10;
    }
    while (v15);
  }
  if (TrafficDescriptor::operator<()) {
    goto LABEL_16;
  }
LABEL_28:

  return sub_10038175C((uint64_t)a1, a3);
}

uint64_t sub_100AE60F4(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    uint64_t v5 = 0;
    uint64_t v8 = 0;
    uint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0x19));
  }
  else
  {
    uint64_t v5 = *(void *)(v4 + 8 * (v3 / 0x19)) + 160 * (v3 % 0x19);
    unint64_t v6 = a2[5] + v3;
    uint64_t v7 = (void *)(v4 + 8 * (v6 / 0x19));
    uint64_t v8 = *v7 + 160 * (v6 % 0x19);
  }
  sub_100AE61DC((void *)a1, (void *)(v4 + 8 * (v3 / 0x19)), v5, v7, v8);
  return a1;
}

void sub_100AE61C8(_Unwind_Exception *a1)
{
  sub_10005EE1C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AE61DC(void *a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 25 * (a4 - a2) - 0x3333333333333333 * ((a5 - *a4) >> 5) + 0x3333333333333333 * ((a3 - *a2) >> 5);
  }
  return sub_100AE622C(a1, a2, a3, v5);
}

uint64_t sub_100AE622C(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 25 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_100AE63DC(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  uint64_t v13 = (void *)(v8 + 8 * (v11 / 0x19));
  if (v9 == v8) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *v13 + 160 * (v11 % 0x19);
  }
  uint64_t v22 = (void *)(v8 + 8 * (v11 / 0x19));
  unint64_t v23 = v14;
  uint64_t result = (uint64_t)sub_10000C6CC(&v22, a4);
  uint64_t v16 = v23;
  if (v14 != v23)
  {
    uint64_t v17 = v22;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4000;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }
      else
      {
        uint64_t v19 = 0;
        do
        {
          uint64_t result = sub_100AE69A4(v14 + v19, a3);
          a3 += 160;
          if (a3 - *a2 == 4000)
          {
            uint64_t v20 = a2[1];
            ++a2;
            a3 = v20;
          }
          v19 += 160;
        }
        while (v14 + v19 != v18);
      }
      a1[5] -= 0x3333333333333333 * ((uint64_t)(v18 - v14) >> 5);
      if (v13 == v17) {
        break;
      }
      unint64_t v21 = v13[1];
      ++v13;
      unint64_t v14 = v21;
    }
    while (v21 != v16);
  }
  return result;
}

void sub_100AE63C0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x3333333333333333 * (v2 >> 5);
  _Unwind_Resume(a1);
}

void sub_100AE63DC(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x19) {
    unint64_t v6 = v5 / 0x19 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x19;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x19) {
    unint64_t v8 = v7 / 0x19;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x19)
  {
    for (a1[4] = v7 - 25 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          uint64_t v29 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          __int16 v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            __int16 v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)__int16 v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          __int16 v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }
          int v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFA0uLL);
          sub_100097C14(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0xFA0uLL);
          sub_100097D2C((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 24;
          }
          else {
            uint64_t v64 = 25;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - 25 * v8;
      if (v8)
      {
        std::string::size_type v66 = (char *)a1[2];
        do
        {
          int v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          CFNumberRef v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              unint64_t v79 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v78);
              uint64_t v81 = &v79[8 * (v78 >> 2)];
              uint64_t v82 = (uint64_t *)a1[1];
              std::string::size_type v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                std::string::size_type v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                CFArrayRef v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)CFArrayRef v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              CFArrayRef v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                std::string::size_type v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              BOOL v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                std::string::size_type v66 = (char *)a1[1];
              }
              __int16 v77 = &v66[-8 * (v74 >> 1)];
              std::string::size_type v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)std::string::size_type v66 = v69;
          std::string::size_type v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      CFArrayRef v91 = a1 + 3;
      if (v13) {
        BOOL v15 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v13);
      }
      else {
        BOOL v15 = 0;
      }
      uint64_t v38 = -25 * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        CFArrayRef v88 = operator new(0xFA0uLL);
        sub_100097E4C(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        long long v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              long long v49 = (char *)sub_10004EF74((uint64_t)v91, v48);
              BOOL v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                int v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)int v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              uint64_t v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          long long v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      unint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_100097F64((uint64_t)__p, v57);
      }
      int v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100AE6930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE69A4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_100AE6A30(a1 + 24, (long long *)(a2 + 24));
  sub_100AE6A30(a1 + 88, (long long *)(a2 + 88));
  *(_WORD *)(a1 + 152) = *(_WORD *)(a2 + 152);
  return a1;
}

void sub_100AE6A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(v10 + 80))
  {
    if (*(unsigned char *)(v10 + 72))
    {
      a10 = v10 + 48;
      sub_100523284((void ***)&a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE6A30(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v3 = *a2;
    *(void *)(a1 + 13) = *(void *)((char *)a2 + 13);
    *(_OWORD *)a1 = v3;
    sub_100AE6AC4(a1 + 24, (uint64_t)a2 + 24);
    *(unsigned char *)(a1 + 56) = 1;
  }
  return a1;
}

void sub_100AE6A9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(v10 + 56))
  {
    if (*(unsigned char *)(v10 + 48)) {
      sub_100523284((void ***)&a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE6AC4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100AE6B1C((void *)a1, a2);
  return a1;
}

void sub_100AE6AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(v10 + 24))
  {
    a10 = v10;
    sub_100523284((void ***)&a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AE6B1C(void *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = result;
    *uint64_t result = 0;
    result[1] = 0;
    result[2] = 0;
    uint64_t result = sub_100AE6B74(result, *(void *)a2, *(void *)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5));
    *((unsigned char *)v2 + 24) = 1;
  }
  return result;
}

void *sub_100AE6B74(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    sub_100AE6BFC(result, a4);
    uint64_t result = (void *)sub_100AE6C50((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100AE6BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100523284(&a9);
  _Unwind_Resume(a1);
}

char *sub_100AE6BFC(void *a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_100522FB0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

uint64_t sub_100AE6C50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  uint64_t v8[2] = &v11;
  uint64_t v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_100522E58(v4, v6);
      v6 += 160;
      uint64_t v4 = v11 + 160;
      v11 += 160;
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  sub_100AE6CF0((uint64_t)v8);
  return v4;
}

void sub_100AE6CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100AE6CF0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100AE6D28(a1);
  }
  return a1;
}

uint64_t sub_100AE6D28(uint64_t result)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  uint64_t v1 = *(uint64_t **)(result + 16);
  uint64_t v3 = *v1;
  for (uint64_t i = *v2; v3 != i; v3 -= 160)
  {
    sub_100522D0C(v3 - 72);
    uint64_t result = sub_100522D0C(v3 - 128);
  }
  return result;
}

unsigned char *sub_100AE6D80(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[152] = 0;
  if (*(unsigned char *)(a2 + 152))
  {
    sub_100AE5CBC((uint64_t)a1, (long long *)a2);
    a1[152] = 1;
  }
  return a1;
}

void sub_100AE6DC4(_Unwind_Exception *a1)
{
  sub_100AE6DD8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100AE6DD8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 152))
  {
    sub_10005D9E0(a1 + 128, *(void **)(a1 + 136));
    sub_10005DBA4((void *)(a1 + 80));
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
  return a1;
}

void sub_100AE6E38(void *a1)
{
  if (a1)
  {
    sub_100AE6E38(*a1);
    sub_100AE6E38(a1[1]);
    sub_100AE6DD8((uint64_t)(a1 + 9));
    operator delete(a1);
  }
}

void sub_100AE6E8C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100AE6F0C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AE6F48(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100AE6F80(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100AE6FB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100AE6FF4(void *a1, uint64_t *a2)
{
  if (sub_10003AF4C((uint64_t)a1))
  {
    return sub_10003B080((uint64_t)a1);
  }
  else
  {
    __int16 v24 = 0;
    int v25 = 0;
    char v26 = 0;
    memset(v23, 0, sizeof(v23));
    uint64_t v27 = -4294967285;
    int v30 = 0;
    char v31 = 0;
    uint64_t v28 = 0;
    char v29 = 0;
    uint64_t v32 = 0;
    char v33 = 0;
    char v34 = 0;
    int v35 = 0;
    char v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v5 = a2[1];
    uint64_t v39 = *a2;
    uint64_t v40 = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v6 = a1[3];
    unint64_t v7 = a1[2];
    if (v7 >= v6)
    {
      uint64_t v9 = a1[1];
      uint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - v9) >> 5);
      if ((unint64_t)(v10 + 1) > 0x124924924924924) {
        sub_100AE785C();
      }
      unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - v9) >> 5);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= v10 + 1) {
        uint64_t v12 = v10 + 1;
      }
      if (v11 >= 0x92492492492492) {
        unint64_t v13 = 0x124924924924924;
      }
      else {
        unint64_t v13 = v12;
      }
      uint64_t v43 = a1 + 3;
      if (v13)
      {
        if (v13 > 0x124924924924924) {
          sub_10006A7CC();
        }
        unint64_t v14 = (char *)operator new(224 * v13);
      }
      else
      {
        unint64_t v14 = 0;
      }
      int64_t v41 = v14;
      *(void *)uint64_t v42 = &v14[224 * v10];
      *(void *)&v42[8] = *(void *)v42;
      *(void *)&v42[16] = &v14[224 * v13];
      sub_100AE751C(*(uint64_t *)v42, (uint64_t)v23);
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)v42;
      *(void *)&v42[8] += 224;
      uint64_t v18 = a1[1];
      for (uint64_t i = a1[2]; i + v15 != v18; sub_100AE751C(v15 + v16, v15 + i))
        v15 -= 224;
      uint64_t v19 = a1[3];
      unint64_t v22 = *(void *)&v42[8];
      long long v20 = *(_OWORD *)&v42[8];
      long long v21 = *(_OWORD *)(a1 + 1);
      a1[1] = v16 + v15;
      *(_OWORD *)uint64_t v42 = v21;
      *((_OWORD *)a1 + 1) = v20;
      *(void *)&v42[16] = v19;
      int64_t v41 = (char *)v21;
      sub_100AE7DD4((uint64_t)&v41);
      unint64_t v8 = v22;
    }
    else
    {
      sub_100AE751C(a1[2], (uint64_t)v23);
      unint64_t v8 = v7 + 224;
      a1[2] = v7 + 224;
    }
    a1[2] = v8;
    sub_100AE5990((uint64_t)v23);
    return a1[2] - 224;
  }
}

void sub_100AE7254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100AE7DD4(v3 - 104);
  sub_100AE5990((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100AE72B4(unint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3 - *a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_100AE7E24(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 80 * a2;
    while (v3 != v7)
    {
      v3 -= 80;
      sub_100AE5C74(v3);
    }
    a1[1] = v7;
  }
}

void sub_100AE734C(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_100AE80A0(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 56 * a2;
    while (v3 != v7)
    {
      unint64_t v8 = *(std::__shared_weak_count **)(v3 - 8);
      if (v8) {
        sub_10004D2C8(v8);
      }
      v3 -= 56;
    }
    a1[1] = v7;
  }
}

void sub_100AE73F0(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x86BCA1AF286BCA1BLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_100AE8464(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 152 * a2;
    while (v3 != v7)
    {
      v3 -= 152;
      sub_100AE5B2C(v3);
    }
    a1[1] = v7;
  }
}

void sub_100AE7490(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_100AE86FC(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 48 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_10005DBA4((void *)(v3 - 48));
    a1[1] = v7;
  }
}

uint64_t sub_100AE751C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  BOOL v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    sub_100AE7808((void *)a1, 0x86BCA1AF286BCA1BLL * (v6 >> 3));
    uint64_t v7 = *(char **)(a1 + 8);
    memmove(v7, v5, v6 - 4);
    *(void *)(a1 + 8) = &v7[8 * (v6 >> 3)];
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4sub_1001A7358((uint64_t)&a9, 0) = 0;
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 32);
  if (v9 != v8)
  {
    sub_100AE78C0((void *)(a1 + 24), 0xCCCCCCCCCCCCCCCDLL * ((v9 - v8) >> 4));
    *(void *)(a1 + 32) = sub_100AE7910(v8, v9, *(void *)(a1 + 32));
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_100AE7A2C((void *)(a1 + 48), *(long long **)(a2 + 48), *(long long **)(a2 + 56), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_1001A7358((uint64_t)&a9, 0) = 0;
  *(void *)(a1 + 88) = 0;
  sub_100AE7C24((void *)(a1 + 72), *(void *)(a2 + 72), *(void *)(a2 + 80), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 3));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v10 = *(void *)(a2 + 96);
  uint64_t v11 = *(void *)(a2 + 104);
  if (v11 != v10)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v10) >> 4);
    if (v12 >= 0x555555555555556) {
      sub_100AE785C();
    }
    unint64_t v13 = (char *)sub_100A52878(v12);
    uint64_t v14 = 0;
    *(void *)(a1 + 96) = v13;
    *(void *)(a1 + 104) = v13;
    *(void *)(a1 + 112) = &v13[48 * v15];
    do
    {
      sub_100AE60F4((uint64_t)&v13[v14], (void *)(v10 + v14));
      v14 += 48;
    }
    while (v10 + v14 != v11);
    *(void *)(a1 + 104) = &v13[v14];
  }
  *(_OWORD *)(a1 + 12sub_1001A7358((uint64_t)&a9, 0) = *(_OWORD *)(a2 + 120);
  long long v16 = *(_OWORD *)(a2 + 136);
  long long v17 = *(_OWORD *)(a2 + 152);
  long long v18 = *(_OWORD *)(a2 + 168);
  *(void *)(a1 + 181) = *(void *)(a2 + 181);
  *(_OWORD *)(a1 + 168) = v18;
  *(_OWORD *)(a1 + 152) = v17;
  *(_OWORD *)(a1 + 136) = v16;
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  uint64_t v19 = *(void *)(a2 + 200);
  *(void *)(a1 + 20sub_1001A7358((uint64_t)&a9, 0) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  uint64_t v20 = *(void *)(a2 + 216);
  *(void *)(a1 + 216) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100AE7770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 32) = v10;
  sub_100AE5BF0(&a9);
  unint64_t v12 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

char *sub_100AE7808(void *a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287) {
    sub_100AE785C();
  }
  uint64_t result = (char *)sub_100AE7874(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[152 * v4];
  return result;
}

void sub_100AE785C()
{
}

void *sub_100AE7874(unint64_t a1)
{
  if (a1 >= 0x1AF286BCA1AF287) {
    sub_10006A7CC();
  }
  return operator new(152 * a1);
}

char *sub_100AE78C0(void *a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334) {
    sub_100AE785C();
  }
  uint64_t result = (char *)sub_1007551D4(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

uint64_t sub_100AE7910(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      uint64_t v8 = a1 + v6;
      long long v9 = *(_OWORD *)(a1 + v6);
      *(void *)(v7 + 16) = *(void *)(a1 + v6 + 16);
      *(_OWORD *)uint64_t v7 = v9;
      uint64_t v10 = (unsigned char *)(a3 + v6 + 24);
      uint64_t v11 = (void **)(a1 + v6 + 24);
      if (*(char *)(a1 + v6 + 47) < 0)
      {
        sub_10004FC84(v10, *v11, *(void *)(v8 + 32));
      }
      else
      {
        long long v12 = *(_OWORD *)v11;
        *(void *)(a3 + v6 + 4sub_1001A7358((uint64_t)&a9, 0) = *(void *)(a1 + v6 + 40);
        *(_OWORD *)uint64_t v10 = v12;
      }
      uint64_t v13 = a3 + v6;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      uint64_t v14 = a3 + v6 + 48;
      *(void *)(v14 + 16) = 0;
      sub_1000302C0((char *)v14, *(long long **)(v8 + 48), *(long long **)(v8 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v8 + 56) - *(void *)(v8 + 48)) >> 3));
      *(_DWORD *)(a3 + v6 + 72) = *(_DWORD *)(v8 + 72);
      v6 += 80;
    }
    while (v8 + 80 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100AE79F0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 80;
    do
    {
      sub_100AE5C74(v4 + v2);
      v2 -= 80;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AE7A2C(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100AE7AB4(result, a4);
    uint64_t result = (void *)sub_100AE7B0C((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100AE7A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1002AC5A8(&a9);
  _Unwind_Resume(a1);
}

char *sub_100AE7AB4(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_100AE785C();
  }
  uint64_t result = (char *)sub_100341ECC((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t sub_100AE7B0C(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  v9[0] = a1;
  v9[1] = &v10;
  void v9[3] = 1;
  uint64_t v10 = a4;
  v9[2] = &v11;
  if (a2 != a3)
  {
    do
    {
      long long v5 = *a2;
      long long v6 = a2[1];
      *(void *)(v4 + 32) = *((void *)a2 + 4);
      *(_OWORD *)uint64_t v4 = v5;
      *(_OWORD *)(v4 + 16) = v6;
      *(void *)(v4 + 4sub_1001A7358((uint64_t)&a9, 0) = *((void *)a2 + 5);
      uint64_t v7 = *((void *)a2 + 6);
      *(void *)(v4 + 48) = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 56;
      a2 = (long long *)((char *)a2 + 56);
    }
    while (a2 != a3);
    uint64_t v11 = v4;
  }
  sub_100AE7BA8((uint64_t)v9);
  return v4;
}

uint64_t sub_100AE7BA8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100AE7BE0(a1);
  }
  return a1;
}

void sub_100AE7BE0(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 - 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    v1 -= 56;
  }
}

void *sub_100AE7C24(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100AE7CAC(result, a4);
    uint64_t result = (void *)sub_100AE7D50((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100AE7C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100AE5AA8(&a9);
  _Unwind_Resume(a1);
}

char *sub_100AE7CAC(void *a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287) {
    sub_100AE785C();
  }
  uint64_t result = (char *)sub_100AE7D04((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[152 * v4];
  return result;
}

void *sub_100AE7D04(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287) {
    sub_10006A7CC();
  }
  return operator new(152 * a2);
}

uint64_t sub_100AE7D50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100AE5CBC(a4 + v7, (long long *)(a2 + v7));
      v7 += 152;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100AE7DB0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 152;
    do
    {
      sub_100AE5B2C(v4 + v2);
      v2 -= 152;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AE7DD4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 224;
    sub_100AE5990(i - 224);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unint64_t *sub_100AE7E24(unint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result + 2;
  unint64_t v5 = result[2];
  uint64_t v6 = result[1];
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - v6) >> 4) >= a2)
  {
    if (a2)
    {
      uint64_t v12 = v6 + 80 * a2;
      do
      {
        *(_OWORD *)uint64_t v6 = 0uLL;
        *(_OWORD *)(v6 + 16) = 0uLL;
        *(_OWORD *)(v6 + 32) = 0uLL;
        *(_OWORD *)(v6 + 48) = 0uLL;
        *(_OWORD *)(v6 + 64) = 0uLL;
        *(_DWORD *)uint64_t v6 = -1;
        *(_DWORD *)(v6 + 8) = -2;
        *(_DWORD *)(v6 + 2sub_1001A7358((uint64_t)&a9, 0) = 2;
        *(_OWORD *)(v6 + 24) = 0uLL;
        *(_OWORD *)(v6 + 4sub_1001A7358((uint64_t)&a9, 0) = 0uLL;
        *(_OWORD *)(v6 + 56) = 0uLL;
        *(_DWORD *)(v6 + 72) = 2;
        v6 += 80;
      }
      while (v6 != v12);
      uint64_t v6 = v12;
    }
    result[1] = v6;
  }
  else
  {
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *result) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x333333333333333) {
      sub_100AE785C();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *result) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x199999999999999) {
      unint64_t v10 = 0x333333333333333;
    }
    else {
      unint64_t v10 = v8;
    }
    char v29 = v4;
    if (v10) {
      unint64_t v10 = (unint64_t)sub_1007551D4(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    unint64_t v13 = v10 + 80 * v7;
    unint64_t v26 = v10;
    v27.i64[0] = v13;
    unint64_t v14 = v10 + 80 * v11;
    unint64_t v28 = v14;
    unint64_t v15 = v13 + 80 * a2;
    unint64_t v16 = v13;
    do
    {
      *(_OWORD *)unint64_t v16 = 0uLL;
      *(_OWORD *)(v16 + 16) = 0uLL;
      *(_OWORD *)(v16 + 32) = 0uLL;
      *(_OWORD *)(v16 + 48) = 0uLL;
      *(_OWORD *)(v16 + 64) = 0uLL;
      *(_DWORD *)unint64_t v16 = -1;
      *(_DWORD *)(v16 + 8) = -2;
      *(_DWORD *)(v16 + 2sub_1001A7358((uint64_t)&a9, 0) = 2;
      *(_OWORD *)(v16 + 24) = 0uLL;
      *(_OWORD *)(v16 + 4sub_1001A7358((uint64_t)&a9, 0) = 0uLL;
      *(_OWORD *)(v16 + 56) = 0uLL;
      *(_DWORD *)(v16 + 72) = 2;
      v16 += 80;
    }
    while (v16 != v15);
    v27.i64[1] = v13 + 80 * a2;
    unint64_t v18 = *v3;
    unint64_t v17 = v3[1];
    if (v17 == *v3)
    {
      int64x2_t v24 = vdupq_n_s64(v17);
    }
    else
    {
      uint64_t v19 = 0;
      do
      {
        uint64_t v20 = v13 + v19;
        uint64_t v21 = v17 + v19;
        long long v22 = *(_OWORD *)(v17 + v19 - 80);
        *(void *)(v20 - 64) = *(void *)(v17 + v19 - 64);
        *(_OWORD *)(v20 - 8sub_1001A7358((uint64_t)&a9, 0) = v22;
        long long v23 = *(_OWORD *)(v17 + v19 - 56);
        *(void *)(v20 - 4sub_1001A7358((uint64_t)&a9, 0) = *(void *)(v17 + v19 - 40);
        *(_OWORD *)(v20 - 56) = v23;
        *(void *)(v21 - 48) = 0;
        *(void *)(v21 - 4sub_1001A7358((uint64_t)&a9, 0) = 0;
        *(void *)(v21 - 56) = 0;
        *(void *)(v20 - 32) = 0;
        *(void *)(v20 - 24) = 0;
        *(void *)(v20 - 16) = 0;
        *(_OWORD *)(v20 - 32) = *(_OWORD *)(v17 + v19 - 32);
        *(void *)(v20 - 16) = *(void *)(v17 + v19 - 16);
        *(void *)(v21 - 32) = 0;
        *(void *)(v21 - 24) = 0;
        *(void *)(v21 - 16) = 0;
        *(_DWORD *)(v20 - 8) = *(_DWORD *)(v17 + v19 - 8);
        v19 -= 80;
      }
      while (v17 + v19 != v18);
      int64x2_t v24 = *(int64x2_t *)v3;
      v13 += v19;
      unint64_t v15 = v27.u64[1];
      unint64_t v14 = v28;
    }
    *uint64_t v3 = v13;
    v3[1] = v15;
    int64x2_t v27 = v24;
    unint64_t v25 = v3[2];
    v3[2] = v14;
    unint64_t v28 = v25;
    unint64_t v26 = v24.i64[0];
    return (unint64_t *)sub_100AE8050((uint64_t)&v26);
  }
  return result;
}

uint64_t sub_100AE8050(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_100AE5C74(i - 80);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void **sub_100AE80A0(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = (uint64_t)*(result - 1);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 56 * a2;
      do
      {
        *(_OWORD *)uint64_t v7 = 0uLL;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(void *)(v7 + 8) = "";
        *(void *)(v7 + 16) = "";
        *(_DWORD *)(v7 + 32) = 2;
        *(void *)(v7 + 44) = 0;
        *(void *)(v7 + 36) = 0;
        *(_DWORD *)(v7 + 52) = 0;
        v7 += 56;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492) {
      sub_100AE785C();
    }
    unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v9;
    }
    void v16[4] = result;
    if (v11) {
      uint64_t v12 = (char *)sub_100341ECC((uint64_t)result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v14 = &v12[56 * v8];
    v16[0] = v12;
    v16[1] = v14;
    void v16[3] = &v12[56 * v11];
    unint64_t v15 = &v14[56 * a2];
    do
    {
      *(_OWORD *)unint64_t v14 = 0uLL;
      *((_OWORD *)v14 + 1) = 0uLL;
      *((void *)v14 + 1) = "";
      *((void *)v14 + 2) = "";
      *((_DWORD *)v14 + 8) = 2;
      *(void *)(v14 + 44) = 0;
      *(void *)(v14 + 36) = 0;
      *((_DWORD *)v14 + 13) = 0;
      v14 += 56;
    }
    while (v14 != v15);
    void v16[2] = v15;
    sub_100AE823C(a1, v16);
    return sub_100AE83DC(v16);
  }
  return result;
}

void sub_100AE8228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100AE83DC((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100AE823C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100AE82B4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100AE82B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 56;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 56);
      long long v10 = *(_OWORD *)(a3 - 40);
      *(void *)(v8 + 32) = *(void *)(a3 - 24);
      *(_OWORD *)uint64_t v8 = v9;
      *(_OWORD *)(v8 + 16) = v10;
      *(_OWORD *)(v8 + 4sub_1001A7358((uint64_t)&a9, 0) = *(_OWORD *)(a3 - 16);
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *((void *)&v15 + 1) = v8;
      v8 -= 56;
      v7 -= 56;
      a3 -= 56;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_100AE8360((uint64_t)v13);
  return v11;
}

uint64_t sub_100AE8360(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100AE8398(a1);
  }
  return a1;
}

void sub_100AE8398(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
    if (v3) {
      sub_10004D2C8(v3);
    }
    v1 += 56;
  }
}

void **sub_100AE83DC(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100AE8410(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 56;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      sub_10004D2C8(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 56;
    }
  }
}

uint64_t sub_100AE8464(void *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0x86BCA1AF286BCA1BLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 152 * a2;
      uint64_t v14 = 152 * a2;
      long long v15 = (void *)(v7 + 136);
      do
      {
        *((_OWORD *)v15 - 8) = 0uLL;
        *((_OWORD *)v15 - 7) = 0uLL;
        *(v15 - 8) = 0;
        *((_DWORD *)v15 - 34) = -3;
        *(void *)((char *)v15 - 132) = 0;
        *((unsigned char *)v15 - 124) = 0;
        *(v15 - 15) = 0x200000002;
        *(_OWORD *)(v15 - 7) = 0uLL;
        *(_OWORD *)(v15 - 5) = 0uLL;
        *(_OWORD *)(v15 - 3) = 0uLL;
        void *v15 = 0;
        v15[1] = 0;
        *((_OWORD *)v15 - 6) = 0uLL;
        *((_OWORD *)v15 - 5) = 0uLL;
        *(void *)((char *)v15 - 66) = 0;
        *(v15 - 1) = v15;
        v15 += 19;
        v14 -= 152;
      }
      while (v14);
    }
    else
    {
      uint64_t v13 = *(void *)(result - 8);
    }
    a1[1] = v13;
  }
  else
  {
    unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x1AF286BCA1AF286) {
      sub_100AE785C();
    }
    unint64_t v10 = 0x86BCA1AF286BCA1BLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0xD79435E50D7943) {
      unint64_t v11 = 0x1AF286BCA1AF286;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v28 = result;
    if (v11) {
      uint64_t v12 = (char *)sub_100AE7D04(result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v16 = &v12[152 * v8];
    unint64_t v26 = v12;
    *(void *)int64x2_t v27 = v16;
    *(void *)&v27[16] = &v12[152 * v11];
    uint64_t v17 = 152 * a2;
    unint64_t v18 = &v16[152 * a2];
    uint64_t v19 = v16 + 136;
    do
    {
      *((_OWORD *)v19 - 8) = 0uLL;
      *((_OWORD *)v19 - 7) = 0uLL;
      *(v19 - 8) = 0;
      *((_DWORD *)v19 - 34) = -3;
      *(void *)((char *)v19 - 132) = 0;
      *((unsigned char *)v19 - 124) = 0;
      *(v19 - 15) = 0x200000002;
      *(_OWORD *)(v19 - 7) = 0uLL;
      *(_OWORD *)(v19 - 5) = 0uLL;
      *(_OWORD *)(v19 - 3) = 0uLL;
      *uint64_t v19 = 0;
      v19[1] = 0;
      *((_OWORD *)v19 - 6) = 0uLL;
      *((_OWORD *)v19 - 5) = 0uLL;
      *(void *)((char *)v19 - 66) = 0;
      *(v19 - 1) = v19;
      v19 += 19;
      v17 -= 152;
    }
    while (v17);
    uint64_t v20 = 0;
    *(void *)&v27[8] = v18;
    uint64_t v22 = *a1;
    for (uint64_t i = a1[1]; i + v20 != v22; sub_100AE5CBC((uint64_t)&v16[v20], (long long *)(v20 + i)))
      v20 -= 152;
    uint64_t v23 = a1[2];
    long long v24 = *(_OWORD *)&v27[8];
    long long v25 = *(_OWORD *)a1;
    *a1 = &v16[v20];
    *(_OWORD *)int64x2_t v27 = v25;
    *(_OWORD *)(a1 + 1) = v24;
    *(void *)&v27[16] = v23;
    unint64_t v26 = (char *)v25;
    return sub_100AE86AC((uint64_t)&v26);
  }
  return result;
}

uint64_t sub_100AE86AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 152;
    sub_100AE5B2C(i - 152);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100AE86FC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1 + 2;
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 4) >= a2)
  {
    if (a2)
    {
      size_t v12 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero((void *)a1[1], v12);
      v6 += v12;
    }
    a1[1] = v6;
  }
  else
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - *a1) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x555555555555555) {
      sub_100AE785C();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    int64x2_t v27 = v4;
    if (v10) {
      unint64_t v10 = (unint64_t)sub_100A52878(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v13 = (char *)(v10 + 48 * v7);
    unint64_t v14 = v10 + 48 * v11;
    unint64_t v26 = v14;
    size_t v15 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v13, v15);
    unint64_t v16 = &v13[v15];
    v25.i64[1] = (uint64_t)&v13[v15];
    uint64_t v18 = *a1;
    unint64_t v17 = a1[1];
    if (v17 == *a1)
    {
      int64x2_t v22 = vdupq_n_s64(v17);
    }
    else
    {
      uint64_t v19 = 0;
      do
      {
        uint64_t v20 = &v13[v19];
        uint64_t v21 = v17 + v19;
        *((void *)v20 - 6) = *(void *)(v17 + v19 - 48);
        *((void *)v20 - 5) = *(void *)(v17 + v19 - 40);
        *((void *)v20 - 4) = *(void *)(v17 + v19 - 32);
        *((void *)v20 - 3) = *(void *)(v17 + v19 - 24);
        *(_OWORD *)(v21 - 48) = 0uLL;
        *(_OWORD *)(v21 - 32) = 0uLL;
        *((void *)v20 - 2) = *(void *)(v17 + v19 - 16);
        *((void *)v20 - 1) = *(void *)(v17 + v19 - 8);
        *(void *)(v21 - 16) = 0;
        *(void *)(v21 - 8) = 0;
        v19 -= 48;
      }
      while (v17 + v19 != v18);
      int64x2_t v22 = *(int64x2_t *)a1;
      v13 += v19;
      unint64_t v16 = (char *)v25.i64[1];
      unint64_t v14 = v26;
    }
    *a1 = (uint64_t)v13;
    a1[1] = (uint64_t)v16;
    int64x2_t v25 = v22;
    unint64_t v23 = a1[2];
    a1[2] = v14;
    unint64_t v26 = v23;
    uint64_t v24 = v22.i64[0];
    sub_100AE88E0((uint64_t)&v24);
  }
}

uint64_t sub_100AE88E0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    sub_10005DBA4((void *)(i - 48));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t **sub_100AE8930(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x70uLL);
    v11[7] = **a4;
    *((_OWORD *)v11 + 5) = 0u;
    *((_OWORD *)v11 + 6) = 0u;
    *((_OWORD *)v11 + 3) = 0u;
    *((_OWORD *)v11 + 4) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_100AE8A00(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      unint64_t v7 = (uint64_t *)v2;
    }
    else {
      unint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28)) {
    return 0;
  }
  sub_10006C514((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

void sub_100AE8A7C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_100AE8AC0((char **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 152 * a2;
  }
}

void sub_100AE8AC0(char **a1, unint64_t a2)
{
  int v5 = a1[1];
  unint64_t v4 = a1[2];
  if (0x86BCA1AF286BCA1BLL * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v11 = 152 * ((152 * a2 - 152) / 0x98) + 152;
      bzero(a1[1], v11);
      v5 += v11;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = 0x86BCA1AF286BCA1BLL * ((v5 - *a1) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x1AF286BCA1AF286) {
      sub_100AE785C();
    }
    unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((v4 - *a1) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0xD79435E50D7943) {
      unint64_t v9 = 0x1AF286BCA1AF286;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9) {
      unint64_t v9 = (unint64_t)sub_100AE7874(v9);
    }
    else {
      uint64_t v10 = 0;
    }
    size_t v12 = (char *)(v9 + 152 * v6);
    unint64_t v13 = v9 + 152 * v10;
    size_t v14 = 152 * ((152 * a2 - 152) / 0x98) + 152;
    bzero(v12, v14);
    size_t v15 = &v12[v14];
    unint64_t v17 = *a1;
    unint64_t v16 = a1[1];
    if (v16 != *a1)
    {
      do
      {
        long long v18 = *(_OWORD *)(v16 - 152);
        *(_OWORD *)(v12 - 136) = *(_OWORD *)(v16 - 136);
        *(_OWORD *)(v12 - 152) = v18;
        long long v19 = *(_OWORD *)(v16 - 120);
        long long v20 = *(_OWORD *)(v16 - 104);
        long long v21 = *(_OWORD *)(v16 - 88);
        *(_OWORD *)(v12 - 72) = *(_OWORD *)(v16 - 72);
        *(_OWORD *)(v12 - 88) = v21;
        *(_OWORD *)(v12 - 104) = v20;
        *(_OWORD *)(v12 - 12sub_1001A7358((uint64_t)&a9, 0) = v19;
        long long v22 = *(_OWORD *)(v16 - 56);
        long long v23 = *(_OWORD *)(v16 - 40);
        long long v24 = *(_OWORD *)(v16 - 24);
        *((_DWORD *)v12 - 2) = *((_DWORD *)v16 - 2);
        *(_OWORD *)(v12 - 24) = v24;
        *(_OWORD *)(v12 - 4sub_1001A7358((uint64_t)&a9, 0) = v23;
        *(_OWORD *)(v12 - 56) = v22;
        v12 -= 152;
        v16 -= 152;
      }
      while (v16 != v17);
      unint64_t v16 = *a1;
    }
    *a1 = v12;
    a1[1] = v15;
    a1[2] = (char *)v13;
    if (v16)
    {
      operator delete(v16);
    }
  }
}

char *sub_100AE8CC0(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (0x86BCA1AF286BCA1BLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 > 0x1AF286BCA1AF286) {
      sub_100AE785C();
    }
    unint64_t v10 = 0x86BCA1AF286BCA1BLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xD79435E50D7943) {
      unint64_t v12 = 0x1AF286BCA1AF286;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_100AE7808(v7, v12);
    size_t v14 = (char *)v7[1];
    unint64_t v13 = (void **)(v7 + 1);
    unint64_t v9 = v14;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      long long v19 = v9;
      long long v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v13 = (void **)(result + 8);
  size_t v15 = (unsigned char *)*((void *)result + 1);
  if (0x86BCA1AF286BCA1BLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    unint64_t v9 = (char *)*v13;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    long long v19 = v9;
    long long v20 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *unint64_t v13 = &v9[v17];
  return result;
}

void sub_100AE8E20(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *(void **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    sub_100AE8F80((void **)a1);
    if (a4 > 0x333333333333333) {
      sub_100AE785C();
    }
    unint64_t v9 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x199999999999999) {
      unint64_t v10 = 0x333333333333333;
    }
    else {
      unint64_t v10 = v9;
    }
    sub_100AE78C0((void *)a1, v10);
    uint64_t v11 = sub_100AE7910(a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 4) < a4)
  {
    uint64_t v12 = a2 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 4);
    sub_100AE8FE8(a2, v12, (uint64_t)v8);
    uint64_t v11 = sub_100AE7910(v12, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v11;
    return;
  }
  uint64_t v13 = sub_100AE8FE8(a2, a3, (uint64_t)v8);
  for (uint64_t i = *(void *)(a1 + 8); i != v13; sub_100AE5C74(i))
    i -= 80;
  *(void *)(a1 + 8) = v13;
}

void sub_100AE8F70(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE8F78(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE8F80(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80;
        sub_100AE5C74(v3);
      }
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100AE8FE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1 + 56;
    do
    {
      uint64_t v6 = v5 - 56;
      long long v7 = *(_OWORD *)(v5 - 56);
      *(void *)(a3 + 16) = *(void *)(v5 - 40);
      *(_OWORD *)a3 = v7;
      std::string::operator=((std::string *)(a3 + 24), (const std::string *)(v5 - 32));
      if (a3 != v5 - 56) {
        sub_10005CA3C(a3 + 48, *(std::string **)(v5 - 8), *(long long **)v5, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v5 - *(void *)(v5 - 8)) >> 3));
      }
      *(_DWORD *)(a3 + 72) = *(_DWORD *)(v5 + 16);
      a3 += 80;
      v5 += 80;
    }
    while (v6 + 80 != a2);
  }
  return a3;
}

void sub_100AE9090(uint64_t *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = *a1;
  if (0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3) < a4)
  {
    sub_100AE9224(a1);
    if (a4 > 0x492492492492492) {
      sub_100AE785C();
    }
    unint64_t v10 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100AE7AB4(a1, v11);
    uint64_t v12 = sub_100AE7B0C(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  if (0x6DB6DB6DB6DB6DB7 * ((a1[1] - v9) >> 3) < a4)
  {
    uint64_t v13 = (long long *)((char *)a2 + 8 * ((a1[1] - v9) >> 3));
    sub_100AE9260(a2, v13, v9);
    uint64_t v12 = sub_100AE7B0C(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }
  uint64_t v14 = sub_100AE9260(a2, a3, v9);
  for (uint64_t i = a1[1]; i != v14; i -= 56)
  {
    unint64_t v16 = *(std::__shared_weak_count **)(i - 8);
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
  a1[1] = v14;
}

void sub_100AE9214(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE921C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE9224(uint64_t *a1)
{
  if (*a1)
  {
    sub_1002AC5FC(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100AE9260(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      long long v6 = *v5;
      long long v7 = v5[1];
      *(void *)(a3 + 32) = *((void *)v5 + 4);
      *(_OWORD *)a3 = v6;
      *(_OWORD *)(a3 + 16) = v7;
      uint64_t v9 = *((void *)v5 + 5);
      uint64_t v8 = *((void *)v5 + 6);
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v10 = *(std::__shared_weak_count **)(a3 + 48);
      *(void *)(a3 + 4sub_1001A7358((uint64_t)&a9, 0) = v9;
      *(void *)(a3 + 48) = v8;
      if (v10) {
        sub_10004D2C8(v10);
      }
      a3 += 56;
      uint64_t v5 = (long long *)((char *)v5 + 56);
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_100AE92E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_DWORD *)a4 = *(_DWORD *)v5;
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(v5 + 8);
    sub_100AE9368(a4 + 24, (long long *)(v5 + 24));
    sub_100AE9368(a4 + 88, (long long *)(v5 + 88));
    *(_WORD *)(a4 + 152) = *(_WORD *)(v5 + 152);
    a4 += 160;
    v5 += 160;
  }
  while (v5 != v6);
  return v6;
}

void sub_100AE9368(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 56) == *((unsigned __int8 *)a2 + 56))
  {
    if (*(unsigned char *)(a1 + 56))
    {
      long long v3 = *a2;
      *(void *)(a1 + 13) = *(void *)((char *)a2 + 13);
      *(_OWORD *)a1 = v3;
      uint64_t v4 = a1 + 24;
      uint64_t v5 = (uint64_t)a2 + 24;
      sub_100AE9424(v4, v5);
    }
  }
  else if (*(unsigned char *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      long long v7 = (void **)(a1 + 24);
      sub_100523284(&v7);
    }
    *(unsigned char *)(a1 + 56) = 0;
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 13) = *(void *)((char *)a2 + 13);
    *(_OWORD *)a1 = v6;
    sub_100AE6AC4(a1 + 24, (uint64_t)a2 + 24);
    *(unsigned char *)(a1 + 56) = 1;
  }
}

void sub_100AE9424(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *(void *)a2) >> 5);
      uint64_t v5 = *(void *)a2;
      sub_100AE94F4((uint64_t *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v6 = (void **)a1;
    sub_100523284(&v6);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100AE6B74((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5));
    *(unsigned char *)(a1 + 24) = 1;
  }
}

uint64_t sub_100AE94F4(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 5) < a4)
  {
    sub_100AE9654(a1);
    if (a4 > 0x199999999999999) {
      sub_10006A748();
    }
    unint64_t v10 = 0x999999999999999ALL * ((a1[2] - *a1) >> 5);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v11 = 0x199999999999999;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100AE6BFC(a1, v11);
    uint64_t result = sub_100AE6C50(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[1] - v9) >> 5) < a4)
  {
    uint64_t v13 = a2 + 32 * ((a1[1] - v9) >> 5);
    sub_100AE9690((uint64_t)&v15, a2, v13, v9);
    uint64_t result = sub_100AE6C50(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = result;
    return result;
  }
  sub_100AE9690((uint64_t)&v16, a2, a3, v9);
  return sub_1005232D8((uint64_t)a1, v14);
}

void sub_100AE9644(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE964C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100AE9654(uint64_t *a1)
{
  if (*a1)
  {
    sub_1005232D8((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100AE9690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    long long v7 = *(_OWORD *)(v5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    *(_OWORD *)(a4 + 16) = v7;
    sub_100AE9718((std::string *)(a4 + 32), (std::string *)(v5 + 32));
    sub_100AE9718((std::string *)(a4 + 88), (std::string *)(v5 + 88));
    uint64_t v8 = *(void *)(v5 + 144);
    *(void *)(a4 + 15sub_1001A7358((uint64_t)&a9, 0) = *(void *)(v5 + 150);
    *(void *)(a4 + 144) = v8;
    a4 += 160;
    v5 += 160;
  }
  while (v5 != v6);
  return v6;
}

void sub_100AE9718(std::string *__dst, std::string *a2)
{
  if (__dst[2].__r_.__value_.__s.__data_[0] == a2[2].__r_.__value_.__s.__data_[0])
  {
    if (__dst[2].__r_.__value_.__s.__data_[0])
    {
      sub_100179AF8(__dst, a2);
      std::string::size_type size = a2[1].__r_.__value_.__l.__size_;
      __dst[1].__r_.__value_.__s.__data_[16] = a2[1].__r_.__value_.__s.__data_[16];
      __dst[1].__r_.__value_.__l.__size_ = size;
    }
  }
  else if (__dst[2].__r_.__value_.__s.__data_[0])
  {
    sub_100AE97B8((uint64_t)__dst);
  }
  else
  {
    sub_1000593FC((uint64_t)__dst, (long long *)a2);
    std::string::size_type v5 = a2[1].__r_.__value_.__l.__size_;
    __dst[1].__r_.__value_.__s.__data_[16] = a2[1].__r_.__value_.__s.__data_[16];
    __dst[1].__r_.__value_.__l.__size_ = v5;
    __dst[2].__r_.__value_.__s.__data_[0] = 1;
  }
}

void sub_100AE97B8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
}

uint64_t sub_100AE97FC(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 25 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x19) {
    a2 = 1;
  }
  if (v5 < 0x32) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t **sub_100AE9874(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    void v14[2] = 1;
    uint64_t v12 = (char *)operator new(0xF0uLL);
    v14[1] = v7;
    *((_DWORD *)v12 + 8) = **a4;
    *((void *)v12 + 29) = 0;
    *(_OWORD *)(v12 + 216) = 0u;
    *(_OWORD *)(v12 + 20sub_1001A7358((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(v12 + 184) = 0u;
    *(_OWORD *)(v12 + 168) = 0u;
    *(_OWORD *)(v12 + 152) = 0u;
    *(_OWORD *)(v12 + 136) = 0u;
    *(_OWORD *)(v12 + 12sub_1001A7358((uint64_t)&a9, 0) = 0u;
    *(_OWORD *)(v12 + 104) = 0u;
    *(_OWORD *)(v12 + 88) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 4sub_1001A7358((uint64_t)&a9, 0) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_100AE9998((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_100AE9998(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100AE6DD8((uint64_t)v2 + 72);
    }
    operator delete(v2);
  }
}

void sub_100AE99F0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 152) == *(unsigned __int8 *)(a2 + 152))
  {
    if (*(unsigned char *)(a1 + 152))
    {
      long long v4 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)a1 = v4;
      std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
      std::string::operator=((std::string *)(a1 + 48), (const std::string *)(a2 + 48));
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
      *(_WORD *)(a1 + 76) = *(_WORD *)(a2 + 76);
      sub_10000C1DC((void *)(a1 + 80), (void *)(a2 + 80));
      if (a1 != a2)
      {
        unint64_t v5 = *(void **)(a2 + 128);
        sub_10005DA3C((uint64_t **)(a1 + 128), v5, (void *)(a2 + 136));
      }
    }
  }
  else if (*(unsigned char *)(a1 + 152))
  {
    sub_100AE9AD4(a1);
  }
  else
  {
    sub_100AE5CBC(a1, (long long *)a2);
    *(unsigned char *)(a1 + 152) = 1;
  }
}

void sub_100AE9AD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 152))
  {
    sub_10005D9E0(a1 + 128, *(void **)(a1 + 136));
    sub_10005DBA4((void *)(a1 + 80));
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    *(unsigned char *)(a1 + 152) = 0;
  }
}

uint64_t sub_100AE9B34(uint64_t a1)
{
  return a1;
}

uint64_t sub_100AE9B60(uint64_t a1, TrafficDescriptor *this, uint64_t a3)
{
  if (TrafficDescriptor::hasAccountInfo(this))
  {
    uint64_t result = TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)a3);
    if (!result) {
      return result;
    }
    if (TrafficDescriptor::hasTrafficClassInfo(this))
    {
      if (*((unsigned char *)this + 232) && *(unsigned char *)(a3 + 232))
      {
        if (*((_DWORD *)this + 57) != *(_DWORD *)(a3 + 228)) {
          return 0;
        }
      }
      else if ((*((unsigned char *)this + 232) != 0) != (*(unsigned char *)(a3 + 232) != 0))
      {
        return 0;
      }
    }
    if (*((unsigned char *)this + 136) && *(unsigned char *)(a3 + 136))
    {
      uint64_t v9 = *((unsigned __int8 *)this + 135);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = *((unsigned __int8 *)this + 135);
      }
      else {
        uint64_t v10 = *((void *)this + 15);
      }
      uint64_t v11 = *(unsigned __int8 *)(a3 + 135);
      int v12 = (char)v11;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a3 + 120);
      }
      if (v10 != v11) {
        return 0;
      }
      uint64_t v13 = (const void **)((char *)this + 112);
      if (v12 >= 0) {
        uint64_t v14 = (unsigned __int8 *)(a3 + 112);
      }
      else {
        uint64_t v14 = *(unsigned __int8 **)(a3 + 112);
      }
      if ((v9 & 0x80) == 0)
      {
        if (*((unsigned char *)this + 135))
        {
          while (*(unsigned __int8 *)v13 == *v14)
          {
            uint64_t v13 = (const void **)((char *)v13 + 1);
            ++v14;
            if (!--v9) {
              goto LABEL_86;
            }
          }
          return 0;
        }
LABEL_86:
        if (*((unsigned char *)this + 104))
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD58, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_101B0FD58))
          {
            sub_10056D028((std::locale *)&unk_101B100A8, "^(\\*|[1-8])\\.([0-9]+)(\\..*)?$", 0);
          }
          memset(v62, 0, sizeof(v62));
          *(_OWORD *)std::string __p = 0u;
          long long v61 = 0u;
          uint64_t v24 = *((unsigned __int8 *)this + 103);
          if ((v24 & 0x80u) == 0) {
            int64x2_t v25 = (char *)this + 80;
          }
          else {
            int64x2_t v25 = (char *)*((void *)this + 10);
          }
          if ((v24 & 0x80u) != 0) {
            uint64_t v24 = *((void *)this + 11);
          }
          if ((sub_100570034((uint64_t)v25, (uint64_t)&v25[v24], (uint64_t)__p, (uint64_t)&unk_101B100A8, 0) & 1) == 0)
          {
            uint64_t v32 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              if (*((char *)this + 103) >= 0) {
                char v33 = (char *)this + 80;
              }
              else {
                char v33 = (char *)*((void *)this + 10);
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v33;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#E Cannot do discovery by account, appCategory=%s (1)", (uint8_t *)&buf, 0xCu);
            }
            goto LABEL_150;
          }
          long long buf = 0uLL;
          uint64_t v70 = 0;
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
          int64x2_t v27 = (char *)__p[0] + 64;
          if (v26 <= 2) {
            int64x2_t v27 = (char *)v62 + 8;
          }
          if (*v27)
          {
            BOOL v28 = v26 > 2;
            if (v26 <= 2) {
              char v29 = (char **)&v61 + 1;
            }
            else {
              char v29 = (char **)((char *)__p[0] + 48);
            }
            int v30 = (char **)((char *)__p[0] + 56);
            if (!v28) {
              int v30 = (char **)v62;
            }
            sub_10012CD04(&buf, *v29, *v30, *v30 - *v29);
            unint64_t v59 = 0;
            if (v70 >= 0) {
              p_long long buf = (const char *)&buf;
            }
            else {
              p_long long buf = (const char *)buf;
            }
          }
          else
          {
            unint64_t v59 = 0;
            p_long long buf = (const char *)&buf;
          }
          unint64_t v59 = strtoull(p_buf, 0, 10);
          if (!v59)
          {
            int64_t v46 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              if (*((char *)this + 103) >= 0) {
                uint64_t v47 = (char *)this + 80;
              }
              else {
                uint64_t v47 = (char *)*((void *)this + 10);
              }
              LODWORD(v67) = 136315138;
              *(void *)((char *)&v67 + 4) = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#E Cannot do discovery by account, appCategory=%s (2)", (uint8_t *)&v67, 0xCu);
            }
            goto LABEL_148;
          }
          uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
          if (!(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)a1 + 2176))(a1, v34, 0))
          {
LABEL_148:
            if (SHIBYTE(v70) < 0) {
              operator delete((void *)buf);
            }
LABEL_150:
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            return 1;
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap(v35, *(Registry **)(a1 + 104));
          uint64_t v37 = ServiceMap;
          if (v38 < 0)
          {
            uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v40 = 5381;
            do
            {
              uint64_t v38 = v40;
              unsigned int v41 = *v39++;
              uint64_t v40 = (33 * v40) ^ v41;
            }
            while (v41);
          }
          std::mutex::lock(ServiceMap);
          *(void *)&long long v67 = v38;
          uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)&v67);
          if (v42)
          {
            uint64_t v44 = v42[3];
            uint64_t v43 = (std::__shared_weak_count *)v42[4];
            if (v43)
            {
              atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v37);
              atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v43);
              char v45 = 0;
LABEL_126:
              if (v44)
              {
                uint64_t v57 = 0;
                uint64_t v58 = 0;
                uint64_t v48 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
                (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v44 + 8))(&v57, v44, v48);
                if (v57)
                {
                  *((void *)&v67 + 1) = 0;
                  uint64_t v68 = 0;
                  *(void *)&long long v67 = (char *)&v67 + 8;
                  sub_100B076CC((uint64_t **)&v67, &v59, (uint64_t *)&v59);
                  long long v49 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                  {
                    if (*((char *)this + 103) >= 0) {
                      uint64_t v50 = (char *)this + 80;
                    }
                    else {
                      uint64_t v50 = (char *)*((void *)this + 10);
                    }
                    *(_DWORD *)CFTypeID v63 = 136315394;
                    *(void *)&v63[4] = v50;
                    __int16 v64 = 2048;
                    unint64_t v65 = v59;
                    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I discovery by account, appCategory=%s, genre=%llu", v63, 0x16u);
                  }
                  uint64_t v51 = v57;
                  sub_100058DB0(v63, "xr");
                  uint64_t v52 = *(std::__shared_weak_count **)(a1 + 4744);
                  uint64_t v55 = *(void *)(a1 + 4736);
                  uint64_t v56 = v52;
                  if (v52) {
                    atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  (*(void (**)(uint64_t, unsigned char *, long long *, uint64_t *))(*(void *)v51 + 184))(v51, v63, &v67, &v55);
                  if (v56) {
                    sub_10004D2C8(v56);
                  }
                  if (v66 < 0) {
                    operator delete(*(void **)v63);
                  }
                  sub_1000346F8((uint64_t)&v67, *((void **)&v67 + 1));
                }
                else
                {
                  int v54 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(v67) = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "slice persona featureState: phone service control empty", (uint8_t *)&v67, 2u);
                  }
                }
                if (v58) {
                  sub_10004D2C8(v58);
                }
              }
              else
              {
                uint64_t v53 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v67) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "slice persona featureState: phone service empty", (uint8_t *)&v67, 2u);
                }
              }
              if ((v45 & 1) == 0) {
                sub_10004D2C8(v43);
              }
              goto LABEL_148;
            }
          }
          else
          {
            uint64_t v44 = 0;
          }
          std::mutex::unlock(v37);
          uint64_t v43 = 0;
          char v45 = 1;
          goto LABEL_126;
        }
        return 1;
      }
      if (!memcmp(*v13, v14, *((void *)this + 15))) {
        goto LABEL_86;
      }
      return 0;
    }
LABEL_153:
    sub_10016C840();
  }
  if (*((unsigned char *)this + 214)
    && (!*(unsigned char *)(a3 + 214) || *((unsigned __int16 *)this + 106) != *(unsigned __int16 *)(a3 + 212))
    || TrafficDescriptor::hasDnnInfo(this)
    && sub_1005AD5C4((unsigned __int8 *)this + 240, (unsigned __int8 *)(a3 + 240)))
  {
    return 0;
  }
  if (!*((unsigned char *)this + 220)) {
    goto LABEL_40;
  }
  if (!*(unsigned char *)(a3 + 220))
  {
    if (!*(unsigned char *)(a3 + 214)) {
      return 0;
    }
    unsigned int v7 = *((unsigned __int16 *)this + 108);
    unsigned int v8 = *((unsigned __int16 *)this + 109);
LABEL_38:
    uint64_t result = 0;
    unsigned int v15 = *(unsigned __int16 *)(a3 + 212);
    if (v15 < v7 || v15 > v8) {
      return result;
    }
LABEL_40:
    if (*((unsigned char *)this + 208))
    {
      if (!*(unsigned char *)(a3 + 208)) {
        return 0;
      }
      uint64_t result = CSIPacketAddress::matchSubnet((CSIPacketAddress *)(a3 + 184), (TrafficDescriptor *)((char *)this + 184));
      if (!result) {
        return result;
      }
    }
    if (*((unsigned char *)this + 224)
      && (!*(unsigned char *)(a3 + 224) || *((unsigned __int16 *)this + 111) != *(unsigned __int16 *)(a3 + 222))
      || *((unsigned char *)this + 232) && (!*(unsigned char *)(a3 + 232) || *((_DWORD *)this + 57) != *(_DWORD *)(a3 + 228))
      || *((unsigned char *)this + 8) && (!*(unsigned char *)(a3 + 8) || *((_DWORD *)this + 1) != *(_DWORD *)(a3 + 4)))
    {
      return 0;
    }
    if (!TrafficDescriptor::hasAppCategoryInfo(this)
      || !TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)a3))
    {
      goto LABEL_60;
    }
    if (!*((unsigned char *)this + 104) || !*(unsigned char *)(a3 + 72)) {
      goto LABEL_153;
    }
    if (!sub_10001D294((unsigned __int8 *)this + 80, (unsigned __int8 *)(a3 + 48)))
    {
LABEL_60:
      if (*((unsigned char *)this + 40) && sub_1005AD5C4((unsigned __int8 *)this + 16, (unsigned __int8 *)(a3 + 16))
        || TrafficDescriptor::hasBundleInfo(this)
        && sub_1005AD5C4((unsigned __int8 *)this + 48, (unsigned __int8 *)(a3 + 48)))
      {
        return 0;
      }
    }
    if (*((unsigned char *)this + 176))
    {
      int v16 = *((char *)this + 175);
      unint64_t v17 = v16 >= 0 ? *((unsigned __int8 *)this + 175) : *((void *)this + 20);
      if (v17)
      {
        if (*(unsigned char *)(a3 + 176))
        {
          int v18 = *(char *)(a3 + 175);
          unint64_t v19 = v18 >= 0 ? *(unsigned __int8 *)(a3 + 175) : *(void *)(a3 + 160);
          if (v19 >= v17)
          {
            if (v16 >= 0) {
              long long v20 = (char *)this + 152;
            }
            else {
              long long v20 = (char *)*((void *)this + 19);
            }
            if (v18 >= 0) {
              uint64_t v21 = a3 + 152;
            }
            else {
              uint64_t v21 = *(void *)(a3 + 152);
            }
            long long v22 = v20 - 1;
            while (1)
            {
              __darwin_ct_rune_t v23 = __tolower(v22[v17]);
              if (v23 != __tolower(*(char *)(v21 - 1 + v19))) {
                break;
              }
              --v19;
              if (!--v17) {
                return !v19 || *(unsigned char *)(v21 + v19 - 1) == 46;
              }
            }
          }
        }
        return 0;
      }
    }
    return 1;
  }
  uint64_t result = 0;
  unsigned int v7 = *((unsigned __int16 *)this + 108);
  if (v7 == *(unsigned __int16 *)(a3 + 216))
  {
    unsigned int v8 = *((unsigned __int16 *)this + 109);
    if (v8 == *(unsigned __int16 *)(a3 + 218))
    {
      if (*(unsigned char *)(a3 + 214)) {
        goto LABEL_38;
      }
    }
  }
  return result;
}

void sub_100AEA478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

uint64_t DataServiceController::sliceManager(DataServiceController *this)
{
  return (uint64_t)this + 96;
}

uint64_t DataServiceController::supportsIDSSlicedCellularInterface(DataServiceController *this)
{
  return _os_feature_enabled_impl();
}

uint64_t non-virtual thunk to'DataServiceController::supportsIDSSlicedCellularInterface(DataServiceController *this)
{
  return _os_feature_enabled_impl();
}

uint64_t sub_100AEA570(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, unsigned int a5, int a6)
{
  if (a4 > 0x10000 && a4 >> 3 > a5)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Unbalanced traffic: in < out", buf, 2u);
    }
  }
  if (a5 > 0x10000 && a5 >> 3 > a4)
  {
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Unbalanced traffic: in > out", buf, 2u);
    }
  }
  v64.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  unsigned int v15 = (void *)*a3;
  uint64_t v13 = a3 + 1;
  uint64_t v14 = v15;
  if (v15 == v13)
  {
LABEL_79:
    int v46 = 0;
    return v46 | (v46 << 8);
  }
  int v16 = (void *)(a1 + 4864);
  unint64_t v17 = (void *)(a1 + 4840);
  while (1)
  {
    int v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
      unint64_t v19 = buf;
      if (v72 < 0) {
        unint64_t v19 = *(unsigned char **)buf;
      }
      *(_DWORD *)unint64_t v65 = 136446210;
      *(void *)&v65[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I mustKeepSliceAlive: %{public}s", v65, 0xCu);
      if (SHIBYTE(v72) < 0) {
        operator delete(*(void **)buf);
      }
    }
    if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v14 + 4)))
    {
      if (!*((unsigned char *)v14 + 104)) {
        sub_10016C840();
      }
      long long v20 = (void *)*v16;
      if (*v16)
      {
        uint64_t v21 = a1 + 4864;
        do
        {
          char v22 = sub_100046FE8(v20 + 4, (void **)v14 + 10);
          if (v22 >= 0) {
            __darwin_ct_rune_t v23 = v20;
          }
          else {
            __darwin_ct_rune_t v23 = v20 + 1;
          }
          if (v22 >= 0) {
            uint64_t v21 = (uint64_t)v20;
          }
          long long v20 = (void *)*v23;
        }
        while (*v23);
        if ((void *)v21 != v16 && (sub_100046FE8(v14 + 10, (void **)(v21 + 32)) & 0x80) == 0)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = v64.__d_.__rep_ - *(void *)(v21 + 56);
          if (v24 <= 0x6FC23ABFFLL) {
            break;
          }
        }
      }
    }
    if (sub_100AEAD30(a1, (TrafficDescriptor *)(v14 + 4)))
    {
      uint64_t v47 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_114;
      }
      uint64_t v48 = asString();
      TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
      if (v72 >= 0) {
        long long v49 = buf;
      }
      else {
        long long v49 = *(unsigned char **)buf;
      }
      *(_DWORD *)unint64_t v65 = 136315394;
      *(void *)&v65[4] = v48;
      __int16 v66 = 2082;
      long long v67 = v49;
      uint64_t v50 = "#I mustKeepSliceAlive: do not forcefully deactivate slice connection %s because it has active test traffic d"
            "escriptor: %{public}s";
      goto LABEL_111;
    }
    if (a6)
    {
      if (TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)(v14 + 4)))
      {
        uint64_t v47 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_114;
        }
        uint64_t v51 = asString();
        TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
        if (v72 >= 0) {
          uint64_t v52 = buf;
        }
        else {
          uint64_t v52 = *(unsigned char **)buf;
        }
        *(_DWORD *)unint64_t v65 = 136315394;
        *(void *)&v65[4] = v51;
        __int16 v66 = 2082;
        long long v67 = v52;
        uint64_t v50 = "#I mustKeepSliceAlive: do not deactivate slice connection %s: has active account id: %{public}s";
        goto LABEL_111;
      }
      if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v14 + 4)))
      {
        if (!*((unsigned char *)v14 + 104)) {
          sub_10016C840();
        }
        int64x2_t v25 = v14 + 10;
        uint64_t v26 = *((unsigned __int8 *)v14 + 103);
        int v27 = (char)v26;
        if ((v26 & 0x80u) != 0) {
          uint64_t v26 = v14[11];
        }
        if (v27 < 0) {
          int64x2_t v25 = (uint64_t *)v14[10];
        }
        if (v26 == 15)
        {
          uint64_t v33 = *v25;
          uint64_t v34 = *(uint64_t *)((char *)v25 + 7);
          if (v33 == 0x6C7070612E6D6F63 && v34 == 0x64656D61672E656CLL)
          {
LABEL_95:
            uint64_t v47 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_114;
            }
            uint64_t v55 = asString();
            TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
            if (v72 >= 0) {
              uint64_t v56 = buf;
            }
            else {
              uint64_t v56 = *(unsigned char **)buf;
            }
            *(_DWORD *)unint64_t v65 = 136315394;
            *(void *)&v65[4] = v55;
            __int16 v66 = 2082;
            long long v67 = v56;
            uint64_t v50 = "#I mustKeepSliceAlive: do not deactivate slice connection %s: has active special app: %{public}s";
            goto LABEL_111;
          }
        }
        else if (v26 == 18)
        {
          uint64_t v28 = *v25;
          uint64_t v29 = v25[1];
          int v30 = *((unsigned __int16 *)v25 + 8);
          BOOL v31 = v28 == 0x6C7070612E6D6F63 && v29 == 0x6974656361662E65;
          if (v31 && v30 == 25965) {
            goto LABEL_95;
          }
        }
      }
    }
    if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v14 + 4)))
    {
      if (!*((unsigned char *)v14 + 104)) {
        sub_10016C840();
      }
      if ((void **)(a1 + 4816) == sub_100046F68(a1 + 4808, (void **)v14 + 10)) {
        goto LABEL_67;
      }
      char v36 = (uint64_t *)*((unsigned __int8 *)v14 + 104);
      if (!*((unsigned char *)v14 + 104)) {
        sub_10016C840();
      }
      uint64_t v37 = (void *)*v17;
      if (*v17)
      {
        uint64_t v38 = a1 + 4840;
        do
        {
          char v39 = sub_100046FE8(v37 + 4, (void **)v14 + 10);
          if (v39 >= 0) {
            uint64_t v40 = v37;
          }
          else {
            uint64_t v40 = v37 + 1;
          }
          if (v39 >= 0) {
            uint64_t v38 = (uint64_t)v37;
          }
          uint64_t v37 = (void *)*v40;
        }
        while (*v40);
        if ((void *)v38 != v17 && (sub_100046FE8(v14 + 10, (void **)(v38 + 32)) & 0x80) == 0)
        {
          uint64_t v47 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_114;
          }
          uint64_t v61 = asString();
          TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
          if (v72 >= 0) {
            long long v62 = buf;
          }
          else {
            long long v62 = *(unsigned char **)buf;
          }
          *(_DWORD *)unint64_t v65 = 136315394;
          *(void *)&v65[4] = v61;
          __int16 v66 = 2082;
          long long v67 = v62;
          uint64_t v50 = "#I mustKeepSliceAlive: do not deactivate slice connection %s: has active call kit call: %{public}s";
LABEL_111:
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v50, v65, 0x16u);
          if ((SHIBYTE(v72) & 0x80000000) == 0) {
            goto LABEL_114;
          }
          long long v60 = *(void **)buf;
LABEL_113:
          operator delete(v60);
          goto LABEL_114;
        }
LABEL_67:
        char v36 = (uint64_t *)*((unsigned __int8 *)v14 + 104);
        if (!*((unsigned char *)v14 + 104)) {
          sub_10016C840();
        }
      }
      if (DataServiceController::isAppWithBundleIdActive(a1, v14 + 10, v36))
      {
        uint64_t v41 = *(void *)(a1 + 1088);
        uint64_t v42 = *(void *)(a1 + 1096);
        buf[0] = 0;
        if (sub_1000D8740(v41, v42, (unsigned __int8 **)v14 + 10) != *(void *)(a1 + 1096)
          || (uint64_t v43 = sub_100046F68(a1 + 4640, (void **)v14 + 10), (void **)(a1 + 4648) != v43)
          && *((unsigned char *)v43 + 121)
          && *((unsigned char *)v43 + 120))
        {
          uint64_t v47 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_114;
          }
          uint64_t v53 = asString();
          TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v14 + 4));
          if (v72 >= 0) {
            int v54 = buf;
          }
          else {
            int v54 = *(unsigned char **)buf;
          }
          *(_DWORD *)unint64_t v65 = 136315394;
          *(void *)&v65[4] = v53;
          __int16 v66 = 2082;
          long long v67 = v54;
          uint64_t v50 = "#I mustKeepSliceAlive: do not deactivate slice connection %s: has active bundle id: %{public}s";
          goto LABEL_111;
        }
      }
    }
    uint64_t v44 = (void *)v14[1];
    if (v44)
    {
      do
      {
        char v45 = v44;
        uint64_t v44 = (void *)*v44;
      }
      while (v44);
    }
    else
    {
      do
      {
        char v45 = (void *)v14[2];
        BOOL v31 = *v45 == (void)v14;
        uint64_t v14 = v45;
      }
      while (!v31);
    }
    uint64_t v14 = v45;
    if (v45 == v13) {
      goto LABEL_79;
    }
  }
  uint64_t v57 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v58 = asString();
    TrafficDescriptor::toString((uint64_t *)v65, (TrafficDescriptor *)(v14 + 4));
    *(_DWORD *)long long buf = 136315650;
    unint64_t v59 = v68 >= 0 ? v65 : *(unsigned char **)v65;
    *(void *)&uint8_t buf[4] = v58;
    __int16 v70 = 2082;
    uint64_t v71 = v59;
    __int16 v72 = 2048;
    uint64_t v73 = v24 / 1000000000;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I mustKeepSliceAlive: do not deactivate slice connection %s: recently forwarded app: %{public}s, age %llu secs", buf, 0x20u);
    if (v68 < 0)
    {
      long long v60 = *(void **)v65;
      goto LABEL_113;
    }
  }
LABEL_114:
  int v46 = 1;
  return v46 | (v46 << 8);
}

uint64_t sub_100AEAD30(uint64_t a1, TrafficDescriptor *this)
{
  uint64_t v2 = *(void **)(a1 + 4992);
  uint64_t v3 = (void *)(a1 + 5000);
  if (v2 == (void *)(a1 + 5000)) {
    return 0;
  }
  unint64_t v5 = (const void **)((char *)this + 48);
  uint64_t v6 = (const void **)((char *)this + 16);
  while (!*((unsigned char *)this + 8) || *((_DWORD *)this + 1) != *((_DWORD *)v2 + 8))
  {
    if (TrafficDescriptor::hasBundleInfo(this))
    {
      if (!*((unsigned char *)this + 72)) {
        sub_10016C840();
      }
      uint64_t v7 = *((unsigned __int8 *)this + 71);
      if ((v7 & 0x80u) == 0) {
        uint64_t v8 = *((unsigned __int8 *)this + 71);
      }
      else {
        uint64_t v8 = *((void *)this + 7);
      }
      uint64_t v9 = *((unsigned __int8 *)v2 + 95);
      int v10 = (char)v9;
      if ((v9 & 0x80u) != 0) {
        uint64_t v9 = v2[10];
      }
      if (v8 == v9)
      {
        if (v10 >= 0) {
          uint64_t v11 = (unsigned __int8 *)(v2 + 9);
        }
        else {
          uint64_t v11 = (unsigned __int8 *)v2[9];
        }
        if ((v7 & 0x80) != 0)
        {
          if (!memcmp(*v5, v11, *((void *)this + 7))) {
            return 1;
          }
        }
        else
        {
          if (!*((unsigned char *)this + 71)) {
            return 1;
          }
          for (uint64_t i = v5; *(unsigned __int8 *)i == *v11; uint64_t i = (const void **)((char *)i + 1))
          {
            ++v11;
            if (!--v7) {
              return 1;
            }
          }
        }
      }
    }
    if (*((unsigned char *)this + 40))
    {
      uint64_t v13 = *((unsigned __int8 *)this + 39);
      if ((v13 & 0x80u) == 0) {
        uint64_t v14 = *((unsigned __int8 *)this + 39);
      }
      else {
        uint64_t v14 = *((void *)this + 3);
      }
      uint64_t v15 = *((unsigned __int8 *)v2 + 119);
      int v16 = (char)v15;
      if ((v15 & 0x80u) != 0) {
        uint64_t v15 = v2[13];
      }
      if (v14 == v15)
      {
        if (v16 >= 0) {
          unint64_t v17 = (unsigned __int8 *)(v2 + 12);
        }
        else {
          unint64_t v17 = (unsigned __int8 *)v2[12];
        }
        if ((v13 & 0x80) != 0)
        {
          if (!memcmp(*v6, v17, *((void *)this + 3))) {
            return 1;
          }
        }
        else
        {
          if (!*((unsigned char *)this + 39)) {
            return 1;
          }
          for (CFIndex j = v6; *(unsigned __int8 *)j == *v17; CFIndex j = (const void **)((char *)j + 1))
          {
            ++v17;
            if (!--v13) {
              return 1;
            }
          }
        }
      }
    }
    unint64_t v19 = (void *)v2[1];
    if (v19)
    {
      do
      {
        long long v20 = v19;
        unint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        long long v20 = (void *)v2[2];
        BOOL v21 = *v20 == (void)v2;
        uint64_t v2 = v20;
      }
      while (!v21);
    }
    uint64_t v2 = v20;
    if (v20 == v3) {
      return 0;
    }
  }
  return 1;
}

uint64_t DataServiceController::mustKeepSliceAlive_sync(DataServiceController *this, int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 14);
  std::string __p = (void *)*((void *)this + 13);
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v24) {
    sub_10004D2C8(v24);
  }
  int v10 = v28;
  uint64_t v9 = v29;
  if (v28 != v29)
  {
    uint64_t v11 = v30;
    while ((v30(*v10) & 1) == 0)
    {
      if (++v10 == v29)
      {
        int v10 = v29;
        break;
      }
    }
    BOOL v21 = v29;
    while (v10 != v21)
    {
      int v12 = *v10;
      uint64_t v13 = 28;
      do
      {
        uint64_t v26 = 0;
        int v27 = 0;
        DataServiceController::getConnection_sync((uint64_t)this, v12, v13, &v26);
        uint64_t v14 = v26;
        if (v26
          && ((*(uint64_t (**)(uint64_t))(*(void *)v26 + 168))(v26) & 1) != 0
          && (*(unsigned int (**)(uint64_t))(*(void *)v14 + 200))(v14) == a2)
        {
          std::string __p = 0;
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = 0;
          uint64_t v25 = 0;
          uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, void **))(*(void *)v14 + 408))(v14, &__p);
          unsigned __int16 v16 = sub_100AEA570((uint64_t)this, v13, v15, a3, a4, 0);
          int v17 = v16 > 0xFFu;
          if ((v16 & 0xFF00) != 0) {
            unsigned __int8 v4 = v16;
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(__p);
          }
        }
        else
        {
          int v17 = 6;
        }
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17 != 6 && v17)
        {
          int v19 = 1;
          return v4 | (v19 << 8);
        }
        uint64_t v13 = (v13 + 1);
      }
      while (v13 != 36);
      int v18 = v10 + 1;
      int v10 = v9;
      if (v18 != v9)
      {
        int v10 = v18;
        while ((v11(*v10) & 1) == 0)
        {
          if (++v10 == v9)
          {
            int v10 = v9;
            break;
          }
        }
      }
    }
  }
  unsigned __int8 v4 = 0;
  int v19 = 0;
  return v4 | (v19 << 8);
}

void sub_100AEB134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'DataServiceController::mustKeepSliceAlive_sync(DataServiceController *this, int a2, unsigned int a3, unsigned int a4)
{
  return DataServiceController::mustKeepSliceAlive_sync((DataServiceController *)((char *)this - 96), a2, a3, a4);
}

uint64_t DataServiceController::canUseInternetSlicing_sync(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 2192))(a1);
  if (result)
  {
    int v11 = a2;
    uint64_t v7 = sub_10003B194(a1 + 4616, &v11);
    BOOL v8 = *(unsigned char *)*v7 == 0;
    uint64_t result = *(unsigned char *)*v7 != 0;
    BOOL v8 = v8 || a3 == 0;
    if (!v8)
    {
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
      char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1040))(a1, a2);
      uint64_t result = DataServiceController::SlicesDataContainer::configured(a1 + 4616, a2, v9, v10);
      if (result) {
        return DataServiceController::isDataModeGoodForInternetSlicing_sync(a1, a2);
      }
    }
  }
  return result;
}

BOOL DataServiceController::isDataModeGoodForInternetSlicing_sync(uint64_t a1, int a2)
{
  int v10 = a2;
  unsigned __int8 v4 = sub_10003B194(a1 + 4616, &v10);
  uint64_t v5 = *v4;
  int v6 = *(_DWORD *)(*v4 + 4);
  uint64_t v7 = sub_10003B004(*(void *)(a1 + 144), a2);
  if (*(void *)(*(void *)(a1 + 144) + 16) != v7)
  {
    int v8 = *(_DWORD *)(v7 + 128);
    if (v6) {
      goto LABEL_3;
    }
    return v8 == 17;
  }
  int v8 = 0;
  if (!v6) {
    return v8 == 17;
  }
LABEL_3:
  BOOL result = 0;
  switch(v8)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      BOOL result = *(unsigned char *)(v5 + 4) & 1;
      break;
    case 14:
    case 16:
      BOOL result = (*(unsigned __int8 *)(v5 + 4) >> 3) & 1;
      break;
    case 17:
      BOOL result = (*(unsigned __int8 *)(v5 + 4) >> 4) & 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t non-virtual thunk to'DataServiceController::canUseInternetSlicing_sync(uint64_t a1, uint64_t a2, int a3)
{
  return DataServiceController::canUseInternetSlicing_sync(a1 - 96, a2, a3);
}

BOOL non-virtual thunk to'DataServiceController::isDataModeGoodForInternetSlicing_sync(uint64_t a1, int a2)
{
  return DataServiceController::isDataModeGoodForInternetSlicing_sync(a1 - 80, a2);
}

uint64_t DataServiceController::useInternetSlicing_sync(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = a1 + 4584;
  if (!*(unsigned char *)(a1 + 4584) || (a3 & 1) != 0) {
    goto LABEL_12;
  }
  sub_100AEB680(&v18, a1, a2);
  uint64_t v7 = v18;
  int v8 = v19;
  if (v18 == v19)
  {
    BOOL v9 = 0;
    if (v18) {
LABEL_10:
    }
      operator delete(v7);
  }
  else
  {
    BOOL v9 = 0;
    int v10 = v18;
    do
    {
      if (v9)
      {
        BOOL v9 = 1;
      }
      else
      {
        int v20 = *v10;
        BOOL v9 = *(unsigned char *)(*sub_10003B194(a1 + 4616, &v20) + 21) != 0;
      }
      ++v10;
    }
    while (v10 != v8);
    if (v7) {
      goto LABEL_10;
    }
  }
  if (!v9) {
    return 0;
  }
LABEL_12:
  if (*(unsigned char *)(v6 + 336) && !*(unsigned char *)(v6 + 337) && !*(void *)(a1 + 4944))
  {
    sub_100AEB680(&v18, a1, a2);
    int v11 = v18;
    int v12 = v19;
    if (v18 == v19)
    {
      BOOL v13 = 0;
    }
    else
    {
      LOBYTE(v13) = 0;
      uint64_t v14 = v18;
      do
      {
        int v20 = *v14;
        uint64_t v15 = sub_10003B194(a1 + 4616, &v20);
        if (v13 || (uint64_t v16 = *v15, *(unsigned char *)(*v15 + 12)) && (*(unsigned char *)(v16 + 13) || *(unsigned char *)(v16 + 14)))
        {
          BOOL v13 = 1;
        }
        else if (*(unsigned __int8 *)(v16 + 1) | *(unsigned __int8 *)(v16 + 2))
        {
          BOOL v13 = *(void *)(v16 + 152) != 0;
        }
        else
        {
          BOOL v13 = 0;
        }
        ++v14;
      }
      while (v14 != v12);
    }
    if (v11) {
      operator delete(v11);
    }
    if (!v13) {
      return 0;
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 2184))(a1, a2, a3 ^ 1u);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1120))(a1, a2);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1808))(a1);
      if (result) {
        return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 1800))(a1, a2) ^ 1;
      }
    }
  }
  return result;
}

void sub_100AEB664(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AEB680(void *a1, uint64_t a2, int a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 1088))(a2);
  int v6 = result;
  if (a3 == 3 || result == a3)
  {
    uint64_t v7 = operator new(4uLL);
    *a1 = v7;
    _DWORD *v7 = v6;
    uint64_t result = (uint64_t)(v7 + 1);
    a1[1] = result;
    a1[2] = result;
  }
  return result;
}

uint64_t non-virtual thunk to'DataServiceController::useInternetSlicing_sync(uint64_t a1, uint64_t a2, int a3)
{
  return DataServiceController::useInternetSlicing_sync(a1 - 96, a2, a3);
}

void DataServiceController::resetSlicePoliciesOnDataModeChange_sync(uint64_t a1, uint64_t a2)
{
  BOOL isDataModeGoodForInternetSlicing_sync = DataServiceController::isDataModeGoodForInternetSlicing_sync(a1, a2);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    uint64_t v8 = asStringBool(isDataModeGoodForInternetSlicing_sync);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Slice connectivity: Data Mode changed to: %s", (uint8_t *)&v7, 0xCu);
  }
  int v7 = a2;
  if (*(unsigned char *)(*sub_10003B194(a1 + 4616, &v7) + 22)) {
    char v6 = !isDataModeGoodForInternetSlicing_sync;
  }
  else {
    char v6 = 0;
  }
  DataServiceController::resetSlicePolicies_sync(a1, a2, 0, v6);
}

void DataServiceController::resetSlicePolicies_sync(uint64_t a1, int a2, char a3, char a4)
{
  sub_100AEC4B4(a1, a2, (uint64_t)"reset policies");
  char v6 = *(std::__shared_weak_count **)(a1 + 112);
  *(void *)long long buf = *(void *)(a1 + 104);
  char v68 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v68) {
    sub_10004D2C8(v68);
  }
  int v7 = v64;
  uint64_t v8 = v65;
  if (v64 != v65)
  {
    char v55 = a3 | a4;
    while ((v66(*v7) & 1) == 0)
    {
      if (++v7 == v65)
      {
        int v7 = v65;
        break;
      }
    }
    int v54 = v65;
    if (v7 != v65)
    {
      uint64_t v57 = v66;
      do
      {
        uint64_t v9 = *v7;
        unint64_t v59 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v9);
        *(_DWORD *)long long buf = v9;
        uint64_t v10 = *sub_10003B194(a1 + 4616, (int *)buf);
        int v11 = *v59;
        if (os_log_type_enabled(*v59, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I we are clearing cached traffic descriptors", buf, 2u);
        }
        uint64_t v13 = *(void *)(v10 + 56);
        for (uint64_t i = *(void *)(v10 + 64); i != v13; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(i - 304)))
          ;
        *(void *)(v10 + 64) = v13;
        v63[0] = 0;
        v63[1] = 0;
        long long v62 = v63;
        sub_100A37478((uint64_t *)&v62, 0, 0);
        char v14 = v55;
        if (*(unsigned char *)(v10 + 18)) {
          char v14 = 1;
        }
        if (v14)
        {
          for (int j = 28; j != 36; ++j)
            sub_100A37478((uint64_t *)&v62, j, j);
        }
        else
        {
          for (int k = 28; k != 36; ++k)
          {
            *(void *)__int16 v70 = 0;
            *(void *)&v70[8] = 0;
            DataServiceController::getConnection_sync(a1, v9, k, (uint64_t *)v70);
            uint64_t v17 = *(void *)v70;
            if (*(void *)v70
              && ((*(uint64_t (**)(void))(**(void **)v70 + 168))(*(void *)v70) & 1) != 0)
            {
              *(void *)long long buf = 0;
              char v68 = 0;
              uint64_t v69 = 0;
              int v18 = (void *)(*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 408))(v17, buf);
              int v19 = v18 + 1;
              int v20 = (void *)*v18;
              if ((void *)*v18 == v18 + 1)
              {
LABEL_36:
                sub_100A37478((uint64_t *)&v62, k, k);
              }
              else
              {
                char v21 = 0;
                while (1)
                {
                  char hasAccountInfo = TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)(v20 + 4));
                  if (hasAccountInfo) {
                    break;
                  }
                  __darwin_ct_rune_t v23 = (void *)v20[1];
                  if (v23)
                  {
                    do
                    {
                      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = v23;
                      __darwin_ct_rune_t v23 = (void *)*v23;
                    }
                    while (v23);
                  }
                  else
                  {
                    do
                    {
                      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = (void *)v20[2];
                      BOOL v25 = *v24 == (void)v20;
                      int v20 = v24;
                    }
                    while (!v25);
                  }
                  v21 |= hasAccountInfo;
                  int v20 = v24;
                  if (v24 == v19)
                  {
                    if (v21) {
                      break;
                    }
                    goto LABEL_36;
                  }
                }
              }
              if (SHIBYTE(v69) < 0) {
                operator delete(*(void **)buf);
              }
            }
            if (*(void *)&v70[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v70[8]);
            }
          }
        }
        uint64_t v26 = (uint64_t)v62;
        if (v62 != v63)
        {
          do
          {
            unint64_t v27 = *(unsigned int *)(v26 + 28);
            *(void *)__int16 v70 = 0;
            *(void *)&v70[8] = 0;
            DataServiceController::getConnection_sync(a1, v9, v27, (uint64_t *)v70);
            uint64_t v28 = *(void *)v70;
            if (*(void *)v70)
            {
              *(void *)long long buf = 0;
              char v68 = 0;
              uint64_t v69 = 0;
              sub_100AE4634(*(void *)(a1 + 152), v9, buf);
              if (0x6DB6DB6DB6DB6DB7 * (((uint64_t)v68 - *(void *)buf) >> 3) > v27)
              {
                int v29 = *(_DWORD *)(*(void *)buf + 56 * v27);
                uint64_t ActiveNetworkByConnection_sync = DataServiceController::getActiveNetworkByConnection_sync(a1, v9, v27);
                (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(*(void *)v28 + 432))(v28, ActiveNetworkByConnection_sync, v29 == 0, 1);
              }
              long long v60 = buf;
              sub_1002AC5A8((void ***)&v60);
            }
            if (*(void *)&v70[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v70[8]);
            }
            BOOL v31 = *(void **)(v26 + 8);
            if (v31)
            {
              do
              {
                uint64_t v32 = (void **)v31;
                BOOL v31 = (void *)*v31;
              }
              while (v31);
            }
            else
            {
              do
              {
                uint64_t v32 = *(void ***)(v26 + 16);
                BOOL v25 = *v32 == (void *)v26;
                uint64_t v26 = (uint64_t)v32;
              }
              while (!v25);
            }
            uint64_t v26 = (uint64_t)v32;
          }
          while (v32 != v63);
        }
        if (a4)
        {
          *(void *)long long buf = 0;
          char v68 = 0;
          uint64_t v69 = 0;
          sub_100058DB0(buf, "resetSlicePolicies_sync: forced shutdown");
          uint64_t v33 = (uint64_t)v62;
          if (v62 != v63)
          {
            do
            {
              int v34 = *(_DWORD *)(v33 + 28);
              if (v34)
              {
                long long v60 = 0;
                uint64_t v61 = 0;
                DataServiceController::getConnection_sync(a1, v9, v34, (uint64_t *)&v60);
                int v35 = (void **)v60;
                if (v60 && (*(unsigned int (**)(uint8_t *))(*(void *)v60 + 168))(v60))
                {
                  char v36 = *v59;
                  if (os_log_type_enabled(*v59, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v37 = asString();
                    *(_DWORD *)__int16 v70 = 136315394;
                    *(void *)&v70[4] = "resetSlicePolicies_sync";
                    *(_WORD *)&v70[12] = 2080;
                    *(void *)&v70[14] = v37;
                    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s: Deactivating %s...", v70, 0x16u);
                  }
                  if (SHIBYTE(v69) >= 0) {
                    uint64_t v38 = buf;
                  }
                  else {
                    uint64_t v38 = *(uint8_t **)buf;
                  }
                  DataServiceController::enableContextStateChangeNotificationRepost(a1, a2, v34, (uint64_t)v38, 1);
                  (*((void (**)(void **, const char *, const char *))*v35 + 12))(v35, "resetSlicePolicies_sync", "CommCenter");
                }
                if (v61) {
                  sub_10004D2C8(v61);
                }
              }
              char v39 = *(void **)(v33 + 8);
              if (v39)
              {
                do
                {
                  uint64_t v40 = (void **)v39;
                  char v39 = (void *)*v39;
                }
                while (v39);
              }
              else
              {
                do
                {
                  uint64_t v40 = *(void ***)(v33 + 16);
                  BOOL v25 = *v40 == (void *)v33;
                  uint64_t v33 = (uint64_t)v40;
                }
                while (!v25);
              }
              uint64_t v33 = (uint64_t)v40;
            }
            while (v40 != v63);
          }
          if (SHIBYTE(v69) < 0) {
            operator delete(*(void **)buf);
          }
        }
        uint64_t v41 = v57;
        if ((*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)a1 + 2176))(a1, v9, 0))
        {
          char v68 = 0;
          uint64_t v69 = 0;
          *(void *)long long buf = &v68;
          uint64_t v42 = *(void ***)(a1 + 1088);
          uint64_t v43 = *(void ***)(a1 + 1096);
          while (v42 != v43)
          {
            if (DataServiceController::sliceApp((unsigned char *)a1, v9, v42)) {
              sub_100046BAC((uint64_t **)buf, v42, (uint64_t)v42);
            }
            v42 += 3;
          }
          sub_100AEFAAC((void *)a1, v9, buf);
          sub_10005CD2C((uint64_t)buf, (char *)v68);
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 2192))(a1))
        {
          uint64_t v44 = *(void *)(a1 + 112);
          *(void *)__int16 v70 = *(void *)(a1 + 104);
          *(void *)&v70[8] = v44;
          if (v44) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
          }
          subscriber::makeSimSlotRange();
          if (*(void *)&v70[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v70[8]);
          }
          int v46 = *(int **)buf;
          char v45 = v68;
          if (*(std::__shared_weak_count **)buf != v68)
          {
            uint64_t v47 = v69;
            while ((v47(*v46) & 1) == 0)
            {
              if (++v46 == (int *)v45)
              {
                int v46 = (int *)v45;
                break;
              }
            }
            uint64_t v48 = v68;
LABEL_94:
            while (v46 != (int *)v48)
            {
              uint64_t v49 = *v46;
              uint64_t v50 = *(void *)(sub_100AEFE40(*(void *)(a1 + 144), *v46) + 24);
              if (v50)
              {
                uint64_t isNrSliceConfigured_sync = DataServiceController::isNrSliceConfigured_sync((void *)a1, v49);
                (*(void (**)(uint64_t, uint64_t))(*(void *)v50 + 752))(v50, isNrSliceConfigured_sync);
              }
              uint64_t v52 = v46 + 1;
              int v46 = (int *)v45;
              if (v52 != (int *)v45)
              {
                int v46 = v52;
                while ((v47(*v46) & 1) == 0)
                {
                  if (++v46 == (int *)v45)
                  {
                    int v46 = (int *)v45;
                    goto LABEL_94;
                  }
                }
              }
            }
          }
          uint64_t v41 = v57;
        }
        sub_10005D144(v63[0]);
        uint64_t v53 = v7 + 1;
        int v7 = v8;
        if (v53 != v8)
        {
          int v7 = v53;
          while ((v41(*v7) & 1) == 0)
          {
            if (++v7 == v8)
            {
              int v7 = v8;
              break;
            }
          }
        }
      }
      while (v7 != v54);
    }
  }
}

void sub_100AEC070(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,std::__shared_weak_count *a28,int a29,__int16 a30,char a31,char a32)
{
  if (a28) {
    sub_10004D2C8(a28);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::resetSlicePoliciesOnWiFiChange_sync(DataServiceController *this, BOOL a2)
{
  unsigned __int8 v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Slice connectivity: Wi-Fi changed to: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 14);
  int v11 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v11) {
    sub_10004D2C8(v11);
  }
  char v6 = (int *)*((void *)&buf + 1);
  int v7 = (int *)buf;
  if ((void)buf != *((void *)&buf + 1))
  {
    uint64_t v8 = v13;
    while ((v8(*v7) & 1) == 0)
    {
      if (++v7 == v6)
      {
        int v7 = v6;
        break;
      }
    }
    uint64_t v9 = (int *)*((void *)&buf + 1);
LABEL_13:
    while (v7 != v9)
    {
      DataServiceController::resetSlicePolicies_sync((uint64_t)this, *v7, 0, 0);
      uint64_t v10 = v7 + 1;
      int v7 = v6;
      if (v10 != v6)
      {
        int v7 = v10;
        while ((v8(*v7) & 1) == 0)
        {
          if (++v7 == v6)
          {
            int v7 = v6;
            goto LABEL_13;
          }
        }
      }
    }
  }
}

void sub_100AEC2C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::resetSlicePoliciesOnVpnChange_sync(DataServiceController *this, int a2, int a3)
{
  BOOL v3 = a3;
  BOOL v4 = a2;
  if (*((unsigned __int8 *)this + 4920) != a2 || *((unsigned __int8 *)this + 4921) != a3)
  {
    *((unsigned char *)this + 492sub_1001A7358((uint64_t)&a9, 0) = a2;
    *((unsigned char *)this + 4921) = a3;
    char v6 = *((void *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = asStringBool(v4);
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Slice connectivity: VPN changed to: %s, usesPolicyBasedRouting: %s", buf, 0x16u);
    }
    int v7 = (std::__shared_weak_count *)*((void *)this + 14);
    uint64_t v13 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    subscriber::makeSimSlotRange();
    if (v13) {
      sub_10004D2C8(v13);
    }
    uint64_t v9 = *(int **)buf;
    uint64_t v8 = *(int **)&buf[8];
    if (*(void *)buf != *(void *)&buf[8])
    {
      uint64_t v10 = *(uint64_t (**)(void))&buf[16];
      while ((v10(*v9) & 1) == 0)
      {
        if (++v9 == v8)
        {
          uint64_t v9 = v8;
          break;
        }
      }
      int v11 = *(int **)&buf[8];
LABEL_15:
      while (v9 != v11)
      {
        DataServiceController::resetSlicePolicies_sync((uint64_t)this, *v9, 1, 0);
        int v12 = v9 + 1;
        uint64_t v9 = v8;
        if (v12 != v8)
        {
          uint64_t v9 = v12;
          while ((v10(*v9) & 1) == 0)
          {
            if (++v9 == v8)
            {
              uint64_t v9 = v8;
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
}

void sub_100AEC494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100AEC4B4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4 = a1;
  sub_100AEB680(&v323, a1, a2);
  char v6 = v323;
  uint64_t v5 = v324;
  if (v323 == v324)
  {
    int v7 = &unk_10153E3F0;
    if (!v323) {
      return v7;
    }
    goto LABEL_13;
  }
  uint64_t v298 = v4 + 4616;
  int v7 = &unk_10153E3F0;
  uint64_t v8 = v323;
  while (1)
  {
    uint64_t v9 = *v8;
    v300 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v9);
    LODWORD(buf) = v9;
    uint64_t v10 = sub_10003B194(v298, (int *)&buf);
    uint64_t v299 = *v10;
    if (*(void *)(*v10 + 56) != *(void *)(*v10 + 64))
    {
      int v7 = (void *)(v299 + 56);
      int v12 = *v300;
      if (os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I we are using cached traffic descriptors", (uint8_t *)&buf, 2u);
      }
LABEL_12:
      if (!v6) {
        return v7;
      }
LABEL_13:
      operator delete(v6);
      return v7;
    }
    if (sub_100AF2240(*(void *)(v4 + 144), v9))
    {
      uint64_t v11 = *(void *)(sub_100AEFE40(*(void *)(v4 + 144), v9) + 24);
      if (v11) {
        break;
      }
    }
    if (++v8 == v5) {
      goto LABEL_12;
    }
  }
  v320 = 0;
  v321 = 0;
  unint64_t v322 = 0;
  char v14 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 920))(v11);
  v320 = 0;
  v321 = 0;
  unint64_t v322 = 0;
  sub_100B05E34(&v320, *v14, v14[1], 0x86BCA1AF286BCA1BLL * ((v14[1] - *v14) >> 4));
  LODWORD(buf) = v9;
  uint64_t v15 = sub_10003B194(v298, (int *)&buf);
  uint64_t v16 = a3;
  uint64_t v17 = *(const TrafficDescriptor **)(*v15 + 32);
  int v18 = *(const TrafficDescriptor **)(*v15 + 40);
  if (v17 == v18)
  {
    int v19 = v321;
  }
  else
  {
    int v19 = v321;
    do
    {
      if ((unint64_t)v19 >= v322)
      {
        int v19 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v320, v17);
      }
      else
      {
        TrafficDescriptor::TrafficDescriptor(v19, v17);
        int v19 = (TrafficDescriptor *)((char *)v19 + 304);
      }
      v321 = v19;
      uint64_t v17 = (const TrafficDescriptor *)((char *)v17 + 304);
    }
    while (v17 != v18);
  }
  v317 = 0;
  v318 = 0;
  unint64_t v319 = 0;
  v314 = 0;
  v315 = 0;
  unint64_t v316 = 0;
  int v20 = v320;
  v304 = (void *)v4;
  if (v320 == v19) {
    goto LABEL_653;
  }
  uint64_t v289 = v4 + 4640;
  v288 = (void **)(v4 + 4648);
  int v295 = (void *)(v299 + 144);
  unint64_t v287 = (uint64_t **)(v4 + 4688);
  unint64_t v290 = (void *)(v4 + 4720);
  v307 = (void *)(v4 + 5000);
  unsigned int v305 = v9;
  v291 = v19;
  while (2)
  {
    v301 = v20;
    if (!TrafficDescriptor::hasBundleInfo(v20)) {
      goto LABEL_33;
    }
    if (!*((unsigned char *)v301 + 72)) {
      sub_10016C840();
    }
    char v21 = (void *)((char *)v301 + 48);
    if (v288 == sub_100046F68(v289, (void **)v301 + 6))
    {
LABEL_33:
      v311 = 0;
      v312 = 0;
      v313 = 0;
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v301);
      v311 = 0;
      v312 = 0;
      v313 = 0;
      *(void *)long long __dst = &v311;
      *(void *)&__dst[8] = 0;
      v311 = (TrafficDescriptor *)operator new(0x130uLL);
      v312 = v311;
      __darwin_ct_rune_t v23 = (TrafficDescriptor *)((char *)v311 + 304);
      v313 = (TrafficDescriptor *)((char *)v311 + 304);
      TrafficDescriptor::TrafficDescriptor(v311, (const TrafficDescriptor *)&buf);
      v312 = v23;
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
      if (TrafficDescriptor::hasDnnInfo(v301))
      {
        if (*(void *)(v299 + 152))
        {
          BOOL v25 = v311;
          for (uint64_t i = v312; i != v25; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)((char *)i - 304)))
            ;
          v312 = v25;
          uint64_t v28 = *(void **)(v299 + 136);
          if (v28 != v295)
          {
            while ((TrafficDescriptor::hasBundleInfo(v301) & 1) == 0)
            {
              long long v355 = 0u;
              long long v356 = 0u;
              long long v353 = 0u;
              long long v354 = 0u;
              long long v351 = 0u;
              long long v352 = 0u;
              long long v349 = 0u;
              long long v350 = 0u;
              long long v347 = 0u;
              long long v348 = 0u;
              long long v345 = 0u;
              long long v346 = 0u;
              long long v343 = 0u;
              long long v344 = 0u;
              long long v341 = 0u;
              long long v342 = 0u;
              long long v339 = 0u;
              long long v340 = 0u;
              long long buf = 0u;
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v301);
              sub_100093B44((std::string *)&v341, (const std::string *)(v28 + 4));
              int v29 = v312;
              if (v312 >= v313)
              {
                int v30 = (TrafficDescriptor *)sub_100B06024((uint64_t *)&v311, (const TrafficDescriptor *)&buf);
              }
              else
              {
                TrafficDescriptor::TrafficDescriptor(v312, (const TrafficDescriptor *)&buf);
                int v30 = (TrafficDescriptor *)((char *)v29 + 304);
              }
              v312 = v30;
              TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
LABEL_75:
              char v39 = (void *)v28[1];
              if (v39)
              {
                do
                {
                  uint64_t v40 = v39;
                  char v39 = (void *)*v39;
                }
                while (v39);
              }
              else
              {
                do
                {
                  uint64_t v40 = (void *)v28[2];
                  BOOL v142 = *v40 == (void)v28;
                  uint64_t v28 = v40;
                }
                while (!v142);
              }
              uint64_t v28 = v40;
              if (v40 == v295)
              {
                BOOL v25 = v312;
                goto LABEL_82;
              }
            }
            memset(__dst, 0, 24);
            if (!*((unsigned char *)v301 + 72)) {
              sub_10016C840();
            }
            if (*((char *)v301 + 71) < 0)
            {
              sub_10004FC84(__dst, *((void **)v301 + 6), *((void *)v301 + 7));
            }
            else
            {
              *(_OWORD *)long long __dst = *((_OWORD *)v301 + 3);
              *(void *)&__dst[16] = *((void *)v301 + 8);
            }
            uint64_t v31 = *((unsigned __int8 *)v28 + 79);
            if ((v31 & 0x80u) == 0) {
              uint64_t v32 = *((unsigned __int8 *)v28 + 79);
            }
            else {
              uint64_t v32 = v28[8];
            }
            uint64_t v33 = __dst[23];
            char v34 = __dst[23];
            if (__dst[23] < 0) {
              uint64_t v33 = *(void *)&__dst[8];
            }
            if (v32 == v33)
            {
              int v35 = (const void **)(v28 + 7);
              if (__dst[23] >= 0) {
                char v36 = __dst;
              }
              else {
                char v36 = *(unsigned __int8 **)__dst;
              }
              if ((v31 & 0x80) != 0)
              {
                if (memcmp(*v35, v36, v28[8])) {
                  goto LABEL_73;
                }
              }
              else if (*((unsigned char *)v28 + 79))
              {
                while (*(unsigned __int8 *)v35 == *v36)
                {
                  int v35 = (const void **)((char *)v35 + 1);
                  ++v36;
                  if (!--v31) {
                    goto LABEL_69;
                  }
                }
                goto LABEL_73;
              }
LABEL_69:
              long long v355 = 0u;
              long long v356 = 0u;
              long long v353 = 0u;
              long long v354 = 0u;
              long long v351 = 0u;
              long long v352 = 0u;
              long long v349 = 0u;
              long long v350 = 0u;
              long long v347 = 0u;
              long long v348 = 0u;
              long long v345 = 0u;
              long long v346 = 0u;
              long long v343 = 0u;
              long long v344 = 0u;
              long long v341 = 0u;
              long long v342 = 0u;
              long long v339 = 0u;
              long long v340 = 0u;
              long long buf = 0u;
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v301);
              sub_100093B44((std::string *)&v341, (const std::string *)(v28 + 4));
              sub_100093B44((std::string *)&v343, (const std::string *)__dst);
              uint64_t v37 = v312;
              if (v312 >= v313)
              {
                uint64_t v38 = (TrafficDescriptor *)sub_100B06024((uint64_t *)&v311, (const TrafficDescriptor *)&buf);
              }
              else
              {
                TrafficDescriptor::TrafficDescriptor(v312, (const TrafficDescriptor *)&buf);
                uint64_t v38 = (TrafficDescriptor *)((char *)v37 + 304);
              }
              v312 = v38;
              TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
              char v34 = __dst[23];
            }
LABEL_73:
            if (v34 < 0) {
              operator delete(*(void **)__dst);
            }
            goto LABEL_75;
          }
LABEL_82:
          if (v311 != v25) {
            goto LABEL_83;
          }
          os_log_t v239 = *v300;
          if (!os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_589;
          }
          TrafficDescriptor::toString((uint64_t *)&buf, v301);
          p_long long buf = &buf;
          if (SBYTE7(v339) < 0) {
            p_long long buf = (long long *)buf;
          }
          *(_DWORD *)long long __dst = 136446210;
          *(void *)&__dst[4] = p_buf;
          uint64_t v241 = v239;
          v242 = "#N We do not know what to do with this Enterprise traffic descriptor, wrong bundle id or else: %{public}s";
LABEL_607:
          _os_log_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_DEFAULT, v242, __dst, 0xCu);
          if (SBYTE7(v339) < 0)
          {
            int64_t v243 = (void *)buf;
LABEL_609:
            operator delete(v243);
          }
LABEL_589:
          *(void *)&long long buf = &v311;
          sub_1008BE774((void ***)&buf);
          goto LABEL_590;
        }
        os_log_t v237 = *v300;
        if (!os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_589;
        }
        TrafficDescriptor::toString((uint64_t *)&buf, v301);
        uint64_t v238 = &buf;
        if (SBYTE7(v339) < 0) {
          uint64_t v238 = (long long *)buf;
        }
LABEL_606:
        *(_DWORD *)long long __dst = 136446210;
        *(void *)&__dst[4] = v238;
        uint64_t v241 = v237;
        v242 = "#E We do not know what to do with this Enterprise traffic descriptor: %{public}s if no managedAllowedApps"
               " configured. We are not going to set a broad all-inclusive traffic interception and examination for that purpose.";
        goto LABEL_607;
      }
      if (*((unsigned char *)v301 + 72) && (void **)(v299 + 168) != sub_100046F68(v299 + 160, (void **)v301 + 6))
      {
        if (!*(void *)(v299 + 152))
        {
          os_log_t v237 = *v300;
          if (!os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_589;
          }
          TrafficDescriptor::toString((uint64_t *)&buf, v301);
          uint64_t v238 = &buf;
          if (SBYTE7(v339) < 0) {
            uint64_t v238 = (long long *)buf;
          }
          goto LABEL_606;
        }
        unint64_t v27 = v311;
        for (int j = v312; j != v27; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)((char *)j - 304)))
          ;
        v312 = v27;
        memset(__dst, 0, 24);
        if (!*((unsigned char *)v301 + 72)) {
          sub_10016C840();
        }
        if (*((char *)v301 + 71) < 0)
        {
          sub_10004FC84(__dst, *((void **)v301 + 6), *((void *)v301 + 7));
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v301 + 3);
          *(void *)&__dst[16] = *((void *)v301 + 8);
        }
        uint64_t v244 = *(void **)(v299 + 136);
        if (v244 != v295)
        {
          while (1)
          {
            uint64_t v245 = *((unsigned __int8 *)v244 + 79);
            if ((v245 & 0x80u) == 0) {
              uint64_t v246 = *((unsigned __int8 *)v244 + 79);
            }
            else {
              uint64_t v246 = v244[8];
            }
            uint64_t v247 = __dst[23];
            if (__dst[23] < 0) {
              uint64_t v247 = *(void *)&__dst[8];
            }
            if (v246 != v247) {
              goto LABEL_631;
            }
            v248 = (const void **)(v244 + 7);
            v249 = __dst[23] >= 0 ? __dst : *(unsigned __int8 **)__dst;
            if ((v245 & 0x80) == 0) {
              break;
            }
            if (!memcmp(*v248, v249, v244[8])) {
              goto LABEL_627;
            }
LABEL_631:
            v252 = (void *)v244[1];
            if (v252)
            {
              do
              {
                v253 = v252;
                v252 = (void *)*v252;
              }
              while (v252);
            }
            else
            {
              do
              {
                v253 = (void *)v244[2];
                BOOL v142 = *v253 == (void)v244;
                uint64_t v244 = v253;
              }
              while (!v142);
            }
            uint64_t v244 = v253;
            if (v253 == v295) {
              goto LABEL_637;
            }
          }
          if (*((unsigned char *)v244 + 79))
          {
            while (*(unsigned __int8 *)v248 == *v249)
            {
              v248 = (const void **)((char *)v248 + 1);
              ++v249;
              if (!--v245) {
                goto LABEL_627;
              }
            }
            goto LABEL_631;
          }
LABEL_627:
          long long v355 = 0u;
          long long v356 = 0u;
          long long v353 = 0u;
          long long v354 = 0u;
          long long v351 = 0u;
          long long v352 = 0u;
          long long v349 = 0u;
          long long v350 = 0u;
          long long v347 = 0u;
          long long v348 = 0u;
          long long v345 = 0u;
          long long v346 = 0u;
          long long v343 = 0u;
          long long v344 = 0u;
          long long v341 = 0u;
          long long v342 = 0u;
          long long v339 = 0u;
          long long v340 = 0u;
          long long buf = 0u;
          TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v301);
          sub_100093B44((std::string *)&v341, (const std::string *)(v244 + 4));
          sub_100093B44((std::string *)&v343, (const std::string *)__dst);
          v250 = v312;
          if (v312 >= v313)
          {
            unsigned int v251 = (TrafficDescriptor *)sub_100B06024((uint64_t *)&v311, (const TrafficDescriptor *)&buf);
          }
          else
          {
            TrafficDescriptor::TrafficDescriptor(v312, (const TrafficDescriptor *)&buf);
            unsigned int v251 = (TrafficDescriptor *)((char *)v250 + 304);
          }
          v312 = v251;
          TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
          goto LABEL_631;
        }
LABEL_637:
        if (v311 == v312)
        {
          uint64_t v254 = *v300;
          if (os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT))
          {
            TrafficDescriptor::toString((uint64_t *)&buf, v301);
            v255 = &buf;
            if (SBYTE7(v339) < 0) {
              v255 = (long long *)buf;
            }
            *(_DWORD *)v357 = 136446210;
            *(void *)&v357[4] = v255;
            _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, "#E We do not know what to do with this Enterprise traffic descriptor, wrong bundle id or else: %{public}s", v357, 0xCu);
            if (SBYTE7(v339) < 0) {
              operator delete((void *)buf);
            }
          }
          if ((__dst[23] & 0x80000000) == 0) {
            goto LABEL_589;
          }
          int64_t v243 = *(void **)__dst;
          goto LABEL_609;
        }
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
      }
LABEL_83:
      if (*(unsigned char *)(v299 + 12) && (*(unsigned char *)(v299 + 13) || *(unsigned char *)(v299 + 14)))
      {
        uint64_t v42 = v311;
        uint64_t v41 = v312;
        for (k = v312; ; uint64_t v41 = k)
        {
          if (v42 == v41) {
            goto LABEL_232;
          }
          if (TrafficDescriptor::hasBundleInfo(v42)) {
            break;
          }
LABEL_133:
          uint64_t v42 = (TrafficDescriptor *)((char *)v42 + 304);
        }
        int64x2_t v328 = 0uLL;
        v329 = 0;
        if (!*((unsigned char *)v42 + 72)) {
          sub_10016C840();
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD68, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_101B0FD68))
        {
          sub_10056D028((std::locale *)&unk_101B10128, "^(\\*|[1-8])(\\.([0-9]+))(\\.(xr|(.*)))?$", 0);
        }
        long long v343 = 0u;
        long long v344 = 0u;
        long long v341 = 0u;
        long long v342 = 0u;
        long long v339 = 0u;
        long long v340 = 0u;
        long long buf = 0u;
        uint64_t v43 = *((unsigned __int8 *)v42 + 71);
        if ((v43 & 0x80u) == 0) {
          uint64_t v44 = (uint64_t)v42 + 48;
        }
        else {
          uint64_t v44 = *((void *)v42 + 6);
        }
        if ((v43 & 0x80u) != 0) {
          uint64_t v43 = *((void *)v42 + 7);
        }
        int v45 = sub_100570034(v44, v44 + v43, (uint64_t)&buf, (uint64_t)&unk_101B10128, 0);
        int v46 = (char *)buf;
        if (!v45 || (unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3), v47 < 4))
        {
          BOOL v56 = 0;
          if (!(void)buf) {
            goto LABEL_118;
          }
          goto LABEL_117;
        }
        memset(v357, 0, sizeof(v357));
        if (*(unsigned char *)(buf + 40))
        {
          sub_10012CD04(v357, *(char **)(buf + 24), *(char **)(buf + 32), *(void *)(buf + 32) - *(void *)(buf + 24));
          int v46 = (char *)buf;
          unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3);
        }
        std::string::size_type v334 = 0;
        std::string __p = 0;
        uint64_t v335 = 0;
        uint64_t v48 = v46 + 88;
        if (v47 <= 3) {
          uint64_t v48 = (char *)&v340 + 8;
        }
        if (*v48)
        {
          BOOL v49 = v47 > 3;
          uint64_t v50 = (char **)&v339 + 1;
          if (v49) {
            uint64_t v50 = (char **)(v46 + 72);
          }
          uint64_t v51 = *v50;
          uint64_t v52 = (char **)(v46 + 80);
          if (!v49) {
            uint64_t v52 = (char **)&v340;
          }
          sub_10012CD04(&__p, v51, *v52, *v52 - v51);
        }
        if (v299)
        {
          *(void *)long long __dst = 0;
          uint64_t v53 = v335 >= 0 ? (const char *)&__p : (const char *)__p;
          *(void *)long long __dst = strtoull(v53, 0, 10);
          sub_100B076CC(v287, (unint64_t *)__dst, (uint64_t *)__dst);
          if (!DataServiceController::realGoodGenre(v299, *(unint64_t *)__dst))
          {
            BOOL v292 = 0;
            char v63 = 0;
            char v64 = 1;
            goto LABEL_218;
          }
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3) < 6)
        {
          BOOL v62 = 0;
        }
        else
        {
          memset(__dst, 0, 24);
          if (*(unsigned char *)(buf + 136))
          {
            sub_10012CD04(__dst, *(char **)(buf + 120), *(char **)(buf + 128), *(void *)(buf + 128) - *(void *)(buf + 120));
            uint64_t v54 = __dst[23];
            uint64_t v55 = *(void *)&__dst[8];
          }
          else
          {
            uint64_t v55 = 0;
            uint64_t v54 = 0;
          }
          int v65 = (char)v54;
          if ((v54 & 0x80u) != 0) {
            uint64_t v54 = v55;
          }
          if (v54 == 2)
          {
            __int16 v66 = *(unsigned __int16 **)__dst;
            if (v65 >= 0) {
              __int16 v66 = (unsigned __int16 *)__dst;
            }
            BOOL v62 = *v66 == 29304;
            if ((v65 & 0x80000000) == 0) {
              goto LABEL_146;
            }
            goto LABEL_145;
          }
          BOOL v62 = 0;
          if (v65 < 0) {
LABEL_145:
          }
            operator delete(*(void **)__dst);
        }
LABEL_146:
        uint64_t v67 = v357[23];
        if ((v357[23] & 0x80u) != 0) {
          uint64_t v67 = *(void *)&v357[8];
        }
        BOOL v292 = v62;
        if (v67 != 1) {
          goto LABEL_182;
        }
        char v68 = v357;
        if ((v357[23] & 0x80u) != 0) {
          char v68 = *(uint8_t **)v357;
        }
        if (*v68 == 42)
        {
          for (uint64_t m = 1; m != 9; ++m)
          {
            unsigned int v70 = dword_10153E3D0[m - 1];
            sub_100058DB0(&v330, "com.apple.networkrelay.tethering.");
            std::string::push_back(&v330, m + 48);
            std::string v331 = v330;
            memset(&v330, 0, sizeof(v330));
            uint64_t v71 = std::string::append(&v331, ".", 1uLL);
            long long v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
            v332.__r_.__value_.__r.__words[2] = v71->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v332.__r_.__value_.__l.__data_ = v72;
            v71->__r_.__value_.__l.__size_ = 0;
            v71->__r_.__value_.__r.__words[2] = 0;
            v71->__r_.__value_.__r.__words[0] = 0;
            if (v335 >= 0) {
              p_p = (const std::string::value_type *)&__p;
            }
            else {
              p_p = (const std::string::value_type *)__p;
            }
            if (v335 >= 0) {
              std::string::size_type v74 = HIBYTE(v335);
            }
            else {
              std::string::size_type v74 = v334;
            }
            BOOL v75 = std::string::append(&v332, p_p, v74);
            std::string::size_type v76 = v75->__r_.__value_.__r.__words[0];
            *(void *)&long long v336 = v75->__r_.__value_.__l.__size_;
            *(void *)((char *)&v336 + 7) = *(std::string::size_type *)((char *)&v75->__r_.__value_.__r.__words[1] + 7);
            char v77 = HIBYTE(v75->__r_.__value_.__r.__words[2]);
            v75->__r_.__value_.__l.__size_ = 0;
            v75->__r_.__value_.__r.__words[2] = 0;
            v75->__r_.__value_.__r.__words[0] = 0;
            unint64_t v78 = v328.u64[1];
            unint64_t v79 = v329;
            if (v328.i64[1] >= (unint64_t)v329)
            {
              std::string::size_type v302 = v76;
              uint64_t v82 = v328.i64[0];
              uint64_t v83 = (v328.i64[1] - v328.i64[0]) >> 5;
              unint64_t v84 = v83 + 1;
              if ((unint64_t)(v83 + 1) >> 59) {
                sub_10006A748();
              }
              if ((uint64_t)&v329[-v328.i64[0]] >> 4 > v84) {
                unint64_t v84 = (uint64_t)&v329[-v328.i64[0]] >> 4;
              }
              if ((unint64_t)&v329[-v328.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v85 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v85 = v84;
              }
              *(void *)&__dst[32] = &v329;
              if (v85 >> 59) {
                sub_10006A7CC();
              }
              uint64_t v86 = (char *)operator new(32 * v85);
              CFArrayRef v87 = &v86[32 * v83];
              *(_DWORD *)CFArrayRef v87 = v70;
              uint64_t v88 = v336;
              *((void *)v87 + 1) = v302;
              *((void *)v87 + 2) = v88;
              *(void *)(v87 + 23) = *(void *)((char *)&v336 + 7);
              v87[31] = v77;
              *(void *)&long long v336 = 0;
              *(void *)((char *)&v336 + 7) = 0;
              if (v78 == v82)
              {
                int64x2_t v92 = vdupq_n_s64(v78);
                CFArrayRef v89 = &v86[32 * v83];
              }
              else
              {
                CFArrayRef v89 = &v86[32 * v83];
                do
                {
                  int v90 = *(_DWORD *)(v78 - 32);
                  v78 -= 32;
                  *((_DWORD *)v89 - 8) = v90;
                  v89 -= 32;
                  long long v91 = *(_OWORD *)(v78 + 8);
                  *((void *)v89 + 3) = *(void *)(v78 + 24);
                  *(_OWORD *)(v89 + 8) = v91;
                  *(void *)(v78 + 16) = 0;
                  *(void *)(v78 + 24) = 0;
                  *(void *)(v78 + 8) = 0;
                }
                while (v78 != v82);
                int64x2_t v92 = v328;
                unint64_t v79 = v329;
              }
              unint64_t v81 = (unint64_t)(v87 + 32);
              v328.i64[0] = (uint64_t)v89;
              v328.i64[1] = (uint64_t)(v87 + 32);
              *(int64x2_t *)&__dst[8] = v92;
              v329 = &v86[32 * v85];
              *(void *)&__dst[24] = v79;
              *(void *)long long __dst = v92.i64[0];
              sub_100255B70((uint64_t)__dst);
              uint64_t v4 = (uint64_t)v304;
              uint64_t v9 = v305;
            }
            else
            {
              *(_DWORD *)v328.i64[1] = v70;
              uint64_t v80 = v336;
              *(void *)(v78 + 8) = v76;
              *(void *)(v78 + 16) = v80;
              *(void *)(v78 + 23) = *(void *)((char *)&v336 + 7);
              *(unsigned char *)(v78 + 31) = v77;
              unint64_t v81 = v78 + 32;
              uint64_t v4 = (uint64_t)v304;
            }
            v328.i64[1] = v81;
            if (SHIBYTE(v332.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v332.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v331.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v331.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v330.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v330.__r_.__value_.__l.__data_);
            }
          }
        }
        else
        {
LABEL_182:
          unint64_t v93 = sub_100AF0DCC((char *)v357);
          if (!HIDWORD(v93)) {
            operator new();
          }
          int v94 = v93;
          sub_100058DB0(&v330, "com.apple.networkrelay.tethering.");
          if ((v357[23] & 0x80u) == 0) {
            uint64_t v95 = v357;
          }
          else {
            uint64_t v95 = *(uint8_t **)v357;
          }
          if ((v357[23] & 0x80u) == 0) {
            std::string::size_type v96 = v357[23];
          }
          else {
            std::string::size_type v96 = *(void *)&v357[8];
          }
          id v97 = std::string::append(&v330, (const std::string::value_type *)v95, v96);
          long long v98 = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
          v331.__r_.__value_.__r.__words[2] = v97->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v331.__r_.__value_.__l.__data_ = v98;
          v97->__r_.__value_.__l.__size_ = 0;
          v97->__r_.__value_.__r.__words[2] = 0;
          v97->__r_.__value_.__r.__words[0] = 0;
          char v99 = std::string::append(&v331, ".", 1uLL);
          long long v100 = *(_OWORD *)&v99->__r_.__value_.__l.__data_;
          v332.__r_.__value_.__r.__words[2] = v99->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v332.__r_.__value_.__l.__data_ = v100;
          v99->__r_.__value_.__l.__size_ = 0;
          v99->__r_.__value_.__r.__words[2] = 0;
          v99->__r_.__value_.__r.__words[0] = 0;
          if (v335 >= 0) {
            CFArrayRef v101 = (const std::string::value_type *)&__p;
          }
          else {
            CFArrayRef v101 = (const std::string::value_type *)__p;
          }
          if (v335 >= 0) {
            std::string::size_type v102 = HIBYTE(v335);
          }
          else {
            std::string::size_type v102 = v334;
          }
          id v103 = std::string::append(&v332, v101, v102);
          std::string::size_type v104 = v103->__r_.__value_.__r.__words[0];
          *(void *)&long long v336 = v103->__r_.__value_.__l.__size_;
          *(void *)((char *)&v336 + 7) = *(std::string::size_type *)((char *)&v103->__r_.__value_.__r.__words[1] + 7);
          char v105 = HIBYTE(v103->__r_.__value_.__r.__words[2]);
          v103->__r_.__value_.__l.__size_ = 0;
          v103->__r_.__value_.__r.__words[2] = 0;
          v103->__r_.__value_.__r.__words[0] = 0;
          unint64_t v106 = v328.u64[1];
          CFArrayRef v107 = v329;
          if (v328.i64[1] >= (unint64_t)v329)
          {
            uint64_t v110 = v328.i64[0];
            uint64_t v111 = (v328.i64[1] - v328.i64[0]) >> 5;
            unint64_t v112 = v111 + 1;
            if ((unint64_t)(v111 + 1) >> 59) {
              sub_10006A748();
            }
            if ((uint64_t)&v329[-v328.i64[0]] >> 4 > v112) {
              unint64_t v112 = (uint64_t)&v329[-v328.i64[0]] >> 4;
            }
            if ((unint64_t)&v329[-v328.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v113 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v113 = v112;
            }
            *(void *)&__dst[32] = &v329;
            if (v113 >> 59) {
              sub_10006A7CC();
            }
            long long v114 = (char *)operator new(32 * v113);
            long long v115 = &v114[32 * v111];
            *(_DWORD *)long long v115 = v94;
            uint64_t v116 = v336;
            *((void *)v115 + 1) = v104;
            *((void *)v115 + 2) = v116;
            *(void *)(v115 + 23) = *(void *)((char *)&v336 + 7);
            v115[31] = v105;
            *(void *)&long long v336 = 0;
            *(void *)((char *)&v336 + 7) = 0;
            if (v106 == v110)
            {
              int64x2_t v120 = vdupq_n_s64(v106);
              CFNumberRef v117 = &v114[32 * v111];
            }
            else
            {
              CFNumberRef v117 = &v114[32 * v111];
              do
              {
                int v118 = *(_DWORD *)(v106 - 32);
                v106 -= 32;
                *((_DWORD *)v117 - 8) = v118;
                v117 -= 32;
                long long v119 = *(_OWORD *)(v106 + 8);
                *((void *)v117 + 3) = *(void *)(v106 + 24);
                *(_OWORD *)(v117 + 8) = v119;
                *(void *)(v106 + 16) = 0;
                *(void *)(v106 + 24) = 0;
                *(void *)(v106 + 8) = 0;
              }
              while (v106 != v110);
              int64x2_t v120 = v328;
              CFArrayRef v107 = v329;
            }
            unint64_t v109 = (unint64_t)(v115 + 32);
            v328.i64[0] = (uint64_t)v117;
            v328.i64[1] = (uint64_t)(v115 + 32);
            *(int64x2_t *)&__dst[8] = v120;
            v329 = &v114[32 * v113];
            *(void *)&__dst[24] = v107;
            *(void *)long long __dst = v120.i64[0];
            sub_100255B70((uint64_t)__dst);
            uint64_t v4 = (uint64_t)v304;
          }
          else
          {
            *(_DWORD *)v328.i64[1] = v94;
            uint64_t v108 = v336;
            *(void *)(v106 + 8) = v104;
            *(void *)(v106 + 16) = v108;
            *(void *)(v106 + 23) = *(void *)((char *)&v336 + 7);
            *(unsigned char *)(v106 + 31) = v105;
            unint64_t v109 = v106 + 32;
          }
          v328.i64[1] = v109;
          uint64_t v9 = v305;
          if (SHIBYTE(v332.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v332.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v331.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v331.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v330.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v330.__r_.__value_.__l.__data_);
          }
        }
        char v64 = 0;
        char v63 = 1;
LABEL_218:
        if (SHIBYTE(v335) < 0) {
          operator delete(__p);
        }
        if ((char)v357[23] < 0) {
          operator delete(*(void **)v357);
        }
        int v46 = (char *)buf;
        if ((v63 & 1) == 0)
        {
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          if ((v64 & 1) == 0)
          {
            *(void *)&long long buf = &v328;
            sub_100B05F98((void ***)&buf);
          }
          BOOL v56 = v292;
          goto LABEL_118;
        }
        BOOL v56 = v292;
        if (!(void)buf)
        {
LABEL_118:
          uint64_t v58 = v328.i64[1];
          uint64_t v57 = v328.i64[0];
          if (v328.i64[0] != v328.i64[1] && (v56 || !*(unsigned char *)(v299 + 20)))
          {
            if (v56) {
              __int16 v59 = 257;
            }
            else {
              __int16 v59 = 0;
            }
            do
            {
              long long v355 = 0u;
              long long v356 = 0u;
              long long v353 = 0u;
              long long v354 = 0u;
              long long v351 = 0u;
              long long v352 = 0u;
              long long v349 = 0u;
              long long v350 = 0u;
              long long v347 = 0u;
              long long v348 = 0u;
              long long v345 = 0u;
              long long v346 = 0u;
              long long v343 = 0u;
              long long v344 = 0u;
              long long v341 = 0u;
              long long v342 = 0u;
              long long v339 = 0u;
              long long v340 = 0u;
              long long buf = 0u;
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf);
              sub_100093B44((std::string *)&v345, (const std::string *)(v57 + 8));
              if (!*((unsigned char *)v42 + 72)) {
LABEL_726:
              }
                sub_10016C840();
              sub_100093B44((std::string *)&v343, (const std::string *)v42 + 2);
              LOWORD(v347) = v59;
              if (TrafficDescriptor::hasRsDnnInfo(v42))
              {
                if (!*((unsigned char *)v42 + 296)) {
                  goto LABEL_726;
                }
                sub_100093B44((std::string *)&v355, (const std::string *)((char *)v42 + 272));
              }
              long long v60 = v315;
              if ((unint64_t)v315 >= v316)
              {
                uint64_t v61 = (TrafficDescriptor *)sub_100B06024((uint64_t *)&v314, (const TrafficDescriptor *)&buf);
              }
              else
              {
                TrafficDescriptor::TrafficDescriptor(v315, (const TrafficDescriptor *)&buf);
                uint64_t v61 = (TrafficDescriptor *)((char *)v60 + 304);
              }
              v315 = v61;
              TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
              v57 += 32;
            }
            while (v57 != v58);
          }
          *(void *)&long long buf = &v328;
          sub_100B05F98((void ***)&buf);
          uint64_t v16 = a3;
          goto LABEL_133;
        }
LABEL_117:
        *((void *)&buf + 1) = v46;
        operator delete(v46);
        goto LABEL_118;
      }
LABEL_232:
      v308 = 0;
      v309 = 0;
      unint64_t v310 = 0;
      v306 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v9);
      LODWORD(buf) = v9;
      CFNumberRef v121 = sub_10003B194(v298, (int *)&buf);
      long long v122 = v311;
      v297 = v312;
      if (v311 != v312)
      {
        uint64_t v303 = *v121;
        while ((TrafficDescriptor::hasBundleInfo(v122) & 1) == 0 && (sub_100AEAD30(v4, v122) & 1) == 0)
        {
          uint64_t v131 = *v306;
          if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
          {
            TrafficDescriptor::toString((uint64_t *)&buf, v122);
            CFTypeID v132 = &buf;
            if (SBYTE7(v339) < 0) {
              CFTypeID v132 = (long long *)buf;
            }
            *(_DWORD *)long long __dst = 136315394;
            *(void *)&__dst[4] = v16;
            *(_WORD *)&__dst[12] = 2082;
            *(void *)&__dst[14] = v132;
            _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(0.1-no bundle id) %{public}s", __dst, 0x16u);
            if (SBYTE7(v339) < 0) {
              operator delete((void *)buf);
            }
          }
          CFNumberRef v133 = v309;
          if ((unint64_t)v309 >= v310)
          {
            uint64_t v134 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v308, v122);
          }
          else
          {
            TrafficDescriptor::TrafficDescriptor(v309, v122);
            uint64_t v134 = (TrafficDescriptor *)((char *)v133 + 304);
          }
          v309 = v134;
LABEL_453:
          long long v122 = (TrafficDescriptor *)((char *)v122 + 304);
          if (v122 == v297) {
            goto LABEL_569;
          }
        }
        long long v336 = 0uLL;
        unint64_t v337 = 0;
        v326 = 0;
        v325 = 0;
        unint64_t v327 = 0;
        if ((TrafficDescriptor::hasBundleInfo(v122) & 1) == 0)
        {
          v127 = v325;
          CFTypeID v128 = v326;
          if (v325 != v326)
          {
LABEL_357:
            CFNumberRef v129 = (TrafficDescriptor *)*((void *)&v336 + 1);
            do
            {
              if ((unint64_t)v129 >= v337)
              {
                CFNumberRef v129 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v336, v127);
              }
              else
              {
                TrafficDescriptor::TrafficDescriptor(v129, v127);
                CFNumberRef v129 = (TrafficDescriptor *)((char *)v129 + 304);
              }
              *((void *)&v336 + 1) = v129;
              v127 = (const TrafficDescriptor *)((char *)v127 + 304);
            }
            while (v127 != v128);
            goto LABEL_370;
          }
          CFNumberRef v129 = (TrafficDescriptor *)*((void *)&v336 + 1);
          goto LABEL_364;
        }
        *(_OWORD *)&v330.__r_.__value_.__r.__words[1] = 0uLL;
        v330.__r_.__value_.__r.__words[0] = (std::string::size_type)&v330.__r_.__value_.__l.__size_;
        int64x2_t v328 = 0uLL;
        v329 = 0;
        if (!*((unsigned char *)v122 + 72)) {
          sub_10016C840();
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD60, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_101B0FD60))
        {
          sub_10056D028((std::locale *)&unk_101B100E8, "^(\\*|[1-8])(\\.((\\*|[0-9]+)(\\.(\\*|[0-9]+)?)?)?)?$", 0);
        }
        long long v343 = 0u;
        long long v344 = 0u;
        long long v341 = 0u;
        long long v342 = 0u;
        long long v339 = 0u;
        long long v340 = 0u;
        long long buf = 0u;
        uint64_t v123 = *((unsigned __int8 *)v122 + 71);
        if ((v123 & 0x80u) == 0) {
          uint64_t v124 = (uint64_t)v122 + 48;
        }
        else {
          uint64_t v124 = *((void *)v122 + 6);
        }
        if ((v123 & 0x80u) != 0) {
          uint64_t v123 = *((void *)v122 + 7);
        }
        if (!sub_100570034(v124, v124 + v123, (uint64_t)&buf, (uint64_t)&unk_101B100E8, 0)
          || *((void *)&buf + 1) - (void)buf != 168)
        {
          int v293 = 0;
          goto LABEL_251;
        }
        std::string::size_type v334 = 0;
        std::string __p = 0;
        uint64_t v335 = 0;
        if (*(unsigned char *)(buf + 40))
        {
          sub_10012CD04(&__p, *(char **)(buf + 24), *(char **)(buf + 32), *(void *)(buf + 32) - *(void *)(buf + 24));
          std::string::size_type v125 = HIBYTE(v335);
          std::string::size_type v126 = v334;
        }
        else
        {
          std::string::size_type v126 = 0;
          std::string::size_type v125 = 0;
        }
        int v192 = (char)v125;
        if ((v125 & 0x80u) != 0) {
          std::string::size_type v125 = v126;
        }
        if (v125 == 1)
        {
          v193 = &__p;
          if (v192 < 0) {
            v193 = __p;
          }
          if (*v193 == 42)
          {
            if (v192 < 0)
            {
              *(unsigned char *)std::string __p = 0;
              std::string::size_type v334 = 0;
            }
            else
            {
              LOBYTE(__p) = 0;
              HIBYTE(v335) = 0;
            }
          }
        }
        memset(&v332, 0, sizeof(v332));
        unint64_t v194 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3);
        CFTypeID v195 = (unsigned char *)(buf + 112);
        if (v194 <= 4) {
          CFTypeID v195 = (char *)&v340 + 8;
        }
        if (*v195)
        {
          BOOL v196 = v194 > 4;
          v197 = (char **)&v339 + 1;
          if (v196) {
            v197 = (char **)(buf + 96);
          }
          v198 = (char **)(buf + 104);
          if (!v196) {
            v198 = (char **)&v340;
          }
          sub_10012CD04(&v332, *v197, *v198, *v198 - *v197);
          std::string::size_type v199 = HIBYTE(v332.__r_.__value_.__r.__words[2]);
          std::string::size_type size = v332.__r_.__value_.__l.__size_;
        }
        else
        {
          std::string::size_type size = 0;
          std::string::size_type v199 = 0;
        }
        if ((v199 & 0x80u) == 0) {
          std::string::size_type v201 = v199;
        }
        else {
          std::string::size_type v201 = size;
        }
        if (v201 != 1) {
          goto LABEL_483;
        }
        v202 = &v332;
        if ((v199 & 0x80u) != 0) {
          v202 = (std::string *)v332.__r_.__value_.__r.__words[0];
        }
        if (v202->__r_.__value_.__s.__data_[0] == 42)
        {
          if (((char)v199 & 0x80000000) == 0)
          {
            v332.__r_.__value_.__s.__data_[0] = 0;
            *((unsigned char *)&v332.__r_.__value_.__s + 23) = 0;
            unint64_t v203 = sub_100AF0DCC((char *)&__p);
            std::string::size_type v199 = 0;
LABEL_489:
            unint64_t v205 = 0;
            goto LABEL_490;
          }
          *v332.__r_.__value_.__l.__data_ = 0;
          v332.__r_.__value_.__l.__size_ = 0;
          int v226 = SHIBYTE(v332.__r_.__value_.__r.__words[2]);
          std::string::size_type v199 = HIBYTE(v332.__r_.__value_.__r.__words[2]);
          unint64_t v203 = sub_100AF0DCC((char *)&__p);
          std::string::size_type size = 0;
          unint64_t v205 = 0;
          if (v226 < 0) {
            goto LABEL_490;
          }
        }
        else
        {
LABEL_483:
          unint64_t v203 = sub_100AF0DCC((char *)&__p);
          if ((char)v199 < 0)
          {
            if (!size) {
              goto LABEL_489;
            }
            CFNumberRef v204 = (std::string *)v332.__r_.__value_.__r.__words[0];
            goto LABEL_488;
          }
        }
        if (!v199) {
          goto LABEL_489;
        }
        CFNumberRef v204 = &v332;
LABEL_488:
        unint64_t v205 = strtoull((const char *)v204, 0, 10);
        std::string::size_type v199 = HIBYTE(v332.__r_.__value_.__r.__words[2]);
        std::string::size_type size = v332.__r_.__value_.__l.__size_;
LABEL_490:
        if ((v203 & 0xFF00000000) == 0 && !((v199 & 0x80u) == 0 ? v199 : size))
        {
          char v225 = 1;
LABEL_559:
          if (SHIBYTE(v332.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v332.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v335) < 0) {
            operator delete(__p);
          }
          int v293 = 1;
          if ((v225 & 1) == 0)
          {
            int v130 = 0;
            goto LABEL_252;
          }
LABEL_251:
          int v130 = 1;
LABEL_252:
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          if (v130)
          {
            v328.i64[1] = 0;
            v329 = 0;
            v328.i64[0] = (uint64_t)&v328.i64[1];
LABEL_299:
            std::string::size_type v148 = v330.__r_.__value_.__r.__words[0];
            uint64_t v4 = (uint64_t)v304;
            if ((std::string::size_type *)v330.__r_.__value_.__l.__data_ != &v330.__r_.__value_.__r.__words[1])
            {
              do
              {
                if (*(unsigned char *)(v148 + 52))
                {
                  if (!*(unsigned char *)(v148 + 40))
                  {
                    v149 = (void *)v304[624];
                    if (v149 != v307)
                    {
                      do
                      {
                        long long v355 = 0u;
                        long long v356 = 0u;
                        long long v353 = 0u;
                        long long v354 = 0u;
                        long long v351 = 0u;
                        long long v352 = 0u;
                        long long v349 = 0u;
                        long long v350 = 0u;
                        long long v347 = 0u;
                        long long v348 = 0u;
                        long long v345 = 0u;
                        long long v346 = 0u;
                        long long v343 = 0u;
                        long long v344 = 0u;
                        long long v341 = 0u;
                        long long v342 = 0u;
                        long long v339 = 0u;
                        long long v340 = 0u;
                        long long buf = 0u;
                        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v122);
                        DWORD1(buf) = *((_DWORD *)v149 + 8);
                        BYTE8(buf) = 1;
                        sub_100179AF8((std::string *)&v343, (const std::string *)v122 + 2);
                        __dst[0] = 0;
                        __dst[24] = 0;
                        sub_100179CB0((uint64_t)&v341, (__n128 *)__dst);
                        if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                          operator delete(*(void **)__dst);
                        }
                        if (*((char *)v149 + 119) < 0)
                        {
                          if (!v149[13])
                          {
LABEL_310:
                            __dst[0] = 0;
                            __dst[24] = 0;
                            sub_100179CB0((uint64_t)&v339, (__n128 *)__dst);
                            if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                              operator delete(*(void **)__dst);
                            }
                            goto LABEL_313;
                          }
                        }
                        else if (!*((unsigned char *)v149 + 119))
                        {
                          goto LABEL_310;
                        }
                        sub_100093B44((std::string *)&v339, (const std::string *)v149 + 4);
LABEL_313:
                        if (!*(unsigned char *)(v148 + 52)) {
                          sub_10016C840();
                        }
                        DWORD1(v352) = *(_DWORD *)(v148 + 48);
                        BYTE8(v352) = 1;
                        sub_100AF09B4((uint64_t *)&v325, (uint64_t)v325, (const TrafficDescriptor *)&buf);
                        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
                        CFTypeID v150 = (void *)v149[1];
                        if (v150)
                        {
                          do
                          {
                            CFNumberRef v151 = v150;
                            CFTypeID v150 = (void *)*v150;
                          }
                          while (v150);
                        }
                        else
                        {
                          do
                          {
                            CFNumberRef v151 = (void *)v149[2];
                            BOOL v142 = *v151 == (void)v149;
                            v149 = v151;
                          }
                          while (!v142);
                        }
                        v149 = v151;
                      }
                      while (v151 != v307);
                    }
                  }
                }
                v152 = *(std::string **)(v148 + 8);
                if (v152)
                {
                  do
                  {
                    v153 = v152;
                    v152 = (std::string *)v152->__r_.__value_.__r.__words[0];
                  }
                  while (v152);
                }
                else
                {
                  do
                  {
                    v153 = *(std::string **)(v148 + 16);
                    BOOL v142 = v153->__r_.__value_.__r.__words[0] == v148;
                    std::string::size_type v148 = (std::string::size_type)v153;
                  }
                  while (!v142);
                }
                std::string::size_type v148 = (std::string::size_type)v153;
              }
              while (v153 != (std::string *)&v330.__r_.__value_.__r.__words[1]);
              std::string::size_type v154 = v330.__r_.__value_.__r.__words[0];
              if ((std::string::size_type *)v330.__r_.__value_.__l.__data_ != &v330.__r_.__value_.__r.__words[1])
              {
                while (1)
                {
                  if (*(unsigned char *)(v154 + 40))
                  {
                    CFNumberRef v155 = (void *)v304[624];
                    if (v155 != v307) {
                      break;
                    }
                  }
LABEL_350:
                  CFTypeID v158 = *(std::string **)(v154 + 8);
                  if (v158)
                  {
                    do
                    {
                      CFNumberRef v159 = v158;
                      CFTypeID v158 = (std::string *)v158->__r_.__value_.__r.__words[0];
                    }
                    while (v158);
                  }
                  else
                  {
                    do
                    {
                      CFNumberRef v159 = *(std::string **)(v154 + 16);
                      BOOL v142 = v159->__r_.__value_.__r.__words[0] == v154;
                      std::string::size_type v154 = (std::string::size_type)v159;
                    }
                    while (!v142);
                  }
                  std::string::size_type v154 = (std::string::size_type)v159;
                  if (v159 == (std::string *)&v330.__r_.__value_.__r.__words[1]) {
                    goto LABEL_356;
                  }
                }
                while (1)
                {
                  if (!*(unsigned char *)(v154 + 40)) {
                    sub_10016C840();
                  }
                  if (v155[5] != *(void *)(v154 + 32)) {
                    goto LABEL_344;
                  }
                  long long v355 = 0u;
                  long long v356 = 0u;
                  long long v353 = 0u;
                  long long v354 = 0u;
                  long long v351 = 0u;
                  long long v352 = 0u;
                  long long v349 = 0u;
                  long long v350 = 0u;
                  long long v347 = 0u;
                  long long v348 = 0u;
                  long long v345 = 0u;
                  long long v346 = 0u;
                  long long v343 = 0u;
                  long long v344 = 0u;
                  long long v341 = 0u;
                  long long v342 = 0u;
                  long long v339 = 0u;
                  long long v340 = 0u;
                  long long buf = 0u;
                  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v122);
                  DWORD1(buf) = *((_DWORD *)v155 + 8);
                  BYTE8(buf) = 1;
                  sub_100179AF8((std::string *)&v343, (const std::string *)v122 + 2);
                  __dst[0] = 0;
                  __dst[24] = 0;
                  sub_100179CB0((uint64_t)&v341, (__n128 *)__dst);
                  if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__dst);
                  }
                  if (*((char *)v155 + 119) < 0)
                  {
                    if (!v155[13])
                    {
LABEL_338:
                      __dst[0] = 0;
                      __dst[24] = 0;
                      sub_100179CB0((uint64_t)&v339, (__n128 *)__dst);
                      if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                        operator delete(*(void **)__dst);
                      }
                      goto LABEL_341;
                    }
                  }
                  else if (!*((unsigned char *)v155 + 119))
                  {
                    goto LABEL_338;
                  }
                  sub_100093B44((std::string *)&v339, (const std::string *)v155 + 4);
LABEL_341:
                  if (*(unsigned char *)(v154 + 52))
                  {
                    DWORD1(v352) = *(_DWORD *)(v154 + 48);
                    BYTE8(v352) = 1;
                  }
                  sub_100AF09B4((uint64_t *)&v325, (uint64_t)v325, (const TrafficDescriptor *)&buf);
                  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
LABEL_344:
                  v156 = (void *)v155[1];
                  if (v156)
                  {
                    do
                    {
                      v157 = v156;
                      v156 = (void *)*v156;
                    }
                    while (v156);
                  }
                  else
                  {
                    do
                    {
                      v157 = (void *)v155[2];
                      BOOL v142 = *v157 == (void)v155;
                      CFNumberRef v155 = v157;
                    }
                    while (!v142);
                  }
                  CFNumberRef v155 = v157;
                  if (v157 == v307) {
                    goto LABEL_350;
                  }
                }
              }
            }
LABEL_356:
            sub_100B07788((char *)v328.i64[1]);
            sub_10005D144((void *)v330.__r_.__value_.__l.__size_);
            v127 = v325;
            CFTypeID v128 = v326;
            if (v325 != v326) {
              goto LABEL_357;
            }
            CFNumberRef v129 = (TrafficDescriptor *)*((void *)&v336 + 1);
            if (v293)
            {
LABEL_370:
              for (uint64_t n = v336; ; n += 304)
              {
                if ((TrafficDescriptor *)n == v129)
                {
                  *(void *)&long long buf = &v325;
                  sub_1008BE774((void ***)&buf);
                  *(void *)&long long buf = &v336;
                  sub_1008BE774((void ***)&buf);
                  goto LABEL_453;
                }
                if (sub_100AEAD30(v4, (TrafficDescriptor *)n))
                {
                  v161 = *v306;
                  if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
                  {
                    TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)n);
                    CFTypeID v162 = &buf;
                    if (SBYTE7(v339) < 0) {
                      CFTypeID v162 = (long long *)buf;
                    }
                    *(_DWORD *)long long __dst = 136315394;
                    *(void *)&__dst[4] = v16;
                    *(_WORD *)&__dst[12] = 2082;
                    *(void *)&__dst[14] = v162;
                    _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(0.2-internal) %{public}s", __dst, 0x16u);
                    if (SBYTE7(v339) < 0) {
                      operator delete((void *)buf);
                    }
                  }
                  CFNumberRef v163 = v309;
                  if ((unint64_t)v309 < v310) {
                    goto LABEL_408;
                  }
                  goto LABEL_409;
                }
                if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)n))
                {
                  uint64_t v174 = *v306;
                  if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
                  {
                    TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)n);
                    CFArrayRef v175 = &buf;
                    if (SBYTE7(v339) < 0) {
                      CFArrayRef v175 = (long long *)buf;
                    }
                    *(_DWORD *)long long __dst = 136315394;
                    *(void *)&__dst[4] = v16;
                    *(_WORD *)&__dst[12] = 2082;
                    *(void *)&__dst[14] = v175;
                    _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(5-no bundle id) %{public}s", __dst, 0x16u);
                    if (SBYTE7(v339) < 0) {
                      operator delete((void *)buf);
                    }
                  }
                  CFNumberRef v163 = v309;
                  if ((unint64_t)v309 < v310)
                  {
LABEL_408:
                    TrafficDescriptor::TrafficDescriptor(v309, (const TrafficDescriptor *)n);
                    CFArrayRef v176 = (TrafficDescriptor *)((char *)v163 + 304);
LABEL_410:
                    v309 = v176;
                    continue;
                  }
LABEL_409:
                  CFArrayRef v176 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v308, (const TrafficDescriptor *)n);
                  goto LABEL_410;
                }
                if (!*(unsigned char *)(n + 72)) {
                  goto LABEL_725;
                }
                v164 = sub_100AF086C(v4, (void **)(n + 48));
                if (!v164[2]) {
                  break;
                }
                if (*(unsigned char *)(v303 + 15))
                {
                  long long v355 = 0u;
                  long long v356 = 0u;
                  long long v353 = 0u;
                  long long v354 = 0u;
                  long long v351 = 0u;
                  long long v352 = 0u;
                  long long v349 = 0u;
                  long long v350 = 0u;
                  long long v347 = 0u;
                  long long v348 = 0u;
                  long long v345 = 0u;
                  long long v346 = 0u;
                  long long v343 = 0u;
                  long long v344 = 0u;
                  long long v341 = 0u;
                  long long v342 = 0u;
                  long long v339 = 0u;
                  long long v340 = 0u;
                  long long buf = 0u;
                  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, (const TrafficDescriptor *)n);
                  v165 = *v306;
                  if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
                  {
                    TrafficDescriptor::toString((uint64_t *)__dst, (TrafficDescriptor *)&buf);
                    CFTypeID v166 = __dst;
                    if (__dst[23] < 0) {
                      CFTypeID v166 = *(unsigned char **)__dst;
                    }
                    *(_DWORD *)v357 = 136315394;
                    *(void *)&v357[4] = v16;
                    *(_WORD *)&v357[12] = 2082;
                    *(void *)&v357[14] = v166;
                    _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(1-generic) %{public}s", v357, 0x16u);
                    if ((__dst[23] & 0x80000000) != 0) {
                      operator delete(*(void **)__dst);
                    }
                  }
                  uint64_t v169 = *v164;
                  CFNumberRef v167 = v164 + 1;
                  uint64_t v168 = (void *)v169;
                  if ((uint64_t *)v169 != v167)
                  {
                    do
                    {
                      sub_100093B44((std::string *)&v339, (const std::string *)(v168 + 4));
                      unint64_t v170 = v309;
                      if ((unint64_t)v309 >= v310)
                      {
                        uint64_t v171 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v308, (const TrafficDescriptor *)&buf);
                      }
                      else
                      {
                        TrafficDescriptor::TrafficDescriptor(v309, (const TrafficDescriptor *)&buf);
                        uint64_t v171 = (TrafficDescriptor *)((char *)v170 + 304);
                      }
                      v309 = v171;
                      v172 = (uint64_t *)v168[1];
                      if (v172)
                      {
                        do
                        {
                          uint64_t v173 = v172;
                          v172 = (uint64_t *)*v172;
                        }
                        while (v172);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v173 = (uint64_t *)v168[2];
                          BOOL v142 = *v173 == (void)v168;
                          uint64_t v168 = v173;
                        }
                        while (!v142);
                      }
                      uint64_t v168 = v173;
                    }
                    while (v173 != v167);
                  }
                  if (!BYTE8(v342)) {
                    sub_10016C840();
                  }
                  uint64_t v4 = (uint64_t)v304;
                  sub_100AF2618((uint64_t)v304, v9, (void **)&v341, 0);
LABEL_450:
                  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
                  continue;
                }
                if (!*(unsigned char *)(n + 72)) {
LABEL_725:
                }
                  sub_10016C840();
                if (sub_100AF092C(v4, v9, (void **)(n + 48)))
                {
                  long long v355 = 0u;
                  long long v356 = 0u;
                  long long v353 = 0u;
                  long long v354 = 0u;
                  long long v351 = 0u;
                  long long v352 = 0u;
                  long long v349 = 0u;
                  long long v350 = 0u;
                  long long v347 = 0u;
                  long long v348 = 0u;
                  long long v345 = 0u;
                  long long v346 = 0u;
                  long long v343 = 0u;
                  long long v344 = 0u;
                  long long v341 = 0u;
                  long long v342 = 0u;
                  long long v339 = 0u;
                  long long v340 = 0u;
                  long long buf = 0u;
                  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, (const TrafficDescriptor *)n);
                  CFTypeID v181 = *v306;
                  if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
                  {
                    TrafficDescriptor::toString((uint64_t *)__dst, (TrafficDescriptor *)&buf);
                    CFArrayRef v182 = __dst;
                    if (__dst[23] < 0) {
                      CFArrayRef v182 = *(unsigned char **)__dst;
                    }
                    *(_DWORD *)v357 = 136315394;
                    *(void *)&v357[4] = v16;
                    *(_WORD *)&v357[12] = 2082;
                    *(void *)&v357[14] = v182;
                    _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(2-managed) %{public}s", v357, 0x16u);
                    if ((__dst[23] & 0x80000000) != 0) {
                      operator delete(*(void **)__dst);
                    }
                  }
                  uint64_t v185 = *v164;
                  CFIndex v183 = v164 + 1;
                  uint64_t v184 = (void *)v185;
                  if ((uint64_t *)v185 != v183)
                  {
                    do
                    {
                      sub_100093B44((std::string *)&v339, (const std::string *)(v184 + 4));
                      v186 = v309;
                      if ((unint64_t)v309 >= v310)
                      {
                        unint64_t v187 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v308, (const TrafficDescriptor *)&buf);
                      }
                      else
                      {
                        TrafficDescriptor::TrafficDescriptor(v309, (const TrafficDescriptor *)&buf);
                        unint64_t v187 = (TrafficDescriptor *)((char *)v186 + 304);
                      }
                      v309 = v187;
                      v188 = (uint64_t *)v184[1];
                      if (v188)
                      {
                        do
                        {
                          v189 = v188;
                          v188 = (uint64_t *)*v188;
                        }
                        while (v188);
                      }
                      else
                      {
                        do
                        {
                          v189 = (uint64_t *)v184[2];
                          BOOL v142 = *v189 == (void)v184;
                          uint64_t v184 = v189;
                        }
                        while (!v142);
                      }
                      uint64_t v184 = v189;
                    }
                    while (v189 != v183);
                  }
                  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
                  uint64_t v4 = (uint64_t)v304;
                }
                else
                {
                  CFArrayRef v190 = *v306;
                  if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
                  {
                    TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)n);
                    CFArrayRef v191 = &buf;
                    if (SBYTE7(v339) < 0) {
                      CFArrayRef v191 = (long long *)buf;
                    }
                    *(_DWORD *)long long __dst = 136315394;
                    *(void *)&__dst[4] = v16;
                    *(_WORD *)&__dst[12] = 2082;
                    *(void *)&__dst[14] = v191;
                    _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(3-skip consumer) %{public}s", __dst, 0x16u);
                    if (SBYTE7(v339) < 0) {
                      operator delete((void *)buf);
                    }
                  }
                }
              }
              long long v355 = 0u;
              long long v356 = 0u;
              long long v353 = 0u;
              long long v354 = 0u;
              long long v351 = 0u;
              long long v352 = 0u;
              long long v349 = 0u;
              long long v350 = 0u;
              long long v347 = 0u;
              long long v348 = 0u;
              long long v345 = 0u;
              long long v346 = 0u;
              long long v343 = 0u;
              long long v344 = 0u;
              long long v341 = 0u;
              long long v342 = 0u;
              long long v339 = 0u;
              long long v340 = 0u;
              long long buf = 0u;
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, (const TrafficDescriptor *)n);
              CFTypeID v177 = *v306;
              if (os_log_type_enabled(*v306, OS_LOG_TYPE_DEFAULT))
              {
                TrafficDescriptor::toString((uint64_t *)__dst, (TrafficDescriptor *)&buf);
                CFArrayRef v178 = __dst;
                if (__dst[23] < 0) {
                  CFArrayRef v178 = *(unsigned char **)__dst;
                }
                *(_DWORD *)v357 = 136315394;
                *(void *)&v357[4] = v16;
                *(_WORD *)&v357[12] = 2082;
                *(void *)&v357[14] = v178;
                _os_log_impl((void *)&_mh_execute_header, v177, OS_LOG_TYPE_DEFAULT, "#N matchAndConvert (%s):(4-no uuids) %{public}s", v357, 0x16u);
                if ((__dst[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__dst);
                }
              }
              __dst[0] = 0;
              __dst[24] = 0;
              sub_100179CB0((uint64_t)&v341, (__n128 *)__dst);
              if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                operator delete(*(void **)__dst);
              }
              __dst[0] = 0;
              __dst[24] = 0;
              sub_100179CB0((uint64_t)&v339, (__n128 *)__dst);
              if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
                operator delete(*(void **)__dst);
              }
              if ((TrafficDescriptor::empty((TrafficDescriptor *)&buf) & 1) == 0)
              {
                LODWORD(__p) = v9;
                *(unsigned char *)(*sub_10003B194(v298, (int *)&__p) + 128) = 1;
                CFArrayRef v179 = v309;
                if ((unint64_t)v309 >= v310)
                {
                  CFArrayRef v180 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v308, (const TrafficDescriptor *)&buf);
                }
                else
                {
                  TrafficDescriptor::TrafficDescriptor(v309, (const TrafficDescriptor *)&buf);
                  CFArrayRef v180 = (TrafficDescriptor *)((char *)v179 + 304);
                }
                v309 = v180;
              }
              goto LABEL_450;
            }
LABEL_364:
            if ((unint64_t)v129 >= v337)
            {
              CFNumberRef v129 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v336, v122);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor(v129, v122);
              CFNumberRef v129 = (TrafficDescriptor *)((char *)v129 + 304);
            }
            *((void *)&v336 + 1) = v129;
            goto LABEL_370;
          }
          unint64_t v135 = (unint64_t *)v328.i64[0];
          if ((unint64_t *)v328.i64[0] == &v328.u64[1]) {
            goto LABEL_299;
          }
          while (1)
          {
            *(_DWORD *)&v357[3] = 0;
            *(_DWORD *)v357 = 0;
            int v136 = *((unsigned __int8 *)v135 + 48);
            if (*((unsigned char *)v135 + 48))
            {
              uint64_t v137 = v135[5];
              unint64_t v138 = v135[5] >> 8;
              char v139 = 1;
            }
            else
            {
              char v139 = 0;
              unint64_t v138 = 0;
              uint64_t v137 = 0;
            }
            long long v355 = 0u;
            long long v356 = 0u;
            long long v353 = 0u;
            long long v354 = 0u;
            long long v351 = 0u;
            long long v352 = 0u;
            long long v349 = 0u;
            long long v350 = 0u;
            long long v347 = 0u;
            long long v348 = 0u;
            long long v345 = 0u;
            long long v346 = 0u;
            long long v343 = 0u;
            long long v344 = 0u;
            long long v341 = 0u;
            long long v342 = 0u;
            long long v339 = 0u;
            long long v340 = 0u;
            long long buf = 0u;
            TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&buf, v122);
            if (*((unsigned char *)v135 + 36)) {
              break;
            }
            if (!*((unsigned char *)v135 + 80))
            {
              if (v136)
              {
                *(void *)long long __dst = v137 | (v138 << 8);
                __dst[8] = v139;
                *(void *)&__dst[9] = 0;
                *(void *)&__dst[16] = 0;
                sub_100B077EC((uint64_t **)&v330, (uint64_t)__dst, (uint64_t)__dst);
              }
              goto LABEL_290;
            }
            sub_100093B44((std::string *)&v341, (const std::string *)(v135 + 7));
            if (v136)
            {
              unint64_t v141 = 0;
              LOBYTE(v14sub_1001A7358((uint64_t)&a9, 0) = 0;
              uint64_t v143 = 0;
LABEL_282:
              *(void *)long long __dst = v137 | (v138 << 8);
              __dst[8] = v139;
              *(_DWORD *)&__dst[9] = *(_DWORD *)v357;
              *(_DWORD *)&__dst[12] = *(_DWORD *)&v357[3];
              *(void *)&__dst[16] = v140 | (v141 << 8) | (v143 << 32);
              sub_100B077EC((uint64_t **)&v330, (uint64_t)__dst, (uint64_t)__dst);
            }
LABEL_283:
            sub_100179AF8((std::string *)&v343, (const std::string *)v122 + 2);
            __dst[0] = 0;
            __dst[24] = 0;
            sub_100179CB0((uint64_t)&v339, (__n128 *)__dst);
            if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
              operator delete(*(void **)__dst);
            }
            BYTE4(buf) = 0;
            BYTE8(buf) = 0;
            v144 = v326;
            if ((unint64_t)v326 >= v327)
            {
              CFArrayRef v145 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v325, (const TrafficDescriptor *)&buf);
              uint64_t v16 = a3;
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor(v326, (const TrafficDescriptor *)&buf);
              uint64_t v16 = a3;
              CFArrayRef v145 = (TrafficDescriptor *)((char *)v144 + 304);
            }
            v326 = v145;
LABEL_290:
            TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&buf);
            CFArrayRef v146 = (unint64_t *)v135[1];
            if (v146)
            {
              do
              {
                CFTypeID v147 = v146;
                CFArrayRef v146 = (unint64_t *)*v146;
              }
              while (v146);
            }
            else
            {
              do
              {
                CFTypeID v147 = (unint64_t *)v135[2];
                BOOL v142 = *v147 == (void)v135;
                unint64_t v135 = v147;
              }
              while (!v142);
            }
            unint64_t v135 = v147;
            uint64_t v9 = v305;
            if (v147 == &v328.u64[1]) {
              goto LABEL_299;
            }
          }
          unint64_t v140 = *((unsigned int *)v135 + 8);
          DWORD1(v352) = *((_DWORD *)v135 + 8);
          BYTE8(v352) = 1;
          if (*((unsigned char *)v135 + 80)) {
            sub_100093B44((std::string *)&v341, (const std::string *)(v135 + 7));
          }
          unint64_t v141 = v140 >> 8;
          if (v136) {
            BOOL v142 = v140 == 0;
          }
          else {
            BOOL v142 = 0;
          }
          uint64_t v143 = !v142;
          if (!v136 && !v140) {
            goto LABEL_283;
          }
          goto LABEL_282;
        }
        if ((v199 & 0x80u) == 0) {
          std::string::size_type v207 = v199;
        }
        else {
          std::string::size_type v207 = size;
        }
        if (!v207)
        {
          v328.i64[1] = 0;
          v329 = 0;
          v328.i64[0] = (uint64_t)&v328.i64[1];
          memset(&__dst[8], 0, 48);
          v357[0] = 0;
          char v358 = 0;
          *(void *)long long __dst = v203;
          __dst[16] = 0;
          sub_1000593FC((uint64_t)&__dst[24], (long long *)v357);
          if (v358 && (char)v357[23] < 0) {
            operator delete(*(void **)v357);
          }
          sub_100B0798C((uint64_t **)&v328, (uint64_t)__dst, (uint64_t)__dst);
          if (__dst[48] && (__dst[47] & 0x80000000) != 0) {
            operator delete(*(void **)&__dst[24]);
          }
          goto LABEL_557;
        }
        unint64_t v294 = v203;
        memset(&v331, 0, sizeof(v331));
        CFNumberRef v208 = (void *)*v290;
        if (*v290)
        {
          v209 = v290;
          do
          {
            unint64_t v210 = v208[4];
            BOOL v211 = v210 >= v205;
            if (v210 >= v205) {
              CFNumberRef v212 = v208;
            }
            else {
              CFNumberRef v212 = v208 + 1;
            }
            if (v211) {
              v209 = v208;
            }
            CFNumberRef v208 = (void *)*v212;
          }
          while (*v212);
          if (v209 != v290 && v209[4] <= v205)
          {
            v213 = (void *)v209[5];
            v214 = v209 + 6;
            if (v213 != v209 + 6)
            {
              std::string::size_type v215 = 0;
              do
              {
                CFNumberRef v216 = (long long *)(v213 + 4);
                if (v215 >= v331.__r_.__value_.__r.__words[2])
                {
                  std::string::size_type v215 = sub_100048008((uint64_t *)&v331, v216);
                }
                else
                {
                  if (*((char *)v213 + 55) < 0)
                  {
                    sub_10004FC84((unsigned char *)v215, (void *)v213[4], v213[5]);
                  }
                  else
                  {
                    long long v217 = *v216;
                    *(void *)(v215 + 16) = v213[6];
                    *(_OWORD *)std::string::size_type v215 = v217;
                  }
                  v215 += 24;
                }
                v331.__r_.__value_.__l.__size_ = v215;
                v218 = (void *)v213[1];
                if (v218)
                {
                  do
                  {
                    CFTypeID v219 = v218;
                    v218 = (void *)*v218;
                  }
                  while (v218);
                }
                else
                {
                  do
                  {
                    CFTypeID v219 = (void *)v213[2];
                    BOOL v142 = *v219 == (void)v213;
                    v213 = v219;
                  }
                  while (!v142);
                }
                v213 = v219;
              }
              while (v219 != v214);
              std::string::size_type v220 = v331.__r_.__value_.__r.__words[0];
              if (v215 != v331.__r_.__value_.__r.__words[0])
              {
                v328.i64[1] = 0;
                v329 = 0;
                v328.i64[0] = (uint64_t)&v328.i64[1];
                do
                {
                  memset(&__dst[16], 0, 40);
                  *(void *)long long __dst = v294;
                  *(void *)&__dst[8] = v205;
                  __dst[16] = 1;
                  if (*(char *)(v220 + 23) < 0)
                  {
                    sub_10004FC84(&__dst[24], *(void **)v220, *(void *)(v220 + 8));
                  }
                  else
                  {
                    long long v221 = *(_OWORD *)v220;
                    *(void *)&__dst[40] = *(void *)(v220 + 16);
                    *(_OWORD *)&__dst[24] = v221;
                  }
                  __dst[48] = 1;
                  sub_100B0798C((uint64_t **)&v328, (uint64_t)__dst, (uint64_t)__dst);
                  if (__dst[48] && (__dst[47] & 0x80000000) != 0) {
                    operator delete(*(void **)&__dst[24]);
                  }
                  v220 += 24;
                }
                while (v220 != v215);
                if (v329)
                {
LABEL_556:
                  *(void *)long long __dst = &v331;
                  sub_100047F64((void ***)__dst);
LABEL_557:
                  char v225 = 0;
                  goto LABEL_559;
                }
                sub_100B07788((char *)v328.i64[1]);
              }
            }
          }
        }
        unint64_t v222 = (void *)v304[624];
        if (v222 == v307)
        {
LABEL_543:
          *(void *)long long __dst = &v331;
          sub_100047F64((void ***)__dst);
          char v225 = 1;
          goto LABEL_559;
        }
        while (v222[5] != v205)
        {
          unint64_t v223 = (void *)v222[1];
          if (v223)
          {
            do
            {
              uint64_t v224 = v223;
              unint64_t v223 = (void *)*v223;
            }
            while (v223);
          }
          else
          {
            do
            {
              uint64_t v224 = (void *)v222[2];
              BOOL v142 = *v224 == (void)v222;
              unint64_t v222 = v224;
            }
            while (!v142);
          }
          unint64_t v222 = v224;
          if (v224 == v307) {
            goto LABEL_543;
          }
        }
        memset(&__dst[16], 0, 40);
        v357[0] = 0;
        char v358 = 0;
        *(void *)long long __dst = v294;
        *(void *)&__dst[8] = v205;
        __dst[16] = 1;
        sub_1000593FC((uint64_t)&__dst[24], (long long *)v357);
        if (v358 && (char)v357[23] < 0) {
          operator delete(*(void **)v357);
        }
        v328.i64[1] = 0;
        v329 = 0;
        v328.i64[0] = (uint64_t)&v328.i64[1];
        sub_100B0798C((uint64_t **)&v328, (uint64_t)__dst, (uint64_t)__dst);
        if (__dst[48] && (__dst[47] & 0x80000000) != 0) {
          operator delete(*(void **)&__dst[24]);
        }
        goto LABEL_556;
      }
LABEL_569:
      unint64_t v227 = v308;
      long long v228 = v309;
      while (1)
      {
        if (v227 == v228)
        {
          *(void *)&long long buf = &v308;
          sub_1008BE774((void ***)&buf);
          goto LABEL_589;
        }
        if (sub_100AF22C0((void *)v4, (uint64_t)v227))
        {
          if (sub_100AF0654((void *)v4, v9, (void **)v227, 1, 1))
          {
            v229 = v318;
            if ((unint64_t)v318 >= v319)
            {
              v230 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v317, v227);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor(v318, v227);
              v230 = (TrafficDescriptor *)((char *)v229 + 304);
            }
            v318 = v230;
            goto LABEL_587;
          }
          os_log_t v235 = *v300;
          if (!os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_587;
          }
          TrafficDescriptor::toString((uint64_t *)&buf, v227);
          v236 = &buf;
          if (SBYTE7(v339) < 0) {
            v236 = (long long *)buf;
          }
          *(_DWORD *)long long __dst = 136446210;
          *(void *)&__dst[4] = v236;
          CFBooleanRef v233 = v235;
          BOOL v234 = "#N slice not allowed: %{public}s";
        }
        else
        {
          os_log_t v231 = *v300;
          if (!os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_587;
          }
          TrafficDescriptor::toString((uint64_t *)&buf, v227);
          CFTypeID v232 = &buf;
          if (SBYTE7(v339) < 0) {
            CFTypeID v232 = (long long *)buf;
          }
          *(_DWORD *)long long __dst = 136446210;
          *(void *)&__dst[4] = v232;
          CFBooleanRef v233 = v231;
          BOOL v234 = "#N traffic descriptor not allowed: %{public}s";
        }
        _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, v234, __dst, 0xCu);
        if (SBYTE7(v339) < 0) {
          operator delete((void *)buf);
        }
LABEL_587:
        unint64_t v227 = (const TrafficDescriptor *)((char *)v227 + 304);
      }
    }
    char v22 = *v300;
    if (os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT))
    {
      if (!*((unsigned char *)v301 + 72)) {
        sub_10016C840();
      }
      if (*((char *)v301 + 71) < 0) {
        char v21 = (void *)*v21;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N we do not allow specific bundle ids in the URSP rules: %s, skipping this definition", (uint8_t *)&buf, 0xCu);
    }
LABEL_590:
    int v20 = (TrafficDescriptor *)((char *)v301 + 304);
    if ((TrafficDescriptor *)((char *)v301 + 304) != v291) {
      continue;
    }
    break;
  }
  v256 = v314;
  v257 = v315;
  if (v314 != v315)
  {
    v258 = v318;
    do
    {
      if ((unint64_t)v258 >= v319)
      {
        v258 = (TrafficDescriptor *)sub_100B05B6C((uint64_t *)&v317, v256);
      }
      else
      {
        TrafficDescriptor::TrafficDescriptor(v258, v256);
        v258 = (TrafficDescriptor *)((char *)v258 + 304);
      }
      v318 = v258;
      v256 = (const TrafficDescriptor *)((char *)v256 + 304);
    }
    while (v256 != v257);
  }
LABEL_653:
  v259 = *v300;
  if (os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v259, OS_LOG_TYPE_DEFAULT, "#I we are setting new cached traffic descriptors", (uint8_t *)&buf, 2u);
  }
  long long buf = 0uLL;
  *(void *)&long long v339 = 0;
  if (*(unsigned char *)(v299 + 1))
  {
    v260 = v317;
    v261 = v318;
    while (v260 != v261)
    {
      if (sub_100AF25B8(v299, (void **)v260))
      {
        uint64_t v262 = *((void *)&buf + 1);
        if (*((void *)&buf + 1) >= (unint64_t)v339)
        {
          uint64_t v263 = sub_100B05B6C((uint64_t *)&buf, v260);
        }
        else
        {
          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), v260);
          uint64_t v263 = v262 + 304;
        }
        *((void *)&buf + 1) = v263;
      }
      v260 = (const TrafficDescriptor *)((char *)v260 + 304);
    }
  }
  if (*(unsigned char *)(v299 + 12) && (*(unsigned char *)(v299 + 13) || *(unsigned char *)(v299 + 14)))
  {
    v264 = v317;
    v265 = v318;
    while (v264 != v265)
    {
      if (!sub_100AF25B8(v299, (void **)v264) && TrafficDescriptor::isXR(v264))
      {
        uint64_t v266 = *((void *)&buf + 1);
        if (*((void *)&buf + 1) >= (unint64_t)v339)
        {
          uint64_t v267 = sub_100B05B6C((uint64_t *)&buf, v264);
        }
        else
        {
          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), v264);
          uint64_t v267 = v266 + 304;
        }
        *((void *)&buf + 1) = v267;
      }
      v264 = (const TrafficDescriptor *)((char *)v264 + 304);
    }
  }
  v268 = v317;
  uint64_t v269 = v318;
  if (v317 != v318)
  {
    do
    {
      if (!sub_100AF25B8(v299, (void **)v268) && TrafficDescriptor::dualXR(v268))
      {
        uint64_t v270 = *((void *)&buf + 1);
        if (*((void *)&buf + 1) >= (unint64_t)v339)
        {
          uint64_t v271 = sub_100B05B6C((uint64_t *)&buf, v268);
        }
        else
        {
          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), v268);
          uint64_t v271 = v270 + 304;
        }
        *((void *)&buf + 1) = v271;
      }
      v268 = (const TrafficDescriptor *)((char *)v268 + 304);
    }
    while (v268 != v269);
    uint64_t v272 = v317;
    v273 = v318;
    while (v272 != v273)
    {
      if (!sub_100AF25B8(v299, (void **)v272) && TrafficDescriptor::notXR(v272))
      {
        uint64_t v274 = *((void *)&buf + 1);
        if (*((void *)&buf + 1) >= (unint64_t)v339)
        {
          uint64_t v275 = sub_100B05B6C((uint64_t *)&buf, v272);
        }
        else
        {
          TrafficDescriptor::TrafficDescriptor(*((TrafficDescriptor **)&buf + 1), v272);
          uint64_t v275 = v274 + 304;
        }
        *((void *)&buf + 1) = v275;
      }
      uint64_t v272 = (const TrafficDescriptor *)((char *)v272 + 304);
    }
  }
  uint64_t v276 = *((void *)&buf + 1);
  if (*((void *)&buf + 1) == (void)buf)
  {
    unint64_t v281 = 0;
LABEL_718:
    uint64_t v284 = v276;
    goto LABEL_719;
  }
  uint64_t v277 = 0;
  unint64_t v278 = 0;
  uint64_t v276 = buf;
  do
  {
    uint64_t v279 = v276 + v277;
    if (*(unsigned char *)(v276 + v277 + 72))
    {
      if ((void **)(v4 + 4816) != sub_100046F68(v4 + 4808, (void **)(v279 + 48)) && *(unsigned char *)(v276 + v277 + 224) == 0)
      {
        LODWORD(__p) = (*(uint64_t (**)(void *))(*v304 + 1088))(v304);
        if (*(unsigned char *)(*sub_10003B194(v298, (int *)&__p) + 17))
        {
          if (!*(unsigned char *)(v279 + 72)) {
            sub_10016C840();
          }
          __dst[0] = 0;
          if ((char *)sub_10004DCA4((const char **)&off_101A3A000, (const char **)&unk_101A3A008, (const void **)(v279 + 48))- (char *)&off_101A3A000 == 8)*(_WORD *)(v276 + v277 + 146) = 257; {
        }
          }
      }
    }
    uint64_t v276 = buf;
    *(_DWORD *)(buf + v277) = v278++;
    unint64_t v281 = 0x86BCA1AF286BCA1BLL * ((*((void *)&buf + 1) - v276) >> 4);
    v277 += 304;
  }
  while (v278 < v281);
  if (*((void *)&buf + 1) == v276) {
    goto LABEL_718;
  }
  uint64_t v282 = 0;
  unint64_t v283 = 0;
  uint64_t v284 = v276;
  uint64_t v276 = *((void *)&buf + 1);
  do
  {
    v285 = *v300;
    if (os_log_type_enabled(*v300, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)__dst, (TrafficDescriptor *)(v284 + v282));
      if (__dst[23] >= 0) {
        v286 = __dst;
      }
      else {
        v286 = *(unsigned char **)__dst;
      }
      *(_DWORD *)v357 = 67109378;
      *(_DWORD *)&v357[4] = v283;
      *(_WORD *)&v357[8] = 2080;
      *(void *)&v357[10] = v286;
      _os_log_impl((void *)&_mh_execute_header, v285, OS_LOG_TYPE_DEFAULT, "#I tds: ret[%d] = %s", v357, 0x12u);
      if ((__dst[23] & 0x80000000) != 0) {
        operator delete(*(void **)__dst);
      }
      uint64_t v276 = *((void *)&buf + 1);
      uint64_t v284 = buf;
    }
    ++v283;
    unint64_t v281 = 0x86BCA1AF286BCA1BLL * ((v276 - v284) >> 4);
    v282 += 304;
  }
  while (v283 < v281);
LABEL_719:
  int v7 = (void *)(v299 + 56);
  if ((long long *)(v299 + 56) != &buf) {
    sub_100B06144(v299 + 56, v284, v276, v281);
  }
  *(void *)long long __dst = &buf;
  sub_1008BE774((void ***)__dst);
  *(void *)&long long buf = &v314;
  sub_1008BE774((void ***)&buf);
  *(void *)&long long buf = &v317;
  sub_1008BE774((void ***)&buf);
  *(void *)&long long buf = &v320;
  sub_1008BE774((void ***)&buf);
  char v6 = v323;
  if (v323) {
    goto LABEL_13;
  }
  return v7;
}

void sub_100AEF500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  __cxa_guard_abort(&qword_101B0FD68);
  STACK[0x2C0] = (unint64_t)&STACK[0x220];
  sub_100B05F98((void ***)&STACK[0x2C0]);
  *(void *)(v72 - 192) = &a59;
  sub_1008BE774((void ***)(v72 - 192));
  *(void *)(v72 - 192) = &a62;
  sub_1008BE774((void ***)(v72 - 192));
  *(void *)(v72 - 192) = &a65;
  sub_1008BE774((void ***)(v72 - 192));
  *(void *)(v72 - 192) = &a68;
  sub_1008BE774((void ***)(v72 - 192));
  if (__p)
  {
    a72 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100AEFAAC(void *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)a1[624];
  char v6 = a1 + 625;
  if (v5 == a1 + 625) {
    goto LABEL_30;
  }
  do
  {
    int v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = v5 + 9;
      if (*((char *)v5 + 95) < 0) {
        uint64_t v8 = (void *)*v8;
      }
      uint64_t v9 = v5 + 12;
      if (*((char *)v5 + 119) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      uint64_t v10 = v5 + 6;
      if (*((char *)v5 + 71) < 0) {
        uint64_t v10 = (void *)*v10;
      }
      int v11 = *((_DWORD *)v5 + 8);
      uint64_t v12 = v5[5];
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v8;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v9;
      __int16 v28 = 2080;
      int v29 = v10;
      __int16 v30 = 2048;
      uint64_t v31 = v12;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Front policies adding (test): pid=%d bundleId=%s uuid=%s procName=%s category=%lu", buf, 0x30u);
    }
    long long v24 = 0uLL;
    uint64_t v25 = 0;
    if (*((char *)v5 + 95) < 0)
    {
      if (!v5[10]) {
        goto LABEL_24;
      }
LABEL_14:
      sub_100AF005C((uint64_t *)buf, (uint64_t)a1, a2, (std::string *)v5 + 3, 1);
      sub_1008BE714((void **)&v24);
      long long v24 = *(_OWORD *)buf;
      uint64_t v13 = *(void *)&buf[16];
      memset(buf, 0, 24);
      uint64_t v25 = v13;
      uint64_t v26 = (void **)buf;
      sub_1008BE774(&v26);
      uint64_t v14 = *((void *)&v24 + 1);
      uint64_t v15 = v24;
      if ((void)v24 == *((void *)&v24 + 1)) {
        goto LABEL_24;
      }
      while (1)
      {
        buf[0] = 0;
        unsigned char buf[24] = 0;
        __n128 v16 = sub_100179CB0(v15 + 240, (__n128 *)buf);
        if (buf[24] && (buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if ((*((char *)v5 + 119) & 0x80000000) == 0) {
          break;
        }
        if (v5[13]) {
          goto LABEL_22;
        }
LABEL_23:
        *(_DWORD *)(v15 + 4) = *((_DWORD *)v5 + 8);
        *(unsigned char *)(v15 + 8) = 1;
        (*(void (**)(void *, uint64_t, __n128))(*a1 + 2216))(a1, v15, v16);
        v15 += 304;
        if (v15 == v14) {
          goto LABEL_24;
        }
      }
      if (!*((unsigned char *)v5 + 119)) {
        goto LABEL_23;
      }
LABEL_22:
      sub_100093B44((std::string *)(v15 + 16), (const std::string *)v5 + 4);
      goto LABEL_23;
    }
    if (*((unsigned char *)v5 + 95)) {
      goto LABEL_14;
    }
LABEL_24:
    *(void *)long long buf = &v24;
    sub_1008BE774((void ***)buf);
    uint64_t v17 = (void *)v5[1];
    if (v17)
    {
      do
      {
        int v18 = v17;
        uint64_t v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        int v18 = (void *)v5[2];
        BOOL v19 = *v18 == (void)v5;
        uint64_t v5 = v18;
      }
      while (!v19);
    }
    uint64_t v5 = v18;
  }
  while (v18 != v6);
LABEL_30:
  *(_DWORD *)long long buf = a2;
  if (*(void *)(*sub_10003B194((uint64_t)(a1 + 577), (int *)buf) + 120)) {
    BOOL v19 = a3[2] == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    int v20 = (void *)*a3;
    if ((void *)*a3 != a3 + 1)
    {
      do
      {
        sub_100AF0384(a1, a2, (std::string *)(v20 + 4));
        char v21 = (void *)v20[1];
        if (v21)
        {
          do
          {
            char v22 = v21;
            char v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            char v22 = (void *)v20[2];
            BOOL v19 = *v22 == (void)v20;
            int v20 = v22;
          }
          while (!v19);
        }
        int v20 = v22;
      }
      while (v22 != a3 + 1);
    }
  }
}

void sub_100AEFDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

uint64_t sub_100AEFE0C(uint64_t a1)
{
  return a1;
}

void non-virtual thunk to'DataServiceController::resetSlicePolicies_sync(uint64_t a1, int a2, char a3, char a4)
{
}

uint64_t sub_100AEFE40(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 == v3) {
LABEL_7:
  }
    __assert_rtn("at", "PerPersonalityDataContainer.h", 67, "0");
  while (1)
  {
    uint64_t v6 = *(void *)(v2 + 416);
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 424);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      int v7 = *(_DWORD *)(v6 + 52);
      sub_10004D2C8(v5);
    }
    else
    {
      int v7 = *(_DWORD *)(v6 + 52);
    }
    if (v7 == a2) {
      return v2;
    }
    v2 += 432;
    if (v2 == v3) {
      goto LABEL_7;
    }
  }
}

uint64_t DataServiceController::isNrSliceConfigured_sync(void *a1, uint64_t a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[14];
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (v9) {
    sub_10004D2C8(v9);
  }
  if ((isValidSimSlot & 1) == 0 || (*(unsigned int (**)(void *))(*a1 + 1088))(a1) != a2) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 2192))(a1);
  if (result)
  {
    int v7 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
    char v8 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 1040))(a1, a2);
    return DataServiceController::SlicesDataContainer::configured((uint64_t)(a1 + 577), a2, v7, v8);
  }
  return result;
}

void sub_100AF003C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'DataServiceController::isNrSliceConfigured_sync(uint64_t a1, uint64_t a2)
{
  return DataServiceController::isNrSliceConfigured_sync((void *)(a1 - 80), a2);
}

void sub_100AF005C(uint64_t *a1, uint64_t a2, int a3, std::string *a4, int a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  BOOL v10 = sub_100AF092C(a2, a3, (void **)&a4->__r_.__value_.__l.__data_);
  int v11 = (uint64_t *)sub_100AEC4B4(a2, a3, (uint64_t)"bundle id");
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (*v11 != v13)
  {
    do
    {
      if (((TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)v12) ^ 1 | v10) & 1) != 0
        && (TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)v12) | !v10) == 1)
      {
        if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v12))
        {
          if (a5 && (TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)v12) & 1) == 0)
          {
            long long v43 = 0u;
            long long v44 = 0u;
            long long v41 = 0u;
            long long v42 = 0u;
            long long v39 = 0u;
            long long v40 = 0u;
            long long v37 = 0u;
            long long v38 = 0u;
            long long v35 = 0u;
            long long v36 = 0u;
            long long v33 = 0u;
            long long v34 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            long long v29 = 0u;
            long long v30 = 0u;
            long long v27 = 0u;
            long long v28 = 0u;
            long long v26 = 0u;
            TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v26, (const TrafficDescriptor *)v12);
            sub_100093B44((std::string *)&v29, a4);
            unint64_t v20 = a1[1];
            if (v20 >= a1[2])
            {
              uint64_t v21 = sub_100B05B6C(a1, (const TrafficDescriptor *)&v26);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)a1[1], (const TrafficDescriptor *)&v26);
              uint64_t v21 = v20 + 304;
              a1[1] = v20 + 304;
            }
            a1[1] = v21;
            TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v26);
          }
          goto LABEL_32;
        }
        if (!*(unsigned char *)(v12 + 72)) {
          sub_10016C840();
        }
        uint64_t v14 = *(unsigned __int8 *)(v12 + 71);
        if ((v14 & 0x80u) == 0) {
          uint64_t v15 = *(unsigned __int8 *)(v12 + 71);
        }
        else {
          uint64_t v15 = *(void *)(v12 + 56);
        }
        std::string::size_type size = HIBYTE(a4->__r_.__value_.__r.__words[2]);
        int v17 = (char)size;
        if ((size & 0x80u) != 0) {
          std::string::size_type size = a4->__r_.__value_.__l.__size_;
        }
        if (v15 == size)
        {
          if (v17 >= 0) {
            int v18 = a4;
          }
          else {
            int v18 = (std::string *)a4->__r_.__value_.__r.__words[0];
          }
          if ((v14 & 0x80) == 0)
          {
            if (*(unsigned char *)(v12 + 71))
            {
              uint64_t v19 = 0;
              while (*(unsigned __int8 *)(v12 + v19 + 48) == v18->__r_.__value_.__s.__data_[v19])
              {
                if (v14 == ++v19) {
                  goto LABEL_26;
                }
              }
              goto LABEL_32;
            }
LABEL_26:
            unint64_t v22 = a1[1];
            if (v22 >= a1[2])
            {
              uint64_t v23 = sub_100B05B6C(a1, (const TrafficDescriptor *)v12);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)a1[1], (const TrafficDescriptor *)v12);
              uint64_t v23 = v22 + 304;
              a1[1] = v22 + 304;
            }
            a1[1] = v23;
            goto LABEL_32;
          }
          if (!memcmp(*(const void **)(v12 + 48), v18, *(void *)(v12 + 56))) {
            goto LABEL_26;
          }
        }
      }
LABEL_32:
      v12 += 304;
    }
    while (v12 != v13);
  }
  if (v10 && *v11 == v11[1])
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v26 = 0u;
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v26);
    sub_100093B44((std::string *)&v29, a4);
    unint64_t v24 = a1[1];
    if (v24 >= a1[2])
    {
      uint64_t v25 = sub_100B05B6C(a1, (const TrafficDescriptor *)&v26);
    }
    else
    {
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)a1[1], (const TrafficDescriptor *)&v26);
      uint64_t v25 = v24 + 304;
      a1[1] = v24 + 304;
    }
    a1[1] = v25;
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v26);
  }
}

void sub_100AF0320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  *(void *)(v9 + 8) = v10;
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&a9);
  a9 = v9;
  sub_1008BE774((void ***)&a9);
  _Unwind_Resume(a1);
}

void sub_100AF0384(void *a1, uint64_t a2, std::string *a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v7 = a3;
    }
    else {
      int v7 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Front policies adding: %s", buf, 0xCu);
  }
  __n128 v16 = 0;
  int v17 = 0;
  uint64_t v18 = 0;
  sub_100AF005C((uint64_t *)&v16, (uint64_t)a1, a2, a3, 0);
  char v8 = v16;
  for (i = v17; v8 != i; char v8 = (const TrafficDescriptor *)((char *)v8 + 304))
  {
    buf[0] = 0;
    v20[0].__r_.__value_.__s.__data_[8] = 0;
    sub_100179CB0((uint64_t)v8 + 240, (__n128 *)buf);
    if (v20[0].__r_.__value_.__s.__data_[8] && v20[0].__r_.__value_.__s.__data_[7] < 0) {
      operator delete(*(void **)buf);
    }
    if (sub_100AF0654(a1, a2, (void **)v8, 0, 0))
    {
      if (*((unsigned char *)v8 + 40))
      {
        (*(void (**)(void *, const TrafficDescriptor *))(*a1 + 2216))(a1, v8);
      }
      else
      {
        memset(v20, 0, sizeof(v20));
        *(_OWORD *)long long buf = 0u;
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)buf, v8);
        uint64_t v10 = sub_100AF086C((uint64_t)a1, (void **)&a3->__r_.__value_.__l.__data_);
        int v11 = v10 + 1;
        uint64_t v12 = (void *)*v10;
        if ((uint64_t *)*v10 != v10 + 1)
        {
          do
          {
            sub_100093B44(v20, (const std::string *)(v12 + 4));
            (*(void (**)(void *, uint8_t *))(*a1 + 2216))(a1, buf);
            uint64_t v13 = (uint64_t *)v12[1];
            if (v13)
            {
              do
              {
                uint64_t v14 = v13;
                uint64_t v13 = (uint64_t *)*v13;
              }
              while (v13);
            }
            else
            {
              do
              {
                uint64_t v14 = (uint64_t *)v12[2];
                BOOL v15 = *v14 == (void)v12;
                uint64_t v12 = v14;
              }
              while (!v15);
            }
            uint64_t v12 = v14;
          }
          while (v14 != v11);
        }
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)buf);
      }
    }
  }
  *(void *)long long buf = &v16;
  sub_1008BE774((void ***)buf);
}

void sub_100AF0608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t sub_100AF0654(void *a1, uint64_t a2, void **this, uint64_t a4, char a5)
{
  if (TrafficDescriptor::empty((TrafficDescriptor *)this)) {
    return 0;
  }
  uint64_t v10 = a1[14];
  *(void *)&long long v16 = a1[13];
  *((void *)&v16 + 1) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (*((void *)&v16 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
  }
  if ((isValidSimSlot & 1) == 0)
  {
    uint64_t v14 = a1[5];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v16) = 136315138;
      *(void *)((char *)&v16 + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "DataServiceController::sliceAllowed() called with invalid SimSlot parameter: %s", (uint8_t *)&v16, 0xCu);
    }
    return 0;
  }
  int v12 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
  char v13 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 1040))(a1, a2);
  if (!DataServiceController::SlicesDataContainer::configured((uint64_t)(a1 + 577), a2, v12, v13)) {
    return 0;
  }
  if ((sub_100AEAD30((uint64_t)a1, (TrafficDescriptor *)this) & 1) == 0)
  {
    if (TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)this))
    {
      if (a5) {
        return 1;
      }
    }
    else
    {
      if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)this)) {
        return a4;
      }
      if (!*((unsigned char *)this + 72)) {
        sub_10016C840();
      }
      if (DataServiceController::isAllowedApp(a1, a2, this + 6)) {
        return 1;
      }
    }
    return 0;
  }
  return 1;
}

void sub_100AF084C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100AF086C(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_100046F68(a1 + 4640, a2);
  if ((void **)(a1 + 4648) != v3 && *((unsigned char *)v3 + 112)) {
    return (uint64_t *)(v3 + 11);
  }
  uint64_t result = &qword_101B0FE50;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD70, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101B0FD70))
    {
      qword_101B0FE60 = 0;
      qword_101B0FE58 = 0;
      qword_101B0FE50 = (uint64_t)&qword_101B0FE58;
      __cxa_atexit((void (*)(void *))sub_100AEFE0C, &qword_101B0FE50, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0FD70);
    }
    return &qword_101B0FE50;
  }
  return result;
}

BOOL sub_100AF092C(uint64_t a1, int a2, void **a3)
{
  int v9 = a2;
  uint64_t v6 = sub_10003B194(a1 + 4616, &v9);
  if (!*(unsigned char *)(*v6 + 1)) {
    return 0;
  }
  uint64_t v7 = *v6;
  return (void **)(v7 + 144) != sub_100046F68(v7 + 136, a3) && sub_100AF97D0(a1, a2, 0xFFFFFFFFFFFFFFFFLL);
}

TrafficDescriptor *sub_100AF09B4(uint64_t *a1, uint64_t a2, const TrafficDescriptor *a3)
{
  uint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  uint64_t v7 = a2 - *a1;
  uint64_t v8 = v7 / 304;
  uint64_t v9 = *a1 + 304 * (v7 / 304);
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v10 = a1[2];
  if (v6 >= v10)
  {
    unint64_t v15 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v6 - v5) >> 4) + 1;
    if (v15 > 0xD79435E50D7943) {
      sub_10006A748();
    }
    unint64_t v17 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v10 - v5) >> 4);
    if (2 * v17 > v15) {
      unint64_t v15 = 2 * v17;
    }
    if (v17 >= 0x6BCA1AF286BCA1) {
      unint64_t v18 = 0xD79435E50D7943;
    }
    else {
      unint64_t v18 = v15;
    }
    long long v44 = a1 + 2;
    if (v18) {
      uint64_t v19 = (char *)sub_100B05D04((uint64_t)(a1 + 2), v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v21 = (TrafficDescriptor *)&v19[304 * v8];
    long long v41 = v19;
    *(void *)&long long v42 = v21;
    *((void *)&v42 + 1) = v21;
    long long v43 = &v19[304 * v18];
    if (v8 == v18)
    {
      if (v7 < 1)
      {
        if (v5 == a2) {
          unint64_t v24 = 1;
        }
        else {
          unint64_t v24 = 2 * v8;
        }
        uint64_t v48 = v11;
        uint64_t v25 = (char *)sub_100B05D04(v11, v24);
        long long v26 = (TrafficDescriptor *)&v25[304 * (v24 >> 2)];
        int v45 = v25;
        v46.i64[0] = (uint64_t)v26;
        long long v28 = &v25[304 * v27];
        v46.i64[1] = (uint64_t)v26;
        unint64_t v47 = v28;
        uint64_t v29 = v42;
        if (*((void *)&v42 + 1) == (void)v42)
        {
          int64x2_t v33 = vdupq_n_s64(v42);
          long long v31 = v26;
        }
        else
        {
          uint64_t v30 = (*((void *)&v42 + 1) - (void)v42) / 304;
          long long v31 = (TrafficDescriptor *)((char *)v26 + 304 * v30);
          uint64_t v32 = 304 * v30;
          do
          {
            TrafficDescriptor::TrafficDescriptor();
            long long v26 = (TrafficDescriptor *)((char *)v26 + 304);
            v29 += 304;
            v32 -= 304;
          }
          while (v32);
          uint64_t v25 = v45;
          long long v26 = (TrafficDescriptor *)v46.i64[0];
          int64x2_t v33 = (int64x2_t)v42;
          long long v28 = v47;
        }
        long long v34 = v43;
        int v45 = v41;
        long long v41 = v25;
        *(void *)&long long v42 = v26;
        int64x2_t v46 = v33;
        *((void *)&v42 + 1) = v31;
        long long v43 = v28;
        unint64_t v47 = v34;
        sub_100B05DE4((uint64_t)&v45);
        uint64_t v21 = v31;
      }
      else
      {
        uint64_t v22 = v8 + 2;
        if (v8 >= -1) {
          uint64_t v22 = v8 + 1;
        }
        uint64_t v21 = (TrafficDescriptor *)((char *)v21 - 304 * (v22 >> 1));
        *(void *)&long long v42 = v21;
        *((void *)&v42 + 1) = v21;
      }
    }
    TrafficDescriptor::TrafficDescriptor(v21, a3);
    *((void *)&v42 + 1) += 304;
    sub_100B05D50(v11, v9, v9, *a1, *a1, v42, v42);
    *(void *)&long long v42 = v35;
    uint64_t v36 = a1[1];
    uint64_t v37 = *((void *)&v42 + 1);
    if (v36 != v9)
    {
      uint64_t v38 = 0;
      do
      {
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(*((void *)&v42 + 1) + v38), (const TrafficDescriptor *)(v9 + v38));
        v38 += 304;
      }
      while (v9 + v38 != v36);
      uint64_t v35 = v42;
      uint64_t v9 = a1[1];
      uint64_t v37 = *((void *)&v42 + 1) + v38;
    }
    uint64_t v39 = *a1;
    *a1 = v35;
    a1[1] = v37;
    uint64_t v40 = a1[2];
    a1[2] = (uint64_t)v43;
    *((void *)&v42 + 1) = v9;
    long long v43 = (char *)v40;
    long long v41 = (char *)v39;
    *(void *)&long long v42 = v39;
    return (TrafficDescriptor *)sub_100B05DE4((uint64_t)&v41);
  }
  else if (v9 == v6)
  {
    uint64_t result = TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(*a1 + 304 * (v7 / 304)), a3);
    a1[1] = v9 + 304;
  }
  else
  {
    unint64_t v12 = v6 - 304;
    if (v6 < 0x130)
    {
      uint64_t v14 = a1[1];
    }
    else
    {
      unint64_t v13 = v6 - 304;
      uint64_t v14 = a1[1];
      do
      {
        TrafficDescriptor::TrafficDescriptor();
        v13 += 304;
        v14 += 304;
      }
      while (v13 < v6);
    }
    a1[1] = v14;
    if (v6 != v9 + 304)
    {
      uint64_t v23 = 16 * ((uint64_t)(v6 - (v9 + 304)) >> 4);
      do
      {
        TrafficDescriptor::operator=();
        v12 -= 304;
        v23 -= 304;
      }
      while (v23);
    }
    return (TrafficDescriptor *)TrafficDescriptor::operator=();
  }
  return result;
}

void sub_100AF0D6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16)
{
  *(void *)(v16 + 8) = v17;
  _Unwind_Resume(exception_object);
}

unint64_t sub_100AF0DCC(char *a1)
{
  if (a1[23] < 0)
  {
    uint64_t v1 = *((void *)a1 + 1);
    if (!v1) {
      goto LABEL_8;
    }
    a1 = *(char **)a1;
  }
  else if (!a1[23])
  {
    uint64_t v1 = 0;
LABEL_8:
    unint64_t v4 = 0;
    unint64_t v3 = 0;
    return v4 | v1 | v3;
  }
  unsigned int v2 = *a1 - 49;
  if (v2 > 7) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = dword_10153E3D0[v2] | (unint64_t)&_mh_execute_header;
  }
  unint64_t v4 = v3 & (unint64_t)&_mh_execute_header;
  uint64_t v1 = v3 & 0xFFFFFF00;
  unint64_t v3 = v3;
  return v4 | v1 | v3;
}

void DataServiceController::sliceTrafficDescriptorsForPolicies_sync(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  sub_100AEB680(&v21, a1, a2);
  uint64_t v5 = v22;
  std::string __p = v21;
  if (v21 != v22)
  {
    unint64_t v6 = v21;
    do
    {
      uint64_t v7 = *v6;
      uint64_t v8 = (uint64_t *)sub_100AEC4B4(a1, *v6, (uint64_t)"policies");
      unint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      sub_100B05E34(&v18, *v8, v8[1], 0x86BCA1AF286BCA1BLL * ((v8[1] - *v8) >> 4));
      v29[0] = off_101A3A128;
      v29[1] = a1;
      void v29[2] = v7;
      uint64_t v30 = v29;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      long long v26 = &v27;
      if (v19 != v18)
      {
        uint64_t v9 = (v19 - v18) / 304;
        unint64_t v10 = v9 - 1;
        uint64_t v11 = 304 * v9 - 304;
        do
        {
          if (0x86BCA1AF286BCA1BLL * ((v19 - v18) >> 4) <= v10) {
            sub_10015B728();
          }
          uint64_t v12 = v28;
          v24[0] = 0;
          v24[1] = 0;
          uint64_t v25 = 0;
          TrafficDescriptor::toKey((uint64_t *)v24, (const TrafficDescriptor *)((char *)v18 + v11));
          sub_100046BAC((uint64_t **)&v26, v24, (uint64_t)v24);
          if (v28 == v12)
          {
            TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v23);
            TrafficDescriptor::operator=();
            TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v23);
          }
          if (SHIBYTE(v25) < 0) {
            operator delete(v24[0]);
          }
          --v10;
          v11 -= 304;
        }
        while (v10 != -1);
        unint64_t v13 = v18;
        uint64_t v14 = v19;
        while (v13 != v14)
        {
          if ((TrafficDescriptor::empty(v13) & 1) == 0)
          {
            if (!v30) {
              sub_10007B600();
            }
            if ((*(unsigned int (**)(void *, const TrafficDescriptor *))(*v30 + 48))(v30, v13))
            {
              unint64_t v15 = a3[1];
              if (v15 >= a3[2])
              {
                uint64_t v16 = sub_100B05B6C(a3, v13);
              }
              else
              {
                TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)a3[1], v13);
                uint64_t v16 = v15 + 304;
                a3[1] = v15 + 304;
              }
              a3[1] = v16;
            }
          }
          unint64_t v13 = (const TrafficDescriptor *)((char *)v13 + 304);
        }
      }
      sub_10005CD2C((uint64_t)&v26, v27);
      sub_100B07C94(v29);
      v23[0] = (void **)&v18;
      sub_1008BE774(v23);
      ++v6;
    }
    while (v6 != v5);
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_100AF10F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

void non-virtual thunk to'DataServiceController::sliceTrafficDescriptorsForPolicies_sync(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
}

BOOL DataServiceController::allowSocketAPIWithTrafficClasses(uint64_t a1, int a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1088))(a1) != a2) {
    return 0;
  }
  int v5 = a2;
  return *(unsigned char *)(*sub_10003B194(a1 + 4616, &v5) + 24) != 0;
}

BOOL non-virtual thunk to'DataServiceController::allowSocketAPIWithTrafficClasses(uint64_t a1, int a2)
{
  return DataServiceController::allowSocketAPIWithTrafficClasses(a1 - 96, a2);
}

uint64_t DataServiceController::sliceInactivityTimeoutSecs(uint64_t a1, int a2, char a3)
{
  if (a3) {
    return 5;
  }
  unint64_t v6 = *(std::__shared_weak_count **)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 104);
  uint64_t v9 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!isValidSimSlot) {
    return 30;
  }
  LODWORD(v8) = a2;
  return *(unsigned int *)(*sub_10003B194(a1 + 4616, (int *)&v8) + 8);
}

void sub_100AF12CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'DataServiceController::sliceInactivityTimeoutSecs(uint64_t a1, int a2, char a3)
{
  return DataServiceController::sliceInactivityTimeoutSecs(a1 - 96, a2, a3);
}

BOOL DataServiceController::supportsLLPHS(uint64_t a1, int a2)
{
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 104);
  unint64_t v10 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (!isValidSimSlot) {
    return 0;
  }
  LODWORD(v9) = a2;
  unint64_t v6 = sub_10003B194(a1 + 4616, (int *)&v9);
  uint64_t v7 = *v6;
  if (!*(unsigned char *)(*v6 + 12)) {
    return 0;
  }
  if (*(unsigned char *)(v7 + 13)) {
    return 1;
  }
  return *(unsigned char *)(v7 + 14) != 0;
}

void sub_100AF139C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL non-virtual thunk to'DataServiceController::supportsLLPHS(uint64_t a1, int a2)
{
  return DataServiceController::supportsLLPHS(a1 - 96, a2);
}

uint64_t sub_100AF13BC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v32 = 0;
  int64x2_t v33 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 104));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 8))(&v32, v14, a2);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (!v32) {
    goto LABEL_33;
  }
  uint64_t v16 = sub_100046F68(a1 + 1048, (void **)(v32 + 24));
  if ((void **)(a1 + 1056) == v16) {
    goto LABEL_33;
  }
  if ((*((unsigned char *)v16 + 58) & 0x10) == 0)
  {
    uint64_t v17 = *v4;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I entitledLLPHS not supported, assume allowed", buf, 2u);
    }
    LOBYTE(v18) = 1;
    goto LABEL_35;
  }
  uint64_t v21 = (char *)v16[9];
  uint64_t v19 = v16 + 9;
  uint64_t v20 = v21;
  if (!v21) {
    goto LABEL_30;
  }
  uint64_t v22 = v19;
  do
  {
    int v23 = *((_DWORD *)v20 + 7);
    BOOL v24 = v23 < 20;
    if (v23 >= 20) {
      uint64_t v25 = (void **)v20;
    }
    else {
      uint64_t v25 = (void **)(v20 + 8);
    }
    if (!v24) {
      uint64_t v22 = (void **)v20;
    }
    uint64_t v20 = (char *)*v25;
  }
  while (*v25);
  if (v22 == v19 || *((int *)v22 + 7) > 20)
  {
LABEL_30:
    uint64_t v28 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v29 = "#I entitledLLPHS: Hera not found";
    goto LABEL_32;
  }
  unsigned int v26 = *((_DWORD *)v22 + 8);
  if (v26 - 5 <= 0xFFFFFFFD)
  {
    unsigned int v18 = (v26 > 6) | (0x1Du >> v26);
    uint64_t v27 = *v4;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v18 & 1;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I entitledLLPHS: uint64_t result = %{BOOL}d", buf, 8u);
    }
    goto LABEL_35;
  }
  uint64_t v28 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v29 = "#N entitledLLPHS: unknown state";
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 2u);
  }
LABEL_33:
  uint64_t v30 = *v4;
  LOBYTE(v18) = 0;
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I entitledLLPHS could not calculate, assume not allowed", buf, 2u);
    LOBYTE(v18) = 0;
  }
LABEL_35:
  if (v33) {
    sub_10004D2C8(v33);
  }
  return v18 & 1;
}

void sub_100AF1708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::updateSlicingStateOnEntitlementsChange_sync(DataServiceController *this)
{
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 14);
  *(void *)long long buf = *((void *)this + 13);
  char v15 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v15) {
    sub_10004D2C8(v15);
  }
  unint64_t v3 = v11;
  if (v11 != v12)
  {
    while ((v13(*v3) & 1) == 0)
    {
      if (++v3 == v12)
      {
        unint64_t v3 = v12;
        break;
      }
    }
    while (v3 != v12)
    {
      uint64_t v4 = *v3;
      int v5 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 6) + 16))(*((void *)this + 6), v4);
      *(_DWORD *)long long buf = v4;
      unint64_t v6 = (unsigned char *)*sub_10003B194((uint64_t)this + 4616, (int *)buf);
      int v7 = sub_100AF13BC((uint64_t)this, v4);
      if (v6[13] != v7)
      {
        uint64_t v8 = *v5;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I entitledLLPHS: new value: %{BOOL}d", buf, 8u);
        }
        if (v6[12]) {
          BOOL v9 = v6[14] == 0;
        }
        else {
          BOOL v9 = 0;
        }
        if (v9)
        {
          sub_100058DB0(buf, "entitlements update");
          (*(void (**)(DataServiceController *, uint64_t, uint8_t *, void))(*(void *)this + 2328))(this, v4, buf, 0);
          if (v16 < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          v6[13] = v7;
        }
      }
      uint64_t v10 = v3 + 1;
      unint64_t v3 = v12;
      if (v10 != v12)
      {
        unint64_t v3 = v10;
        while ((v13(*v3) & 1) == 0)
        {
          if (++v3 == v12)
          {
            unint64_t v3 = v12;
            break;
          }
        }
      }
    }
  }
}

void sub_100AF1990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::setStatisticsData(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  uint64_t v4 = a1 + 4616;
  *(unsigned char *)(a4 + 104) = *(unsigned char *)(a1 + 4920);
  int v5 = a3 + 1;
  unint64_t v6 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    uint64_t v8 = a1;
    BOOL v9 = (char *)(a4 + 112);
    unint64_t v47 = (void **)(a4 + 56);
    uint64_t v48 = a3 + 1;
    uint64_t v51 = (std::string *)(a4 + 32);
    uint64_t v52 = a4 + 136;
    uint64_t v50 = (std::string *)(a4 + 80);
    do
    {
      if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v6 + 4)))
      {
        if (!*((unsigned char *)v6 + 104)) {
          goto LABEL_121;
        }
        uint64_t v10 = v6 + 10;
        uint64_t v11 = *((unsigned __int8 *)v6 + 103);
        int v12 = (char)v11;
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = v6[11];
        }
        if (v11 == 15)
        {
          if (v12 < 0) {
            uint64_t v10 = (void *)*v10;
          }
          uint64_t v21 = (void *)*v10;
          uint64_t v22 = *(void *)((char *)v10 + 7);
          if (v21 != (void *)0x6C7070612E6D6F63 || v22 != 0x64656D61672E656CLL) {
            goto LABEL_20;
          }
        }
        else
        {
          if (v11 != 18) {
            goto LABEL_20;
          }
          if (v12 < 0) {
            uint64_t v10 = (void *)*v10;
          }
          unint64_t v13 = (void *)*v10;
          uint64_t v14 = v10[1];
          int v15 = *((unsigned __int16 *)v10 + 8);
          BOOL v16 = v13 == (void *)0x6C7070612E6D6F63 && v14 == 0x6974656361662E65;
          if (!v16 || v15 != 25965) {
            goto LABEL_20;
          }
        }
        *(unsigned char *)(a4 + 105) = 1;
      }
LABEL_20:
      uint64_t v18 = *(unsigned __int8 *)(a4 + 23);
      if ((v18 & 0x80u) != 0) {
        uint64_t v18 = *(void *)(a4 + 8);
      }
      if (!v18 && (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v6 + 4)) & 1) == 0 && *((unsigned char *)v6 + 72))
      {
        (*(void (**)(std::string *__return_ptr, uint64_t, void *))(*(void *)v8 + 2272))(&__s, v8, v6 + 6);
        if (*(char *)(a4 + 23) < 0) {
          operator delete(*(void **)a4);
        }
        *(std::string *)a4 = __s;
      }
      uint64_t v19 = *(unsigned __int8 *)(a4 + 135);
      if ((v19 & 0x80u) != 0) {
        uint64_t v19 = *(void *)(a4 + 120);
      }
      if (!v19 && TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)(v6 + 4)))
      {
        if (*(char *)(a4 + 135) < 0)
        {
          *(void *)(a4 + 12sub_1001A7358((uint64_t)&a9, 0) = 5;
          uint64_t v20 = *(char **)(a4 + 112);
        }
        else
        {
          *(unsigned char *)(a4 + 135) = 5;
          uint64_t v20 = v9;
        }
        strcpy(v20, "llphs");
      }
      uint64_t v24 = *(unsigned __int8 *)(a4 + 23);
      if ((v24 & 0x80u) != 0) {
        uint64_t v24 = *(void *)(a4 + 8);
      }
      if (!v24 && TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v6 + 4)))
      {
        if (!*((unsigned char *)v6 + 104)) {
LABEL_121:
        }
          sub_10016C840();
        std::string::operator=((std::string *)a4, (const std::string *)(v6 + 10));
        if (*(char *)(a4 + 135) < 0)
        {
          *(void *)(a4 + 12sub_1001A7358((uint64_t)&a9, 0) = 8;
          uint64_t v25 = *(char **)(a4 + 112);
        }
        else
        {
          *(unsigned char *)(a4 + 135) = 8;
          uint64_t v25 = v9;
        }
        strcpy(v25, "consumer");
        uint64_t v26 = v8;
        sub_100AEB680(&__s, v8, a2);
        std::string::size_type size = __s.__r_.__value_.__l.__size_;
        uint64_t v28 = (_DWORD *)__s.__r_.__value_.__r.__words[0];
        if (__s.__r_.__value_.__r.__words[0] != __s.__r_.__value_.__l.__size_)
        {
          do
          {
            LODWORD(v54) = *v28;
            uint64_t v29 = sub_10003B194(v4, (int *)&v54);
            if (!*((unsigned char *)v6 + 104)) {
              sub_10016C840();
            }
            uint64_t v30 = *v29;
            if ((void **)(v30 + 144) != sub_100046F68(*v29 + 136, (void **)v6 + 10))
            {
              if (*(char *)(a4 + 135) < 0)
              {
                *(void *)(a4 + 12sub_1001A7358((uint64_t)&a9, 0) = 10;
                long long v31 = *(char **)(a4 + 112);
              }
              else
              {
                *(unsigned char *)(a4 + 135) = 10;
                long long v31 = v9;
              }
              strcpy(v31, "enterprise");
              int v32 = *(char *)(a4 + 159);
              if (*((unsigned char *)v6 + 136))
              {
                if (v32 < 0)
                {
                  *(void *)(a4 + 144) = 12;
                  uint64_t v33 = *(void *)(a4 + 136);
                }
                else
                {
                  *(unsigned char *)(a4 + 159) = 12;
                  uint64_t v33 = v52;
                }
                *(_DWORD *)(v33 + 8) = 2037542759;
                *(void *)uint64_t v33 = *(void *)"app_category";
                uint64_t v35 = (unsigned char *)(v33 + 12);
              }
              else
              {
                if (v32 < 0)
                {
                  *(void *)(a4 + 144) = 3;
                  uint64_t v34 = *(void *)(a4 + 136);
                }
                else
                {
                  *(unsigned char *)(a4 + 159) = 3;
                  uint64_t v34 = v52;
                }
                *(unsigned char *)(v34 + 2) = 110;
                *(_WORD *)uint64_t v34 = 28260;
                uint64_t v35 = (unsigned char *)(v34 + 3);
              }
              *uint64_t v35 = 0;
            }
            ++v28;
          }
          while (v28 != (_DWORD *)size);
          uint64_t v28 = (_DWORD *)__s.__r_.__value_.__r.__words[0];
        }
        if (v28) {
          operator delete(v28);
        }
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v56 = 0;
        uint64_t v8 = v26;
        (*(void (**)(void ***__return_ptr, uint64_t, uint64_t))(*(void *)v26 + 2264))(&v54, v26, a4);
        int v5 = v48;
        if (v56)
        {
          uint64_t v36 = v54;
          memset(&v53, 0, sizeof(v53));
          if (v54 != &v55)
          {
            sub_100B07D18(&__s);
            uint64_t v37 = v36[1];
            std::string v53 = __s;
            if (v37)
            {
              do
              {
                uint64_t v38 = v37;
                uint64_t v37 = (void *)*v37;
              }
              while (v37);
            }
            else
            {
              do
              {
                uint64_t v38 = v36[2];
                BOOL v16 = *v38 == (void)v36;
                uint64_t v36 = (void **)v38;
              }
              while (!v16);
            }
            if (v38 != &v55)
            {
              do
              {
                *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
                strcpy((char *)&__s, ",");
                std::string::append(&v53, (const std::string::value_type *)&__s, 1uLL);
                if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__s.__r_.__value_.__l.__data_);
                }
                sub_100B07D18(&__s);
                if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  p_s = &__s;
                }
                else {
                  p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
                }
                if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v40 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v40 = __s.__r_.__value_.__l.__size_;
                }
                std::string::append(&v53, (const std::string::value_type *)p_s, v40);
                if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__s.__r_.__value_.__l.__data_);
                }
                long long v41 = (void *)v38[1];
                if (v41)
                {
                  do
                  {
                    long long v42 = (void **)v41;
                    long long v41 = (void *)*v41;
                  }
                  while (v41);
                }
                else
                {
                  do
                  {
                    long long v42 = (void **)v38[2];
                    BOOL v16 = *v42 == v38;
                    uint64_t v38 = v42;
                  }
                  while (!v16);
                }
                uint64_t v38 = v42;
              }
              while (v42 != &v55);
            }
          }
          if (*(char *)(a4 + 79) < 0) {
            operator delete(*v47);
          }
          *(std::string *)unint64_t v47 = v53;
        }
        sub_1000346F8((uint64_t)&v54, v55);
      }
      if (!*(_DWORD *)(a4 + 24) && *((unsigned char *)v6 + 264)) {
        *(_DWORD *)(a4 + 24) = *((_DWORD *)v6 + 65);
      }
      uint64_t v43 = *(unsigned __int8 *)(a4 + 55);
      if ((v43 & 0x80u) != 0) {
        uint64_t v43 = *(void *)(a4 + 40);
      }
      if (!v43 && *((unsigned char *)v6 + 296)) {
        std::string::operator=(v51, (const std::string *)(v6 + 34));
      }
      uint64_t v44 = *(unsigned __int8 *)(a4 + 103);
      if ((v44 & 0x80u) != 0) {
        uint64_t v44 = *(void *)(a4 + 88);
      }
      if (!v44 && *((unsigned char *)v6 + 136)) {
        std::string::operator=(v50, (const std::string *)(v6 + 14));
      }
      int v45 = (void *)v6[1];
      if (v45)
      {
        do
        {
          int64x2_t v46 = v45;
          int v45 = (void *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          int64x2_t v46 = (void *)v6[2];
          BOOL v16 = *v46 == (void)v6;
          unint64_t v6 = v46;
        }
        while (!v16);
      }
      unint64_t v6 = v46;
    }
    while (v46 != v5);
  }
}

void sub_100AF2004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,void *a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&a22, a23);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'DataServiceController::setStatisticsData(uint64_t a1, int a2, void *a3, uint64_t a4)
{
}

uint64_t *DataServiceController::getGenreForBundleID_sync@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = (uint64_t *)sub_100046F68(a1 + 4640, a2);
  if ((uint64_t *)(a1 + 4648) == result || !*((unsigned char *)result + 80))
  {
    a3[2] = 0;
    a3[1] = 0;
    *a3 = (uint64_t)(a3 + 1);
  }
  else
  {
    return sub_1001E0DB4(a3, (uint64_t)(result + 7));
  }
  return result;
}

uint64_t *non-virtual thunk to'DataServiceController::getGenreForBundleID_sync@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t *a3@<X8>)
{
  return DataServiceController::getGenreForBundleID_sync(a1 - 96, a2, a3);
}

void **DataServiceController::getBundleIdByUUID_sync@<X0>(void **result@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = (void **)result[580];
  int v5 = result + 581;
  if (v4 == result + 581)
  {
LABEL_10:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    while (1)
    {
      if (*((unsigned char *)v4 + 112))
      {
        uint64_t result = sub_100046F68((uint64_t)(v4 + 11), a2);
        if (v4 + 12 != result) {
          break;
        }
      }
      int v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
      if (v8 == v5) {
        goto LABEL_10;
      }
    }
    if (*((char *)v4 + 55) < 0)
    {
      uint64_t v11 = v4[4];
      unint64_t v12 = (unint64_t)v4[5];
      return (void **)sub_10004FC84((unsigned char *)a3, v11, v12);
    }
    else
    {
      long long v10 = *((_OWORD *)v4 + 2);
      *(void *)(a3 + 16) = v4[6];
      *(_OWORD *)a3 = v10;
    }
  }
  return result;
}

void **non-virtual thunk to'DataServiceController::getBundleIdByUUID_sync@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  return DataServiceController::getBundleIdByUUID_sync((void **)(a1 - 96), a2, a3);
}

BOOL DataServiceController::realGoodGenre(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(void **)(a1 + 336);
  if (!v2) {
    return 1;
  }
  unint64_t v3 = (void *)(a1 + 336);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      unint64_t v6 = v2;
    }
    else {
      unint64_t v6 = v2 + 1;
    }
    if (v5) {
      unint64_t v3 = v2;
    }
    unsigned int v2 = (void *)*v6;
  }
  while (*v6);
  return v3 == (void *)(a1 + 336) || v3[4] > a2 || *((unsigned char *)v3 + 40) || *((_DWORD *)v3 + 11) == 0;
}

BOOL sub_100AF2240(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = v2 + 432;
  do
  {
    uint64_t v7 = *(void *)(v5 - 16);
    unint64_t v6 = *(std::__shared_weak_count **)(v5 - 8);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      int v8 = *(_DWORD *)(v7 + 52);
      sub_10004D2C8(v6);
    }
    else
    {
      int v8 = *(_DWORD *)(v7 + 52);
    }
    BOOL result = v8 == a2;
    BOOL v10 = v8 == a2 || v5 == v3;
    v5 += 432;
  }
  while (!v10);
  return result;
}

uint64_t sub_100AF22C0(void *a1, uint64_t a2)
{
  if (sub_100AEAD30((uint64_t)a1, (TrafficDescriptor *)a2))
  {
    unint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)a2);
      if (v24 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v26 = v5;
      unint64_t v6 = "#I trafficClassAllowed: true: %{public}s (1)";
LABEL_37:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      return 1;
    }
    return 1;
  }
  if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)a2)
    || !*(unsigned char *)(a2 + 232)
    || (int v7 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1),
        !DataServiceController::SlicesDataContainer::useEntitlementsGenres((uint64_t)(a1 + 577), v7)))
  {
    unint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)a2);
      if (v24 >= 0) {
        uint64_t v21 = __p;
      }
      else {
        uint64_t v21 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v26 = v21;
      unint64_t v6 = "#I trafficClassAllowed: true: %{public}s (4)";
      goto LABEL_37;
    }
    return 1;
  }
  if (!*(unsigned char *)(a2 + 72)) {
    goto LABEL_46;
  }
  int v8 = sub_100046F68((uint64_t)(a1 + 580), (void **)(a2 + 48));
  if (a1 + 581 == v8 || !*((unsigned char *)v8 + 160)) {
    goto LABEL_25;
  }
  if (!*(unsigned char *)(a2 + 232)) {
LABEL_46:
  }
    sub_10016C840();
  uint64_t v11 = (char *)v8[18];
  BOOL v9 = v8 + 18;
  BOOL v10 = v11;
  if (v11)
  {
    unsigned int v12 = *(_DWORD *)(a2 + 228);
    unint64_t v13 = v9;
    do
    {
      unsigned int v14 = *((_DWORD *)v10 + 7);
      BOOL v15 = v14 >= v12;
      if (v14 >= v12) {
        BOOL v16 = (void **)v10;
      }
      else {
        BOOL v16 = (void **)(v10 + 8);
      }
      if (v15) {
        unint64_t v13 = (void **)v10;
      }
      BOOL v10 = (char *)*v16;
    }
    while (*v16);
    if (v13 != v9 && v12 >= *((_DWORD *)v13 + 7))
    {
      unint64_t v4 = a1[5];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)a2);
        if (v24 >= 0) {
          uint64_t v22 = __p;
        }
        else {
          uint64_t v22 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v26 = v22;
        unint64_t v6 = "#I trafficClassAllowed: true: %{public}s (2)";
        goto LABEL_37;
      }
      return 1;
    }
  }
LABEL_25:
  uint64_t v17 = a1[5];
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v18)
  {
    TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)a2);
    if (v24 >= 0) {
      uint64_t v20 = __p;
    }
    else {
      uint64_t v20 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v26 = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I trafficClassAllowed: false: %{public}s (3)", buf, 0xCu);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return result;
}

BOOL sub_100AF25B8(uint64_t a1, void **this)
{
  if (TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)this)) {
    return 1;
  }
  if (*((unsigned char *)this + 104)) {
    return a1 + 168 != (void)sub_100046F68(a1 + 160, this + 10);
  }
  return 0;
}

void sub_100AF2618(uint64_t a1, int a2, void **a3, int a4)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v27 = 0;
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  sub_100AEB680(&v22, a1, a2);
  long long v9 = v22;
  if ((void)v22 == *((void *)&v22 + 1))
  {
LABEL_6:
    if ((void)v9) {
      operator delete((void *)v9);
    }
    if (!a4) {
      goto LABEL_27;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 104));
    unsigned int v12 = ServiceMap;
    if (v13 < 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v22 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v22);
    if (v17)
    {
      uint64_t v19 = v17[3];
      BOOL v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        if (!v19)
        {
LABEL_25:
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
LABEL_27:
          sub_100B02DE0(a1, a2, (uint64_t)a3, (uint64_t)__p, (uint64_t)v24, a4);
          if ((SHIBYTE(v25) & 0x80000000) == 0) {
            goto LABEL_30;
          }
          uint64_t v21 = v24[0];
          goto LABEL_29;
        }
LABEL_20:
        (*(void (**)(long long *__return_ptr, uint64_t, void **))(*(void *)v19 + 96))(&v22, v19, a3);
        if (SHIBYTE(v27) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)std::string __p = v22;
        uint64_t v27 = v23;
        (*(void (**)(long long *__return_ptr, uint64_t, void **))(*(void *)v19 + 104))(&v22, v19, a3);
        if (SHIBYTE(v25) < 0) {
          operator delete(v24[0]);
        }
        *(_OWORD *)char v24 = v22;
        uint64_t v25 = v23;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    BOOL v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_25;
    }
    goto LABEL_20;
  }
  BOOL v10 = (int *)v22;
  while ((a4 & 1) != 0 || !sub_100AF092C(a1, *v10, a3))
  {
    if (++v10 == *((int **)&v9 + 1)) {
      goto LABEL_6;
    }
  }
  if ((void)v9)
  {
    uint64_t v21 = (void *)v9;
LABEL_29:
    operator delete(v21);
  }
LABEL_30:
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100AF2864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::forwardTrafficToAgent_sync(DataServiceController *this, const TrafficDescriptor *a2)
{
  if ((TrafficDescriptor::empty(a2) & 1) == 0)
  {
    unint64_t v4 = *((void *)this + 5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)v7, a2);
      if (v8 >= 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (void **)v7[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor forward: %{public}s", buf, 0xCu);
      if (v8 < 0) {
        operator delete(v7[0]);
      }
    }
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v6, a2);
    v9[0] = off_101A3A1B8;
    v9[1] = this;
    void v9[3] = v9;
    sub_100AF2A2C();
    sub_100B083C8(v9);
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v6);
  }
}

void sub_100AF2A08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B083C8((void *)(v2 - 112));
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)va);
  _Unwind_Resume(a1);
}

void sub_100AF2A2C()
{
  uint64_t v0 = (void *)__chkstk_darwin();
  int v113 = v1;
  uint64_t v116 = v2;
  uint64_t v4 = v3;
  uint64_t v5 = (uint64_t)v0;
  if ((sub_100AF22C0(v0, v3) & 1) == 0)
  {
    *(unsigned char *)(v4 + 228) = 0;
    *(unsigned char *)(v4 + 232) = 0;
  }
  int v6 = TrafficDescriptor::empty((TrafficDescriptor *)v4);
  int v7 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 1088);
  if (v6)
  {
    unsigned int v8 = v7(v5);
    sub_100058DB0(__p, "");
    v140[0] = 0;
    char v141 = 0;
    int v9 = sub_100AF4954(v5, v8, (void **)__p, (const TrafficDescriptor *)v140);
    if (v141) {
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v140);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v139, (const TrafficDescriptor *)v4);
    uint64_t v11 = (TrafficDescriptor *)v139;
    sub_100AF58F0(*(void *)(v116 + 24), v10, v9);
LABEL_193:
    unint64_t v78 = v11;
    goto LABEL_194;
  }
  unsigned int v118 = v7(v5);
  unsigned int v12 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48));
  uint64_t v13 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)v4);
    unsigned int v14 = __p;
    if (__p[23] < 0) {
      unsigned int v14 = *(unsigned char **)__p;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor select: %{public}s", (uint8_t *)&buf, 0xCu);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  if (!(*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v5 + 2176))(v5, v118, 1))
  {
LABEL_182:
    uint64_t v73 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)v4);
      std::string::size_type v74 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v74;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#N Cannot find connection type for td, using basic internet: td=[%{public}s]", (uint8_t *)&buf, 0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    unsigned int v75 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
    sub_100058DB0(__p, "");
    v120[0] = 0;
    char v121 = 0;
    int v76 = sub_100AF4954(v5, v75, (void **)__p, (const TrafficDescriptor *)v120);
    if (v121) {
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v120);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v77 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v119, (const TrafficDescriptor *)v4);
    uint64_t v11 = (TrafficDescriptor *)v119;
    sub_100AF58F0(*(void *)(v116 + 24), v77, v76);
    goto LABEL_193;
  }
  *(_DWORD *)std::string __p = v118;
  uint64_t v111 = *sub_10003B194(v5 + 4616, (int *)__p);
  *(_DWORD *)std::string __p = v118;
  __str = (std::string *)(v4 + 48);
  long long __dst = (std::string *)(v4 + 240);
  uint64_t v15 = *sub_10003B194(v5 + 4616, (int *)__p);
  if (v113 && *(unsigned char *)(v15 + 1)) {
    goto LABEL_17;
  }
  if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v4)) {
    goto LABEL_21;
  }
  if (!*(unsigned char *)(v4 + 72)) {
    sub_10016C840();
  }
  if (sub_100AF092C(v5, v118, (void **)&__str->__r_.__value_.__l.__data_))
  {
LABEL_17:
    int v112 = 1;
  }
  else
  {
LABEL_21:
    __p[0] = 0;
    __p[24] = 0;
    sub_100179CB0((uint64_t)__dst, (__n128 *)__p);
    if (__p[24] && (__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v112 = 0;
  }
  if (*(unsigned char *)(v5 + 4920)
    && !*(unsigned char *)(v5 + 4921)
    && TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v4)
    && (TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)v4) & 1) == 0)
  {
    if (!v112)
    {
LABEL_46:
      if (!*(unsigned char *)(v4 + 72)) {
        sub_10016C840();
      }
      if (!*(unsigned char *)(v5 + 4972)
        || (void **)(v5 + 4936) == sub_100046F68(v5 + 4928, (void **)&__str->__r_.__value_.__l.__data_))
      {
        unsigned int v83 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
        sub_100058DB0(__p, "");
        v137[0] = 0;
        char v138 = 0;
        int v84 = sub_100AF4954(v5, v83, (void **)__p, (const TrafficDescriptor *)v137);
        if (v138) {
          TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v137);
        }
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        long long v165 = 0u;
        long long v166 = 0u;
        long long v163 = 0u;
        long long v164 = 0u;
        long long v161 = 0u;
        long long v162 = 0u;
        long long v159 = 0u;
        long long v160 = 0u;
        long long v157 = 0u;
        long long v158 = 0u;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        memset(__p, 0, sizeof(__p));
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p);
        sub_100179AF8((std::string *)&__p[48], __str);
        if (*(unsigned char *)(v4 + 40)
          && (*(char *)(v4 + 39) < 0 ? (uint64_t v85 = *(void *)(v4 + 24)) : (uint64_t v85 = *(unsigned __int8 *)(v4 + 39)), v85))
        {
          sub_100179AF8((std::string *)&__p[16], (const std::string *)(v4 + 16));
        }
        else
        {
          if (!*(unsigned char *)(v4 + 8))
          {
            if (!*(unsigned char *)(v4 + 72)) {
              sub_10016C840();
            }
            std::string::size_type v102 = sub_100AF086C(v5, (void **)&__str->__r_.__value_.__l.__data_);
            id v103 = v102 + 1;
            std::string::size_type v104 = (void *)*v102;
            if ((uint64_t *)*v102 != v102 + 1)
            {
              do
              {
                sub_100093B44((std::string *)&__p[16], (const std::string *)(v104 + 4));
                int v105 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
                TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v136, (const TrafficDescriptor *)__p);
                sub_100AF58F0(*(void *)(v116 + 24), v105, v84);
                TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v136);
                unint64_t v106 = (uint64_t *)v104[1];
                if (v106)
                {
                  do
                  {
                    CFArrayRef v107 = v106;
                    unint64_t v106 = (uint64_t *)*v106;
                  }
                  while (v106);
                }
                else
                {
                  do
                  {
                    CFArrayRef v107 = (uint64_t *)v104[2];
                    BOOL v108 = *v107 == (void)v104;
                    std::string::size_type v104 = v107;
                  }
                  while (!v108);
                }
                std::string::size_type v104 = v107;
              }
              while (v107 != v103);
            }
            goto LABEL_213;
          }
          *(_DWORD *)&__p[4] = *(_DWORD *)(v4 + 4);
          __p[8] = *(unsigned char *)(v4 + 8);
        }
        int v101 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v135, (const TrafficDescriptor *)__p);
        sub_100AF58F0(*(void *)(v116 + 24), v101, v84);
        long long v22 = (TrafficDescriptor *)v135;
        goto LABEL_208;
      }
      goto LABEL_49;
    }
    memset(__p, 0, 24);
    memset(&buf, 0, sizeof(buf));
    if (*(unsigned char *)(v4 + 72))
    {
      if ((void **)(v15 + 168) == sub_100046F68(v15 + 160, (void **)&__str->__r_.__value_.__l.__data_))
      {
        if (*(unsigned char *)(v4 + 72))
        {
          sub_100AF5948(v5, v118, (void **)&__str->__r_.__value_.__l.__data_, (std::string *)__p, &buf);
LABEL_36:
          uint64_t v16 = __p[23];
          if (__p[23] < 0) {
            uint64_t v16 = *(void *)&__p[8];
          }
          std::string::size_type size = buf.__r_.__value_.__l.__size_;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          BOOL v18 = (v16 | size) == 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(buf.__r_.__value_.__l.__data_);
            if ((__p[23] & 0x80) == 0)
            {
LABEL_42:
              if (!v18) {
                goto LABEL_50;
              }
              goto LABEL_46;
            }
          }
          else if ((__p[23] & 0x80) == 0)
          {
            goto LABEL_42;
          }
          operator delete(*(void **)__p);
          if (!v18) {
            goto LABEL_50;
          }
          goto LABEL_46;
        }
      }
      else if (*(unsigned char *)(v4 + 72))
      {
        std::string::operator=(&buf, __str);
        goto LABEL_36;
      }
    }
    sub_10016C840();
  }
LABEL_49:
  if (!v112) {
    goto LABEL_92;
  }
LABEL_50:
  uint64_t v19 = sub_10003B004(*(void *)(v5 + 144), v118);
  char v20 = (const char *)kWildCardDnn;
  if (*(void *)(*(void *)(v5 + 144) + 16) == v19 || *(_DWORD *)(v19 + 128) != 17)
  {
    if (v113 && TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)v4))
    {
      long long v165 = 0u;
      long long v166 = 0u;
      long long v163 = 0u;
      long long v164 = 0u;
      long long v161 = 0u;
      long long v162 = 0u;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v155 = 0u;
      long long v156 = 0u;
      long long v153 = 0u;
      long long v154 = 0u;
      memset(__p, 0, sizeof(__p));
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p);
      sub_100AF576C((uint64_t)__p, (TrafficDescriptor *)v4);
      if (!BYTE8(v164)) {
        sub_10016C840();
      }
      v133[0] = 0;
      char v134 = 0;
      int v21 = sub_100AF4954(v5, v118, (void **)&v163, (const TrafficDescriptor *)v133);
      if (v134) {
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v133);
      }
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v132, (const TrafficDescriptor *)__p);
      sub_100AF58F0(*(void *)(v116 + 24), v118, v21);
      long long v22 = (TrafficDescriptor *)v132;
      goto LABEL_208;
    }
    memset(&buf, 0, sizeof(buf));
    *(_DWORD *)std::string __p = v118;
    uint64_t v23 = sub_10003B194(v5 + 4616, (int *)__p);
    uint64_t v24 = *v23;
    if (*(char *)(*v23 + 303) < 0) {
      sub_10004FC84(&buf, *(void **)(v24 + 280), *(void *)(v24 + 288));
    }
    else {
      std::string buf = *(std::string *)(v24 + 280);
    }
    std::string::size_type v25 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    char v26 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v25 = buf.__r_.__value_.__l.__size_;
    }
    if (v25)
    {
      memset(&v167, 0, sizeof(v167));
      if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v4))
      {
        if (!*(unsigned char *)(v4 + 72)) {
          sub_10016C840();
        }
        *(_DWORD *)std::string __p = v118;
        uint64_t v27 = sub_10003B194(v5 + 4616, (int *)__p);
        uint64_t v28 = *v27;
        if (*(unsigned char *)(*v27 + 1))
        {
          uint64_t v29 = sub_100046F68(v28 + 136, (void **)&__str->__r_.__value_.__l.__data_);
          if ((void **)(v28 + 144) != v29)
          {
            std::string::operator=(&v167, (const std::string *)(v29 + 10));
            sub_100AF97D0(v5, v118, 0xFFFFFFFFFFFFFFFFLL);
          }
        }
      }
      std::string::size_type v30 = HIBYTE(v167.__r_.__value_.__r.__words[2]);
      if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v30 = v167.__r_.__value_.__l.__size_;
      }
      if (v30) {
        std::string::operator=(&buf, &v167);
      }
      char v26 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v31 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t v31 = buf.__r_.__value_.__l.__size_;
      }
      if (v31 != strlen(v20)
        || ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (p_std::string buf = &buf)
          : (p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0]),
            memcmp(p_buf, v20, v31)))
      {
        long long v165 = 0u;
        long long v166 = 0u;
        long long v163 = 0u;
        long long v164 = 0u;
        long long v161 = 0u;
        long long v162 = 0u;
        long long v159 = 0u;
        long long v160 = 0u;
        long long v157 = 0u;
        long long v158 = 0u;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        memset(__p, 0, sizeof(__p));
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p);
        sub_100093B44((std::string *)&v163, &buf);
        sub_100AF576C((uint64_t)__p, (TrafficDescriptor *)v4);
        v130[0] = 0;
        char v131 = 0;
        int v33 = sub_100AF4954(v5, v118, (void **)&buf.__r_.__value_.__l.__data_, (const TrafficDescriptor *)v130);
        if (v131) {
          TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v130);
        }
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v129, (const TrafficDescriptor *)__p);
        sub_100AF58F0(*(void *)(v116 + 24), v118, v33);
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v129);
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)__p);
        if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v167.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        return;
      }
      if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v167.__r_.__value_.__l.__data_);
        char v26 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
    }
    if (v26 < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  if ((TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)v4) & 1) == 0)
  {
    unint64_t v79 = v20;
    if (!TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v4)) {
      goto LABEL_251;
    }
    memset(__p, 0, 24);
    memset(&buf, 0, sizeof(buf));
    if (*(unsigned char *)(v4 + 72))
    {
      if ((void **)(v15 + 168) == sub_100046F68(v15 + 160, (void **)&__str->__r_.__value_.__l.__data_))
      {
        if (*(unsigned char *)(v4 + 72))
        {
          sub_100AF5948(v5, v118, (void **)&__str->__r_.__value_.__l.__data_, (std::string *)__p, &buf);
LABEL_224:
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v86 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v86 = buf.__r_.__value_.__l.__size_;
          }
          if (v86)
          {
            sub_100093B44((std::string *)(v4 + 80), &buf);
            CFArrayRef v87 = *v12;
            if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
            {
              TrafficDescriptor::toString((uint64_t *)&v167, (TrafficDescriptor *)v4);
              uint64_t v88 = (v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? &v167
                  : (std::string *)v167.__r_.__value_.__r.__words[0];
              LODWORD(v15sub_1001A7358((uint64_t)&a9, 0) = 136446210;
              *(void *)((char *)&v150 + 4) = v88;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor select: fakeAppCategory: td = %{public}s", (uint8_t *)&v150, 0xCu);
              if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v167.__r_.__value_.__l.__data_);
              }
            }
          }
          uint64_t v89 = __p[23];
          if (__p[23] < 0) {
            uint64_t v89 = *(void *)&__p[8];
          }
          if (v89)
          {
            sub_100093B44(__dst, (const std::string *)__p);
            int v90 = *v12;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
            {
              long long v91 = __p;
              if (__p[23] < 0) {
                long long v91 = *(unsigned char **)__p;
              }
              LODWORD(v167.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)v167.__r_.__value_.__r.__words + 4) = (std::string::size_type)v91;
              _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor select: %{public}s: DNN updated from MDM", (uint8_t *)&v167, 0xCu);
            }
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            goto LABEL_92;
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(buf.__r_.__value_.__l.__data_);
            if ((__p[23] & 0x80) == 0)
            {
LABEL_247:
              if (v86) {
                goto LABEL_92;
              }
              goto LABEL_251;
            }
          }
          else if ((__p[23] & 0x80) == 0)
          {
            goto LABEL_247;
          }
          operator delete(*(void **)__p);
          if (v86) {
            goto LABEL_92;
          }
LABEL_251:
          int64x2_t v92 = (const std::string *)(v111 + 256);
          int v93 = *(char *)(v111 + 279);
          if (v93 >= 0) {
            size_t v94 = *(unsigned __int8 *)(v111 + 279);
          }
          else {
            size_t v94 = *(void *)(v111 + 264);
          }
          if (v94 == strlen(v79)
            && (v93 >= 0 ? (uint64_t v95 = (const void *)(v111 + 256)) : (uint64_t v95 = (const void *)v92->__r_.__value_.__r.__words[0]),
                !memcmp(v95, v79, v94)))
          {
            if (*(char *)(v15 + 327) < 0) {
              uint64_t v100 = *(void *)(v15 + 312);
            }
            else {
              uint64_t v100 = *(unsigned __int8 *)(v15 + 327);
            }
            if (!v100)
            {
              uint64_t v110 = *v12;
              if (!os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_92;
              }
              *(_WORD *)std::string __p = 0;
              id v97 = "#I TrafficDescriptor select: no DNN info and no anyLookupDnn";
              long long v98 = v110;
              uint32_t v99 = 2;
LABEL_265:
              _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, v97, __p, v99);
              goto LABEL_92;
            }
            unint64_t v109 = (void *)(v15 + 304);
            sub_100093B44(__dst, (const std::string *)(v15 + 304));
            std::string::size_type v96 = *v12;
            if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_92;
            }
            if (*(char *)(v15 + 327) < 0) {
              unint64_t v109 = (void *)*v109;
            }
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v109;
            id v97 = "#I TrafficDescriptor select: %{public}s: DNN updated from anyLookupDnn";
          }
          else
          {
            if (!v94) {
              goto LABEL_92;
            }
            sub_100093B44(__dst, v92);
            std::string::size_type v96 = *v12;
            if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_92;
            }
            if (*(char *)(v111 + 279) < 0) {
              int64x2_t v92 = (const std::string *)v92->__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::string __p = 136446210;
            *(void *)&__p[4] = v92;
            id v97 = "#I TrafficDescriptor select: %{public}s: DNN updated from enterpriseDnn";
          }
          long long v98 = v96;
          uint32_t v99 = 12;
          goto LABEL_265;
        }
      }
      else if (*(unsigned char *)(v4 + 72))
      {
        std::string::operator=(&buf, __str);
        goto LABEL_224;
      }
    }
    sub_10016C840();
  }
LABEL_92:
  uint64_t v34 = *(void *)(v5 + 144);
  uint64_t v35 = *(void **)(v34 + 8);
  __dsta = *(void **)(v34 + 16);
  if (v35 == __dsta) {
    goto LABEL_182;
  }
  while (1)
  {
    uint64_t v37 = v35[52];
    uint64_t v36 = (std::__shared_weak_count *)v35[53];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      int v38 = *(_DWORD *)(v37 + 52);
      sub_10004D2C8(v36);
    }
    else
    {
      int v38 = *(_DWORD *)(v37 + 52);
    }
    if (v38 != v118 || !v35[3]) {
      goto LABEL_179;
    }
    uint64_t v39 = (uint64_t *)sub_100AEC4B4(v5, v118, (uint64_t)"select connection for td");
    if (v39[1] == *v39) {
      break;
    }
    long long v165 = 0uLL;
    long long v166 = 0uLL;
    long long v163 = 0uLL;
    long long v164 = 0uLL;
    long long v161 = 0uLL;
    long long v162 = 0uLL;
    long long v159 = 0uLL;
    long long v160 = 0uLL;
    long long v157 = 0uLL;
    long long v158 = 0uLL;
    long long v155 = 0uLL;
    long long v156 = 0uLL;
    long long v153 = 0uLL;
    long long v154 = 0uLL;
    memset(__p, 0, sizeof(__p));
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p);
    long long v150 = 0uLL;
    uint64_t v151 = 0;
    std::string::size_type v40 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)v4);
      long long v41 = &buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v41 = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      LODWORD(v167.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v167.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I findRsDnn_sync <%{public}s>", (uint8_t *)&v167, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v42 = *v39;
    uint64_t v43 = v39[1];
    while (1)
    {
      if (v42 == v43)
      {
        long long v150 = 0uLL;
        uint64_t v151 = 0;
        goto LABEL_115;
      }
      if (TrafficDescriptor::hasRsDnnInfo((TrafficDescriptor *)v42))
      {
        uint64_t v44 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)v42);
          int v45 = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int v45 = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v167.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v167.__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I cbTd <%{public}s>", (uint8_t *)&v167, 0xCu);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        if (sub_100AE9B60(v5, (TrafficDescriptor *)v42, v4)) {
          break;
        }
      }
      v42 += 304;
    }
    __int16 v66 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)&buf, (TrafficDescriptor *)v4);
      int v67 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
      std::string::size_type v68 = buf.__r_.__value_.__r.__words[0];
      TrafficDescriptor::toString((uint64_t *)&v167, (TrafficDescriptor *)v42);
      uint64_t v69 = &buf;
      if (v67 < 0) {
        uint64_t v69 = (std::string *)v68;
      }
      unsigned int v70 = &v167;
      if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned int v70 = (std::string *)v167.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t v168 = 136446466;
      uint64_t v169 = v69;
      __int16 v170 = 2082;
      uint64_t v171 = v70;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor find dnn: td=%{public}s: found cbTd: %{public}s", v168, 0x16u);
      if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v167.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    TrafficDescriptor::operator=();
    if (!*(unsigned char *)(v42 + 296)) {
      sub_10016C840();
    }
    if (*(char *)(v42 + 295) < 0)
    {
      sub_10004FC84(&v150, *(void **)(v42 + 272), *(void *)(v42 + 280));
    }
    else
    {
      long long v71 = *(_OWORD *)(v42 + 272);
      uint64_t v151 = *(void *)(v42 + 288);
      long long v150 = v71;
    }
LABEL_115:
    if (SHIBYTE(v151) < 0)
    {
      if (*((void *)&v150 + 1))
      {
LABEL_209:
        sub_100AF576C((uint64_t)__p, (TrafficDescriptor *)v4);
        v124[0] = 0;
        char v125 = 0;
        int v82 = sub_100AF4954(v5, v118, (void **)&v150, (const TrafficDescriptor *)v124);
        if (v125) {
          TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v124);
        }
        TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v123, (const TrafficDescriptor *)__p);
        sub_100AF58F0(*(void *)(v116 + 24), v118, v82);
        TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v123);
        if (SHIBYTE(v151) < 0) {
          operator delete((void *)v150);
        }
        goto LABEL_213;
      }
      operator delete((void *)v150);
    }
    else if (HIBYTE(v151))
    {
      goto LABEL_209;
    }
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)__p);
    memset(&buf, 0, sizeof(buf));
    int64x2_t v46 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)v4);
      unint64_t v47 = __p;
      if (__p[23] < 0) {
        unint64_t v47 = *(unsigned char **)__p;
      }
      LODWORD(v167.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v167.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor <%{public}s> matching:", (uint8_t *)&v167, 0xCu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    uint64_t v48 = *v39;
    if (678152731 * ((unint64_t)(v39[1] - *v39) >> 4))
    {
      uint64_t v49 = 0;
      unint64_t v50 = 0;
      do
      {
        uint64_t v51 = (TrafficDescriptor *)(v48 + v49);
        if ((TrafficDescriptor::empty((TrafficDescriptor *)(v48 + v49)) & 1) == 0
          && (TrafficDescriptor::hasRsDnnInfo(v51) & 1) == 0)
        {
          uint64_t v52 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            TrafficDescriptor::toString((uint64_t *)__p, v51);
            std::string v53 = __p;
            if (__p[23] < 0) {
              std::string v53 = *(unsigned char **)__p;
            }
            LODWORD(v167.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v167.__r_.__value_.__r.__words + 4) = (std::string::size_type)v53;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I bbTd <%{public}s>", (uint8_t *)&v167, 0xCu);
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
          }
          if (((TrafficDescriptor::hasDnnInfo(v51) & 1) != 0
             || (TrafficDescriptor::hasAppInfo(v51) & 1) != 0
             || (TrafficDescriptor::hasTrafficInfo(v51) & 1) != 0
             || TrafficDescriptor::hasAccountInfo(v51))
            && sub_100AE9B60(v5, v51, v4))
          {
            uint64_t v54 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string __p = 0;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor match", __p, 2u);
            }
            long long v165 = 0u;
            long long v166 = 0u;
            long long v163 = 0u;
            long long v164 = 0u;
            long long v161 = 0u;
            long long v162 = 0u;
            long long v159 = 0u;
            long long v160 = 0u;
            long long v157 = 0u;
            long long v158 = 0u;
            long long v155 = 0u;
            long long v156 = 0u;
            long long v153 = 0u;
            long long v154 = 0u;
            memset(__p, 0, sizeof(__p));
            TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p, v51);
            sub_100AF576C((uint64_t)__p, (TrafficDescriptor *)v4);
            std::string::size_type v55 = buf.__r_.__value_.__l.__size_;
            if (buf.__r_.__value_.__l.__size_ >= buf.__r_.__value_.__r.__words[2])
            {
              std::string::size_type v56 = sub_100B06024((uint64_t *)&buf, (const TrafficDescriptor *)__p);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)buf.__r_.__value_.__l.__size_, (const TrafficDescriptor *)__p);
              std::string::size_type v56 = v55 + 304;
            }
            buf.__r_.__value_.__l.__size_ = v56;
            TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)__p);
          }
        }
        ++v50;
        uint64_t v48 = *v39;
        v49 += 304;
      }
      while (v50 < 678152731 * ((unint64_t)(v39[1] - *v39) >> 4));
    }
    std::string::size_type v57 = buf.__r_.__value_.__l.__size_;
    uint64_t v58 = (TrafficDescriptor *)buf.__r_.__value_.__r.__words[0];
    int v59 = v113;
    if (buf.__r_.__value_.__r.__words[0] != buf.__r_.__value_.__l.__size_) {
      int v59 = 0;
    }
    if (v112 & v59)
    {
      long long v60 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor matched none, trying the directly configured TD", __p, 2u);
        uint64_t v58 = (TrafficDescriptor *)buf.__r_.__value_.__l.__size_;
      }
      if ((unint64_t)v58 >= buf.__r_.__value_.__r.__words[2])
      {
        std::string::size_type v57 = sub_100B05B6C((uint64_t *)&buf, (const TrafficDescriptor *)v4);
      }
      else
      {
        TrafficDescriptor::TrafficDescriptor(v58, (const TrafficDescriptor *)v4);
        std::string::size_type v57 = (std::string::size_type)v58 + 304;
      }
      buf.__r_.__value_.__l.__size_ = v57;
      uint64_t v58 = (TrafficDescriptor *)buf.__r_.__value_.__r.__words[0];
    }
    if (v58 == (TrafficDescriptor *)v57) {
      goto LABEL_178;
    }
    uint64_t v61 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor matched", __p, 2u);
    }
    memset(&__p[8], 0, 64);
    *(void *)std::string __p = v5;
    *(_DWORD *)&__p[8] = v118;
    sub_100B09C8C((uint64_t)&__p[16], v116);
    memset(&__p[48], 0, 24);
    sub_100B05E34(&__p[48], (uint64_t)buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_, 0x86BCA1AF286BCA1BLL * ((uint64_t)(buf.__r_.__value_.__l.__size_ - buf.__r_.__value_.__r.__words[0]) >> 4));
    memset(v122, 0, sizeof(v122));
    sub_100B05E34(v122, (uint64_t)buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_, 0x86BCA1AF286BCA1BLL * ((uint64_t)(buf.__r_.__value_.__l.__size_ - buf.__r_.__value_.__r.__words[0]) >> 4));
    uint64_t v142 = *(void *)__p;
    int v143 = *(_DWORD *)&__p[8];
    sub_100B09C8C((uint64_t)v144, (uint64_t)&__p[16]);
    long long v146 = 0uLL;
    uint64_t v147 = 0;
    sub_100B05E34(&v146, *(uint64_t *)&__p[48], *(uint64_t *)&__p[56], 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)&__p[56] - *(void *)&__p[48]) >> 4));
    v149 = 0;
    BOOL v62 = operator new(0x50uLL);
    char v63 = v62;
    uint64_t v64 = v142;
    void *v62 = off_101A3A5E8;
    v62[1] = v64;
    *((_DWORD *)v62 + 4) = v143;
    if (!v145)
    {
      int v65 = v62 + 6;
      goto LABEL_163;
    }
    if (v145 != v144)
    {
      v62[6] = v145;
      int v65 = &v145;
LABEL_163:
      void *v65 = 0;
      goto LABEL_177;
    }
    v62[6] = v62 + 3;
    (*(void (**)(void *))(v144[0] + 24))(v144);
LABEL_177:
    *(_OWORD *)(v63 + 7) = v146;
    v63[9] = v147;
    uint64_t v147 = 0;
    long long v146 = 0uLL;
    v149 = v63;
    int v72 = sub_100AF59F4(v5, v118, 0, v122, (uint64_t)v148);
    sub_100B0A3F4(v148);
    v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&v146;
    sub_1008BE774((void ***)&v167);
    sub_100B083C8(v144);
    v167.__r_.__value_.__r.__words[0] = (std::string::size_type)v122;
    sub_1008BE774((void ***)&v167);
    v167.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p[48];
    sub_1008BE774((void ***)&v167);
    sub_100B083C8(&__p[16]);
    if (v72)
    {
      *(void *)std::string __p = &buf;
      sub_1008BE774((void ***)__p);
      return;
    }
LABEL_178:
    *(void *)std::string __p = &buf;
    sub_1008BE774((void ***)__p);
LABEL_179:
    v35 += 54;
    if (v35 == __dsta) {
      goto LABEL_182;
    }
  }
  long long v165 = 0uLL;
  long long v166 = 0uLL;
  long long v163 = 0uLL;
  long long v164 = 0uLL;
  long long v161 = 0uLL;
  long long v162 = 0uLL;
  long long v159 = 0uLL;
  long long v160 = 0uLL;
  long long v157 = 0uLL;
  long long v158 = 0uLL;
  long long v155 = 0uLL;
  long long v156 = 0uLL;
  long long v153 = 0uLL;
  long long v154 = 0uLL;
  memset(__p, 0, sizeof(__p));
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p);
  sub_100AF576C((uint64_t)__p, (TrafficDescriptor *)v4);
  uint64_t v80 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I NW does not have URSP and DNN is not known; use Internet",
      (uint8_t *)&buf,
      2u);
  }
  sub_100058DB0(&buf, "");
  v127[0] = 0;
  char v128 = 0;
  int v81 = sub_100AF4954(v5, v118, (void **)&buf.__r_.__value_.__l.__data_, (const TrafficDescriptor *)v127);
  if (v128) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v127);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v126, (const TrafficDescriptor *)__p);
  sub_100AF58F0(*(void *)(v116 + 24), v118, v81);
  long long v22 = (TrafficDescriptor *)v126;
LABEL_208:
  TrafficDescriptor::~TrafficDescriptor(v22);
LABEL_213:
  unint64_t v78 = (TrafficDescriptor *)__p;
LABEL_194:
  TrafficDescriptor::~TrafficDescriptor(v78);
}

void sub_100AF447C(_Unwind_Exception *a1)
{
}

void non-virtual thunk to'DataServiceController::forwardTrafficToAgent_sync(DataServiceController *this, const TrafficDescriptor *a2)
{
}

void DataServiceController::forwardTrafficToInternetAgent_sync(void *a1, TrafficDescriptor *a2)
{
  if ((TrafficDescriptor::empty(a2) & 1) == 0)
  {
    if ((sub_100AEAD30((uint64_t)a1, a2) & 1) == 0 && *((unsigned char *)a2 + 40))
    {
      *((unsigned char *)a2 + 4) = 0;
      *((unsigned char *)a2 + 8) = 0;
    }
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)&__p, a2);
      uint64_t v5 = v9 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)std::string buf = 136446210;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor forward to internet: %{public}s", buf, 0xCu);
      if (v9 < 0) {
        operator delete(__p);
      }
    }
    std::string __p = 0;
    unsigned int v8 = 0;
    int v6 = (*(uint64_t (**)(void *))(*a1 + 1088))(a1);
    DataServiceController::getConnection_sync((uint64_t)a1, v6, 0, (uint64_t *)&__p);
    if (__p) {
      (*(void (**)(void *, TrafficDescriptor *))(*(void *)__p + 440))(__p, a2);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
}

void sub_100AF492C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'DataServiceController::forwardTrafficToInternetAgent_sync(uint64_t a1, TrafficDescriptor *a2)
{
}

uint64_t sub_100AF4954(uint64_t a1, unsigned int a2, void **a3, const TrafficDescriptor *a4)
{
  uint64_t v4 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
  if ((char)v4 < 0) {
    uint64_t v4 = (unsigned __int8 *)a3[1];
  }
  if (!v4) {
    return 0;
  }
  char v9 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  unint64_t v78 = 0;
  unint64_t v79 = 0;
  DataServiceController::getConnection_sync(a1, a2, 0, (uint64_t *)&v78);
  if (!v78) {
    goto LABEL_27;
  }
  uint64_t v85 = 0;
  std::string::size_type v86 = 0;
  (*(void (**)(uint64_t (***__return_ptr)()))(*v78 + 136))(&v85);
  if (v85)
  {
    *(void *)&uint8_t buf[8] = 0;
    *(void *)std::string buf = 0;
    (*((void (**)(unsigned char *__return_ptr))*v85 + 58))(buf);
    if (*(void *)buf)
    {
      uint64_t v10 = *(unsigned __int8 *)(*(void *)buf + 71);
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = (unsigned __int8 *)*(unsigned __int8 *)(*(void *)buf + 71);
      }
      else {
        uint64_t v11 = *(unsigned __int8 **)(*(void *)buf + 56);
      }
      unsigned int v12 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
      int v13 = (char)v12;
      if ((char)v12 < 0) {
        unsigned int v12 = (unsigned __int8 *)a3[1];
      }
      if (v11 == v12)
      {
        unsigned int v14 = (const void **)(*(void *)buf + 48);
        if (v13 >= 0) {
          uint64_t v15 = (unsigned __int8 *)a3;
        }
        else {
          uint64_t v15 = (unsigned __int8 *)*a3;
        }
        if ((v10 & 0x80) == 0)
        {
          if (*(unsigned char *)(*(void *)buf + 71))
          {
            uint64_t v16 = v15;
            while (*(unsigned __int8 *)v14 == *v16)
            {
              unsigned int v14 = (const void **)((char *)v14 + 1);
              ++v16;
              if (!--v10) {
                goto LABEL_123;
              }
            }
            goto LABEL_23;
          }
          goto LABEL_123;
        }
        if (!memcmp(*v14, v15, *(void *)(*(void *)buf + 56)))
        {
LABEL_123:
          uint64_t v54 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v76) = 136446210;
            *(void *)((char *)&v76 + 4) = v15;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Requested Internet APN: %{public}s", (uint8_t *)&v76, 0xCu);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v86) {
            sub_10004D2C8(v86);
          }
          if (v79) {
            sub_10004D2C8(v79);
          }
          return 0;
        }
      }
    }
LABEL_23:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v86) {
    sub_10004D2C8(v86);
  }
LABEL_27:
  if (v79) {
    sub_10004D2C8(v79);
  }
  unsigned int v61 = 36;
  std::string::size_type v86 = 0;
  uint64_t v87 = 0;
  uint64_t v85 = off_101A3A248;
  uint64_t v88 = &v85;
  long long v84 = 0u;
  long long v83 = 0u;
  long long v82 = 0u;
  long long v81 = 0u;
  unint64_t v78 = (void *)a1;
  unint64_t v79 = (std::__shared_weak_count *)a2;
  uint64_t v80 = v9;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v81, *a3, (unint64_t)a3[1]);
  }
  else
  {
    long long v81 = *(_OWORD *)a3;
    *(void *)&long long v82 = a3[2];
  }
  *((void *)&v82 + 1) = &v61;
  sub_100B08B18((uint64_t)&v83, (uint64_t)&v85);
  long long v76 = 0uLL;
  uint64_t v77 = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *a3, (unint64_t)a3[1]);
  }
  else
  {
    long long __p = *(_OWORD *)a3;
    int v72 = (unsigned __int8 *)a3[2];
  }
  std::string::size_type v56 = v9;
  sub_100B08B18((uint64_t)v73, (uint64_t)&v85);
  *(void *)&unsigned char buf[24] = 0;
  uint64_t v17 = operator new(0x40uLL);
  void *v17 = off_101A3A2D8;
  BOOL v18 = v17 + 1;
  if (SHIBYTE(v72) < 0)
  {
    sub_10004FC84(v18, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)BOOL v18 = __p;
    void v17[3] = v72;
  }
  if (v74)
  {
    if (v74 == v73)
    {
      v17[7] = v17 + 4;
      (*(void (**)(void *))(v73[0] + 24))(v73);
      goto LABEL_44;
    }
    uint64_t v19 = &v74;
    v17[7] = v74;
  }
  else
  {
    uint64_t v19 = v17 + 7;
  }
  *uint64_t v19 = 0;
LABEL_44:
  *(void *)&unsigned char buf[24] = v17;
  sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
  sub_100B08BB0(buf);
  sub_100B08A94(v73);
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)__p);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__dst, *a3, (unint64_t)a3[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)a3;
    long long v60 = (unsigned __int8 *)a3[2];
  }
  *(void *)&unsigned char buf[24] = 0;
  char v20 = operator new(0x20uLL);
  void *v20 = off_101A3A368;
  int v21 = v20 + 1;
  if (SHIBYTE(v60) < 0)
  {
    sub_10004FC84(v21, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)int v21 = __dst;
    void v20[3] = v60;
  }
  *(void *)&unsigned char buf[24] = v20;
  sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
  sub_100B08BB0(buf);
  if (SHIBYTE(v60) < 0) {
    operator delete((void *)__dst);
  }
  if (*((unsigned char *)a4 + 304))
  {
    long long v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I add td matching rejectFunc", buf, 2u);
    }
    sub_100B06400((TrafficDescriptor *)v57, a4);
    *(void *)&unsigned char buf[24] = 0;
    uint64_t v23 = operator new(0x150uLL);
    void *v23 = off_101A3A3E8;
    v23[1] = a1;
    *((_DWORD *)v23 + 4) = a2;
    *((unsigned char *)v23 + 24) = 0;
    *((unsigned char *)v23 + 328) = 0;
    if (v58)
    {
      TrafficDescriptor::TrafficDescriptor();
      *((unsigned char *)v23 + 328) = 1;
    }
    *(void *)&unsigned char buf[24] = v23;
    sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
    sub_100B08BB0(buf);
    if (v58) {
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v57);
    }
  }
  *(void *)std::string buf = off_101A3A468;
  *(void *)&unsigned char buf[24] = buf;
  sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
  sub_100B08BB0(buf);
  *(void *)std::string buf = off_101A3A4E8;
  *(void *)&uint8_t buf[8] = a1;
  *(void *)&uint8_t buf[16] = a2;
  *(void *)&unsigned char buf[24] = buf;
  sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
  sub_100B08BB0(buf);
  *(void *)std::string buf = off_101A3A568;
  *(void *)&unsigned char buf[24] = buf;
  sub_100AF55C8((uint64_t *)&v76, (uint64_t)buf);
  sub_100B08BB0(buf);
  uint64_t v24 = v76;
  if (*((void *)&v76 + 1) != (void)v76)
  {
    for (unint64_t i = 0; i < (uint64_t)(*((void *)&v76 + 1) - v76) >> 5; ++i)
    {
      uint64_t v26 = v24 + 32 * i;
      uint64_t v27 = *(void *)(v26 + 24);
      if (v27)
      {
        if (v27 == v26)
        {
          unsigned int v70 = v69;
          (*(void (**)(void, void *))(**(void **)(v26 + 24) + 24))(*(void *)(v26 + 24), v69);
          goto LABEL_68;
        }
        uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 16))(v27);
      }
      unsigned int v70 = (void *)v27;
LABEL_68:
      uint64_t v28 = v78[18];
      std::string::size_type v30 = *(void **)(v28 + 8);
      uint64_t v29 = *(void **)(v28 + 16);
      while (v30 != v29)
      {
        uint64_t v32 = v30[52];
        size_t v31 = (std::__shared_weak_count *)v30[53];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          int v33 = *(_DWORD *)(v32 + 52);
          sub_10004D2C8(v31);
        }
        else
        {
          int v33 = *(_DWORD *)(v32 + 52);
        }
        if (v33 == v79)
        {
          uint64_t v34 = (void *)v30[7];
          uint64_t v35 = (void *)v30[8];
          while (1)
          {
            if (v34 == v35) {
              goto LABEL_105;
            }
            if (*v34) {
              break;
            }
LABEL_98:
            v34 += 2;
          }
          __int16 v66 = 0;
          int v67 = 0;
          (*(void (**)(std::string **__return_ptr))(*(void *)*v34 + 776))(&v66);
          if (!v66)
          {
            int v41 = 5;
            goto LABEL_95;
          }
          unint64_t size = v66[6].__r_.__value_.__l.__size_;
          memset(buf, 0, 24);
          ConnectionMaskToTypes((uint64_t *)buf, size);
          uint64_t v37 = *(void **)buf;
          if (*(void *)&buf[8] - *(void *)buf == 4)
          {
            int v38 = **(_DWORD **)buf;
            if ((isSlice() & 1) == 0) {
              goto LABEL_91;
            }
            uint64_t v64 = v66;
            int v65 = v67;
            if (v67) {
              atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v39 = (std::__shared_weak_count *)v34[1];
            uint64_t v62 = *v34;
            char v63 = v39;
            if (v39) {
              atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            int v68 = v38;
            if (!v70) {
              sub_10007B600();
            }
            char v40 = (*(uint64_t (**)(void *, std::string **, int *, uint64_t *))(*v70 + 48))(v70, &v64, &v68, &v62);
            if (v63) {
              sub_10004D2C8(v63);
            }
            if (v65) {
              sub_10004D2C8(v65);
            }
            if ((v40 & 1) == 0)
            {
              if (!*((void *)&v84 + 1)) {
                sub_10007B600();
              }
              if (((*(uint64_t (**)(void, std::string *, long long *))(**((void **)&v84 + 1) + 48))(*((void *)&v84 + 1), v66 + 2, &v81) & 1) == 0)std::string::operator=(v66 + 2, (const std::string *)&v81); {
              sub_100C97DFC((uint64_t)v66, v80, (uint64_t)"");
              }
              **((_DWORD **)&v82 + 1) = v38;
              int v41 = 4;
            }
            else
            {
LABEL_91:
              int v41 = 5;
            }
            uint64_t v37 = *(void **)buf;
            if (!*(void *)buf)
            {
LABEL_95:
              if (v67) {
                sub_10004D2C8(v67);
              }
              if (v41 != 5) {
                break;
              }
              goto LABEL_98;
            }
          }
          else
          {
            int v41 = 5;
            if (!*(void *)buf) {
              goto LABEL_95;
            }
          }
          *(void *)&uint8_t buf[8] = v37;
          operator delete(v37);
          goto LABEL_95;
        }
        v30 += 54;
      }
LABEL_105:
      int v42 = **((_DWORD **)&v82 + 1);
      sub_100B08BB0(v69);
      if (v42 != 36)
      {
        uint64_t v43 = *v56;
        if (os_log_type_enabled(*v56, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = *((char *)a3 + 23);
          int v45 = (void **)*a3;
          uint64_t v46 = asString();
          if (v44 >= 0) {
            unint64_t v47 = a3;
          }
          else {
            unint64_t v47 = v45;
          }
          *(_DWORD *)std::string buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = i;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v47;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v46;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I chooseConnectionType(success %u): dnn=%{public}s, conn=%s", buf, 0x1Cu);
        }
        break;
      }
      uint64_t v24 = v76;
    }
  }
  uint64_t v48 = v61;
  if (v61 == 36)
  {
    uint64_t v49 = *v56;
    if (os_log_type_enabled(*v56, OS_LOG_TYPE_DEFAULT))
    {
      int v50 = *((char *)a3 + 23);
      uint64_t v51 = (void **)*a3;
      uint64_t v52 = asString();
      if (v50 >= 0) {
        std::string v53 = a3;
      }
      else {
        std::string v53 = v51;
      }
      *(_DWORD *)std::string buf = 136446466;
      *(void *)&uint8_t buf[4] = v53;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v52;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I chooseConnectionType(fail): dnn=%{public}s, conn=%s", buf, 0x16u);
    }
    uint64_t v48 = 0;
    unsigned int v61 = 0;
  }
  *(void *)std::string buf = &v76;
  sub_100B06460((void ***)buf);
  sub_100B08A94(&v83);
  if (SBYTE7(v82) < 0) {
    operator delete((void *)v81);
  }
  sub_100B08A94(&v85);
  return v48;
}

void sub_100AF53EC(_Unwind_Exception *a1)
{
  STACK[0x220] = v1 - 256;
  sub_100B06460((void ***)&STACK[0x220]);
  sub_100AF5730(v1 - 224);
  sub_100B08A94((void *)(v1 - 136));
  _Unwind_Resume(a1);
}

uint64_t sub_100AF55C8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    uint64_t v9 = (uint64_t)(v6 - *a1) >> 5;
    if ((unint64_t)(v9 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 4;
    if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v23 = v4;
    if (v12)
    {
      if (v12 >> 59) {
        sub_10006A7CC();
      }
      int v13 = (char *)operator new(32 * v12);
    }
    else
    {
      int v13 = 0;
    }
    unsigned int v14 = &v13[32 * v12];
    uint64_t v15 = sub_100B06330((uint64_t)&v13[32 * v9], a2);
    uint64_t v8 = v15 + 32;
    uint64_t v17 = *a1;
    unint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      int64x2_t v18 = vdupq_n_s64(v16);
    }
    else
    {
      do
      {
        v16 -= 32;
        uint64_t v15 = sub_100B06330(v15 - 32, v16);
      }
      while (v16 != v17);
      int64x2_t v18 = *(int64x2_t *)a1;
    }
    *a1 = v15;
    a1[1] = v8;
    int64x2_t v21 = v18;
    uint64_t v19 = a1[2];
    a1[2] = (uint64_t)v14;
    uint64_t v22 = v19;
    uint64_t v20 = v18.i64[0];
    uint64_t result = sub_100B063B0((uint64_t)&v20);
  }
  else
  {
    uint64_t result = sub_100B06330(v6, a2);
    uint64_t v8 = result + 32;
  }
  a1[1] = v8;
  return result;
}

uint64_t sub_100AF56F4(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100AF5730(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

std::string *sub_100AF576C(uint64_t a1, TrafficDescriptor *this)
{
  if (TrafficDescriptor::hasAccountInfo(this))
  {
    if (*((unsigned char *)this + 136))
    {
      return sub_100093B44((std::string *)(a1 + 112), (const std::string *)((char *)this + 112));
    }
LABEL_24:
    sub_10016C840();
  }
  if (TrafficDescriptor::hasDnnInfo(this))
  {
    if (!*(unsigned char *)(a1 + 264)) {
      goto LABEL_11;
    }
    uint64_t v5 = *(unsigned __int8 *)(a1 + 263);
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *(void *)(a1 + 248);
    }
    if (!v5)
    {
LABEL_11:
      if (!*((unsigned char *)this + 264)) {
        goto LABEL_24;
      }
      sub_100093B44((std::string *)(a1 + 240), (const std::string *)this + 10);
    }
  }
  uint64_t result = (std::string *)TrafficDescriptor::hasBundleInfo(this);
  if (result)
  {
    if (!*((unsigned char *)this + 72)) {
      goto LABEL_24;
    }
    uint64_t result = sub_100093B44((std::string *)(a1 + 48), (const std::string *)this + 2);
  }
  if (*((unsigned char *)this + 40))
  {
    uint64_t v6 = *((unsigned __int8 *)this + 39);
    if ((v6 & 0x80u) != 0) {
      uint64_t v6 = *((void *)this + 3);
    }
    if (v6) {
      uint64_t result = sub_100093B44((std::string *)(a1 + 16), (const std::string *)((char *)this + 16));
    }
  }
  if (*((unsigned char *)this + 8))
  {
    *(_DWORD *)(a1 + 4) = *((_DWORD *)this + 1);
    *(unsigned char *)(a1 + 8) = 1;
  }
  return result;
}

BOOL DataServiceController::SlicesDataContainer::useEntitlementsGenres(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == a1 + 8 || *(_DWORD *)(v3 + 32) > a2) {
    return 0;
  }
  int v8 = a2;
  return *(unsigned char *)(*sub_10003B194(a1, &v8) + 23) != 0;
}

uint64_t sub_100AF58F0(uint64_t a1, int a2, int a3)
{
  int v5 = a2;
  int v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

char *sub_100AF5948(uint64_t a1, int a2, void **a3, std::string *a4, std::string *a5)
{
  int v13 = a2;
  uint64_t result = (char *)sub_10003B194(a1 + 4616, &v13);
  uint64_t v11 = *(void *)result;
  if (*(unsigned char *)(*(void *)result + 1))
  {
    uint64_t result = (char *)sub_100046F68(v11 + 136, a3);
    if ((char *)(v11 + 144) != result)
    {
      unint64_t v12 = (const std::string *)(result + 56);
      std::string::operator=(a4, (const std::string *)(result + 80));
      std::string::operator=(a5, v12);
      return (char *)sub_100AF97D0(a1, a2, 0xFFFFFFFFFFFFFFFFLL);
    }
  }
  return result;
}

uint64_t sub_100AF59F4(uint64_t a1, int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v6 = a1;
  uint64_t v7 = *a4;
  unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((a4[1] - *a4) >> 4);
  if (v8 <= a3)
  {
    uint64_t v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string::size_type v55 = 136315650;
      *(void *)&v55[4] = "selectDnnForTd_sync";
      *(_WORD *)&v55[12] = 1024;
      *(_DWORD *)&v55[14] = a3;
      *(_WORD *)&v55[18] = 1024;
      *(_DWORD *)&v55[20] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%s: index of traffic descriptors is too large: %u, tds size: %u", v55, 0x18u);
    }
    return 0;
  }
  memset(v39, 0, sizeof(v39));
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v39, (const TrafficDescriptor *)(v7 + 304 * a3));
  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v36, (const TrafficDescriptor *)v39);
  if (TrafficDescriptor::hasAppCategoryInfo((TrafficDescriptor *)v36)) {
    sub_100179AF8((std::string *)v37, (const std::string *)v38);
  }
  long long v58 = 0u;
  long long v59 = 0u;
  uint64_t v60 = 0;
  memset(v57, 0, sizeof(v57));
  long long v56 = 0u;
  *(_OWORD *)&v55[8] = 0u;
  *(void *)std::string::size_type v55 = v6;
  *(_DWORD *)&v55[8] = a2;
  sub_100B0A478((uint64_t)&v55[16], a5);
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v57[8], (const TrafficDescriptor *)v39);
  *((void *)&v58 + 1) = a3;
  long long v59 = 0uLL;
  uint64_t v60 = 0;
  sub_100B05E34(&v59, *a4, a4[1], 0x86BCA1AF286BCA1BLL * ((a4[1] - *a4) >> 4));
  unint64_t v12 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)v36);
    int v13 = v35 >= 0 ? __p : (void **)__p[0];
    int v14 = 678152731 * ((unint64_t)(a4[1] - *a4) >> 4);
    *(_DWORD *)std::string buf = 136446722;
    *(void *)&uint8_t buf[4] = v13;
    __int16 v51 = 1024;
    int v52 = a3;
    __int16 v53 = 1024;
    int v54 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I trying lookup for: <%{public}s>, index %u, tds size: %u", buf, 0x18u);
    if (v35 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v15 = *(void *)(v6 + 144);
  unint64_t v16 = *(void **)(v15 + 8);
  uint64_t v17 = *(void **)(v15 + 16);
  if (v16 == v17)
  {
LABEL_26:
    uint64_t v31 = 0;
    goto LABEL_27;
  }
  while (1)
  {
    uint64_t v19 = v16[52];
    int64x2_t v18 = (std::__shared_weak_count *)v16[53];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      int v20 = *(_DWORD *)(v19 + 52);
      sub_10004D2C8(v18);
    }
    else
    {
      int v20 = *(_DWORD *)(v19 + 52);
    }
    if (v20 != a2) {
      goto LABEL_25;
    }
    uint64_t v21 = v16[3];
    if (!v21) {
      goto LABEL_25;
    }
    uint64_t v40 = *(void *)v55;
    int v41 = *(_DWORD *)&v55[8];
    sub_100B0A478((uint64_t)v42, (uint64_t)&v55[16]);
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v44, (const TrafficDescriptor *)&v57[8]);
    uint64_t v22 = v6;
    uint64_t v45 = *((void *)&v58 + 1);
    uint64_t v47 = 0;
    long long v46 = 0uLL;
    sub_100B05E34(&v46, v59, *((uint64_t *)&v59 + 1), 0x86BCA1AF286BCA1BLL * ((uint64_t)(*((void *)&v59 + 1) - v59) >> 4));
    uint64_t v49 = 0;
    uint64_t v23 = operator new(0x188uLL);
    uint64_t v24 = v23;
    uint64_t v25 = v40;
    void *v23 = off_101A3A678;
    v23[1] = v25;
    *((_DWORD *)v23 + 4) = v41;
    uint64_t v26 = (char *)(v23 + 3);
    if (!v43)
    {
      uint64_t v27 = v23 + 6;
      goto LABEL_20;
    }
    if (v43 != v42)
    {
      v23[6] = v43;
      uint64_t v27 = &v43;
LABEL_20:
      *uint64_t v27 = 0;
      goto LABEL_22;
    }
    v23[6] = v26;
    (*(void (**)(void *, char *))(v42[0] + 24))(v42, v26);
LABEL_22:
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(v24 + 7), (const TrafficDescriptor *)v44);
    uint64_t v28 = v47;
    v24[45] = v45;
    *((_OWORD *)v24 + 23) = v46;
    v24[48] = v28;
    uint64_t v47 = 0;
    long long v46 = 0uLL;
    uint64_t v49 = v24;
    char v29 = (*(uint64_t (**)(uint64_t, _OWORD *, void *))(*(void *)v21 + 912))(v21, v36, v48);
    sub_10012C330(v48);
    *(void *)std::string buf = &v46;
    sub_1008BE774((void ***)buf);
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v44);
    sub_100B0A3F4(v42);
    if (v29) {
      break;
    }
    uint64_t v6 = v22;
    std::string::size_type v30 = *(NSObject **)(v22 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#E TrafficDescriptor lookup failed", buf, 2u);
    }
LABEL_25:
    v16 += 54;
    if (v16 == v17) {
      goto LABEL_26;
    }
  }
  uint64_t v31 = 1;
LABEL_27:
  *(void *)std::string buf = &v59;
  sub_1008BE774((void ***)buf);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v57[8]);
  sub_100B0A3F4(&v55[16]);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v36);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v39);
  return v31;
}

void sub_100AF5FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, TrafficDescriptor *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

uint64_t sub_100AF6070(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 48);
  sub_1008BE774(&v3);
  sub_100B083C8((void *)(a1 + 16));
  return a1;
}

uint64_t sub_100AF60B4(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 360);
  sub_1008BE774(&v3);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(a1 + 48));
  sub_100B0A3F4((void *)(a1 + 16));
  return a1;
}

BOOL DataServiceController::isAllowedApp(unsigned char *a1, int a2, void **a3)
{
  LODWORD(v16) = a2;
  uint64_t v6 = sub_10003B194((uint64_t)(a1 + 4616), (int *)&v16);
  uint64_t v7 = *v6;
  if (*(unsigned char *)(*v6 + 1) && (void **)(v7 + 144) != sub_100046F68(v7 + 136, a3))
  {
    if (!sub_100AF97D0((uint64_t)a1, a2, 0xFFFFFFFFFFFFFFFFLL)) {
      return 0;
    }
    char v8 = 1;
    BOOL result = 1;
    if (*(unsigned char *)(v7 + 128)) {
      return result;
    }
LABEL_8:
    uint64_t v10 = sub_100046F68(v7 + 104, a3);
    BOOL v11 = v7 + 112 == (void)v10;
    BOOL result = v7 + 112 != (void)v10;
    if ((v8 & 1) != 0 || v11) {
      return result;
    }
    goto LABEL_10;
  }
  if (!*(unsigned char *)(v7 + 128))
  {
    char v8 = 0;
    goto LABEL_8;
  }
LABEL_10:
  if (!a1[4920] || a1[4921])
  {
    if (*(unsigned char *)(v7 + 15))
    {
LABEL_13:
      unint64_t v16 = 0;
      v17[0] = 0;
      v17[1] = 0;
      (*(void (**)(void ***__return_ptr, unsigned char *, void **))(*(void *)a1 + 2264))(&v16, a1, a3);
      unint64_t v12 = v16;
      if (v16 == v17)
      {
LABEL_21:
        sub_1000346F8((uint64_t)&v16, v17[0]);
        return 1;
      }
      while (sub_100AF97D0((uint64_t)a1, a2, v12[4]))
      {
        int v13 = (void *)v12[1];
        if (v13)
        {
          do
          {
            int v14 = (void **)v13;
            int v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            int v14 = (void **)v12[2];
            BOOL v11 = *v14 == v12;
            unint64_t v12 = v14;
          }
          while (!v11);
        }
        unint64_t v12 = v14;
        if (v14 == v17) {
          goto LABEL_21;
        }
      }
      sub_1000346F8((uint64_t)&v16, v17[0]);
    }
    return 0;
  }
  if (!a1[4972]) {
    return 0;
  }
  uint64_t v15 = sub_100046F68((uint64_t)(a1 + 4928), a3);
  BOOL result = 0;
  if (a1 + 4936 != (unsigned char *)v15 && *(unsigned char *)(v7 + 15)) {
    goto LABEL_13;
  }
  return result;
}

void sub_100AF62EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void *DataServiceController::getSliceTrafficDescriptors(uint64_t a1, int a2, int a3, uint64_t a4)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 1174405120;
  dispatch_object_t v11[2] = sub_100AF6460;
  v11[3] = &unk_101A3A008;
  void v11[4] = a1;
  int v13 = a2;
  int v14 = a3;
  sub_100B0AA48((uint64_t)v12, a4);
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(a1 + 8));
  int v5 = *(NSObject **)(a1 + 24);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 1174405120;
  void v7[2] = sub_100B0AAE0;
  void v7[3] = &unk_101A3A6F0;
  void v7[5] = v9;
  char v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v7[4] = v11;
  dispatch_async(v5, v7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  return sub_100525CFC(v12);
}

void sub_100AF6454(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AF6460(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!sub_100AF2240(*(void *)(v2 + 144), *(_DWORD *)(a1 + 72))) {
    goto LABEL_9;
  }
  uint64_t v7 = 0;
  v8[0] = 0;
  DataServiceController::getConnection_sync(v2, *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76), &v7);
  uint64_t v3 = v7;
  if (v7)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v10 = 0;
    uint64_t v4 = ((uint64_t (*)(void **, void **))(*v7)[51])(v7, __p);
    uint64_t v5 = *(void *)(a1 + 64);
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v5 + 48))(v5, __p, v4);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v8[0]) {
    sub_10004D2C8((std::__shared_weak_count *)v8[0]);
  }
  if (!v3)
  {
LABEL_9:
    sub_100058DB0(__p, "");
    v8[0] = 0;
    v8[1] = 0;
    uint64_t v7 = v8;
    uint64_t v6 = *(void *)(a1 + 64);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **, void ***))(*(void *)v6 + 48))(v6, __p, &v7);
    sub_10005D9E0((uint64_t)&v7, v8[0]);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100AF65C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100AF6614(uint64_t a1, uint64_t a2)
{
  return sub_100B0AA48(a1 + 40, a2 + 40);
}

void *sub_100AF6620(uint64_t a1)
{
  return sub_100525CFC((void *)(a1 + 40));
}

void *non-virtual thunk to'DataServiceController::getSliceTrafficDescriptors(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return DataServiceController::getSliceTrafficDescriptors(a1 - 96, a2, a3, a4);
}

void *DataServiceController::getSliceTrafficDescriptors(uint64_t a1, uint64_t a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_100AF6784;
  void v9[3] = &unk_101A3A038;
  void v9[4] = a1;
  sub_100B0AB1C((uint64_t)v10, a2);
  uint64_t v7 = 0;
  char v8 = 0;
  sub_10003E168(&v7, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100B0AAE0;
  block[3] = &unk_101A3A6F0;
  block[5] = v7;
  uint64_t v6 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v9;
  dispatch_async(v3, block);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return sub_100526174(v10);
}

void sub_100AF6778(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100AF6784(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  v15[0] = 0;
  v15[1] = 0;
  int v14 = (uint64_t *)v15;
  int v3 = (*(uint64_t (**)(void *))(*v2 + 1088))(v2);
  sub_100AEB680(&v12, (uint64_t)v2, v3);
  uint64_t v4 = v12;
  uint64_t v5 = v13;
  if (v12 != v13)
  {
    uint64_t v6 = v12;
    do
    {
      uint64_t v7 = *v6;
      char v8 = (const TrafficDescriptor **)sub_100AEC4B4((uint64_t)v2, *v6, (uint64_t)"get descriptors");
      uint64_t v9 = *v8;
      uint64_t v10 = v8[1];
      while (v9 != v10)
      {
        if (sub_100AF0654(v2, v7, (void **)v9, 1, 0)) {
          sub_1003816BC(&v14, (uint64_t)v9, v9);
        }
        uint64_t v9 = (const TrafficDescriptor *)((char *)v9 + 304);
      }
      ++v6;
    }
    while (v6 != v5);
  }
  if (v4) {
    operator delete(v4);
  }
  uint64_t v11 = *(void *)(a1 + 64);
  if (!v11) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t **))(*(void *)v11 + 48))(v11, &v14);
  sub_10005D9E0((uint64_t)&v14, v15[0]);
}

void sub_100AF68E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_100AF691C(uint64_t a1, uint64_t a2)
{
  return sub_100B0AB1C(a1 + 40, a2 + 40);
}

void *sub_100AF6928(uint64_t a1)
{
  return sub_100526174((void *)(a1 + 40));
}

void *non-virtual thunk to'DataServiceController::getSliceTrafficDescriptors(uint64_t a1, uint64_t a2)
{
  return DataServiceController::getSliceTrafficDescriptors(a1 - 96, a2);
}

void *DataServiceController::getSliceTrafficDescriptors_sync(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  if (!sub_100AF2240(*(void *)(a1 + 144), a2)) {
    return &kEmptyTrafficDescriptorsSet;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  DataServiceController::getConnection_sync(a1, v4, a3, &v10);
  uint64_t v6 = v10;
  if (v10)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v9 = 0;
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v10 + 408))(v10, __p);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (!v6) {
    return &kEmptyTrafficDescriptorsSet;
  }
  return (void *)v4;
}

void sub_100AF6A0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void *non-virtual thunk to'DataServiceController::getSliceTrafficDescriptors_sync(uint64_t a1, uint64_t a2, int a3)
{
  return DataServiceController::getSliceTrafficDescriptors_sync(a1 - 96, a2, a3);
}

void DataServiceController::callKitCallChanged_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2)
  {
    uint64_t v5 = a1 + 4616;
    *(_DWORD *)std::string buf = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
    if (*(unsigned char *)(*sub_10003B194(v5, (int *)buf) + 16))
    {
      int v6 = *(unsigned __int8 *)(a2 + 26);
      int v7 = *(unsigned __int8 *)(a2 + 24);
      char v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v9 = a2;
        }
        else {
          uint64_t v9 = *(void *)a2;
        }
        uint64_t v10 = asStringBool(*(unsigned char *)(a2 + 25));
        uint64_t v11 = asStringBool(*(unsigned char *)(a2 + 27));
        uint64_t v12 = asStringBool(v7 != 0);
        uint64_t v13 = asStringBool(v6 != 0);
        *(_DWORD *)std::string buf = 136447234;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v10;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v31 = v11;
        __int16 v32 = 2080;
        uint64_t v33 = v12;
        __int16 v34 = 2080;
        uint64_t v35 = v13;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I CallKit: Got VoIP Call Change event with bundleId %{public}s and active %s, video %s, callStart %s, callEnd %s", buf, 0x34u);
      }
      char v14 = *(unsigned char *)(a2 + 25);
      *(void *)std::string buf = a2;
      *((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 4832), (void **)a2, (uint64_t)&unk_10144E20E, (long long **)buf) + 56) = v14;
      if (v6) {
        sub_1000E9358((uint64_t **)(a1 + 4832), (void **)a2);
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
      if (((v7 != 0) & (*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)a1 + 2176))(a1, v15, 0)) == 1&& (void **)(a1 + 4816) != sub_100046F68(a1 + 4808, (void **)a2))
      {
        uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
        if (DataServiceController::sliceApp((unsigned char *)a1, v16, (void **)a2))
        {
          uint64_t v17 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I CallKit: Got VoIP Call Change event: adding the front policies", buf, 2u);
          }
          uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
          sub_100AF0384((void *)a1, v18, (std::string *)a2);
        }
      }
      if ((void **)(a1 + 4816) == sub_100046F68(a1 + 4808, (void **)a2))
      {
        uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
        if (!DataServiceController::sliceApp((unsigned char *)a1, v19, (void **)a2) && v6 != 0)
        {
          sub_100046BAC((uint64_t **)(a1 + 4808), (void **)a2, a2);
          memset(buf, 0, sizeof(buf));
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 2264))(buf, a1, a2);
          int v20 = *(void **)&buf[8];
          if (!*(void *)&buf[8]) {
            goto LABEL_30;
          }
          uint64_t v21 = &buf[8];
          do
          {
            uint64_t v22 = v20;
            uint64_t v23 = v21;
            unint64_t v24 = v20[4];
            uint64_t v25 = v20 + 1;
            unint64_t v26 = v24 >> 3;
            if (v26 >= 0x465)
            {
              uint64_t v25 = v22;
              uint64_t v21 = (uint8_t *)v22;
            }
            int v20 = (void *)*v25;
          }
          while (v20);
          if (v21 == &buf[8]
            || (v26 >= 0x465 ? (uint64_t v27 = (uint8_t *)v22) : (uint64_t v27 = v23), *((void *)v27 + 4) >= 0x2329uLL))
          {
LABEL_30:
            sub_100058DB0(__p, "App DB update: CallKit: new VoIP App detected");
            DataServiceController::updateSlicingDefinitionsWithAppDB(a1, (unint64_t *)__p);
            if (v29 < 0) {
              operator delete(__p[0]);
            }
          }
          sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
        }
      }
    }
    else
    {
      sub_10005CD2C(a1 + 4832, *(char **)(a1 + 4840));
      *(void *)(a1 + 4832) = a1 + 4840;
      *(void *)(a1 + 4848) = 0;
      *(void *)(a1 + 484sub_1001A7358((uint64_t)&a9, 0) = 0;
    }
  }
}

void sub_100AF6F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1000346F8((uint64_t)&a16, a17);
  _Unwind_Resume(a1);
}

void DataServiceController::activateFacetime(DataServiceController *this)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v6 = 0;
  sub_100058DB0(__p, "com.apple.facetime");
  uint64_t v2 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
  if (DataServiceController::sliceApp(this, v2, __p))
  {
    v4[0] = 0;
    v4[1] = 0;
    int v3 = v4;
    sub_100046BAC((uint64_t **)&v3, __p, (uint64_t)__p);
    DataServiceController::handleActiveAppsChanged_sync(this, &v3);
    sub_10005CD2C((uint64_t)&v3, v4[0]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100AF7014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void DataServiceController::handleNetworkSlicingSupportChanged_sync(void *a1, uint64_t a2)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 2192))(a1)) {
    return;
  }
  uint64_t v4 = (void *)a1[140];
  if (v4 == a1 + 141) {
    return;
  }
  int v34 = 0;
  uint64_t v35 = (uint64_t)(a1 + 577);
  do
  {
    uint64_t v5 = sub_100046F68(a2, (void **)v4 + 4);
    if ((void **)(a2 + 8) == v5)
    {
      uint64_t v6 = (uint64_t **)(v4 + 7);
    }
    else
    {
      uint64_t v6 = (uint64_t **)(v4 + 7);
      if (sub_100B0ABB4(v5 + 7, (uint64_t)(v4 + 7))) {
        goto LABEL_55;
      }
    }
    int v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *((unsigned __int8 *)v4 + 55);
      BOOL v9 = (v8 & 0x80u) != 0;
      if ((v8 & 0x80u) != 0) {
        uint64_t v8 = v4[5];
      }
      if (v9) {
        uint64_t v10 = (const char *)v4[4];
      }
      else {
        uint64_t v10 = (const char *)(v4 + 4);
      }
      BOOL v11 = v8 == 0;
      uint64_t v12 = "<invalid>";
      if (!v11) {
        uint64_t v12 = v10;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I slice persona featureState updated: %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v13 = a1[69];
    uint64_t v15 = *(void **)v13;
    char v14 = *(void **)(v13 + 8);
    if (*(void **)v13 != v14)
    {
      while (!sub_10001D294((unsigned __int8 *)(*v15 + 24), (unsigned __int8 *)v4 + 32))
      {
        v15 += 2;
        if (v15 == v14)
        {
          uint64_t v15 = v14;
          break;
        }
      }
      if (v15 != *(void **)(v13 + 8))
      {
        uint64_t v16 = *v15;
        uint64_t v17 = (std::__shared_weak_count *)v15[1];
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v16) {
          goto LABEL_53;
        }
        uint64_t v18 = a1[14];
        *(void *)&long long buf = a1[13];
        *((void *)&buf + 1) = v18;
        if (v18) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
        }
        char isValidSimSlot = subscriber::isValidSimSlot();
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if ((isValidSimSlot & 1) == 0) {
          goto LABEL_53;
        }
        LODWORD(buf) = *(_DWORD *)(v16 + 52);
        int v20 = sub_10003B194(v35, (int *)&buf);
        uint64_t v21 = *v20;
        if (*(void *)(*v20 + 344) == v4[9])
        {
          uint64_t v22 = *(void **)(v21 + 328);
          uint64_t v23 = (void *)(v21 + 336);
          if (v22 == v23)
          {
LABEL_53:
            if (v17) {
              sub_10004D2C8(v17);
            }
            goto LABEL_55;
          }
          unint64_t v24 = *v6;
          while (v22[4] == v24[4]
               && *((unsigned __int8 *)v22 + 40) == *((unsigned __int8 *)v24 + 40)
               && *((_DWORD *)v22 + 11) == *((_DWORD *)v24 + 11))
          {
            uint64_t v25 = (void *)v22[1];
            unint64_t v26 = v22;
            if (v25)
            {
              do
              {
                uint64_t v22 = v25;
                uint64_t v25 = (void *)*v25;
              }
              while (v25);
            }
            else
            {
              do
              {
                uint64_t v22 = (void *)v26[2];
                BOOL v11 = *v22 == (void)v26;
                unint64_t v26 = v22;
              }
              while (!v11);
            }
            uint64_t v27 = (uint64_t *)v24[1];
            if (v27)
            {
              do
              {
                uint64_t v28 = v27;
                uint64_t v27 = (uint64_t *)*v27;
              }
              while (v27);
            }
            else
            {
              do
              {
                uint64_t v28 = (uint64_t *)v24[2];
                BOOL v11 = *v28 == (void)v24;
                unint64_t v24 = v28;
              }
              while (!v11);
            }
            unint64_t v24 = v28;
            if (v22 == v23) {
              goto LABEL_53;
            }
          }
        }
        LODWORD(buf) = *(_DWORD *)(v16 + 52);
        char v29 = (uint64_t **)(*sub_10003B194(v35, (int *)&buf) + 328);
        if (v29 != v6) {
          sub_100B0AC80(v29, (void *)v4[7], v4 + 8);
        }
        std::string::size_type v30 = a1[5];
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v31 = subscriber::asString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v31;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s: slice persona featureState changed", (uint8_t *)&buf, 0xCu);
        }
        int v34 = 1;
        goto LABEL_53;
      }
    }
LABEL_55:
    __int16 v32 = (void *)v4[1];
    if (v32)
    {
      do
      {
        uint64_t v33 = v32;
        __int16 v32 = (void *)*v32;
      }
      while (v32);
    }
    else
    {
      do
      {
        uint64_t v33 = (void *)v4[2];
        BOOL v11 = *v33 == (void)v4;
        uint64_t v4 = v33;
      }
      while (!v11);
    }
    uint64_t v4 = v33;
  }
  while (v33 != a1 + 141);
  if (v34)
  {
    sub_100058DB0(&buf, "feature state change");
    (*(void (**)(void *, uint64_t, long long *, uint64_t))(*a1 + 2328))(a1, 3, &buf, 1);
    if (v37 < 0) {
      operator delete((void *)buf);
    }
  }
}

void sub_100AF7450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100AF74A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 288))
  {
    uint64_t v2 = *(void *)(v1 + 5080);
    *(void *)(v1 + 508sub_1001A7358((uint64_t)&a9, 0) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    sub_10005CD2C(v1 + 4784, *(char **)(v1 + 4792));
    *(void *)(v1 + 4784) = v1 + 4792;
    *(void *)(v1 + 480sub_1001A7358((uint64_t)&a9, 0) = 0;
    *(void *)(v1 + 4792) = 0;
    sub_100058DB0(__p, "App DB recovery");
    DataServiceController::updateSlicingDefinitionsWithAppDB(v1, (unint64_t *)__p);
    if (v4 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100AF7550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::sendNRSlicedRunningAppStateChanged_sync(DataServiceController *this)
{
  uint64_t v1 = this;
  int64x2_t v137 = 0uLL;
  unint64_t v138 = 0;
  uint64_t v2 = (char *)*((void *)this + 580);
  int v3 = (char *)this + 4648;
  if (v2 != (char *)this + 4648)
  {
    std::string::size_type v102 = (char *)this + 4648;
    do
    {
      if (v2[128])
      {
        int v4 = *((_DWORD *)v2 + 31);
        if ((v4 - 5) >= 0xFFFFFFFE)
        {
          unint64_t v136 = 0;
          int64x2_t v135 = 0u;
          memset(v134, 0, sizeof(v134));
          std::string::operator=((std::string *)v134, (const std::string *)(v2 + 32));
          v134[24] = v4 == 4;
          uint64_t v5 = *((void *)v1 + 14);
          *(void *)&v109[0] = *((void *)v1 + 13);
          *((void *)&v109[0] + 1) = v5;
          if (v5) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
          }
          subscriber::makeSimSlotRange();
          if (*((void *)&v109[0] + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v109[0] + 1));
          }
          uint64_t v6 = v131;
          int v7 = v132;
          if (v131 != v132)
          {
            uint64_t v8 = v133;
            while ((v8(*v6) & 1) == 0)
            {
              if (++v6 == v7)
              {
                uint64_t v6 = v7;
                break;
              }
            }
            BOOL v9 = v132;
            std::string::size_type v104 = v132;
LABEL_15:
            if (v6 != v9)
            {
              uint64_t v10 = sub_100AEFE40(*((void *)v1 + 18), *v6);
              uint64_t v12 = *(uint64_t **)v10;
              BOOL v11 = *(uint64_t **)(v10 + 8);
              while (1)
              {
                if (v12 == v11)
                {
                  long long v46 = v6 + 1;
                  uint64_t v6 = v7;
                  uint64_t v1 = this;
                  if (v46 != v7)
                  {
                    uint64_t v6 = v46;
                    while ((v8(*v6) & 1) == 0)
                    {
                      if (++v6 == v7)
                      {
                        uint64_t v6 = v7;
                        break;
                      }
                    }
                  }
                  BOOL v9 = v104;
                  goto LABEL_15;
                }
                uint64_t v14 = *v12;
                uint64_t v13 = (std::__shared_weak_count *)v12[1];
                if (v13) {
                  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (!v14) {
                  break;
                }
                (*(void (**)(uint64_t))(*(void *)v14 + 472))(v14);
                if ((isSlice() & 1) == 0 || !(*(unsigned int (**)(uint64_t))(*(void *)v14 + 168))(v14)) {
                  break;
                }
                memset(&__str, 0, sizeof(__str));
                uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, std::string *))(*(void *)v14 + 408))(v14, &__str);
                long long v129 = 0u;
                memset(&v127, 0, sizeof(v127));
                char v128 = &v129;
                std::string::operator=(&v127, &__str);
                uint64_t v18 = (void *)*v15;
                uint64_t v17 = v15 + 1;
                uint64_t v16 = v18;
                if (v18 != v17)
                {
                  while (1)
                  {
                    long long v125 = 0u;
                    long long v126 = 0u;
                    long long v123 = 0u;
                    long long v124 = 0u;
                    long long v121 = 0u;
                    long long v122 = 0u;
                    long long v119 = 0u;
                    long long v120 = 0u;
                    long long v117 = 0u;
                    long long v118 = 0u;
                    long long v115 = 0u;
                    long long v116 = 0u;
                    long long v113 = 0u;
                    long long v114 = 0u;
                    *(_OWORD *)__s1 = 0u;
                    long long v112 = 0u;
                    long long v110 = 0u;
                    memset(v109, 0, sizeof(v109));
                    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v109, (const TrafficDescriptor *)(v16 + 4));
                    if ((TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v109) & 1) == 0) {
                      goto LABEL_46;
                    }
                    if (!BYTE8(v112)) {
                      sub_10016C840();
                    }
                    uint64_t v19 = BYTE7(v112);
                    if ((SBYTE7(v112) & 0x80u) == 0) {
                      int v20 = (void *)BYTE7(v112);
                    }
                    else {
                      int v20 = __s1[1];
                    }
                    unint64_t v21 = v2[55];
                    int v22 = (char)v21;
                    if ((v21 & 0x80u) != 0) {
                      unint64_t v21 = *((void *)v2 + 5);
                    }
                    if (v20 != (void *)v21) {
                      goto LABEL_46;
                    }
                    uint64_t v23 = v22 >= 0 ? v2 + 32 : (char *)*((void *)v2 + 4);
                    if ((BYTE7(v112) & 0x80) == 0) {
                      break;
                    }
                    if (!memcmp(__s1[0], v23, (size_t)__s1[1])) {
                      goto LABEL_42;
                    }
LABEL_46:
                    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v109);
                    uint64_t v25 = (void *)v16[1];
                    if (v25)
                    {
                      do
                      {
                        unint64_t v26 = v25;
                        uint64_t v25 = (void *)*v25;
                      }
                      while (v25);
                    }
                    else
                    {
                      do
                      {
                        unint64_t v26 = (void *)v16[2];
                        BOOL v27 = *v26 == (void)v16;
                        uint64_t v16 = v26;
                      }
                      while (!v27);
                    }
                    uint64_t v16 = v26;
                    if (v26 == v17) {
                      goto LABEL_52;
                    }
                  }
                  if (BYTE7(v112))
                  {
                    unint64_t v24 = __s1;
                    while (*(unsigned __int8 *)v24 == *v23)
                    {
                      unint64_t v24 = (void **)((char *)v24 + 1);
                      ++v23;
                      if (!--v19) {
                        goto LABEL_42;
                      }
                    }
                    goto LABEL_46;
                  }
LABEL_42:
                  __p.n128_u8[0] = 0;
                  char v108 = 0;
                  sub_100179CB0((uint64_t)&v109[1], &__p);
                  if (v108 && v107 < 0) {
                    operator delete((void *)__p.n128_u64[0]);
                  }
                  BYTE4(v109[0]) = 0;
                  BYTE8(v109[0]) = 0;
                  LODWORD(v109[0]) = 0;
                  sub_1003816BC((uint64_t **)&v128, (uint64_t)v109, (const TrafficDescriptor *)v109);
                  goto LABEL_46;
                }
LABEL_52:
                if (*((void *)&v129 + 1))
                {
                  uint64_t v28 = v135.i64[1];
                  if (v135.i64[1] >= v136)
                  {
                    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v135.i64[1] - v135.i64[0]) >> 4);
                    unint64_t v31 = v30 + 1;
                    if (v30 + 1 > 0x555555555555555) {
                      sub_10006A748();
                    }
                    if (0x5555555555555556 * ((uint64_t)(v136 - v135.i64[0]) >> 4) > v31) {
                      unint64_t v31 = 0x5555555555555556 * ((uint64_t)(v136 - v135.i64[0]) >> 4);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v136 - v135.i64[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                      unint64_t v32 = 0x555555555555555;
                    }
                    else {
                      unint64_t v32 = v31;
                    }
                    *(void *)&long long v110 = &v136;
                    if (v32) {
                      unint64_t v32 = (unint64_t)sub_100A52878(v32);
                    }
                    else {
                      uint64_t v33 = 0;
                    }
                    *(void *)&v109[0] = v32;
                    *((void *)&v109[0] + 1) = v32 + 48 * v30;
                    *(void *)&v109[1] = *((void *)&v109[0] + 1);
                    *((void *)&v109[1] + 1) = v32 + 48 * v33;
                    sub_100B064E4(*((void **)&v109[0] + 1), (long long *)&v127);
                    uint64_t v34 = *((void *)&v109[0] + 1);
                    uint64_t v29 = *(void *)&v109[1] + 48;
                    *(void *)&v109[1] += 48;
                    int64x2_t v35 = v135;
                    if (v135.i64[1] == v135.i64[0])
                    {
                      int64x2_t v44 = vdupq_n_s64(v135.u64[1]);
                    }
                    else
                    {
                      uint64_t v36 = 0;
                      do
                      {
                        uint64_t v37 = v34 + v36;
                        uint64_t v38 = v35.i64[1] + v36;
                        long long v39 = *(_OWORD *)(v35.i64[1] + v36 - 48);
                        *(void *)(v37 - 32) = *(void *)(v35.i64[1] + v36 - 32);
                        *(_OWORD *)(v37 - 48) = v39;
                        *(void *)(v38 - 4sub_1001A7358((uint64_t)&a9, 0) = 0;
                        *(void *)(v38 - 32) = 0;
                        *(void *)(v38 - 48) = 0;
                        *(void *)(v37 - 24) = *(void *)(v35.i64[1] + v36 - 24);
                        uint64_t v40 = (uint64_t *)(v35.i64[1] + v36 - 16);
                        uint64_t v41 = *v40;
                        *(void *)(v34 + v36 - 16) = *v40;
                        uint64_t v42 = v34 + v36 - 16;
                        uint64_t v43 = *(void *)(v35.i64[1] + v36 - 8);
                        *(void *)(v37 - 8) = v43;
                        if (v43)
                        {
                          *(void *)(v41 + 16) = v42;
                          *(void *)(v38 - 24) = v40;
                          uint64_t *v40 = 0;
                          *(void *)(v35.i64[1] + v36 - 8) = 0;
                        }
                        else
                        {
                          *(void *)(v37 - 24) = v42;
                        }
                        v36 -= 48;
                      }
                      while (v35.i64[1] + v36 != v35.i64[0]);
                      int64x2_t v44 = v135;
                      uint64_t v29 = *(void *)&v109[1];
                      v34 += v36;
                    }
                    v135.i64[0] = v34;
                    v135.i64[1] = v29;
                    *(int64x2_t *)((char *)v109 + 8) = v44;
                    unint64_t v45 = v136;
                    unint64_t v136 = *((void *)&v109[1] + 1);
                    *((void *)&v109[1] + 1) = v45;
                    *(void *)&v109[0] = v44.i64[0];
                    sub_100B065B0((uint64_t)v109);
                  }
                  else
                  {
                    sub_100B064E4((void *)v135.i64[1], (long long *)&v127);
                    uint64_t v29 = v28 + 48;
                  }
                  v135.i64[1] = v29;
                }
                sub_10005D9E0((uint64_t)&v128, (void *)v129);
                if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v127.__r_.__value_.__l.__data_);
                }
                if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  break;
                }
                operator delete(__str.__r_.__value_.__l.__data_);
                if (v13) {
                  goto LABEL_78;
                }
LABEL_79:
                v12 += 2;
              }
              if (!v13) {
                goto LABEL_79;
              }
LABEL_78:
              sub_10004D2C8(v13);
              goto LABEL_79;
            }
          }
          int v3 = v102;
          if (v135.i64[1] != v135.i64[0])
          {
            uint64_t v47 = v137.i64[1];
            if (v137.i64[1] >= v138)
            {
              uint64_t v49 = 0x6DB6DB6DB6DB6DB7 * ((v137.i64[1] - v137.i64[0]) >> 3);
              unint64_t v50 = v49 + 1;
              if ((unint64_t)(v49 + 1) > 0x492492492492492) {
                sub_10006A748();
              }
              if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v138 - v137.i64[0]) >> 3) > v50) {
                unint64_t v50 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v138 - v137.i64[0]) >> 3);
              }
              if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v138 - v137.i64[0]) >> 3)) >= 0x249249249249249) {
                unint64_t v51 = 0x492492492492492;
              }
              else {
                unint64_t v51 = v50;
              }
              *(void *)&long long v110 = &v138;
              if (v51) {
                unint64_t v51 = (unint64_t)sub_10057A920(v51);
              }
              else {
                uint64_t v52 = 0;
              }
              *(void *)&v109[0] = v51;
              *((void *)&v109[0] + 1) = v51 + 56 * v49;
              *(void *)&v109[1] = *((void *)&v109[0] + 1);
              *((void *)&v109[1] + 1) = v51 + 56 * v52;
              sub_100B06600(*((void **)&v109[0] + 1), (long long *)v134);
              uint64_t v53 = *((void *)&v109[0] + 1);
              uint64_t v48 = *(void *)&v109[1] + 56;
              *(void *)&v109[1] += 56;
              int64x2_t v54 = v137;
              if (v137.i64[1] == v137.i64[0])
              {
                int64x2_t v59 = vdupq_n_s64(v137.u64[1]);
              }
              else
              {
                uint64_t v55 = 0;
                do
                {
                  uint64_t v56 = v53 + v55;
                  uint64_t v57 = v54.i64[1] + v55;
                  long long v58 = *(_OWORD *)(v54.i64[1] + v55 - 56);
                  *(void *)(v56 - 4sub_1001A7358((uint64_t)&a9, 0) = *(void *)(v54.i64[1] + v55 - 40);
                  *(_OWORD *)(v56 - 56) = v58;
                  *(void *)(v57 - 48) = 0;
                  *(void *)(v57 - 4sub_1001A7358((uint64_t)&a9, 0) = 0;
                  *(void *)(v57 - 56) = 0;
                  *(unsigned char *)(v56 - 32) = *(unsigned char *)(v54.i64[1] + v55 - 32);
                  *(void *)(v56 - 16) = 0;
                  *(void *)(v56 - 8) = 0;
                  *(void *)(v56 - 24) = 0;
                  *(_OWORD *)(v56 - 24) = *(_OWORD *)(v54.i64[1] + v55 - 24);
                  *(void *)(v56 - 8) = *(void *)(v54.i64[1] + v55 - 8);
                  *(void *)(v57 - 24) = 0;
                  *(void *)(v57 - 16) = 0;
                  *(void *)(v57 - 8) = 0;
                  v55 -= 56;
                }
                while (v54.i64[1] + v55 != v54.i64[0]);
                int64x2_t v59 = v137;
                uint64_t v48 = *(void *)&v109[1];
                v53 += v55;
              }
              v137.i64[0] = v53;
              v137.i64[1] = v48;
              *(int64x2_t *)((char *)v109 + 8) = v59;
              unint64_t v60 = v138;
              unint64_t v138 = *((void *)&v109[1] + 1);
              *((void *)&v109[1] + 1) = v60;
              *(void *)&v109[0] = v59.i64[0];
              sub_100B06884((uint64_t)v109);
            }
            else
            {
              sub_100B06600((void *)v137.i64[1], (long long *)v134);
              uint64_t v48 = v47 + 56;
            }
            v137.i64[1] = v48;
          }
          *(void *)&v109[0] = &v135;
          sub_100B067B8((void ***)v109);
          if ((v134[23] & 0x80000000) != 0) {
            operator delete(*(void **)v134);
          }
        }
      }
      unsigned int v61 = (char *)*((void *)v2 + 1);
      if (v61)
      {
        do
        {
          uint64_t v62 = v61;
          unsigned int v61 = *(char **)v61;
        }
        while (v61);
      }
      else
      {
        do
        {
          uint64_t v62 = (char *)*((void *)v2 + 2);
          BOOL v27 = *(void *)v62 == (void)v2;
          uint64_t v2 = v62;
        }
        while (!v27);
      }
      uint64_t v2 = v62;
    }
    while (v62 != v3);
  }
  char v63 = (void **)((char *)v1 + 4752);
  uint64_t v64 = (char *)v1 + 4776;
  if (!*((unsigned char *)v1 + 4776)) {
    goto LABEL_185;
  }
  uint64_t v65 = v137.i64[1];
  uint64_t v66 = v137.i64[0];
  uint64_t v67 = *((void *)v1 + 594);
  if (v137.i64[1] - v137.i64[0] != *((void *)v1 + 595) - v67) {
    goto LABEL_170;
  }
LABEL_117:
  if (v66 != v65)
  {
    uint64_t v68 = *(unsigned __int8 *)(v66 + 23);
    if ((v68 & 0x80u) == 0) {
      uint64_t v69 = *(unsigned __int8 *)(v66 + 23);
    }
    else {
      uint64_t v69 = *(void *)(v66 + 8);
    }
    uint64_t v70 = *(unsigned __int8 *)(v67 + 23);
    int v71 = (char)v70;
    if ((v70 & 0x80u) != 0) {
      uint64_t v70 = *(void *)(v67 + 8);
    }
    if (v69 == v70)
    {
      int v72 = v71 >= 0 ? (unsigned __int8 *)v67 : *(unsigned __int8 **)v67;
      if ((v68 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v66, v72, *(void *)(v66 + 8))) {
          goto LABEL_170;
        }
      }
      else if (*(unsigned char *)(v66 + 23))
      {
        uint64_t v73 = 0;
        do
        {
          if (*(unsigned __int8 *)(v66 + v73) != v72[v73]) {
            goto LABEL_170;
          }
          ++v73;
        }
        while (v68 != v73);
      }
      if (*(unsigned __int8 *)(v66 + 24) == *(unsigned __int8 *)(v67 + 24))
      {
        uint64_t v74 = *(void *)(v66 + 32);
        uint64_t v105 = *(void *)(v66 + 40);
        unsigned int v75 = *(unsigned __int8 ***)(v67 + 32);
        if (v105 - v74 == *(void *)(v67 + 40) - (void)v75)
        {
          while (1)
          {
            if (v74 == v105)
            {
              v66 += 56;
              v67 += 56;
              goto LABEL_117;
            }
            uint64_t v76 = *(unsigned __int8 *)(v74 + 23);
            if ((v76 & 0x80u) == 0) {
              uint64_t v77 = (unsigned __int8 *)*(unsigned __int8 *)(v74 + 23);
            }
            else {
              uint64_t v77 = *(unsigned __int8 **)(v74 + 8);
            }
            unint64_t v78 = (unsigned __int8 *)*((unsigned __int8 *)v75 + 23);
            int v79 = (char)v78;
            if ((char)v78 < 0) {
              unint64_t v78 = v75[1];
            }
            if (v77 != v78) {
              break;
            }
            if (v79 >= 0) {
              uint64_t v80 = (unsigned __int8 *)v75;
            }
            else {
              uint64_t v80 = *v75;
            }
            if ((v76 & 0x80) != 0)
            {
              if (memcmp(*(const void **)v74, v80, *(void *)(v74 + 8))) {
                break;
              }
            }
            else if (*(unsigned char *)(v74 + 23))
            {
              uint64_t v81 = 0;
              while (*(unsigned __int8 *)(v74 + v81) == v80[v81])
              {
                if (v76 == ++v81) {
                  goto LABEL_153;
                }
              }
              break;
            }
LABEL_153:
            if (*(unsigned __int8 **)(v74 + 40) != v75[5]) {
              break;
            }
            long long v82 = *(void **)(v74 + 24);
            if (v82 != (void *)(v74 + 32))
            {
              long long v83 = v75[3];
              while (TrafficDescriptor::operator==())
              {
                long long v84 = (void *)v82[1];
                uint64_t v85 = v82;
                if (v84)
                {
                  do
                  {
                    long long v82 = v84;
                    long long v84 = (void *)*v84;
                  }
                  while (v84);
                }
                else
                {
                  do
                  {
                    long long v82 = (void *)v85[2];
                    BOOL v27 = *v82 == (void)v85;
                    uint64_t v85 = v82;
                  }
                  while (!v27);
                }
                std::string::size_type v86 = (unsigned __int8 *)*((void *)v83 + 1);
                if (v86)
                {
                  do
                  {
                    uint64_t v87 = v86;
                    std::string::size_type v86 = *(unsigned __int8 **)v86;
                  }
                  while (v86);
                }
                else
                {
                  do
                  {
                    uint64_t v87 = (unsigned __int8 *)*((void *)v83 + 2);
                    BOOL v27 = *(void *)v87 == (void)v83;
                    long long v83 = v87;
                  }
                  while (!v27);
                }
                long long v83 = v87;
                if (v82 == (void *)(v74 + 32)) {
                  goto LABEL_168;
                }
              }
              break;
            }
LABEL_168:
            v74 += 48;
            v75 += 6;
          }
        }
      }
    }
LABEL_170:
    uint64_t v1 = this;
    if (*v64)
    {
      if (v63 != (void **)&v137)
      {
        int64x2_t v88 = v137;
        unint64_t v89 = 0x6DB6DB6DB6DB6DB7 * ((v137.i64[1] - v137.i64[0]) >> 3);
        uint64_t v90 = *((void *)this + 596);
        uint64_t v91 = *((void *)this + 594);
        if (0x6DB6DB6DB6DB6DB7 * ((v90 - v91) >> 3) >= v89)
        {
          if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 595) - v91) >> 3) >= v89)
          {
            uint64_t v100 = sub_100B069AC((std::string *)v137.i64[0], (std::string *)v137.i64[1], *((std::string **)this + 594));
            uint64_t v1 = this;
            for (uint64_t i = *((void *)this + 595); (std::string *)i != v100; sub_100B0683C(i))
              i -= 56;
            *((void *)this + 595) = v100;
            goto LABEL_195;
          }
          uint32_t v99 = (std::string *)(v137.i64[0] + 8 * ((*((void *)this + 595) - v91) >> 3));
          sub_100B069AC((std::string *)v137.i64[0], v99, *((std::string **)this + 594));
          uint64_t v1 = this;
          uint64_t v97 = sub_100B06928((uint64_t)v99, v88.i64[1], *((void *)this + 595));
        }
        else
        {
          if (v91)
          {
            uint64_t v92 = *((void *)this + 595);
            int v93 = (void *)*((void *)this + 594);
            if (v92 != v91)
            {
              do
              {
                v92 -= 56;
                sub_100B0683C(v92);
              }
              while (v92 != v91);
              int v93 = *v63;
            }
            *((void *)this + 595) = v91;
            operator delete(v93);
            uint64_t v90 = 0;
            std::__shared_weak_count *v63 = 0;
            v63[1] = 0;
            v63[2] = 0;
          }
          if (v89 > 0x492492492492492) {
            sub_10006A748();
          }
          unint64_t v94 = 0x6DB6DB6DB6DB6DB7 * (v90 >> 3);
          uint64_t v95 = 2 * v94;
          if (2 * v94 <= v89) {
            uint64_t v95 = 0x6DB6DB6DB6DB6DB7 * ((v88.i64[1] - v88.i64[0]) >> 3);
          }
          if (v94 >= 0x249249249249249) {
            unint64_t v96 = 0x492492492492492;
          }
          else {
            unint64_t v96 = v95;
          }
          sub_100B068D4(v63, v96);
          uint64_t v1 = this;
          uint64_t v97 = sub_100B06928(v88.i64[0], v88.i64[1], *((void *)this + 595));
        }
        *((void *)v1 + 595) = v97;
      }
LABEL_195:
      (*(void (**)(void, int64x2_t *))(**((void **)v1 + 530) + 144))(*((void *)v1 + 530), &v137);
      goto LABEL_196;
    }
LABEL_185:
    std::__shared_weak_count *v63 = 0;
    v63[1] = 0;
    v63[2] = 0;
    int64x2_t v98 = v137;
    *(void *)&v109[0] = v63;
    if (v137.i64[1] != v137.i64[0])
    {
      *((void *)&v109[0] + 1) = 0;
      sub_100B068D4(v63, 0x6DB6DB6DB6DB6DB7 * ((v137.i64[1] - v137.i64[0]) >> 3));
      *((void *)v1 + 595) = sub_100B06928(v98.i64[0], v98.i64[1], *((void *)v1 + 595));
    }
    unsigned char *v64 = 1;
    goto LABEL_195;
  }
LABEL_196:
  *(void *)&v109[0] = &v137;
  sub_100B06C10((void ***)v109);
}